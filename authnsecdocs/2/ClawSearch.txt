Directory structure:
└── codecat-clawsearch/
    ├── Readme.md
    ├── ClawSearch.sln
    ├── License.txt
    ├── ClawSearch/
    │   ├── ClawSearch.vcxproj
    │   ├── ClawSearch.vcxproj.filters
    │   ├── Common.h
    │   ├── Scratch.cpp
    │   ├── SearchResult.h
    │   ├── csMain.cpp
    │   ├── csMain.h
    │   ├── csMath.h
    │   ├── csScanner.cpp
    │   ├── csScanner.h
    │   ├── plugin.cpp
    │   ├── plugin.h
    │   ├── pluginmain.cpp
    │   ├── pluginmain.h
    │   ├── pluginsdk/
    │   │   ├── _dbgfunctions.h
    │   │   ├── _plugin_types.h
    │   │   ├── _plugins.h
    │   │   ├── _scriptapi.h
    │   │   ├── _scriptapi_argument.h
    │   │   ├── _scriptapi_assembler.h
    │   │   ├── _scriptapi_bookmark.h
    │   │   ├── _scriptapi_comment.h
    │   │   ├── _scriptapi_debug.h
    │   │   ├── _scriptapi_flag.h
    │   │   ├── _scriptapi_function.h
    │   │   ├── _scriptapi_gui.h
    │   │   ├── _scriptapi_label.h
    │   │   ├── _scriptapi_memory.h
    │   │   ├── _scriptapi_misc.h
    │   │   ├── _scriptapi_module.h
    │   │   ├── _scriptapi_pattern.h
    │   │   ├── _scriptapi_register.h
    │   │   ├── _scriptapi_stack.h
    │   │   ├── _scriptapi_symbol.h
    │   │   ├── bridgegraph.h
    │   │   ├── bridgelist.h
    │   │   ├── bridgemain.h
    │   │   ├── DeviceNameResolver/
    │   │   │   └── DeviceNameResolver.h
    │   │   ├── TitanEngine/
    │   │   │   └── TitanEngine.h
    │   │   ├── XEDParse/
    │   │   │   └── XEDParse.h
    │   │   ├── dbghelp/
    │   │   │   └── dbghelp.h
    │   │   ├── jansson/
    │   │   │   ├── jansson.h
    │   │   │   ├── jansson_config.h
    │   │   │   └── jansson_x64dbg.h
    │   │   └── lz4/
    │   │       ├── lz4.h
    │   │       ├── lz4file.h
    │   │       └── lz4hc.h
    │   └── scratch2/
    │       ├── s2list.h
    │       └── s2string.h
    ├── cd/
    │   └── include/
    │       ├── cd.h
    │       ├── cd_canvas.hpp
    │       ├── cd_old.h
    │       ├── cd_plus.h
    │       ├── cd_private.h
    │       ├── cdcairo.h
    │       ├── cdcgm.h
    │       ├── cdclipbd.h
    │       ├── cddbuf.h
    │       ├── cddebug.h
    │       ├── cddgn.h
    │       ├── cddxf.h
    │       ├── cdemf.h
    │       ├── cdgdiplus.h
    │       ├── cdgl.h
    │       ├── cdim.h
    │       ├── cdimage.h
    │       ├── cdirgb.h
    │       ├── cdiup.h
    │       ├── cdlua.h
    │       ├── cdlua3_private.h
    │       ├── cdlua5_private.h
    │       ├── cdluagl.h
    │       ├── cdluaim.h
    │       ├── cdluaiup.h
    │       ├── cdluapdf.h
    │       ├── cdmf.h
    │       ├── cdmf_private.h
    │       ├── cdnative.h
    │       ├── cdpdf.h
    │       ├── cdpicture.h
    │       ├── cdpptx.h
    │       ├── cdprint.h
    │       ├── cdps.h
    │       ├── cdsvg.h
    │       ├── cdwmf.h
    │       ├── wd.h
    │       └── wd_old.h
    ├── iup/
    │   ├── etc/
    │   │   ├── iup.manifest
    │   │   ├── iup.rc
    │   │   ├── iup64.manifest
    │   │   ├── iupstub.c
    │   │   └── pen.cur
    │   └── include/
    │       ├── iup.h
    │       ├── iup_class_cbs.hpp
    │       ├── iup_config.h
    │       ├── iup_mglplot.h
    │       ├── iup_plot.h
    │       ├── iup_plus.h
    │       ├── iup_scintilla.h
    │       ├── iupcbs.h
    │       ├── iupcontrols.h
    │       ├── iupdef.h
    │       ├── iupdraw.h
    │       ├── iupgl.h
    │       ├── iupglcontrols.h
    │       ├── iupim.h
    │       ├── iupkey.h
    │       ├── iuplua.h
    │       ├── iuplua_mglplot.h
    │       ├── iuplua_plot.h
    │       ├── iuplua_scintilla.h
    │       ├── iupluacontrols.h
    │       ├── iupluagl.h
    │       ├── iupluaglcontrols.h
    │       ├── iupluaim.h
    │       ├── iupluamatrixex.h
    │       ├── iupluaole.h
    │       ├── iupluatuio.h
    │       ├── iupluaweb.h
    │       ├── iupmatrixex.h
    │       ├── iupole.h
    │       ├── iuptuio.h
    │       └── iupweb.h
    └── .github/
        ├── FUNDING.yml
        └── workflows/
            └── build.yml

================================================
File: Readme.md
================================================
# ClawSearch

A memory scanner plugin for x64dbg, inspired by Cheat Engine.

![](Screenshot.png)



================================================
File: ClawSearch.sln
================================================
ï»¿
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 14
VisualStudioVersion = 14.0.24720.0
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ClawSearch", "ClawSearch\ClawSearch.vcxproj", "{176822C9-3CF8-41A9-81AB-8BBD3E3E2A32}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{176822C9-3CF8-41A9-81AB-8BBD3E3E2A32}.Debug|x64.ActiveCfg = Debug|x64
		{176822C9-3CF8-41A9-81AB-8BBD3E3E2A32}.Debug|x64.Build.0 = Debug|x64
		{176822C9-3CF8-41A9-81AB-8BBD3E3E2A32}.Debug|x86.ActiveCfg = Debug|Win32
		{176822C9-3CF8-41A9-81AB-8BBD3E3E2A32}.Debug|x86.Build.0 = Debug|Win32
		{176822C9-3CF8-41A9-81AB-8BBD3E3E2A32}.Release|x64.ActiveCfg = Release|x64
		{176822C9-3CF8-41A9-81AB-8BBD3E3E2A32}.Release|x64.Build.0 = Release|x64
		{176822C9-3CF8-41A9-81AB-8BBD3E3E2A32}.Release|x86.ActiveCfg = Release|Win32
		{176822C9-3CF8-41A9-81AB-8BBD3E3E2A32}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal



================================================
File: License.txt
================================================
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS



================================================
File: ClawSearch/ClawSearch.vcxproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{176822C9-3CF8-41A9-81AB-8BBD3E3E2A32}</ProjectGuid>
    <RootNamespace>ClawSearch</RootNamespace>
    <ProjectName>ClawSearch</ProjectName>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
    <PlatformToolset>v142</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <TargetExt>.dp32</TargetExt>
    <IncludePath>$(SolutionDir)iup\include;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <TargetExt>.dp32</TargetExt>
    <IncludePath>$(SolutionDir)iup\include;$(IncludePath)</IncludePath>
    <LibraryPath>$(SolutionDir)iup\;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <TargetExt>.dp64</TargetExt>
    <IncludePath>$(SolutionDir)iup\include;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <TargetExt>.dp64</TargetExt>
    <IncludePath>$(SolutionDir)iup\include;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <DisableSpecificWarnings>4091</DisableSpecificWarnings>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <SubSystem>Windows</SubSystem>
      <IgnoreSpecificDefaultLibraries>
      </IgnoreSpecificDefaultLibraries>
      <AdditionalDependencies>comctl32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <InlineFunctionExpansion>Disabled</InlineFunctionExpansion>
      <WholeProgramOptimization>false</WholeProgramOptimization>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <DisableSpecificWarnings>4091</DisableSpecificWarnings>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <SubSystem>Windows</SubSystem>
      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
      <AdditionalDependencies>comctl32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <DisableSpecificWarnings>4091</DisableSpecificWarnings>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <SubSystem>Windows</SubSystem>
      <AdditionalDependencies>comctl32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <IgnoreSpecificDefaultLibraries>
      </IgnoreSpecificDefaultLibraries>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <InlineFunctionExpansion>Disabled</InlineFunctionExpansion>
      <WholeProgramOptimization>false</WholeProgramOptimization>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <DisableSpecificWarnings>4091</DisableSpecificWarnings>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <SubSystem>Windows</SubSystem>
      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>
      <AdditionalDependencies>comctl32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="csMain.cpp" />
    <ClCompile Include="csScanner.cpp" />
    <ClCompile Include="plugin.cpp" />
    <ClCompile Include="pluginmain.cpp" />
    <ClCompile Include="Scratch.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\cd\include\cd.h" />
    <ClInclude Include="..\cd\include\cdcairo.h" />
    <ClInclude Include="..\cd\include\cdcgm.h" />
    <ClInclude Include="..\cd\include\cdclipbd.h" />
    <ClInclude Include="..\cd\include\cddbuf.h" />
    <ClInclude Include="..\cd\include\cddebug.h" />
    <ClInclude Include="..\cd\include\cddgn.h" />
    <ClInclude Include="..\cd\include\cddxf.h" />
    <ClInclude Include="..\cd\include\cdemf.h" />
    <ClInclude Include="..\cd\include\cdgdiplus.h" />
    <ClInclude Include="..\cd\include\cdgl.h" />
    <ClInclude Include="..\cd\include\cdim.h" />
    <ClInclude Include="..\cd\include\cdimage.h" />
    <ClInclude Include="..\cd\include\cdirgb.h" />
    <ClInclude Include="..\cd\include\cdiup.h" />
    <ClInclude Include="..\cd\include\cdlua.h" />
    <ClInclude Include="..\cd\include\cdlua3_private.h" />
    <ClInclude Include="..\cd\include\cdlua5_private.h" />
    <ClInclude Include="..\cd\include\cdluagl.h" />
    <ClInclude Include="..\cd\include\cdluaim.h" />
    <ClInclude Include="..\cd\include\cdluaiup.h" />
    <ClInclude Include="..\cd\include\cdluapdf.h" />
    <ClInclude Include="..\cd\include\cdmf.h" />
    <ClInclude Include="..\cd\include\cdmf_private.h" />
    <ClInclude Include="..\cd\include\cdnative.h" />
    <ClInclude Include="..\cd\include\cdpdf.h" />
    <ClInclude Include="..\cd\include\cdpicture.h" />
    <ClInclude Include="..\cd\include\cdpptx.h" />
    <ClInclude Include="..\cd\include\cdprint.h" />
    <ClInclude Include="..\cd\include\cdps.h" />
    <ClInclude Include="..\cd\include\cdsvg.h" />
    <ClInclude Include="..\cd\include\cdwmf.h" />
    <ClInclude Include="..\cd\include\cd_canvas.hpp" />
    <ClInclude Include="..\cd\include\cd_old.h" />
    <ClInclude Include="..\cd\include\cd_plus.h" />
    <ClInclude Include="..\cd\include\cd_private.h" />
    <ClInclude Include="..\cd\include\wd.h" />
    <ClInclude Include="..\cd\include\wd_old.h" />
    <ClInclude Include="..\iup\include\iup.h" />
    <ClInclude Include="..\iup\include\iupcbs.h" />
    <ClInclude Include="..\iup\include\iupcontrols.h" />
    <ClInclude Include="..\iup\include\iupdef.h" />
    <ClInclude Include="..\iup\include\iupdraw.h" />
    <ClInclude Include="..\iup\include\iupgl.h" />
    <ClInclude Include="..\iup\include\iupglcontrols.h" />
    <ClInclude Include="..\iup\include\iupim.h" />
    <ClInclude Include="..\iup\include\iupkey.h" />
    <ClInclude Include="..\iup\include\iuplua.h" />
    <ClInclude Include="..\iup\include\iupluacontrols.h" />
    <ClInclude Include="..\iup\include\iupluagl.h" />
    <ClInclude Include="..\iup\include\iupluaglcontrols.h" />
    <ClInclude Include="..\iup\include\iupluaim.h" />
    <ClInclude Include="..\iup\include\iupluamatrixex.h" />
    <ClInclude Include="..\iup\include\iupluaole.h" />
    <ClInclude Include="..\iup\include\iupluatuio.h" />
    <ClInclude Include="..\iup\include\iupluaweb.h" />
    <ClInclude Include="..\iup\include\iuplua_mglplot.h" />
    <ClInclude Include="..\iup\include\iuplua_plot.h" />
    <ClInclude Include="..\iup\include\iuplua_scintilla.h" />
    <ClInclude Include="..\iup\include\iupmatrixex.h" />
    <ClInclude Include="..\iup\include\iupole.h" />
    <ClInclude Include="..\iup\include\iuptuio.h" />
    <ClInclude Include="..\iup\include\iupweb.h" />
    <ClInclude Include="..\iup\include\iup_class_cbs.hpp" />
    <ClInclude Include="..\iup\include\iup_config.h" />
    <ClInclude Include="..\iup\include\iup_mglplot.h" />
    <ClInclude Include="..\iup\include\iup_plot.h" />
    <ClInclude Include="..\iup\include\iup_plus.h" />
    <ClInclude Include="..\iup\include\iup_scintilla.h" />
    <ClInclude Include="Common.h" />
    <ClInclude Include="csMain.h" />
    <ClInclude Include="csMath.h" />
    <ClInclude Include="csScanner.h" />
    <ClInclude Include="plugin.h" />
    <ClInclude Include="pluginmain.h" />
    <ClInclude Include="pluginsdk\bridgegraph.h" />
    <ClInclude Include="pluginsdk\bridgelist.h" />
    <ClInclude Include="pluginsdk\bridgemain.h" />
    <ClInclude Include="pluginsdk\dbghelp\dbghelp.h" />
    <ClInclude Include="pluginsdk\DeviceNameResolver\DeviceNameResolver.h" />
    <ClInclude Include="pluginsdk\jansson\jansson.h" />
    <ClInclude Include="pluginsdk\jansson\jansson_config.h" />
    <ClInclude Include="pluginsdk\jansson\jansson_x64dbg.h" />
    <ClInclude Include="pluginsdk\lz4\lz4.h" />
    <ClInclude Include="pluginsdk\lz4\lz4file.h" />
    <ClInclude Include="pluginsdk\lz4\lz4hc.h" />
    <ClInclude Include="pluginsdk\TitanEngine\TitanEngine.h" />
    <ClInclude Include="pluginsdk\XEDParse\XEDParse.h" />
    <ClInclude Include="pluginsdk\_dbgfunctions.h" />
    <ClInclude Include="pluginsdk\_plugins.h" />
    <ClInclude Include="pluginsdk\_plugin_types.h" />
    <ClInclude Include="pluginsdk\_scriptapi.h" />
    <ClInclude Include="pluginsdk\_scriptapi_argument.h" />
    <ClInclude Include="pluginsdk\_scriptapi_assembler.h" />
    <ClInclude Include="pluginsdk\_scriptapi_bookmark.h" />
    <ClInclude Include="pluginsdk\_scriptapi_comment.h" />
    <ClInclude Include="pluginsdk\_scriptapi_debug.h" />
    <ClInclude Include="pluginsdk\_scriptapi_flag.h" />
    <ClInclude Include="pluginsdk\_scriptapi_function.h" />
    <ClInclude Include="pluginsdk\_scriptapi_gui.h" />
    <ClInclude Include="pluginsdk\_scriptapi_label.h" />
    <ClInclude Include="pluginsdk\_scriptapi_memory.h" />
    <ClInclude Include="pluginsdk\_scriptapi_misc.h" />
    <ClInclude Include="pluginsdk\_scriptapi_module.h" />
    <ClInclude Include="pluginsdk\_scriptapi_pattern.h" />
    <ClInclude Include="pluginsdk\_scriptapi_register.h" />
    <ClInclude Include="pluginsdk\_scriptapi_stack.h" />
    <ClInclude Include="pluginsdk\_scriptapi_symbol.h" />
    <ClInclude Include="SearchResult.h" />
  </ItemGroup>
  <ItemGroup>
    <Library Include="..\cd\cd.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </Library>
    <Library Include="..\cd\cdcontextplus.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </Library>
    <Library Include="..\cd\cdcontextplus_x64.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
    </Library>
    <Library Include="..\cd\cdim.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </Library>
    <Library Include="..\cd\cdim_x64.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
    </Library>
    <Library Include="..\cd\cd_x64.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
    </Library>
    <Library Include="..\iup\freetype6.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </Library>
    <Library Include="..\iup\freetype6_x64.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
    </Library>
    <Library Include="..\iup\iup.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </Library>
    <Library Include="..\iup\iupcd.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </Library>
    <Library Include="..\iup\iupcd_x64.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
    </Library>
    <Library Include="..\iup\iupcontrols.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </Library>
    <Library Include="..\iup\iupcontrols_x64.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
    </Library>
    <Library Include="..\iup\iupim.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </Library>
    <Library Include="..\iup\iupimglib.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </Library>
    <Library Include="..\iup\iupimglib_x64.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
    </Library>
    <Library Include="..\iup\iupim_x64.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
    </Library>
    <Library Include="..\iup\iup_x64.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
    </Library>
    <Library Include="..\iup\zlib1.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </Library>
    <Library Include="..\iup\zlib1_x64.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
    </Library>
    <Library Include="pluginsdk\DeviceNameResolver\DeviceNameResolver_x64.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</ExcludedFromBuild>
    </Library>
    <Library Include="pluginsdk\DeviceNameResolver\DeviceNameResolver_x86.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
    </Library>
    <Library Include="pluginsdk\jansson\jansson_x64.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</ExcludedFromBuild>
    </Library>
    <Library Include="pluginsdk\jansson\jansson_x86.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
    </Library>
    <Library Include="pluginsdk\lz4\lz4_x64.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</ExcludedFromBuild>
    </Library>
    <Library Include="pluginsdk\lz4\lz4_x86.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
    </Library>
    <Library Include="pluginsdk\TitanEngine\TitanEngine_x64.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</ExcludedFromBuild>
    </Library>
    <Library Include="pluginsdk\TitanEngine\TitanEngine_x86.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
    </Library>
    <Library Include="pluginsdk\x32bridge.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
    </Library>
    <Library Include="pluginsdk\x32dbg.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
    </Library>
    <Library Include="pluginsdk\x64bridge.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</ExcludedFromBuild>
    </Library>
    <Library Include="pluginsdk\x64dbg.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</ExcludedFromBuild>
    </Library>
    <Library Include="pluginsdk\XEDParse\XEDParse_x64.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</ExcludedFromBuild>
    </Library>
    <Library Include="pluginsdk\XEDParse\XEDParse_x86.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
    </Library>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>


================================================
File: ClawSearch/ClawSearch.vcxproj.filters
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Header Files\pluginsdk">
      <UniqueIdentifier>{e26abb2c-05ce-4474-aa6b-0d6f0bc27926}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\pluginsdk\dbghelp">
      <UniqueIdentifier>{c87c3d42-364d-4fe6-9ab3-8f7e8352af43}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\pluginsdk\jansson">
      <UniqueIdentifier>{b1cd7fb9-d2e4-448a-bf04-4f11115651f2}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\pluginsdk\lz4">
      <UniqueIdentifier>{c50e39c1-5972-409e-a5f3-904860f1a661}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\pluginsdk\TitanEngine">
      <UniqueIdentifier>{831de1fc-1ccd-427d-a848-f62169b3743e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\pluginsdk\XEDParse">
      <UniqueIdentifier>{ffcdd30c-5e60-4075-95bf-ea1ca7aad310}</UniqueIdentifier>
    </Filter>
    <Filter Include="Library Files">
      <UniqueIdentifier>{83b94fba-0963-43a4-b8bd-12730a208fad}</UniqueIdentifier>
    </Filter>
    <Filter Include="Library Files\iup">
      <UniqueIdentifier>{85ea7a07-60e1-4e05-9447-b1d29c07ea08}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\iup">
      <UniqueIdentifier>{08041497-59d7-45cc-812d-2fe0b0851086}</UniqueIdentifier>
    </Filter>
    <Filter Include="Library Files\cd">
      <UniqueIdentifier>{c4ab402c-b055-4460-b96a-c700ed3b4e76}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\cd">
      <UniqueIdentifier>{e37a3db0-b7e1-48cc-a71d-c7b1639633ba}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\pluginsdk\dbghelp\DeviceNameResolver">
      <UniqueIdentifier>{17a1513c-2d16-432c-a7ec-8e31e09ebfbf}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="pluginsdk\dbghelp\dbghelp.h">
      <Filter>Header Files\pluginsdk\dbghelp</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\DeviceNameResolver\DeviceNameResolver.h">
      <Filter>Header Files\pluginsdk\dbghelp\DeviceNameResolver</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\jansson\jansson.h">
      <Filter>Header Files\pluginsdk\jansson</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\jansson\jansson_config.h">
      <Filter>Header Files\pluginsdk\jansson</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\jansson\jansson_x64dbg.h">
      <Filter>Header Files\pluginsdk\jansson</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\lz4\lz4.h">
      <Filter>Header Files\pluginsdk\lz4</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\lz4\lz4file.h">
      <Filter>Header Files\pluginsdk\lz4</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\lz4\lz4hc.h">
      <Filter>Header Files\pluginsdk\lz4</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\XEDParse\XEDParse.h">
      <Filter>Header Files\pluginsdk\XEDParse</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\TitanEngine\TitanEngine.h">
      <Filter>Header Files\pluginsdk\TitanEngine</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_dbgfunctions.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_plugin_types.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_plugins.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_argument.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_assembler.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_bookmark.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_comment.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_debug.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_flag.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_function.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_gui.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_label.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_memory.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_misc.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_module.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_pattern.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_register.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_stack.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_symbol.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\bridgegraph.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\bridgelist.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\bridgemain.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="plugin.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="pluginmain.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\iup\include\iupglcontrols.h">
      <Filter>Header Files\iup</Filter>
    </ClInclude>
    <ClInclude Include="..\iup\include\iupim.h">
      <Filter>Header Files\iup</Filter>
    </ClInclude>
    <ClInclude Include="..\iup\include\iupkey.h">
      <Filter>Header Files\iup</Filter>
    </ClInclude>
    <ClInclude Include="..\iup\include\iuplua.h">
      <Filter>Header Files\iup</Filter>
    </ClInclude>
    <ClInclude Include="..\iup\include\iuplua_mglplot.h">
      <Filter>Header Files\iup</Filter>
    </ClInclude>
    <ClInclude Include="..\iup\include\iuplua_plot.h">
      <Filter>Header Files\iup</Filter>
    </ClInclude>
    <ClInclude Include="..\iup\include\iuplua_scintilla.h">
      <Filter>Header Files\iup</Filter>
    </ClInclude>
    <ClInclude Include="..\iup\include\iupluacontrols.h">
      <Filter>Header Files\iup</Filter>
    </ClInclude>
    <ClInclude Include="..\iup\include\iupluagl.h">
      <Filter>Header Files\iup</Filter>
    </ClInclude>
    <ClInclude Include="..\iup\include\iupluaglcontrols.h">
      <Filter>Header Files\iup</Filter>
    </ClInclude>
    <ClInclude Include="..\iup\include\iupluaim.h">
      <Filter>Header Files\iup</Filter>
    </ClInclude>
    <ClInclude Include="..\iup\include\iupluamatrixex.h">
      <Filter>Header Files\iup</Filter>
    </ClInclude>
    <ClInclude Include="..\iup\include\iupluaole.h">
      <Filter>Header Files\iup</Filter>
    </ClInclude>
    <ClInclude Include="..\iup\include\iupluatuio.h">
      <Filter>Header Files\iup</Filter>
    </ClInclude>
    <ClInclude Include="..\iup\include\iupluaweb.h">
      <Filter>Header Files\iup</Filter>
    </ClInclude>
    <ClInclude Include="..\iup\include\iupmatrixex.h">
      <Filter>Header Files\iup</Filter>
    </ClInclude>
    <ClInclude Include="..\iup\include\iupole.h">
      <Filter>Header Files\iup</Filter>
    </ClInclude>
    <ClInclude Include="..\iup\include\iuptuio.h">
      <Filter>Header Files\iup</Filter>
    </ClInclude>
    <ClInclude Include="..\iup\include\iupweb.h">
      <Filter>Header Files\iup</Filter>
    </ClInclude>
    <ClInclude Include="..\iup\include\iup.h">
      <Filter>Header Files\iup</Filter>
    </ClInclude>
    <ClInclude Include="..\iup\include\iup_class_cbs.hpp">
      <Filter>Header Files\iup</Filter>
    </ClInclude>
    <ClInclude Include="..\iup\include\iup_config.h">
      <Filter>Header Files\iup</Filter>
    </ClInclude>
    <ClInclude Include="..\iup\include\iup_mglplot.h">
      <Filter>Header Files\iup</Filter>
    </ClInclude>
    <ClInclude Include="..\iup\include\iup_plot.h">
      <Filter>Header Files\iup</Filter>
    </ClInclude>
    <ClInclude Include="..\iup\include\iup_plus.h">
      <Filter>Header Files\iup</Filter>
    </ClInclude>
    <ClInclude Include="..\iup\include\iup_scintilla.h">
      <Filter>Header Files\iup</Filter>
    </ClInclude>
    <ClInclude Include="..\iup\include\iupcbs.h">
      <Filter>Header Files\iup</Filter>
    </ClInclude>
    <ClInclude Include="..\iup\include\iupcontrols.h">
      <Filter>Header Files\iup</Filter>
    </ClInclude>
    <ClInclude Include="..\iup\include\iupdef.h">
      <Filter>Header Files\iup</Filter>
    </ClInclude>
    <ClInclude Include="..\iup\include\iupdraw.h">
      <Filter>Header Files\iup</Filter>
    </ClInclude>
    <ClInclude Include="..\iup\include\iupgl.h">
      <Filter>Header Files\iup</Filter>
    </ClInclude>
    <ClInclude Include="csMain.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\cd\include\cddgn.h">
      <Filter>Header Files\cd</Filter>
    </ClInclude>
    <ClInclude Include="..\cd\include\cddxf.h">
      <Filter>Header Files\cd</Filter>
    </ClInclude>
    <ClInclude Include="..\cd\include\cdemf.h">
      <Filter>Header Files\cd</Filter>
    </ClInclude>
    <ClInclude Include="..\cd\include\cdgdiplus.h">
      <Filter>Header Files\cd</Filter>
    </ClInclude>
    <ClInclude Include="..\cd\include\cdgl.h">
      <Filter>Header Files\cd</Filter>
    </ClInclude>
    <ClInclude Include="..\cd\include\cdim.h">
      <Filter>Header Files\cd</Filter>
    </ClInclude>
    <ClInclude Include="..\cd\include\cdimage.h">
      <Filter>Header Files\cd</Filter>
    </ClInclude>
    <ClInclude Include="..\cd\include\cdirgb.h">
      <Filter>Header Files\cd</Filter>
    </ClInclude>
    <ClInclude Include="..\cd\include\cdiup.h">
      <Filter>Header Files\cd</Filter>
    </ClInclude>
    <ClInclude Include="..\cd\include\cdlua.h">
      <Filter>Header Files\cd</Filter>
    </ClInclude>
    <ClInclude Include="..\cd\include\cdlua3_private.h">
      <Filter>Header Files\cd</Filter>
    </ClInclude>
    <ClInclude Include="..\cd\include\cdlua5_private.h">
      <Filter>Header Files\cd</Filter>
    </ClInclude>
    <ClInclude Include="..\cd\include\cdluagl.h">
      <Filter>Header Files\cd</Filter>
    </ClInclude>
    <ClInclude Include="..\cd\include\cdluaim.h">
      <Filter>Header Files\cd</Filter>
    </ClInclude>
    <ClInclude Include="..\cd\include\cdluaiup.h">
      <Filter>Header Files\cd</Filter>
    </ClInclude>
    <ClInclude Include="..\cd\include\cdluapdf.h">
      <Filter>Header Files\cd</Filter>
    </ClInclude>
    <ClInclude Include="..\cd\include\cdmf.h">
      <Filter>Header Files\cd</Filter>
    </ClInclude>
    <ClInclude Include="..\cd\include\cdmf_private.h">
      <Filter>Header Files\cd</Filter>
    </ClInclude>
    <ClInclude Include="..\cd\include\cdnative.h">
      <Filter>Header Files\cd</Filter>
    </ClInclude>
    <ClInclude Include="..\cd\include\cdpdf.h">
      <Filter>Header Files\cd</Filter>
    </ClInclude>
    <ClInclude Include="..\cd\include\cdpicture.h">
      <Filter>Header Files\cd</Filter>
    </ClInclude>
    <ClInclude Include="..\cd\include\cdpptx.h">
      <Filter>Header Files\cd</Filter>
    </ClInclude>
    <ClInclude Include="..\cd\include\cdprint.h">
      <Filter>Header Files\cd</Filter>
    </ClInclude>
    <ClInclude Include="..\cd\include\cdps.h">
      <Filter>Header Files\cd</Filter>
    </ClInclude>
    <ClInclude Include="..\cd\include\cdsvg.h">
      <Filter>Header Files\cd</Filter>
    </ClInclude>
    <ClInclude Include="..\cd\include\cdwmf.h">
      <Filter>Header Files\cd</Filter>
    </ClInclude>
    <ClInclude Include="..\cd\include\wd.h">
      <Filter>Header Files\cd</Filter>
    </ClInclude>
    <ClInclude Include="..\cd\include\wd_old.h">
      <Filter>Header Files\cd</Filter>
    </ClInclude>
    <ClInclude Include="..\cd\include\cd.h">
      <Filter>Header Files\cd</Filter>
    </ClInclude>
    <ClInclude Include="..\cd\include\cd_canvas.hpp">
      <Filter>Header Files\cd</Filter>
    </ClInclude>
    <ClInclude Include="..\cd\include\cd_old.h">
      <Filter>Header Files\cd</Filter>
    </ClInclude>
    <ClInclude Include="..\cd\include\cd_plus.h">
      <Filter>Header Files\cd</Filter>
    </ClInclude>
    <ClInclude Include="..\cd\include\cd_private.h">
      <Filter>Header Files\cd</Filter>
    </ClInclude>
    <ClInclude Include="..\cd\include\cdcairo.h">
      <Filter>Header Files\cd</Filter>
    </ClInclude>
    <ClInclude Include="..\cd\include\cdcgm.h">
      <Filter>Header Files\cd</Filter>
    </ClInclude>
    <ClInclude Include="..\cd\include\cdclipbd.h">
      <Filter>Header Files\cd</Filter>
    </ClInclude>
    <ClInclude Include="..\cd\include\cddbuf.h">
      <Filter>Header Files\cd</Filter>
    </ClInclude>
    <ClInclude Include="..\cd\include\cddebug.h">
      <Filter>Header Files\cd</Filter>
    </ClInclude>
    <ClInclude Include="SearchResult.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Common.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="csMath.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="csScanner.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <Library Include="pluginsdk\x32bridge.lib">
      <Filter>Library Files</Filter>
    </Library>
    <Library Include="pluginsdk\x32dbg.lib">
      <Filter>Library Files</Filter>
    </Library>
    <Library Include="pluginsdk\x64bridge.lib">
      <Filter>Library Files</Filter>
    </Library>
    <Library Include="pluginsdk\x64dbg.lib">
      <Filter>Library Files</Filter>
    </Library>
    <Library Include="pluginsdk\DeviceNameResolver\DeviceNameResolver_x64.lib">
      <Filter>Library Files</Filter>
    </Library>
    <Library Include="pluginsdk\DeviceNameResolver\DeviceNameResolver_x86.lib">
      <Filter>Library Files</Filter>
    </Library>
    <Library Include="pluginsdk\jansson\jansson_x64.lib">
      <Filter>Library Files</Filter>
    </Library>
    <Library Include="pluginsdk\jansson\jansson_x86.lib">
      <Filter>Library Files</Filter>
    </Library>
    <Library Include="pluginsdk\lz4\lz4_x64.lib">
      <Filter>Library Files</Filter>
    </Library>
    <Library Include="pluginsdk\lz4\lz4_x86.lib">
      <Filter>Library Files</Filter>
    </Library>
    <Library Include="pluginsdk\TitanEngine\TitanEngine_x64.lib">
      <Filter>Library Files</Filter>
    </Library>
    <Library Include="pluginsdk\TitanEngine\TitanEngine_x86.lib">
      <Filter>Library Files</Filter>
    </Library>
    <Library Include="pluginsdk\XEDParse\XEDParse_x64.lib">
      <Filter>Library Files</Filter>
    </Library>
    <Library Include="pluginsdk\XEDParse\XEDParse_x86.lib">
      <Filter>Library Files</Filter>
    </Library>
    <Library Include="..\iup\iup.lib">
      <Filter>Library Files\iup</Filter>
    </Library>
    <Library Include="..\iup\iupcd.lib">
      <Filter>Library Files\iup</Filter>
    </Library>
    <Library Include="..\iup\iupcontrols.lib">
      <Filter>Library Files\iup</Filter>
    </Library>
    <Library Include="..\iup\iupim.lib">
      <Filter>Library Files\iup</Filter>
    </Library>
    <Library Include="..\iup\iupimglib.lib">
      <Filter>Library Files\iup</Filter>
    </Library>
    <Library Include="..\iup\zlib1.lib">
      <Filter>Library Files\iup</Filter>
    </Library>
    <Library Include="..\iup\freetype6.lib">
      <Filter>Library Files\iup</Filter>
    </Library>
    <Library Include="..\cd\cd.lib">
      <Filter>Library Files\cd</Filter>
    </Library>
    <Library Include="..\cd\cdcontextplus.lib">
      <Filter>Library Files\cd</Filter>
    </Library>
    <Library Include="..\cd\cdim.lib">
      <Filter>Library Files\cd</Filter>
    </Library>
    <Library Include="..\iup\iupimglib_x64.lib">
      <Filter>Library Files\iup</Filter>
    </Library>
    <Library Include="..\iup\zlib1_x64.lib">
      <Filter>Library Files\iup</Filter>
    </Library>
    <Library Include="..\iup\freetype6_x64.lib">
      <Filter>Library Files\iup</Filter>
    </Library>
    <Library Include="..\iup\iup_x64.lib">
      <Filter>Library Files\iup</Filter>
    </Library>
    <Library Include="..\iup\iupcd_x64.lib">
      <Filter>Library Files\iup</Filter>
    </Library>
    <Library Include="..\iup\iupcontrols_x64.lib">
      <Filter>Library Files\iup</Filter>
    </Library>
    <Library Include="..\iup\iupim_x64.lib">
      <Filter>Library Files\iup</Filter>
    </Library>
    <Library Include="..\cd\cd_x64.lib">
      <Filter>Library Files\cd</Filter>
    </Library>
    <Library Include="..\cd\cdcontextplus_x64.lib">
      <Filter>Library Files\cd</Filter>
    </Library>
    <Library Include="..\cd\cdim_x64.lib">
      <Filter>Library Files\cd</Filter>
    </Library>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="plugin.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="pluginmain.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="csMain.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Scratch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="csScanner.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>


================================================
File: ClawSearch/Common.h
================================================
#pragma once

#include "scratch2/s2string.h"
#include "scratch2/s2list.h"

#include <cassert>



================================================
File: ClawSearch/Scratch.cpp
================================================
#define S2_IMPL
#include "Common.h"



================================================
File: ClawSearch/SearchResult.h
================================================
#pragma once

#include "Common.h"

class SearchResult
{
public:
	uintptr_t m_base;
	uintptr_t m_offset;
	uint64_t m_valueFound;
};



================================================
File: ClawSearch/csMain.cpp
================================================
#include "csMain.h"

#include "plugin.h"

CLAW_CALLBACK(SearchWindowClosing);
CLAW_CALLBACK(FirstScan);
CLAW_CALLBACK(NextScan);
CLAW_CALLBACK(ScanValueTypeChanged);

int _claw_ResultClicked(Ihandle* handle, char* text, int item, int state) { _csMain->ResultClicked(text, item, state); return 0; }

csMain::csMain()
	: m_scanner(this)
{
	m_hDialog = nullptr;

	m_hButtonFirstScan = nullptr;
	m_hButtonNextScan = nullptr;

	m_hCheckHex = nullptr;
	m_hTextInput = nullptr;

	m_hComboScanType = nullptr;
	m_hComboValueType = nullptr;

	m_hFrameScanOptions = nullptr;
	m_hFloatMethod = nullptr;
	m_hCheckFastScan = nullptr;
	m_hTextFastScanAlign = nullptr;
	m_hCheckPauseWhileScanning = nullptr;

	m_hListResults = nullptr;

	m_currentScan = 0;
}

csMain::~csMain()
{
	if (m_hDialog != nullptr) {
		Close();
	}
}

SearchValueMethod csMain::MethodForType(SearchValueType type)
{
	switch (type) {
	case SVT_Char:
	case SVT_Int16:
	case SVT_Int32:
	case SVT_Int64:
		return SVM_Integer;

	case SVT_Float:
	case SVT_Double:
		return SVM_Float;
	}

	return SVM_Unknown;
}

int csMain::SearchWindowClosing()
{
	m_hDialog = nullptr;
	return IUP_CLOSE;
}

void csMain::PerformScan(bool firstScan)
{
	IupSetAttribute(m_hButtonFirstScan, "ACTIVE", "NO");
	IupSetAttribute(m_hButtonNextScan, "ACTIVE", "NO");
	IupSetAttribute(m_hComboScanType, "ACTIVE", "NO");

	m_scanner.m_inputText = IupGetAttribute(m_hTextInput, "VALUE");
	m_scanner.m_inputIsHex = !strcmp(IupGetAttribute(m_hCheckHex, "VALUE"), "ON");
	m_scanner.m_pauseWhileScanning = DbgIsRunning() && !strcmp(IupGetAttribute(m_hCheckPauseWhileScanning, "VALUE"), "ON");

	if (!strcmp(IupGetAttribute(m_hCheckFastScan, "VALUE"), "ON")) {
		sscanf(IupGetAttribute(m_hTextFastScanAlign, "VALUE"), "%d", &m_scanner.m_scanStep);

		if (m_scanner.m_scanStep < 1) {
			m_scanner.m_scanStep = 1;
		}
	}

	m_scanner.m_currentScanFloatTruncate = !strcmp(IupGetAttribute(m_hFloatMethod, "VALUE"), "trunc");
	m_scanner.m_currentScanFloatRound = !strcmp(IupGetAttribute(m_hFloatMethod, "VALUE"), "round");
	m_scanner.m_currentScanFloatRound2 = !strcmp(IupGetAttribute(m_hFloatMethod, "VALUE"), "round2");

	m_scanner.PerformScan(firstScan);

	IupSetAttribute(m_hListResults, "REMOVEITEM", "ALL");
	IupSetAttribute(m_hListResults, "AUTOREDRAW", "NO");

	size_t numResults = m_scanner.m_results.len();

	for (auto& result : m_scanner.m_results) {
		uintptr_t pointer = result.m_base + result.m_offset;

		s2::string strLine = s2::strprintf("%p", pointer);

		//TODO: Can we up the performance on this?
		if (numResults < 20) {
			char moduleName[MAX_MODULE_SIZE];
			if (DbgGetModuleAt(pointer, moduleName)) {
				strLine += s2::strprintf(" (%s)", moduleName);
			}

			char label[MAX_LABEL_SIZE];
			if (DbgGetLabelAt(pointer, SEG_DEFAULT, label)) {
				strLine += s2::strprintf(" %s", label);
			}
		}

		IupSetAttribute(m_hListResults, "APPENDITEM", strLine);
	}

	IupSetAttribute(m_hListResults, "AUTOREDRAW", "YES");
	IupRedraw(m_hListResults, 1);

	IupSetAttribute(m_hButtonFirstScan, "ACTIVE", "YES");
	IupSetAttribute(m_hButtonNextScan, "ACTIVE", "YES");
	IupSetAttribute(m_hComboScanType, "ACTIVE", "YES");
}

int csMain::FirstScan()
{
	if (m_currentScan > 0) {
		// New scan
		m_currentScan = 0;

		IupSetAttribute(m_hListResults, "REMOVEITEM", "ALL");

		IupSetAttribute(m_hButtonFirstScan, "TITLE", "First Scan");

		IupSetAttribute(m_hComboValueType, "ACTIVE", "YES");
		IupSetAttribute(m_hButtonNextScan, "ACTIVE", "NO");

		SetScanTypeCombo(true);
		return 0;
	}

	// First scan
	m_currentScan = 1;

	IupSetAttribute(m_hButtonFirstScan, "TITLE", "New Scan");
	SetScanTypeCombo(false);

	PerformScan(true);

	IupSetAttribute(m_hComboValueType, "ACTIVE", "NO");
	IupSetAttribute(m_hButtonNextScan, "ACTIVE", "YES");

	return 0;
}

int csMain::NextScan()
{
	m_currentScan++;

	PerformScan(false);

	return 0;
}

void csMain::ResultClicked(char* text, int item, int state)
{
	int index = item - 1;

	if (index == -1 || state == 0) {
		return;
	}

	SearchResult &result = m_scanner.m_results[index];

	GuiDumpAt(result.m_base + result.m_offset);
}

int csMain::ScanValueTypeChanged()
{
	bool inputHidden = false;

	if (m_currentScan == 0) {
		m_scanner.m_initialScanType = (InitialScanType)IupGetInt(m_hComboScanType, "VALUE");
		IupSetAttribute(m_hCheckHex, "ACTIVE", "YES");
		IupSetAttribute(m_hTextInput, "ACTIVE", "YES");
	} else {
		m_scanner.m_currentScanType = (ScanType)IupGetInt(m_hComboScanType, "VALUE");
		if (m_scanner.m_currentScanType == ST_Changed || m_scanner.m_currentScanType == ST_Unchanged || m_scanner.m_currentScanType == ST_Increased || m_scanner.m_currentScanType == ST_Decreased) {
			IupSetAttribute(m_hCheckHex, "ACTIVE", "NO");
			IupSetAttribute(m_hTextInput, "ACTIVE", "NO");
			inputHidden = true;
		} else {
			IupSetAttribute(m_hCheckHex, "ACTIVE", "YES");
			IupSetAttribute(m_hTextInput, "ACTIVE", "YES");
		}
	}
	m_scanner.m_currentScanValueType = (SearchValueType)IupGetInt(m_hComboValueType, "VALUE");
	m_scanner.m_currentScanValueMethod = MethodForType(m_scanner.m_currentScanValueType);

	if (!inputHidden) {
		IupSetAttribute(m_hCheckHex, "ACTIVE", m_scanner.m_currentScanValueMethod == SVM_Integer ? "YES" : "NO");
	}
	IupSetAttribute(m_hFloatMethod, "ACTIVE", m_scanner.m_currentScanValueMethod == SVM_Float ? "YES" : "NO");

	return 0;
}

void csMain::SetScanTypeCombo(bool firstScan)
{
	IupSetAttribute(m_hComboScanType, "REMOVEITEM", "ALL");

	if (firstScan) {
		IupSetAttribute(m_hComboScanType, "1", "Exact value");
		IupSetAttribute(m_hComboScanType, "2", "Bigger than...");
		IupSetAttribute(m_hComboScanType, "3", "Smaller than...");
		IupSetInt(m_hComboScanType, "VALUE", (int)m_scanner.m_initialScanType);
		return;
	}

	IupSetAttribute(m_hComboScanType, "1", "Exact value");
	IupSetAttribute(m_hComboScanType, "2", "Changed value");
	IupSetAttribute(m_hComboScanType, "3", "Unchanged value");
	IupSetAttribute(m_hComboScanType, "4", "Bigger than...");
	IupSetAttribute(m_hComboScanType, "5", "Smaller than...");
	IupSetAttribute(m_hComboScanType, "6", "Increased value");
	IupSetAttribute(m_hComboScanType, "7", "Decreased value");
	IupSetInt(m_hComboScanType, "VALUE", (int)m_scanner.m_currentScanType);
}

void csMain::Open()
{
	if (m_hDialog != nullptr) {
		return;
	}

	m_hButtonFirstScan = IupButton("First Scan", "ScanFirst");
	m_hButtonNextScan = IupButton("Next Scan", "ScanNext");
	Ihandle* hButtons = IupSetAttributes(IupHbox(m_hButtonFirstScan, m_hButtonNextScan, nullptr), "MARGIN=0x0, GAP=5");

	IupSetAttribute(m_hButtonNextScan, "ACTIVE", "NO");

	CLAW_SETCALLBACK(m_hButtonFirstScan, "ACTION", FirstScan);
	CLAW_SETCALLBACK(m_hButtonNextScan, "ACTION", NextScan);

	m_hCheckHex = IupToggle("Hex", nullptr);
	m_hTextInput = IupSetAttributes(IupText(nullptr), "EXPAND=HORIZONTAL");
	Ihandle* hInput = IupSetAttributes(IupHbox(m_hCheckHex, m_hTextInput, nullptr), "MARGIN=0x0, GAP=5");

	m_hComboScanType = IupList(nullptr);
	IupSetAttribute(m_hComboScanType, "DROPDOWN", "YES");
	IupSetAttribute(m_hComboScanType, "EXPAND", "HORIZONTAL");
	IupSetAttribute(m_hComboScanType, "VISIBLEITEMS", "10");
	SetScanTypeCombo(true);
	Ihandle* hScanType = IupSetAttributes(IupHbox(IupLabel("Scan type"), m_hComboScanType, nullptr), "MARGIN=0x0, GAP=5");
	CLAW_SETCALLBACK(m_hComboScanType, "ACTION", ScanValueTypeChanged);

	m_hComboValueType = IupList(nullptr);
	IupSetAttribute(m_hComboValueType, "DROPDOWN", "YES");
	IupSetAttribute(m_hComboValueType, "EXPAND", "HORIZONTAL");
	IupSetAttribute(m_hComboValueType, "VISIBLEITEMS", "10");
	IupSetAttribute(m_hComboValueType, "1", "Byte");
	IupSetAttribute(m_hComboValueType, "2", "2 Bytes");
	IupSetAttribute(m_hComboValueType, "3", "4 Bytes");
	IupSetAttribute(m_hComboValueType, "4", "8 Bytes");
	IupSetAttribute(m_hComboValueType, "5", "Float");
	IupSetAttribute(m_hComboValueType, "6", "Double");
	IupSetInt(m_hComboValueType, "VALUE", (int)m_scanner.m_currentScanValueType);
	Ihandle* hValueType = IupSetAttributes(IupHbox(IupLabel("Value type"), m_hComboValueType, nullptr), "MARGIN=0x0, GAP=5");
	CLAW_SETCALLBACK(m_hComboValueType, "ACTION", ScanValueTypeChanged);

	m_hCheckFastScan = IupToggle("Fast Scan", nullptr);
	IupSetAttribute(m_hCheckFastScan, "VALUE", "ON");

	m_hTextFastScanAlign = IupText(nullptr);
	IupSetAttribute(m_hTextFastScanAlign, "VALUE", "4");

	Ihandle* radioFloatTruncated = IupToggle("Truncated", nullptr);
	Ihandle* radioFloatRounded = IupToggle("Rounded", nullptr);
	Ihandle* radioFloatRoundedExtreme = IupToggle("Rounded (Extreme)", nullptr);

	IupSetHandle("trunc", radioFloatTruncated);
	IupSetHandle("round", radioFloatRounded);
	IupSetHandle("round2", radioFloatRoundedExtreme);

	m_hFloatMethod = IupRadio(IupSetAttributes(IupVbox(radioFloatTruncated, radioFloatRounded, radioFloatRoundedExtreme, nullptr), "MARGIN=0x0, GAP=5"));
	IupSetAttribute(m_hFloatMethod, "ACTIVE", "NO");

	Ihandle* hFastScan = IupSetAttributes(IupHbox(m_hCheckFastScan, m_hTextFastScanAlign, nullptr), "MARGIN=0x0, GAP=5");

	m_hCheckPauseWhileScanning = IupToggle("Pause while scanning", nullptr);

	m_hFrameScanOptions = IupFrame(IupVbox(
		m_hFloatMethod,
		hFastScan,
		m_hCheckPauseWhileScanning,
		nullptr)
	);
	IupSetAttribute(m_hFrameScanOptions, "TITLE", "Scan Options");
	IupSetAttribute(m_hFrameScanOptions, "EXPAND", "YES");

	Ihandle* vControls = IupSetAttributes(IupVbox(
		hButtons,
		hInput,
		hScanType,
		hValueType,
		m_hFrameScanOptions,
		nullptr), "MARGIN=10x0, GAP=5, EXPAND=HORIZONTAL");

	m_hListResults = IupList(nullptr);
	IupSetAttribute(m_hListResults, "FONT", "Consolas, 9");
	IupSetAttribute(m_hListResults, "EXPAND", "YES");
	IupSetAttribute(m_hListResults, "1", nullptr);
	IupSetCallback(m_hListResults, "ACTION", (Icallback)_claw_ResultClicked);

	m_hDialog = IupDialog(IupSetAttributes(IupHbox(m_hListResults, vControls, nullptr), "PADDING=4x4, MARGIN=10x10"));

	IupSetAttribute(m_hDialog, "TITLE", "ClawSearch");
	IupSetAttribute(m_hDialog, "SIZE", "500x200");

	IupSetAttribute(m_hDialog, "NATIVEPARENT", (char*)GuiGetWindowHandle());
	CLAW_SETCALLBACK(m_hDialog, "CLOSE_CB", SearchWindowClosing);
	IupShowXY(m_hDialog, IUP_CENTERPARENT, IUP_CENTERPARENT);
}

void csMain::Close()
{
	if (m_hDialog == nullptr) {
		return;
	}
	IupDestroy(m_hDialog);
	m_hDialog = nullptr;
}

csMain* _csMain = nullptr;

void OpenSearch()
{
	if (_csMain == nullptr) {
		_csMain = new csMain;
	}

	_csMain->Open();
}

void CloseSearch()
{
	if (_csMain == nullptr) {
		return;
	}

	_csMain->Close();
	delete _csMain;
}



================================================
File: ClawSearch/csMain.h
================================================
#pragma once

#include <iup.h>
#include <iupcontrols.h>

#include "pluginsdk/bridgemain.h"

#include "csScanner.h"

class csMain
{
public:
	// The main dialog
	Ihandle* m_hDialog;

	// Scan buttons
	Ihandle* m_hButtonFirstScan;
	Ihandle* m_hButtonNextScan;

	// Value input
	Ihandle* m_hCheckHex;
	Ihandle* m_hTextInput;

	// Value type input
	Ihandle* m_hComboScanType;
	Ihandle* m_hComboValueType;

	// Scan options
	Ihandle* m_hFrameScanOptions;

	// Scan options -> Float method
	Ihandle* m_hFloatMethod;

	// Scan options -> Fast scan
	Ihandle* m_hCheckFastScan;
	Ihandle* m_hTextFastScanAlign;

	// Scan options -> Pause while scanning
	Ihandle* m_hCheckPauseWhileScanning;

	// List results
	Ihandle* m_hListResults;

	// Scanner
	csScanner m_scanner;
	int m_currentScan;

public:
	csMain();
	~csMain();

	SearchValueMethod MethodForType(SearchValueType type);

	int SearchWindowClosing();

	void PerformScan(bool firstScan);

	int FirstScan();
	int NextScan();
	void ResultClicked(char* text, int item, int state);
	int ScanValueTypeChanged();

	void SetScanTypeCombo(bool firstScan);

	void Open();
	void Close();
};

extern csMain* _csMain;

void OpenSearch();
void CloseSearch();

inline bool cmpfloat(const float &a, const float &b, float e = FLT_EPSILON) { return fabsf(a - b) < e; }
inline bool cmpdouble(const double &a, const double &b, double e = DBL_EPSILON) { return fabsl(a - b) < e; }

#define CLAW_SETCALLBACK(handle, cb, name) IupSetCallback(handle, cb, _claw_##name);

#define CLAW_CALLBACK(name) static int _claw_##name(Ihandle* handle) { return _csMain->name(); }
#define CLAW_CALLBACK_HANDLE(name) static int _claw_##name(Ihandle* handle) { return _csMain->name(handle); }



================================================
File: ClawSearch/csMath.h
================================================
#pragma once

#include <math.h>

inline float truncf_to(const float &f, int n)
{
	if (n == 0) { return truncf(f); }
	float m = powf(10.0f, (float)n);
	return truncf(f * m) / m;
}

inline double truncl_to(const double &f, int n)
{
	if (n == 0) { return truncl(f); }
	double m = powl(10.0f, (double)n);
	return truncl(f * m) / m;
}

inline float roundf_to(const float &f, int n)
{
	if (n == 0) { return roundf(f); }
	float m = powf(10.0f, (float)n);
	return roundf(f * m) / m;
}

inline double roundl_to(const double &f, int n)
{
	if (n == 0) { return roundl(f); }
	double m = powl(10.0, (double)n);
	return roundl(f * m) / m;
}

inline float floorf_to(const float &f, int n)
{
	if (n == 0) { return floorf(f); }
	float m = powf(10.0f, (float)n);
	return roundf(f * m) / m;
}

inline double floorl_to(const double &f, int n)
{
	if (n == 0) { return floorl(f); }
	double m = powl(10.0, (double)n);
	return floorl(f * m) / m;
}

inline float ceilf_to(const float &f, int n)
{
	if (n == 0) { return ceilf(f); }
	float m = powf(10.0f, (float)n);
	return ceilf(f * m) / m;
}

inline double ceill_to(const double &f, int n)
{
	if (n == 0) { return ceill(f); }
	double m = powl(10.0, (double)n);
	return ceill(f * m) / m;
}



================================================
File: ClawSearch/csScanner.cpp
================================================
#include "csScanner.h"

#include "plugin.h"

#include "csMain.h"
#include "csMath.h"

csScanner::csScanner(csMain* main)
{
	m_main = main;

	m_currentScanMap.count = 0;
	m_currentScanMap.page = nullptr;

	m_initialScanType = IST_Equal;
	m_currentScanType = ST_Equal;
	m_currentScanValueType = SVT_Int32;
	m_currentScanValueMethod = SVM_Integer;

	m_inputText = nullptr;
	m_inputIsHex = false;

	m_pauseWhileScanning = false;

	m_scanStep = 1;

	m_currentScanFloatTruncate = false;
	m_currentScanFloatRound = false;
	m_currentScanFloatRound2 = false;
	m_currentScanFloatRoundNum = 0;

	m_scanSize = 0x1000;
	m_currentBuffer = nullptr;
	m_currentCompare = nullptr;
}

csScanner::~csScanner()
{
	if (m_currentBuffer != nullptr) {
		free(m_currentBuffer);
	}

	if (m_currentScanMap.page != nullptr) {
		BridgeFree(m_currentScanMap.page);
	}
}

void csScanner::PerformScan(bool firstScan)
{
	size_t findSize = 0;
	unsigned char* find = nullptr;

	if (firstScan) {
		m_results.clear();
	}

	if (m_pauseWhileScanning) {
		DbgCmdExecDirect("pause");
		_plugin_waituntilpaused();
	}

	//TODO: Clean this up
#define HANDLE_SEARCHFOR_SCANF(format, type) type searchFor; \
	if (sscanf(m_inputText, format, &searchFor) > 0) { \
		findSize = sizeof(searchFor); \
		find = (unsigned char*)malloc(findSize); \
		memcpy(find, &searchFor, findSize); \
	}

	if (m_currentScanValueType == SVT_Char) {
		if (m_inputIsHex) {
			HANDLE_SEARCHFOR_SCANF("%hhx", uint8_t);
		} else {
			HANDLE_SEARCHFOR_SCANF("%hhd", int8_t);
		}
	} else if (m_currentScanValueType == SVT_Int16) {
		if (m_inputIsHex) {
			HANDLE_SEARCHFOR_SCANF("%hx", uint16_t);
		} else {
			HANDLE_SEARCHFOR_SCANF("%hd", int16_t);
		}
	} else if (m_currentScanValueType == SVT_Int32) {
		if (m_inputIsHex) {
			HANDLE_SEARCHFOR_SCANF("%x", uint32_t);
		} else {
			HANDLE_SEARCHFOR_SCANF("%d", int32_t);
		}
	} else if (m_currentScanValueType == SVT_Int64) {
		if (m_inputIsHex) {
			HANDLE_SEARCHFOR_SCANF("%llx", uint64_t);
		} else {
			HANDLE_SEARCHFOR_SCANF("%llx", int64_t);
		}
	} else if (m_currentScanValueType == SVT_Float) {
		HANDLE_SEARCHFOR_SCANF("%f", float);
	} else if (m_currentScanValueType == SVT_Double) {
		HANDLE_SEARCHFOR_SCANF("%lf", double);
	}

#undef HANDLE_SEARCHFOR

	if (find == nullptr) {
		IupMessage("Error", "Unhandled value type!");
		return;
	}

	if (m_currentScanValueMethod == SVM_Float) {
		const char* afterPeriod = strchr(m_inputText, '.');
		if (afterPeriod == nullptr) {
			m_currentScanFloatRoundNum = 0;
		} else {
			m_currentScanFloatRoundNum = (int)strlen(afterPeriod + 1);
		}
	}

	if (m_currentBuffer == nullptr) {
		m_currentBuffer = (unsigned char*)malloc(m_scanSize);
		memset(m_currentBuffer, 0, m_scanSize);
	}

	if (m_currentScanMap.page != nullptr) {
		BridgeFree(m_currentScanMap.page);
		m_currentScanMap.page = nullptr;
	}

	// If this is the very first scan
	if (firstScan) {
		DbgMemMap(&m_currentScanMap);

		// For each memory region
		for (int iMap = 0; iMap < m_currentScanMap.count; iMap++) {
			MEMPAGE &memPage = m_currentScanMap.page[iMap];
			uintptr_t base = (uintptr_t)memPage.mbi.BaseAddress;
			size_t size = memPage.mbi.RegionSize;
			uintptr_t end = base + size;

			// For each page in the memory region
			for (uintptr_t p = base; p < end; p += m_scanSize) {
				size_t sz = m_scanSize;
				if (p + sz >= end) {
					sz = end - p;
				}

				//TODO: Try ReadProcessMemory instead
				DbgMemRead(p, m_currentBuffer, sz);

				// Perform search on buffer
				for (uintptr_t s = 0; s < sz; s += m_scanStep) {
					// Stop if find size is beyond scan size
					if (s + findSize > sz) {
						break;
					}

					// Compare at this position
					if (!MatchDataInitial(m_currentBuffer + s, find, (int)findSize)) {
						continue;
					}

					// Found it!
					SearchResult &result = m_results.add();
					result.m_base = p;
					result.m_offset = s;
					result.m_valueFound = 0;
					if (findSize <= sizeof(uint64_t)) {
						memcpy(&result.m_valueFound, m_currentBuffer + s, findSize);
					}

					// We can step forward now
					s += findSize;
				}
			}
		}
	}

	m_currentCompare = (unsigned char*)malloc(findSize);

	// If this is not our first scan
	if (!firstScan) {
		s2::list<SearchResult> newResults;
		newResults.ensure_memory(m_results.len());

		for (size_t i = 0; i < m_results.len(); i++) {
			SearchResult &result = m_results[i];

			//TODO: This is really slow!

			uintptr_t ptr = result.m_base + result.m_offset;

			// The memory must still be readable
			if (DbgMemIsValidReadPtr(ptr)) {
				DbgMemRead(result.m_base + result.m_offset, m_currentCompare, findSize);

				// Match data
				if (MatchDataNext(m_currentCompare, find, result, (int)findSize)) {
					newResults.add(result);
				}
			}
		}

		m_results = newResults;
	}

	if (m_pauseWhileScanning) {
		DbgCmdExec("run");
	}

	free(find);
	free(m_currentCompare);
	m_currentCompare = nullptr;
}

bool csScanner::MatchDataInitial(void* p, void* src, int sz)
{
	switch (m_initialScanType) {
	case IST_Equal: return MatchDataEqual(p, src, sz);
	case IST_MoreThan: return MatchDataDifference(p, src, sz, 1);
	case IST_LessThan: return MatchDataDifference(p, src, sz, -1);
	default: assert(false); return false;
	}
}

bool csScanner::MatchDataNext(void* p, void* src, SearchResult &result, int sz)
{
	switch (m_currentScanType) {
	case ST_Equal: return MatchDataEqual(p, src, sz);
	case ST_Changed: assert(sz <= 8); return !MatchDataEqual(p, &result.m_valueFound, sz);
	case ST_MoreThan: return MatchDataDifference(p, src, sz, 1);
	case ST_LessThan: return MatchDataDifference(p, src, sz, -1);
	case ST_Increased: assert(sz <= 8); return MatchDataDifference(p, &result.m_valueFound, sz, 1);
	case ST_Decreased: assert(sz <= 8); return MatchDataDifference(p, &result.m_valueFound, sz, -1);
	}
	return false;
}

bool csScanner::MatchDataEqual(void* p, void* src, int sz)
{
	if (m_currentScanValueMethod == SVM_Integer) {
		// For basic integer types we can simply compare the bytes
		if (memcmp(p, src, sz) != 0) {
			return false;
		}

	} else if (m_currentScanValueMethod == SVM_Float) {
		// For floating point types it depends on the size
		if (m_currentScanValueType == SVT_Float) {
			const float &orig = *(float*)src;
			const float &f = *(float*)p;

			if (m_currentScanFloatRound) {
				// If our source float is rounded
				float rounded = roundf_to(f, m_currentScanFloatRoundNum);

				// Go to next if the float does not compare
				if (!cmpfloat(rounded, orig)) {
					return false;
				}
			} else if (m_currentScanFloatRound2) {
				// If our source float is extreme rounded
				float rounded1 = ceilf_to(f, m_currentScanFloatRoundNum);
				float rounded2 = floorf_to(f, m_currentScanFloatRoundNum);

				// Go to next if the float does not compare
				if (!cmpfloat(rounded1, orig) && !cmpfloat(rounded2, orig)) {
					return false;
				}
			} else if (m_currentScanFloatTruncate) {
				// If our source float is truncated
				float truncated = truncf_to(f, m_currentScanFloatRoundNum);

				// Go to next if the float does not compare
				if (!cmpfloat(truncated, orig)) {
					return false;
				}
			} else {
				// Regular float compare using epsilon
				if (!cmpfloat(f, orig)) {
					// Go to next if the float does not compare
					return false;
				}
			}

		} else if (m_currentScanValueType == SVT_Double) {
			const double &orig = *(double*)src;
			const double &d = *(double*)p;

			if (m_currentScanFloatRound) {
				// If our source double is rounded
				double rounded = roundl_to(d, m_currentScanFloatRoundNum);

				// Go to next if the double does not compare
				if (!cmpdouble(rounded, orig)) {
					return false;
				}
			} else if (m_currentScanFloatRound2) {
				// If our source double is extreme rounded
				double rounded1 = ceill_to(d, m_currentScanFloatRoundNum);
				double rounded2 = floorl_to(d, m_currentScanFloatRoundNum);

				// Go to next if the double does not compare
				if (!cmpdouble(rounded1, orig) && !cmpdouble(rounded2, orig)) {
					return false;
				}
			} else if (m_currentScanFloatTruncate) {
				// If our source double is truncated
				double truncated = truncl_to(d, m_currentScanFloatRoundNum);

				// Go to next if the double does not compare
				if (!cmpdouble(truncated, orig)) {
					return false;
				}
			} else {
				// Regular double compare using epsilon
				if (!cmpdouble(d, orig)) {
					// Go to next if the double does not compare
					return false;
				}
			}

		} else {
			// Unknown floating point type
			assert(false);
			return false;
		}

	} else {
		// Unknown scan value method
		assert(false);
		return false;
	}

	// It matches!
	return true;
}

bool csScanner::MatchDataDifference(void* p, void* src, int sz, int dir)
{
	//TODO: Clean this up
#define HANDLE_DIFFERENCE(type) const type &orig = *(type*)src; \
	const type &v = *(type*)p; \
	switch (dir) { \
	case -1: return v < orig; \
	case 1: return v > orig; \
	default: assert(false); return false; \
	}

	if (m_currentScanValueType == SVT_Char) {
		HANDLE_DIFFERENCE(char);
	} else if (m_currentScanValueType == SVT_Int16) {
		HANDLE_DIFFERENCE(int16_t);
	} else if (m_currentScanValueType == SVT_Int32) {
		HANDLE_DIFFERENCE(int32_t);
	} else if (m_currentScanValueType == SVT_Int64) {
		HANDLE_DIFFERENCE(int64_t);

	} else if (m_currentScanValueType == SVT_Float) {
		HANDLE_DIFFERENCE(float);
	} else if (m_currentScanValueType == SVT_Double) {
		HANDLE_DIFFERENCE(double);

	} else {
		// Unhandled type
		assert(false);
	}

	return false;

#undef HANDLE_DIFFERENCE
}



================================================
File: ClawSearch/csScanner.h
================================================
#pragma once

#include "pluginsdk/bridgemain.h"

#include "Common.h"
#include "SearchResult.h"

class csMain;

enum SearchValueType
{
	SVT_Unknown,

	SVT_Char, // 1 byte
	SVT_Int16, // 2 bytes
	SVT_Int32, // 4 bytes
	SVT_Int64, // 8 bytes

	SVT_Float, // 4 bytes
	SVT_Double, // 8 bytes
};

enum SearchValueMethod
{
	SVM_Unknown,

	SVM_Integer, // char, int16, int32, int64
	SVM_Float, // float, double
};

enum InitialScanType
{
	IST_Unknown,

	IST_Equal, // source == input
	IST_MoreThan, // source > input
	IST_LessThan, // source < input
};

enum ScanType
{
	ST_Unknown,

	ST_Equal, // source == input
	ST_Changed, // source != lastValue
	ST_Unchanged, // source == lastValue
	ST_MoreThan, // source > input
	ST_LessThan, // source < input
	ST_Increased, // source > lastValue
	ST_Decreased, // source < lastValue
};

class csScanner
{
public:
	csMain* m_main;

	MEMMAP m_currentScanMap;

	InitialScanType m_initialScanType;
	ScanType m_currentScanType;
	SearchValueType m_currentScanValueType;
	SearchValueMethod m_currentScanValueMethod;

	const char* m_inputText;
	bool m_inputIsHex;

	bool m_pauseWhileScanning;

	int m_scanStep;

	bool m_currentScanFloatTruncate;
	bool m_currentScanFloatRound;
	bool m_currentScanFloatRound2;
	int m_currentScanFloatRoundNum;

	s2::list<SearchResult> m_results;

	size_t m_scanSize;
	unsigned char* m_currentBuffer;
	unsigned char* m_currentCompare;

public:
	csScanner(csMain* main);
	~csScanner();

	void PerformScan(bool firstScan);

	bool MatchDataInitial(void* p, void* src, int sz);
	bool MatchDataNext(void* p, void* src, SearchResult &result, int sz);

	bool MatchDataEqual(void* p, void* src, int sz);
	bool MatchDataDifference(void* p, void* src, int sz, int dir);
};



================================================
File: ClawSearch/plugin.cpp
================================================
#include "plugin.h"

#include "csMain.h"

static void executeOnGuiThreadAndWait(void(*worker)())
{
	struct Context
	{
		HANDLE event;
		void(*worker)();
	};
	auto context = Context{ CreateEventW(nullptr, true, false, nullptr), worker };
	GuiExecuteOnGuiThreadEx([](void* data)
	{
		auto context = (Context*)data;
		context->worker();
		SetEvent(context->event);
	}, &context);
	WaitForSingleObject(context.event, INFINITE);
	CloseHandle(context.event);
}

enum
{
	MENU_OPENSEARCH
};

PLUG_EXPORT void CBMENUENTRY(CBTYPE cbType, PLUG_CB_MENUENTRY* info)
{
	switch (info->hEntry) {
	case MENU_OPENSEARCH:
		OpenSearch();
		break;

	default:
		break;
	}
}

//Initialize your plugin data here.
bool pluginInit(PLUG_INITSTRUCT* initStruct)
{
	return true; //Return false to cancel loading the plugin.
}

//Do GUI/Menu related things here.
void pluginSetup()
{
	_plugin_menuaddentry(hMenu, MENU_OPENSEARCH, "Open search dialog");
	_plugin_menuaddentry(hMenuDump, MENU_OPENSEARCH, "ClawSearch");

	// Initialize the UI on the same thread as x64dbg's UI
	executeOnGuiThreadAndWait([]
	{
		IupOpen(nullptr, nullptr);
		IupControlsOpen();

		IupSetGlobal("LOCKLOOP", "YES");
	});
}

//Deinitialize your plugin data here (clearing menus optional).
bool pluginStop()
{
	_plugin_menuclear(hMenu);
	_plugin_menuclear(hMenuDisasm);
	_plugin_menuclear(hMenuDump);
	_plugin_menuclear(hMenuStack);

	executeOnGuiThreadAndWait([]
	{
		CloseSearch();
		IupClose();
	});

	return true;
}

// Hack for Iup
int main() { return 0; }



================================================
File: ClawSearch/plugin.h
================================================
#pragma once

#include "pluginmain.h"

//plugin data
#define PLUGIN_NAME "ClawSearch"
#define PLUGIN_VERSION 1

//functions
bool pluginInit(PLUG_INITSTRUCT* initStruct);
bool pluginStop();
void pluginSetup();



================================================
File: ClawSearch/pluginmain.cpp
================================================
#include "pluginmain.h"
#include "plugin.h"

int pluginHandle;
HWND hwndDlg;
int hMenu;
int hMenuDisasm;
int hMenuDump;
int hMenuStack;

PLUG_EXPORT bool pluginit(PLUG_INITSTRUCT* initStruct)
{
	initStruct->pluginVersion = PLUGIN_VERSION;
	initStruct->sdkVersion = PLUG_SDKVERSION;
	strncpy_s(initStruct->pluginName, PLUGIN_NAME, _TRUNCATE);
	pluginHandle = initStruct->pluginHandle;
	return pluginInit(initStruct);
}

PLUG_EXPORT bool plugstop()
{
	return pluginStop();
}

PLUG_EXPORT void plugsetup(PLUG_SETUPSTRUCT* setupStruct)
{
	hwndDlg = setupStruct->hwndDlg;
	hMenu = setupStruct->hMenu;
	hMenuDisasm = setupStruct->hMenuDisasm;
	hMenuDump = setupStruct->hMenuDump;
	hMenuStack = setupStruct->hMenuStack;
	pluginSetup();
}

BOOL WINAPI DllMain(
	_In_ HINSTANCE hinstDLL,
	_In_ DWORD     fdwReason,
	_In_ LPVOID    lpvReserved
	)
{
	return TRUE;
}



================================================
File: ClawSearch/pluginmain.h
================================================
#pragma once

#include "pluginsdk/bridgemain.h"
#include "pluginsdk/_plugins.h"

#include "pluginsdk/_scriptapi_argument.h"
#include "pluginsdk/_scriptapi_assembler.h"
#include "pluginsdk/_scriptapi_bookmark.h"
#include "pluginsdk/_scriptapi_comment.h"
#include "pluginsdk/_scriptapi_debug.h"
#include "pluginsdk/_scriptapi_flag.h"
#include "pluginsdk/_scriptapi_function.h"
#include "pluginsdk/_scriptapi_gui.h"
#include "pluginsdk/_scriptapi_label.h"
#include "pluginsdk/_scriptapi_memory.h"
#include "pluginsdk/_scriptapi_misc.h"
#include "pluginsdk/_scriptapi_module.h"
#include "pluginsdk/_scriptapi_pattern.h"
#include "pluginsdk/_scriptapi_register.h"
#include "pluginsdk/_scriptapi_stack.h"
#include "pluginsdk/_scriptapi_symbol.h"

#include "pluginsdk/DeviceNameResolver/DeviceNameResolver.h"
#include "pluginsdk/jansson/jansson.h"
#include "pluginsdk/lz4/lz4file.h"
#include "pluginsdk/TitanEngine/TitanEngine.h"
#include "pluginsdk/XEDParse/XEDParse.h"

#ifdef _WIN64
#pragma comment(lib, "pluginsdk/x64dbg.lib")
#pragma comment(lib, "pluginsdk/x64bridge.lib")
#pragma comment(lib, "pluginsdk/DeviceNameResolver/DeviceNameResolver_x64.lib")
#pragma comment(lib, "pluginsdk/jansson/jansson_x64.lib")
#pragma comment(lib, "pluginsdk/lz4/lz4_x64.lib")
#pragma comment(lib, "pluginsdk/TitanEngine/TitanEngine_x64.lib")
#pragma comment(lib, "pluginsdk/XEDParse/XEDParse_x64.lib")
#else
#pragma comment(lib, "pluginsdk/x32dbg.lib")
#pragma comment(lib, "pluginsdk/x32bridge.lib")
#pragma comment(lib, "pluginsdk/DeviceNameResolver/DeviceNameResolver_x86.lib")
#pragma comment(lib, "pluginsdk/jansson/jansson_x86.lib")
#pragma comment(lib, "pluginsdk/lz4/lz4_x86.lib")
#pragma comment(lib, "pluginsdk/TitanEngine/TitanEngine_x86.lib")
#pragma comment(lib, "pluginsdk/XEDParse/XEDParse_x86.lib")
#endif //_WIN64

#define Cmd(x) DbgCmdExecDirect(x)
#define Eval(x) DbgValFromString(x)
#define PLUG_EXPORT extern "C" __declspec(dllexport)

//superglobal variables
extern int pluginHandle;
extern HWND hwndDlg;
extern int hMenu;
extern int hMenuDisasm;
extern int hMenuDump;
extern int hMenuStack;



================================================
File: ClawSearch/pluginsdk/_dbgfunctions.h
================================================
#ifndef _DBGFUNCTIONS_H
#define _DBGFUNCTIONS_H

#ifndef __cplusplus
#include <stdbool.h>
#endif

typedef struct
{
    char mod[MAX_MODULE_SIZE];
    duint addr;
    unsigned char oldbyte;
    unsigned char newbyte;
} DBGPATCHINFO;

typedef struct
{
    duint addr;
    duint from;
    duint to;
    char comment[MAX_COMMENT_SIZE];
} DBGCALLSTACKENTRY;

typedef struct
{
    int total;
    DBGCALLSTACKENTRY* entries;
} DBGCALLSTACK;

typedef struct
{
    duint addr;
    duint handler;
} DBGSEHRECORD;

typedef struct
{
    duint total;
    DBGSEHRECORD* records;
} DBGSEHCHAIN;

typedef struct
{
    DWORD dwProcessId;
    char szExeFile[MAX_PATH];
    char szExeMainWindowTitle[MAX_PATH];
    char szExeArgs[MAX_COMMAND_LINE_SIZE];
} DBGPROCESSINFO;

typedef struct
{
    DWORD rva;
    BYTE type;
    WORD size;
} DBGRELOCATIONINFO;

typedef enum
{
    InstructionBody = 0,
    InstructionHeading = 1,
    InstructionTailing = 2,
    InstructionOverlapped = 3, // The byte was executed with differing instruction base addresses
    DataByte,  // This and the following is not implemented yet.
    DataWord,
    DataDWord,
    DataQWord,
    DataFloat,
    DataDouble,
    DataLongDouble,
    DataXMM,
    DataYMM,
    DataMMX,
    DataMixed, //the byte is accessed in multiple ways
    InstructionDataMixed //the byte is both executed and written
} TRACERECORDBYTETYPE;

typedef enum
{
    TraceRecordNone,
    TraceRecordBitExec,
    TraceRecordByteWithExecTypeAndCounter,
    TraceRecordWordWithExecTypeAndCounter
} TRACERECORDTYPE;

typedef struct
{
    duint Handle;
    unsigned char TypeNumber;
    unsigned int GrantedAccess;
} HANDLEINFO;

// The longest ip address is 1234:6789:1234:6789:1234:6789:123.567.901.345 (46 bytes)
#define TCP_ADDR_SIZE 50

typedef struct
{
    char RemoteAddress[TCP_ADDR_SIZE];
    unsigned short RemotePort;
    char LocalAddress[TCP_ADDR_SIZE];
    unsigned short LocalPort;
    char StateText[TCP_ADDR_SIZE];
    unsigned int State;
} TCPCONNECTIONINFO;

typedef struct
{
    duint handle;
    duint parent;
    DWORD threadId;
    DWORD style;
    DWORD styleEx;
    duint wndProc;
    bool enabled;
    RECT position;
    char windowTitle[MAX_COMMENT_SIZE];
    char windowClass[MAX_COMMENT_SIZE];
} WINDOW_INFO;

typedef struct
{
    duint addr;
    duint size;
    duint flags;
} HEAPINFO;

typedef struct
{
    const char* name;
    duint value;
} CONSTANTINFO;

typedef enum
{
    MODSYMUNLOADED = 0,
    MODSYMLOADING,
    MODSYMLOADED
} MODULESYMBOLSTATUS;

typedef bool (*ASSEMBLEATEX)(duint addr, const char* instruction, char* error, bool fillnop);
typedef bool (*SECTIONFROMADDR)(duint addr, char* section);
typedef bool (*MODNAMEFROMADDR)(duint addr, char* modname, bool extension);
typedef duint(*MODBASEFROMADDR)(duint addr);
typedef duint(*MODBASEFROMNAME)(const char* modname);
typedef duint(*MODSIZEFROMADDR)(duint addr);
typedef bool (*ASSEMBLE)(duint addr, unsigned char* dest, int* size, const char* instruction, char* error);
typedef bool (*PATCHGET)(duint addr);
typedef bool (*PATCHINRANGE)(duint start, duint end);
typedef bool (*MEMPATCH)(duint va, const unsigned char* src, duint size);
typedef void (*PATCHRESTORERANGE)(duint start, duint end);
typedef bool (*PATCHENUM)(DBGPATCHINFO* patchlist, size_t* cbsize);
typedef bool (*PATCHRESTORE)(duint addr);
typedef int (*PATCHFILE)(DBGPATCHINFO* patchlist, int count, const char* szFileName, char* error);
typedef int (*MODPATHFROMADDR)(duint addr, char* path, int size);
typedef int (*MODPATHFROMNAME)(const char* modname, char* path, int size);
typedef bool (*DISASMFAST)(const unsigned char* data, duint addr, BASIC_INSTRUCTION_INFO* basicinfo);
typedef void (*MEMUPDATEMAP)();
typedef void (*GETCALLSTACK)(DBGCALLSTACK* callstack);
typedef void (*GETSEHCHAIN)(DBGSEHCHAIN* sehchain);
typedef void (*SYMBOLDOWNLOADALLSYMBOLS)(const char* szSymbolStore);
typedef bool (*GETJIT)(char* jit, bool x64);
typedef bool (*GETJITAUTO)(bool* jitauto);
typedef bool (*GETDEFJIT)(char* defjit);
typedef bool (*GETPROCESSLIST)(DBGPROCESSINFO** entries, int* count);
typedef bool (*GETPAGERIGHTS)(duint addr, char* rights);
typedef bool (*SETPAGERIGHTS)(duint addr, const char* rights);
typedef bool (*PAGERIGHTSTOSTRING)(DWORD protect, char* rights);
typedef bool (*ISPROCESSELEVATED)();
typedef bool (*GETCMDLINE)(char* cmdline, size_t* cbsize);
typedef bool (*SETCMDLINE)(const char* cmdline);
typedef duint(*FILEOFFSETTOVA)(const char* modname, duint offset);
typedef duint(*VATOFILEOFFSET)(duint va);
typedef duint(*GETADDRFROMLINE)(const char* szSourceFile, int line, duint* displacement);
typedef bool (*GETSOURCEFROMADDR)(duint addr, char* szSourceFile, int* line);
typedef bool (*VALFROMSTRING)(const char* string, duint* value);
typedef bool (*PATCHGETEX)(duint addr, DBGPATCHINFO* info);
typedef bool (*GETBRIDGEBP)(BPXTYPE type, duint addr, BRIDGEBP* bp);
typedef bool (*STRINGFORMATINLINE)(const char* format, size_t resultSize, char* result);
typedef void (*GETMNEMONICBRIEF)(const char* mnem, size_t resultSize, char* result);
typedef unsigned int (*GETTRACERECORDHITCOUNT)(duint address);
typedef TRACERECORDBYTETYPE(*GETTRACERECORDBYTETYPE)(duint address);
typedef bool (*SETTRACERECORDTYPE)(duint pageAddress, TRACERECORDTYPE type);
typedef TRACERECORDTYPE(*GETTRACERECORDTYPE)(duint pageAddress);
typedef bool (*ENUMHANDLES)(ListOf(HANDLEINFO) handles);
typedef bool (*GETHANDLENAME)(duint handle, char* name, size_t nameSize, char* typeName, size_t typeNameSize);
typedef bool (*ENUMTCPCONNECTIONS)(ListOf(TCPCONNECTIONINFO) connections);
typedef duint(*GETDBGEVENTS)();
typedef int (*MODGETPARTY)(duint base);
typedef void (*MODSETPARTY)(duint base, int party);
typedef bool(*WATCHISWATCHDOGTRIGGERED)(unsigned int id);
typedef bool(*MEMISCODEPAGE)(duint addr, bool refresh);
typedef bool(*ANIMATECOMMAND)(const char* command);
typedef void(*DBGSETDEBUGGEEINITSCRIPT)(const char* fileName);
typedef const char* (*DBGGETDEBUGGEEINITSCRIPT)();
typedef bool(*HANDLESENUMWINDOWS)(ListOf(WINDOW_INFO) windows);
typedef bool(*HANDLESENUMHEAPS)(ListOf(HEAPINFO) heaps);
typedef bool(*THREADGETNAME)(DWORD tid, char* name);
typedef bool(*ISDEPENABLED)();
typedef void(*GETCALLSTACKEX)(DBGCALLSTACK* callstack, bool cache);
typedef bool(*GETUSERCOMMENT)(duint addr, char* comment);
typedef void(*ENUMCONSTANTS)(ListOf(CONSTANTINFO) constants);
typedef duint(*MEMBPSIZE)(duint addr);
typedef bool(*MODRELOCATIONSFROMADDR)(duint addr, ListOf(DBGRELOCATIONINFO) relocations);
typedef bool(*MODRELOCATIONATADDR)(duint addr, DBGRELOCATIONINFO* relocation);
typedef bool(*MODRELOCATIONSINRANGE)(duint addr, duint size, ListOf(DBGRELOCATIONINFO) relocations);
typedef duint(*DBGETHASH)();
typedef int(*SYMAUTOCOMPLETE)(const char* Search, char** Buffer, int MaxSymbols);
typedef void(*REFRESHMODULELIST)();
typedef duint(*GETADDRFROMLINEEX)(duint mod, const char* szSourceFile, int line);
typedef MODULESYMBOLSTATUS(*MODSYMBOLSTATUS)(duint mod);

//The list of all the DbgFunctions() return value.
//WARNING: This list is append only. Do not insert things in the middle or plugins would break.
typedef struct DBGFUNCTIONS_
{
    ASSEMBLEATEX AssembleAtEx;
    SECTIONFROMADDR SectionFromAddr;
    MODNAMEFROMADDR ModNameFromAddr;
    MODBASEFROMADDR ModBaseFromAddr;
    MODBASEFROMNAME ModBaseFromName;
    MODSIZEFROMADDR ModSizeFromAddr;
    ASSEMBLE Assemble;
    PATCHGET PatchGet;
    PATCHINRANGE PatchInRange;
    MEMPATCH MemPatch;
    PATCHRESTORERANGE PatchRestoreRange;
    PATCHENUM PatchEnum;
    PATCHRESTORE PatchRestore;
    PATCHFILE PatchFile;
    MODPATHFROMADDR ModPathFromAddr;
    MODPATHFROMNAME ModPathFromName;
    DISASMFAST DisasmFast;
    MEMUPDATEMAP MemUpdateMap;
    GETCALLSTACK GetCallStack;
    GETSEHCHAIN GetSEHChain;
    SYMBOLDOWNLOADALLSYMBOLS SymbolDownloadAllSymbols;
    GETJITAUTO GetJitAuto;
    GETJIT GetJit;
    GETDEFJIT GetDefJit;
    GETPROCESSLIST GetProcessList;
    GETPAGERIGHTS GetPageRights;
    SETPAGERIGHTS SetPageRights;
    PAGERIGHTSTOSTRING PageRightsToString;
    ISPROCESSELEVATED IsProcessElevated;
    GETCMDLINE GetCmdline;
    SETCMDLINE SetCmdline;
    FILEOFFSETTOVA FileOffsetToVa;
    VATOFILEOFFSET VaToFileOffset;
    GETADDRFROMLINE GetAddrFromLine;
    GETSOURCEFROMADDR GetSourceFromAddr;
    VALFROMSTRING ValFromString;
    PATCHGETEX PatchGetEx;
    GETBRIDGEBP GetBridgeBp;
    STRINGFORMATINLINE StringFormatInline;
    GETMNEMONICBRIEF GetMnemonicBrief;
    GETTRACERECORDHITCOUNT GetTraceRecordHitCount;
    GETTRACERECORDBYTETYPE GetTraceRecordByteType;
    SETTRACERECORDTYPE SetTraceRecordType;
    GETTRACERECORDTYPE GetTraceRecordType;
    ENUMHANDLES EnumHandles;
    GETHANDLENAME GetHandleName;
    ENUMTCPCONNECTIONS EnumTcpConnections;
    GETDBGEVENTS GetDbgEvents;
    MODGETPARTY ModGetParty;
    MODSETPARTY ModSetParty;
    WATCHISWATCHDOGTRIGGERED WatchIsWatchdogTriggered;
    MEMISCODEPAGE MemIsCodePage;
    ANIMATECOMMAND AnimateCommand;
    DBGSETDEBUGGEEINITSCRIPT DbgSetDebuggeeInitScript;
    DBGGETDEBUGGEEINITSCRIPT DbgGetDebuggeeInitScript;
    HANDLESENUMWINDOWS EnumWindows;
    HANDLESENUMHEAPS EnumHeaps;
    THREADGETNAME ThreadGetName;
    ISDEPENABLED IsDepEnabled;
    GETCALLSTACKEX GetCallStackEx;
    GETUSERCOMMENT GetUserComment;
    ENUMCONSTANTS EnumConstants;
    ENUMCONSTANTS EnumErrorCodes;
    ENUMCONSTANTS EnumExceptions;
    MEMBPSIZE MemBpSize;
    MODRELOCATIONSFROMADDR ModRelocationsFromAddr;
    MODRELOCATIONATADDR ModRelocationAtAddr;
    MODRELOCATIONSINRANGE ModRelocationsInRange;
    DBGETHASH DbGetHash;
    SYMAUTOCOMPLETE SymAutoComplete;
    REFRESHMODULELIST RefreshModuleList;
    GETADDRFROMLINEEX GetAddrFromLineEx;
    MODSYMBOLSTATUS ModSymbolStatus;
} DBGFUNCTIONS;

#ifdef BUILD_DBG

const DBGFUNCTIONS* dbgfunctionsget();
void dbgfunctionsinit();

#endif //BUILD_DBG

#endif //_DBGFUNCTIONS_H



================================================
File: ClawSearch/pluginsdk/_plugin_types.h
================================================
#ifndef _PLUGIN_DATA_H
#define _PLUGIN_DATA_H

#ifdef BUILD_DBG

#include "_global.h"
#include "jansson/jansson.h"
#pragma warning(push)
#pragma warning(disable:4091)
#include <dbghelp.h>
#pragma warning(pop)

#else

#ifdef __GNUC__
#include "dbghelp/dbghelp.h"
#else
#pragma warning(push)
#pragma warning(disable:4091)
#include <dbghelp.h>
#pragma warning(pop)
#endif // __GNUC__

#ifndef deflen
#define deflen 1024
#endif // deflen

#include "bridgemain.h"
#include "_dbgfunctions.h"
#include "jansson/jansson.h"

#endif // BUILD_DBG

#endif // _PLUGIN_DATA_H



================================================
File: ClawSearch/pluginsdk/_plugins.h
================================================
#ifndef _PLUGINS_H
#define _PLUGINS_H

#ifndef __cplusplus
#include <stdbool.h>
#endif

#ifndef PLUG_IMPEXP
#ifdef BUILD_DBG
#define PLUG_IMPEXP __declspec(dllexport)
#else
#define PLUG_IMPEXP __declspec(dllimport)
#endif //BUILD_DBG
#endif //PLUG_IMPEXP

#include "_plugin_types.h"

//default structure alignments forced
#ifdef _WIN64
#pragma pack(push, 16)
#else //x86
#pragma pack(push, 8)
#endif //_WIN64

//defines
#define PLUG_SDKVERSION 1

#define PLUG_DB_LOADSAVE_DATA 1
#define PLUG_DB_LOADSAVE_ALL 2

//structures
typedef struct
{
    //provided by the debugger
    int pluginHandle;
    //provided by the pluginit function
    int sdkVersion;
    int pluginVersion;
    char pluginName[256];
} PLUG_INITSTRUCT;

typedef struct
{
    //provided by the debugger
    HWND hwndDlg; //gui window handle
    int hMenu; //plugin menu handle
    int hMenuDisasm; //plugin disasm menu handle
    int hMenuDump; //plugin dump menu handle
    int hMenuStack; //plugin stack menu handle
    int hMenuGraph; //plugin graph menu handle
    int hMenuMemmap; //plugin memory map menu handle
    int hMenuSymmod; //plugin symbol module menu handle
} PLUG_SETUPSTRUCT;

typedef struct
{
    void* data; //user data
} PLUG_SCRIPTSTRUCT;

//callback structures
typedef struct
{
    const char* szFileName;
} PLUG_CB_INITDEBUG;

typedef struct
{
    void* reserved;
} PLUG_CB_STOPDEBUG;

typedef struct
{
    CREATE_PROCESS_DEBUG_INFO* CreateProcessInfo;
    IMAGEHLP_MODULE64* modInfo;
    const char* DebugFileName;
    PROCESS_INFORMATION* fdProcessInfo;
} PLUG_CB_CREATEPROCESS;

typedef struct
{
    EXIT_PROCESS_DEBUG_INFO* ExitProcess;
} PLUG_CB_EXITPROCESS;

typedef struct
{
    CREATE_THREAD_DEBUG_INFO* CreateThread;
    DWORD dwThreadId;
} PLUG_CB_CREATETHREAD;

typedef struct
{
    EXIT_THREAD_DEBUG_INFO* ExitThread;
    DWORD dwThreadId;
} PLUG_CB_EXITTHREAD;

typedef struct
{
    void* reserved;
} PLUG_CB_SYSTEMBREAKPOINT;

typedef struct
{
    LOAD_DLL_DEBUG_INFO* LoadDll;
    IMAGEHLP_MODULE64* modInfo;
    const char* modname;
} PLUG_CB_LOADDLL;

typedef struct
{
    UNLOAD_DLL_DEBUG_INFO* UnloadDll;
} PLUG_CB_UNLOADDLL;

typedef struct
{
    OUTPUT_DEBUG_STRING_INFO* DebugString;
} PLUG_CB_OUTPUTDEBUGSTRING;

typedef struct
{
    EXCEPTION_DEBUG_INFO* Exception;
} PLUG_CB_EXCEPTION;

typedef struct
{
    BRIDGEBP* breakpoint;
} PLUG_CB_BREAKPOINT;

typedef struct
{
    void* reserved;
} PLUG_CB_PAUSEDEBUG;

typedef struct
{
    void* reserved;
} PLUG_CB_RESUMEDEBUG;

typedef struct
{
    void* reserved;
} PLUG_CB_STEPPED;

typedef struct
{
    DWORD dwProcessId;
} PLUG_CB_ATTACH;

typedef struct
{
    PROCESS_INFORMATION* fdProcessInfo;
} PLUG_CB_DETACH;

typedef struct
{
    DEBUG_EVENT* DebugEvent;
} PLUG_CB_DEBUGEVENT;

typedef struct
{
    int hEntry;
} PLUG_CB_MENUENTRY;

typedef struct
{
    MSG* message;
    long* result;
    bool retval;
} PLUG_CB_WINEVENT;

typedef struct
{
    MSG* message;
    bool retval;
} PLUG_CB_WINEVENTGLOBAL;

typedef struct
{
    json_t* root;
    int loadSaveType;
} PLUG_CB_LOADSAVEDB;

typedef struct
{
    const char* symbol;
    bool retval;
} PLUG_CB_FILTERSYMBOL;

typedef struct
{
    duint cip;
    bool stop;
} PLUG_CB_TRACEEXECUTE;

typedef struct
{
    int hWindow;
    duint VA;
} PLUG_CB_SELCHANGED;

typedef struct
{
    BridgeCFGraphList graph;
} PLUG_CB_ANALYZE;

typedef struct
{
    duint addr;
    BRIDGE_ADDRINFO* addrinfo;
    bool retval;
} PLUG_CB_ADDRINFO;

typedef struct
{
    const char* string;
    duint value;
    int* value_size;
    bool* isvar;
    bool* hexonly;
    bool retval;
} PLUG_CB_VALFROMSTRING;

typedef struct
{
    const char* string;
    duint value;
    bool retval;
} PLUG_CB_VALTOSTRING;

typedef struct
{
    GUIMENUTYPE hMenu;
} PLUG_CB_MENUPREPARE;

//enums
typedef enum
{
    CB_INITDEBUG, //PLUG_CB_INITDEBUG
    CB_STOPDEBUG, //PLUG_CB_STOPDEBUG
    CB_CREATEPROCESS, //PLUG_CB_CREATEPROCESS
    CB_EXITPROCESS, //PLUG_CB_EXITPROCESS
    CB_CREATETHREAD, //PLUG_CB_CREATETHREAD
    CB_EXITTHREAD, //PLUG_CB_EXITTHREAD
    CB_SYSTEMBREAKPOINT, //PLUG_CB_SYSTEMBREAKPOINT
    CB_LOADDLL, //PLUG_CB_LOADDLL
    CB_UNLOADDLL, //PLUG_CB_UNLOADDLL
    CB_OUTPUTDEBUGSTRING, //PLUG_CB_OUTPUTDEBUGSTRING
    CB_EXCEPTION, //PLUG_CB_EXCEPTION
    CB_BREAKPOINT, //PLUG_CB_BREAKPOINT
    CB_PAUSEDEBUG, //PLUG_CB_PAUSEDEBUG
    CB_RESUMEDEBUG, //PLUG_CB_RESUMEDEBUG
    CB_STEPPED, //PLUG_CB_STEPPED
    CB_ATTACH, //PLUG_CB_ATTACHED (before attaching, after CB_INITDEBUG)
    CB_DETACH, //PLUG_CB_DETACH (before detaching, before CB_STOPDEBUG)
    CB_DEBUGEVENT, //PLUG_CB_DEBUGEVENT (called on any debug event)
    CB_MENUENTRY, //PLUG_CB_MENUENTRY
    CB_WINEVENT, //PLUG_CB_WINEVENT
    CB_WINEVENTGLOBAL, //PLUG_CB_WINEVENTGLOBAL
    CB_LOADDB, //PLUG_CB_LOADSAVEDB
    CB_SAVEDB, //PLUG_CB_LOADSAVEDB
    CB_FILTERSYMBOL, //PLUG_CB_FILTERSYMBOL
    CB_TRACEEXECUTE, //PLUG_CB_TRACEEXECUTE
    CB_SELCHANGED, //PLUG_CB_SELCHANGED
    CB_ANALYZE, //PLUG_CB_ANALYZE
    CB_ADDRINFO, //PLUG_CB_ADDRINFO
    CB_VALFROMSTRING, //PLUG_CB_VALFROMSTRING
    CB_VALTOSTRING, //PLUG_CB_VALTOSTRING
    CB_MENUPREPARE, //PLUG_CB_MENUPREPARE
    CB_LAST
} CBTYPE;

typedef enum
{
    FORMAT_ERROR, //generic failure (no message)
    FORMAT_SUCCESS, //success
    FORMAT_ERROR_MESSAGE, //formatting failed but an error was put in the buffer (there are always at least 511 characters available).
    FORMAT_BUFFER_TOO_SMALL //buffer too small (x64dbg will retry until the buffer is big enough)
} FORMATRESULT;

//typedefs
typedef void (*CBPLUGIN)(CBTYPE cbType, void* callbackInfo);
typedef bool (*CBPLUGINCOMMAND)(int argc, char** argv);
typedef void (*CBPLUGINSCRIPT)();
typedef duint(*CBPLUGINEXPRFUNCTION)(int argc, duint* argv, void* userdata);
typedef FORMATRESULT(*CBPLUGINFORMATFUNCTION)(char* dest, size_t destCount, int argc, char* argv[], duint value, void* userdata);
typedef bool (*CBPLUGINPREDICATE)(void* userdata);

//exports
#ifdef __cplusplus
extern "C"
{
#endif

PLUG_IMPEXP void _plugin_registercallback(int pluginHandle, CBTYPE cbType, CBPLUGIN cbPlugin);
PLUG_IMPEXP bool _plugin_unregistercallback(int pluginHandle, CBTYPE cbType);
PLUG_IMPEXP bool _plugin_registercommand(int pluginHandle, const char* command, CBPLUGINCOMMAND cbCommand, bool debugonly);
PLUG_IMPEXP bool _plugin_unregistercommand(int pluginHandle, const char* command);
PLUG_IMPEXP void _plugin_logprintf(const char* format, ...);
PLUG_IMPEXP void _plugin_logputs(const char* text);
PLUG_IMPEXP void _plugin_logprint(const char* text);
PLUG_IMPEXP void _plugin_debugpause();
PLUG_IMPEXP void _plugin_debugskipexceptions(bool skip);
PLUG_IMPEXP int _plugin_menuadd(int hMenu, const char* title);
PLUG_IMPEXP bool _plugin_menuaddentry(int hMenu, int hEntry, const char* title);
PLUG_IMPEXP bool _plugin_menuaddseparator(int hMenu);
PLUG_IMPEXP bool _plugin_menuclear(int hMenu);
PLUG_IMPEXP void _plugin_menuseticon(int hMenu, const ICONDATA* icon);
PLUG_IMPEXP void _plugin_menuentryseticon(int pluginHandle, int hEntry, const ICONDATA* icon);
PLUG_IMPEXP void _plugin_menuentrysetchecked(int pluginHandle, int hEntry, bool checked);
PLUG_IMPEXP void _plugin_menusetvisible(int pluginHandle, int hMenu, bool visible);
PLUG_IMPEXP void _plugin_menuentrysetvisible(int pluginHandle, int hEntry, bool visible);
PLUG_IMPEXP void _plugin_menusetname(int pluginHandle, int hMenu, const char* name);
PLUG_IMPEXP void _plugin_menuentrysetname(int pluginHandle, int hEntry, const char* name);
PLUG_IMPEXP void _plugin_menuentrysethotkey(int pluginHandle, int hEntry, const char* hotkey);
PLUG_IMPEXP bool _plugin_menuremove(int hMenu);
PLUG_IMPEXP bool _plugin_menuentryremove(int pluginHandle, int hEntry);
PLUG_IMPEXP void _plugin_startscript(CBPLUGINSCRIPT cbScript);
PLUG_IMPEXP bool _plugin_waituntilpaused();
PLUG_IMPEXP bool _plugin_registerexprfunction(int pluginHandle, const char* name, int argc, CBPLUGINEXPRFUNCTION cbFunction, void* userdata);
PLUG_IMPEXP bool _plugin_unregisterexprfunction(int pluginHandle, const char* name);
PLUG_IMPEXP bool _plugin_unload(const char* pluginName);
PLUG_IMPEXP bool _plugin_load(const char* pluginName);
PLUG_IMPEXP duint _plugin_hash(const void* data, duint size);
PLUG_IMPEXP bool _plugin_registerformatfunction(int pluginHandle, const char* type, CBPLUGINFORMATFUNCTION cbFunction, void* userdata);
PLUG_IMPEXP bool _plugin_unregisterformatfunction(int pluginHandle, const char* type);

#ifdef __cplusplus
}
#endif

#pragma pack(pop)

#endif // _PLUGINS_H



================================================
File: ClawSearch/pluginsdk/_scriptapi.h
================================================
#ifndef _SCRIPT_API_H
#define _SCRIPT_API_H

#include "_plugins.h"

#define SCRIPT_EXPORT PLUG_IMPEXP

#endif //_SCRIPT_API_H


================================================
File: ClawSearch/pluginsdk/_scriptapi_argument.h
================================================
#ifndef _SCRIPTAPI_ARGUMENT_H
#define _SCRIPTAPI_ARGUMENT_H

#include "_scriptapi.h"

namespace Script
{
    namespace Argument
    {
        struct ArgumentInfo
        {
            char mod[MAX_MODULE_SIZE];
            duint rvaStart;
            duint rvaEnd;
            bool manual;
            duint instructioncount;
        };

        SCRIPT_EXPORT bool Add(duint start, duint end, bool manual, duint instructionCount = 0);
        SCRIPT_EXPORT bool Add(const ArgumentInfo* info);
        SCRIPT_EXPORT bool Get(duint addr, duint* start = nullptr, duint* end = nullptr, duint* instructionCount = nullptr);
        SCRIPT_EXPORT bool GetInfo(duint addr, ArgumentInfo* info);
        SCRIPT_EXPORT bool Overlaps(duint start, duint end);
        SCRIPT_EXPORT bool Delete(duint address);
        SCRIPT_EXPORT void DeleteRange(duint start, duint end, bool deleteManual = false);
        SCRIPT_EXPORT void Clear();
        SCRIPT_EXPORT bool GetList(ListOf(ArgumentInfo) list); //caller has the responsibility to free the list
    }; //Argument
}; //Script

#endif //_SCRIPTAPI_ARGUMENT_H


================================================
File: ClawSearch/pluginsdk/_scriptapi_assembler.h
================================================
#ifndef _SCRIPTAPI_ASSEMBLER_H
#define _SCRIPTAPI_ASSEMBLER_H

#include "_scriptapi.h"

namespace Script
{
    namespace Assembler
    {
        SCRIPT_EXPORT bool Assemble(duint addr, unsigned char* dest, int* size, const char* instruction); //dest[16]
        SCRIPT_EXPORT bool AssembleEx(duint addr, unsigned char* dest, int* size, const char* instruction, char* error); //dest[16], error[MAX_ERROR_SIZE]
        SCRIPT_EXPORT bool AssembleMem(duint addr, const char* instruction);
        SCRIPT_EXPORT bool AssembleMemEx(duint addr, const char* instruction, int* size, char* error, bool fillnop); //error[MAX_ERROR_SIZE]
    }; //Assembler
}; //Script

#endif //_SCRIPTAPI_ASSEMBLER_H


================================================
File: ClawSearch/pluginsdk/_scriptapi_bookmark.h
================================================
#ifndef _SCRIPTAPI_BOOKMARK_H
#define _SCRIPTAPI_BOOKMARK_H

#include "_scriptapi.h"

namespace Script
{
    namespace Bookmark
    {
        struct BookmarkInfo
        {
            char mod[MAX_MODULE_SIZE];
            duint rva;
            bool manual;
        };

        SCRIPT_EXPORT bool Set(duint addr, bool manual = false);
        SCRIPT_EXPORT bool Set(const BookmarkInfo* info);
        SCRIPT_EXPORT bool Get(duint addr);
        SCRIPT_EXPORT bool GetInfo(duint addr, BookmarkInfo* info);
        SCRIPT_EXPORT bool Delete(duint addr);
        SCRIPT_EXPORT void DeleteRange(duint start, duint end);
        SCRIPT_EXPORT void Clear();
        SCRIPT_EXPORT bool GetList(ListOf(BookmarkInfo) list); //caller has the responsibility to free the list
    }; //Bookmark
}; //Script

#endif //_SCRIPTAPI_BOOKMARK_H


================================================
File: ClawSearch/pluginsdk/_scriptapi_comment.h
================================================
#ifndef _SCRIPTAPI_COMMENT_H
#define _SCRIPTAPI_COMMENT_H

#include "_scriptapi.h"

namespace Script
{
    namespace Comment
    {
        struct CommentInfo
        {
            char mod[MAX_MODULE_SIZE];
            duint rva;
            char text[MAX_LABEL_SIZE];
            bool manual;
        };

        SCRIPT_EXPORT bool Set(duint addr, const char* text, bool manual = false);
        SCRIPT_EXPORT bool Set(const CommentInfo* info);
        SCRIPT_EXPORT bool Get(duint addr, char* text); //text[MAX_COMMENT_SIZE]
        SCRIPT_EXPORT bool GetInfo(duint addr, CommentInfo* info);
        SCRIPT_EXPORT bool Delete(duint addr);
        SCRIPT_EXPORT void DeleteRange(duint start, duint end);
        SCRIPT_EXPORT void Clear();
        SCRIPT_EXPORT bool GetList(ListOf(CommentInfo) list); //caller has the responsibility to free the list
    }; //Comment
}; //Script

#endif //_SCRIPTAPI_COMMENT_H


================================================
File: ClawSearch/pluginsdk/_scriptapi_debug.h
================================================
#ifndef _SCRIPTAPI_DEBUG_H
#define _SCRIPTAPI_DEBUG_H

#include "_scriptapi.h"

namespace Script
{
    namespace Debug
    {
        enum HardwareType
        {
            HardwareAccess,
            HardwareWrite,
            HardwareExecute
        };

        SCRIPT_EXPORT void Wait();
        SCRIPT_EXPORT void Run();
        SCRIPT_EXPORT void Pause();
        SCRIPT_EXPORT void Stop();
        SCRIPT_EXPORT void StepIn();
        SCRIPT_EXPORT void StepOver();
        SCRIPT_EXPORT void StepOut();
        SCRIPT_EXPORT bool SetBreakpoint(duint address);
        SCRIPT_EXPORT bool DeleteBreakpoint(duint address);
        SCRIPT_EXPORT bool DisableBreakpoint(duint address);
        SCRIPT_EXPORT bool SetHardwareBreakpoint(duint address, HardwareType type = HardwareExecute);
        SCRIPT_EXPORT bool DeleteHardwareBreakpoint(duint address);
    }; //Debug
}; //Script

#endif //_SCRIPTAPI_DEBUG_H


================================================
File: ClawSearch/pluginsdk/_scriptapi_flag.h
================================================
#ifndef _SCRIPTAPI_FLAG_H
#define _SCRIPTAPI_FLAG_H

#include "_scriptapi.h"

namespace Script
{
    namespace Flag
    {
        enum FlagEnum
        {
            ZF,
            OF,
            CF,
            PF,
            SF,
            TF,
            AF,
            DF,
            IF
        };

        SCRIPT_EXPORT bool Get(FlagEnum flag);
        SCRIPT_EXPORT bool Set(FlagEnum flag, bool value);

        SCRIPT_EXPORT bool GetZF();
        SCRIPT_EXPORT bool SetZF(bool value);
        SCRIPT_EXPORT bool GetOF();
        SCRIPT_EXPORT bool SetOF(bool value);
        SCRIPT_EXPORT bool GetCF();
        SCRIPT_EXPORT bool SetCF(bool value);
        SCRIPT_EXPORT bool GetPF();
        SCRIPT_EXPORT bool SetPF(bool value);
        SCRIPT_EXPORT bool GetSF();
        SCRIPT_EXPORT bool SetSF(bool value);
        SCRIPT_EXPORT bool GetTF();
        SCRIPT_EXPORT bool SetTF(bool value);
        SCRIPT_EXPORT bool GetAF();
        SCRIPT_EXPORT bool SetAF(bool value);
        SCRIPT_EXPORT bool GetDF();
        SCRIPT_EXPORT bool SetDF(bool value);
        SCRIPT_EXPORT bool GetIF();
        SCRIPT_EXPORT bool SetIF(bool value);
    };
};

#endif //_SCRIPTAPI_FLAG_H


================================================
File: ClawSearch/pluginsdk/_scriptapi_function.h
================================================
#ifndef _SCRIPTAPI_FUNCTION_H
#define _SCRIPTAPI_FUNCTION_H

#include "_scriptapi.h"

namespace Script
{
    namespace Function
    {
        struct FunctionInfo
        {
            char mod[MAX_MODULE_SIZE];
            duint rvaStart;
            duint rvaEnd;
            bool manual;
            duint instructioncount;
        };

        SCRIPT_EXPORT bool Add(duint start, duint end, bool manual, duint instructionCount = 0);
        SCRIPT_EXPORT bool Add(const FunctionInfo* info);
        SCRIPT_EXPORT bool Get(duint addr, duint* start = nullptr, duint* end = nullptr, duint* instructionCount = nullptr);
        SCRIPT_EXPORT bool GetInfo(duint addr, FunctionInfo* info);
        SCRIPT_EXPORT bool Overlaps(duint start, duint end);
        SCRIPT_EXPORT bool Delete(duint address);
        SCRIPT_EXPORT void DeleteRange(duint start, duint end, bool deleteManual);
        SCRIPT_EXPORT void DeleteRange(duint start, duint end);
        SCRIPT_EXPORT void Clear();
        SCRIPT_EXPORT bool GetList(ListOf(FunctionInfo) list); //caller has the responsibility to free the list
    }; //Function
}; //Script

#endif //_SCRIPTAPI_FUNCTION_H



================================================
File: ClawSearch/pluginsdk/_scriptapi_gui.h
================================================
#ifndef _SCRIPTAPI_GUI_H
#define _SCRIPTAPI_GUI_H

#include "_scriptapi.h"

namespace Script
{
    namespace Gui
    {
        namespace Disassembly
        {
            SCRIPT_EXPORT bool SelectionGet(duint* start, duint* end);
            SCRIPT_EXPORT bool SelectionSet(duint start, duint end);
            SCRIPT_EXPORT duint SelectionGetStart();
            SCRIPT_EXPORT duint SelectionGetEnd();
        }; //Disassembly

        namespace Dump
        {
            SCRIPT_EXPORT bool SelectionGet(duint* start, duint* end);
            SCRIPT_EXPORT bool SelectionSet(duint start, duint end);
            SCRIPT_EXPORT duint SelectionGetStart();
            SCRIPT_EXPORT duint SelectionGetEnd();
        }; //Dump

        namespace Stack
        {
            SCRIPT_EXPORT bool SelectionGet(duint* start, duint* end);
            SCRIPT_EXPORT bool SelectionSet(duint start, duint end);
            SCRIPT_EXPORT duint SelectionGetStart();
            SCRIPT_EXPORT duint SelectionGetEnd();
        }; //Stack

        namespace Graph
        {
            SCRIPT_EXPORT duint SelectionGetStart();
        }; //Graph

        namespace MemMap
        {
            SCRIPT_EXPORT duint SelectionGetStart();
        }; //MemoryMap

        namespace SymMod
        {
            SCRIPT_EXPORT duint SelectionGetStart();
        }; //SymMod
    }; //Gui

    namespace Gui
    {
        enum Window
        {
            DisassemblyWindow,
            DumpWindow,
            StackWindow,
            GraphWindow,
            MemMapWindow,
            SymModWindow
        };

        SCRIPT_EXPORT bool SelectionGet(Window window, duint* start, duint* end);
        SCRIPT_EXPORT bool SelectionSet(Window window, duint start, duint end);
        SCRIPT_EXPORT duint SelectionGetStart(Window window);
        SCRIPT_EXPORT duint SelectionGetEnd(Window window);
        SCRIPT_EXPORT void Message(const char* message);
        SCRIPT_EXPORT bool MessageYesNo(const char* message);
        SCRIPT_EXPORT bool InputLine(const char* title, char* text); //text[GUI_MAX_LINE_SIZE]
        SCRIPT_EXPORT bool InputValue(const char* title, duint* value);
        SCRIPT_EXPORT void Refresh();
        SCRIPT_EXPORT void AddQWidgetTab(void* qWidget);
        SCRIPT_EXPORT void ShowQWidgetTab(void* qWidget);
        SCRIPT_EXPORT void CloseQWidgetTab(void* qWidget);

    }; //Gui
}; //Script

#endif //_SCRIPTAPI_GUI_H


================================================
File: ClawSearch/pluginsdk/_scriptapi_label.h
================================================
#ifndef _SCRIPTAPI_LABEL_H
#define _SCRIPTAPI_LABEL_H

#include "_scriptapi.h"

namespace Script
{
    namespace Label
    {
        struct LabelInfo
        {
            char mod[MAX_MODULE_SIZE];
            duint rva;
            char text[MAX_LABEL_SIZE];
            bool manual;
        };

        SCRIPT_EXPORT bool Set(duint addr, const char* text, bool manual = false);
        SCRIPT_EXPORT bool Set(const LabelInfo* info);
        SCRIPT_EXPORT bool FromString(const char* label, duint* addr);
        SCRIPT_EXPORT bool Get(duint addr, char* text); //text[MAX_LABEL_SIZE]
        SCRIPT_EXPORT bool GetInfo(duint addr, LabelInfo* info);
        SCRIPT_EXPORT bool Delete(duint addr);
        SCRIPT_EXPORT void DeleteRange(duint start, duint end);
        SCRIPT_EXPORT void Clear();
        SCRIPT_EXPORT bool GetList(ListOf(LabelInfo) list); //caller has the responsibility to free the list
    }; //Label
}; //Script

#endif //_SCRIPTAPI_LABEL_H


================================================
File: ClawSearch/pluginsdk/_scriptapi_memory.h
================================================
#ifndef _SCRIPTAPI_MEMORY_H
#define _SCRIPTAPI_MEMORY_H

#include "_scriptapi.h"

namespace Script
{
    namespace Memory
    {
        SCRIPT_EXPORT bool Read(duint addr, void* data, duint size, duint* sizeRead);
        SCRIPT_EXPORT bool Write(duint addr, const void* data, duint size, duint* sizeWritten);
        SCRIPT_EXPORT bool IsValidPtr(duint addr);
        SCRIPT_EXPORT duint RemoteAlloc(duint addr, duint size);
        SCRIPT_EXPORT bool RemoteFree(duint addr);
        SCRIPT_EXPORT unsigned int GetProtect(duint addr, bool reserved = false, bool cache = true);
        SCRIPT_EXPORT duint GetBase(duint addr, bool reserved = false, bool cache = true);
        SCRIPT_EXPORT duint GetSize(duint addr, bool reserved = false, bool cache = true);

        SCRIPT_EXPORT unsigned char ReadByte(duint addr);
        SCRIPT_EXPORT bool WriteByte(duint addr, unsigned char data);
        SCRIPT_EXPORT unsigned short ReadWord(duint addr);
        SCRIPT_EXPORT bool WriteWord(duint addr, unsigned short data);
        SCRIPT_EXPORT unsigned int ReadDword(duint addr);
        SCRIPT_EXPORT bool WriteDword(duint addr, unsigned int data);
        SCRIPT_EXPORT unsigned long long ReadQword(duint addr);
        SCRIPT_EXPORT bool WriteQword(duint addr, unsigned long long data);
        SCRIPT_EXPORT duint ReadPtr(duint addr);
        SCRIPT_EXPORT bool WritePtr(duint addr, duint data);
    }; //Memory
}; //Script

#endif //_SCRIPTAPI_MEMORY_H


================================================
File: ClawSearch/pluginsdk/_scriptapi_misc.h
================================================
#ifndef _SCRIPTAPI_MISC_H
#define _SCRIPTAPI_MISC_H

#include "_scriptapi.h"

namespace Script
{
    namespace Misc
    {
        /// <summary>
        /// Evaluates an expression and returns the result. Analagous to using the Command field in x64dbg.
        ///
        /// Expressions can consist of memory locations, registers, flags, API names, labels, symbols, variables etc.
        ///
        /// Example: bool success = ParseExpression("[esp+8]", &val)
        /// </summary>
        /// <param name="expression">The expression to evaluate.</param>
        /// <param name="value">The result of the expression.</param>
        /// <returns>True on success, False on failure.</returns>
        SCRIPT_EXPORT bool ParseExpression(const char* expression, duint* value);

        /// <summary>
        /// Returns the address of a function in the debuggee's memory space.
        ///
        /// Example: duint addr = RemoteGetProcAddress("kernel32.dll", "GetProcAddress")
        /// </summary>
        /// <param name="module">The name of the module.</param>
        /// <param name="api">The name of the function.</param>
        /// <returns>The address of the function in the debuggee.</returns>
        SCRIPT_EXPORT duint RemoteGetProcAddress(const char* module, const char* api);

        /// <summary>
        /// Returns the address for a label created in the disassembly window.
        ///
        /// Example: duint addr = ResolveLabel("sneaky_crypto")
        /// </summary>
        /// <param name="label">The name of the label to resolve.</param>
        /// <returns>The memory address for the label.</returns>
        SCRIPT_EXPORT duint ResolveLabel(const char* label);

        /// <summary>
        /// Allocates the requested number of bytes from x64dbg's default process heap.
        ///
        /// Note: this allocation is in the debugger, not the debuggee.
        ///
        /// Memory allocated using this function should be Free'd after use.
        ///
        /// Example: void* addr = Alloc(0x100000)
        /// </summary>
        /// <param name="size">Number of bytes to allocate.</param>
        /// <returns>A pointer to the newly allocated memory.</returns>
        SCRIPT_EXPORT void* Alloc(duint size);

        /// <summary>
        /// Frees memory previously allocated by Alloc.
        ///
        /// Example: Free(addr)
        /// </summary>
        /// <param name="ptr">Pointer returned by Alloc.</param>
        /// <returns>Nothing.</returns>
        SCRIPT_EXPORT void Free(void* ptr);
    }; //Misc
}; //Script

#endif //_SCRIPTAPI_MISC_H


================================================
File: ClawSearch/pluginsdk/_scriptapi_module.h
================================================
#ifndef _SCRIPTAPI_MODULE_H
#define _SCRIPTAPI_MODULE_H

#include "_scriptapi.h"

namespace Script
{
    namespace Module
    {
        struct ModuleInfo
        {
            duint base;
            duint size;
            duint entry;
            int sectionCount;
            char name[MAX_MODULE_SIZE];
            char path[MAX_PATH];
        };

        struct ModuleSectionInfo
        {
            duint addr;
            duint size;
            char name[MAX_SECTION_SIZE * 5];
        };

        struct ModuleExport
        {
            duint ordinal;
            duint rva;
            duint va;
            bool forwarded;
            char forwardName[MAX_STRING_SIZE];
            char name[MAX_STRING_SIZE];
            char undecoratedName[MAX_STRING_SIZE];
        };

        struct ModuleImport
        {
            duint iatRva;
            duint iatVa;
            duint ordinal; //equal to -1 if imported by name
            char name[MAX_STRING_SIZE];
            char undecoratedName[MAX_STRING_SIZE];
        };

        SCRIPT_EXPORT bool InfoFromAddr(duint addr, ModuleInfo* info);
        SCRIPT_EXPORT bool InfoFromName(const char* name, ModuleInfo* info);
        SCRIPT_EXPORT duint BaseFromAddr(duint addr);
        SCRIPT_EXPORT duint BaseFromName(const char* name);
        SCRIPT_EXPORT duint SizeFromAddr(duint addr);
        SCRIPT_EXPORT duint SizeFromName(const char* name);
        SCRIPT_EXPORT bool NameFromAddr(duint addr, char* name); //name[MAX_MODULE_SIZE]
        SCRIPT_EXPORT bool PathFromAddr(duint addr, char* path); //path[MAX_PATH]
        SCRIPT_EXPORT bool PathFromName(const char* name, char* path); //path[MAX_PATH]
        SCRIPT_EXPORT duint EntryFromAddr(duint addr);
        SCRIPT_EXPORT duint EntryFromName(const char* name);
        SCRIPT_EXPORT int SectionCountFromAddr(duint addr);
        SCRIPT_EXPORT int SectionCountFromName(const char* name);
        SCRIPT_EXPORT bool SectionFromAddr(duint addr, int number, ModuleSectionInfo* section);
        SCRIPT_EXPORT bool SectionFromName(const char* name, int number, ModuleSectionInfo* section);
        SCRIPT_EXPORT bool SectionListFromAddr(duint addr, ListOf(ModuleSectionInfo) list);
        SCRIPT_EXPORT bool SectionListFromName(const char* name, ListOf(ModuleSectionInfo) list);
        SCRIPT_EXPORT bool GetMainModuleInfo(ModuleInfo* info);
        SCRIPT_EXPORT duint GetMainModuleBase();
        SCRIPT_EXPORT duint GetMainModuleSize();
        SCRIPT_EXPORT duint GetMainModuleEntry();
        SCRIPT_EXPORT int GetMainModuleSectionCount();
        SCRIPT_EXPORT bool GetMainModuleName(char* name); //name[MAX_MODULE_SIZE]
        SCRIPT_EXPORT bool GetMainModulePath(char* path); //path[MAX_PATH]
        SCRIPT_EXPORT bool GetMainModuleSectionList(ListOf(ModuleSectionInfo) list); //caller has the responsibility to free the list
        SCRIPT_EXPORT bool GetList(ListOf(ModuleInfo) list); //caller has the responsibility to free the list
        SCRIPT_EXPORT bool GetExports(const ModuleInfo* mod, ListOf(ModuleExport) list); //caller has the responsibility to free the list
        SCRIPT_EXPORT bool GetImports(const ModuleInfo* mod, ListOf(ModuleImport) list); //caller has the responsibility to free the list
    }; //Module
}; //Script

#endif //_SCRIPTAPI_MODULE_H



================================================
File: ClawSearch/pluginsdk/_scriptapi_pattern.h
================================================
#ifndef _SCRIPTAPI_PATTERN_H
#define _SCRIPTAPI_PATTERN_H

#include "_scriptapi.h"

namespace Script
{
    namespace Pattern
    {
        SCRIPT_EXPORT duint Find(unsigned char* data, duint datasize, const char* pattern);
        SCRIPT_EXPORT duint FindMem(duint start, duint size, const char* pattern);
        SCRIPT_EXPORT void Write(unsigned char* data, duint datasize, const char* pattern);
        SCRIPT_EXPORT void WriteMem(duint start, duint size, const char* pattern);
        SCRIPT_EXPORT bool SearchAndReplace(unsigned char* data, duint datasize, const char* searchpattern, const char* replacepattern);
        SCRIPT_EXPORT bool SearchAndReplaceMem(duint start, duint size, const char* searchpattern, const char* replacepattern);
    };
};

#endif //_SCRIPTAPI_FIND_H


================================================
File: ClawSearch/pluginsdk/_scriptapi_register.h
================================================
#ifndef _SCRIPTAPI_REGISTER_H
#define _SCRIPTAPI_REGISTER_H

#include "_scriptapi.h"

namespace Script
{
    namespace Register
    {
        enum RegisterEnum
        {
            DR0,
            DR1,
            DR2,
            DR3,
            DR6,
            DR7,

            EAX,
            AX,
            AH,
            AL,
            EBX,
            BX,
            BH,
            BL,
            ECX,
            CX,
            CH,
            CL,
            EDX,
            DX,
            DH,
            DL,
            EDI,
            DI,
            ESI,
            SI,
            EBP,
            BP,
            ESP,
            SP,
            EIP,

#ifdef _WIN64
            RAX,
            RBX,
            RCX,
            RDX,
            RSI,
            SIL,
            RDI,
            DIL,
            RBP,
            BPL,
            RSP,
            SPL,
            RIP,
            R8,
            R8D,
            R8W,
            R8B,
            R9,
            R9D,
            R9W,
            R9B,
            R10,
            R10D,
            R10W,
            R10B,
            R11,
            R11D,
            R11W,
            R11B,
            R12,
            R12D,
            R12W,
            R12B,
            R13,
            R13D,
            R13W,
            R13B,
            R14,
            R14D,
            R14W,
            R14B,
            R15,
            R15D,
            R15W,
            R15B,
#endif //_WIN64

            CIP,
            CSP,
            CAX,
            CBX,
            CCX,
            CDX,
            CDI,
            CSI,
            CBP,
            CFLAGS
        }; //RegisterEnum

        SCRIPT_EXPORT duint Get(RegisterEnum reg);
        SCRIPT_EXPORT bool Set(RegisterEnum reg, duint value);
        SCRIPT_EXPORT int Size(); //gets architecture register size in bytes

        SCRIPT_EXPORT duint GetDR0();
        SCRIPT_EXPORT bool SetDR0(duint value);
        SCRIPT_EXPORT duint GetDR1();
        SCRIPT_EXPORT bool SetDR1(duint value);
        SCRIPT_EXPORT duint GetDR2();
        SCRIPT_EXPORT bool SetDR2(duint value);
        SCRIPT_EXPORT duint GetDR3();
        SCRIPT_EXPORT bool SetDR3(duint value);
        SCRIPT_EXPORT duint GetDR6();
        SCRIPT_EXPORT bool SetDR6(duint value);
        SCRIPT_EXPORT duint GetDR7();
        SCRIPT_EXPORT bool SetDR7(duint value);

        SCRIPT_EXPORT unsigned int GetEAX();
        SCRIPT_EXPORT bool SetEAX(unsigned int value);
        SCRIPT_EXPORT unsigned short GetAX();
        SCRIPT_EXPORT bool SetAX(unsigned short value);
        SCRIPT_EXPORT unsigned char GetAH();
        SCRIPT_EXPORT bool SetAH(unsigned char value);
        SCRIPT_EXPORT unsigned char GetAL();
        SCRIPT_EXPORT bool SetAL(unsigned char value);
        SCRIPT_EXPORT unsigned int GetEBX();
        SCRIPT_EXPORT bool SetEBX(unsigned int value);
        SCRIPT_EXPORT unsigned short GetBX();
        SCRIPT_EXPORT bool SetBX(unsigned short value);
        SCRIPT_EXPORT unsigned char GetBH();
        SCRIPT_EXPORT bool SetBH(unsigned char value);
        SCRIPT_EXPORT unsigned char GetBL();
        SCRIPT_EXPORT bool SetBL(unsigned char value);
        SCRIPT_EXPORT unsigned int GetECX();
        SCRIPT_EXPORT bool SetECX(unsigned int value);
        SCRIPT_EXPORT unsigned short GetCX();
        SCRIPT_EXPORT bool SetCX(unsigned short value);
        SCRIPT_EXPORT unsigned char GetCH();
        SCRIPT_EXPORT bool SetCH(unsigned char value);
        SCRIPT_EXPORT unsigned char GetCL();
        SCRIPT_EXPORT bool SetCL(unsigned char value);
        SCRIPT_EXPORT unsigned int GetEDX();
        SCRIPT_EXPORT bool SetEDX(unsigned int value);
        SCRIPT_EXPORT unsigned short GetDX();
        SCRIPT_EXPORT bool SetDX(unsigned short value);
        SCRIPT_EXPORT unsigned char GetDH();
        SCRIPT_EXPORT bool SetDH(unsigned char value);
        SCRIPT_EXPORT unsigned char GetDL();
        SCRIPT_EXPORT bool SetDL(unsigned char value);
        SCRIPT_EXPORT unsigned int GetEDI();
        SCRIPT_EXPORT bool SetEDI(unsigned int value);
        SCRIPT_EXPORT unsigned short GetDI();
        SCRIPT_EXPORT bool SetDI(unsigned short value);
        SCRIPT_EXPORT unsigned int GetESI();
        SCRIPT_EXPORT bool SetESI(unsigned int value);
        SCRIPT_EXPORT unsigned short GetSI();
        SCRIPT_EXPORT bool SetSI(unsigned short value);
        SCRIPT_EXPORT unsigned int GetEBP();
        SCRIPT_EXPORT bool SetEBP(unsigned int value);
        SCRIPT_EXPORT unsigned short GetBP();
        SCRIPT_EXPORT bool SetBP(unsigned short value);
        SCRIPT_EXPORT unsigned int GetESP();
        SCRIPT_EXPORT bool SetESP(unsigned int value);
        SCRIPT_EXPORT unsigned short GetSP();
        SCRIPT_EXPORT bool SetSP(unsigned short value);
        SCRIPT_EXPORT unsigned int GetEIP();
        SCRIPT_EXPORT bool SetEIP(unsigned int value);

#ifdef _WIN64
        SCRIPT_EXPORT unsigned long long GetRAX();
        SCRIPT_EXPORT bool SetRAX(unsigned long long value);
        SCRIPT_EXPORT unsigned long long GetRBX();
        SCRIPT_EXPORT bool SetRBX(unsigned long long value);
        SCRIPT_EXPORT unsigned long long GetRCX();
        SCRIPT_EXPORT bool SetRCX(unsigned long long value);
        SCRIPT_EXPORT unsigned long long GetRDX();
        SCRIPT_EXPORT bool SetRDX(unsigned long long value);
        SCRIPT_EXPORT unsigned long long GetRSI();
        SCRIPT_EXPORT bool SetRSI(unsigned long long value);
        SCRIPT_EXPORT unsigned char GetSIL();
        SCRIPT_EXPORT bool SetSIL(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetRDI();
        SCRIPT_EXPORT bool SetRDI(unsigned long long value);
        SCRIPT_EXPORT unsigned char GetDIL();
        SCRIPT_EXPORT bool SetDIL(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetRBP();
        SCRIPT_EXPORT bool SetRBP(unsigned long long value);
        SCRIPT_EXPORT unsigned char GetBPL();
        SCRIPT_EXPORT bool SetBPL(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetRSP();
        SCRIPT_EXPORT bool SetRSP(unsigned long long value);
        SCRIPT_EXPORT unsigned char GetSPL();
        SCRIPT_EXPORT bool SetSPL(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetRIP();
        SCRIPT_EXPORT bool SetRIP(unsigned long long value);
        SCRIPT_EXPORT unsigned long long GetR8();
        SCRIPT_EXPORT bool SetR8(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR8D();
        SCRIPT_EXPORT bool SetR8D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR8W();
        SCRIPT_EXPORT bool SetR8W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR8B();
        SCRIPT_EXPORT bool SetR8B(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetR9();
        SCRIPT_EXPORT bool SetR9(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR9D();
        SCRIPT_EXPORT bool SetR9D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR9W();
        SCRIPT_EXPORT bool SetR9W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR9B();
        SCRIPT_EXPORT bool SetR9B(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetR10();
        SCRIPT_EXPORT bool SetR10(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR10D();
        SCRIPT_EXPORT bool SetR10D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR10W();
        SCRIPT_EXPORT bool SetR10W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR10B();
        SCRIPT_EXPORT bool SetR10B(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetR11();
        SCRIPT_EXPORT bool SetR11(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR11D();
        SCRIPT_EXPORT bool SetR11D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR11W();
        SCRIPT_EXPORT bool SetR11W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR11B();
        SCRIPT_EXPORT bool SetR11B(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetR12();
        SCRIPT_EXPORT bool SetR12(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR12D();
        SCRIPT_EXPORT bool SetR12D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR12W();
        SCRIPT_EXPORT bool SetR12W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR12B();
        SCRIPT_EXPORT bool SetR12B(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetR13();
        SCRIPT_EXPORT bool SetR13(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR13D();
        SCRIPT_EXPORT bool SetR13D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR13W();
        SCRIPT_EXPORT bool SetR13W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR13B();
        SCRIPT_EXPORT bool SetR13B(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetR14();
        SCRIPT_EXPORT bool SetR14(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR14D();
        SCRIPT_EXPORT bool SetR14D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR14W();
        SCRIPT_EXPORT bool SetR14W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR14B();
        SCRIPT_EXPORT bool SetR14B(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetR15();
        SCRIPT_EXPORT bool SetR15(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR15D();
        SCRIPT_EXPORT bool SetR15D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR15W();
        SCRIPT_EXPORT bool SetR15W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR15B();
        SCRIPT_EXPORT bool SetR15B(unsigned char value);
#endif //_WIN64

        SCRIPT_EXPORT duint GetCAX();
        SCRIPT_EXPORT bool SetCAX(duint value);
        SCRIPT_EXPORT duint GetCBX();
        SCRIPT_EXPORT bool SetCBX(duint value);
        SCRIPT_EXPORT duint GetCCX();
        SCRIPT_EXPORT bool SetCCX(duint value);
        SCRIPT_EXPORT duint GetCDX();
        SCRIPT_EXPORT bool SetCDX(duint value);
        SCRIPT_EXPORT duint GetCDI();
        SCRIPT_EXPORT bool SetCDI(duint value);
        SCRIPT_EXPORT duint GetCSI();
        SCRIPT_EXPORT bool SetCSI(duint value);
        SCRIPT_EXPORT duint GetCBP();
        SCRIPT_EXPORT bool SetCBP(duint value);
        SCRIPT_EXPORT duint GetCSP();
        SCRIPT_EXPORT bool SetCSP(duint value);
        SCRIPT_EXPORT duint GetCIP();
        SCRIPT_EXPORT bool SetCIP(duint value);
        SCRIPT_EXPORT duint GetCFLAGS();
        SCRIPT_EXPORT bool SetCFLAGS(duint value);
    }; //Register
}; //Script

#endif //_SCRIPTAPI_REGISTER_H


================================================
File: ClawSearch/pluginsdk/_scriptapi_stack.h
================================================
#ifndef _SCRIPTAPI_STACK_H
#define _SCRIPTAPI_STACK_H

#include "_scriptapi.h"

namespace Script
{
    namespace Stack
    {
        SCRIPT_EXPORT duint Pop();
        SCRIPT_EXPORT duint Push(duint value); //returns the previous top, equal to Peek(1)
        SCRIPT_EXPORT duint Peek(int offset = 0); //offset is in multiples of Register::Size(), for easy x32/x64 portability
    }; //Stack
}; //Script

#endif //_SCRIPTAPI_STACK_H


================================================
File: ClawSearch/pluginsdk/_scriptapi_symbol.h
================================================
#ifndef _SCRIPTAPI_SYMBOL_H
#define _SCRIPTAPI_SYMBOL_H

#include "_scriptapi.h"

namespace Script
{
    namespace Symbol
    {
        enum SymbolType
        {
            Function, //user-defined function
            Import, //IAT entry
            Export //export
        };

        struct SymbolInfo
        {
            char mod[MAX_MODULE_SIZE];
            duint rva;
            char name[MAX_LABEL_SIZE];
            bool manual;
            SymbolType type;
        };

        SCRIPT_EXPORT bool GetList(ListOf(SymbolInfo) list); //caller has the responsibility to free the list
    }; //Symbol
}; //Script

#endif //_SCRIPTAPI_SYMBOL_H


================================================
File: ClawSearch/pluginsdk/bridgegraph.h
================================================
#ifndef _GRAPH_H
#define _GRAPH_H

typedef struct
{
    duint addr; //virtual address of the instruction
    unsigned char data[15]; //instruction bytes
} BridgeCFInstruction;

typedef struct
{
    duint parentGraph; //function of which this node is a part
    duint start; //start of the block
    duint end; //end of the block (inclusive)
    duint brtrue; //destination if condition is true
    duint brfalse; //destination if condition is false
    duint icount; //number of instructions in node
    bool terminal; //node is a RET
    bool split; //node is a split (brtrue points to the next node)
    bool indirectcall; //node contains indirect calls (call reg, call [reg+X])
    void* userdata; //user data
    ListInfo exits; //exits (including brtrue and brfalse, duint)
    ListInfo instrs; //block instructions
} BridgeCFNodeList;

typedef struct
{
    duint entryPoint; //graph entry point
    void* userdata; //user data
    ListInfo nodes; //graph nodes (BridgeCFNodeList)
} BridgeCFGraphList;

#ifdef __cplusplus
#if _MSC_VER >= 1700 && !defined(NO_CPP11)

#include <unordered_map>
#include <unordered_set>
#include <vector>
#include <utility>

struct BridgeCFNode
{
    duint parentGraph = 0; //function of which this node is a part
    duint start = 0; //va of the first instruction in the block
    duint end = 0; //va of the last instruction in the block (inclusive)
    duint brtrue = 0; //destination if condition is true
    duint brfalse = 0; //destination if condition is false
    duint icount = 0; //number of instructions in node
    bool terminal = false; //node is a RET
    bool split = false; //node is a split (brtrue points to the next node)
    bool indirectcall = false; //node contains indirect calls (call reg, call [reg+X])
    void* userdata = nullptr; //user data
    std::vector<duint> exits; //exits (including brtrue and brfalse)
    std::vector<BridgeCFInstruction> instrs; //block instructions

    static void Free(const BridgeCFNodeList* nodeList)
    {
        if(!BridgeList<duint>::Free(&nodeList->exits))
            __debugbreak();
        if(!BridgeList<BridgeCFInstruction>::Free(&nodeList->instrs))
            __debugbreak();
    }

    BridgeCFNode() = default;

    BridgeCFNode(const BridgeCFNodeList* nodeList, bool freedata)
    {
        if(!nodeList)
            __debugbreak();
        parentGraph = nodeList->parentGraph;
        start = nodeList->start;
        end = nodeList->end;
        brtrue = nodeList->brtrue;
        brfalse = nodeList->brfalse;
        icount = nodeList->icount;
        terminal = nodeList->terminal;
        indirectcall = nodeList->indirectcall;
        split = nodeList->split;
        userdata = nodeList->userdata;
        if(!BridgeList<duint>::ToVector(&nodeList->exits, exits, freedata))
            __debugbreak();
        if(!BridgeList<BridgeCFInstruction>::ToVector(&nodeList->instrs, instrs, freedata))
            __debugbreak();
    }

    BridgeCFNode(duint parentGraph, duint start, duint end)
        : parentGraph(parentGraph),
          start(start),
          end(end)
    {
    }

    BridgeCFNodeList ToNodeList() const
    {
        BridgeCFNodeList out;
        out.parentGraph = parentGraph;
        out.start = start;
        out.end = end;
        out.brtrue = brtrue;
        out.brfalse = brfalse;
        out.icount = icount;
        out.terminal = terminal;
        out.indirectcall = indirectcall;
        out.split = split;
        out.userdata = userdata;
        BridgeList<duint>::CopyData(&out.exits, exits);
        BridgeList<BridgeCFInstruction>::CopyData(&out.instrs, instrs);
        return std::move(out);
    }
};

struct BridgeCFGraph
{
    duint entryPoint; //graph entry point
    void* userdata; //user data
    std::unordered_map<duint, BridgeCFNode> nodes; //CFNode.start -> CFNode
    std::unordered_map<duint, std::unordered_set<duint>> parents; //CFNode.start -> parents

    static void Free(const BridgeCFGraphList* graphList)
    {
        if(!graphList || graphList->nodes.size != graphList->nodes.count * sizeof(BridgeCFNodeList))
            __debugbreak();
        auto data = (BridgeCFNodeList*)graphList->nodes.data;
        for(int i = 0; i < graphList->nodes.count; i++)
            BridgeCFNode::Free(&data[i]);
        BridgeFree(data);
    }

    explicit BridgeCFGraph(const BridgeCFGraphList* graphList, bool freedata)
    {
        if(!graphList || graphList->nodes.size != graphList->nodes.count * sizeof(BridgeCFNodeList))
            __debugbreak();
        entryPoint = graphList->entryPoint;
        userdata = graphList->userdata;
        auto data = (BridgeCFNodeList*)graphList->nodes.data;
        for(int i = 0; i < graphList->nodes.count; i++)
            AddNode(BridgeCFNode(&data[i], freedata));
        if(freedata && data)
            BridgeFree(data);
    }

    explicit BridgeCFGraph(duint entryPoint)
        : entryPoint(entryPoint),
          userdata(nullptr)
    {
    }

    void AddNode(const BridgeCFNode & node)
    {
        nodes[node.start] = node;
        AddParent(node.start, node.brtrue);
        AddParent(node.start, node.brfalse);
    }

    void AddParent(duint child, duint parent)
    {
        if(!child || !parent)
            return;
        auto found = parents.find(child);
        if(found == parents.end())
        {
            parents[child] = std::unordered_set<duint>();
            parents[child].insert(parent);
        }
        else
            found->second.insert(parent);
    }

    BridgeCFGraphList ToGraphList() const
    {
        BridgeCFGraphList out;
        out.entryPoint = entryPoint;
        out.userdata = userdata;
        std::vector<BridgeCFNodeList> nodeList;
        nodeList.reserve(nodes.size());
        for(const auto & nodeIt : nodes)
            nodeList.push_back(nodeIt.second.ToNodeList());
        BridgeList<BridgeCFNodeList>::CopyData(&out.nodes, nodeList);
        return std::move(out);
    }
};

#endif //_MSC_VER
#endif //__cplusplus

#endif //_GRAPH_H


================================================
File: ClawSearch/pluginsdk/bridgelist.h
================================================
#ifndef _LIST_H
#define _LIST_H

typedef struct
{
    int count; //Number of element in the list.
    size_t size; //Size of list in bytes (used for type checking).
    void* data; //Pointer to the list contents. Must be deleted by the caller using BridgeFree (or BridgeList::Free).
} ListInfo;

#define ListOf(Type) ListInfo*

#ifdef __cplusplus

#include <vector>

/**
\brief A list object. This object is NOT thread safe.
\tparam Type BridgeList contents type.
*/
template<typename Type>
class BridgeList
{
public:
    /**
    \brief BridgeList constructor.
    \param _freeData (Optional) the free function.
    */
    explicit BridgeList()
    {
        memset(&_listInfo, 0, sizeof(_listInfo));
    }

    /**
    \brief BridgeList destructor.
    */
    ~BridgeList()
    {
        Cleanup();
    }

    /**
    \brief Gets the list data.
    \return Returns ListInfo->data. Can be null if the list was never initialized. Will be destroyed once this object goes out of scope!
    */
    Type* Data() const
    {
        return reinterpret_cast<Type*>(_listInfo.data);
    }

    /**
    \brief Gets the number of elements in the list. This will crash the program if the data is not consistent with the specified template argument.
    \return The number of elements in the list.
    */
    int Count() const
    {
        if(_listInfo.size != _listInfo.count * sizeof(Type)) //make sure the user is using the correct type.
            __debugbreak();
        return _listInfo.count;
    }

    /**
    \brief Cleans up the list, freeing the list data when it is not null.
    */
    void Cleanup()
    {
        if(_listInfo.data)
        {
            BridgeFree(_listInfo.data);
            _listInfo.data = nullptr;
        }
    }

    /**
    \brief Reference operator (cleans up the previous list)
    \return Pointer to the ListInfo.
    */
    ListInfo* operator&()
    {
        Cleanup();
        return &_listInfo;
    }

    /**
    \brief Array indexer operator. This will crash if you try to access out-of-bounds.
    \param index Zero-based index of the item you want to get.
    \return Reference to a value at that index.
    */
    Type & operator[](size_t index) const
    {
        if(index >= size_t(Count())) //make sure the out-of-bounds access is caught as soon as possible.
            __debugbreak();
        return Data()[index];
    }

    /**
    \brief Copies data to a ListInfo structure..
    \param [out] listInfo If non-null, information describing the list.
    \param listData Data to copy in the ListInfo structure.
    \return true if it succeeds, false if it fails.
    */
    static bool CopyData(ListInfo* listInfo, const std::vector<Type> & listData)
    {
        if(!listInfo)
            return false;
        listInfo->count = int(listData.size());
        listInfo->size = listInfo->count * sizeof(Type);
        if(listInfo->count)
        {
            listInfo->data = BridgeAlloc(listInfo->size);
            Type* curItem = reinterpret_cast<Type*>(listInfo->data);
            for(const auto & item : listData)
            {
                *curItem = item;
                ++curItem;
            }
        }
        else
            listInfo->data = nullptr;
        return true;
    }

    static bool Free(const ListInfo* listInfo)
    {
        if(!listInfo || listInfo->size != listInfo->count * sizeof(Type) || (listInfo->count && !listInfo->data))
            return false;
        BridgeFree(listInfo->data);
        return true;
    }

    static bool ToVector(const ListInfo* listInfo, std::vector<Type> & listData, bool freedata = true)
    {
        if(!listInfo || listInfo->size != listInfo->count * sizeof(Type) || (listInfo->count && !listInfo->data))
            return false;
        listData.resize(listInfo->count);
        for(int i = 0; i < listInfo->count; i++)
            listData[i] = ((Type*)listInfo->data)[i];
        if(freedata && listInfo->data)
            BridgeFree(listInfo->data);
        return true;
    }

private:
    ListInfo _listInfo;
};

#endif //__cplusplus

#endif //_LIST_H


================================================
File: ClawSearch/pluginsdk/bridgemain.h
================================================
#ifndef _BRIDGEMAIN_H_
#define _BRIDGEMAIN_H_

#include <windows.h>

#ifndef __cplusplus
#include <stdbool.h>
#define DEFAULT_PARAM(name, value) name
#else
#define DEFAULT_PARAM(name, value) name = value
#endif

//default structure alignments forced
#ifdef _WIN64
#pragma pack(push, 16)
#else //x86
#pragma pack(push, 8)
#endif //_WIN64

#ifdef _WIN64
typedef unsigned long long duint;
typedef signed long long dsint;
#else
typedef unsigned long duint;
typedef signed long dsint;
#endif //_WIN64

#ifndef BRIDGE_IMPEXP
#ifdef BUILD_BRIDGE
#define BRIDGE_IMPEXP __declspec(dllexport)
#else
#define BRIDGE_IMPEXP __declspec(dllimport)
#endif //BUILD_BRIDGE
#endif //BRIDGE_IMPEXP

#ifdef __cplusplus
extern "C"
{
#endif

//Bridge defines
#define MAX_SETTING_SIZE 65536
#define DBG_VERSION 25

//Bridge functions

/// <summary>
/// Initialize the bridge.
/// </summary>
/// <returns>On error it returns a non-null error message.</returns>
BRIDGE_IMPEXP const wchar_t* BridgeInit();

/// <summary>
/// Start the bridge.
/// </summary>
/// <returns>On error it returns a non-null error message.</returns>
BRIDGE_IMPEXP const wchar_t* BridgeStart();

/// <summary>
/// Allocate buffer. Use BridgeFree to free the buffer.
/// </summary>
/// <param name="size">Size in bytes of the buffer to allocate.</param>
/// <returns>A pointer to the allocated buffer. This function will trigger a crash dump if unsuccessful.</returns>
BRIDGE_IMPEXP void* BridgeAlloc(size_t size);

/// <summary>
/// Free buffer allocated by BridgeAlloc.
/// </summary>
/// <param name="ptr">Buffer to free.</param>
BRIDGE_IMPEXP void BridgeFree(void* ptr);

/// <summary>
/// Get a string setting from the in-memory setting store.
/// </summary>
/// <param name="section">Section the setting is in. Cannot be null.</param>
/// <param name="key">Setting key (name). Cannot be null.</param>
/// <param name="value">Output buffer for the value. Should be of MAX_SETTING_SIZE. Cannot be null.</param>
/// <returns>True if the setting was found and copied in the value parameter.</returns>
BRIDGE_IMPEXP bool BridgeSettingGet(const char* section, const char* key, char* value);

/// <summary>
/// Get an integer setting from the in-memory setting store.
/// </summary>
/// <param name="section">Section the setting is in. Cannot be null.</param>
/// <param name="key">Setting key (name). Cannot be null.</param>
/// <param name="value">Output value.</param>
/// <returns>True if the setting was found and successfully converted to an integer.</returns>
BRIDGE_IMPEXP bool BridgeSettingGetUint(const char* section, const char* key, duint* value);

/// <summary>
/// Set a string setting in the in-memory setting store.
/// </summary>
/// <param name="section">Section the setting is in. Cannot be null.</param>
/// <param name="key">Setting key (name). Set to null to clear the whole section.</param>
/// <param name="value">New setting value. Set to null to remove the key from the section.</param>
/// <returns>True if the operation was successful.</returns>
BRIDGE_IMPEXP bool BridgeSettingSet(const char* section, const char* key, const char* value);

/// <summary>
/// Set an integer setting in the in-memory setting store.
/// </summary>
/// <param name="section">Section the setting is in. Cannot be null.</param>
/// <param name="key">Setting key (name). Set to null to clear the whole section.</param>
/// <param name="value">New setting value.</param>
/// <returns>True if the operation was successful.</returns>
BRIDGE_IMPEXP bool BridgeSettingSetUint(const char* section, const char* key, duint value);

/// <summary>
/// Flush the in-memory setting store to disk.
/// </summary>
/// <returns></returns>
BRIDGE_IMPEXP bool BridgeSettingFlush();

/// <summary>
/// Read the in-memory setting store from disk.
/// </summary>
/// <param name="errorLine">Line where the error occurred. Set to null to ignore this.</param>
/// <returns>True if the setting were read and parsed correctly.</returns>
BRIDGE_IMPEXP bool BridgeSettingRead(int* errorLine);

/// <summary>
/// Get the debugger version.
/// </summary>
/// <returns>25</returns>
BRIDGE_IMPEXP int BridgeGetDbgVersion();

/// <summary>
/// Checks if the current process is elevated.
/// </summary>
/// <returns>true if the process is elevated, false otherwise.</returns>
BRIDGE_IMPEXP bool BridgeIsProcessElevated();

#ifdef __cplusplus
}
#endif

//list structure (and C++ wrapper)
#include "bridgelist.h"

#include "bridgegraph.h"

#ifdef __cplusplus
extern "C"
{
#endif

//Debugger defines
#define MAX_LABEL_SIZE 256
#define MAX_COMMENT_SIZE 512
#define MAX_MODULE_SIZE 256
#define MAX_IMPORT_SIZE 65536
#define MAX_BREAKPOINT_SIZE 256
#define MAX_CONDITIONAL_EXPR_SIZE 256
#define MAX_CONDITIONAL_TEXT_SIZE 256
#define MAX_SCRIPT_LINE_SIZE 2048
#define MAX_THREAD_NAME_SIZE 256
#define MAX_WATCH_NAME_SIZE 256
#define MAX_STRING_SIZE 512
#define MAX_ERROR_SIZE 512
#define RIGHTS_STRING_SIZE (sizeof("ERWCG") + 1)
#define MAX_SECTION_SIZE 10
#define MAX_COMMAND_LINE_SIZE 256
#define MAX_MNEMONIC_SIZE 64
#define PAGE_SIZE 0x1000

//Debugger enums
typedef enum
{
    initialized,
    paused,
    running,
    stopped
} DBGSTATE;

typedef enum
{
    SEG_DEFAULT,
    SEG_ES,
    SEG_DS,
    SEG_FS,
    SEG_GS,
    SEG_CS,
    SEG_SS
} SEGMENTREG;

typedef enum
{
    flagmodule = 0x1,
    flaglabel = 0x2,
    flagcomment = 0x4,
    flagbookmark = 0x8,
    flagfunction = 0x10,
    flagloop = 0x20,
    flagargs = 0x40,
    flagNoFuncOffset = 0x80
} ADDRINFOFLAGS;

typedef enum
{
    bp_none = 0,
    bp_normal = 1,
    bp_hardware = 2,
    bp_memory = 4,
    bp_dll = 8,
    bp_exception = 16
} BPXTYPE;

typedef enum
{
    FUNC_NONE,
    FUNC_BEGIN,
    FUNC_MIDDLE,
    FUNC_END,
    FUNC_SINGLE
} FUNCTYPE;

typedef enum
{
    LOOP_NONE,
    LOOP_BEGIN,
    LOOP_MIDDLE,
    LOOP_ENTRY,
    LOOP_END,
    LOOP_SINGLE
} LOOPTYPE;

//order by most important type last
typedef enum
{
    XREF_NONE,
    XREF_DATA,
    XREF_JMP,
    XREF_CALL
} XREFTYPE;

typedef enum
{
    ARG_NONE,
    ARG_BEGIN,
    ARG_MIDDLE,
    ARG_END,
    ARG_SINGLE
} ARGTYPE;

typedef enum
{
    DBG_SCRIPT_LOAD,                // param1=const char* filename,      param2=unused
    DBG_SCRIPT_UNLOAD,              // param1=unused,                    param2=unused
    DBG_SCRIPT_RUN,                 // param1=int destline,              param2=unused
    DBG_SCRIPT_STEP,                // param1=unused,                    param2=unused
    DBG_SCRIPT_BPTOGGLE,            // param1=int line,                  param2=unused
    DBG_SCRIPT_BPGET,               // param1=int line,                  param2=unused
    DBG_SCRIPT_CMDEXEC,             // param1=const char* command,       param2=unused
    DBG_SCRIPT_ABORT,               // param1=unused,                    param2=unused
    DBG_SCRIPT_GETLINETYPE,         // param1=int line,                  param2=unused
    DBG_SCRIPT_SETIP,               // param1=int line,                  param2=unused
    DBG_SCRIPT_GETBRANCHINFO,       // param1=int line,                  param2=SCRIPTBRANCH* info
    DBG_SYMBOL_ENUM,                // param1=SYMBOLCBINFO* cbInfo,      param2=unused
    DBG_ASSEMBLE_AT,                // param1=duint addr,                param2=const char* instruction
    DBG_MODBASE_FROM_NAME,          // param1=const char* modname,       param2=unused
    DBG_DISASM_AT,                  // param1=duint addr,                 param2=DISASM_INSTR* instr
    DBG_STACK_COMMENT_GET,          // param1=duint addr,                param2=STACK_COMMENT* comment
    DBG_GET_THREAD_LIST,            // param1=THREADALLINFO* list,       param2=unused
    DBG_SETTINGS_UPDATED,           // param1=unused,                    param2=unused
    DBG_DISASM_FAST_AT,             // param1=duint addr,                param2=BASIC_INSTRUCTION_INFO* basicinfo
    DBG_MENU_ENTRY_CLICKED,         // param1=int hEntry,                param2=unused
    DBG_FUNCTION_GET,               // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_FUNCTION_OVERLAPS,          // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_FUNCTION_ADD,               // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_FUNCTION_DEL,               // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_LOOP_GET,                   // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_LOOP_OVERLAPS,              // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_LOOP_ADD,                   // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_LOOP_DEL,                   // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_IS_RUN_LOCKED,              // param1=unused,                    param2=unused
    DBG_IS_BP_DISABLED,             // param1=duint addr,                param2=unused
    DBG_SET_AUTO_COMMENT_AT,        // param1=duint addr,                param2=const char* text
    DBG_DELETE_AUTO_COMMENT_RANGE,  // param1=duint start,               param2=duint end
    DBG_SET_AUTO_LABEL_AT,          // param1=duint addr,                param2=const char* text
    DBG_DELETE_AUTO_LABEL_RANGE,    // param1=duint start,               param2=duint end
    DBG_SET_AUTO_BOOKMARK_AT,       // param1=duint addr,                param2=const char* text
    DBG_DELETE_AUTO_BOOKMARK_RANGE, // param1=duint start,               param2=duint end
    DBG_SET_AUTO_FUNCTION_AT,       // param1=duint addr,                param2=const char* text
    DBG_DELETE_AUTO_FUNCTION_RANGE, // param1=duint start,               param2=duint end
    DBG_GET_STRING_AT,              // param1=duint addr,                param2=unused
    DBG_GET_FUNCTIONS,              // param1=unused,                    param2=unused
    DBG_WIN_EVENT,                  // param1=MSG* message,              param2=long* result
    DBG_WIN_EVENT_GLOBAL,           // param1=MSG* message,              param2=unused
    DBG_INITIALIZE_LOCKS,           // param1=unused,                    param2=unused
    DBG_DEINITIALIZE_LOCKS,         // param1=unused,                    param2=unused
    DBG_GET_TIME_WASTED_COUNTER,    // param1=unused,                    param2=unused
    DBG_SYMBOL_ENUM_FROMCACHE,      // param1=SYMBOLCBINFO* cbInfo,      param2=unused
    DBG_DELETE_COMMENT_RANGE,       // param1=duint start,               param2=duint end
    DBG_DELETE_LABEL_RANGE,         // param1=duint start,               param2=duint end
    DBG_DELETE_BOOKMARK_RANGE,      // param1=duint start,               param2=duint end
    DBG_GET_XREF_COUNT_AT,          // param1=duint addr,                param2=unused
    DBG_GET_XREF_TYPE_AT,           // param1=duint addr,                param2=unused
    DBG_XREF_ADD,                   // param1=duint addr,                param2=duint from
    DBG_XREF_DEL_ALL,               // param1=duint addr,                param2=unused
    DBG_XREF_GET,                   // param1=duint addr,                param2=XREF_INFO* info
    DBG_GET_ENCODE_TYPE_BUFFER,     // param1=duint addr,                param2=unused
    DBG_ENCODE_TYPE_GET,            // param1=duint addr,                param2=duint size
    DBG_DELETE_ENCODE_TYPE_RANGE,   // param1=duint start,               param2=duint end
    DBG_ENCODE_SIZE_GET,            // param1=duint addr,                param2=duint codesize
    DBG_DELETE_ENCODE_TYPE_SEG,     // param1=duint addr,                param2=unused
    DBG_RELEASE_ENCODE_TYPE_BUFFER, // param1=void* buffer,              param2=unused
    DBG_ARGUMENT_GET,               // param1=FUNCTION* info,            param2=unused
    DBG_ARGUMENT_OVERLAPS,          // param1=FUNCTION* info,            param2=unused
    DBG_ARGUMENT_ADD,               // param1=FUNCTION* info,            param2=unused
    DBG_ARGUMENT_DEL,               // param1=FUNCTION* info,            param2=unused
    DBG_GET_WATCH_LIST,             // param1=ListOf(WATCHINFO),         param2=unused
    DBG_SELCHANGED,                 // param1=hWindow,                   param2=VA
    DBG_GET_PROCESS_HANDLE,         // param1=unused,                    param2=unused
    DBG_GET_THREAD_HANDLE,          // param1=unused,                    param2=unused
    DBG_GET_PROCESS_ID,             // param1=unused,                    param2=unused
    DBG_GET_THREAD_ID,              // param1=unused,                    param2=unused
    DBG_GET_PEB_ADDRESS,            // param1=DWORD ProcessId,           param2=unused
    DBG_GET_TEB_ADDRESS,            // param1=DWORD ThreadId,            param2=unused
    DBG_ANALYZE_FUNCTION,           // param1=BridgeCFGraphList* graph,  param2=duint entry
    DBG_MENU_PREPARE,               // param1=int hMenu,                 param2=unused
    DBG_GET_SYMBOL_INFO,            // param1=void* symbol,              param2=SYMBOLINFO* info
} DBGMSG;

typedef enum
{
    linecommand,
    linebranch,
    linelabel,
    linecomment,
    lineempty,
} SCRIPTLINETYPE;

typedef enum
{
    scriptnobranch,
    scriptjmp,
    scriptjnejnz,
    scriptjejz,
    scriptjbjl,
    scriptjajg,
    scriptjbejle,
    scriptjaejge,
    scriptcall
} SCRIPTBRANCHTYPE;

typedef enum
{
    instr_normal,
    instr_branch,
    instr_stack
} DISASM_INSTRTYPE;

typedef enum
{
    arg_normal,
    arg_memory
} DISASM_ARGTYPE;

typedef enum
{
    str_none,
    str_ascii,
    str_unicode
} STRING_TYPE;

typedef enum
{
    _PriorityIdle = -15,
    _PriorityAboveNormal = 1,
    _PriorityBelowNormal = -1,
    _PriorityHighest = 2,
    _PriorityLowest = -2,
    _PriorityNormal = 0,
    _PriorityTimeCritical = 15,
    _PriorityUnknown = 0x7FFFFFFF
} THREADPRIORITY;

typedef enum
{
    _Executive = 0,
    _FreePage = 1,
    _PageIn = 2,
    _PoolAllocation = 3,
    _DelayExecution = 4,
    _Suspended = 5,
    _UserRequest = 6,
    _WrExecutive = 7,
    _WrFreePage = 8,
    _WrPageIn = 9,
    _WrPoolAllocation = 10,
    _WrDelayExecution = 11,
    _WrSuspended = 12,
    _WrUserRequest = 13,
    _WrEventPair = 14,
    _WrQueue = 15,
    _WrLpcReceive = 16,
    _WrLpcReply = 17,
    _WrVirtualMemory = 18,
    _WrPageOut = 19,
    _WrRendezvous = 20,
    _Spare2 = 21,
    _Spare3 = 22,
    _Spare4 = 23,
    _Spare5 = 24,
    _WrCalloutStack = 25,
    _WrKernel = 26,
    _WrResource = 27,
    _WrPushLock = 28,
    _WrMutex = 29,
    _WrQuantumEnd = 30,
    _WrDispatchInt = 31,
    _WrPreempted = 32,
    _WrYieldExecution = 33,
    _WrFastMutex = 34,
    _WrGuardedMutex = 35,
    _WrRundown = 36,
} THREADWAITREASON;

typedef enum
{
    size_byte = 1,
    size_word = 2,
    size_dword = 4,
    size_qword = 8,
    size_xmmword = 16,
    size_ymmword = 32
} MEMORY_SIZE;

typedef enum
{
    enc_unknown,  //must be 0
    enc_byte,     //1 byte
    enc_word,     //2 bytes
    enc_dword,    //4 bytes
    enc_fword,    //6 bytes
    enc_qword,    //8 bytes
    enc_tbyte,    //10 bytes
    enc_oword,    //16 bytes
    enc_mmword,   //8 bytes
    enc_xmmword,  //16 bytes
    enc_ymmword,  //32 bytes
    enc_zmmword,  //64 bytes avx512 not supported
    enc_real4,    //4 byte float
    enc_real8,    //8 byte double
    enc_real10,   //10 byte decimal
    enc_ascii,    //ascii sequence
    enc_unicode,  //unicode sequence
    enc_code,     //start of code
    enc_junk,     //junk code
    enc_middle    //middle of data
} ENCODETYPE;

typedef enum
{
    TYPE_UINT, // unsigned integer
    TYPE_INT,  // signed integer
    TYPE_FLOAT,// single precision floating point value
    TYPE_ASCII, // ascii string
    TYPE_UNICODE, // unicode string
    TYPE_INVALID // invalid watch expression or data type
} WATCHVARTYPE;

typedef enum
{
    MODE_DISABLED, // watchdog is disabled
    MODE_ISTRUE,   // alert if expression is not 0
    MODE_ISFALSE,  // alert if expression is 0
    MODE_CHANGED,  // alert if expression is changed
    MODE_UNCHANGED // alert if expression is not changed
} WATCHDOGMODE;

typedef enum
{
    hw_access,
    hw_write,
    hw_execute
} BPHWTYPE;

typedef enum
{
    mem_access,
    mem_read,
    mem_write,
    mem_execute
} BPMEMTYPE;

typedef enum
{
    dll_load = 1,
    dll_unload,
    dll_all
} BPDLLTYPE;

typedef enum
{
    ex_firstchance = 1,
    ex_secondchance,
    ex_all
} BPEXTYPE;

typedef enum
{
    hw_byte,
    hw_word,
    hw_dword,
    hw_qword
} BPHWSIZE;

typedef enum
{
    sym_import,
    sym_export,
    sym_symbol
} SYMBOLTYPE;

//Debugger typedefs
typedef MEMORY_SIZE VALUE_SIZE;

typedef struct DBGFUNCTIONS_ DBGFUNCTIONS;

typedef bool (*CBSYMBOLENUM)(const struct SYMBOLPTR_* symbol, void* user);

//Debugger structs
typedef struct
{
    MEMORY_BASIC_INFORMATION mbi;
    char info[MAX_MODULE_SIZE];
} MEMPAGE;

typedef struct
{
    int count;
    MEMPAGE* page;
} MEMMAP;

typedef struct
{
    BPXTYPE type;
    duint addr;
    bool enabled;
    bool singleshoot;
    bool active;
    char name[MAX_BREAKPOINT_SIZE];
    char mod[MAX_MODULE_SIZE];
    unsigned short slot;
    // extended part
    unsigned char typeEx; //BPHWTYPE/BPMEMTYPE/BPDLLTYPE/BPEXTYPE
    unsigned char hwSize; //BPHWSIZE
    unsigned int hitCount;
    bool fastResume;
    bool silent;
    char breakCondition[MAX_CONDITIONAL_EXPR_SIZE];
    char logText[MAX_CONDITIONAL_TEXT_SIZE];
    char logCondition[MAX_CONDITIONAL_EXPR_SIZE];
    char commandText[MAX_CONDITIONAL_TEXT_SIZE];
    char commandCondition[MAX_CONDITIONAL_EXPR_SIZE];
} BRIDGEBP;

typedef struct
{
    int count;
    BRIDGEBP* bp;
} BPMAP;

typedef struct
{
    char WatchName[MAX_WATCH_NAME_SIZE];
    char Expression[MAX_CONDITIONAL_EXPR_SIZE];
    unsigned int window;
    unsigned int id;
    WATCHVARTYPE varType;
    WATCHDOGMODE watchdogMode;
    duint value;
    bool watchdogTriggered;
} WATCHINFO;

typedef struct
{
    duint start; //OUT
    duint end; //OUT
    duint instrcount; //OUT
} FUNCTION;

typedef struct
{
    int depth; //IN
    duint start; //OUT
    duint end; //OUT
    duint instrcount; //OUT
} LOOP;

typedef struct
{
    int flags; //ADDRINFOFLAGS (IN)
    char module[MAX_MODULE_SIZE]; //module the address is in
    char label[MAX_LABEL_SIZE];
    char comment[MAX_COMMENT_SIZE];
    bool isbookmark;
    FUNCTION function;
    LOOP loop;
    FUNCTION args;
} BRIDGE_ADDRINFO;

typedef struct SYMBOLINFO_
{
    duint addr;
    char* decoratedSymbol;
    char* undecoratedSymbol;
    SYMBOLTYPE type;
    bool freeDecorated;
    bool freeUndecorated;
    DWORD ordinal;
} SYMBOLINFO;

typedef struct
{
    duint base;
    char name[MAX_MODULE_SIZE];
} SYMBOLMODULEINFO;

typedef struct
{
    duint base;
    CBSYMBOLENUM cbSymbolEnum;
    void* user;
} SYMBOLCBINFO;

typedef struct
{
    bool c;
    bool p;
    bool a;
    bool z;
    bool s;
    bool t;
    bool i;
    bool d;
    bool o;
} FLAGS;

typedef struct
{
    bool FZ;
    bool PM;
    bool UM;
    bool OM;
    bool ZM;
    bool IM;
    bool DM;
    bool DAZ;
    bool PE;
    bool UE;
    bool OE;
    bool ZE;
    bool DE;
    bool IE;

    unsigned short RC;
} MXCSRFIELDS;

typedef struct
{
    bool B;
    bool C3;
    bool C2;
    bool C1;
    bool C0;
    bool ES;
    bool SF;
    bool P;
    bool U;
    bool O;
    bool Z;
    bool D;
    bool I;

    unsigned short TOP;

} X87STATUSWORDFIELDS;

typedef struct
{
    bool IC;
    bool IEM;
    bool PM;
    bool UM;
    bool OM;
    bool ZM;
    bool DM;
    bool IM;

    unsigned short RC;
    unsigned short PC;

} X87CONTROLWORDFIELDS;

typedef struct DECLSPEC_ALIGN(16) _XMMREGISTER
{
    ULONGLONG Low;
    LONGLONG High;
} XMMREGISTER;

typedef struct
{
    XMMREGISTER Low; //XMM/SSE part
    XMMREGISTER High; //AVX part
} YMMREGISTER;

typedef struct
{
    BYTE    data[10];
    int     st_value;
    int     tag;
} X87FPUREGISTER;

typedef struct
{
    WORD   ControlWord;
    WORD   StatusWord;
    WORD   TagWord;
    DWORD   ErrorOffset;
    DWORD   ErrorSelector;
    DWORD   DataOffset;
    DWORD   DataSelector;
    DWORD   Cr0NpxState;
} X87FPU;

typedef struct
{
    ULONG_PTR cax;
    ULONG_PTR ccx;
    ULONG_PTR cdx;
    ULONG_PTR cbx;
    ULONG_PTR csp;
    ULONG_PTR cbp;
    ULONG_PTR csi;
    ULONG_PTR cdi;
#ifdef _WIN64
    ULONG_PTR r8;
    ULONG_PTR r9;
    ULONG_PTR r10;
    ULONG_PTR r11;
    ULONG_PTR r12;
    ULONG_PTR r13;
    ULONG_PTR r14;
    ULONG_PTR r15;
#endif //_WIN64
    ULONG_PTR cip;
    ULONG_PTR eflags;
    unsigned short gs;
    unsigned short fs;
    unsigned short es;
    unsigned short ds;
    unsigned short cs;
    unsigned short ss;
    ULONG_PTR dr0;
    ULONG_PTR dr1;
    ULONG_PTR dr2;
    ULONG_PTR dr3;
    ULONG_PTR dr6;
    ULONG_PTR dr7;
    BYTE RegisterArea[80];
    X87FPU x87fpu;
    DWORD MxCsr;
#ifdef _WIN64
    XMMREGISTER XmmRegisters[16];
    YMMREGISTER YmmRegisters[16];
#else // x86
    XMMREGISTER XmmRegisters[8];
    YMMREGISTER YmmRegisters[8];
#endif
} REGISTERCONTEXT;

typedef struct
{
    DWORD code;
    char name[128];
} LASTERROR;

typedef struct
{
    DWORD code;
    char name[128];
} LASTSTATUS;

typedef struct
{
    REGISTERCONTEXT regcontext;
    FLAGS flags;
    X87FPUREGISTER x87FPURegisters[8];
    unsigned long long mmx[8];
    MXCSRFIELDS MxCsrFields;
    X87STATUSWORDFIELDS x87StatusWordFields;
    X87CONTROLWORDFIELDS x87ControlWordFields;
    LASTERROR lastError;
    LASTSTATUS lastStatus;
} REGDUMP;

typedef struct
{
    DISASM_ARGTYPE type; //normal/memory
    SEGMENTREG segment;
    char mnemonic[64];
    duint constant; //constant in the instruction (imm/disp)
    duint value; //equal to constant or equal to the register value
    duint memvalue; //memsize:[value]
} DISASM_ARG;

typedef struct
{
    char instruction[64];
    DISASM_INSTRTYPE type;
    int argcount;
    int instr_size;
    DISASM_ARG arg[3];
} DISASM_INSTR;

typedef struct
{
    char color[8]; //hex color-code
    char comment[MAX_COMMENT_SIZE];
} STACK_COMMENT;

typedef struct
{
    int ThreadNumber;
    HANDLE Handle;
    DWORD ThreadId;
    duint ThreadStartAddress;
    duint ThreadLocalBase;
    char threadName[MAX_THREAD_NAME_SIZE];
} THREADINFO;

typedef struct
{
    THREADINFO BasicInfo;
    duint ThreadCip;
    DWORD SuspendCount;
    THREADPRIORITY Priority;
    THREADWAITREASON WaitReason;
    DWORD LastError;
    FILETIME UserTime;
    FILETIME KernelTime;
    FILETIME CreationTime;
    ULONG64 Cycles; // Windows Vista or greater
} THREADALLINFO;

typedef struct
{
    int count;
    THREADALLINFO* list;
    int CurrentThread;
} THREADLIST;

typedef struct
{
    duint value; //displacement / addrvalue (rip-relative)
    MEMORY_SIZE size; //byte/word/dword/qword
    char mnemonic[MAX_MNEMONIC_SIZE];
} MEMORY_INFO;

typedef struct
{
    duint value;
    VALUE_SIZE size;
} VALUE_INFO;

//definitions for BASIC_INSTRUCTION_INFO.type
#define TYPE_VALUE 1
#define TYPE_MEMORY 2
#define TYPE_ADDR 4

typedef struct
{
    DWORD type; //value|memory|addr
    VALUE_INFO value; //immediat
    MEMORY_INFO memory;
    duint addr; //addrvalue (jumps + calls)
    bool branch; //jumps/calls
    bool call; //instruction is a call
    int size;
    char instruction[MAX_MNEMONIC_SIZE * 4];
} BASIC_INSTRUCTION_INFO;

typedef struct
{
    SCRIPTBRANCHTYPE type;
    int dest;
    char branchlabel[256];
} SCRIPTBRANCH;

typedef struct
{
    duint addr;
    duint start;
    duint end;
    bool manual;
    int depth;
} FUNCTION_LOOP_INFO;

typedef struct
{
    duint addr;
    XREFTYPE type;
} XREF_RECORD;

typedef struct
{
    duint refcount;
    XREF_RECORD* references;
} XREF_INFO;

typedef struct SYMBOLPTR_
{
    duint modbase;
    const void* symbol;
} SYMBOLPTR;

//Debugger functions
BRIDGE_IMPEXP const char* DbgInit();
BRIDGE_IMPEXP void DbgExit();
BRIDGE_IMPEXP bool DbgMemRead(duint va, void* dest, duint size);
BRIDGE_IMPEXP bool DbgMemWrite(duint va, const void* src, duint size);
BRIDGE_IMPEXP duint DbgMemGetPageSize(duint base);
BRIDGE_IMPEXP duint DbgMemFindBaseAddr(duint addr, duint* size);

/// <summary>
/// Asynchronously execute a debugger command by adding it to the command queue.
/// Note: the command may not have completed before this call returns. Use this
/// function if you don't care when the command gets executed.
///
/// Example: DbgCmdExec("ClearLog")
/// </summary>
/// <param name="cmd">The command to execute.</param>
/// <returns>True if the command was successfully submitted to the command queue. False if the submission failed.</returns>
BRIDGE_IMPEXP bool DbgCmdExec(const char* cmd);

/// <summary>
/// Performs synchronous execution of a debugger command. This function call only
/// returns after the command has completed.
///
/// Example: DbgCmdExecDirect("loadlib advapi32.dll")
/// </summary>
/// <param name="cmd">The command to execute.</param>
/// <returns>True if the command executed successfully, False if there was a problem.</returns>
BRIDGE_IMPEXP bool DbgCmdExecDirect(const char* cmd);
BRIDGE_IMPEXP bool DbgMemMap(MEMMAP* memmap);
BRIDGE_IMPEXP bool DbgIsValidExpression(const char* expression);
BRIDGE_IMPEXP bool DbgIsDebugging();
BRIDGE_IMPEXP bool DbgIsJumpGoingToExecute(duint addr);
BRIDGE_IMPEXP bool DbgGetLabelAt(duint addr, SEGMENTREG segment, char* text);
BRIDGE_IMPEXP bool DbgSetLabelAt(duint addr, const char* text);
BRIDGE_IMPEXP void DbgClearLabelRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgGetCommentAt(duint addr, char* text);
BRIDGE_IMPEXP bool DbgSetCommentAt(duint addr, const char* text);
BRIDGE_IMPEXP void DbgClearCommentRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgGetBookmarkAt(duint addr);
BRIDGE_IMPEXP bool DbgSetBookmarkAt(duint addr, bool isbookmark);
BRIDGE_IMPEXP void DbgClearBookmarkRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgGetModuleAt(duint addr, char* text);
BRIDGE_IMPEXP BPXTYPE DbgGetBpxTypeAt(duint addr);
BRIDGE_IMPEXP duint DbgValFromString(const char* string);
BRIDGE_IMPEXP bool DbgGetRegDumpEx(REGDUMP* regdump, size_t size);
BRIDGE_IMPEXP bool DbgValToString(const char* string, duint value);
BRIDGE_IMPEXP bool DbgMemIsValidReadPtr(duint addr);
BRIDGE_IMPEXP int DbgGetBpList(BPXTYPE type, BPMAP* list);
BRIDGE_IMPEXP FUNCTYPE DbgGetFunctionTypeAt(duint addr);
BRIDGE_IMPEXP LOOPTYPE DbgGetLoopTypeAt(duint addr, int depth);
BRIDGE_IMPEXP duint DbgGetBranchDestination(duint addr);
BRIDGE_IMPEXP void DbgScriptLoad(const char* filename);
BRIDGE_IMPEXP void DbgScriptUnload();
BRIDGE_IMPEXP void DbgScriptRun(int destline);
BRIDGE_IMPEXP void DbgScriptStep();
BRIDGE_IMPEXP bool DbgScriptBpToggle(int line);
BRIDGE_IMPEXP bool DbgScriptBpGet(int line);
BRIDGE_IMPEXP bool DbgScriptCmdExec(const char* command);
BRIDGE_IMPEXP void DbgScriptAbort();
BRIDGE_IMPEXP SCRIPTLINETYPE DbgScriptGetLineType(int line);
BRIDGE_IMPEXP void DbgScriptSetIp(int line);
BRIDGE_IMPEXP bool DbgScriptGetBranchInfo(int line, SCRIPTBRANCH* info);
BRIDGE_IMPEXP void DbgSymbolEnum(duint base, CBSYMBOLENUM cbSymbolEnum, void* user);
BRIDGE_IMPEXP void DbgSymbolEnumFromCache(duint base, CBSYMBOLENUM cbSymbolEnum, void* user);
BRIDGE_IMPEXP bool DbgAssembleAt(duint addr, const char* instruction);
BRIDGE_IMPEXP duint DbgModBaseFromName(const char* name);
BRIDGE_IMPEXP void DbgDisasmAt(duint addr, DISASM_INSTR* instr);
BRIDGE_IMPEXP bool DbgStackCommentGet(duint addr, STACK_COMMENT* comment);
BRIDGE_IMPEXP void DbgGetThreadList(THREADLIST* list);
BRIDGE_IMPEXP void DbgSettingsUpdated();
BRIDGE_IMPEXP void DbgDisasmFastAt(duint addr, BASIC_INSTRUCTION_INFO* basicinfo);
BRIDGE_IMPEXP void DbgMenuEntryClicked(int hEntry);
BRIDGE_IMPEXP bool DbgFunctionGet(duint addr, duint* start, duint* end);
BRIDGE_IMPEXP bool DbgFunctionOverlaps(duint start, duint end);
BRIDGE_IMPEXP bool DbgFunctionAdd(duint start, duint end);
BRIDGE_IMPEXP bool DbgFunctionDel(duint addr);
BRIDGE_IMPEXP bool DbgArgumentGet(duint addr, duint* start, duint* end);
BRIDGE_IMPEXP bool DbgArgumentOverlaps(duint start, duint end);
BRIDGE_IMPEXP bool DbgArgumentAdd(duint start, duint end);
BRIDGE_IMPEXP bool DbgArgumentDel(duint addr);
BRIDGE_IMPEXP bool DbgLoopGet(int depth, duint addr, duint* start, duint* end);
BRIDGE_IMPEXP bool DbgLoopOverlaps(int depth, duint start, duint end);
BRIDGE_IMPEXP bool DbgLoopAdd(duint start, duint end);
BRIDGE_IMPEXP bool DbgLoopDel(int depth, duint addr);
BRIDGE_IMPEXP bool DbgXrefAdd(duint addr, duint from);
BRIDGE_IMPEXP bool DbgXrefDelAll(duint addr);
BRIDGE_IMPEXP bool DbgXrefGet(duint addr, XREF_INFO* info);
BRIDGE_IMPEXP size_t DbgGetXrefCountAt(duint addr);
BRIDGE_IMPEXP XREFTYPE DbgGetXrefTypeAt(duint addr);
BRIDGE_IMPEXP bool DbgIsRunLocked();
BRIDGE_IMPEXP bool DbgIsBpDisabled(duint addr);
BRIDGE_IMPEXP bool DbgSetAutoCommentAt(duint addr, const char* text);
BRIDGE_IMPEXP void DbgClearAutoCommentRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgSetAutoLabelAt(duint addr, const char* text);
BRIDGE_IMPEXP void DbgClearAutoLabelRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgSetAutoBookmarkAt(duint addr);
BRIDGE_IMPEXP void DbgClearAutoBookmarkRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgSetAutoFunctionAt(duint start, duint end);
BRIDGE_IMPEXP void DbgClearAutoFunctionRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgGetStringAt(duint addr, char* text);
BRIDGE_IMPEXP const DBGFUNCTIONS* DbgFunctions();
BRIDGE_IMPEXP bool DbgWinEvent(MSG* message, long* result);
BRIDGE_IMPEXP bool DbgWinEventGlobal(MSG* message);
BRIDGE_IMPEXP bool DbgIsRunning();
BRIDGE_IMPEXP duint DbgGetTimeWastedCounter();
BRIDGE_IMPEXP ARGTYPE DbgGetArgTypeAt(duint addr);
BRIDGE_IMPEXP void* DbgGetEncodeTypeBuffer(duint addr, duint* size);
BRIDGE_IMPEXP void DbgReleaseEncodeTypeBuffer(void* buffer);
BRIDGE_IMPEXP ENCODETYPE DbgGetEncodeTypeAt(duint addr, duint size);
BRIDGE_IMPEXP duint DbgGetEncodeSizeAt(duint addr, duint codesize);
BRIDGE_IMPEXP bool DbgSetEncodeType(duint addr, duint size, ENCODETYPE type);
BRIDGE_IMPEXP void DbgDelEncodeTypeRange(duint start, duint end);
BRIDGE_IMPEXP void DbgDelEncodeTypeSegment(duint start);
BRIDGE_IMPEXP bool DbgGetWatchList(ListOf(WATCHINFO) list);
BRIDGE_IMPEXP void DbgSelChanged(int hWindow, duint VA);
BRIDGE_IMPEXP HANDLE DbgGetProcessHandle();
BRIDGE_IMPEXP HANDLE DbgGetThreadHandle();
BRIDGE_IMPEXP DWORD DbgGetProcessId();
BRIDGE_IMPEXP DWORD DbgGetThreadId();
BRIDGE_IMPEXP duint DbgGetPebAddress(DWORD ProcessId);
BRIDGE_IMPEXP duint DbgGetTebAddress(DWORD ThreadId);
BRIDGE_IMPEXP bool DbgAnalyzeFunction(duint entry, BridgeCFGraphList* graph);
BRIDGE_IMPEXP duint DbgEval(const char* expression, bool* DEFAULT_PARAM(success, nullptr));
BRIDGE_IMPEXP void DbgGetSymbolInfo(const SYMBOLPTR* symbolptr, SYMBOLINFO* info);

//Gui defines
typedef enum
{
    GUI_PLUGIN_MENU,
    GUI_DISASM_MENU,
    GUI_DUMP_MENU,
    GUI_STACK_MENU,
    GUI_GRAPH_MENU,
    GUI_MEMMAP_MENU,
    GUI_SYMMOD_MENU,
} GUIMENUTYPE;

BRIDGE_IMPEXP void DbgMenuPrepare(GUIMENUTYPE hMenu);

typedef enum
{
    GUI_DISASSEMBLY,
    GUI_DUMP,
    GUI_STACK,
    GUI_GRAPH,
    GUI_MEMMAP,
    GUI_SYMMOD,
} GUISELECTIONTYPE;

#define GUI_MAX_LINE_SIZE 65536
#define GUI_MAX_DISASSEMBLY_SIZE 2048

//Gui enums
typedef enum
{
    GUI_DISASSEMBLE_AT,             // param1=(duint)va,            param2=(duint)cip
    GUI_SET_DEBUG_STATE,            // param1=(DBGSTATE)state,      param2=unused
    GUI_ADD_MSG_TO_LOG,             // param1=(const char*)msg,     param2=unused
    GUI_CLEAR_LOG,                  // param1=unused,               param2=unused
    GUI_UPDATE_REGISTER_VIEW,       // param1=unused,               param2=unused
    GUI_UPDATE_DISASSEMBLY_VIEW,    // param1=unused,               param2=unused
    GUI_UPDATE_BREAKPOINTS_VIEW,    // param1=unused,               param2=unused
    GUI_UPDATE_WINDOW_TITLE,        // param1=(const char*)file,    param2=unused
    GUI_GET_WINDOW_HANDLE,          // param1=unused,               param2=unused
    GUI_DUMP_AT,                    // param1=(duint)va             param2=unused
    GUI_SCRIPT_ADD,                 // param1=int count,            param2=const char** lines
    GUI_SCRIPT_CLEAR,               // param1=unused,               param2=unused
    GUI_SCRIPT_SETIP,               // param1=int line,             param2=unused
    GUI_SCRIPT_ERROR,               // param1=int line,             param2=const char* message
    GUI_SCRIPT_SETTITLE,            // param1=const char* title,    param2=unused
    GUI_SCRIPT_SETINFOLINE,         // param1=int line,             param2=const char* info
    GUI_SCRIPT_MESSAGE,             // param1=const char* message,  param2=unused
    GUI_SCRIPT_MSGYN,               // param1=const char* message,  param2=unused
    GUI_SYMBOL_LOG_ADD,             // param1(const char*)msg,      param2=unused
    GUI_SYMBOL_LOG_CLEAR,           // param1=unused,               param2=unused
    GUI_SYMBOL_SET_PROGRESS,        // param1=int percent           param2=unused
    GUI_SYMBOL_UPDATE_MODULE_LIST,  // param1=int count,            param2=SYMBOLMODULEINFO* modules
    GUI_REF_ADDCOLUMN,              // param1=int width,            param2=(const char*)title
    GUI_REF_SETROWCOUNT,            // param1=int rows,             param2=unused
    GUI_REF_GETROWCOUNT,            // param1=unused,               param2=unused
    GUI_REF_DELETEALLCOLUMNS,       // param1=unused,               param2=unused
    GUI_REF_SETCELLCONTENT,         // param1=(CELLINFO*)info,      param2=unused
    GUI_REF_GETCELLCONTENT,         // param1=int row,              param2=int col
    GUI_REF_RELOADDATA,             // param1=unused,               param2=unused
    GUI_REF_SETSINGLESELECTION,     // param1=int index,            param2=bool scroll
    GUI_REF_SETPROGRESS,            // param1=int progress,         param2=unused
    GUI_REF_SETCURRENTTASKPROGRESS, // param1=int progress,         param2=const char* taskTitle
    GUI_REF_SETSEARCHSTARTCOL,      // param1=int col               param2=unused
    GUI_STACK_DUMP_AT,              // param1=duint addr,           param2=duint csp
    GUI_UPDATE_DUMP_VIEW,           // param1=unused,               param2=unused
    GUI_UPDATE_THREAD_VIEW,         // param1=unused,               param2=unused
    GUI_ADD_RECENT_FILE,            // param1=(const char*)file,    param2=unused
    GUI_SET_LAST_EXCEPTION,         // param1=unsigned int code,    param2=unused
    GUI_GET_DISASSEMBLY,            // param1=duint addr,           param2=char* text
    GUI_MENU_ADD,                   // param1=int hMenu,            param2=const char* title
    GUI_MENU_ADD_ENTRY,             // param1=int hMenu,            param2=const char* title
    GUI_MENU_ADD_SEPARATOR,         // param1=int hMenu,            param2=unused
    GUI_MENU_CLEAR,                 // param1=int hMenu,            param2=unused
    GUI_SELECTION_GET,              // param1=GUISELECTIONTYPE,     param2=SELECTIONDATA* selection
    GUI_SELECTION_SET,              // param1=GUISELECTIONTYPE,     param2=const SELECTIONDATA* selection
    GUI_GETLINE_WINDOW,             // param1=const char* title,    param2=char* text
    GUI_AUTOCOMPLETE_ADDCMD,        // param1=const char* cmd,      param2=ununsed
    GUI_AUTOCOMPLETE_DELCMD,        // param1=const char* cmd,      param2=ununsed
    GUI_AUTOCOMPLETE_CLEARALL,      // param1=unused,               param2=unused
    GUI_SCRIPT_ENABLEHIGHLIGHTING,  // param1=bool enable,          param2=unused
    GUI_ADD_MSG_TO_STATUSBAR,       // param1=const char* msg,      param2=unused
    GUI_UPDATE_SIDEBAR,             // param1=unused,               param2=unused
    GUI_REPAINT_TABLE_VIEW,         // param1=unused,               param2=unused
    GUI_UPDATE_PATCHES,             // param1=unused,               param2=unused
    GUI_UPDATE_CALLSTACK,           // param1=unused,               param2=unused
    GUI_UPDATE_SEHCHAIN,            // param1=unused,               param2=unused
    GUI_SYMBOL_REFRESH_CURRENT,     // param1=unused,               param2=unused
    GUI_UPDATE_MEMORY_VIEW,         // param1=unused,               param2=unused
    GUI_REF_INITIALIZE,             // param1=const char* name,     param2=unused
    GUI_LOAD_SOURCE_FILE,           // param1=const char* path,     param2=duint addr
    GUI_MENU_SET_ICON,              // param1=int hMenu,            param2=ICONINFO*
    GUI_MENU_SET_ENTRY_ICON,        // param1=int hEntry,           param2=ICONINFO*
    GUI_SHOW_CPU,                   // param1=unused,               param2=unused
    GUI_ADD_QWIDGET_TAB,            // param1=QWidget*,             param2=unused
    GUI_SHOW_QWIDGET_TAB,           // param1=QWidget*,             param2=unused
    GUI_CLOSE_QWIDGET_TAB,          // param1=QWidget*,             param2=unused
    GUI_EXECUTE_ON_GUI_THREAD,      // param1=GUICALLBACKEX cb,     param2=void* userdata
    GUI_UPDATE_TIME_WASTED_COUNTER, // param1=unused,               param2=unused
    GUI_SET_GLOBAL_NOTES,           // param1=const char* text,     param2=unused
    GUI_GET_GLOBAL_NOTES,           // param1=char** text,          param2=unused
    GUI_SET_DEBUGGEE_NOTES,         // param1=const char* text,     param2=unused
    GUI_GET_DEBUGGEE_NOTES,         // param1=char** text,          param2=unused
    GUI_DUMP_AT_N,                  // param1=int index,            param2=duint va
    GUI_DISPLAY_WARNING,            // param1=const char *text,     param2=unused
    GUI_REGISTER_SCRIPT_LANG,       // param1=SCRIPTTYPEINFO* info, param2=unused
    GUI_UNREGISTER_SCRIPT_LANG,     // param1=int id,               param2=unused
    GUI_UPDATE_ARGUMENT_VIEW,       // param1=unused,               param2=unused
    GUI_FOCUS_VIEW,                 // param1=int hWindow,          param2=unused
    GUI_UPDATE_WATCH_VIEW,          // param1=unused,               param2=unused
    GUI_LOAD_GRAPH,                 // param1=BridgeCFGraphList*    param2=unused
    GUI_GRAPH_AT,                   // param1=duint addr            param2=unused
    GUI_UPDATE_GRAPH_VIEW,          // param1=unused,               param2=unused
    GUI_SET_LOG_ENABLED,            // param1=bool isEnabled        param2=unused
    GUI_ADD_FAVOURITE_TOOL,         // param1=const char* name      param2=const char* description
    GUI_ADD_FAVOURITE_COMMAND,      // param1=const char* command   param2=const char* shortcut
    GUI_SET_FAVOURITE_TOOL_SHORTCUT,// param1=const char* name      param2=const char* shortcut
    GUI_FOLD_DISASSEMBLY,           // param1=duint startAddress    param2=duint length
    GUI_SELECT_IN_MEMORY_MAP,       // param1=duint addr,           param2=unused
    GUI_GET_ACTIVE_VIEW,            // param1=ACTIVEVIEW*,          param2=unused
    GUI_MENU_SET_ENTRY_CHECKED,     // param1=int hEntry,           param2=bool checked
    GUI_ADD_INFO_LINE,              // param1=const char* infoline, param2=unused
    GUI_PROCESS_EVENTS,             // param1=unused,               param2=unused
    GUI_TYPE_ADDNODE,               // param1=void* parent,         param2=TYPEDESCRIPTOR* type
    GUI_TYPE_CLEAR,                 // param1=unused,               param2=unused
    GUI_UPDATE_TYPE_WIDGET,         // param1=unused,               param2=unused
    GUI_CLOSE_APPLICATION,          // param1=unused,               param2=unused
    GUI_MENU_SET_VISIBLE,           // param1=int hMenu,            param2=bool visible
    GUI_MENU_SET_ENTRY_VISIBLE,     // param1=int hEntry,           param2=bool visible
    GUI_MENU_SET_NAME,              // param1=int hMenu,            param2=const char* name
    GUI_MENU_SET_ENTRY_NAME,        // param1=int hEntry,           param2=const char* name
    GUI_FLUSH_LOG,                  // param1=unused,               param2=unused
    GUI_MENU_SET_ENTRY_HOTKEY,      // param1=int hEntry,           param2=const char* hack
    GUI_REF_SEARCH_GETROWCOUNT,     // param1=unused,               param2=unused
    GUI_REF_SEARCH_GETCELLCONTENT,  // param1=int row,              param2=int col
    GUI_MENU_REMOVE,                // param1=int hEntryMenu,       param2=unused
    GUI_REF_ADDCOMMAND,             // param1=const char* title,    param2=const char* command
    GUI_OPEN_TRACE_FILE,            // param1=const char* file name,param2=unused
    GUI_UPDATE_TRACE_BROWSER,       // param1=unused,               param2=unused
    GUI_INVALIDATE_SYMBOL_SOURCE,   // param1=duint base,           param2=unused
    GUI_GET_CURRENT_GRAPH,          // param1=BridgeCFGraphList*,   param2=unused
    GUI_SHOW_REF,                   // param1=unused,               param2=unused
} GUIMSG;

//GUI Typedefs
struct _TYPEDESCRIPTOR;

typedef void (*GUICALLBACK)();
typedef void (*GUICALLBACKEX)(void*);
typedef bool (*GUISCRIPTEXECUTE)(const char* text);
typedef void (*GUISCRIPTCOMPLETER)(const char* text, char** entries, int* entryCount);
typedef bool (*TYPETOSTRING)(const struct _TYPEDESCRIPTOR* type, char* dest, size_t* destCount); //don't change destCount for final failure

//GUI structures
typedef struct
{
    int row;
    int col;
    const char* str;
} CELLINFO;

typedef struct
{
    duint start;
    duint end;
} SELECTIONDATA;

typedef struct
{
    const void* data;
    duint size;
} ICONDATA;

typedef struct
{
    char name[64];
    int id;
    GUISCRIPTEXECUTE execute;
    GUISCRIPTCOMPLETER completeCommand;
} SCRIPTTYPEINFO;

typedef struct
{
    void* titleHwnd;
    void* classHwnd;
    char title[MAX_STRING_SIZE];
    char className[MAX_STRING_SIZE];
} ACTIVEVIEW;

typedef struct _TYPEDESCRIPTOR
{
    bool expanded; //is the type node expanded?
    bool reverse; //big endian?
    const char* name; //type name (int b)
    duint addr; //virtual address
    duint offset; //offset to addr for the actual location
    int id; //type id
    int size; //sizeof(type)
    TYPETOSTRING callback; //convert to string
    void* userdata; //user data
} TYPEDESCRIPTOR;

//GUI functions
//code page is utf8
BRIDGE_IMPEXP const char* GuiTranslateText(const char* Source);
BRIDGE_IMPEXP void GuiDisasmAt(duint addr, duint cip);
BRIDGE_IMPEXP void GuiSetDebugState(DBGSTATE state);
BRIDGE_IMPEXP void GuiSetDebugStateFast(DBGSTATE state);
BRIDGE_IMPEXP void GuiAddLogMessage(const char* msg);
BRIDGE_IMPEXP void GuiLogClear();
BRIDGE_IMPEXP void GuiUpdateAllViews();
BRIDGE_IMPEXP void GuiUpdateRegisterView();
BRIDGE_IMPEXP void GuiUpdateDisassemblyView();
BRIDGE_IMPEXP void GuiUpdateBreakpointsView();
BRIDGE_IMPEXP void GuiUpdateWindowTitle(const char* filename);
BRIDGE_IMPEXP HWND GuiGetWindowHandle();
BRIDGE_IMPEXP void GuiDumpAt(duint va);
BRIDGE_IMPEXP void GuiScriptAdd(int count, const char** lines);
BRIDGE_IMPEXP void GuiScriptClear();
BRIDGE_IMPEXP void GuiScriptSetIp(int line);
BRIDGE_IMPEXP void GuiScriptError(int line, const char* message);
BRIDGE_IMPEXP void GuiScriptSetTitle(const char* title);
BRIDGE_IMPEXP void GuiScriptSetInfoLine(int line, const char* info);
BRIDGE_IMPEXP void GuiScriptMessage(const char* message);
BRIDGE_IMPEXP int GuiScriptMsgyn(const char* message);
BRIDGE_IMPEXP void GuiScriptEnableHighlighting(bool enable);
BRIDGE_IMPEXP void GuiSymbolLogAdd(const char* message);
BRIDGE_IMPEXP void GuiSymbolLogClear();
BRIDGE_IMPEXP void GuiSymbolSetProgress(int percent);
BRIDGE_IMPEXP void GuiSymbolUpdateModuleList(int count, SYMBOLMODULEINFO* modules);
BRIDGE_IMPEXP void GuiSymbolRefreshCurrent();
BRIDGE_IMPEXP void GuiReferenceAddColumn(int width, const char* title);
BRIDGE_IMPEXP void GuiReferenceSetRowCount(int count);
BRIDGE_IMPEXP int GuiReferenceGetRowCount();
BRIDGE_IMPEXP int GuiReferenceSearchGetRowCount();
BRIDGE_IMPEXP void GuiReferenceDeleteAllColumns();
BRIDGE_IMPEXP void GuiReferenceInitialize(const char* name);
BRIDGE_IMPEXP void GuiReferenceSetCellContent(int row, int col, const char* str);
BRIDGE_IMPEXP char* GuiReferenceGetCellContent(int row, int col);
BRIDGE_IMPEXP char* GuiReferenceSearchGetCellContent(int row, int col);
BRIDGE_IMPEXP void GuiReferenceReloadData();
BRIDGE_IMPEXP void GuiReferenceSetSingleSelection(int index, bool scroll);
BRIDGE_IMPEXP void GuiReferenceSetProgress(int progress);
BRIDGE_IMPEXP void GuiReferenceSetCurrentTaskProgress(int progress, const char* taskTitle);
BRIDGE_IMPEXP void GuiReferenceSetSearchStartCol(int col);
BRIDGE_IMPEXP void GuiStackDumpAt(duint addr, duint csp);
BRIDGE_IMPEXP void GuiUpdateDumpView();
BRIDGE_IMPEXP void GuiUpdateWatchView();
BRIDGE_IMPEXP void GuiUpdateThreadView();
BRIDGE_IMPEXP void GuiUpdateMemoryView();
BRIDGE_IMPEXP void GuiAddRecentFile(const char* file);
BRIDGE_IMPEXP void GuiSetLastException(unsigned int exception);
BRIDGE_IMPEXP bool GuiGetDisassembly(duint addr, char* text);
BRIDGE_IMPEXP int GuiMenuAdd(int hMenu, const char* title);
BRIDGE_IMPEXP int GuiMenuAddEntry(int hMenu, const char* title);
BRIDGE_IMPEXP void GuiMenuAddSeparator(int hMenu);
BRIDGE_IMPEXP void GuiMenuClear(int hMenu);
BRIDGE_IMPEXP void GuiMenuRemove(int hEntryMenu);
BRIDGE_IMPEXP bool GuiSelectionGet(GUISELECTIONTYPE hWindow, SELECTIONDATA* selection);
BRIDGE_IMPEXP bool GuiSelectionSet(GUISELECTIONTYPE hWindow, const SELECTIONDATA* selection);
BRIDGE_IMPEXP bool GuiGetLineWindow(const char* title, char* text);
BRIDGE_IMPEXP void GuiAutoCompleteAddCmd(const char* cmd);
BRIDGE_IMPEXP void GuiAutoCompleteDelCmd(const char* cmd);
BRIDGE_IMPEXP void GuiAutoCompleteClearAll();
BRIDGE_IMPEXP void GuiAddStatusBarMessage(const char* msg);
BRIDGE_IMPEXP void GuiUpdateSideBar();
BRIDGE_IMPEXP void GuiRepaintTableView();
BRIDGE_IMPEXP void GuiUpdatePatches();
BRIDGE_IMPEXP void GuiUpdateCallStack();
BRIDGE_IMPEXP void GuiUpdateSEHChain();
BRIDGE_IMPEXP void GuiLoadSourceFileEx(const char* path, duint addr);
BRIDGE_IMPEXP void GuiMenuSetIcon(int hMenu, const ICONDATA* icon);
BRIDGE_IMPEXP void GuiMenuSetEntryIcon(int hEntry, const ICONDATA* icon);
BRIDGE_IMPEXP void GuiMenuSetEntryChecked(int hEntry, bool checked);
BRIDGE_IMPEXP void GuiMenuSetVisible(int hMenu, bool visible);
BRIDGE_IMPEXP void GuiMenuSetEntryVisible(int hEntry, bool visible);
BRIDGE_IMPEXP void GuiMenuSetName(int hMenu, const char* name);
BRIDGE_IMPEXP void GuiMenuSetEntryName(int hEntry, const char* name);
BRIDGE_IMPEXP void GuiMenuSetEntryHotkey(int hEntry, const char* hack);
BRIDGE_IMPEXP void GuiShowCpu();
BRIDGE_IMPEXP void GuiAddQWidgetTab(void* qWidget);
BRIDGE_IMPEXP void GuiShowQWidgetTab(void* qWidget);
BRIDGE_IMPEXP void GuiCloseQWidgetTab(void* qWidget);
BRIDGE_IMPEXP void GuiExecuteOnGuiThread(GUICALLBACK cbGuiThread);
BRIDGE_IMPEXP void GuiUpdateTimeWastedCounter();
BRIDGE_IMPEXP void GuiSetGlobalNotes(const char* text);
BRIDGE_IMPEXP void GuiGetGlobalNotes(char** text);
BRIDGE_IMPEXP void GuiSetDebuggeeNotes(const char* text);
BRIDGE_IMPEXP void GuiGetDebuggeeNotes(char** text);
BRIDGE_IMPEXP void GuiDumpAtN(duint va, int index);
BRIDGE_IMPEXP void GuiDisplayWarning(const char* title, const char* text);
BRIDGE_IMPEXP void GuiRegisterScriptLanguage(SCRIPTTYPEINFO* info);
BRIDGE_IMPEXP void GuiUnregisterScriptLanguage(int id);
BRIDGE_IMPEXP void GuiUpdateArgumentWidget();
BRIDGE_IMPEXP void GuiFocusView(int hWindow);
BRIDGE_IMPEXP bool GuiIsUpdateDisabled();
BRIDGE_IMPEXP void GuiUpdateEnable(bool updateNow);
BRIDGE_IMPEXP void GuiUpdateDisable();
BRIDGE_IMPEXP bool GuiLoadGraph(BridgeCFGraphList* graph, duint addr);
BRIDGE_IMPEXP duint GuiGraphAt(duint addr);
BRIDGE_IMPEXP void GuiUpdateGraphView();
BRIDGE_IMPEXP void GuiDisableLog();
BRIDGE_IMPEXP void GuiEnableLog();
BRIDGE_IMPEXP void GuiAddFavouriteTool(const char* name, const char* description);
BRIDGE_IMPEXP void GuiAddFavouriteCommand(const char* name, const char* shortcut);
BRIDGE_IMPEXP void GuiSetFavouriteToolShortcut(const char* name, const char* shortcut);
BRIDGE_IMPEXP void GuiFoldDisassembly(duint startAddress, duint length);
BRIDGE_IMPEXP void GuiSelectInMemoryMap(duint addr);
BRIDGE_IMPEXP void GuiGetActiveView(ACTIVEVIEW* activeView);
BRIDGE_IMPEXP void GuiAddInfoLine(const char* infoLine);
BRIDGE_IMPEXP void GuiProcessEvents();
BRIDGE_IMPEXP void* GuiTypeAddNode(void* parent, const TYPEDESCRIPTOR* type);
BRIDGE_IMPEXP bool GuiTypeClear();
BRIDGE_IMPEXP void GuiUpdateTypeWidget();
BRIDGE_IMPEXP void GuiCloseApplication();
BRIDGE_IMPEXP void GuiFlushLog();
BRIDGE_IMPEXP void GuiReferenceAddCommand(const char* title, const char* command);
BRIDGE_IMPEXP void GuiUpdateTraceBrowser();
BRIDGE_IMPEXP void GuiOpenTraceFile(const char* fileName);
BRIDGE_IMPEXP void GuiInvalidateSymbolSource(duint base);
BRIDGE_IMPEXP void GuiExecuteOnGuiThreadEx(GUICALLBACKEX cbGuiThread, void* userdata);
BRIDGE_IMPEXP void GuiGetCurrentGraph(BridgeCFGraphList* graphList);
BRIDGE_IMPEXP void GuiShowReferences();

#ifdef __cplusplus
}
#endif

#pragma pack(pop)

#endif // _BRIDGEMAIN_H_



================================================
File: ClawSearch/pluginsdk/DeviceNameResolver/DeviceNameResolver.h
================================================
#ifndef _DEVICENAMERESOLVER_H
#define _DEVICENAMERESOLVER_H

#include <windows.h>

#ifdef __cplusplus
extern "C"
{
#endif

__declspec(dllexport) bool DevicePathToPathW(const wchar_t* szDevicePath, wchar_t* szPath, size_t nSizeInChars);
__declspec(dllexport) bool DevicePathToPathA(const char* szDevicePath, char* szPath, size_t nSizeInChars);
__declspec(dllexport) bool DevicePathFromFileHandleW(HANDLE hFile, wchar_t* szDevicePath, size_t nSizeInChars);
__declspec(dllexport) bool DevicePathFromFileHandleA(HANDLE hFile, char* szDevicePath, size_t nSizeInChars);
__declspec(dllexport) bool PathFromFileHandleW(HANDLE hFile, wchar_t* szPath, size_t nSizeInChars);
__declspec(dllexport) bool PathFromFileHandleA(HANDLE hFile, char* szPath, size_t nSizeInChars);

#ifdef __cplusplus
}
#endif

#endif // _DEVICENAMERESOLVER_H



================================================
File: ClawSearch/pluginsdk/TitanEngine/TitanEngine.h
================================================
#ifndef TITANENGINE
#define TITANENGINE

#define TITCALL

#if _MSC_VER > 1000
#pragma once
#endif

#include <windows.h>
#include <stdint.h>

#pragma pack(push, 1)

// Global.Constant.Structure.Declaration:
// Engine.External:
#define UE_STRUCT_PE32STRUCT 1
#define UE_STRUCT_PE64STRUCT 2
#define UE_STRUCT_PESTRUCT 3
#define UE_STRUCT_IMPORTENUMDATA 4
#define UE_STRUCT_THREAD_ITEM_DATA 5
#define UE_STRUCT_LIBRARY_ITEM_DATA 6
#define UE_STRUCT_LIBRARY_ITEM_DATAW 7
#define UE_STRUCT_PROCESS_ITEM_DATA 8
#define UE_STRUCT_HANDLERARRAY 9
#define UE_STRUCT_PLUGININFORMATION 10
#define UE_STRUCT_HOOK_ENTRY 11
#define UE_STRUCT_FILE_STATUS_INFO 12
#define UE_STRUCT_FILE_FIX_INFO 13
#define UE_STRUCT_X87FPUREGISTER 14
#define UE_STRUCT_X87FPU 15
#define UE_STRUCT_TITAN_ENGINE_CONTEXT 16

#define UE_ACCESS_READ 0
#define UE_ACCESS_WRITE 1
#define UE_ACCESS_ALL 2

#define UE_HIDE_PEBONLY 0
#define UE_HIDE_BASIC 1

#define UE_PLUGIN_CALL_REASON_PREDEBUG 1
#define UE_PLUGIN_CALL_REASON_EXCEPTION 2
#define UE_PLUGIN_CALL_REASON_POSTDEBUG 3
#define UE_PLUGIN_CALL_REASON_UNHANDLEDEXCEPTION 4

#define TEE_HOOK_NRM_JUMP 1
#define TEE_HOOK_NRM_CALL 3
#define TEE_HOOK_IAT 5

#define UE_ENGINE_ALOW_MODULE_LOADING 1
#define UE_ENGINE_AUTOFIX_FORWARDERS 2
#define UE_ENGINE_PASS_ALL_EXCEPTIONS 3
#define UE_ENGINE_NO_CONSOLE_WINDOW 4
#define UE_ENGINE_BACKUP_FOR_CRITICAL_FUNCTIONS 5
#define UE_ENGINE_CALL_PLUGIN_CALLBACK 6
#define UE_ENGINE_RESET_CUSTOM_HANDLER 7
#define UE_ENGINE_CALL_PLUGIN_DEBUG_CALLBACK 8
#define UE_ENGINE_SET_DEBUG_PRIVILEGE 9
#define UE_ENGINE_SAFE_ATTACH 10

#define UE_OPTION_REMOVEALL 1
#define UE_OPTION_DISABLEALL 2
#define UE_OPTION_REMOVEALLDISABLED 3
#define UE_OPTION_REMOVEALLENABLED 4

#define UE_STATIC_DECRYPTOR_XOR 1
#define UE_STATIC_DECRYPTOR_SUB 2
#define UE_STATIC_DECRYPTOR_ADD 3

#define UE_STATIC_DECRYPTOR_FOREWARD 1
#define UE_STATIC_DECRYPTOR_BACKWARD 2

#define UE_STATIC_KEY_SIZE_1 1
#define UE_STATIC_KEY_SIZE_2 2
#define UE_STATIC_KEY_SIZE_4 4
#define UE_STATIC_KEY_SIZE_8 8

#define UE_STATIC_APLIB 1
#define UE_STATIC_APLIB_DEPACK 2
#define UE_STATIC_LZMA 3

#define UE_STATIC_HASH_MD5 1
#define UE_STATIC_HASH_SHA1 2
#define UE_STATIC_HASH_CRC32 3

#define UE_RESOURCE_LANGUAGE_ANY -1

#define UE_PE_OFFSET 0
#define UE_IMAGEBASE 1
#define UE_OEP 2
#define UE_SIZEOFIMAGE 3
#define UE_SIZEOFHEADERS 4
#define UE_SIZEOFOPTIONALHEADER 5
#define UE_SECTIONALIGNMENT 6
#define UE_IMPORTTABLEADDRESS 7
#define UE_IMPORTTABLESIZE 8
#define UE_RESOURCETABLEADDRESS 9
#define UE_RESOURCETABLESIZE 10
#define UE_EXPORTTABLEADDRESS 11
#define UE_EXPORTTABLESIZE 12
#define UE_TLSTABLEADDRESS 13
#define UE_TLSTABLESIZE 14
#define UE_RELOCATIONTABLEADDRESS 15
#define UE_RELOCATIONTABLESIZE 16
#define UE_TIMEDATESTAMP 17
#define UE_SECTIONNUMBER 18
#define UE_CHECKSUM 19
#define UE_SUBSYSTEM 20
#define UE_CHARACTERISTICS 21
#define UE_NUMBEROFRVAANDSIZES 22
#define UE_BASEOFCODE 23
#define UE_BASEOFDATA 24
#define UE_DLLCHARACTERISTICS 25
//leaving some enum space here for future additions
#define UE_SECTIONNAME 40
#define UE_SECTIONVIRTUALOFFSET 41
#define UE_SECTIONVIRTUALSIZE 42
#define UE_SECTIONRAWOFFSET 43
#define UE_SECTIONRAWSIZE 44
#define UE_SECTIONFLAGS 45

#define UE_VANOTFOUND = -2;

#define UE_CH_BREAKPOINT 1
#define UE_CH_SINGLESTEP 2
#define UE_CH_ACCESSVIOLATION 3
#define UE_CH_ILLEGALINSTRUCTION 4
#define UE_CH_NONCONTINUABLEEXCEPTION 5
#define UE_CH_ARRAYBOUNDSEXCEPTION 6
#define UE_CH_FLOATDENORMALOPERAND 7
#define UE_CH_FLOATDEVIDEBYZERO 8
#define UE_CH_INTEGERDEVIDEBYZERO 9
#define UE_CH_INTEGEROVERFLOW 10
#define UE_CH_PRIVILEGEDINSTRUCTION 11
#define UE_CH_PAGEGUARD 12
#define UE_CH_EVERYTHINGELSE 13
#define UE_CH_CREATETHREAD 14
#define UE_CH_EXITTHREAD 15
#define UE_CH_CREATEPROCESS 16
#define UE_CH_EXITPROCESS 17
#define UE_CH_LOADDLL 18
#define UE_CH_UNLOADDLL 19
#define UE_CH_OUTPUTDEBUGSTRING 20
#define UE_CH_AFTEREXCEPTIONPROCESSING 21
#define UE_CH_SYSTEMBREAKPOINT 23
#define UE_CH_UNHANDLEDEXCEPTION 24
#define UE_CH_RIPEVENT 25
#define UE_CH_DEBUGEVENT 26

#define UE_OPTION_HANDLER_RETURN_HANDLECOUNT 1
#define UE_OPTION_HANDLER_RETURN_ACCESS 2
#define UE_OPTION_HANDLER_RETURN_FLAGS 3
#define UE_OPTION_HANDLER_RETURN_TYPENAME 4

#define UE_BREAKPOINT_INT3 1
#define UE_BREAKPOINT_LONG_INT3 2
#define UE_BREAKPOINT_UD2 3

#define UE_BPXREMOVED 0
#define UE_BPXACTIVE 1
#define UE_BPXINACTIVE 2

#define UE_BREAKPOINT 0
#define UE_SINGLESHOOT 1
#define UE_HARDWARE 2
#define UE_MEMORY 3
#define UE_MEMORY_READ 4
#define UE_MEMORY_WRITE 5
#define UE_MEMORY_EXECUTE 6
#define UE_BREAKPOINT_TYPE_INT3 0x10000000
#define UE_BREAKPOINT_TYPE_LONG_INT3 0x20000000
#define UE_BREAKPOINT_TYPE_UD2 0x30000000

#define UE_HARDWARE_EXECUTE 4
#define UE_HARDWARE_WRITE 5
#define UE_HARDWARE_READWRITE 6

#define UE_HARDWARE_SIZE_1 7
#define UE_HARDWARE_SIZE_2 8
#define UE_HARDWARE_SIZE_4 9
#define UE_HARDWARE_SIZE_8 10

#define UE_ON_LIB_LOAD 1
#define UE_ON_LIB_UNLOAD 2
#define UE_ON_LIB_ALL 3

#define UE_APISTART 0
#define UE_APIEND 1

#define UE_PLATFORM_x86 1
#define UE_PLATFORM_x64 2
#define UE_PLATFORM_ALL 3

#define UE_FUNCTION_STDCALL 1
#define UE_FUNCTION_CCALL 2
#define UE_FUNCTION_FASTCALL 3
#define UE_FUNCTION_STDCALL_RET 4
#define UE_FUNCTION_CCALL_RET 5
#define UE_FUNCTION_FASTCALL_RET 6
#define UE_FUNCTION_STDCALL_CALL 7
#define UE_FUNCTION_CCALL_CALL 8
#define UE_FUNCTION_FASTCALL_CALL 9
#define UE_PARAMETER_BYTE 0
#define UE_PARAMETER_WORD 1
#define UE_PARAMETER_DWORD 2
#define UE_PARAMETER_QWORD 3
#define UE_PARAMETER_PTR_BYTE 4
#define UE_PARAMETER_PTR_WORD 5
#define UE_PARAMETER_PTR_DWORD 6
#define UE_PARAMETER_PTR_QWORD 7
#define UE_PARAMETER_STRING 8
#define UE_PARAMETER_UNICODE 9

#define UE_EAX 1
#define UE_EBX 2
#define UE_ECX 3
#define UE_EDX 4
#define UE_EDI 5
#define UE_ESI 6
#define UE_EBP 7
#define UE_ESP 8
#define UE_EIP 9
#define UE_EFLAGS 10
#define UE_DR0 11
#define UE_DR1 12
#define UE_DR2 13
#define UE_DR3 14
#define UE_DR6 15
#define UE_DR7 16
#define UE_RAX 17
#define UE_RBX 18
#define UE_RCX 19
#define UE_RDX 20
#define UE_RDI 21
#define UE_RSI 22
#define UE_RBP 23
#define UE_RSP 24
#define UE_RIP 25
#define UE_RFLAGS 26
#define UE_R8 27
#define UE_R9 28
#define UE_R10 29
#define UE_R11 30
#define UE_R12 31
#define UE_R13 32
#define UE_R14 33
#define UE_R15 34
#define UE_CIP 35
#define UE_CSP 36
#ifdef _WIN64
#define UE_CFLAGS UE_RFLAGS
#else
#define UE_CFLAGS UE_EFLAGS
#endif
#define UE_SEG_GS 37
#define UE_SEG_FS 38
#define UE_SEG_ES 39
#define UE_SEG_DS 40
#define UE_SEG_CS 41
#define UE_SEG_SS 42
#define UE_x87_r0 43
#define UE_x87_r1 44
#define UE_x87_r2 45
#define UE_x87_r3 46
#define UE_x87_r4 47
#define UE_x87_r5 48
#define UE_x87_r6 49
#define UE_x87_r7 50
#define UE_X87_STATUSWORD 51
#define UE_X87_CONTROLWORD 52
#define UE_X87_TAGWORD 53
#define UE_MXCSR 54
#define UE_MMX0 55
#define UE_MMX1 56
#define UE_MMX2 57
#define UE_MMX3 58
#define UE_MMX4 59
#define UE_MMX5 60
#define UE_MMX6 61
#define UE_MMX7 62
#define UE_XMM0 63
#define UE_XMM1 64
#define UE_XMM2 65
#define UE_XMM3 66
#define UE_XMM4 67
#define UE_XMM5 68
#define UE_XMM6 69
#define UE_XMM7 70
#define UE_XMM8 71
#define UE_XMM9 72
#define UE_XMM10 73
#define UE_XMM11 74
#define UE_XMM12 75
#define UE_XMM13 76
#define UE_XMM14 77
#define UE_XMM15 78
#define UE_x87_ST0 79
#define UE_x87_ST1 80
#define UE_x87_ST2 81
#define UE_x87_ST3 82
#define UE_x87_ST4 83
#define UE_x87_ST5 84
#define UE_x87_ST6 85
#define UE_x87_ST7 86
#define UE_YMM0 87
#define UE_YMM1 88
#define UE_YMM2 89
#define UE_YMM3 90
#define UE_YMM4 91
#define UE_YMM5 92
#define UE_YMM6 93
#define UE_YMM7 94
#define UE_YMM8 95
#define UE_YMM9 96
#define UE_YMM10 97
#define UE_YMM11 98
#define UE_YMM12 99
#define UE_YMM13 100
#define UE_YMM14 101
#define UE_YMM15 102

#ifndef CONTEXT_EXTENDED_REGISTERS
#define CONTEXT_EXTENDED_REGISTERS 0
#endif

typedef struct
{
    DWORD PE32Offset;
    DWORD ImageBase;
    DWORD OriginalEntryPoint;
    DWORD BaseOfCode;
    DWORD BaseOfData;
    DWORD NtSizeOfImage;
    DWORD NtSizeOfHeaders;
    WORD SizeOfOptionalHeaders;
    DWORD FileAlignment;
    DWORD SectionAligment;
    DWORD ImportTableAddress;
    DWORD ImportTableSize;
    DWORD ResourceTableAddress;
    DWORD ResourceTableSize;
    DWORD ExportTableAddress;
    DWORD ExportTableSize;
    DWORD TLSTableAddress;
    DWORD TLSTableSize;
    DWORD RelocationTableAddress;
    DWORD RelocationTableSize;
    DWORD TimeDateStamp;
    WORD SectionNumber;
    DWORD CheckSum;
    WORD SubSystem;
    WORD Characteristics;
    DWORD NumberOfRvaAndSizes;
} PE32Struct, *PPE32Struct;

typedef struct
{
    DWORD PE64Offset;
    DWORD64 ImageBase;
    DWORD OriginalEntryPoint;
    DWORD BaseOfCode;
    DWORD BaseOfData;
    DWORD NtSizeOfImage;
    DWORD NtSizeOfHeaders;
    WORD SizeOfOptionalHeaders;
    DWORD FileAlignment;
    DWORD SectionAligment;
    DWORD ImportTableAddress;
    DWORD ImportTableSize;
    DWORD ResourceTableAddress;
    DWORD ResourceTableSize;
    DWORD ExportTableAddress;
    DWORD ExportTableSize;
    DWORD TLSTableAddress;
    DWORD TLSTableSize;
    DWORD RelocationTableAddress;
    DWORD RelocationTableSize;
    DWORD TimeDateStamp;
    WORD SectionNumber;
    DWORD CheckSum;
    WORD SubSystem;
    WORD Characteristics;
    DWORD NumberOfRvaAndSizes;
} PE64Struct, *PPE64Struct;

#if defined(_WIN64)
typedef PE64Struct PEStruct;
#else
typedef PE32Struct PEStruct;
#endif

typedef struct
{
    bool NewDll;
    int NumberOfImports;
    ULONG_PTR ImageBase;
    ULONG_PTR BaseImportThunk;
    ULONG_PTR ImportThunk;
    char* APIName;
    char* DLLName;
} ImportEnumData, *PImportEnumData;

typedef struct
{
    HANDLE hThread;
    DWORD dwThreadId;
    void* ThreadStartAddress;
    void* ThreadLocalBase;
    void* TebAddress;
    ULONG WaitTime;
    LONG Priority;
    LONG BasePriority;
    ULONG ContextSwitches;
    ULONG ThreadState;
    ULONG WaitReason;
} THREAD_ITEM_DATA, *PTHREAD_ITEM_DATA;

typedef struct
{
    HANDLE hFile;
    void* BaseOfDll;
    HANDLE hFileMapping;
    void* hFileMappingView;
    char szLibraryPath[MAX_PATH];
    char szLibraryName[MAX_PATH];
} LIBRARY_ITEM_DATA, *PLIBRARY_ITEM_DATA;

typedef struct
{
    HANDLE hFile;
    void* BaseOfDll;
    HANDLE hFileMapping;
    void* hFileMappingView;
    wchar_t szLibraryPath[MAX_PATH];
    wchar_t szLibraryName[MAX_PATH];
} LIBRARY_ITEM_DATAW, *PLIBRARY_ITEM_DATAW;

typedef struct
{
    HANDLE hProcess;
    DWORD dwProcessId;
    HANDLE hThread;
    DWORD dwThreadId;
    HANDLE hFile;
    void* BaseOfImage;
    void* ThreadStartAddress;
    void* ThreadLocalBase;
} PROCESS_ITEM_DATA, *PPROCESS_ITEM_DATA;

typedef struct
{
    ULONG ProcessId;
    HANDLE hHandle;
} HandlerArray, *PHandlerArray;

typedef struct
{
    char PluginName[64];
    DWORD PluginMajorVersion;
    DWORD PluginMinorVersion;
    HMODULE PluginBaseAddress;
    void* TitanDebuggingCallBack;
    void* TitanRegisterPlugin;
    void* TitanReleasePlugin;
    void* TitanResetPlugin;
    bool PluginDisabled;
} PluginInformation, *PPluginInformation;

#define TEE_MAXIMUM_HOOK_SIZE 14
#define TEE_MAXIMUM_HOOK_RELOCS 7
#if defined(_WIN64)
#define TEE_MAXIMUM_HOOK_INSERT_SIZE 14
#else
#define TEE_MAXIMUM_HOOK_INSERT_SIZE 5
#endif

typedef struct HOOK_ENTRY
{
    bool IATHook;
    BYTE HookType;
    DWORD HookSize;
    void* HookAddress;
    void* RedirectionAddress;
    BYTE HookBytes[TEE_MAXIMUM_HOOK_SIZE];
    BYTE OriginalBytes[TEE_MAXIMUM_HOOK_SIZE];
    void* IATHookModuleBase;
    DWORD IATHookNameHash;
    bool HookIsEnabled;
    bool HookIsRemote;
    void* PatchedEntry;
    DWORD RelocationInfo[TEE_MAXIMUM_HOOK_RELOCS];
    int RelocationCount;
} HOOK_ENTRY, *PHOOK_ENTRY;

#define UE_DEPTH_SURFACE 0
#define UE_DEPTH_DEEP 1

#define UE_UNPACKER_CONDITION_SEARCH_FROM_EP 1

#define UE_UNPACKER_CONDITION_LOADLIBRARY 1
#define UE_UNPACKER_CONDITION_GETPROCADDRESS 2
#define UE_UNPACKER_CONDITION_ENTRYPOINTBREAK 3
#define UE_UNPACKER_CONDITION_RELOCSNAPSHOT1 4
#define UE_UNPACKER_CONDITION_RELOCSNAPSHOT2 5

#define UE_FIELD_OK 0
#define UE_FIELD_BROKEN_NON_FIXABLE 1
#define UE_FIELD_BROKEN_NON_CRITICAL 2
#define UE_FIELD_BROKEN_FIXABLE_FOR_STATIC_USE 3
#define UE_FIELD_BROKEN_BUT_CAN_BE_EMULATED 4
#define UE_FIELD_FIXABLE_NON_CRITICAL 5
#define UE_FIELD_FIXABLE_CRITICAL 6
#define UE_FIELD_NOT_PRESET 7
#define UE_FIELD_NOT_PRESET_WARNING 8

#define UE_RESULT_FILE_OK 10
#define UE_RESULT_FILE_INVALID_BUT_FIXABLE 11
#define UE_RESULT_FILE_INVALID_AND_NON_FIXABLE 12
#define UE_RESULT_FILE_INVALID_FORMAT 13

typedef struct
{
    BYTE OveralEvaluation;
    bool EvaluationTerminatedByException;
    bool FileIs64Bit;
    bool FileIsDLL;
    bool FileIsConsole;
    bool MissingDependencies;
    bool MissingDeclaredAPIs;
    BYTE SignatureMZ;
    BYTE SignaturePE;
    BYTE EntryPoint;
    BYTE ImageBase;
    BYTE SizeOfImage;
    BYTE FileAlignment;
    BYTE SectionAlignment;
    BYTE ExportTable;
    BYTE RelocationTable;
    BYTE ImportTable;
    BYTE ImportTableSection;
    BYTE ImportTableData;
    BYTE IATTable;
    BYTE TLSTable;
    BYTE LoadConfigTable;
    BYTE BoundImportTable;
    BYTE COMHeaderTable;
    BYTE ResourceTable;
    BYTE ResourceData;
    BYTE SectionTable;
} FILE_STATUS_INFO, *PFILE_STATUS_INFO;

typedef struct
{
    BYTE OveralEvaluation;
    bool FixingTerminatedByException;
    bool FileFixPerformed;
    bool StrippedRelocation;
    bool DontFixRelocations;
    DWORD OriginalRelocationTableAddress;
    DWORD OriginalRelocationTableSize;
    bool StrippedExports;
    bool DontFixExports;
    DWORD OriginalExportTableAddress;
    DWORD OriginalExportTableSize;
    bool StrippedResources;
    bool DontFixResources;
    DWORD OriginalResourceTableAddress;
    DWORD OriginalResourceTableSize;
    bool StrippedTLS;
    bool DontFixTLS;
    DWORD OriginalTLSTableAddress;
    DWORD OriginalTLSTableSize;
    bool StrippedLoadConfig;
    bool DontFixLoadConfig;
    DWORD OriginalLoadConfigTableAddress;
    DWORD OriginalLoadConfigTableSize;
    bool StrippedBoundImports;
    bool DontFixBoundImports;
    DWORD OriginalBoundImportTableAddress;
    DWORD OriginalBoundImportTableSize;
    bool StrippedIAT;
    bool DontFixIAT;
    DWORD OriginalImportAddressTableAddress;
    DWORD OriginalImportAddressTableSize;
    bool StrippedCOM;
    bool DontFixCOM;
    DWORD OriginalCOMTableAddress;
    DWORD OriginalCOMTableSize;
} FILE_FIX_INFO, *PFILE_FIX_INFO;

typedef struct DECLSPEC_ALIGN(16) _XmmRegister_t
{
    ULONGLONG Low;
    LONGLONG High;
} XmmRegister_t;

typedef struct
{
    XmmRegister_t Low; //XMM/SSE part
    XmmRegister_t High; //AVX part
} YmmRegister_t;

typedef struct
{
    BYTE    data[10];
    int     st_value;
    int     tag;
} x87FPURegister_t;

typedef struct
{
    WORD   ControlWord;
    WORD   StatusWord;
    WORD   TagWord;
    DWORD   ErrorOffset;
    DWORD   ErrorSelector;
    DWORD   DataOffset;
    DWORD   DataSelector;
    DWORD   Cr0NpxState;
} x87FPU_t;

typedef struct
{
    ULONG_PTR cax;
    ULONG_PTR ccx;
    ULONG_PTR cdx;
    ULONG_PTR cbx;
    ULONG_PTR csp;
    ULONG_PTR cbp;
    ULONG_PTR csi;
    ULONG_PTR cdi;
#ifdef _WIN64
    ULONG_PTR r8;
    ULONG_PTR r9;
    ULONG_PTR r10;
    ULONG_PTR r11;
    ULONG_PTR r12;
    ULONG_PTR r13;
    ULONG_PTR r14;
    ULONG_PTR r15;
#endif //_WIN64
    ULONG_PTR cip;
    ULONG_PTR eflags;
    unsigned short gs;
    unsigned short fs;
    unsigned short es;
    unsigned short ds;
    unsigned short cs;
    unsigned short ss;
    ULONG_PTR dr0;
    ULONG_PTR dr1;
    ULONG_PTR dr2;
    ULONG_PTR dr3;
    ULONG_PTR dr6;
    ULONG_PTR dr7;
    BYTE RegisterArea[80];
    x87FPU_t x87fpu;
    DWORD MxCsr;
#ifdef _WIN64
    XmmRegister_t XmmRegisters[16];
    YmmRegister_t YmmRegisters[16];
#else // x86
    XmmRegister_t XmmRegisters[8];
    YmmRegister_t YmmRegisters[8];
#endif
} TITAN_ENGINE_CONTEXT_t;

#ifdef __cplusplus
extern "C"
{
#endif

// Global.Function.Declaration:
// TitanEngine.Dumper.functions:
__declspec(dllexport) bool TITCALL DumpProcess(HANDLE hProcess, LPVOID ImageBase, const char* szDumpFileName, ULONG_PTR EntryPoint);
__declspec(dllexport) bool TITCALL DumpProcessW(HANDLE hProcess, LPVOID ImageBase, const wchar_t* szDumpFileName, ULONG_PTR EntryPoint);
__declspec(dllexport) bool TITCALL DumpProcessEx(DWORD ProcessId, LPVOID ImageBase, const char* szDumpFileName, ULONG_PTR EntryPoint);
__declspec(dllexport) bool TITCALL DumpProcessExW(DWORD ProcessId, LPVOID ImageBase, const wchar_t* szDumpFileName, ULONG_PTR EntryPoint);
__declspec(dllexport) bool TITCALL DumpMemory(HANDLE hProcess, LPVOID MemoryStart, ULONG_PTR MemorySize, const char* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpMemoryW(HANDLE hProcess, LPVOID MemoryStart, ULONG_PTR MemorySize, const wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpMemoryEx(DWORD ProcessId, LPVOID MemoryStart, ULONG_PTR MemorySize, const char* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpMemoryExW(DWORD ProcessId, LPVOID MemoryStart, ULONG_PTR MemorySize, const wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpRegions(HANDLE hProcess, const char* szDumpFolder, bool DumpAboveImageBaseOnly);
__declspec(dllexport) bool TITCALL DumpRegionsW(HANDLE hProcess, const wchar_t* szDumpFolder, bool DumpAboveImageBaseOnly);
__declspec(dllexport) bool TITCALL DumpRegionsEx(DWORD ProcessId, const char* szDumpFolder, bool DumpAboveImageBaseOnly);
__declspec(dllexport) bool TITCALL DumpRegionsExW(DWORD ProcessId, const wchar_t* szDumpFolder, bool DumpAboveImageBaseOnly);
__declspec(dllexport) bool TITCALL DumpModule(HANDLE hProcess, LPVOID ModuleBase, const char* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpModuleW(HANDLE hProcess, LPVOID ModuleBase, const wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpModuleEx(DWORD ProcessId, LPVOID ModuleBase, const char* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpModuleExW(DWORD ProcessId, LPVOID ModuleBase, const wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL PastePEHeader(HANDLE hProcess, LPVOID ImageBase, const char* szDebuggedFileName);
__declspec(dllexport) bool TITCALL PastePEHeaderW(HANDLE hProcess, LPVOID ImageBase, const wchar_t* szDebuggedFileName);
__declspec(dllexport) bool TITCALL ExtractSection(const char* szFileName, const char* szDumpFileName, DWORD SectionNumber);
__declspec(dllexport) bool TITCALL ExtractSectionW(const wchar_t* szFileName, const wchar_t* szDumpFileName, DWORD SectionNumber);
__declspec(dllexport) bool TITCALL ResortFileSections(const char* szFileName);
__declspec(dllexport) bool TITCALL ResortFileSectionsW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL FindOverlay(const char* szFileName, LPDWORD OverlayStart, LPDWORD OverlaySize);
__declspec(dllexport) bool TITCALL FindOverlayW(const wchar_t* szFileName, LPDWORD OverlayStart, LPDWORD OverlaySize);
__declspec(dllexport) bool TITCALL ExtractOverlay(const char* szFileName, const char* szExtactedFileName);
__declspec(dllexport) bool TITCALL ExtractOverlayW(const wchar_t* szFileName, const wchar_t* szExtactedFileName);
__declspec(dllexport) bool TITCALL AddOverlay(const char* szFileName, const char* szOverlayFileName);
__declspec(dllexport) bool TITCALL AddOverlayW(const wchar_t* szFileName, const wchar_t* szOverlayFileName);
__declspec(dllexport) bool TITCALL CopyOverlay(const char* szInFileName, const char* szOutFileName);
__declspec(dllexport) bool TITCALL CopyOverlayW(const wchar_t* szInFileName, const wchar_t* szOutFileName);
__declspec(dllexport) bool TITCALL RemoveOverlay(const char* szFileName);
__declspec(dllexport) bool TITCALL RemoveOverlayW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL MakeAllSectionsRWE(const char* szFileName);
__declspec(dllexport) bool TITCALL MakeAllSectionsRWEW(const wchar_t* szFileName);
__declspec(dllexport) long TITCALL AddNewSectionEx(const char* szFileName, const char* szSectionName, DWORD SectionSize, DWORD SectionAttributes, LPVOID SectionContent, DWORD ContentSize);
__declspec(dllexport) long TITCALL AddNewSectionExW(const wchar_t* szFileName, const char* szSectionName, DWORD SectionSize, DWORD SectionAttributes, LPVOID SectionContent, DWORD ContentSize);
__declspec(dllexport) long TITCALL AddNewSection(const char* szFileName, const char* szSectionName, DWORD SectionSize);
__declspec(dllexport) long TITCALL AddNewSectionW(const wchar_t* szFileName, const char* szSectionName, DWORD SectionSize);
__declspec(dllexport) bool TITCALL ResizeLastSection(const char* szFileName, DWORD NumberOfExpandBytes, bool AlignResizeData);
__declspec(dllexport) bool TITCALL ResizeLastSectionW(const wchar_t* szFileName, DWORD NumberOfExpandBytes, bool AlignResizeData);
__declspec(dllexport) void TITCALL SetSharedOverlay(const char* szFileName);
__declspec(dllexport) void TITCALL SetSharedOverlayW(const wchar_t* szFileName);
__declspec(dllexport) char* TITCALL GetSharedOverlay();
__declspec(dllexport) wchar_t* TITCALL GetSharedOverlayW();
__declspec(dllexport) bool TITCALL DeleteLastSection(const char* szFileName);
__declspec(dllexport) bool TITCALL DeleteLastSectionW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL DeleteLastSectionEx(const char* szFileName, DWORD NumberOfSections);
__declspec(dllexport) bool TITCALL DeleteLastSectionExW(const wchar_t* szFileName, DWORD NumberOfSections);
__declspec(dllexport) ULONG_PTR TITCALL GetPE32DataFromMappedFile(ULONG_PTR FileMapVA, DWORD WhichSection, DWORD WhichData);
__declspec(dllexport) ULONG_PTR TITCALL GetPE32Data(const char* szFileName, DWORD WhichSection, DWORD WhichData);
__declspec(dllexport) ULONG_PTR TITCALL GetPE32DataW(const wchar_t* szFileName, DWORD WhichSection, DWORD WhichData);
__declspec(dllexport) bool TITCALL GetPE32DataFromMappedFileEx(ULONG_PTR FileMapVA, LPVOID DataStorage);
__declspec(dllexport) bool TITCALL GetPE32DataEx(const char* szFileName, LPVOID DataStorage);
__declspec(dllexport) bool TITCALL GetPE32DataExW(const wchar_t* szFileName, LPVOID DataStorage);
__declspec(dllexport) bool TITCALL SetPE32DataForMappedFile(ULONG_PTR FileMapVA, DWORD WhichSection, DWORD WhichData, ULONG_PTR NewDataValue);
__declspec(dllexport) bool TITCALL SetPE32Data(const char* szFileName, DWORD WhichSection, DWORD WhichData, ULONG_PTR NewDataValue);
__declspec(dllexport) bool TITCALL SetPE32DataW(const wchar_t* szFileName, DWORD WhichSection, DWORD WhichData, ULONG_PTR NewDataValue);
__declspec(dllexport) bool TITCALL SetPE32DataForMappedFileEx(ULONG_PTR FileMapVA, LPVOID DataStorage);
__declspec(dllexport) bool TITCALL SetPE32DataEx(const char* szFileName, LPVOID DataStorage);
__declspec(dllexport) bool TITCALL SetPE32DataExW(const wchar_t* szFileName, LPVOID DataStorage);
__declspec(dllexport) long TITCALL GetPE32SectionNumberFromVA(ULONG_PTR FileMapVA, ULONG_PTR AddressToConvert);
__declspec(dllexport) ULONG_PTR TITCALL ConvertVAtoFileOffset(ULONG_PTR FileMapVA, ULONG_PTR AddressToConvert, bool ReturnType);
__declspec(dllexport) ULONG_PTR TITCALL ConvertVAtoFileOffsetEx(ULONG_PTR FileMapVA, DWORD FileSize, ULONG_PTR ImageBase, ULONG_PTR AddressToConvert, bool AddressIsRVA, bool ReturnType);
__declspec(dllexport) ULONG_PTR TITCALL ConvertFileOffsetToVA(ULONG_PTR FileMapVA, ULONG_PTR AddressToConvert, bool ReturnType);
__declspec(dllexport) ULONG_PTR TITCALL ConvertFileOffsetToVAEx(ULONG_PTR FileMapVA, DWORD FileSize, ULONG_PTR ImageBase, ULONG_PTR AddressToConvert, bool ReturnType);
__declspec(dllexport) bool TITCALL MemoryReadSafe(HANDLE hProcess, LPVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T* lpNumberOfBytesRead);
__declspec(dllexport) bool TITCALL MemoryWriteSafe(HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T* lpNumberOfBytesWritten);
// TitanEngine.Realigner.functions:
__declspec(dllexport) bool TITCALL FixHeaderCheckSum(const char* szFileName);
__declspec(dllexport) bool TITCALL FixHeaderCheckSumW(const wchar_t* szFileName);
__declspec(dllexport) long TITCALL RealignPE(ULONG_PTR FileMapVA, DWORD FileSize, DWORD RealingMode);
__declspec(dllexport) long TITCALL RealignPEEx(const char* szFileName, DWORD RealingFileSize, DWORD ForcedFileAlignment);
__declspec(dllexport) long TITCALL RealignPEExW(const wchar_t* szFileName, DWORD RealingFileSize, DWORD ForcedFileAlignment);
__declspec(dllexport) bool TITCALL WipeSection(const char* szFileName, int WipeSectionNumber, bool RemovePhysically);
__declspec(dllexport) bool TITCALL WipeSectionW(const wchar_t* szFileName, int WipeSectionNumber, bool RemovePhysically);
__declspec(dllexport) bool TITCALL IsPE32FileValidEx(const char* szFileName, DWORD CheckDepth, LPVOID FileStatusInfo);
__declspec(dllexport) bool TITCALL IsPE32FileValidExW(const wchar_t* szFileName, DWORD CheckDepth, LPVOID FileStatusInfo);
__declspec(dllexport) bool TITCALL FixBrokenPE32FileEx(const char* szFileName, LPVOID FileStatusInfo, LPVOID FileFixInfo);
__declspec(dllexport) bool TITCALL FixBrokenPE32FileExW(const wchar_t* szFileName, LPVOID FileStatusInfo, LPVOID FileFixInfo);
__declspec(dllexport) bool TITCALL IsFileDLL(const char* szFileName, ULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL IsFileDLLW(const wchar_t* szFileName, ULONG_PTR FileMapVA);
// TitanEngine.Hider.functions:
__declspec(dllexport) void* TITCALL GetPEBLocation(HANDLE hProcess);
__declspec(dllexport) void* TITCALL GetPEBLocation64(HANDLE hProcess);
__declspec(dllexport) void* TITCALL GetTEBLocation(HANDLE hThread);
__declspec(dllexport) void* TITCALL GetTEBLocation64(HANDLE hThread);
__declspec(dllexport) bool TITCALL HideDebugger(HANDLE hProcess, DWORD PatchAPILevel);
__declspec(dllexport) bool TITCALL UnHideDebugger(HANDLE hProcess, DWORD PatchAPILevel);
// TitanEngine.Relocater.functions:
__declspec(dllexport) void TITCALL RelocaterCleanup();
__declspec(dllexport) void TITCALL RelocaterInit(DWORD MemorySize, ULONG_PTR OldImageBase, ULONG_PTR NewImageBase);
__declspec(dllexport) void TITCALL RelocaterAddNewRelocation(HANDLE hProcess, ULONG_PTR RelocateAddress, DWORD RelocateState);
__declspec(dllexport) long TITCALL RelocaterEstimatedSize();
__declspec(dllexport) bool TITCALL RelocaterExportRelocation(ULONG_PTR StorePlace, DWORD StorePlaceRVA, ULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL RelocaterExportRelocationEx(const char* szFileName, const char* szSectionName);
__declspec(dllexport) bool TITCALL RelocaterExportRelocationExW(const wchar_t* szFileName, const char* szSectionName);
__declspec(dllexport) bool TITCALL RelocaterGrabRelocationTable(HANDLE hProcess, ULONG_PTR MemoryStart, DWORD MemorySize);
__declspec(dllexport) bool TITCALL RelocaterGrabRelocationTableEx(HANDLE hProcess, ULONG_PTR MemoryStart, ULONG_PTR MemorySize, DWORD NtSizeOfImage);
__declspec(dllexport) bool TITCALL RelocaterMakeSnapshot(HANDLE hProcess, const char* szSaveFileName, LPVOID MemoryStart, ULONG_PTR MemorySize);
__declspec(dllexport) bool TITCALL RelocaterMakeSnapshotW(HANDLE hProcess, const wchar_t* szSaveFileName, LPVOID MemoryStart, ULONG_PTR MemorySize);
__declspec(dllexport) bool TITCALL RelocaterCompareTwoSnapshots(HANDLE hProcess, ULONG_PTR LoadedImageBase, ULONG_PTR NtSizeOfImage, const char* szDumpFile1, const char* szDumpFile2, ULONG_PTR MemStart);
__declspec(dllexport) bool TITCALL RelocaterCompareTwoSnapshotsW(HANDLE hProcess, ULONG_PTR LoadedImageBase, ULONG_PTR NtSizeOfImage, const wchar_t* szDumpFile1, const wchar_t* szDumpFile2, ULONG_PTR MemStart);
__declspec(dllexport) bool TITCALL RelocaterChangeFileBase(const char* szFileName, ULONG_PTR NewImageBase);
__declspec(dllexport) bool TITCALL RelocaterChangeFileBaseW(const wchar_t* szFileName, ULONG_PTR NewImageBase);
__declspec(dllexport) bool TITCALL RelocaterRelocateMemoryBlock(ULONG_PTR FileMapVA, ULONG_PTR MemoryLocation, void* RelocateMemory, DWORD RelocateMemorySize, ULONG_PTR CurrentLoadedBase, ULONG_PTR RelocateBase);
__declspec(dllexport) bool TITCALL RelocaterWipeRelocationTable(const char* szFileName);
__declspec(dllexport) bool TITCALL RelocaterWipeRelocationTableW(const wchar_t* szFileName);
// TitanEngine.Resourcer.functions:
__declspec(dllexport) ULONG_PTR TITCALL ResourcerLoadFileForResourceUse(const char* szFileName);
__declspec(dllexport) ULONG_PTR TITCALL ResourcerLoadFileForResourceUseW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL ResourcerFreeLoadedFile(LPVOID LoadedFileBase);
__declspec(dllexport) bool TITCALL ResourcerExtractResourceFromFileEx(HMODULE hFile, const char* szResourceType, const char* szResourceName, const char* szExtractedFileName);
__declspec(dllexport) bool TITCALL ResourcerExtractResourceFromFile(const char* szFileName, const char* szResourceType, const char* szResourceName, const char* szExtractedFileName);
__declspec(dllexport) bool TITCALL ResourcerExtractResourceFromFileW(const wchar_t* szFileName, char* szResourceType, const char* szResourceName, const char* szExtractedFileName);
__declspec(dllexport) bool TITCALL ResourcerFindResource(const char* szFileName, const char* szResourceType, DWORD ResourceType, const char* szResourceName, DWORD ResourceName, DWORD ResourceLanguage, PULONG_PTR pResourceData, LPDWORD pResourceSize);
__declspec(dllexport) bool TITCALL ResourcerFindResourceW(const wchar_t* szFileName, const wchar_t* szResourceType, DWORD ResourceType, const wchar_t* szResourceName, DWORD ResourceName, DWORD ResourceLanguage, PULONG_PTR pResourceData, LPDWORD pResourceSize);
__declspec(dllexport) bool TITCALL ResourcerFindResourceEx(ULONG_PTR FileMapVA, DWORD FileSize, const wchar_t* szResourceType, DWORD ResourceType, const wchar_t* szResourceName, DWORD ResourceName, DWORD ResourceLanguage, PULONG_PTR pResourceData, LPDWORD pResourceSize);
__declspec(dllexport) void TITCALL ResourcerEnumerateResource(const char* szFileName, void* CallBack);
__declspec(dllexport) void TITCALL ResourcerEnumerateResourceW(const wchar_t* szFileName, void* CallBack);
__declspec(dllexport) void TITCALL ResourcerEnumerateResourceEx(ULONG_PTR FileMapVA, DWORD FileSize, void* CallBack);
// TitanEngine.Threader.functions:
__declspec(dllexport) bool TITCALL ThreaderImportRunningThreadData(DWORD ProcessId);
__declspec(dllexport) void* TITCALL ThreaderGetThreadInfo(HANDLE hThread, DWORD ThreadId);
__declspec(dllexport) void TITCALL ThreaderEnumThreadInfo(void* EnumCallBack);
__declspec(dllexport) bool TITCALL ThreaderPauseThread(HANDLE hThread);
__declspec(dllexport) bool TITCALL ThreaderResumeThread(HANDLE hThread);
__declspec(dllexport) bool TITCALL ThreaderTerminateThread(HANDLE hThread, DWORD ThreadExitCode);
__declspec(dllexport) bool TITCALL ThreaderPauseAllThreads(bool LeaveMainRunning);
__declspec(dllexport) bool TITCALL ThreaderResumeAllThreads(bool LeaveMainPaused);
__declspec(dllexport) bool TITCALL ThreaderPauseProcess();
__declspec(dllexport) bool TITCALL ThreaderResumeProcess();
__declspec(dllexport) ULONG_PTR TITCALL ThreaderCreateRemoteThread(ULONG_PTR ThreadStartAddress, bool AutoCloseTheHandle, LPVOID ThreadPassParameter, LPDWORD ThreadId);
__declspec(dllexport) bool TITCALL ThreaderInjectAndExecuteCode(LPVOID InjectCode, DWORD StartDelta, DWORD InjectSize);
__declspec(dllexport) ULONG_PTR TITCALL ThreaderCreateRemoteThreadEx(HANDLE hProcess, ULONG_PTR ThreadStartAddress, bool AutoCloseTheHandle, LPVOID ThreadPassParameter, LPDWORD ThreadId);
__declspec(dllexport) bool TITCALL ThreaderInjectAndExecuteCodeEx(HANDLE hProcess, LPVOID InjectCode, DWORD StartDelta, DWORD InjectSize);
__declspec(dllexport) void TITCALL ThreaderSetCallBackForNextExitThreadEvent(LPVOID exitThreadCallBack);
__declspec(dllexport) bool TITCALL ThreaderIsThreadStillRunning(HANDLE hThread);
__declspec(dllexport) bool TITCALL ThreaderIsThreadActive(HANDLE hThread);
__declspec(dllexport) bool TITCALL ThreaderIsAnyThreadActive();
__declspec(dllexport) bool TITCALL ThreaderExecuteOnlyInjectedThreads();
__declspec(dllexport) ULONG_PTR TITCALL ThreaderGetOpenHandleForThread(DWORD ThreadId);
__declspec(dllexport) bool TITCALL ThreaderIsExceptionInMainThread();
// TitanEngine.Debugger.functions:
__declspec(dllexport) void* TITCALL StaticDisassembleEx(ULONG_PTR DisassmStart, LPVOID DisassmAddress);
__declspec(dllexport) void* TITCALL StaticDisassemble(LPVOID DisassmAddress);
__declspec(dllexport) void* TITCALL DisassembleEx(HANDLE hProcess, LPVOID DisassmAddress, bool ReturnInstructionType);
__declspec(dllexport) void* TITCALL Disassemble(LPVOID DisassmAddress);
__declspec(dllexport) long TITCALL StaticLengthDisassemble(LPVOID DisassmAddress);
__declspec(dllexport) long TITCALL LengthDisassembleEx(HANDLE hProcess, LPVOID DisassmAddress);
__declspec(dllexport) long TITCALL LengthDisassemble(LPVOID DisassmAddress);
__declspec(dllexport) void* TITCALL InitDebug(char* szFileName, char* szCommandLine, char* szCurrentFolder);
__declspec(dllexport) void* TITCALL InitDebugW(const wchar_t* szFileName, const wchar_t* szCommandLine, const wchar_t* szCurrentFolder);
__declspec(dllexport) void* TITCALL InitNativeDebug(char* szFileName, char* szCommandLine, char* szCurrentFolder);
__declspec(dllexport) void* TITCALL InitNativeDebugW(const wchar_t* szFileName, const wchar_t* szCommandLine, const wchar_t* szCurrentFolder);
__declspec(dllexport) void* TITCALL InitDebugEx(const char* szFileName, const char* szCommandLine, const char* szCurrentFolder, LPVOID EntryCallBack);
__declspec(dllexport) void* TITCALL InitDebugExW(const wchar_t* szFileName, const wchar_t* szCommandLine, const wchar_t* szCurrentFolder, LPVOID EntryCallBack);
__declspec(dllexport) void* TITCALL InitDLLDebug(const char* szFileName, bool ReserveModuleBase, const char* szCommandLine, const char* szCurrentFolder, LPVOID EntryCallBack);
__declspec(dllexport) void* TITCALL InitDLLDebugW(const wchar_t* szFileName, bool ReserveModuleBase, const wchar_t* szCommandLine, const wchar_t* szCurrentFolder, LPVOID EntryCallBack);
__declspec(dllexport) bool TITCALL StopDebug();
__declspec(dllexport) void TITCALL SetBPXOptions(long DefaultBreakPointType);
__declspec(dllexport) bool TITCALL IsBPXEnabled(ULONG_PTR bpxAddress);
__declspec(dllexport) bool TITCALL EnableBPX(ULONG_PTR bpxAddress);
__declspec(dllexport) bool TITCALL DisableBPX(ULONG_PTR bpxAddress);
__declspec(dllexport) bool TITCALL SetBPX(ULONG_PTR bpxAddress, DWORD bpxType, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL DeleteBPX(ULONG_PTR bpxAddress);
__declspec(dllexport) bool TITCALL SafeDeleteBPX(ULONG_PTR bpxAddress);
__declspec(dllexport) bool TITCALL SetAPIBreakPoint(const char* szDLLName, const char* szAPIName, DWORD bpxType, DWORD bpxPlace, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL DeleteAPIBreakPoint(const char* szDLLName, const char* szAPIName, DWORD bpxPlace);
__declspec(dllexport) bool TITCALL SafeDeleteAPIBreakPoint(const char* szDLLName, const char* szAPIName, DWORD bpxPlace);
__declspec(dllexport) bool TITCALL SetMemoryBPX(ULONG_PTR MemoryStart, SIZE_T SizeOfMemory, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL SetMemoryBPXEx(ULONG_PTR MemoryStart, SIZE_T SizeOfMemory, DWORD BreakPointType, bool RestoreOnHit, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL RemoveMemoryBPX(ULONG_PTR MemoryStart, SIZE_T SizeOfMemory);
__declspec(dllexport) bool TITCALL GetContextFPUDataEx(HANDLE hActiveThread, void* FPUSaveArea);
__declspec(dllexport) void TITCALL Getx87FPURegisters(x87FPURegister_t x87FPURegisters[8], TITAN_ENGINE_CONTEXT_t* titcontext);
__declspec(dllexport) void TITCALL GetMMXRegisters(uint64_t mmx[8], TITAN_ENGINE_CONTEXT_t* titcontext);
__declspec(dllexport) bool TITCALL GetFullContextDataEx(HANDLE hActiveThread, TITAN_ENGINE_CONTEXT_t* titcontext);
__declspec(dllexport) bool TITCALL SetFullContextDataEx(HANDLE hActiveThread, TITAN_ENGINE_CONTEXT_t* titcontext);
__declspec(dllexport) ULONG_PTR TITCALL GetContextDataEx(HANDLE hActiveThread, DWORD IndexOfRegister);
__declspec(dllexport) ULONG_PTR TITCALL GetContextData(DWORD IndexOfRegister);
__declspec(dllexport) bool TITCALL SetContextFPUDataEx(HANDLE hActiveThread, void* FPUSaveArea);
__declspec(dllexport) bool TITCALL SetContextDataEx(HANDLE hActiveThread, DWORD IndexOfRegister, ULONG_PTR NewRegisterValue);
__declspec(dllexport) bool TITCALL SetContextData(DWORD IndexOfRegister, ULONG_PTR NewRegisterValue);
__declspec(dllexport) bool TITCALL GetAVXContext(HANDLE hActiveThread, TITAN_ENGINE_CONTEXT_t* titcontext);
__declspec(dllexport) bool TITCALL SetAVXContext(HANDLE hActiveThread, TITAN_ENGINE_CONTEXT_t* titcontext);
__declspec(dllexport) void TITCALL ClearExceptionNumber();
__declspec(dllexport) long TITCALL CurrentExceptionNumber();
__declspec(dllexport) bool TITCALL MatchPatternEx(HANDLE hProcess, void* MemoryToCheck, int SizeOfMemoryToCheck, void* PatternToMatch, int SizeOfPatternToMatch, PBYTE WildCard);
__declspec(dllexport) bool TITCALL MatchPattern(void* MemoryToCheck, int SizeOfMemoryToCheck, void* PatternToMatch, int SizeOfPatternToMatch, PBYTE WildCard);
__declspec(dllexport) ULONG_PTR TITCALL FindEx(HANDLE hProcess, LPVOID MemoryStart, DWORD MemorySize, LPVOID SearchPattern, DWORD PatternSize, LPBYTE WildCard);
extern "C" __declspec(dllexport) ULONG_PTR TITCALL Find(LPVOID MemoryStart, DWORD MemorySize, LPVOID SearchPattern, DWORD PatternSize, LPBYTE WildCard);
__declspec(dllexport) bool TITCALL FillEx(HANDLE hProcess, LPVOID MemoryStart, DWORD MemorySize, PBYTE FillByte);
__declspec(dllexport) bool TITCALL Fill(LPVOID MemoryStart, DWORD MemorySize, PBYTE FillByte);
__declspec(dllexport) bool TITCALL PatchEx(HANDLE hProcess, LPVOID MemoryStart, DWORD MemorySize, LPVOID ReplacePattern, DWORD ReplaceSize, bool AppendNOP, bool PrependNOP);
__declspec(dllexport) bool TITCALL Patch(LPVOID MemoryStart, DWORD MemorySize, LPVOID ReplacePattern, DWORD ReplaceSize, bool AppendNOP, bool PrependNOP);
__declspec(dllexport) bool TITCALL ReplaceEx(HANDLE hProcess, LPVOID MemoryStart, DWORD MemorySize, LPVOID SearchPattern, DWORD PatternSize, DWORD NumberOfRepetitions, LPVOID ReplacePattern, DWORD ReplaceSize, PBYTE WildCard);
__declspec(dllexport) bool TITCALL Replace(LPVOID MemoryStart, DWORD MemorySize, LPVOID SearchPattern, DWORD PatternSize, DWORD NumberOfRepetitions, LPVOID ReplacePattern, DWORD ReplaceSize, PBYTE WildCard);
__declspec(dllexport) void* TITCALL GetDebugData();
__declspec(dllexport) void* TITCALL GetTerminationData();
__declspec(dllexport) long TITCALL GetExitCode();
__declspec(dllexport) ULONG_PTR TITCALL GetDebuggedDLLBaseAddress();
__declspec(dllexport) ULONG_PTR TITCALL GetDebuggedFileBaseAddress();
__declspec(dllexport) bool TITCALL GetRemoteString(HANDLE hProcess, LPVOID StringAddress, LPVOID StringStorage, int MaximumStringSize);
__declspec(dllexport) ULONG_PTR TITCALL GetFunctionParameter(HANDLE hProcess, DWORD FunctionType, DWORD ParameterNumber, DWORD ParameterType);
__declspec(dllexport) ULONG_PTR TITCALL GetJumpDestinationEx(HANDLE hProcess, ULONG_PTR InstructionAddress, bool JustJumps);
__declspec(dllexport) ULONG_PTR TITCALL GetJumpDestination(HANDLE hProcess, ULONG_PTR InstructionAddress);
__declspec(dllexport) bool TITCALL IsJumpGoingToExecuteEx(HANDLE hProcess, HANDLE hThread, ULONG_PTR InstructionAddress, ULONG_PTR RegFlags);
__declspec(dllexport) bool TITCALL IsJumpGoingToExecute();
__declspec(dllexport) void TITCALL SetCustomHandler(DWORD ExceptionId, LPVOID CallBack);
__declspec(dllexport) void TITCALL ForceClose();
__declspec(dllexport) void TITCALL StepInto(LPVOID traceCallBack);
__declspec(dllexport) void TITCALL StepOver(LPVOID traceCallBack);
__declspec(dllexport) void TITCALL StepOut(LPVOID StepOut, bool StepFinal);
__declspec(dllexport) void TITCALL SingleStep(DWORD StepCount, LPVOID StepCallBack);
__declspec(dllexport) bool TITCALL GetUnusedHardwareBreakPointRegister(LPDWORD RegisterIndex);
__declspec(dllexport) bool TITCALL SetHardwareBreakPointEx(HANDLE hActiveThread, ULONG_PTR bpxAddress, DWORD IndexOfRegister, DWORD bpxType, DWORD bpxSize, LPVOID bpxCallBack, LPDWORD IndexOfSelectedRegister);
__declspec(dllexport) bool TITCALL SetHardwareBreakPoint(ULONG_PTR bpxAddress, DWORD IndexOfRegister, DWORD bpxType, DWORD bpxSize, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL DeleteHardwareBreakPoint(DWORD IndexOfRegister);
__declspec(dllexport) bool TITCALL RemoveAllBreakPoints(DWORD RemoveOption);
__declspec(dllexport) PROCESS_INFORMATION* TITCALL TitanGetProcessInformation();
__declspec(dllexport) STARTUPINFOW* TITCALL TitanGetStartupInformation();
__declspec(dllexport) void TITCALL DebugLoop();
__declspec(dllexport) void TITCALL SetDebugLoopTimeOut(DWORD TimeOut);
__declspec(dllexport) void TITCALL SetNextDbgContinueStatus(DWORD SetDbgCode);
__declspec(dllexport) bool TITCALL AttachDebugger(DWORD ProcessId, bool KillOnExit, LPVOID DebugInfo, LPVOID CallBack);
__declspec(dllexport) bool TITCALL DetachDebugger(DWORD ProcessId);
__declspec(dllexport) bool TITCALL DetachDebuggerEx(DWORD ProcessId);
__declspec(dllexport) void TITCALL DebugLoopEx(DWORD TimeOut);
__declspec(dllexport) void TITCALL AutoDebugEx(const char* szFileName, bool ReserveModuleBase, const char* szCommandLine, const char* szCurrentFolder, DWORD TimeOut, LPVOID EntryCallBack);
__declspec(dllexport) void TITCALL AutoDebugExW(const wchar_t* szFileName, bool ReserveModuleBase, const wchar_t* szCommandLine, const wchar_t* szCurrentFolder, DWORD TimeOut, LPVOID EntryCallBack);
__declspec(dllexport) bool TITCALL IsFileBeingDebugged();
__declspec(dllexport) void TITCALL SetErrorModel(bool DisplayErrorMessages);
// TitanEngine.FindOEP.functions:
__declspec(dllexport) void TITCALL FindOEPInit();
__declspec(dllexport) bool TITCALL FindOEPGenerically(const char* szFileName, LPVOID TraceInitCallBack, LPVOID CallBack);
__declspec(dllexport) bool TITCALL FindOEPGenericallyW(const wchar_t* szFileName, LPVOID TraceInitCallBack, LPVOID CallBack);
// TitanEngine.Importer.functions:
__declspec(dllexport) void TITCALL ImporterAddNewDll(const char* szDLLName, ULONG_PTR FirstThunk);
__declspec(dllexport) void TITCALL ImporterAddNewAPI(const char* szAPIName, ULONG_PTR ThunkValue);
__declspec(dllexport) void TITCALL ImporterAddNewOrdinalAPI(ULONG_PTR OrdinalNumber, ULONG_PTR ThunkValue);
__declspec(dllexport) long TITCALL ImporterGetAddedDllCount();
__declspec(dllexport) long TITCALL ImporterGetAddedAPICount();
__declspec(dllexport) bool TITCALL ImporterExportIAT(ULONG_PTR StorePlace, ULONG_PTR FileMapVA, HANDLE hFileMap);
__declspec(dllexport) long TITCALL ImporterEstimatedSize();
__declspec(dllexport) bool TITCALL ImporterExportIATEx(const char* szDumpFileName, const char* szExportFileName, const char* szSectionName);
__declspec(dllexport) bool TITCALL ImporterExportIATExW(const wchar_t* szDumpFileName, const wchar_t* szExportFileName, const wchar_t* szSectionName = L".RL!TEv2");
__declspec(dllexport) ULONG_PTR TITCALL ImporterFindAPIWriteLocation(const char* szAPIName);
__declspec(dllexport) ULONG_PTR TITCALL ImporterFindOrdinalAPIWriteLocation(ULONG_PTR OrdinalNumber);
__declspec(dllexport) ULONG_PTR TITCALL ImporterFindAPIByWriteLocation(ULONG_PTR APIWriteLocation);
__declspec(dllexport) ULONG_PTR TITCALL ImporterFindDLLByWriteLocation(ULONG_PTR APIWriteLocation);
__declspec(dllexport) void* TITCALL ImporterGetDLLName(ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetDLLNameW(ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetAPIName(ULONG_PTR APIAddress);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetAPIOrdinalNumber(ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetAPINameEx(ULONG_PTR APIAddress, ULONG_PTR DLLBasesList);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetRemoteAPIAddress(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetRemoteAPIAddressEx(const char* szDLLName, const char* szAPIName);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetLocalAPIAddress(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetDLLNameFromDebugee(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetDLLNameFromDebugeeW(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetAPINameFromDebugee(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetAPIOrdinalNumberFromDebugee(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) long TITCALL ImporterGetDLLIndexEx(ULONG_PTR APIAddress, ULONG_PTR DLLBasesList);
__declspec(dllexport) long TITCALL ImporterGetDLLIndex(HANDLE hProcess, ULONG_PTR APIAddress, ULONG_PTR DLLBasesList);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetRemoteDLLBase(HANDLE hProcess, HMODULE LocalModuleBase);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetRemoteDLLBaseEx(HANDLE hProcess, const char* szModuleName);
__declspec(dllexport) void* TITCALL ImporterGetRemoteDLLBaseExW(HANDLE hProcess, const wchar_t* szModuleName);
__declspec(dllexport) bool TITCALL ImporterIsForwardedAPI(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetForwardedAPIName(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetForwardedDLLName(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) long TITCALL ImporterGetForwardedDLLIndex(HANDLE hProcess, ULONG_PTR APIAddress, ULONG_PTR DLLBasesList);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetForwardedAPIOrdinalNumber(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetNearestAPIAddress(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetNearestAPIName(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) bool TITCALL ImporterCopyOriginalIAT(const char* szOriginalFile, const char* szDumpFile);
__declspec(dllexport) bool TITCALL ImporterCopyOriginalIATW(const wchar_t* szOriginalFile, const wchar_t* szDumpFile);
__declspec(dllexport) bool TITCALL ImporterLoadImportTable(const char* szFileName);
__declspec(dllexport) bool TITCALL ImporterLoadImportTableW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL ImporterMoveOriginalIAT(const char* szOriginalFile, const char* szDumpFile, const char* szSectionName);
__declspec(dllexport) bool TITCALL ImporterMoveOriginalIATW(const wchar_t* szOriginalFile, const wchar_t* szDumpFile, const char* szSectionName);
__declspec(dllexport) void TITCALL ImporterAutoSearchIAT(DWORD ProcessId, const char* szFileName, ULONG_PTR SearchStart, LPVOID pIATStart, LPVOID pIATSize);
__declspec(dllexport) void TITCALL ImporterAutoSearchIATW(DWORD ProcessIds, const wchar_t* szFileName, ULONG_PTR SearchStart, LPVOID pIATStart, LPVOID pIATSize);
__declspec(dllexport) void TITCALL ImporterAutoSearchIATEx(DWORD ProcessId, ULONG_PTR ImageBase, ULONG_PTR SearchStart, LPVOID pIATStart, LPVOID pIATSize);
__declspec(dllexport) void TITCALL ImporterEnumAddedData(LPVOID EnumCallBack);
__declspec(dllexport) long TITCALL ImporterAutoFixIATEx(DWORD ProcessId, const char* szDumpedFile, const char* szSectionName, bool DumpRunningProcess, bool RealignFile, ULONG_PTR EntryPointAddress, ULONG_PTR ImageBase, ULONG_PTR SearchStart, bool TryAutoFix, bool FixEliminations, LPVOID UnknownPointerFixCallback);
__declspec(dllexport) long TITCALL ImporterAutoFixIATExW(DWORD ProcessId, const wchar_t* szDumpedFile, const wchar_t* szSectionName, bool DumpRunningProcess, bool RealignFile, ULONG_PTR EntryPointAddress, ULONG_PTR ImageBase, ULONG_PTR SearchStart,  bool TryAutoFix, bool FixEliminations, LPVOID UnknownPointerFixCallback);
__declspec(dllexport) long TITCALL ImporterAutoFixIAT(DWORD ProcessId, const char* szDumpedFile, ULONG_PTR SearchStart);
__declspec(dllexport) long TITCALL ImporterAutoFixIATW(DWORD ProcessId, const wchar_t* szDumpedFile, ULONG_PTR SearchStart);
__declspec(dllexport) bool TITCALL ImporterDeleteAPI(DWORD_PTR apiAddr);
// Global.Engine.Hook.functions:
__declspec(dllexport) bool TITCALL HooksSafeTransitionEx(LPVOID HookAddressArray, int NumberOfHooks, bool TransitionStart);
__declspec(dllexport) bool TITCALL HooksSafeTransition(LPVOID HookAddress, bool TransitionStart);
__declspec(dllexport) bool TITCALL HooksIsAddressRedirected(LPVOID HookAddress);
__declspec(dllexport) void* TITCALL HooksGetTrampolineAddress(LPVOID HookAddress);
__declspec(dllexport) void* TITCALL HooksGetHookEntryDetails(LPVOID HookAddress);
__declspec(dllexport) bool TITCALL HooksInsertNewRedirection(LPVOID HookAddress, LPVOID RedirectTo, int HookType);
__declspec(dllexport) bool TITCALL HooksInsertNewIATRedirectionEx(ULONG_PTR FileMapVA, ULONG_PTR LoadedModuleBase, const char* szHookFunction, LPVOID RedirectTo);
__declspec(dllexport) bool TITCALL HooksInsertNewIATRedirection(const char* szModuleName, const char* szHookFunction, LPVOID RedirectTo);
__declspec(dllexport) bool TITCALL HooksRemoveRedirection(LPVOID HookAddress, bool RemoveAll);
__declspec(dllexport) bool TITCALL HooksRemoveRedirectionsForModule(HMODULE ModuleBase);
__declspec(dllexport) bool TITCALL HooksRemoveIATRedirection(const char* szModuleName, const char* szHookFunction, bool RemoveAll);
__declspec(dllexport) bool TITCALL HooksDisableRedirection(LPVOID HookAddress, bool DisableAll);
__declspec(dllexport) bool TITCALL HooksDisableRedirectionsForModule(HMODULE ModuleBase);
__declspec(dllexport) bool TITCALL HooksDisableIATRedirection(const char* szModuleName, const char* szHookFunction, bool DisableAll);
__declspec(dllexport) bool TITCALL HooksEnableRedirection(LPVOID HookAddress, bool EnableAll);
__declspec(dllexport) bool TITCALL HooksEnableRedirectionsForModule(HMODULE ModuleBase);
__declspec(dllexport) bool TITCALL HooksEnableIATRedirection(const char* szModuleName, const char* szHookFunction, bool EnableAll);
__declspec(dllexport) void TITCALL HooksScanModuleMemory(HMODULE ModuleBase, LPVOID CallBack);
__declspec(dllexport) void TITCALL HooksScanEntireProcessMemory(LPVOID CallBack);
__declspec(dllexport) void TITCALL HooksScanEntireProcessMemoryEx();
// TitanEngine.Tracer.functions:
__declspec(dllexport) void TITCALL TracerInit();
__declspec(dllexport) ULONG_PTR TITCALL TracerLevel1(HANDLE hProcess, ULONG_PTR AddressToTrace);
__declspec(dllexport) ULONG_PTR TITCALL HashTracerLevel1(HANDLE hProcess, ULONG_PTR AddressToTrace, DWORD InputNumberOfInstructions);
__declspec(dllexport) long TITCALL TracerDetectRedirection(HANDLE hProcess, ULONG_PTR AddressToTrace);
__declspec(dllexport) ULONG_PTR TITCALL TracerFixKnownRedirection(HANDLE hProcess, ULONG_PTR AddressToTrace, DWORD RedirectionId);
__declspec(dllexport) ULONG_PTR TITCALL TracerFixRedirectionViaModule(HMODULE hModuleHandle, HANDLE hProcess, ULONG_PTR AddressToTrace, DWORD IdParameter);
__declspec(dllexport) long TITCALL TracerFixRedirectionViaImpRecPlugin(HANDLE hProcess, const char* szPluginName, ULONG_PTR AddressToTrace);
// TitanEngine.Exporter.functions:
__declspec(dllexport) void TITCALL ExporterCleanup();
__declspec(dllexport) void TITCALL ExporterSetImageBase(ULONG_PTR ImageBase);
__declspec(dllexport) void TITCALL ExporterInit(DWORD MemorySize, ULONG_PTR ImageBase, DWORD ExportOrdinalBase, const char* szExportModuleName);
__declspec(dllexport) bool TITCALL ExporterAddNewExport(const char* szExportName, DWORD ExportRelativeAddress);
__declspec(dllexport) bool TITCALL ExporterAddNewOrdinalExport(DWORD OrdinalNumber, DWORD ExportRelativeAddress);
__declspec(dllexport) long TITCALL ExporterGetAddedExportCount();
__declspec(dllexport) long TITCALL ExporterEstimatedSize();
__declspec(dllexport) bool TITCALL ExporterBuildExportTable(ULONG_PTR StorePlace, ULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL ExporterBuildExportTableEx(const char* szExportFileName, const char* szSectionName);
__declspec(dllexport) bool TITCALL ExporterBuildExportTableExW(const wchar_t* szExportFileName, const char* szSectionName);
__declspec(dllexport) bool TITCALL ExporterLoadExportTable(const char* szFileName);
__declspec(dllexport) bool TITCALL ExporterLoadExportTableW(const wchar_t* szFileName);
// TitanEngine.Librarian.functions:
__declspec(dllexport) bool TITCALL LibrarianSetBreakPoint(const char* szLibraryName, DWORD bpxType, bool SingleShoot, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL LibrarianRemoveBreakPoint(const char* szLibraryName, DWORD bpxType);
__declspec(dllexport) void* TITCALL LibrarianGetLibraryInfo(const char* szLibraryName);
__declspec(dllexport) void* TITCALL LibrarianGetLibraryInfoW(const wchar_t* szLibraryName);
__declspec(dllexport) void* TITCALL LibrarianGetLibraryInfoEx(void* BaseOfDll);
__declspec(dllexport) void* TITCALL LibrarianGetLibraryInfoExW(void* BaseOfDll);
__declspec(dllexport) void TITCALL LibrarianEnumLibraryInfo(void* EnumCallBack);
__declspec(dllexport) void TITCALL LibrarianEnumLibraryInfoW(void* EnumCallBack);
// TitanEngine.Process.functions:
__declspec(dllexport) long TITCALL GetActiveProcessId(const char* szImageName);
__declspec(dllexport) long TITCALL GetActiveProcessIdW(const wchar_t* szImageName);
__declspec(dllexport) void TITCALL EnumProcessesWithLibrary(const char* szLibraryName, void* EnumFunction);
__declspec(dllexport) HANDLE TITCALL TitanOpenProcess(DWORD dwDesiredAccess, bool bInheritHandle, DWORD dwProcessId);
__declspec(dllexport) HANDLE TITCALL TitanOpenThread(DWORD dwDesiredAccess, bool bInheritHandle, DWORD dwThreadId);
// TitanEngine.TLSFixer.functions:
__declspec(dllexport) bool TITCALL TLSBreakOnCallBack(LPVOID ArrayOfCallBacks, DWORD NumberOfCallBacks, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL TLSGrabCallBackData(const char* szFileName, LPVOID ArrayOfCallBacks, LPDWORD NumberOfCallBacks);
__declspec(dllexport) bool TITCALL TLSGrabCallBackDataW(const wchar_t* szFileName, LPVOID ArrayOfCallBacks, LPDWORD NumberOfCallBacks);
__declspec(dllexport) bool TITCALL TLSBreakOnCallBackEx(const char* szFileName, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL TLSBreakOnCallBackExW(const wchar_t* szFileName, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL TLSRemoveCallback(const char* szFileName);
__declspec(dllexport) bool TITCALL TLSRemoveCallbackW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL TLSRemoveTable(const char* szFileName);
__declspec(dllexport) bool TITCALL TLSRemoveTableW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL TLSBackupData(const char* szFileName);
__declspec(dllexport) bool TITCALL TLSBackupDataW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL TLSRestoreData();
__declspec(dllexport) bool TITCALL TLSBuildNewTable(ULONG_PTR FileMapVA, ULONG_PTR StorePlace, ULONG_PTR StorePlaceRVA, LPVOID ArrayOfCallBacks, DWORD NumberOfCallBacks);
__declspec(dllexport) bool TITCALL TLSBuildNewTableEx(const char* szFileName, const char* szSectionName, LPVOID ArrayOfCallBacks, DWORD NumberOfCallBacks);
__declspec(dllexport) bool TITCALL TLSBuildNewTableExW(const wchar_t* szFileName, const char* szSectionName, LPVOID ArrayOfCallBacks, DWORD NumberOfCallBacks);
// TitanEngine.TranslateName.functions:
__declspec(dllexport) void* TITCALL TranslateNativeName(const char* szNativeName);
__declspec(dllexport) void* TITCALL TranslateNativeNameW(const wchar_t* szNativeName);
// TitanEngine.Handler.functions:
__declspec(dllexport) long TITCALL HandlerGetActiveHandleCount(DWORD ProcessId);
__declspec(dllexport) bool TITCALL HandlerIsHandleOpen(DWORD ProcessId, HANDLE hHandle);
__declspec(dllexport) void* TITCALL HandlerGetHandleName(HANDLE hProcess, DWORD ProcessId, HANDLE hHandle, bool TranslateName);
__declspec(dllexport) void* TITCALL HandlerGetHandleNameW(HANDLE hProcess, DWORD ProcessId, HANDLE hHandle, bool TranslateName);
__declspec(dllexport) long TITCALL HandlerEnumerateOpenHandles(DWORD ProcessId, LPVOID HandleBuffer, DWORD MaxHandleCount);
__declspec(dllexport) ULONG_PTR TITCALL HandlerGetHandleDetails(HANDLE hProcess, DWORD ProcessId, HANDLE hHandle, DWORD InformationReturn);
__declspec(dllexport) bool TITCALL HandlerCloseRemoteHandle(HANDLE hProcess, HANDLE hHandle);
__declspec(dllexport) long TITCALL HandlerEnumerateLockHandles(char* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated, LPVOID HandleDataBuffer, DWORD MaxHandleCount);
__declspec(dllexport) long TITCALL HandlerEnumerateLockHandlesW(const wchar_t* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated, LPVOID HandleDataBuffer, DWORD MaxHandleCount);
__declspec(dllexport) bool TITCALL HandlerCloseAllLockHandles(const char* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated);
__declspec(dllexport) bool TITCALL HandlerCloseAllLockHandlesW(const wchar_t* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated);
__declspec(dllexport) bool TITCALL HandlerIsFileLocked(const char* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated);
__declspec(dllexport) bool TITCALL HandlerIsFileLockedW(const wchar_t* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated);
// TitanEngine.Handler[Mutex].functions:
__declspec(dllexport) long TITCALL HandlerEnumerateOpenMutexes(HANDLE hProcess, DWORD ProcessId, LPVOID HandleBuffer, DWORD MaxHandleCount);
__declspec(dllexport) ULONG_PTR TITCALL HandlerGetOpenMutexHandle(HANDLE hProcess, DWORD ProcessId, const char* szMutexString);
__declspec(dllexport) ULONG_PTR TITCALL HandlerGetOpenMutexHandleW(HANDLE hProcess, DWORD ProcessId, const wchar_t* szMutexString);
__declspec(dllexport) long TITCALL HandlerGetProcessIdWhichCreatedMutex(const char* szMutexString);
__declspec(dllexport) long TITCALL HandlerGetProcessIdWhichCreatedMutexW(const wchar_t* szMutexString);
// TitanEngine.Injector.functions:
__declspec(dllexport) bool TITCALL RemoteLoadLibrary(HANDLE hProcess, const char* szLibraryFile, bool WaitForThreadExit);
__declspec(dllexport) bool TITCALL RemoteLoadLibraryW(HANDLE hProcess, const wchar_t* szLibraryFile, bool WaitForThreadExit);
__declspec(dllexport) bool TITCALL RemoteFreeLibrary(HANDLE hProcess, HMODULE hModule, const char* szLibraryFile, bool WaitForThreadExit);
__declspec(dllexport) bool TITCALL RemoteFreeLibraryW(HANDLE hProcess, HMODULE hModule, const wchar_t* szLibraryFile, bool WaitForThreadExit);
__declspec(dllexport) bool TITCALL RemoteExitProcess(HANDLE hProcess, DWORD ExitCode);
// TitanEngine.StaticUnpacker.functions:
__declspec(dllexport) bool TITCALL StaticFileLoad(const char* szFileName, DWORD DesiredAccess, bool SimulateLoad, LPHANDLE FileHandle, LPDWORD LoadedSize, LPHANDLE FileMap, PULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL StaticFileLoadW(const wchar_t* szFileName, DWORD DesiredAccess, bool SimulateLoad, LPHANDLE FileHandle, LPDWORD LoadedSize, LPHANDLE FileMap, PULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL StaticFileUnload(const char* szFileName, bool CommitChanges, HANDLE FileHandle, DWORD LoadedSize, HANDLE FileMap, ULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL StaticFileUnloadW(const wchar_t* szFileName, bool CommitChanges, HANDLE FileHandle, DWORD LoadedSize, HANDLE FileMap, ULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL StaticFileOpen(const char* szFileName, DWORD DesiredAccess, LPHANDLE FileHandle, LPDWORD FileSizeLow, LPDWORD FileSizeHigh);
__declspec(dllexport) bool TITCALL StaticFileOpenW(const wchar_t* szFileName, DWORD DesiredAccess, LPHANDLE FileHandle, LPDWORD FileSizeLow, LPDWORD FileSizeHigh);
__declspec(dllexport) bool TITCALL StaticFileGetContent(HANDLE FileHandle, DWORD FilePositionLow, LPDWORD FilePositionHigh, void* Buffer, DWORD Size);
__declspec(dllexport) void TITCALL StaticFileClose(HANDLE FileHandle);
__declspec(dllexport) void TITCALL StaticMemoryDecrypt(LPVOID MemoryStart, DWORD MemorySize, DWORD DecryptionType, DWORD DecryptionKeySize, ULONG_PTR DecryptionKey);
__declspec(dllexport) void TITCALL StaticMemoryDecryptEx(LPVOID MemoryStart, DWORD MemorySize, DWORD DecryptionKeySize, void* DecryptionCallBack);
__declspec(dllexport) void TITCALL StaticMemoryDecryptSpecial(LPVOID MemoryStart, DWORD MemorySize, DWORD DecryptionKeySize, DWORD SpecDecryptionType, void* DecryptionCallBack);
__declspec(dllexport) void TITCALL StaticSectionDecrypt(ULONG_PTR FileMapVA, DWORD SectionNumber, bool SimulateLoad, DWORD DecryptionType, DWORD DecryptionKeySize, ULONG_PTR DecryptionKey);
__declspec(dllexport) bool TITCALL StaticMemoryDecompress(void* Source, DWORD SourceSize, void* Destination, DWORD DestinationSize, int Algorithm);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopy(HANDLE hFile, ULONG_PTR FileMapVA, ULONG_PTR VitualAddressToCopy, DWORD Size, bool AddressIsRVA, const char* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopyW(HANDLE hFile, ULONG_PTR FileMapVA, ULONG_PTR VitualAddressToCopy, DWORD Size, bool AddressIsRVA, const wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopyEx(HANDLE hFile, DWORD RawAddressToCopy, DWORD Size, const char* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopyExW(HANDLE hFile, DWORD RawAddressToCopy, DWORD Size, const wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopyEx64(HANDLE hFile, DWORD64 RawAddressToCopy, DWORD64 Size, const char* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopyEx64W(HANDLE hFile, DWORD64 RawAddressToCopy, DWORD64 Size, const wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticHashMemory(void* MemoryToHash, DWORD SizeOfMemory, void* HashDigest, bool OutputString, int Algorithm);
__declspec(dllexport) bool TITCALL StaticHashFileW(const wchar_t* szFileName, char* HashDigest, bool OutputString, int Algorithm);
__declspec(dllexport) bool TITCALL StaticHashFile(const char* szFileName, char* HashDigest, bool OutputString, int Algorithm);
// TitanEngine.Engine.functions:
__declspec(dllexport) void TITCALL EngineUnpackerInitialize(const char* szFileName, const char* szUnpackedFileName, bool DoLogData, bool DoRealignFile, bool DoMoveOverlay, void* EntryCallBack);
__declspec(dllexport) void TITCALL EngineUnpackerInitializeW(const wchar_t* szFileName, const wchar_t* szUnpackedFileName, bool DoLogData, bool DoRealignFile, bool DoMoveOverlay, void* EntryCallBack);
__declspec(dllexport) bool TITCALL EngineUnpackerSetBreakCondition(void* SearchStart, DWORD SearchSize, void* SearchPattern, DWORD PatternSize, DWORD PatternDelta, ULONG_PTR BreakType, bool SingleBreak, DWORD Parameter1, DWORD Parameter2);
__declspec(dllexport) void TITCALL EngineUnpackerSetEntryPointAddress(ULONG_PTR UnpackedEntryPointAddress);
__declspec(dllexport) void TITCALL EngineUnpackerFinalizeUnpacking();
// TitanEngine.Engine.functions:
__declspec(dllexport) void TITCALL SetEngineVariable(DWORD VariableId, bool VariableSet);
__declspec(dllexport) bool TITCALL EngineCreateMissingDependencies(const char* szFileName, const char* szOutputFolder, bool LogCreatedFiles);
__declspec(dllexport) bool TITCALL EngineCreateMissingDependenciesW(const wchar_t* szFileName, const wchar_t* szOutputFolder, bool LogCreatedFiles);
__declspec(dllexport) bool TITCALL EngineFakeMissingDependencies(HANDLE hProcess);
__declspec(dllexport) bool TITCALL EngineDeleteCreatedDependencies();
__declspec(dllexport) bool TITCALL EngineCreateUnpackerWindow(const char* WindowUnpackerTitle, const char* WindowUnpackerLongTitle, const char* WindowUnpackerName, const char* WindowUnpackerAuthor, void* StartUnpackingCallBack);
__declspec(dllexport) void TITCALL EngineAddUnpackerWindowLogMessage(const char* szLogMessage);
__declspec(dllexport) bool TITCALL EngineCheckStructAlignment(DWORD StructureType, ULONG_PTR StructureSize);
// Global.Engine.Extension.Functions:
__declspec(dllexport) bool TITCALL ExtensionManagerIsPluginLoaded(const char* szPluginName);
__declspec(dllexport) bool TITCALL ExtensionManagerIsPluginEnabled(const char* szPluginName);
__declspec(dllexport) bool TITCALL ExtensionManagerDisableAllPlugins();
__declspec(dllexport) bool TITCALL ExtensionManagerDisablePlugin(const char* szPluginName);
__declspec(dllexport) bool TITCALL ExtensionManagerEnableAllPlugins();
__declspec(dllexport) bool TITCALL ExtensionManagerEnablePlugin(const char* szPluginName);
__declspec(dllexport) bool TITCALL ExtensionManagerUnloadAllPlugins();
__declspec(dllexport) bool TITCALL ExtensionManagerUnloadPlugin(const char* szPluginName);
__declspec(dllexport) void* TITCALL ExtensionManagerGetPluginInfo(const char* szPluginName);

#ifdef __cplusplus
}
#endif

#pragma pack(pop)

#endif /*TITANENGINE*/



================================================
File: ClawSearch/pluginsdk/XEDParse/XEDParse.h
================================================
#ifndef _XEDPARSE_H
#define _XEDPARSE_H

#include <windows.h>

//XEDParse defines
#ifdef XEDPARSE_BUILD
#define XEDPARSE_EXPORT __declspec(dllexport)
#else
#define XEDPARSE_EXPORT __declspec(dllimport)
#endif //XEDPARSE_BUILD

#define XEDPARSE_CALL //calling convention

#define XEDPARSE_MAXBUFSIZE 256
#define XEDPARSE_MAXASMSIZE 16

//typedefs
typedef bool (XEDPARSE_CALL* CBXEDPARSE_UNKNOWN)(const char* text, ULONGLONG* value);

//XEDParse enums
enum XEDPARSE_STATUS
{
    XEDPARSE_ERROR = 0,
    XEDPARSE_OK = 1
};

//XEDParse structs
#pragma pack(push,8)
struct XEDPARSE
{
    bool x64; // use 64-bit instructions
    ULONGLONG cip; //instruction pointer (for relative addressing)
    unsigned int dest_size; //destination size (returned by XEDParse)
    CBXEDPARSE_UNKNOWN cbUnknown; //unknown operand callback
    unsigned char dest[XEDPARSE_MAXASMSIZE]; //destination buffer
    char instr[XEDPARSE_MAXBUFSIZE]; //instruction text
    char error[XEDPARSE_MAXBUFSIZE]; //error text (in case of an error)
};
#pragma pack(pop)

#ifdef __cplusplus
extern "C"
{
#endif

XEDPARSE_EXPORT XEDPARSE_STATUS XEDPARSE_CALL XEDParseAssemble(XEDPARSE* XEDParse);

#ifdef __cplusplus
}
#endif

#endif // _XEDPARSE_H



================================================
File: ClawSearch/pluginsdk/dbghelp/dbghelp.h
================================================
#ifndef _DBGHELP_
#define _DBGHELP_


// As a general principal always call the 64 bit version
// of every API, if a choice exists.  The 64 bit version
// works great on 32 bit platforms, and is forward
// compatible to 64 bit platforms.

#ifdef _WIN64
#ifndef _IMAGEHLP64
#define _IMAGEHLP64
#endif
#endif

#pragma pack(push,8)

// For those without specstrings.h
// Since there are different versions of this header, I need to
// individually test each item and define it if it is not around.

#ifndef __in
#define __in
#endif
#ifndef __out
#define __out
#endif
#ifndef __inout
#define __inout
#endif
#ifndef __in_opt
#define __in_opt
#endif
#ifndef __out_opt
#define __out_opt
#endif
#ifndef __inout_opt
#define __inout_opt
#endif
#ifndef __in_ecount
#define __in_ecount(x)
#endif
#ifndef __out_ecount
#define __out_ecount(x)
#endif
#ifndef __inout_ecount
#define __inout_ecount(x)
#endif
#ifndef __in_bcount
#define __in_bcount(x)
#endif
#ifndef __out_bcount
#define __out_bcount(x)
#endif
#ifndef __inout_bcount
#define __inout_bcount(x)
#endif
#ifndef __out_xcount
#define __out_xcount(x)
#endif
#ifndef __deref_opt_out
#define __deref_opt_out
#endif
#ifndef __deref_out
#define __deref_out
#endif
#ifndef __out_ecount_opt
#define __out_ecount_opt(x)
#endif
#ifndef __in_bcount_opt
#define __in_bcount_opt(x)
#endif
#ifndef __out_bcount_opt
#define __out_bcount_opt(x)
#endif
#ifndef __deref_out_opt
#define __deref_out_opt
#endif


#ifdef __cplusplus
extern "C" {
#endif

#ifdef _IMAGEHLP_SOURCE_
#define IMAGEAPI __stdcall
#define DBHLP_DEPRECIATED
#else
#define IMAGEAPI DECLSPEC_IMPORT __stdcall
#if (_MSC_VER >= 1300) && !defined(MIDL_PASS)
#define DBHLP_DEPRECIATED   __declspec(deprecated)
#else
#define DBHLP_DEPRECIATED
#endif
#endif

#define DBHLPAPI IMAGEAPI

#define IMAGE_SEPARATION (64*1024)

// Observant readers may notice that 2 new fields,
// 'fReadOnly' and 'Version' have been added to
// the LOADED_IMAGE structure after 'fDOSImage'.
// This does not change the size of the structure
// from previous headers.  That is because while
// 'fDOSImage' is a byte, it is padded by the
// compiler to 4 bytes.  So the 2 new fields are
// slipped into the extra space.

typedef struct _LOADED_IMAGE
{
    PSTR                  ModuleName;
    HANDLE                hFile;
    PUCHAR                MappedAddress;
#ifdef _IMAGEHLP64
    PIMAGE_NT_HEADERS64   FileHeader;
#else
    PIMAGE_NT_HEADERS32   FileHeader;
#endif
    PIMAGE_SECTION_HEADER LastRvaSection;
    ULONG                 NumberOfSections;
    PIMAGE_SECTION_HEADER Sections;
    ULONG                 Characteristics;
    BOOLEAN               fSystemImage;
    BOOLEAN               fDOSImage;
    BOOLEAN               fReadOnly;
    UCHAR                 Version;
    LIST_ENTRY            Links;
    ULONG                 SizeOfImage;
} LOADED_IMAGE, *PLOADED_IMAGE;

#define MAX_SYM_NAME            2000


// Error codes set by dbghelp functions.  Call GetLastError
// to see them.
// Dbghelp also sets error codes found in winerror.h

#define ERROR_IMAGE_NOT_STRIPPED    0x8800  // the image is not stripped.  No dbg file available.
#define ERROR_NO_DBG_POINTER        0x8801  // image is stripped but there is no pointer to a dbg file
#define ERROR_NO_PDB_POINTER        0x8802  // image does not point to a pdb file

typedef BOOL
(CALLBACK* PFIND_DEBUG_FILE_CALLBACK)(
    __in HANDLE FileHandle,
    __in PCSTR FileName,
    __in PVOID CallerData
);

HANDLE
IMAGEAPI
SymFindDebugInfoFile(
    __in HANDLE hProcess,
    __in PCSTR FileName,
    __out_ecount(MAX_PATH + 1) PSTR DebugFilePath,
    __in_opt PFIND_DEBUG_FILE_CALLBACK Callback,
    __in_opt PVOID CallerData
);

typedef BOOL
(CALLBACK* PFIND_DEBUG_FILE_CALLBACKW)(
    __in HANDLE FileHandle,
    __in PCWSTR FileName,
    __in PVOID  CallerData
);

HANDLE
IMAGEAPI
SymFindDebugInfoFileW(
    __in HANDLE hProcess,
    __in PCWSTR FileName,
    __out_ecount(MAX_PATH + 1) PWSTR DebugFilePath,
    __in_opt PFIND_DEBUG_FILE_CALLBACKW Callback,
    __in_opt PVOID CallerData
);

HANDLE
IMAGEAPI
FindDebugInfoFile(
    __in PCSTR FileName,
    __in PCSTR SymbolPath,
    __out_ecount(MAX_PATH + 1) PSTR DebugFilePath
);

HANDLE
IMAGEAPI
FindDebugInfoFileEx(
    __in PCSTR FileName,
    __in PCSTR SymbolPath,
    __out_ecount(MAX_PATH + 1) PSTR  DebugFilePath,
    __in_opt PFIND_DEBUG_FILE_CALLBACK Callback,
    __in_opt PVOID CallerData
);

HANDLE
IMAGEAPI
FindDebugInfoFileExW(
    __in PCWSTR FileName,
    __in PCWSTR SymbolPath,
    __out_ecount(MAX_PATH + 1) PWSTR DebugFilePath,
    __in_opt PFIND_DEBUG_FILE_CALLBACKW Callback,
    __in_opt PVOID CallerData
);

typedef BOOL
(CALLBACK* PFINDFILEINPATHCALLBACK)(
    __in PCSTR filename,
    __in PVOID context
);

BOOL
IMAGEAPI
SymFindFileInPath(
    __in HANDLE hprocess,
    __in_opt PCSTR SearchPath,
    __in PCSTR FileName,
    __in_opt PVOID id,
    __in DWORD two,
    __in DWORD three,
    __in DWORD flags,
    __out_ecount(MAX_PATH + 1) PSTR FoundFile,
    __in_opt PFINDFILEINPATHCALLBACK callback,
    __in_opt PVOID context
);

typedef BOOL
(CALLBACK* PFINDFILEINPATHCALLBACKW)(
    __in PCWSTR filename,
    __in PVOID context
);

BOOL
IMAGEAPI
SymFindFileInPathW(
    __in HANDLE hprocess,
    __in_opt PCWSTR SearchPath,
    __in PCWSTR FileName,
    __in_opt PVOID id,
    __in DWORD two,
    __in DWORD three,
    __in DWORD flags,
    __out_ecount(MAX_PATH + 1) PWSTR FoundFile,
    __in_opt PFINDFILEINPATHCALLBACKW callback,
    __in_opt PVOID context
);

typedef BOOL
(CALLBACK* PFIND_EXE_FILE_CALLBACK)(
    __in HANDLE FileHandle,
    __in PCSTR FileName,
    __in_opt PVOID CallerData
);

HANDLE
IMAGEAPI
SymFindExecutableImage(
    __in HANDLE hProcess,
    __in PCSTR FileName,
    __out_ecount(MAX_PATH + 1) PSTR ImageFilePath,
    __in PFIND_EXE_FILE_CALLBACK Callback,
    __in PVOID CallerData
);

typedef BOOL
(CALLBACK* PFIND_EXE_FILE_CALLBACKW)(
    __in HANDLE FileHandle,
    __in PCWSTR FileName,
    __in_opt PVOID CallerData
);

HANDLE
IMAGEAPI
SymFindExecutableImageW(
    __in HANDLE hProcess,
    __in PCWSTR FileName,
    __out_ecount(MAX_PATH + 1) PWSTR ImageFilePath,
    __in PFIND_EXE_FILE_CALLBACKW Callback,
    __in PVOID CallerData
);

HANDLE
IMAGEAPI
FindExecutableImage(
    __in PCSTR FileName,
    __in PCSTR SymbolPath,
    __out_ecount(MAX_PATH + 1) PSTR ImageFilePath
);

HANDLE
IMAGEAPI
FindExecutableImageEx(
    __in PCSTR FileName,
    __in PCSTR SymbolPath,
    __out_ecount(MAX_PATH + 1) PSTR ImageFilePath,
    __in_opt PFIND_EXE_FILE_CALLBACK Callback,
    __in_opt PVOID CallerData
);

HANDLE
IMAGEAPI
FindExecutableImageExW(
    __in PCWSTR FileName,
    __in PCWSTR SymbolPath,
    __out_ecount(MAX_PATH + 1) PWSTR ImageFilePath,
    __in_opt PFIND_EXE_FILE_CALLBACKW Callback,
    __in PVOID CallerData
);

PIMAGE_NT_HEADERS
IMAGEAPI
ImageNtHeader(
    __in PVOID Base
);

PVOID
IMAGEAPI
ImageDirectoryEntryToDataEx(
    __in PVOID Base,
    __in BOOLEAN MappedAsImage,
    __in USHORT DirectoryEntry,
    __out PULONG Size,
    __out_opt PIMAGE_SECTION_HEADER* FoundHeader
);

PVOID
IMAGEAPI
ImageDirectoryEntryToData(
    __in PVOID Base,
    __in BOOLEAN MappedAsImage,
    __in USHORT DirectoryEntry,
    __out PULONG Size
);

PIMAGE_SECTION_HEADER
IMAGEAPI
ImageRvaToSection(
    __in PIMAGE_NT_HEADERS NtHeaders,
    __in PVOID Base,
    __in ULONG Rva
);

PVOID
IMAGEAPI
ImageRvaToVa(
    __in PIMAGE_NT_HEADERS NtHeaders,
    __in PVOID Base,
    __in ULONG Rva,
    __in_opt OUT PIMAGE_SECTION_HEADER* LastRvaSection
);

#ifndef _WIN64
// This api won't be ported to Win64 - Fix your code.

typedef struct _IMAGE_DEBUG_INFORMATION
{
    LIST_ENTRY List;
    DWORD ReservedSize;
    PVOID ReservedMappedBase;
    USHORT ReservedMachine;
    USHORT ReservedCharacteristics;
    DWORD ReservedCheckSum;
    DWORD ImageBase;
    DWORD SizeOfImage;

    DWORD ReservedNumberOfSections;
    PIMAGE_SECTION_HEADER ReservedSections;

    DWORD ReservedExportedNamesSize;
    PSTR ReservedExportedNames;

    DWORD ReservedNumberOfFunctionTableEntries;
    PIMAGE_FUNCTION_ENTRY ReservedFunctionTableEntries;
    DWORD ReservedLowestFunctionStartingAddress;
    DWORD ReservedHighestFunctionEndingAddress;

    DWORD ReservedNumberOfFpoTableEntries;
    PFPO_DATA ReservedFpoTableEntries;

    DWORD SizeOfCoffSymbols;
    PIMAGE_COFF_SYMBOLS_HEADER CoffSymbols;

    DWORD ReservedSizeOfCodeViewSymbols;
    PVOID ReservedCodeViewSymbols;

    PSTR ImageFilePath;
    PSTR ImageFileName;
    PSTR ReservedDebugFilePath;

    DWORD ReservedTimeDateStamp;

    BOOL  ReservedRomImage;
    PIMAGE_DEBUG_DIRECTORY ReservedDebugDirectory;
    DWORD ReservedNumberOfDebugDirectories;

    DWORD ReservedOriginalFunctionTableBaseAddress;

    DWORD Reserved[ 2 ];

} IMAGE_DEBUG_INFORMATION, *PIMAGE_DEBUG_INFORMATION;


PIMAGE_DEBUG_INFORMATION
IMAGEAPI
MapDebugInformation(
    __in_opt HANDLE FileHandle,
    __in PCSTR FileName,
    __in_opt PCSTR SymbolPath,
    __in ULONG ImageBase
);

BOOL
IMAGEAPI
UnmapDebugInformation(
    __out_xcount(unknown) PIMAGE_DEBUG_INFORMATION DebugInfo
);

#endif

BOOL
IMAGEAPI
SearchTreeForFile(
    __in PCSTR RootPath,
    __in PCSTR InputPathName,
    __out_ecount(MAX_PATH + 1) PSTR OutputPathBuffer
);

BOOL
IMAGEAPI
SearchTreeForFileW(
    __in PCWSTR RootPath,
    __in PCWSTR InputPathName,
    __out_ecount(MAX_PATH + 1) PWSTR OutputPathBuffer
);

typedef BOOL
(CALLBACK* PENUMDIRTREE_CALLBACK)(
    __in PCSTR FilePath,
    __in_opt PVOID CallerData
);

BOOL
IMAGEAPI
EnumDirTree(
    __in_opt HANDLE hProcess,
    __in PCSTR RootPath,
    __in PCSTR InputPathName,
    __out_ecount_opt(MAX_PATH + 1) PSTR OutputPathBuffer,
    __in_opt PENUMDIRTREE_CALLBACK cb,
    __in_opt PVOID data
);

typedef BOOL
(CALLBACK* PENUMDIRTREE_CALLBACKW)(
    __in PCWSTR FilePath,
    __in_opt PVOID CallerData
);

BOOL
IMAGEAPI
EnumDirTreeW(
    __in_opt HANDLE hProcess,
    __in PCWSTR RootPath,
    __in PCWSTR InputPathName,
    __out_ecount_opt(MAX_PATH + 1) PWSTR OutputPathBuffer,
    __in_opt PENUMDIRTREE_CALLBACKW cb,
    __in_opt PVOID data
);

BOOL
IMAGEAPI
MakeSureDirectoryPathExists(
    __in PCSTR DirPath
);

//
// UnDecorateSymbolName Flags
//

#define UNDNAME_COMPLETE                 (0x0000)  // Enable full undecoration
#define UNDNAME_NO_LEADING_UNDERSCORES   (0x0001)  // Remove leading underscores from MS extended keywords
#define UNDNAME_NO_MS_KEYWORDS           (0x0002)  // Disable expansion of MS extended keywords
#define UNDNAME_NO_FUNCTION_RETURNS      (0x0004)  // Disable expansion of return type for primary declaration
#define UNDNAME_NO_ALLOCATION_MODEL      (0x0008)  // Disable expansion of the declaration model
#define UNDNAME_NO_ALLOCATION_LANGUAGE   (0x0010)  // Disable expansion of the declaration language specifier
#define UNDNAME_NO_MS_THISTYPE           (0x0020)  // NYI Disable expansion of MS keywords on the 'this' type for primary declaration
#define UNDNAME_NO_CV_THISTYPE           (0x0040)  // NYI Disable expansion of CV modifiers on the 'this' type for primary declaration
#define UNDNAME_NO_THISTYPE              (0x0060)  // Disable all modifiers on the 'this' type
#define UNDNAME_NO_ACCESS_SPECIFIERS     (0x0080)  // Disable expansion of access specifiers for members
#define UNDNAME_NO_THROW_SIGNATURES      (0x0100)  // Disable expansion of 'throw-signatures' for functions and pointers to functions
#define UNDNAME_NO_MEMBER_TYPE           (0x0200)  // Disable expansion of 'static' or 'virtual'ness of members
#define UNDNAME_NO_RETURN_UDT_MODEL      (0x0400)  // Disable expansion of MS model for UDT returns
#define UNDNAME_32_BIT_DECODE            (0x0800)  // Undecorate 32-bit decorated names
#define UNDNAME_NAME_ONLY                (0x1000)  // Crack only the name for primary declaration;
//  return just [scope::]name.  Does expand template params
#define UNDNAME_NO_ARGUMENTS             (0x2000)  // Don't undecorate arguments to function
#define UNDNAME_NO_SPECIAL_SYMS          (0x4000)  // Don't undecorate special names (v-table, vcall, vector xxx, metatype, etc)

DWORD
IMAGEAPI
WINAPI
UnDecorateSymbolName(
    __in PCSTR name,
    __out_ecount(maxStringLength) PSTR outputString,
    __in DWORD maxStringLength,
    __in DWORD flags
);

DWORD
IMAGEAPI
WINAPI
UnDecorateSymbolNameW(
    __in PCWSTR name,
    __out_ecount(maxStringLength) PWSTR outputString,
    __in DWORD maxStringLength,
    __in DWORD flags
);

//
// these values are used for synthesized file types
// that can be passed in as image headers instead of
// the standard ones from ntimage.h
//

#define DBHHEADER_DEBUGDIRS     0x1
#define DBHHEADER_CVMISC        0x2
#define DBHHEADER_PDBGUID       0x3
typedef struct _MODLOAD_DATA
{
    DWORD   ssize;                  // size of this struct
    DWORD   ssig;                   // signature identifying the passed data
    PVOID   data;                   // pointer to passed data
    DWORD   size;                   // size of passed data
    DWORD   flags;                  // options
} MODLOAD_DATA, *PMODLOAD_DATA;

typedef struct _MODLOAD_CVMISC
{
    DWORD   oCV;                    // ofset to the codeview record
    size_t  cCV;                    // size of the codeview record
    DWORD   oMisc;                  // offset to the misc record
    size_t  cMisc;                  // size of the misc record
    DWORD   dtImage;                // datetime stamp of the image
    DWORD   cImage;                 // size of the image
} MODLOAD_CVMISC, *PMODLOAD_CVMISC;

typedef struct _MODLOAD_PDBGUID_PDBAGE
{
    GUID    PdbGuid;                // Pdb Guid
    DWORD   PdbAge;                 // Pdb Age
} MODLOAD_PDBGUID_PDBAGE, *PMODLOAD_PDBGUID_PDBAGE;

//
// StackWalking API
//

typedef enum
{
    AddrMode1616,
    AddrMode1632,
    AddrModeReal,
    AddrModeFlat
} ADDRESS_MODE;

typedef struct _tagADDRESS64
{
    DWORD64       Offset;
    WORD          Segment;
    ADDRESS_MODE  Mode;
} ADDRESS64, *LPADDRESS64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define ADDRESS ADDRESS64
#define LPADDRESS LPADDRESS64
#else
typedef struct _tagADDRESS
{
    DWORD         Offset;
    WORD          Segment;
    ADDRESS_MODE  Mode;
} ADDRESS, *LPADDRESS;

__inline
void
Address32To64(
    __in LPADDRESS a32,
    __out LPADDRESS64 a64
)
{
    a64->Offset = (ULONG64)(LONG64)(LONG)a32->Offset;
    a64->Segment = a32->Segment;
    a64->Mode = a32->Mode;
}

__inline
void
Address64To32(
    __in LPADDRESS64 a64,
    __out LPADDRESS a32
)
{
    a32->Offset = (ULONG)a64->Offset;
    a32->Segment = a64->Segment;
    a32->Mode = a64->Mode;
}
#endif

//
// This structure is included in the STACKFRAME structure,
// and is used to trace through usermode callbacks in a thread's
// kernel stack.  The values must be copied by the kernel debugger
// from the DBGKD_GET_VERSION and WAIT_STATE_CHANGE packets.
//

//
// New KDHELP structure for 64 bit system support.
// This structure is preferred in new code.
//
typedef struct _KDHELP64
{

    //
    // address of kernel thread object, as provided in the
    // WAIT_STATE_CHANGE packet.
    //
    DWORD64   Thread;

    //
    // offset in thread object to pointer to the current callback frame
    // in kernel stack.
    //
    DWORD   ThCallbackStack;

    //
    // offset in thread object to pointer to the current callback backing
    // store frame in kernel stack.
    //
    DWORD   ThCallbackBStore;

    //
    // offsets to values in frame:
    //
    // address of next callback frame
    DWORD   NextCallback;

    // address of saved frame pointer (if applicable)
    DWORD   FramePointer;


    //
    // Address of the kernel function that calls out to user mode
    //
    DWORD64   KiCallUserMode;

    //
    // Address of the user mode dispatcher function
    //
    DWORD64   KeUserCallbackDispatcher;

    //
    // Lowest kernel mode address
    //
    DWORD64   SystemRangeStart;

    //
    // Address of the user mode exception dispatcher function.
    // Added in API version 10.
    //
    DWORD64   KiUserExceptionDispatcher;

    //
    // Stack bounds, added in API version 11.
    //
    DWORD64   StackBase;
    DWORD64   StackLimit;

    DWORD64   Reserved[5];

} KDHELP64, *PKDHELP64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define KDHELP KDHELP64
#define PKDHELP PKDHELP64
#else
typedef struct _KDHELP
{

    //
    // address of kernel thread object, as provided in the
    // WAIT_STATE_CHANGE packet.
    //
    DWORD   Thread;

    //
    // offset in thread object to pointer to the current callback frame
    // in kernel stack.
    //
    DWORD   ThCallbackStack;

    //
    // offsets to values in frame:
    //
    // address of next callback frame
    DWORD   NextCallback;

    // address of saved frame pointer (if applicable)
    DWORD   FramePointer;

    //
    // Address of the kernel function that calls out to user mode
    //
    DWORD   KiCallUserMode;

    //
    // Address of the user mode dispatcher function
    //
    DWORD   KeUserCallbackDispatcher;

    //
    // Lowest kernel mode address
    //
    DWORD   SystemRangeStart;

    //
    // offset in thread object to pointer to the current callback backing
    // store frame in kernel stack.
    //
    DWORD   ThCallbackBStore;

    //
    // Address of the user mode exception dispatcher function.
    // Added in API version 10.
    //
    DWORD   KiUserExceptionDispatcher;

    //
    // Stack bounds, added in API version 11.
    //
    DWORD   StackBase;
    DWORD   StackLimit;

    DWORD   Reserved[5];

} KDHELP, *PKDHELP;

__inline
void
KdHelp32To64(
    __in PKDHELP p32,
    __out PKDHELP64 p64
)
{
    p64->Thread = p32->Thread;
    p64->ThCallbackStack = p32->ThCallbackStack;
    p64->NextCallback = p32->NextCallback;
    p64->FramePointer = p32->FramePointer;
    p64->KiCallUserMode = p32->KiCallUserMode;
    p64->KeUserCallbackDispatcher = p32->KeUserCallbackDispatcher;
    p64->SystemRangeStart = p32->SystemRangeStart;
    p64->KiUserExceptionDispatcher = p32->KiUserExceptionDispatcher;
    p64->StackBase = p32->StackBase;
    p64->StackLimit = p32->StackLimit;
}
#endif

typedef struct _tagSTACKFRAME64
{
    ADDRESS64   AddrPC;               // program counter
    ADDRESS64   AddrReturn;           // return address
    ADDRESS64   AddrFrame;            // frame pointer
    ADDRESS64   AddrStack;            // stack pointer
    ADDRESS64   AddrBStore;           // backing store pointer
    PVOID       FuncTableEntry;       // pointer to pdata/fpo or NULL
    DWORD64     Params[4];            // possible arguments to the function
    BOOL        Far;                  // WOW far call
    BOOL        Virtual;              // is this a virtual frame?
    DWORD64     Reserved[3];
    KDHELP64    KdHelp;
} STACKFRAME64, *LPSTACKFRAME64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define STACKFRAME STACKFRAME64
#define LPSTACKFRAME LPSTACKFRAME64
#else
typedef struct _tagSTACKFRAME
{
    ADDRESS     AddrPC;               // program counter
    ADDRESS     AddrReturn;           // return address
    ADDRESS     AddrFrame;            // frame pointer
    ADDRESS     AddrStack;            // stack pointer
    PVOID       FuncTableEntry;       // pointer to pdata/fpo or NULL
    DWORD       Params[4];            // possible arguments to the function
    BOOL        Far;                  // WOW far call
    BOOL        Virtual;              // is this a virtual frame?
    DWORD       Reserved[3];
    KDHELP      KdHelp;
    ADDRESS     AddrBStore;           // backing store pointer
} STACKFRAME, *LPSTACKFRAME;
#endif


typedef
BOOL
(__stdcall* PREAD_PROCESS_MEMORY_ROUTINE64)(
    __in HANDLE hProcess,
    __in DWORD64 qwBaseAddress,
    __out_bcount(nSize) PVOID lpBuffer,
    __in DWORD nSize,
    __out LPDWORD lpNumberOfBytesRead
);

typedef
PVOID
(__stdcall* PFUNCTION_TABLE_ACCESS_ROUTINE64)(
    __in HANDLE ahProcess,
    __in DWORD64 AddrBase
);

typedef
DWORD64
(__stdcall* PGET_MODULE_BASE_ROUTINE64)(
    __in HANDLE hProcess,
    __in DWORD64 Address
);

typedef
DWORD64
(__stdcall* PTRANSLATE_ADDRESS_ROUTINE64)(
    __in HANDLE hProcess,
    __in HANDLE hThread,
    __in LPADDRESS64 lpaddr
);

BOOL
IMAGEAPI
StackWalk64(
    __in DWORD MachineType,
    __in HANDLE hProcess,
    __in HANDLE hThread,
    __inout LPSTACKFRAME64 StackFrame,
    __inout PVOID ContextRecord,
    __in_opt PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemoryRoutine,
    __in_opt PFUNCTION_TABLE_ACCESS_ROUTINE64 FunctionTableAccessRoutine,
    __in_opt PGET_MODULE_BASE_ROUTINE64 GetModuleBaseRoutine,
    __in_opt PTRANSLATE_ADDRESS_ROUTINE64 TranslateAddress
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)

#define PREAD_PROCESS_MEMORY_ROUTINE PREAD_PROCESS_MEMORY_ROUTINE64
#define PFUNCTION_TABLE_ACCESS_ROUTINE PFUNCTION_TABLE_ACCESS_ROUTINE64
#define PGET_MODULE_BASE_ROUTINE PGET_MODULE_BASE_ROUTINE64
#define PTRANSLATE_ADDRESS_ROUTINE PTRANSLATE_ADDRESS_ROUTINE64

#define StackWalk StackWalk64

#else

typedef
BOOL
(__stdcall* PREAD_PROCESS_MEMORY_ROUTINE)(
    __in HANDLE hProcess,
    __in DWORD lpBaseAddress,
    __out_bcount(nSize) PVOID lpBuffer,
    __in DWORD nSize,
    __out PDWORD lpNumberOfBytesRead
);

typedef
PVOID
(__stdcall* PFUNCTION_TABLE_ACCESS_ROUTINE)(
    __in HANDLE hProcess,
    __in DWORD AddrBase
);

typedef
DWORD
(__stdcall* PGET_MODULE_BASE_ROUTINE)(
    __in HANDLE hProcess,
    __in DWORD Address
);

typedef
DWORD
(__stdcall* PTRANSLATE_ADDRESS_ROUTINE)(
    __in HANDLE hProcess,
    __in HANDLE hThread,
    __out LPADDRESS lpaddr
);

BOOL
IMAGEAPI
StackWalk(
    DWORD MachineType,
    __in HANDLE hProcess,
    __in HANDLE hThread,
    __inout LPSTACKFRAME StackFrame,
    __inout PVOID ContextRecord,
    __in_opt PREAD_PROCESS_MEMORY_ROUTINE ReadMemoryRoutine,
    __in_opt PFUNCTION_TABLE_ACCESS_ROUTINE FunctionTableAccessRoutine,
    __in_opt PGET_MODULE_BASE_ROUTINE GetModuleBaseRoutine,
    __in_opt PTRANSLATE_ADDRESS_ROUTINE TranslateAddress
);

#endif


#define API_VERSION_NUMBER 11

typedef struct API_VERSION
{
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    USHORT  Revision;
    USHORT  Reserved;
} API_VERSION, *LPAPI_VERSION;

LPAPI_VERSION
IMAGEAPI
ImagehlpApiVersion(
    VOID
);

LPAPI_VERSION
IMAGEAPI
ImagehlpApiVersionEx(
    __in LPAPI_VERSION AppVersion
);

DWORD
IMAGEAPI
GetTimestampForLoadedLibrary(
    __in HMODULE Module
);

//
// typedefs for function pointers
//
typedef BOOL
(CALLBACK* PSYM_ENUMMODULES_CALLBACK64)(
    __in PCSTR ModuleName,
    __in DWORD64 BaseOfDll,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYM_ENUMMODULES_CALLBACKW64)(
    __in PCWSTR ModuleName,
    __in DWORD64 BaseOfDll,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PENUMLOADED_MODULES_CALLBACK64)(
    __in PCSTR ModuleName,
    __in DWORD64 ModuleBase,
    __in ULONG ModuleSize,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PENUMLOADED_MODULES_CALLBACKW64)(
    __in PCWSTR ModuleName,
    __in DWORD64 ModuleBase,
    __in ULONG ModuleSize,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYM_ENUMSYMBOLS_CALLBACK64)(
    __in PCSTR SymbolName,
    __in DWORD64 SymbolAddress,
    __in ULONG SymbolSize,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYM_ENUMSYMBOLS_CALLBACK64W)(
    __in PCWSTR SymbolName,
    __in DWORD64 SymbolAddress,
    __in ULONG SymbolSize,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYMBOL_REGISTERED_CALLBACK64)(
    __in HANDLE hProcess,
    __in ULONG ActionCode,
    __in_opt ULONG64 CallbackData,
    __in_opt ULONG64 UserContext
);

typedef
PVOID
(CALLBACK* PSYMBOL_FUNCENTRY_CALLBACK)(
    __in HANDLE hProcess,
    __in DWORD AddrBase,
    __in_opt PVOID UserContext
);

typedef
PVOID
(CALLBACK* PSYMBOL_FUNCENTRY_CALLBACK64)(
    __in HANDLE hProcess,
    __in ULONG64 AddrBase,
    __in ULONG64 UserContext
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)

#define PSYM_ENUMMODULES_CALLBACK PSYM_ENUMMODULES_CALLBACK64
#define PSYM_ENUMSYMBOLS_CALLBACK PSYM_ENUMSYMBOLS_CALLBACK64
#define PSYM_ENUMSYMBOLS_CALLBACKW PSYM_ENUMSYMBOLS_CALLBACK64W
#define PENUMLOADED_MODULES_CALLBACK PENUMLOADED_MODULES_CALLBACK64
#define PSYMBOL_REGISTERED_CALLBACK PSYMBOL_REGISTERED_CALLBACK64
#define PSYMBOL_FUNCENTRY_CALLBACK PSYMBOL_FUNCENTRY_CALLBACK64

#else

typedef BOOL
(CALLBACK* PSYM_ENUMMODULES_CALLBACK)(
    __in PCSTR ModuleName,
    __in ULONG BaseOfDll,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYM_ENUMSYMBOLS_CALLBACK)(
    __in PCSTR SymbolName,
    __in ULONG SymbolAddress,
    __in ULONG SymbolSize,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYM_ENUMSYMBOLS_CALLBACKW)(
    __in PCWSTR SymbolName,
    __in ULONG SymbolAddress,
    __in ULONG SymbolSize,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PENUMLOADED_MODULES_CALLBACK)(
    __in PCSTR ModuleName,
    __in ULONG ModuleBase,
    __in ULONG ModuleSize,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYMBOL_REGISTERED_CALLBACK)(
    __in HANDLE hProcess,
    __in ULONG ActionCode,
    __in_opt PVOID CallbackData,
    __in_opt PVOID UserContext
);

#endif


// values found in SYMBOL_INFO.Tag
//
// This was taken from cvconst.h and should
// not override any values found there.
//
// #define _NO_CVCONST_H_ if you don't
// have access to that file...

#ifdef _NO_CVCONST_H

// DIA enums

enum SymTagEnum
{
    SymTagNull,
    SymTagExe,
    SymTagCompiland,
    SymTagCompilandDetails,
    SymTagCompilandEnv,
    SymTagFunction,
    SymTagBlock,
    SymTagData,
    SymTagAnnotation,
    SymTagLabel,
    SymTagPublicSymbol,
    SymTagUDT,
    SymTagEnum,
    SymTagFunctionType,
    SymTagPointerType,
    SymTagArrayType,
    SymTagBaseType,
    SymTagTypedef,
    SymTagBaseClass,
    SymTagFriend,
    SymTagFunctionArgType,
    SymTagFuncDebugStart,
    SymTagFuncDebugEnd,
    SymTagUsingNamespace,
    SymTagVTableShape,
    SymTagVTable,
    SymTagCustom,
    SymTagThunk,
    SymTagCustomType,
    SymTagManagedType,
    SymTagDimension,
    SymTagMax
};

#endif

//
// flags found in SYMBOL_INFO.Flags
//

#define SYMFLAG_VALUEPRESENT     0x00000001
#define SYMFLAG_REGISTER         0x00000008
#define SYMFLAG_REGREL           0x00000010
#define SYMFLAG_FRAMEREL         0x00000020
#define SYMFLAG_PARAMETER        0x00000040
#define SYMFLAG_LOCAL            0x00000080
#define SYMFLAG_CONSTANT         0x00000100
#define SYMFLAG_EXPORT           0x00000200
#define SYMFLAG_FORWARDER        0x00000400
#define SYMFLAG_FUNCTION         0x00000800
#define SYMFLAG_VIRTUAL          0x00001000
#define SYMFLAG_THUNK            0x00002000
#define SYMFLAG_TLSREL           0x00004000
#define SYMFLAG_SLOT             0x00008000
#define SYMFLAG_ILREL            0x00010000
#define SYMFLAG_METADATA         0x00020000
#define SYMFLAG_CLR_TOKEN        0x00040000

// this resets SymNext/Prev to the beginning
// of the module passed in the address field

#define SYMFLAG_RESET            0x80000000

//
// symbol type enumeration
//
typedef enum
{
    SymNone = 0,
    SymCoff,
    SymCv,
    SymPdb,
    SymExport,
    SymDeferred,
    SymSym,       // .sym file
    SymDia,
    SymVirtual,
    NumSymTypes
} SYM_TYPE;

//
// symbol data structure
//

typedef struct _IMAGEHLP_SYMBOL64
{
    DWORD   SizeOfStruct;           // set to sizeof(IMAGEHLP_SYMBOL64)
    DWORD64 Address;                // virtual address including dll base address
    DWORD   Size;                   // estimated size of symbol, can be zero
    DWORD   Flags;                  // info about the symbols, see the SYMF defines
    DWORD   MaxNameLength;          // maximum size of symbol name in 'Name'
    CHAR    Name[1];                // symbol name (null terminated string)
} IMAGEHLP_SYMBOL64, *PIMAGEHLP_SYMBOL64;

typedef struct _IMAGEHLP_SYMBOL64_PACKAGE
{
    IMAGEHLP_SYMBOL64 sym;
    CHAR              name[MAX_SYM_NAME + 1];
} IMAGEHLP_SYMBOL64_PACKAGE, *PIMAGEHLP_SYMBOL64_PACKAGE;

typedef struct _IMAGEHLP_SYMBOLW64
{
    DWORD   SizeOfStruct;           // set to sizeof(IMAGEHLP_SYMBOLW64)
    DWORD64 Address;                // virtual address including dll base address
    DWORD   Size;                   // estimated size of symbol, can be zero
    DWORD   Flags;                  // info about the symbols, see the SYMF defines
    DWORD   MaxNameLength;          // maximum size of symbol name in 'Name'
    WCHAR   Name[1];                // symbol name (null terminated string)
} IMAGEHLP_SYMBOLW64, *PIMAGEHLP_SYMBOLW64;

typedef struct _IMAGEHLP_SYMBOLW64_PACKAGE
{
    IMAGEHLP_SYMBOLW64 sym;
    WCHAR              name[MAX_SYM_NAME + 1];
} IMAGEHLP_SYMBOLW64_PACKAGE, *PIMAGEHLP_SYMBOLW64_PACKAGE;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)

#define IMAGEHLP_SYMBOL IMAGEHLP_SYMBOL64
#define PIMAGEHLP_SYMBOL PIMAGEHLP_SYMBOL64
#define IMAGEHLP_SYMBOL_PACKAGE IMAGEHLP_SYMBOL64_PACKAGE
#define PIMAGEHLP_SYMBOL_PACKAGE PIMAGEHLP_SYMBOL64_PACKAGE
#define IMAGEHLP_SYMBOLW IMAGEHLP_SYMBOLW64
#define PIMAGEHLP_SYMBOLW PIMAGEHLP_SYMBOLW64
#define IMAGEHLP_SYMBOLW_PACKAGE IMAGEHLP_SYMBOLW64_PACKAGE
#define PIMAGEHLP_SYMBOLW_PACKAGE PIMAGEHLP_SYMBOLW64_PACKAGE

#else

typedef struct _IMAGEHLP_SYMBOL
{
    DWORD SizeOfStruct;           // set to sizeof(IMAGEHLP_SYMBOL)
    DWORD Address;                // virtual address including dll base address
    DWORD Size;                   // estimated size of symbol, can be zero
    DWORD Flags;                  // info about the symbols, see the SYMF defines
    DWORD                       MaxNameLength;          // maximum size of symbol name in 'Name'
    CHAR                        Name[1];                // symbol name (null terminated string)
} IMAGEHLP_SYMBOL, *PIMAGEHLP_SYMBOL;

typedef struct _IMAGEHLP_SYMBOL_PACKAGE
{
    IMAGEHLP_SYMBOL sym;
    CHAR            name[MAX_SYM_NAME + 1];
} IMAGEHLP_SYMBOL_PACKAGE, *PIMAGEHLP_SYMBOL_PACKAGE;

typedef struct _IMAGEHLP_SYMBOLW
{
    DWORD SizeOfStruct;           // set to sizeof(IMAGEHLP_SYMBOLW)
    DWORD Address;                // virtual address including dll base address
    DWORD Size;                   // estimated size of symbol, can be zero
    DWORD Flags;                  // info about the symbols, see the SYMF defines
    DWORD                       MaxNameLength;          // maximum size of symbol name in 'Name'
    WCHAR                       Name[1];                // symbol name (null terminated string)
} IMAGEHLP_SYMBOLW, *PIMAGEHLP_SYMBOLW;

typedef struct _IMAGEHLP_SYMBOLW_PACKAGE
{
    IMAGEHLP_SYMBOLW sym;
    WCHAR            name[MAX_SYM_NAME + 1];
} IMAGEHLP_SYMBOLW_PACKAGE, *PIMAGEHLP_SYMBOLW_PACKAGE;

#endif

//
// module data structure
//

typedef struct _IMAGEHLP_MODULE64
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE64)
    DWORD64  BaseOfImage;            // base load address of module
    DWORD    ImageSize;              // virtual size of the loaded module
    DWORD    TimeDateStamp;          // date/time stamp from pe header
    DWORD    CheckSum;               // checksum from the pe header
    DWORD    NumSyms;                // number of symbols in the symbol table
    SYM_TYPE SymType;                // type of symbols loaded
    CHAR     ModuleName[32];         // module name
    CHAR     ImageName[256];         // image name
    CHAR     LoadedImageName[256];   // symbol file name
    // new elements: 07-Jun-2002
    CHAR     LoadedPdbName[256];     // pdb file name
    DWORD    CVSig;                  // Signature of the CV record in the debug directories
    CHAR     CVData[MAX_PATH * 3];   // Contents of the CV record
    DWORD    PdbSig;                 // Signature of PDB
    GUID     PdbSig70;               // Signature of PDB (VC 7 and up)
    DWORD    PdbAge;                 // DBI age of pdb
    BOOL     PdbUnmatched;           // loaded an unmatched pdb
    BOOL     DbgUnmatched;           // loaded an unmatched dbg
    BOOL     LineNumbers;            // we have line number information
    BOOL     GlobalSymbols;          // we have internal symbol information
    BOOL     TypeInfo;               // we have type information
    // new elements: 17-Dec-2003
    BOOL     SourceIndexed;          // pdb supports source server
    BOOL     Publics;                // contains public symbols
} IMAGEHLP_MODULE64, *PIMAGEHLP_MODULE64;

typedef struct _IMAGEHLP_MODULEW64
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE64)
    DWORD64  BaseOfImage;            // base load address of module
    DWORD    ImageSize;              // virtual size of the loaded module
    DWORD    TimeDateStamp;          // date/time stamp from pe header
    DWORD    CheckSum;               // checksum from the pe header
    DWORD    NumSyms;                // number of symbols in the symbol table
    SYM_TYPE SymType;                // type of symbols loaded
    WCHAR    ModuleName[32];         // module name
    WCHAR    ImageName[256];         // image name
    // new elements: 07-Jun-2002
    WCHAR    LoadedImageName[256];   // symbol file name
    WCHAR    LoadedPdbName[256];     // pdb file name
    DWORD    CVSig;                  // Signature of the CV record in the debug directories
    WCHAR        CVData[MAX_PATH * 3];   // Contents of the CV record
    DWORD    PdbSig;                 // Signature of PDB
    GUID     PdbSig70;               // Signature of PDB (VC 7 and up)
    DWORD    PdbAge;                 // DBI age of pdb
    BOOL     PdbUnmatched;           // loaded an unmatched pdb
    BOOL     DbgUnmatched;           // loaded an unmatched dbg
    BOOL     LineNumbers;            // we have line number information
    BOOL     GlobalSymbols;          // we have internal symbol information
    BOOL     TypeInfo;               // we have type information
    // new elements: 17-Dec-2003
    BOOL     SourceIndexed;          // pdb supports source server
    BOOL     Publics;                // contains public symbols
} IMAGEHLP_MODULEW64, *PIMAGEHLP_MODULEW64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_MODULE IMAGEHLP_MODULE64
#define PIMAGEHLP_MODULE PIMAGEHLP_MODULE64
#define IMAGEHLP_MODULEW IMAGEHLP_MODULEW64
#define PIMAGEHLP_MODULEW PIMAGEHLP_MODULEW64
#else
typedef struct _IMAGEHLP_MODULE
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE)
    DWORD    BaseOfImage;            // base load address of module
    DWORD    ImageSize;              // virtual size of the loaded module
    DWORD    TimeDateStamp;          // date/time stamp from pe header
    DWORD    CheckSum;               // checksum from the pe header
    DWORD    NumSyms;                // number of symbols in the symbol table
    SYM_TYPE SymType;                // type of symbols loaded
    CHAR     ModuleName[32];         // module name
    CHAR     ImageName[256];         // image name
    CHAR     LoadedImageName[256];   // symbol file name
} IMAGEHLP_MODULE, *PIMAGEHLP_MODULE;

typedef struct _IMAGEHLP_MODULEW
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE)
    DWORD    BaseOfImage;            // base load address of module
    DWORD    ImageSize;              // virtual size of the loaded module
    DWORD    TimeDateStamp;          // date/time stamp from pe header
    DWORD    CheckSum;               // checksum from the pe header
    DWORD    NumSyms;                // number of symbols in the symbol table
    SYM_TYPE SymType;                // type of symbols loaded
    WCHAR    ModuleName[32];         // module name
    WCHAR    ImageName[256];         // image name
    WCHAR    LoadedImageName[256];   // symbol file name
} IMAGEHLP_MODULEW, *PIMAGEHLP_MODULEW;
#endif

//
// source file line data structure
//

typedef struct _IMAGEHLP_LINE64
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_LINE64)
    PVOID    Key;                    // internal
    DWORD    LineNumber;             // line number in file
    PCHAR    FileName;               // full filename
    DWORD64  Address;                // first instruction of line
} IMAGEHLP_LINE64, *PIMAGEHLP_LINE64;

typedef struct _IMAGEHLP_LINEW64
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_LINE64)
    PVOID    Key;                    // internal
    DWORD    LineNumber;             // line number in file
    PWSTR    FileName;               // full filename
    DWORD64  Address;                // first instruction of line
} IMAGEHLP_LINEW64, *PIMAGEHLP_LINEW64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_LINE IMAGEHLP_LINE64
#define PIMAGEHLP_LINE PIMAGEHLP_LINE64
#else
typedef struct _IMAGEHLP_LINE
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_LINE)
    PVOID    Key;                    // internal
    DWORD    LineNumber;             // line number in file
    PCHAR    FileName;               // full filename
    DWORD    Address;                // first instruction of line
} IMAGEHLP_LINE, *PIMAGEHLP_LINE;

typedef struct _IMAGEHLP_LINEW
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_LINE64)
    PVOID    Key;                    // internal
    DWORD    LineNumber;             // line number in file
    PCHAR    FileName;               // full filename
    DWORD64  Address;                // first instruction of line
} IMAGEHLP_LINEW, *PIMAGEHLP_LINEW;
#endif

//
// source file structure
//

typedef struct _SOURCEFILE
{
    DWORD64  ModBase;                // base address of loaded module
    PCHAR    FileName;               // full filename of source
} SOURCEFILE, *PSOURCEFILE;

typedef struct _SOURCEFILEW
{
    DWORD64  ModBase;                // base address of loaded module
    PWSTR    FileName;               // full filename of source
} SOURCEFILEW, *PSOURCEFILEW;

//
// data structures used for registered symbol callbacks
//

#define CBA_DEFERRED_SYMBOL_LOAD_START          0x00000001
#define CBA_DEFERRED_SYMBOL_LOAD_COMPLETE       0x00000002
#define CBA_DEFERRED_SYMBOL_LOAD_FAILURE        0x00000003
#define CBA_SYMBOLS_UNLOADED                    0x00000004
#define CBA_DUPLICATE_SYMBOL                    0x00000005
#define CBA_READ_MEMORY                         0x00000006
#define CBA_DEFERRED_SYMBOL_LOAD_CANCEL         0x00000007
#define CBA_SET_OPTIONS                         0x00000008
#define CBA_EVENT                               0x00000010
#define CBA_DEFERRED_SYMBOL_LOAD_PARTIAL        0x00000020
#define CBA_DEBUG_INFO                          0x10000000
#define CBA_SRCSRV_INFO                         0x20000000
#define CBA_SRCSRV_EVENT                        0x40000000

typedef struct _IMAGEHLP_CBA_READ_MEMORY
{
    DWORD64   addr;                                     // address to read from
    PVOID     buf;                                      // buffer to read to
    DWORD     bytes;                                    // amount of bytes to read
    DWORD*    bytesread;                                // pointer to store amount of bytes read
} IMAGEHLP_CBA_READ_MEMORY, *PIMAGEHLP_CBA_READ_MEMORY;

enum
{
    sevInfo = 0,
    sevProblem,
    sevAttn,
    sevFatal,
    sevMax  // unused
};

#define EVENT_SRCSPEW_START 100
#define EVENT_SRCSPEW       100
#define EVENT_SRCSPEW_END   199

typedef struct _IMAGEHLP_CBA_EVENT
{
    DWORD severity;                                     // values from sevInfo to sevFatal
    DWORD code;                                         // numerical code IDs the error
    PCHAR desc;                                         // may contain a text description of the error
    PVOID object;                                       // value dependant upon the error code
} IMAGEHLP_CBA_EVENT, *PIMAGEHLP_CBA_EVENT;

typedef struct _IMAGEHLP_CBA_EVENTW
{
    DWORD  severity;                                     // values from sevInfo to sevFatal
    DWORD  code;                                         // numerical code IDs the error
    PCWSTR desc;                                         // may contain a text description of the error
    PVOID  object;                                       // value dependant upon the error code
} IMAGEHLP_CBA_EVENTW, *PIMAGEHLP_CBA_EVENTW;

typedef struct _IMAGEHLP_DEFERRED_SYMBOL_LOAD64
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_DEFERRED_SYMBOL_LOAD64)
    DWORD64  BaseOfImage;            // base load address of module
    DWORD    CheckSum;               // checksum from the pe header
    DWORD    TimeDateStamp;          // date/time stamp from pe header
    CHAR     FileName[MAX_PATH];     // symbols file or image name
    BOOLEAN  Reparse;                // load failure reparse
    HANDLE   hFile;                  // file handle, if passed
    DWORD    Flags;                     //
} IMAGEHLP_DEFERRED_SYMBOL_LOAD64, *PIMAGEHLP_DEFERRED_SYMBOL_LOAD64;

typedef struct _IMAGEHLP_DEFERRED_SYMBOL_LOADW64
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_DEFERRED_SYMBOL_LOADW64)
    DWORD64  BaseOfImage;            // base load address of module
    DWORD    CheckSum;               // checksum from the pe header
    DWORD    TimeDateStamp;          // date/time stamp from pe header
    WCHAR    FileName[MAX_PATH + 1]; // symbols file or image name
    BOOLEAN  Reparse;                // load failure reparse
    HANDLE   hFile;                  // file handle, if passed
    DWORD    Flags;         //
} IMAGEHLP_DEFERRED_SYMBOL_LOADW64, *PIMAGEHLP_DEFERRED_SYMBOL_LOADW64;

#define DSLFLAG_MISMATCHED_PDB  0x1
#define DSLFLAG_MISMATCHED_DBG  0x2

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_DEFERRED_SYMBOL_LOAD IMAGEHLP_DEFERRED_SYMBOL_LOAD64
#define PIMAGEHLP_DEFERRED_SYMBOL_LOAD PIMAGEHLP_DEFERRED_SYMBOL_LOAD64
#else
typedef struct _IMAGEHLP_DEFERRED_SYMBOL_LOAD
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_DEFERRED_SYMBOL_LOAD)
    DWORD    BaseOfImage;            // base load address of module
    DWORD    CheckSum;               // checksum from the pe header
    DWORD    TimeDateStamp;          // date/time stamp from pe header
    CHAR     FileName[MAX_PATH];     // symbols file or image name
    BOOLEAN  Reparse;                // load failure reparse
    HANDLE   hFile;                  // file handle, if passed
} IMAGEHLP_DEFERRED_SYMBOL_LOAD, *PIMAGEHLP_DEFERRED_SYMBOL_LOAD;
#endif

typedef struct _IMAGEHLP_DUPLICATE_SYMBOL64
{
    DWORD              SizeOfStruct;           // set to sizeof(IMAGEHLP_DUPLICATE_SYMBOL64)
    DWORD              NumberOfDups;           // number of duplicates in the Symbol array
    PIMAGEHLP_SYMBOL64 Symbol;                 // array of duplicate symbols
    DWORD              SelectedSymbol;         // symbol selected (-1 to start)
} IMAGEHLP_DUPLICATE_SYMBOL64, *PIMAGEHLP_DUPLICATE_SYMBOL64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_DUPLICATE_SYMBOL IMAGEHLP_DUPLICATE_SYMBOL64
#define PIMAGEHLP_DUPLICATE_SYMBOL PIMAGEHLP_DUPLICATE_SYMBOL64
#else
typedef struct _IMAGEHLP_DUPLICATE_SYMBOL
{
    DWORD            SizeOfStruct;           // set to sizeof(IMAGEHLP_DUPLICATE_SYMBOL)
    DWORD            NumberOfDups;           // number of duplicates in the Symbol array
    PIMAGEHLP_SYMBOL Symbol;                 // array of duplicate symbols
    DWORD            SelectedSymbol;         // symbol selected (-1 to start)
} IMAGEHLP_DUPLICATE_SYMBOL, *PIMAGEHLP_DUPLICATE_SYMBOL;
#endif

// If dbghelp ever needs to display graphical UI, it will use this as the parent window.

BOOL
IMAGEAPI
SymSetParentWindow(
    __in HWND hwnd
);

PCHAR
IMAGEAPI
SymSetHomeDirectory(
    __in_opt HANDLE hProcess,
    __in_opt PCSTR dir
);

PWSTR
IMAGEAPI
SymSetHomeDirectoryW(
    __in_opt HANDLE hProcess,
    __in_opt PCWSTR dir
);

PCHAR
IMAGEAPI
SymGetHomeDirectory(
    __in DWORD type,
    __out_ecount(size) PSTR dir,
    __in size_t size
);

PWSTR
IMAGEAPI
SymGetHomeDirectoryW(
    __in DWORD type,
    __out_ecount(size) PWSTR dir,
    __in size_t size
);

enum
{
    hdBase = 0, // root directory for dbghelp
    hdSym,      // where symbols are stored
    hdSrc,      // where source is stored
    hdMax       // end marker
};

typedef struct _OMAP
{
    ULONG  rva;
    ULONG  rvaTo;
} OMAP, *POMAP;

BOOL
IMAGEAPI
SymGetOmaps(
    __in HANDLE hProcess,
    __in DWORD64 BaseOfDll,
    __out POMAP* OmapTo,
    __out PDWORD64 cOmapTo,
    __out POMAP* OmapFrom,
    __out PDWORD64 cOmapFrom
);

//
// options that are set/returned by SymSetOptions() & SymGetOptions()
// these are used as a mask
//
#define SYMOPT_CASE_INSENSITIVE          0x00000001
#define SYMOPT_UNDNAME                   0x00000002
#define SYMOPT_DEFERRED_LOADS            0x00000004
#define SYMOPT_NO_CPP                    0x00000008
#define SYMOPT_LOAD_LINES                0x00000010
#define SYMOPT_OMAP_FIND_NEAREST         0x00000020
#define SYMOPT_LOAD_ANYTHING             0x00000040
#define SYMOPT_IGNORE_CVREC              0x00000080
#define SYMOPT_NO_UNQUALIFIED_LOADS      0x00000100
#define SYMOPT_FAIL_CRITICAL_ERRORS      0x00000200
#define SYMOPT_EXACT_SYMBOLS             0x00000400
#define SYMOPT_ALLOW_ABSOLUTE_SYMBOLS    0x00000800
#define SYMOPT_IGNORE_NT_SYMPATH         0x00001000
#define SYMOPT_INCLUDE_32BIT_MODULES     0x00002000
#define SYMOPT_PUBLICS_ONLY              0x00004000
#define SYMOPT_NO_PUBLICS                0x00008000
#define SYMOPT_AUTO_PUBLICS              0x00010000
#define SYMOPT_NO_IMAGE_SEARCH           0x00020000
#define SYMOPT_SECURE                    0x00040000
#define SYMOPT_NO_PROMPTS                0x00080000
#define SYMOPT_OVERWRITE                 0x00100000
#define SYMOPT_IGNORE_IMAGEDIR           0x00200000
#define SYMOPT_FLAT_DIRECTORY            0x00400000
#define SYMOPT_FAVOR_COMPRESSED          0x00800000
#define SYMOPT_ALLOW_ZERO_ADDRESS        0x01000000
#define SYMOPT_DISABLE_SYMSRV_AUTODETECT 0x02000000

#define SYMOPT_DEBUG                     0x80000000

DWORD
IMAGEAPI
SymSetOptions(
    __in DWORD   SymOptions
);

DWORD
IMAGEAPI
SymGetOptions(
    VOID
);

BOOL
IMAGEAPI
SymCleanup(
    __in HANDLE hProcess
);

BOOL
IMAGEAPI
SymMatchString(
    __in PCSTR string,
    __in PCSTR expression,
    __in BOOL fCase
);

BOOL
IMAGEAPI
SymMatchStringA(
    __in PCSTR string,
    __in PCSTR expression,
    __in BOOL fCase
);

BOOL
IMAGEAPI
SymMatchStringW(
    __in PCWSTR string,
    __in PCWSTR expression,
    __in BOOL fCase
);

typedef BOOL
(CALLBACK* PSYM_ENUMSOURCEFILES_CALLBACK)(
    __in PSOURCEFILE pSourceFile,
    __in_opt PVOID UserContext
);

// for backwards compatibility - don't use this
#define PSYM_ENUMSOURCFILES_CALLBACK PSYM_ENUMSOURCEFILES_CALLBACK

BOOL
IMAGEAPI
SymEnumSourceFiles(
    __in HANDLE hProcess,
    __in ULONG64 ModBase,
    __in_opt PCSTR Mask,
    __in PSYM_ENUMSOURCEFILES_CALLBACK cbSrcFiles,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYM_ENUMSOURCEFILES_CALLBACKW)(
    __in PSOURCEFILEW pSourceFile,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumSourceFilesW(
    __in HANDLE hProcess,
    __in ULONG64 ModBase,
    __in_opt PCWSTR Mask,
    __in PSYM_ENUMSOURCEFILES_CALLBACKW cbSrcFiles,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumerateModules64(
    __in HANDLE hProcess,
    __in PSYM_ENUMMODULES_CALLBACK64 EnumModulesCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumerateModulesW64(
    __in HANDLE hProcess,
    __in PSYM_ENUMMODULES_CALLBACKW64 EnumModulesCallback,
    __in_opt PVOID UserContext
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymEnumerateModules SymEnumerateModules64
#else
BOOL
IMAGEAPI
SymEnumerateModules(
    __in HANDLE hProcess,
    __in PSYM_ENUMMODULES_CALLBACK EnumModulesCallback,
    __in_opt PVOID UserContext
);
#endif

BOOL
IMAGEAPI
EnumerateLoadedModulesEx(
    __in HANDLE hProcess,
    __in PENUMLOADED_MODULES_CALLBACK64 EnumLoadedModulesCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
EnumerateLoadedModulesExW(
    __in HANDLE hProcess,
    __in PENUMLOADED_MODULES_CALLBACKW64 EnumLoadedModulesCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
EnumerateLoadedModules64(
    __in HANDLE hProcess,
    __in PENUMLOADED_MODULES_CALLBACK64 EnumLoadedModulesCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
EnumerateLoadedModulesW64(
    __in HANDLE hProcess,
    __in PENUMLOADED_MODULES_CALLBACKW64 EnumLoadedModulesCallback,
    __in_opt PVOID UserContext
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define EnumerateLoadedModules EnumerateLoadedModules64
#else
BOOL
IMAGEAPI
EnumerateLoadedModules(
    __in HANDLE hProcess,
    __in PENUMLOADED_MODULES_CALLBACK EnumLoadedModulesCallback,
    __in_opt PVOID UserContext
);
#endif

PVOID
IMAGEAPI
SymFunctionTableAccess64(
    __in HANDLE hProcess,
    __in DWORD64 AddrBase
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymFunctionTableAccess SymFunctionTableAccess64
#else
PVOID
IMAGEAPI
SymFunctionTableAccess(
    __in HANDLE hProcess,
    __in DWORD AddrBase
);
#endif

BOOL
IMAGEAPI
SymGetUnwindInfo(
    __in HANDLE hProcess,
    __in DWORD64 Address,
    __out_bcount_opt(*Size) PVOID Buffer,
    __inout PULONG Size
);

BOOL
IMAGEAPI
SymGetModuleInfo64(
    __in HANDLE hProcess,
    __in DWORD64 qwAddr,
    __out PIMAGEHLP_MODULE64 ModuleInfo
);

BOOL
IMAGEAPI
SymGetModuleInfoW64(
    __in HANDLE hProcess,
    __in DWORD64 qwAddr,
    __out PIMAGEHLP_MODULEW64 ModuleInfo
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetModuleInfo   SymGetModuleInfo64
#define SymGetModuleInfoW  SymGetModuleInfoW64
#else
BOOL
IMAGEAPI
SymGetModuleInfo(
    __in HANDLE hProcess,
    __in DWORD dwAddr,
    __out PIMAGEHLP_MODULE ModuleInfo
);

BOOL
IMAGEAPI
SymGetModuleInfoW(
    __in HANDLE hProcess,
    __in DWORD dwAddr,
    __out PIMAGEHLP_MODULEW ModuleInfo
);
#endif

DWORD64
IMAGEAPI
SymGetModuleBase64(
    __in HANDLE hProcess,
    __in DWORD64 qwAddr
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetModuleBase SymGetModuleBase64
#else
DWORD
IMAGEAPI
SymGetModuleBase(
    __in HANDLE hProcess,
    __in DWORD dwAddr
);
#endif

typedef struct _SRCCODEINFO
{
    DWORD   SizeOfStruct;           // set to sizeof(SRCCODEINFO)
    PVOID   Key;                    // not used
    DWORD64 ModBase;                // base address of module this applies to
    CHAR    Obj[MAX_PATH + 1];      // the object file within the module
    CHAR    FileName[MAX_PATH + 1]; // full filename
    DWORD   LineNumber;             // line number in file
    DWORD64 Address;                // first instruction of line
} SRCCODEINFO, *PSRCCODEINFO;

typedef struct _SRCCODEINFOW
{
    DWORD   SizeOfStruct;           // set to sizeof(SRCCODEINFO)
    PVOID   Key;                    // not used
    DWORD64 ModBase;                // base address of module this applies to
    WCHAR   Obj[MAX_PATH + 1];      // the object file within the module
    WCHAR   FileName[MAX_PATH + 1]; // full filename
    DWORD   LineNumber;             // line number in file
    DWORD64 Address;                // first instruction of line
} SRCCODEINFOW, *PSRCCODEINFOW;

typedef BOOL
(CALLBACK* PSYM_ENUMLINES_CALLBACK)(
    __in PSRCCODEINFO LineInfo,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumLines(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCSTR Obj,
    __in_opt PCSTR File,
    __in PSYM_ENUMLINES_CALLBACK EnumLinesCallback,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYM_ENUMLINES_CALLBACKW)(
    __in PSRCCODEINFOW LineInfo,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumLinesW(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCWSTR Obj,
    __in_opt PCWSTR File,
    __in PSYM_ENUMLINES_CALLBACKW EnumLinesCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymGetLineFromAddr64(
    __in HANDLE hProcess,
    __in DWORD64 qwAddr,
    __out PDWORD pdwDisplacement,
    __out PIMAGEHLP_LINE64 Line64
);

BOOL
IMAGEAPI
SymGetLineFromAddrW64(
    __in HANDLE hProcess,
    __in DWORD64 dwAddr,
    __out PDWORD pdwDisplacement,
    __out PIMAGEHLP_LINEW64 Line
);

BOOL
IMAGEAPI
SymEnumSourceLines(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCSTR Obj,
    __in_opt PCSTR File,
    __in_opt DWORD Line,
    __in DWORD Flags,
    __in PSYM_ENUMLINES_CALLBACK EnumLinesCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumSourceLinesW(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCWSTR Obj,
    __in_opt PCWSTR File,
    __in_opt DWORD Line,
    __in DWORD Flags,
    __in PSYM_ENUMLINES_CALLBACKW EnumLinesCallback,
    __in_opt PVOID UserContext
);

// flags for SymEnumSourceLines

#define ESLFLAG_FULLPATH        0x1
#define ESLFLAG_NEAREST         0x2
#define ESLFLAG_PREV            0x4
#define ESLFLAG_NEXT            0x8

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetLineFromAddr SymGetLineFromAddr64
#define SymGetLineFromAddrW SymGetLineFromAddrW64
#else
BOOL
IMAGEAPI
SymGetLineFromAddr(
    __in HANDLE hProcess,
    __in DWORD dwAddr,
    __out PDWORD pdwDisplacement,
    __out PIMAGEHLP_LINE Line
);

BOOL
IMAGEAPI
SymGetLineFromAddrW(
    __in HANDLE hProcess,
    __in DWORD dwAddr,
    __out PDWORD pdwDisplacement,
    __out PIMAGEHLP_LINEW Line
);
#endif

BOOL
IMAGEAPI
SymGetLineFromName64(
    __in HANDLE hProcess,
    __in_opt PCSTR ModuleName,
    __in_opt PCSTR FileName,
    __in DWORD dwLineNumber,
    __out PLONG plDisplacement,
    __inout PIMAGEHLP_LINE64 Line
);

BOOL
IMAGEAPI
SymGetLineFromNameW64(
    __in HANDLE hProcess,
    __in_opt PCWSTR ModuleName,
    __in_opt PCWSTR FileName,
    __in DWORD dwLineNumber,
    __out PLONG plDisplacement,
    __inout PIMAGEHLP_LINEW64 Line
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetLineFromName SymGetLineFromName64
#else
BOOL
IMAGEAPI
SymGetLineFromName(
    __in HANDLE hProcess,
    __in_opt PCSTR ModuleName,
    __in_opt PCSTR FileName,
    __in DWORD dwLineNumber,
    __out PLONG plDisplacement,
    __inout PIMAGEHLP_LINE Line
);
#endif

BOOL
IMAGEAPI
SymGetLineNext64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINE64 Line
);

BOOL
IMAGEAPI
SymGetLineNextW64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINEW64 Line
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetLineNext SymGetLineNext64
#else
BOOL
IMAGEAPI
SymGetLineNext(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINE Line
);

BOOL
IMAGEAPI
SymGetLineNextW(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINEW Line
);
#endif

BOOL
IMAGEAPI
SymGetLinePrev64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINE64 Line
);

BOOL
IMAGEAPI
SymGetLinePrevW64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINEW64 Line
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetLinePrev SymGetLinePrev64
#else
BOOL
IMAGEAPI
SymGetLinePrev(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINE Line
);

BOOL
IMAGEAPI
SymGetLinePrevW(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINEW Line
);
#endif

ULONG
IMAGEAPI
SymGetFileLineOffsets64(
    __in HANDLE hProcess,
    __in_opt PCSTR ModuleName,
    __in PCSTR FileName,
    __out_ecount(BufferLines) PDWORD64 Buffer,
    __in ULONG BufferLines
);

BOOL
IMAGEAPI
SymMatchFileName(
    __in PCSTR FileName,
    __in PCSTR Match,
    __deref_opt_out PSTR* FileNameStop,
    __deref_opt_out PSTR* MatchStop
);

BOOL
IMAGEAPI
SymMatchFileNameW(
    __in PCWSTR FileName,
    __in PCWSTR Match,
    __deref_opt_out PWSTR* FileNameStop,
    __deref_opt_out PWSTR* MatchStop
);

BOOL
IMAGEAPI
SymGetSourceFile(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCSTR Params,
    __in PCSTR FileSpec,
    __out_ecount(Size) PSTR FilePath,
    __in DWORD Size
);

BOOL
IMAGEAPI
SymGetSourceFileW(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCWSTR Params,
    __in PCWSTR FileSpec,
    __out_ecount(Size) PWSTR FilePath,
    __in DWORD Size
);

BOOL
IMAGEAPI
SymGetSourceFileToken(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in PCSTR FileSpec,
    __deref_out PVOID* Token,
    __out DWORD* Size
);

BOOL
IMAGEAPI
SymGetSourceFileTokenW(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in PCWSTR FileSpec,
    __deref_out PVOID* Token,
    __out DWORD* Size
);

BOOL
IMAGEAPI
SymGetSourceFileFromToken(
    __in HANDLE hProcess,
    __in PVOID Token,
    __in_opt PCSTR Params,
    __out_ecount(Size) PSTR FilePath,
    __in DWORD Size
);

BOOL
IMAGEAPI
SymGetSourceFileFromTokenW(
    __in HANDLE hProcess,
    __in PVOID Token,
    __in_opt PCWSTR Params,
    __out_ecount(Size) PWSTR FilePath,
    __in DWORD Size
);

BOOL
IMAGEAPI
SymGetSourceVarFromToken(
    __in HANDLE hProcess,
    __in PVOID Token,
    __in_opt PCSTR Params,
    __in PCSTR VarName,
    __out_ecount(Size) PSTR Value,
    __in DWORD Size
);

BOOL
IMAGEAPI
SymGetSourceVarFromTokenW(
    __in HANDLE hProcess,
    __in PVOID Token,
    __in_opt PCWSTR Params,
    __in PCWSTR VarName,
    __out_ecount(Size) PWSTR Value,
    __in DWORD Size
);

typedef BOOL (CALLBACK* PENUMSOURCEFILETOKENSCALLBACK)(__in PVOID token,  __in size_t size);

BOOL
IMAGEAPI
SymEnumSourceFileTokens(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in PENUMSOURCEFILETOKENSCALLBACK Callback
);

BOOL
IMAGEAPI
SymInitialize(
    __in HANDLE hProcess,
    __in_opt PCSTR UserSearchPath,
    __in BOOL fInvadeProcess
);

BOOL
IMAGEAPI
SymInitializeW(
    __in HANDLE hProcess,
    __in_opt PCWSTR UserSearchPath,
    __in BOOL fInvadeProcess
);

BOOL
IMAGEAPI
SymGetSearchPath(
    __in HANDLE hProcess,
    __out_ecount(SearchPathLength) PSTR SearchPath,
    __in DWORD SearchPathLength
);

BOOL
IMAGEAPI
SymGetSearchPathW(
    __in HANDLE hProcess,
    __out_ecount(SearchPathLength) PWSTR SearchPath,
    __in DWORD SearchPathLength
);

BOOL
IMAGEAPI
SymSetSearchPath(
    __in HANDLE hProcess,
    __in_opt PCSTR SearchPath
);

BOOL
IMAGEAPI
SymSetSearchPathW(
    __in HANDLE hProcess,
    __in_opt PCWSTR SearchPath
);

#define SLMFLAG_VIRTUAL     0x1
#define SLMFLAG_ALT_INDEX   0x2
#define SLMFLAG_NO_SYMBOLS  0x4

DWORD64
IMAGEAPI
SymLoadModuleEx(
    __in HANDLE hProcess,
    __in_opt HANDLE hFile,
    __in_opt PCSTR ImageName,
    __in_opt PCSTR ModuleName,
    __in DWORD64 BaseOfDll,
    __in DWORD DllSize,
    __in_opt PMODLOAD_DATA Data,
    __in_opt DWORD Flags
);

DWORD64
IMAGEAPI
SymLoadModuleExW(
    __in HANDLE hProcess,
    __in_opt HANDLE hFile,
    __in_opt PCWSTR ImageName,
    __in_opt PCWSTR ModuleName,
    __in DWORD64 BaseOfDll,
    __in DWORD DllSize,
    __in_opt PMODLOAD_DATA Data,
    __in_opt DWORD Flags
);

BOOL
IMAGEAPI
SymUnloadModule64(
    __in HANDLE hProcess,
    __in DWORD64 BaseOfDll
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymUnloadModule SymUnloadModule64
#else
BOOL
IMAGEAPI
SymUnloadModule(
    __in HANDLE hProcess,
    __in DWORD BaseOfDll
);
#endif

BOOL
IMAGEAPI
SymUnDName64(
    __in PIMAGEHLP_SYMBOL64 sym,            // Symbol to undecorate
    __out_ecount(UnDecNameLength) PSTR UnDecName,   // Buffer to store undecorated name in
    __in DWORD UnDecNameLength              // Size of the buffer
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymUnDName SymUnDName64
#else
BOOL
IMAGEAPI
SymUnDName(
    __in PIMAGEHLP_SYMBOL sym,              // Symbol to undecorate
    __out_ecount(UnDecNameLength) PSTR UnDecName,   // Buffer to store undecorated name in
    __in DWORD UnDecNameLength              // Size of the buffer
);
#endif

BOOL
IMAGEAPI
SymRegisterCallback64(
    __in HANDLE hProcess,
    __in PSYMBOL_REGISTERED_CALLBACK64 CallbackFunction,
    __in ULONG64 UserContext
);

BOOL
IMAGEAPI
SymRegisterCallbackW64(
    __in HANDLE hProcess,
    __in PSYMBOL_REGISTERED_CALLBACK64 CallbackFunction,
    __in ULONG64 UserContext
);

BOOL
IMAGEAPI
SymRegisterFunctionEntryCallback64(
    __in HANDLE hProcess,
    __in PSYMBOL_FUNCENTRY_CALLBACK64 CallbackFunction,
    __in ULONG64 UserContext
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymRegisterCallback SymRegisterCallback64
#define SymRegisterFunctionEntryCallback SymRegisterFunctionEntryCallback64
#else
BOOL
IMAGEAPI
SymRegisterCallback(
    __in HANDLE hProcess,
    __in PSYMBOL_REGISTERED_CALLBACK CallbackFunction,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymRegisterFunctionEntryCallback(
    __in HANDLE hProcess,
    __in PSYMBOL_FUNCENTRY_CALLBACK CallbackFunction,
    __in_opt PVOID UserContext
);
#endif


typedef struct _IMAGEHLP_SYMBOL_SRC
{
    DWORD sizeofstruct;
    DWORD type;
    char  file[MAX_PATH];
} IMAGEHLP_SYMBOL_SRC, *PIMAGEHLP_SYMBOL_SRC;

typedef struct _MODULE_TYPE_INFO   // AKA TYPTYP
{
    USHORT      dataLength;
    USHORT      leaf;
    BYTE        data[1];
} MODULE_TYPE_INFO, *PMODULE_TYPE_INFO;

typedef struct _SYMBOL_INFO
{
    ULONG       SizeOfStruct;
    ULONG       TypeIndex;        // Type Index of symbol
    ULONG64     Reserved[2];
    ULONG       Index;
    ULONG       Size;
    ULONG64     ModBase;          // Base Address of module comtaining this symbol
    ULONG       Flags;
    ULONG64     Value;            // Value of symbol, ValuePresent should be 1
    ULONG64     Address;          // Address of symbol including base address of module
    ULONG       Register;         // register holding value or pointer to value
    ULONG       Scope;            // scope of the symbol
    ULONG       Tag;              // pdb classification
    ULONG       NameLen;          // Actual length of name
    ULONG       MaxNameLen;
    CHAR        Name[1];          // Name of symbol
} SYMBOL_INFO, *PSYMBOL_INFO;

typedef struct _SYMBOL_INFO_PACKAGE
{
    SYMBOL_INFO si;
    CHAR        name[MAX_SYM_NAME + 1];
} SYMBOL_INFO_PACKAGE, *PSYMBOL_INFO_PACKAGE;

typedef struct _SYMBOL_INFOW
{
    ULONG       SizeOfStruct;
    ULONG       TypeIndex;        // Type Index of symbol
    ULONG64     Reserved[2];
    ULONG       Index;
    ULONG       Size;
    ULONG64     ModBase;          // Base Address of module comtaining this symbol
    ULONG       Flags;
    ULONG64     Value;            // Value of symbol, ValuePresent should be 1
    ULONG64     Address;          // Address of symbol including base address of module
    ULONG       Register;         // register holding value or pointer to value
    ULONG       Scope;            // scope of the symbol
    ULONG       Tag;              // pdb classification
    ULONG       NameLen;          // Actual length of name
    ULONG       MaxNameLen;
    WCHAR       Name[1];          // Name of symbol
} SYMBOL_INFOW, *PSYMBOL_INFOW;

typedef struct _SYMBOL_INFO_PACKAGEW
{
    SYMBOL_INFOW si;
    WCHAR        name[MAX_SYM_NAME + 1];
} SYMBOL_INFO_PACKAGEW, *PSYMBOL_INFO_PACKAGEW;

typedef struct _IMAGEHLP_STACK_FRAME
{
    ULONG64 InstructionOffset;
    ULONG64 ReturnOffset;
    ULONG64 FrameOffset;
    ULONG64 StackOffset;
    ULONG64 BackingStoreOffset;
    ULONG64 FuncTableEntry;
    ULONG64 Params[4];
    ULONG64 Reserved[5];
    BOOL    Virtual;
    ULONG   Reserved2;
} IMAGEHLP_STACK_FRAME, *PIMAGEHLP_STACK_FRAME;

typedef VOID IMAGEHLP_CONTEXT, *PIMAGEHLP_CONTEXT;


BOOL
IMAGEAPI
SymSetContext(
    __in HANDLE hProcess,
    __in PIMAGEHLP_STACK_FRAME StackFrame,
    __in_opt PIMAGEHLP_CONTEXT Context
);

BOOL
IMAGEAPI
SymSetScopeFromAddr(
    __in HANDLE hProcess,
    __in ULONG64 Address
);

BOOL
IMAGEAPI
SymSetScopeFromIndex(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in DWORD Index
);

typedef BOOL
(CALLBACK* PSYM_ENUMPROCESSES_CALLBACK)(
    __in HANDLE hProcess,
    __in PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumProcesses(
    __in PSYM_ENUMPROCESSES_CALLBACK EnumProcessesCallback,
    __in PVOID UserContext
);

BOOL
IMAGEAPI
SymFromAddr(
    __in HANDLE hProcess,
    __in DWORD64 Address,
    __out_opt PDWORD64 Displacement,
    __inout PSYMBOL_INFO Symbol
);

BOOL
IMAGEAPI
SymFromAddrW(
    __in HANDLE hProcess,
    __in DWORD64 Address,
    __out_opt PDWORD64 Displacement,
    __inout PSYMBOL_INFOW Symbol
);

BOOL
IMAGEAPI
SymFromToken(
    __in HANDLE hProcess,
    __in DWORD64 Base,
    __in DWORD Token,
    __inout PSYMBOL_INFO Symbol
);

BOOL
IMAGEAPI
SymFromTokenW(
    __in HANDLE hProcess,
    __in DWORD64 Base,
    __in DWORD Token,
    __inout PSYMBOL_INFOW Symbol
);

BOOL
IMAGEAPI
SymNext(
    __in HANDLE hProcess,
    __inout PSYMBOL_INFO si
);

BOOL
IMAGEAPI
SymNextW(
    __in HANDLE hProcess,
    __inout PSYMBOL_INFOW siw
);

BOOL
IMAGEAPI
SymPrev(
    __in HANDLE hProcess,
    __inout PSYMBOL_INFO si
);

BOOL
IMAGEAPI
SymPrevW(
    __in HANDLE hProcess,
    __inout PSYMBOL_INFOW siw
);

// While SymFromName will provide a symbol from a name,
// SymEnumSymbols can provide the same matching information
// for ALL symbols with a matching name, even regular
// expressions.  That way you can search across modules
// and differentiate between identically named symbols.

BOOL
IMAGEAPI
SymFromName(
    __in HANDLE hProcess,
    __in PCSTR Name,
    __inout PSYMBOL_INFO Symbol
);

BOOL
IMAGEAPI
SymFromNameW(
    __in HANDLE hProcess,
    __in PCWSTR Name,
    __inout PSYMBOL_INFOW Symbol
);

typedef BOOL
(CALLBACK* PSYM_ENUMERATESYMBOLS_CALLBACK)(
    __in PSYMBOL_INFO pSymInfo,
    __in ULONG SymbolSize,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumSymbols(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt PCSTR Mask,
    __in PSYM_ENUMERATESYMBOLS_CALLBACK EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYM_ENUMERATESYMBOLS_CALLBACKW)(
    __in PSYMBOL_INFOW pSymInfo,
    __in ULONG SymbolSize,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumSymbolsW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt PCWSTR Mask,
    __in PSYM_ENUMERATESYMBOLS_CALLBACKW EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumSymbolsForAddr(
    __in HANDLE hProcess,
    __in DWORD64 Address,
    __in PSYM_ENUMERATESYMBOLS_CALLBACK EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumSymbolsForAddrW(
    __in HANDLE hProcess,
    __in DWORD64 Address,
    __in PSYM_ENUMERATESYMBOLS_CALLBACKW EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

#define SYMSEARCH_MASKOBJS      0x01    // used internally to implement other APIs
#define SYMSEARCH_RECURSE       0X02    // recurse scopes
#define SYMSEARCH_GLOBALSONLY   0X04    // search only for global symbols
#define SYMSEARCH_ALLITEMS      0X08    // search for everything in the pdb, not just normal scoped symbols

BOOL
IMAGEAPI
SymSearch(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt DWORD Index,
    __in_opt DWORD SymTag,
    __in_opt PCSTR Mask,
    __in_opt DWORD64 Address,
    __in PSYM_ENUMERATESYMBOLS_CALLBACK EnumSymbolsCallback,
    __in_opt PVOID UserContext,
    __in DWORD Options
);

BOOL
IMAGEAPI
SymSearchW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt DWORD Index,
    __in_opt DWORD SymTag,
    __in_opt PCWSTR Mask,
    __in_opt DWORD64 Address,
    __in PSYM_ENUMERATESYMBOLS_CALLBACKW EnumSymbolsCallback,
    __in_opt PVOID UserContext,
    __in DWORD Options
);

BOOL
IMAGEAPI
SymGetScope(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in DWORD Index,
    __inout PSYMBOL_INFO Symbol
);

BOOL
IMAGEAPI
SymGetScopeW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in DWORD Index,
    __inout PSYMBOL_INFOW Symbol
);

BOOL
IMAGEAPI
SymFromIndex(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in DWORD Index,
    __inout PSYMBOL_INFO Symbol
);

BOOL
IMAGEAPI
SymFromIndexW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in DWORD Index,
    __inout PSYMBOL_INFOW Symbol
);

typedef enum _IMAGEHLP_SYMBOL_TYPE_INFO
{
    TI_GET_SYMTAG,
    TI_GET_SYMNAME,
    TI_GET_LENGTH,
    TI_GET_TYPE,
    TI_GET_TYPEID,
    TI_GET_BASETYPE,
    TI_GET_ARRAYINDEXTYPEID,
    TI_FINDCHILDREN,
    TI_GET_DATAKIND,
    TI_GET_ADDRESSOFFSET,
    TI_GET_OFFSET,
    TI_GET_VALUE,
    TI_GET_COUNT,
    TI_GET_CHILDRENCOUNT,
    TI_GET_BITPOSITION,
    TI_GET_VIRTUALBASECLASS,
    TI_GET_VIRTUALTABLESHAPEID,
    TI_GET_VIRTUALBASEPOINTEROFFSET,
    TI_GET_CLASSPARENTID,
    TI_GET_NESTED,
    TI_GET_SYMINDEX,
    TI_GET_LEXICALPARENT,
    TI_GET_ADDRESS,
    TI_GET_THISADJUST,
    TI_GET_UDTKIND,
    TI_IS_EQUIV_TO,
    TI_GET_CALLING_CONVENTION,
    TI_IS_CLOSE_EQUIV_TO,
    TI_GTIEX_REQS_VALID,
    TI_GET_VIRTUALBASEOFFSET,
    TI_GET_VIRTUALBASEDISPINDEX,
    TI_GET_IS_REFERENCE,
    TI_GET_INDIRECTVIRTUALBASECLASS,
    IMAGEHLP_SYMBOL_TYPE_INFO_MAX,
} IMAGEHLP_SYMBOL_TYPE_INFO;

typedef struct _TI_FINDCHILDREN_PARAMS
{
    ULONG Count;
    ULONG Start;
    ULONG ChildId[1];
} TI_FINDCHILDREN_PARAMS;

BOOL
IMAGEAPI
SymGetTypeInfo(
    __in HANDLE hProcess,
    __in DWORD64 ModBase,
    __in ULONG TypeId,
    __in IMAGEHLP_SYMBOL_TYPE_INFO GetType,
    __out PVOID pInfo
);

#define IMAGEHLP_GET_TYPE_INFO_UNCACHED 0x00000001
#define IMAGEHLP_GET_TYPE_INFO_CHILDREN 0x00000002

typedef struct _IMAGEHLP_GET_TYPE_INFO_PARAMS
{
    IN  ULONG    SizeOfStruct;
    IN  ULONG    Flags;
    IN  ULONG    NumIds;
    IN  PULONG   TypeIds;
    IN  ULONG64  TagFilter;
    IN  ULONG    NumReqs;
    IN  IMAGEHLP_SYMBOL_TYPE_INFO* ReqKinds;
    IN  PULONG_PTR ReqOffsets;
    IN  PULONG   ReqSizes;
    IN  ULONG_PTR ReqStride;
    IN  ULONG_PTR BufferSize;
    OUT PVOID    Buffer;
    OUT ULONG    EntriesMatched;
    OUT ULONG    EntriesFilled;
    OUT ULONG64  TagsFound;
    OUT ULONG64  AllReqsValid;
    IN  ULONG    NumReqsValid;
    OUT PULONG64 ReqsValid OPTIONAL;
} IMAGEHLP_GET_TYPE_INFO_PARAMS, *PIMAGEHLP_GET_TYPE_INFO_PARAMS;

BOOL
IMAGEAPI
SymGetTypeInfoEx(
    __in HANDLE hProcess,
    __in DWORD64 ModBase,
    __inout PIMAGEHLP_GET_TYPE_INFO_PARAMS Params
);

BOOL
IMAGEAPI
SymEnumTypes(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PSYM_ENUMERATESYMBOLS_CALLBACK EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumTypesW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PSYM_ENUMERATESYMBOLS_CALLBACKW EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumTypesByName(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt PCSTR mask,
    __in PSYM_ENUMERATESYMBOLS_CALLBACK EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumTypesByNameW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt PCWSTR mask,
    __in PSYM_ENUMERATESYMBOLS_CALLBACKW EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymGetTypeFromName(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PCSTR Name,
    __inout PSYMBOL_INFO Symbol
);

BOOL
IMAGEAPI
SymGetTypeFromNameW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PCWSTR Name,
    __inout PSYMBOL_INFOW Symbol
);

BOOL
IMAGEAPI
SymAddSymbol(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PCSTR Name,
    __in DWORD64 Address,
    __in DWORD Size,
    __in DWORD Flags
);

BOOL
IMAGEAPI
SymAddSymbolW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PCWSTR Name,
    __in DWORD64 Address,
    __in DWORD Size,
    __in DWORD Flags
);

BOOL
IMAGEAPI
SymDeleteSymbol(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt PCSTR Name,
    __in DWORD64 Address,
    __in DWORD Flags
);

BOOL
IMAGEAPI
SymDeleteSymbolW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt PCWSTR Name,
    __in DWORD64 Address,
    __in DWORD Flags
);

BOOL
IMAGEAPI
SymRefreshModuleList(
    __in HANDLE hProcess
);

BOOL
IMAGEAPI
SymAddSourceStream(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCSTR StreamFile,
    __in_bcount_opt(Size) PBYTE Buffer,
    __in size_t Size
);

typedef BOOL (WINAPI* SYMADDSOURCESTREAM)(HANDLE, ULONG64, PCSTR, PBYTE, size_t);

BOOL
IMAGEAPI
SymAddSourceStreamA(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCSTR StreamFile,
    __in_bcount_opt(Size) PBYTE Buffer,
    __in size_t Size
);

typedef BOOL (WINAPI* SYMADDSOURCESTREAMA)(HANDLE, ULONG64, PCSTR, PBYTE, size_t);

BOOL
IMAGEAPI
SymAddSourceStreamW(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCWSTR FileSpec,
    __in_bcount_opt(Size) PBYTE Buffer,
    __in size_t Size
);

BOOL
IMAGEAPI
SymSrvIsStoreW(
    __in_opt HANDLE hProcess,
    __in PCWSTR path
);

BOOL
IMAGEAPI
SymSrvIsStore(
    __in_opt HANDLE hProcess,
    __in PCSTR path
);

PCSTR
IMAGEAPI
SymSrvDeltaName(
    __in HANDLE hProcess,
    __in_opt PCSTR SymPath,
    __in PCSTR Type,
    __in PCSTR File1,
    __in PCSTR File2
);

PCWSTR
IMAGEAPI
SymSrvDeltaNameW(
    __in HANDLE hProcess,
    __in_opt PCWSTR SymPath,
    __in PCWSTR Type,
    __in PCWSTR File1,
    __in PCWSTR File2
);

PCSTR
IMAGEAPI
SymSrvGetSupplement(
    __in HANDLE hProcess,
    __in_opt PCSTR SymPath,
    __in PCSTR Node,
    __in PCSTR File
);

PCWSTR
IMAGEAPI
SymSrvGetSupplementW(
    __in HANDLE hProcess,
    __in_opt PCWSTR SymPath,
    __in PCWSTR Node,
    __in PCWSTR File
);

BOOL
IMAGEAPI
SymSrvGetFileIndexes(
    __in PCSTR File,
    __out GUID* Id,
    __out PDWORD Val1,
    __out_opt PDWORD Val2,
    __in DWORD Flags
);

BOOL
IMAGEAPI
SymSrvGetFileIndexesW(
    __in PCWSTR File,
    __out GUID* Id,
    __out PDWORD Val1,
    __out_opt PDWORD Val2,
    __in DWORD Flags
);

BOOL
IMAGEAPI
SymSrvGetFileIndexStringW(
    __in HANDLE hProcess,
    __in_opt PCWSTR SrvPath,
    __in PCWSTR File,
    __out_ecount(Size) PWSTR Index,
    __in size_t Size,
    __in DWORD Flags
);

BOOL
IMAGEAPI
SymSrvGetFileIndexString(
    __in HANDLE hProcess,
    __in_opt PCSTR SrvPath,
    __in PCSTR File,
    __out_ecount(Size) PSTR Index,
    __in size_t Size,
    __in DWORD Flags
);

typedef struct
{
    DWORD sizeofstruct;
    char file[MAX_PATH + 1];
    BOOL  stripped;
    DWORD timestamp;
    DWORD size;
    char dbgfile[MAX_PATH + 1];
    char pdbfile[MAX_PATH + 1];
    GUID  guid;
    DWORD sig;
    DWORD age;
} SYMSRV_INDEX_INFO, *PSYMSRV_INDEX_INFO;

typedef struct
{
    DWORD sizeofstruct;
    WCHAR file[MAX_PATH + 1];
    BOOL  stripped;
    DWORD timestamp;
    DWORD size;
    WCHAR dbgfile[MAX_PATH + 1];
    WCHAR pdbfile[MAX_PATH + 1];
    GUID  guid;
    DWORD sig;
    DWORD age;
} SYMSRV_INDEX_INFOW, *PSYMSRV_INDEX_INFOW;

BOOL
IMAGEAPI
SymSrvGetFileIndexInfo(
    __in PCSTR File,
    __out PSYMSRV_INDEX_INFO Info,
    __in DWORD Flags
);

BOOL
IMAGEAPI
SymSrvGetFileIndexInfoW(
    __in PCWSTR File,
    __out PSYMSRV_INDEX_INFOW Info,
    __in DWORD Flags
);

PCSTR
IMAGEAPI
SymSrvStoreSupplement(
    __in HANDLE hProcess,
    __in_opt PCSTR SrvPath,
    __in PCSTR Node,
    __in PCSTR File,
    __in DWORD Flags
);

PCWSTR
IMAGEAPI
SymSrvStoreSupplementW(
    __in HANDLE hProcess,
    __in_opt PCWSTR SymPath,
    __in PCWSTR Node,
    __in PCWSTR File,
    __in DWORD Flags
);

PCSTR
IMAGEAPI
SymSrvStoreFile(
    __in HANDLE hProcess,
    __in_opt PCSTR SrvPath,
    __in PCSTR File,
    __in DWORD Flags
);

PCWSTR
IMAGEAPI
SymSrvStoreFileW(
    __in HANDLE hProcess,
    __in_opt PCWSTR SrvPath,
    __in PCWSTR File,
    __in DWORD Flags
);

// used by SymGetSymbolFile's "Type" parameter

enum
{
    sfImage = 0,
    sfDbg,
    sfPdb,
    sfMpd,
    sfMax
};

BOOL
IMAGEAPI
SymGetSymbolFile(
    __in_opt HANDLE hProcess,
    __in_opt PCSTR SymPath,
    __in PCSTR ImageFile,
    __in DWORD Type,
    __out_ecount(cSymbolFile) PSTR SymbolFile,
    __in size_t cSymbolFile,
    __out_ecount(cDbgFile) PSTR DbgFile,
    __in size_t cDbgFile
);

BOOL
IMAGEAPI
SymGetSymbolFileW(
    __in_opt HANDLE hProcess,
    __in_opt PCWSTR SymPath,
    __in PCWSTR ImageFile,
    __in DWORD Type,
    __out_ecount(cSymbolFile) PWSTR SymbolFile,
    __in size_t cSymbolFile,
    __out_ecount(cDbgFile) PWSTR DbgFile,
    __in size_t cDbgFile
);

//
// Full user-mode dump creation.
//

typedef BOOL (WINAPI* PDBGHELP_CREATE_USER_DUMP_CALLBACK)(
    __in DWORD DataType,
    __in PVOID* Data,
    __out LPDWORD DataLength,
    __in_opt PVOID UserData
);

BOOL
WINAPI
DbgHelpCreateUserDump(
    __in_opt LPCSTR FileName,
    __in PDBGHELP_CREATE_USER_DUMP_CALLBACK Callback,
    __in_opt PVOID UserData
);

BOOL
WINAPI
DbgHelpCreateUserDumpW(
    __in_opt LPCWSTR FileName,
    __in PDBGHELP_CREATE_USER_DUMP_CALLBACK Callback,
    __in_opt PVOID UserData
);

// -----------------------------------------------------------------
// The following 4 legacy APIs are fully supported, but newer
// ones are recommended.  SymFromName and SymFromAddr provide
// much more detailed info on the returned symbol.

BOOL
IMAGEAPI
SymGetSymFromAddr64(
    __in HANDLE hProcess,
    __in DWORD64 qwAddr,
    __out_opt PDWORD64 pdwDisplacement,
    __inout PIMAGEHLP_SYMBOL64  Symbol
);


#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymFromAddr SymGetSymFromAddr64
#else
BOOL
IMAGEAPI
SymGetSymFromAddr(
    __in HANDLE hProcess,
    __in DWORD dwAddr,
    __out_opt PDWORD pdwDisplacement,
    __inout PIMAGEHLP_SYMBOL Symbol
);
#endif

// While following two APIs will provide a symbol from a name,
// SymEnumSymbols can provide the same matching information
// for ALL symbols with a matching name, even regular
// expressions.  That way you can search across modules
// and differentiate between identically named symbols.

BOOL
IMAGEAPI
SymGetSymFromName64(
    __in HANDLE hProcess,
    __in PCSTR Name,
    __inout PIMAGEHLP_SYMBOL64 Symbol
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymFromName SymGetSymFromName64
#else
BOOL
IMAGEAPI
SymGetSymFromName(
    __in HANDLE hProcess,
    __in PCSTR Name,
    __inout PIMAGEHLP_SYMBOL Symbol
);
#endif


// Symbol server exports

typedef BOOL (WINAPI* PSYMBOLSERVERPROC)(PCSTR, PCSTR, PVOID, DWORD, DWORD, PSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERPROCA)(PCSTR, PCSTR, PVOID, DWORD, DWORD, PSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERPROCW)(PCWSTR, PCWSTR, PVOID, DWORD, DWORD, PWSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERBYINDEXPROC)(PCSTR, PCSTR, PCSTR, PSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERBYINDEXPROCA)(PCSTR, PCSTR, PCSTR, PSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERBYINDEXPROCW)(PCWSTR, PCWSTR, PCWSTR, PWSTR);
typedef BOOL (WINAPI* PSYMBOLSERVEROPENPROC)(VOID);
typedef BOOL (WINAPI* PSYMBOLSERVERCLOSEPROC)(VOID);
typedef BOOL (WINAPI* PSYMBOLSERVERSETOPTIONSPROC)(UINT_PTR, ULONG64);
typedef BOOL (WINAPI* PSYMBOLSERVERSETOPTIONSWPROC)(UINT_PTR, ULONG64);
typedef BOOL (CALLBACK WINAPI* PSYMBOLSERVERCALLBACKPROC)(UINT_PTR action, ULONG64 data, ULONG64 context);
typedef UINT_PTR(WINAPI* PSYMBOLSERVERGETOPTIONSPROC)();
typedef BOOL (WINAPI* PSYMBOLSERVERPINGPROC)(PCSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERPINGPROCA)(PCSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERPINGPROCW)(PCWSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERGETVERSION)(LPAPI_VERSION);
typedef BOOL (WINAPI* PSYMBOLSERVERDELTANAME)(PCSTR, PVOID, DWORD, DWORD, PVOID, DWORD, DWORD, PSTR, size_t);
typedef BOOL (WINAPI* PSYMBOLSERVERDELTANAMEW)(PCWSTR, PVOID, DWORD, DWORD, PVOID, DWORD, DWORD, PWSTR, size_t);
typedef BOOL (WINAPI* PSYMBOLSERVERGETSUPPLEMENT)(PCSTR, PCSTR, PCSTR, PSTR, size_t);
typedef BOOL (WINAPI* PSYMBOLSERVERGETSUPPLEMENTW)(PCWSTR, PCWSTR, PCWSTR, PWSTR, size_t);
typedef BOOL (WINAPI* PSYMBOLSERVERSTORESUPPLEMENT)(PCSTR, PCSTR, PCSTR, PSTR, size_t, DWORD);
typedef BOOL (WINAPI* PSYMBOLSERVERSTORESUPPLEMENTW)(PCWSTR, PCWSTR, PCWSTR, PWSTR, size_t, DWORD);
typedef BOOL (WINAPI* PSYMBOLSERVERGETINDEXSTRING)(PVOID, DWORD, DWORD, PSTR, size_t);
typedef BOOL (WINAPI* PSYMBOLSERVERGETINDEXSTRINGW)(PVOID, DWORD, DWORD, PWSTR, size_t);
typedef BOOL (WINAPI* PSYMBOLSERVERSTOREFILE)(PCSTR, PCSTR, PVOID, DWORD, DWORD, PSTR, size_t, DWORD);
typedef BOOL (WINAPI* PSYMBOLSERVERSTOREFILEW)(PCWSTR, PCWSTR, PVOID, DWORD, DWORD, PWSTR, size_t, DWORD);
typedef BOOL (WINAPI* PSYMBOLSERVERISSTORE)(PCSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERISSTOREW)(PCWSTR);
typedef DWORD (WINAPI* PSYMBOLSERVERVERSION)();
typedef BOOL (CALLBACK WINAPI* PSYMBOLSERVERMESSAGEPROC)(UINT_PTR action, ULONG64 data, ULONG64 context);

#define SYMSRV_VERSION              2

#define SSRVOPT_CALLBACK            0x00000001
#define SSRVOPT_DWORD               0x00000002
#define SSRVOPT_DWORDPTR            0x00000004
#define SSRVOPT_GUIDPTR             0x00000008
#define SSRVOPT_OLDGUIDPTR          0x00000010
#define SSRVOPT_UNATTENDED          0x00000020
#define SSRVOPT_NOCOPY              0x00000040
#define SSRVOPT_GETPATH             0x00000040
#define SSRVOPT_PARENTWIN           0x00000080
#define SSRVOPT_PARAMTYPE           0x00000100
#define SSRVOPT_SECURE              0x00000200
#define SSRVOPT_TRACE               0x00000400
#define SSRVOPT_SETCONTEXT          0x00000800
#define SSRVOPT_PROXY               0x00001000
#define SSRVOPT_DOWNSTREAM_STORE    0x00002000
#define SSRVOPT_OVERWRITE           0x00004000
#define SSRVOPT_RESETTOU            0x00008000
#define SSRVOPT_CALLBACKW           0x00010000
#define SSRVOPT_FLAT_DEFAULT_STORE  0x00020000
#define SSRVOPT_PROXYW              0x00040000
#define SSRVOPT_MESSAGE             0x00080000
#define SSRVOPT_SERVICE             0x00100000   // deprecated
#define SSRVOPT_FAVOR_COMPRESSED    0x00200000
#define SSRVOPT_STRING              0x00400000
#define SSRVOPT_WINHTTP             0x00800000
#define SSRVOPT_WININET             0x01000000

#define SSRVOPT_MAX                 0x0100000

#define SSRVOPT_RESET               ((ULONG_PTR)-1)


#define NUM_SSRVOPTS                30

#define SSRVACTION_TRACE        1
#define SSRVACTION_QUERYCANCEL  2
#define SSRVACTION_EVENT        3
#define SSRVACTION_EVENTW       4
#define SSRVACTION_SIZE         5

#define SYMSTOREOPT_COMPRESS        0x01
#define SYMSTOREOPT_OVERWRITE       0x02
#define SYMSTOREOPT_RETURNINDEX     0x04
#define SYMSTOREOPT_POINTER         0x08
#define SYMSTOREOPT_ALT_INDEX       0x10
#define SYMSTOREOPT_UNICODE         0x20
#define SYMSTOREOPT_PASS_IF_EXISTS  0x40

#ifdef DBGHELP_TRANSLATE_TCHAR
#define SymInitialize                     SymInitializeW
#define SymAddSymbol                      SymAddSymbolW
#define SymDeleteSymbol                   SymDeleteSymbolW
#define SearchTreeForFile                 SearchTreeForFileW
#define UnDecorateSymbolName              UnDecorateSymbolNameW
#define SymGetLineFromName64              SymGetLineFromNameW64
#define SymGetLineFromAddr64              SymGetLineFromAddrW64
#define SymGetLineNext64                  SymGetLineNextW64
#define SymGetLinePrev64                  SymGetLinePrevW64
#define SymFromName                       SymFromNameW
#define SymFindExecutableImage            SymFindExecutableImageW
#define FindExecutableImageEx             FindExecutableImageExW
#define SymSearch                         SymSearchW
#define SymEnumLines                      SymEnumLinesW
#define SymEnumSourceLines                SymEnumSourceLinesW
#define SymGetTypeFromName                SymGetTypeFromNameW
#define SymEnumSymbolsForAddr             SymEnumSymbolsForAddrW
#define SymFromAddr                       SymFromAddrW
#define SymMatchString                    SymMatchStringW
#define SymEnumSourceFiles                SymEnumSourceFilesW
#define SymEnumSymbols                    SymEnumSymbolsW
#define SymLoadModuleEx                   SymLoadModuleExW
#define SymSetSearchPath                  SymSetSearchPathW
#define SymGetSearchPath                  SymGetSearchPathW
#define EnumDirTree                       EnumDirTreeW
#define SymFromToken                      SymFromTokenW
#define SymFromIndex                      SymFromIndexW
#define SymGetScope                       SymGetScopeW
#define SymNext                           SymNextW
#define SymPrev                           SymPrevW
#define SymEnumTypes                      SymEnumTypesW
#define SymEnumTypesByName                SymEnumTypesByNameW
#define SymRegisterCallback64             SymRegisterCallbackW64
#define SymFindDebugInfoFile              SymFindDebugInfoFileW
#define FindDebugInfoFileEx               FindDebugInfoFileExW
#define SymFindFileInPath                 SymFindFileInPathW
#define SymEnumerateModules64             SymEnumerateModulesW64
#define SymSetHomeDirectory               SymSetHomeDirectoryW
#define SymGetHomeDirectory               SymGetHomeDirectoryW
#define SymGetSourceFile                  SymGetSourceFileW
#define SymGetSourceFileToken             SymGetSourceFileTokenW
#define SymGetSourceFileFromToken         SymGetSourceFileFromTokenW
#define SymGetSourceVarFromToken          SymGetSourceVarFromTokenW
#define SymGetSourceFileToken             SymGetSourceFileTokenW
#define SymGetFileLineOffsets64           SymGetFileLineOffsetsW64
#define SymFindFileInPath                 SymFindFileInPathW
#define SymMatchFileName                  SymMatchFileNameW
#define SymGetSourceFileFromToken         SymGetSourceFileFromTokenW
#define SymGetSourceVarFromToken          SymGetSourceVarFromTokenW
#define SymGetModuleInfo64                SymGetModuleInfoW64
#define SymSrvIsStore                     SymSrvIsStoreW
#define SymSrvDeltaName                   SymSrvDeltaNameW
#define SymSrvGetSupplement               SymSrvGetSupplementW
#define SymSrvStoreSupplement             SymSrvStoreSupplementW
#define SymSrvGetFileIndexes              SymSrvGetFileIndexes
#define SymSrvGetFileIndexString          SymSrvGetFileIndexStringW
#define SymSrvStoreFile                   SymSrvStoreFileW
#define SymGetSymbolFile                  SymGetSymbolFileW
#define EnumerateLoadedModules64          EnumerateLoadedModulesW64
#define EnumerateLoadedModulesEx          EnumerateLoadedModulesExW
#define SymSrvGetFileIndexInfo            SymSrvGetFileIndexInfoW

#define IMAGEHLP_LINE64                   IMAGEHLP_LINEW64
#define PIMAGEHLP_LINE64                  PIMAGEHLP_LINEW64
#define SYMBOL_INFO                       SYMBOL_INFOW
#define PSYMBOL_INFO                      PSYMBOL_INFOW
#define SYMBOL_INFO_PACKAGE               SYMBOL_INFO_PACKAGEW
#define PSYMBOL_INFO_PACKAGE              PSYMBOL_INFO_PACKAGEW
#define FIND_EXE_FILE_CALLBACK            FIND_EXE_FILE_CALLBACKW
#define PFIND_EXE_FILE_CALLBACK           PFIND_EXE_FILE_CALLBACKW
#define SYM_ENUMERATESYMBOLS_CALLBACK     SYM_ENUMERATESYMBOLS_CALLBACKW
#define PSYM_ENUMERATESYMBOLS_CALLBACK    PSYM_ENUMERATESYMBOLS_CALLBACKW
#define SRCCODEINFO                       SRCCODEINFOW
#define PSRCCODEINFO                      PSRCCODEINFOW
#define SOURCEFILE                        SOURCEFILEW
#define PSOURCEFILE                       PSOURCEFILEW
#define SYM_ENUMSOURECFILES_CALLBACK      SYM_ENUMSOURCEFILES_CALLBACKW
#define PSYM_ENUMSOURCEFILES_CALLBACK     PSYM_ENUMSOURECFILES_CALLBACKW
#define IMAGEHLP_CBA_EVENT                IMAGEHLP_CBA_EVENTW
#define PIMAGEHLP_CBA_EVENT               PIMAGEHLP_CBA_EVENTW
#define PENUMDIRTREE_CALLBACK             PENUMDIRTREE_CALLBACKW
#define IMAGEHLP_DEFERRED_SYMBOL_LOAD64   IMAGEHLP_DEFERRED_SYMBOL_LOADW64
#define PIMAGEHLP_DEFERRED_SYMBOL_LOAD64  PIMAGEHLP_DEFERRED_SYMBOL_LOADW64
#define PFIND_DEBUG_FILE_CALLBACK         PFIND_DEBUG_FILE_CALLBACKW
#define PFINDFILEINPATHCALLBACK           PFINDFILEINPATHCALLBACKW
#define IMAGEHLP_MODULE64                 IMAGEHLP_MODULEW64
#define PIMAGEHLP_MODULE64                PIMAGEHLP_MODULEW64
#define SYMSRV_INDEX_INFO                 SYMSRV_INDEX_INFOW
#define PSYMSRV_INDEX_INFO                PSYMSRV_INDEX_INFOW

#define PSYMBOLSERVERPROC                 PSYMBOLSERVERPROCW
#define PSYMBOLSERVERPINGPROC             PSYMBOLSERVERPINGPROCW
#endif

// -----------------------------------------------------------------
// The following APIs exist only for backwards compatibility
// with a pre-release version documented in an MSDN release.

// You should use SymFindFileInPath if you want to maintain
// future compatibility.

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
FindFileInPath(
    __in HANDLE hprocess,
    __in PCSTR SearchPath,
    __in PCSTR FileName,
    __in PVOID id,
    __in DWORD two,
    __in DWORD three,
    __in DWORD flags,
    __out_ecount(MAX_PATH + 1) PSTR FilePath
);

// You should use SymFindFileInPath if you want to maintain
// future compatibility.

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
FindFileInSearchPath(
    __in HANDLE hprocess,
    __in PCSTR SearchPath,
    __in PCSTR FileName,
    __in DWORD one,
    __in DWORD two,
    __in DWORD three,
    __out_ecount(MAX_PATH + 1) PSTR FilePath
);

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
SymEnumSym(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PSYM_ENUMERATESYMBOLS_CALLBACK EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
SymEnumerateSymbols64(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PSYM_ENUMSYMBOLS_CALLBACK64 EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
SymEnumerateSymbolsW64(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PSYM_ENUMSYMBOLS_CALLBACK64W EnumSymbolsCallback,
    __in_opt PVOID UserContext
);


#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymEnumerateSymbols SymEnumerateSymbols64
#define SymEnumerateSymbolsW SymEnumerateSymbolsW64
#else
DBHLP_DEPRECIATED
BOOL
IMAGEAPI
SymEnumerateSymbols(
    __in HANDLE hProcess,
    __in ULONG BaseOfDll,
    __in PSYM_ENUMSYMBOLS_CALLBACK EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
SymEnumerateSymbolsW(
    __in HANDLE hProcess,
    __in ULONG BaseOfDll,
    __in PSYM_ENUMSYMBOLS_CALLBACKW EnumSymbolsCallback,
    __in_opt PVOID UserContext
);
#endif

// use SymLoadModuleEx

DWORD64
IMAGEAPI
SymLoadModule64(
    __in HANDLE hProcess,
    __in_opt HANDLE hFile,
    __in_opt PCSTR ImageName,
    __in_opt PCSTR ModuleName,
    __in DWORD64 BaseOfDll,
    __in DWORD SizeOfDll
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymLoadModule SymLoadModule64
#else
DWORD
IMAGEAPI
SymLoadModule(
    __in HANDLE hProcess,
    __in_opt HANDLE hFile,
    __in_opt PCSTR ImageName,
    __in_opt PCSTR ModuleName,
    __in DWORD BaseOfDll,
    __in DWORD SizeOfDll
);
#endif

BOOL
IMAGEAPI
SymGetSymNext64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOL64 Symbol
);

BOOL
IMAGEAPI
SymGetSymNextW64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOLW64 Symbol
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymNext SymGetSymNext64
#define SymGetSymNextW SymGetSymNextW64
#else
BOOL
IMAGEAPI
SymGetSymNext(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOL Symbol
);

BOOL
IMAGEAPI
SymGetSymNextW(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOLW Symbol
);
#endif

BOOL
IMAGEAPI
SymGetSymPrev64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOL64 Symbol
);

BOOL
IMAGEAPI
SymGetSymPrevW64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOLW64 Symbol
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymPrev SymGetSymPrev64
#define SymGetSymPrevW SymGetSymPrevW64
#else
BOOL
IMAGEAPI
SymGetSymPrev(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOL Symbol
);

BOOL
IMAGEAPI
SymGetSymPrevW(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOLW Symbol
);
#endif


// These values should not be used.
// They have been replaced by SYMFLAG_ values.

#define SYMF_OMAP_GENERATED   0x00000001
#define SYMF_OMAP_MODIFIED    0x00000002
#define SYMF_REGISTER         0x00000008
#define SYMF_REGREL           0x00000010
#define SYMF_FRAMEREL         0x00000020
#define SYMF_PARAMETER        0x00000040
#define SYMF_LOCAL            0x00000080
#define SYMF_CONSTANT         0x00000100
#define SYMF_EXPORT           0x00000200
#define SYMF_FORWARDER        0x00000400
#define SYMF_FUNCTION         0x00000800
#define SYMF_VIRTUAL          0x00001000
#define SYMF_THUNK            0x00002000
#define SYMF_TLSREL           0x00004000

// These values should also not be used.
// They have been replaced by SYMFLAG_ values.

#define IMAGEHLP_SYMBOL_INFO_VALUEPRESENT          1
#define IMAGEHLP_SYMBOL_INFO_REGISTER              SYMF_REGISTER        // 0x0008
#define IMAGEHLP_SYMBOL_INFO_REGRELATIVE           SYMF_REGREL          // 0x0010
#define IMAGEHLP_SYMBOL_INFO_FRAMERELATIVE         SYMF_FRAMEREL        // 0x0020
#define IMAGEHLP_SYMBOL_INFO_PARAMETER             SYMF_PARAMETER       // 0x0040
#define IMAGEHLP_SYMBOL_INFO_LOCAL                 SYMF_LOCAL           // 0x0080
#define IMAGEHLP_SYMBOL_INFO_CONSTANT              SYMF_CONSTANT        // 0x0100
#define IMAGEHLP_SYMBOL_FUNCTION                   SYMF_FUNCTION        // 0x0800
#define IMAGEHLP_SYMBOL_VIRTUAL                    SYMF_VIRTUAL         // 0x1000
#define IMAGEHLP_SYMBOL_THUNK                      SYMF_THUNK           // 0x2000
#define IMAGEHLP_SYMBOL_INFO_TLSRELATIVE           SYMF_TLSREL          // 0x4000

#pragma pack(pop)


#pragma pack(push,4)

#define MINIDUMP_SIGNATURE ('PMDM')
#define MINIDUMP_VERSION   (42899)
typedef DWORD RVA;
typedef ULONG64 RVA64;

typedef struct _MINIDUMP_LOCATION_DESCRIPTOR
{
    ULONG32 DataSize;
    RVA Rva;
} MINIDUMP_LOCATION_DESCRIPTOR;

typedef struct _MINIDUMP_LOCATION_DESCRIPTOR64
{
    ULONG64 DataSize;
    RVA64 Rva;
} MINIDUMP_LOCATION_DESCRIPTOR64;


typedef struct _MINIDUMP_MEMORY_DESCRIPTOR
{
    ULONG64 StartOfMemoryRange;
    MINIDUMP_LOCATION_DESCRIPTOR Memory;
} MINIDUMP_MEMORY_DESCRIPTOR, *PMINIDUMP_MEMORY_DESCRIPTOR;

// DESCRIPTOR64 is used for full-memory minidumps where
// all of the raw memory is laid out sequentially at the
// end of the dump.  There is no need for individual RVAs
// as the RVA is the base RVA plus the sum of the preceeding
// data blocks.
typedef struct _MINIDUMP_MEMORY_DESCRIPTOR64
{
    ULONG64 StartOfMemoryRange;
    ULONG64 DataSize;
} MINIDUMP_MEMORY_DESCRIPTOR64, *PMINIDUMP_MEMORY_DESCRIPTOR64;


typedef struct _MINIDUMP_HEADER
{
    ULONG32 Signature;
    ULONG32 Version;
    ULONG32 NumberOfStreams;
    RVA StreamDirectoryRva;
    ULONG32 CheckSum;
    union
    {
        ULONG32 Reserved;
        ULONG32 TimeDateStamp;
    };
    ULONG64 Flags;
} MINIDUMP_HEADER, *PMINIDUMP_HEADER;

//
// The MINIDUMP_HEADER field StreamDirectoryRva points to
// an array of MINIDUMP_DIRECTORY structures.
//

typedef struct _MINIDUMP_DIRECTORY
{
    ULONG32 StreamType;
    MINIDUMP_LOCATION_DESCRIPTOR Location;
} MINIDUMP_DIRECTORY, *PMINIDUMP_DIRECTORY;


typedef struct _MINIDUMP_STRING
{
    ULONG32 Length;         // Length in bytes of the string
    WCHAR   Buffer [0];     // Variable size buffer
} MINIDUMP_STRING, *PMINIDUMP_STRING;



//
// The MINIDUMP_DIRECTORY field StreamType may be one of the following types.
// Types will be added in the future, so if a program reading the minidump
// header encounters a stream type it does not understand it should ignore
// the data altogether. Any tag above LastReservedStream will not be used by
// the system and is reserved for program-specific information.
//

typedef enum _MINIDUMP_STREAM_TYPE
{

    UnusedStream                = 0,
    ReservedStream0             = 1,
    ReservedStream1             = 2,
    ThreadListStream            = 3,
    ModuleListStream            = 4,
    MemoryListStream            = 5,
    ExceptionStream             = 6,
    SystemInfoStream            = 7,
    ThreadExListStream          = 8,
    Memory64ListStream          = 9,
    CommentStreamA              = 10,
    CommentStreamW              = 11,
    HandleDataStream            = 12,
    FunctionTableStream         = 13,
    UnloadedModuleListStream    = 14,
    MiscInfoStream              = 15,
    MemoryInfoListStream        = 16,
    ThreadInfoListStream        = 17,
    HandleOperationListStream   = 18,
    TokenStream                 = 19,

    ceStreamNull                = 0x8000,
    ceStreamSystemInfo          = 0x8001,
    ceStreamException           = 0x8002,
    ceStreamModuleList          = 0x8003,
    ceStreamProcessList         = 0x8004,
    ceStreamThreadList          = 0x8005,
    ceStreamThreadContextList   = 0x8006,
    ceStreamThreadCallStackList = 0x8007,
    ceStreamMemoryVirtualList   = 0x8008,
    ceStreamMemoryPhysicalList  = 0x8009,
    ceStreamBucketParameters    = 0x800A,
    ceStreamProcessModuleMap    = 0x800B,
    ceStreamDiagnosisList       = 0x800C,

    LastReservedStream          = 0xffff

} MINIDUMP_STREAM_TYPE;


//
// The minidump system information contains processor and
// Operating System specific information.
//

//
// CPU information is obtained from one of two places.
//
//  1) On x86 computers, CPU_INFORMATION is obtained from the CPUID
//     instruction. You must use the X86 portion of the union for X86
//     computers.
//
//  2) On non-x86 architectures, CPU_INFORMATION is obtained by calling
//     IsProcessorFeatureSupported().
//

typedef union _CPU_INFORMATION
{

    //
    // X86 platforms use CPUID function to obtain processor information.
    //

    struct
    {

        //
        // CPUID Subfunction 0, register EAX (VendorId [0]),
        // EBX (VendorId [1]) and ECX (VendorId [2]).
        //

        ULONG32 VendorId [ 3 ];

        //
        // CPUID Subfunction 1, register EAX
        //

        ULONG32 VersionInformation;

        //
        // CPUID Subfunction 1, register EDX
        //

        ULONG32 FeatureInformation;


        //
        // CPUID, Subfunction 80000001, register EBX. This will only
        // be obtained if the vendor id is "AuthenticAMD".
        //

        ULONG32 AMDExtendedCpuFeatures;

    } X86CpuInfo;

    //
    // Non-x86 platforms use processor feature flags.
    //

    struct
    {

        ULONG64 ProcessorFeatures [ 2 ];

    } OtherCpuInfo;

} CPU_INFORMATION, *PCPU_INFORMATION;

typedef struct _MINIDUMP_SYSTEM_INFO
{

    //
    // ProcessorArchitecture, ProcessorLevel and ProcessorRevision are all
    // taken from the SYSTEM_INFO structure obtained by GetSystemInfo( ).
    //

    USHORT ProcessorArchitecture;
    USHORT ProcessorLevel;
    USHORT ProcessorRevision;

    union
    {
        USHORT Reserved0;
        struct
        {
            UCHAR NumberOfProcessors;
            UCHAR ProductType;
        };
    };

    //
    // MajorVersion, MinorVersion, BuildNumber, PlatformId and
    // CSDVersion are all taken from the OSVERSIONINFO structure
    // returned by GetVersionEx( ).
    //

    ULONG32 MajorVersion;
    ULONG32 MinorVersion;
    ULONG32 BuildNumber;
    ULONG32 PlatformId;

    //
    // RVA to a CSDVersion string in the string table.
    //

    RVA CSDVersionRva;

    union
    {
        ULONG32 Reserved1;
        struct
        {
            USHORT SuiteMask;
            USHORT Reserved2;
        };
    };

    CPU_INFORMATION Cpu;

} MINIDUMP_SYSTEM_INFO, *PMINIDUMP_SYSTEM_INFO;


//
// The minidump thread contains standard thread
// information plus an RVA to the memory for this
// thread and an RVA to the CONTEXT structure for
// this thread.
//


//
// ThreadId must be 4 bytes on all architectures.
//

C_ASSERT(sizeof(((PPROCESS_INFORMATION)0)->dwThreadId) == 4);

typedef struct _MINIDUMP_THREAD
{
    ULONG32 ThreadId;
    ULONG32 SuspendCount;
    ULONG32 PriorityClass;
    ULONG32 Priority;
    ULONG64 Teb;
    MINIDUMP_MEMORY_DESCRIPTOR Stack;
    MINIDUMP_LOCATION_DESCRIPTOR ThreadContext;
} MINIDUMP_THREAD, *PMINIDUMP_THREAD;

//
// The thread list is a container of threads.
//

typedef struct _MINIDUMP_THREAD_LIST
{
    ULONG32 NumberOfThreads;
    MINIDUMP_THREAD Threads [0];
} MINIDUMP_THREAD_LIST, *PMINIDUMP_THREAD_LIST;


typedef struct _MINIDUMP_THREAD_EX
{
    ULONG32 ThreadId;
    ULONG32 SuspendCount;
    ULONG32 PriorityClass;
    ULONG32 Priority;
    ULONG64 Teb;
    MINIDUMP_MEMORY_DESCRIPTOR Stack;
    MINIDUMP_LOCATION_DESCRIPTOR ThreadContext;
    MINIDUMP_MEMORY_DESCRIPTOR BackingStore;
} MINIDUMP_THREAD_EX, *PMINIDUMP_THREAD_EX;

//
// The thread list is a container of threads.
//

typedef struct _MINIDUMP_THREAD_EX_LIST
{
    ULONG32 NumberOfThreads;
    MINIDUMP_THREAD_EX Threads [0];
} MINIDUMP_THREAD_EX_LIST, *PMINIDUMP_THREAD_EX_LIST;


//
// The MINIDUMP_EXCEPTION is the same as EXCEPTION on Win64.
//

typedef struct _MINIDUMP_EXCEPTION
{
    ULONG32 ExceptionCode;
    ULONG32 ExceptionFlags;
    ULONG64 ExceptionRecord;
    ULONG64 ExceptionAddress;
    ULONG32 NumberParameters;
    ULONG32 __unusedAlignment;
    ULONG64 ExceptionInformation [ EXCEPTION_MAXIMUM_PARAMETERS ];
} MINIDUMP_EXCEPTION, *PMINIDUMP_EXCEPTION;


//
// The exception information stream contains the id of the thread that caused
// the exception (ThreadId), the exception record for the exception
// (ExceptionRecord) and an RVA to the thread context where the exception
// occured.
//

typedef struct MINIDUMP_EXCEPTION_STREAM
{
    ULONG32 ThreadId;
    ULONG32  __alignment;
    MINIDUMP_EXCEPTION ExceptionRecord;
    MINIDUMP_LOCATION_DESCRIPTOR ThreadContext;
} MINIDUMP_EXCEPTION_STREAM, *PMINIDUMP_EXCEPTION_STREAM;


//
// The MINIDUMP_MODULE contains information about a
// a specific module. It includes the CheckSum and
// the TimeDateStamp for the module so the module
// can be reloaded during the analysis phase.
//

typedef struct _MINIDUMP_MODULE
{
    ULONG64 BaseOfImage;
    ULONG32 SizeOfImage;
    ULONG32 CheckSum;
    ULONG32 TimeDateStamp;
    RVA ModuleNameRva;
    VS_FIXEDFILEINFO VersionInfo;
    MINIDUMP_LOCATION_DESCRIPTOR CvRecord;
    MINIDUMP_LOCATION_DESCRIPTOR MiscRecord;
    ULONG64 Reserved0;                          // Reserved for future use.
    ULONG64 Reserved1;                          // Reserved for future use.
} MINIDUMP_MODULE, *PMINIDUMP_MODULE;


//
// The minidump module list is a container for modules.
//

typedef struct _MINIDUMP_MODULE_LIST
{
    ULONG32 NumberOfModules;
    MINIDUMP_MODULE Modules [ 0 ];
} MINIDUMP_MODULE_LIST, *PMINIDUMP_MODULE_LIST;


//
// Memory Ranges
//

typedef struct _MINIDUMP_MEMORY_LIST
{
    ULONG32 NumberOfMemoryRanges;
    MINIDUMP_MEMORY_DESCRIPTOR MemoryRanges [0];
} MINIDUMP_MEMORY_LIST, *PMINIDUMP_MEMORY_LIST;

typedef struct _MINIDUMP_MEMORY64_LIST
{
    ULONG64 NumberOfMemoryRanges;
    RVA64 BaseRva;
    MINIDUMP_MEMORY_DESCRIPTOR64 MemoryRanges [0];
} MINIDUMP_MEMORY64_LIST, *PMINIDUMP_MEMORY64_LIST;


//
// Support for user supplied exception information.
//

typedef struct _MINIDUMP_EXCEPTION_INFORMATION
{
    DWORD ThreadId;
    PEXCEPTION_POINTERS ExceptionPointers;
    BOOL ClientPointers;
} MINIDUMP_EXCEPTION_INFORMATION, *PMINIDUMP_EXCEPTION_INFORMATION;

typedef struct _MINIDUMP_EXCEPTION_INFORMATION64
{
    DWORD ThreadId;
    ULONG64 ExceptionRecord;
    ULONG64 ContextRecord;
    BOOL ClientPointers;
} MINIDUMP_EXCEPTION_INFORMATION64, *PMINIDUMP_EXCEPTION_INFORMATION64;


//
// Support for capturing system handle state at the time of the dump.
//

// Per-handle object information varies according to
// the OS, the OS version, the processor type and
// so on.  The minidump gives a minidump identifier
// to each possible data format for identification
// purposes but does not control nor describe the actual data.
typedef enum _MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE
{
    MiniHandleObjectInformationNone,
    MiniThreadInformation1,
    MiniMutantInformation1,
    MiniMutantInformation2,
    MiniProcessInformation1,
    MiniProcessInformation2,
    MiniHandleObjectInformationTypeMax
} MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE;

typedef struct _MINIDUMP_HANDLE_OBJECT_INFORMATION
{
    RVA NextInfoRva;
    ULONG32 InfoType;
    ULONG32 SizeOfInfo;
    // Raw information follows.
} MINIDUMP_HANDLE_OBJECT_INFORMATION;

typedef struct _MINIDUMP_HANDLE_DESCRIPTOR
{
    ULONG64 Handle;
    RVA TypeNameRva;
    RVA ObjectNameRva;
    ULONG32 Attributes;
    ULONG32 GrantedAccess;
    ULONG32 HandleCount;
    ULONG32 PointerCount;
} MINIDUMP_HANDLE_DESCRIPTOR, *PMINIDUMP_HANDLE_DESCRIPTOR;

typedef struct _MINIDUMP_HANDLE_DESCRIPTOR_2
{
    ULONG64 Handle;
    RVA TypeNameRva;
    RVA ObjectNameRva;
    ULONG32 Attributes;
    ULONG32 GrantedAccess;
    ULONG32 HandleCount;
    ULONG32 PointerCount;
    RVA ObjectInfoRva;
    ULONG32 Reserved0;
} MINIDUMP_HANDLE_DESCRIPTOR_2, *PMINIDUMP_HANDLE_DESCRIPTOR_2;

// The latest MINIDUMP_HANDLE_DESCRIPTOR definition.
typedef MINIDUMP_HANDLE_DESCRIPTOR_2 MINIDUMP_HANDLE_DESCRIPTOR_N;
typedef MINIDUMP_HANDLE_DESCRIPTOR_N* PMINIDUMP_HANDLE_DESCRIPTOR_N;

typedef struct _MINIDUMP_HANDLE_DATA_STREAM
{
    ULONG32 SizeOfHeader;
    ULONG32 SizeOfDescriptor;
    ULONG32 NumberOfDescriptors;
    ULONG32 Reserved;
} MINIDUMP_HANDLE_DATA_STREAM, *PMINIDUMP_HANDLE_DATA_STREAM;

// Some operating systems can track the last operations
// performed on a handle.  For example, Application Verifier
// can enable this for some versions of Windows.  The
// handle operation list collects handle operations
// known for the dump target.
// Each entry is an AVRF_HANDLE_OPERATION.
typedef struct _MINIDUMP_HANDLE_OPERATION_LIST
{
    ULONG32 SizeOfHeader;
    ULONG32 SizeOfEntry;
    ULONG32 NumberOfEntries;
    ULONG32 Reserved;
} MINIDUMP_HANDLE_OPERATION_LIST, *PMINIDUMP_HANDLE_OPERATION_LIST;


//
// Support for capturing dynamic function table state at the time of the dump.
//

typedef struct _MINIDUMP_FUNCTION_TABLE_DESCRIPTOR
{
    ULONG64 MinimumAddress;
    ULONG64 MaximumAddress;
    ULONG64 BaseAddress;
    ULONG32 EntryCount;
    ULONG32 SizeOfAlignPad;
} MINIDUMP_FUNCTION_TABLE_DESCRIPTOR, *PMINIDUMP_FUNCTION_TABLE_DESCRIPTOR;

typedef struct _MINIDUMP_FUNCTION_TABLE_STREAM
{
    ULONG32 SizeOfHeader;
    ULONG32 SizeOfDescriptor;
    ULONG32 SizeOfNativeDescriptor;
    ULONG32 SizeOfFunctionEntry;
    ULONG32 NumberOfDescriptors;
    ULONG32 SizeOfAlignPad;
} MINIDUMP_FUNCTION_TABLE_STREAM, *PMINIDUMP_FUNCTION_TABLE_STREAM;


//
// The MINIDUMP_UNLOADED_MODULE contains information about a
// a specific module that was previously loaded but no
// longer is.  This can help with diagnosing problems where
// callers attempt to call code that is no longer loaded.
//

typedef struct _MINIDUMP_UNLOADED_MODULE
{
    ULONG64 BaseOfImage;
    ULONG32 SizeOfImage;
    ULONG32 CheckSum;
    ULONG32 TimeDateStamp;
    RVA ModuleNameRva;
} MINIDUMP_UNLOADED_MODULE, *PMINIDUMP_UNLOADED_MODULE;


//
// The minidump unloaded module list is a container for unloaded modules.
//

typedef struct _MINIDUMP_UNLOADED_MODULE_LIST
{
    ULONG32 SizeOfHeader;
    ULONG32 SizeOfEntry;
    ULONG32 NumberOfEntries;
} MINIDUMP_UNLOADED_MODULE_LIST, *PMINIDUMP_UNLOADED_MODULE_LIST;


//
// The miscellaneous information stream contains a variety
// of small pieces of information.  A member is valid if
// it's within the available size and its corresponding
// bit is set.
//

#define MINIDUMP_MISC1_PROCESS_ID            0x00000001
#define MINIDUMP_MISC1_PROCESS_TIMES         0x00000002
#define MINIDUMP_MISC1_PROCESSOR_POWER_INFO  0x00000004
#define MINIDUMP_MISC3_PROCESS_INTEGRITY     0x00000010
#define MINIDUMP_MISC3_PROCESS_EXECUTE_FLAGS 0x00000020
#define MINIDUMP_MISC3_TIMEZONE              0x00000040
#define MINIDUMP_MISC3_PROTECTED_PROCESS     0x00000080

typedef struct _MINIDUMP_MISC_INFO
{
    ULONG32 SizeOfInfo;
    ULONG32 Flags1;
    ULONG32 ProcessId;
    ULONG32 ProcessCreateTime;
    ULONG32 ProcessUserTime;
    ULONG32 ProcessKernelTime;
} MINIDUMP_MISC_INFO, *PMINIDUMP_MISC_INFO;

typedef struct _MINIDUMP_MISC_INFO_2
{
    ULONG32 SizeOfInfo;
    ULONG32 Flags1;
    ULONG32 ProcessId;
    ULONG32 ProcessCreateTime;
    ULONG32 ProcessUserTime;
    ULONG32 ProcessKernelTime;
    ULONG32 ProcessorMaxMhz;
    ULONG32 ProcessorCurrentMhz;
    ULONG32 ProcessorMhzLimit;
    ULONG32 ProcessorMaxIdleState;
    ULONG32 ProcessorCurrentIdleState;
} MINIDUMP_MISC_INFO_2, *PMINIDUMP_MISC_INFO_2;

typedef struct _MINIDUMP_MISC_INFO_3
{
    ULONG32 SizeOfInfo;
    ULONG32 Flags1;
    ULONG32 ProcessId;
    ULONG32 ProcessCreateTime;
    ULONG32 ProcessUserTime;
    ULONG32 ProcessKernelTime;
    ULONG32 ProcessorMaxMhz;
    ULONG32 ProcessorCurrentMhz;
    ULONG32 ProcessorMhzLimit;
    ULONG32 ProcessorMaxIdleState;
    ULONG32 ProcessorCurrentIdleState;
    ULONG32 ProcessIntegrityLevel;
    ULONG32 ProcessExecuteFlags;
    ULONG32 ProtectedProcess;
    ULONG32 TimeZoneId;
    TIME_ZONE_INFORMATION TimeZone;
} MINIDUMP_MISC_INFO_3, *PMINIDUMP_MISC_INFO_3;

// The latest MINIDUMP_MISC_INFO definition.
typedef MINIDUMP_MISC_INFO_3 MINIDUMP_MISC_INFO_N;
typedef MINIDUMP_MISC_INFO_N* PMINIDUMP_MISC_INFO_N;


//
// The memory information stream contains memory region
// description information.  This stream corresponds to
// what VirtualQuery would return for the process the
// dump was created for.
//

typedef struct _MINIDUMP_MEMORY_INFO
{
    ULONG64 BaseAddress;
    ULONG64 AllocationBase;
    ULONG32 AllocationProtect;
    ULONG32 __alignment1;
    ULONG64 RegionSize;
    ULONG32 State;
    ULONG32 Protect;
    ULONG32 Type;
    ULONG32 __alignment2;
} MINIDUMP_MEMORY_INFO, *PMINIDUMP_MEMORY_INFO;

typedef struct _MINIDUMP_MEMORY_INFO_LIST
{
    ULONG SizeOfHeader;
    ULONG SizeOfEntry;
    ULONG64 NumberOfEntries;
} MINIDUMP_MEMORY_INFO_LIST, *PMINIDUMP_MEMORY_INFO_LIST;


//
// The memory information stream contains memory region
// description information.  This stream corresponds to
// what VirtualQuery would return for the process the
// dump was created for.
//

// Thread dump writer status flags.
#define MINIDUMP_THREAD_INFO_ERROR_THREAD    0x00000001
#define MINIDUMP_THREAD_INFO_WRITING_THREAD  0x00000002
#define MINIDUMP_THREAD_INFO_EXITED_THREAD   0x00000004
#define MINIDUMP_THREAD_INFO_INVALID_INFO    0x00000008
#define MINIDUMP_THREAD_INFO_INVALID_CONTEXT 0x00000010
#define MINIDUMP_THREAD_INFO_INVALID_TEB     0x00000020

typedef struct _MINIDUMP_THREAD_INFO
{
    ULONG32 ThreadId;
    ULONG32 DumpFlags;
    ULONG32 DumpError;
    ULONG32 ExitStatus;
    ULONG64 CreateTime;
    ULONG64 ExitTime;
    ULONG64 KernelTime;
    ULONG64 UserTime;
    ULONG64 StartAddress;
    ULONG64 Affinity;
} MINIDUMP_THREAD_INFO, *PMINIDUMP_THREAD_INFO;

typedef struct _MINIDUMP_THREAD_INFO_LIST
{
    ULONG SizeOfHeader;
    ULONG SizeOfEntry;
    ULONG NumberOfEntries;
} MINIDUMP_THREAD_INFO_LIST, *PMINIDUMP_THREAD_INFO_LIST;

//
// Support for token information.
//
typedef struct _MINIDUMP_TOKEN_INFO_HEADER
{
    ULONG   TokenSize;   // The size of the token structure.
    ULONG   TokenId;     // The PID in NtOpenProcessToken() call or TID in NtOpenThreadToken() call.
    ULONG64 TokenHandle; // The handle value returned.
} MINIDUMP_TOKEN_INFO_HEADER, *PMINIDUMP_TOKEN_INFO_HEADER;

typedef struct _MINIDUMP_TOKEN_INFO_LIST
{
    ULONG TokenListSize;
    ULONG TokenListEntries;
    ULONG ListHeaderSize;
    ULONG ElementHeaderSize;
} MINIDUMP_TOKEN_INFO_LIST, *PMINIDUMP_TOKEN_INFO_LIST;

//
// Support for arbitrary user-defined information.
//

typedef struct _MINIDUMP_USER_RECORD
{
    ULONG32 Type;
    MINIDUMP_LOCATION_DESCRIPTOR Memory;
} MINIDUMP_USER_RECORD, *PMINIDUMP_USER_RECORD;


typedef struct _MINIDUMP_USER_STREAM
{
    ULONG32 Type;
    ULONG BufferSize;
    PVOID Buffer;

} MINIDUMP_USER_STREAM, *PMINIDUMP_USER_STREAM;


typedef struct _MINIDUMP_USER_STREAM_INFORMATION
{
    ULONG UserStreamCount;
    PMINIDUMP_USER_STREAM UserStreamArray;
} MINIDUMP_USER_STREAM_INFORMATION, *PMINIDUMP_USER_STREAM_INFORMATION;

//
// Callback support.
//

typedef enum _MINIDUMP_CALLBACK_TYPE
{
    ModuleCallback,
    ThreadCallback,
    ThreadExCallback,
    IncludeThreadCallback,
    IncludeModuleCallback,
    MemoryCallback,
    CancelCallback,
    WriteKernelMinidumpCallback,
    KernelMinidumpStatusCallback,
    RemoveMemoryCallback,
    IncludeVmRegionCallback,
    IoStartCallback,
    IoWriteAllCallback,
    IoFinishCallback,
    ReadMemoryFailureCallback,
    SecondaryFlagsCallback,
} MINIDUMP_CALLBACK_TYPE;


typedef struct _MINIDUMP_THREAD_CALLBACK
{
    ULONG ThreadId;
    HANDLE ThreadHandle;
    CONTEXT Context;
    ULONG SizeOfContext;
    ULONG64 StackBase;
    ULONG64 StackEnd;
} MINIDUMP_THREAD_CALLBACK, *PMINIDUMP_THREAD_CALLBACK;


typedef struct _MINIDUMP_THREAD_EX_CALLBACK
{
    ULONG ThreadId;
    HANDLE ThreadHandle;
    CONTEXT Context;
    ULONG SizeOfContext;
    ULONG64 StackBase;
    ULONG64 StackEnd;
    ULONG64 BackingStoreBase;
    ULONG64 BackingStoreEnd;
} MINIDUMP_THREAD_EX_CALLBACK, *PMINIDUMP_THREAD_EX_CALLBACK;


typedef struct _MINIDUMP_INCLUDE_THREAD_CALLBACK
{
    ULONG ThreadId;
} MINIDUMP_INCLUDE_THREAD_CALLBACK, *PMINIDUMP_INCLUDE_THREAD_CALLBACK;


typedef enum _THREAD_WRITE_FLAGS
{
    ThreadWriteThread            = 0x0001,
    ThreadWriteStack             = 0x0002,
    ThreadWriteContext           = 0x0004,
    ThreadWriteBackingStore      = 0x0008,
    ThreadWriteInstructionWindow = 0x0010,
    ThreadWriteThreadData        = 0x0020,
    ThreadWriteThreadInfo        = 0x0040,
} THREAD_WRITE_FLAGS;

typedef struct _MINIDUMP_MODULE_CALLBACK
{
    PWCHAR FullPath;
    ULONG64 BaseOfImage;
    ULONG SizeOfImage;
    ULONG CheckSum;
    ULONG TimeDateStamp;
    VS_FIXEDFILEINFO VersionInfo;
    PVOID CvRecord;
    ULONG SizeOfCvRecord;
    PVOID MiscRecord;
    ULONG SizeOfMiscRecord;
} MINIDUMP_MODULE_CALLBACK, *PMINIDUMP_MODULE_CALLBACK;


typedef struct _MINIDUMP_INCLUDE_MODULE_CALLBACK
{
    ULONG64 BaseOfImage;
} MINIDUMP_INCLUDE_MODULE_CALLBACK, *PMINIDUMP_INCLUDE_MODULE_CALLBACK;


typedef enum _MODULE_WRITE_FLAGS
{
    ModuleWriteModule        = 0x0001,
    ModuleWriteDataSeg       = 0x0002,
    ModuleWriteMiscRecord    = 0x0004,
    ModuleWriteCvRecord      = 0x0008,
    ModuleReferencedByMemory = 0x0010,
    ModuleWriteTlsData       = 0x0020,
    ModuleWriteCodeSegs      = 0x0040,
} MODULE_WRITE_FLAGS;


typedef struct _MINIDUMP_IO_CALLBACK
{
    HANDLE Handle;
    ULONG64 Offset;
    PVOID Buffer;
    ULONG BufferBytes;
} MINIDUMP_IO_CALLBACK, *PMINIDUMP_IO_CALLBACK;


typedef struct _MINIDUMP_READ_MEMORY_FAILURE_CALLBACK
{
    ULONG64 Offset;
    ULONG Bytes;
    HRESULT FailureStatus;
} MINIDUMP_READ_MEMORY_FAILURE_CALLBACK,
*PMINIDUMP_READ_MEMORY_FAILURE_CALLBACK;


typedef struct _MINIDUMP_CALLBACK_INPUT
{
    ULONG ProcessId;
    HANDLE ProcessHandle;
    ULONG CallbackType;
    union
    {
        HRESULT Status;
        MINIDUMP_THREAD_CALLBACK Thread;
        MINIDUMP_THREAD_EX_CALLBACK ThreadEx;
        MINIDUMP_MODULE_CALLBACK Module;
        MINIDUMP_INCLUDE_THREAD_CALLBACK IncludeThread;
        MINIDUMP_INCLUDE_MODULE_CALLBACK IncludeModule;
        MINIDUMP_IO_CALLBACK Io;
        MINIDUMP_READ_MEMORY_FAILURE_CALLBACK ReadMemoryFailure;
        ULONG SecondaryFlags;
    };
} MINIDUMP_CALLBACK_INPUT, *PMINIDUMP_CALLBACK_INPUT;

typedef struct _MINIDUMP_CALLBACK_OUTPUT
{
    union
    {
        ULONG ModuleWriteFlags;
        ULONG ThreadWriteFlags;
        ULONG SecondaryFlags;
        struct
        {
            ULONG64 MemoryBase;
            ULONG MemorySize;
        };
        struct
        {
            BOOL CheckCancel;
            BOOL Cancel;
        };
        HANDLE Handle;
        struct
        {
            MINIDUMP_MEMORY_INFO VmRegion;
            BOOL Continue;
        };
        HRESULT Status;
    };
} MINIDUMP_CALLBACK_OUTPUT, *PMINIDUMP_CALLBACK_OUTPUT;


//
// A normal minidump contains just the information
// necessary to capture stack traces for all of the
// existing threads in a process.
//
// A minidump with data segments includes all of the data
// sections from loaded modules in order to capture
// global variable contents.  This can make the dump much
// larger if many modules have global data.
//
// A minidump with full memory includes all of the accessible
// memory in the process and can be very large.  A minidump
// with full memory always has the raw memory data at the end
// of the dump so that the initial structures in the dump can
// be mapped directly without having to include the raw
// memory information.
//
// Stack and backing store memory can be filtered to remove
// data unnecessary for stack walking.  This can improve
// compression of stacks and also deletes data that may
// be private and should not be stored in a dump.
// Memory can also be scanned to see what modules are
// referenced by stack and backing store memory to allow
// omission of other modules to reduce dump size.
// In either of these modes the ModuleReferencedByMemory flag
// is set for all modules referenced before the base
// module callbacks occur.
//
// On some operating systems a list of modules that were
// recently unloaded is kept in addition to the currently
// loaded module list.  This information can be saved in
// the dump if desired.
//
// Stack and backing store memory can be scanned for referenced
// pages in order to pick up data referenced by locals or other
// stack memory.  This can increase the size of a dump significantly.
//
// Module paths may contain undesired information such as user names
// or other important directory names so they can be stripped.  This
// option reduces the ability to locate the proper image later
// and should only be used in certain situations.
//
// Complete operating system per-process and per-thread information can
// be gathered and stored in the dump.
//
// The virtual address space can be scanned for various types
// of memory to be included in the dump.
//
// Code which is concerned with potentially private information
// getting into the minidump can set a flag that automatically
// modifies all existing and future flags to avoid placing
// unnecessary data in the dump.  Basic data, such as stack
// information, will still be included but optional data, such
// as indirect memory, will not.
//
// When doing a full memory dump it's possible to store all
// of the enumerated memory region descriptive information
// in a memory information stream.
//
// Additional thread information beyond the basic thread
// structure can be collected if desired.
//
// A minidump with code segments includes all of the code
// and code-related sections from loaded modules in order
// to capture executable content.
//
// MiniDumpWithoutAuxiliaryState turns off any secondary,
// auxiliary-supported memory gathering.
//
// MiniDumpWithFullAuxiliaryState asks any present auxiliary
// data providers to include all of their state in the dump.
// The exact set of what is provided depends on the auxiliary.
// This can be quite large.
//

typedef enum _MINIDUMP_TYPE
{
    MiniDumpNormal                         = 0x00000000,
    MiniDumpWithDataSegs                   = 0x00000001,
    MiniDumpWithFullMemory                 = 0x00000002,
    MiniDumpWithHandleData                 = 0x00000004,
    MiniDumpFilterMemory                   = 0x00000008,
    MiniDumpScanMemory                     = 0x00000010,
    MiniDumpWithUnloadedModules            = 0x00000020,
    MiniDumpWithIndirectlyReferencedMemory = 0x00000040,
    MiniDumpFilterModulePaths              = 0x00000080,
    MiniDumpWithProcessThreadData          = 0x00000100,
    MiniDumpWithPrivateReadWriteMemory     = 0x00000200,
    MiniDumpWithoutOptionalData            = 0x00000400,
    MiniDumpWithFullMemoryInfo             = 0x00000800,
    MiniDumpWithThreadInfo                 = 0x00001000,
    MiniDumpWithCodeSegs                   = 0x00002000,
    MiniDumpWithoutAuxiliaryState          = 0x00004000,
    MiniDumpWithFullAuxiliaryState         = 0x00008000,
    MiniDumpWithPrivateWriteCopyMemory     = 0x00010000,
    MiniDumpIgnoreInaccessibleMemory       = 0x00020000,
    MiniDumpWithTokenInformation           = 0x00040000,
    MiniDumpValidTypeFlags                 = 0x0007ffff,
} MINIDUMP_TYPE;

//
// In addition to the primary flags provided to
// MiniDumpWriteDump there are additional, less
// frequently used options queried via the secondary
// flags callback.
//
// MiniSecondaryWithoutPowerInfo suppresses the minidump
// query that retrieves processor power information for
// MINIDUMP_MISC_INFO.
//

typedef enum _MINIDUMP_SECONDARY_FLAGS
{
    MiniSecondaryWithoutPowerInfo = 0x00000001,

    MiniSecondaryValidFlags       = 0x00000001,
} MINIDUMP_SECONDARY_FLAGS;


//
// The minidump callback should modify the FieldsToWrite parameter to reflect
// what portions of the specified thread or module should be written to the
// file.
//

typedef
BOOL
(WINAPI* MINIDUMP_CALLBACK_ROUTINE)(
    __inout PVOID CallbackParam,
    __in    PMINIDUMP_CALLBACK_INPUT CallbackInput,
    __inout PMINIDUMP_CALLBACK_OUTPUT CallbackOutput
);

typedef struct _MINIDUMP_CALLBACK_INFORMATION
{
    MINIDUMP_CALLBACK_ROUTINE CallbackRoutine;
    PVOID CallbackParam;
} MINIDUMP_CALLBACK_INFORMATION, *PMINIDUMP_CALLBACK_INFORMATION;



//++
//
// PVOID
// RVA_TO_ADDR(
//     PVOID Mapping,
//     ULONG Rva
//     )
//
// Routine Description:
//
//     Map an RVA that is contained within a mapped file to it's associated
//     flat address.
//
// Arguments:
//
//     Mapping - Base address of mapped file containing the RVA.
//
//     Rva - An Rva to fixup.
//
// Return Values:
//
//     A pointer to the desired data.
//
//--

#define RVA_TO_ADDR(Mapping,Rva) ((PVOID)(((ULONG_PTR) (Mapping)) + (Rva)))

BOOL
WINAPI
MiniDumpWriteDump(
    __in HANDLE hProcess,
    __in DWORD ProcessId,
    __in HANDLE hFile,
    __in MINIDUMP_TYPE DumpType,
    __in_opt PMINIDUMP_EXCEPTION_INFORMATION ExceptionParam,
    __in_opt PMINIDUMP_USER_STREAM_INFORMATION UserStreamParam,
    __in_opt PMINIDUMP_CALLBACK_INFORMATION CallbackParam
);

BOOL
WINAPI
MiniDumpReadDumpStream(
    __in PVOID BaseOfDump,
    __in ULONG StreamNumber,
    __deref_out_opt PMINIDUMP_DIRECTORY* Dir,
    __deref_out_opt PVOID* StreamPointer,
    __out_opt ULONG* StreamSize
);

#pragma pack(pop)

#ifdef __cplusplus
}
#endif


#endif // _DBGHELP_




================================================
File: ClawSearch/pluginsdk/jansson/jansson.h
================================================
/*
 * Copyright (c) 2009-2016 Petri Lehtinen <petri@digip.org>
 *
 * Jansson is free software; you can redistribute it and/or modify
 * it under the terms of the MIT license. See LICENSE for details.
 */

#ifndef JANSSON_H
#define JANSSON_H

#include <stdio.h>
#include <stdlib.h>  /* for size_t */
#include <stdarg.h>

#include "jansson_config.h"

#ifdef __cplusplus
extern "C" {
#endif

/* version */

#define JANSSON_MAJOR_VERSION  2
#define JANSSON_MINOR_VERSION  9
#define JANSSON_MICRO_VERSION  0

/* Micro version is omitted if it's 0 */
#define JANSSON_VERSION  "2.9"

/* Version as a 3-byte hex number, e.g. 0x010201 == 1.2.1. Use this
   for numeric comparisons, e.g. #if JANSSON_VERSION_HEX >= ... */
#define JANSSON_VERSION_HEX  ((JANSSON_MAJOR_VERSION << 16) |   \
                              (JANSSON_MINOR_VERSION << 8)  |   \
                              (JANSSON_MICRO_VERSION << 0))


/* types */

typedef enum
{
    JSON_OBJECT,
    JSON_ARRAY,
    JSON_STRING,
    JSON_INTEGER,
    JSON_REAL,
    JSON_TRUE,
    JSON_FALSE,
    JSON_NULL
} json_type;

typedef struct json_t
{
    json_type type;
    size_t refcount;
} json_t;

#ifndef JANSSON_USING_CMAKE /* disabled if using cmake */
#if JSON_INTEGER_IS_LONG_LONG
#ifdef _WIN32
#define JSON_INTEGER_FORMAT "I64d"
#else
#define JSON_INTEGER_FORMAT "lld"
#endif
typedef long long json_int_t;
#else
#define JSON_INTEGER_FORMAT "ld"
typedef long json_int_t;
#endif /* JSON_INTEGER_IS_LONG_LONG */
#endif

#define json_typeof(json)      ((json)->type)
#define json_is_object(json)   ((json) && json_typeof(json) == JSON_OBJECT)
#define json_is_array(json)    ((json) && json_typeof(json) == JSON_ARRAY)
#define json_is_string(json)   ((json) && json_typeof(json) == JSON_STRING)
#define json_is_integer(json)  ((json) && json_typeof(json) == JSON_INTEGER)
#define json_is_real(json)     ((json) && json_typeof(json) == JSON_REAL)
#define json_is_number(json)   (json_is_integer(json) || json_is_real(json))
#define json_is_true(json)     ((json) && json_typeof(json) == JSON_TRUE)
#define json_is_false(json)    ((json) && json_typeof(json) == JSON_FALSE)
#define json_boolean_value     json_is_true
#define json_is_boolean(json)  (json_is_true(json) || json_is_false(json))
#define json_is_null(json)     ((json) && json_typeof(json) == JSON_NULL)

/* construction, destruction, reference counting */

__declspec(dllimport) json_t* json_object(void);
__declspec(dllimport) json_t* json_array(void);
__declspec(dllimport) json_t* json_string(const char* value);
__declspec(dllimport) json_t* json_stringn(const char* value, size_t len);
__declspec(dllimport) json_t* json_string_nocheck(const char* value);
__declspec(dllimport) json_t* json_stringn_nocheck(const char* value, size_t len);
__declspec(dllimport) json_t* json_integer(json_int_t value);
__declspec(dllimport) json_t* json_real(double value);
__declspec(dllimport) json_t* json_true(void);
__declspec(dllimport) json_t* json_false(void);
#define json_boolean(val)      ((val) ? json_true() : json_false())
__declspec(dllimport) json_t* json_null(void);

static JSON_INLINE
json_t* json_incref(json_t* json)
{
    if(json && json->refcount != (size_t) - 1)
        ++json->refcount;
    return json;
}

/* do not call json_delete directly */
__declspec(dllimport) void json_delete(json_t* json);

static JSON_INLINE
void json_decref(json_t* json)
{
    if(json && json->refcount != (size_t) - 1 && --json->refcount == 0)
        json_delete(json);
}

#if defined(__GNUC__) || defined(__clang__)
static JSON_INLINE
void json_decrefp(json_t** json)
{
    if(json)
    {
        json_decref(*json);
        *json = NULL;
    }
}

#define json_auto_t json_t __attribute__((cleanup(json_decrefp)))
#endif


/* error reporting */

#define JSON_ERROR_TEXT_LENGTH    160
#define JSON_ERROR_SOURCE_LENGTH   80

typedef struct
{
    int line;
    int column;
    int position;
    char source[JSON_ERROR_SOURCE_LENGTH];
    char text[JSON_ERROR_TEXT_LENGTH];
} json_error_t;


/* getters, setters, manipulation */

__declspec(dllimport) void json_object_seed(size_t seed);
__declspec(dllimport) size_t json_object_size(const json_t* object);
__declspec(dllimport) json_t* json_object_get(const json_t* object, const char* key);
__declspec(dllimport) int json_object_set_new(json_t* object, const char* key, json_t* value);
__declspec(dllimport) int json_object_set_new_nocheck(json_t* object, const char* key, json_t* value);
__declspec(dllimport) int json_object_del(json_t* object, const char* key);
__declspec(dllimport) int json_object_clear(json_t* object);
__declspec(dllimport) int json_object_update(json_t* object, json_t* other);
__declspec(dllimport) int json_object_update_existing(json_t* object, json_t* other);
__declspec(dllimport) int json_object_update_missing(json_t* object, json_t* other);
__declspec(dllimport) void* json_object_iter(json_t* object);
__declspec(dllimport) void* json_object_iter_at(json_t* object, const char* key);
__declspec(dllimport) void* json_object_key_to_iter(const char* key);
__declspec(dllimport) void* json_object_iter_next(json_t* object, void* iter);
__declspec(dllimport) const char* json_object_iter_key(void* iter);
__declspec(dllimport) json_t* json_object_iter_value(void* iter);
__declspec(dllimport) int json_object_iter_set_new(json_t* object, void* iter, json_t* value);

#define json_object_foreach(object, key, value) \
    for(key = json_object_iter_key(json_object_iter(object)); \
        key && (value = json_object_iter_value(json_object_key_to_iter(key))); \
        key = json_object_iter_key(json_object_iter_next(object, json_object_key_to_iter(key))))

#define json_object_foreach_safe(object, n, key, value)     \
    for(key = json_object_iter_key(json_object_iter(object)), \
            n = json_object_iter_next(object, json_object_key_to_iter(key)); \
        key && (value = json_object_iter_value(json_object_key_to_iter(key))); \
        key = json_object_iter_key(n), \
            n = json_object_iter_next(object, json_object_key_to_iter(key)))

#define json_array_foreach(array, index, value) \
    for(index = 0; \
        index < json_array_size(array) && (value = json_array_get(array, index)); \
        index++)

static JSON_INLINE
int json_object_set(json_t* object, const char* key, json_t* value)
{
    return json_object_set_new(object, key, json_incref(value));
}

static JSON_INLINE
int json_object_set_nocheck(json_t* object, const char* key, json_t* value)
{
    return json_object_set_new_nocheck(object, key, json_incref(value));
}

static JSON_INLINE
int json_object_iter_set(json_t* object, void* iter, json_t* value)
{
    return json_object_iter_set_new(object, iter, json_incref(value));
}

__declspec(dllimport) size_t json_array_size(const json_t* array);
__declspec(dllimport) json_t* json_array_get(const json_t* array, size_t index);
__declspec(dllimport) int json_array_set_new(json_t* array, size_t index, json_t* value);
__declspec(dllimport) int json_array_append_new(json_t* array, json_t* value);
__declspec(dllimport) int json_array_insert_new(json_t* array, size_t index, json_t* value);
__declspec(dllimport) int json_array_remove(json_t* array, size_t index);
__declspec(dllimport) int json_array_clear(json_t* array);
__declspec(dllimport) int json_array_extend(json_t* array, json_t* other);

static JSON_INLINE
int json_array_set(json_t* array, size_t ind, json_t* value)
{
    return json_array_set_new(array, ind, json_incref(value));
}

static JSON_INLINE
int json_array_append(json_t* array, json_t* value)
{
    return json_array_append_new(array, json_incref(value));
}

static JSON_INLINE
int json_array_insert(json_t* array, size_t ind, json_t* value)
{
    return json_array_insert_new(array, ind, json_incref(value));
}

__declspec(dllimport) const char* json_string_value(const json_t* string);
__declspec(dllimport) size_t json_string_length(const json_t* string);
__declspec(dllimport) json_int_t json_integer_value(const json_t* integer);
__declspec(dllimport) double json_real_value(const json_t* real);
__declspec(dllimport) double json_number_value(const json_t* json);

__declspec(dllimport) int json_string_set(json_t* string, const char* value);
__declspec(dllimport) int json_string_setn(json_t* string, const char* value, size_t len);
__declspec(dllimport) int json_string_set_nocheck(json_t* string, const char* value);
__declspec(dllimport) int json_string_setn_nocheck(json_t* string, const char* value, size_t len);
__declspec(dllimport) int json_integer_set(json_t* integer, json_int_t value);
__declspec(dllimport) int json_real_set(json_t* real, double value);

/* pack, unpack */

__declspec(dllimport) json_t* json_pack(const char* fmt, ...);
__declspec(dllimport) json_t* json_pack_ex(json_error_t* error, size_t flags, const char* fmt, ...);
__declspec(dllimport) json_t* json_vpack_ex(json_error_t* error, size_t flags, const char* fmt, va_list ap);

#define JSON_VALIDATE_ONLY  0x1
#define JSON_STRICT         0x2

__declspec(dllimport) int json_unpack(json_t* root, const char* fmt, ...);
__declspec(dllimport) int json_unpack_ex(json_t* root, json_error_t* error, size_t flags, const char* fmt, ...);
__declspec(dllimport) int json_vunpack_ex(json_t* root, json_error_t* error, size_t flags, const char* fmt, va_list ap);


/* equality */

__declspec(dllimport) int json_equal(json_t* value1, json_t* value2);


/* copying */

__declspec(dllimport) json_t* json_copy(json_t* value);
__declspec(dllimport) json_t* json_deep_copy(const json_t* value);


/* decoding */

#define JSON_REJECT_DUPLICATES  0x1
#define JSON_DISABLE_EOF_CHECK  0x2
#define JSON_DECODE_ANY         0x4
#define JSON_DECODE_INT_AS_REAL 0x8
#define JSON_ALLOW_NUL          0x10

typedef size_t (*json_load_callback_t)(void* buffer, size_t buflen, void* data);

__declspec(dllimport) json_t* json_loads(const char* input, size_t flags, json_error_t* error);
__declspec(dllimport) json_t* json_loadb(const char* buffer, size_t buflen, size_t flags, json_error_t* error);
__declspec(dllimport) json_t* json_loadf(FILE* input, size_t flags, json_error_t* error);
__declspec(dllimport) json_t* json_load_file(const char* path, size_t flags, json_error_t* error);
__declspec(dllimport) json_t* json_load_callback(json_load_callback_t callback, void* data, size_t flags, json_error_t* error);


/* encoding */

#define JSON_MAX_INDENT         0x1F
#define JSON_INDENT(n)          ((n) & JSON_MAX_INDENT)
#define JSON_COMPACT            0x20
#define JSON_ENSURE_ASCII       0x40
#define JSON_SORT_KEYS          0x80
#define JSON_PRESERVE_ORDER     0x100
#define JSON_ENCODE_ANY         0x200
#define JSON_ESCAPE_SLASH       0x400
#define JSON_REAL_PRECISION(n)  (((n) & 0x1F) << 11)

typedef int (*json_dump_callback_t)(const char* buffer, size_t size, void* data);

__declspec(dllimport) char* json_dumps(const json_t* json, size_t flags);
__declspec(dllimport) int json_dumpf(const json_t* json, FILE* output, size_t flags);
__declspec(dllimport) int json_dump_file(const json_t* json, const char* path, size_t flags);
__declspec(dllimport) int json_dump_callback(const json_t* json, json_dump_callback_t callback, void* data, size_t flags);

/* custom memory allocation */

typedef void* (*json_malloc_t)(size_t);
typedef void (*json_free_t)(void*);

__declspec(dllimport) void json_set_alloc_funcs(json_malloc_t malloc_fn, json_free_t free_fn);
__declspec(dllimport) void json_get_alloc_funcs(json_malloc_t* malloc_fn, json_free_t* free_fn);

#ifdef __cplusplus
}
#endif

#endif



================================================
File: ClawSearch/pluginsdk/jansson/jansson_config.h
================================================
/*
 * Copyright (c) 2010-2016 Petri Lehtinen <petri@digip.org>
 *
 * Jansson is free software; you can redistribute it and/or modify
 * it under the terms of the MIT license. See LICENSE for details.
 *
 *
 * This file specifies a part of the site-specific configuration for
 * Jansson, namely those things that affect the public API in
 * jansson.h.
 *
 * The CMake system will generate the jansson_config.h file and
 * copy it to the build and install directories.
 */

#ifndef JANSSON_CONFIG_H
#define JANSSON_CONFIG_H

/* Define this so that we can disable scattered automake configuration in source files */
#ifndef JANSSON_USING_CMAKE
#define JANSSON_USING_CMAKE
#endif

/* Note: when using cmake, JSON_INTEGER_IS_LONG_LONG is not defined nor used,
 * as we will also check for __int64 etc types.
 * (the definition was used in the automake system) */

/* Bring in the cmake-detected defines */
#define HAVE_STDINT_H 1
/* #undef HAVE_INTTYPES_H */
/* #undef HAVE_SYS_TYPES_H */

/* Include our standard type header for the integer typedef */

#if defined(HAVE_STDINT_H)
#  include <stdint.h>
#elif defined(HAVE_INTTYPES_H)
#  include <inttypes.h>
#elif defined(HAVE_SYS_TYPES_H)
#  include <sys/types.h>
#endif


/* If your compiler supports the inline keyword in C, JSON_INLINE is
   defined to `inline', otherwise empty. In C++, the inline is always
   supported. */
#ifdef __cplusplus
#define JSON_INLINE inline
#else
#define JSON_INLINE __inline
#endif


#define json_int_t long long
#define json_strtoint strtoll
#define JSON_INTEGER_FORMAT "I64d"


/* If locale.h and localeconv() are available, define to 1, otherwise to 0. */
#define JSON_HAVE_LOCALECONV 1


/* Maximum recursion depth for parsing JSON input.
   This limits the depth of e.g. array-within-array constructions. */
#define JSON_PARSER_MAX_DEPTH 2048


#endif



================================================
File: ClawSearch/pluginsdk/jansson/jansson_x64dbg.h
================================================
#pragma once

#include "jansson.h"

typedef json_t* JSON;

static JSON_INLINE
json_t* json_hex(unsigned json_int_t value)
{
    char hexvalue[20];
    sprintf_s(hexvalue, "0x%llX", value);
    return json_string(hexvalue);
}

static JSON_INLINE
unsigned json_int_t json_hex_value(const json_t* hex)
{
    unsigned json_int_t ret = 0;
    const char* hexvalue;
    hexvalue = json_string_value(hex);
    if(!hexvalue)
        return 0;
    sscanf_s(hexvalue, "0x%llX", &ret);
    return ret;
}



================================================
File: ClawSearch/pluginsdk/lz4/lz4.h
================================================
/*
   LZ4 - Fast LZ compression algorithm
   Header File
   Copyright (C) 2011-2014, Yann Collet.
   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following disclaimer
   in the documentation and/or other materials provided with the
   distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

   You can contact the author at :
   - LZ4 homepage : http://fastcompression.blogspot.com/p/lz4.html
   - LZ4 source repository : http://code.google.com/p/lz4/
*/
#ifndef _LZ4_H
#define _LZ4_H

#if defined (__cplusplus)
extern "C"
{
#endif


/**************************************
   Version
**************************************/
#define LZ4_VERSION_MAJOR    1    /* for major interface/format changes  */
#define LZ4_VERSION_MINOR    1    /* for minor interface/format changes  */
#define LZ4_VERSION_RELEASE  3    /* for tweaks, bug-fixes, or development */


/**************************************
   Compiler Options
**************************************/
#if (defined(__GNUC__) && defined(__STRICT_ANSI__)) || (defined(_MSC_VER) && !defined(__cplusplus))   /* Visual Studio */
#  define inline __inline           /* Visual C is not C99, but supports some kind of inline */
#endif


/**************************************
   Simple Functions
**************************************/

__declspec(dllimport) int LZ4_compress(const char* source, char* dest, int inputSize);
__declspec(dllimport) int LZ4_decompress_safe(const char* source, char* dest, int inputSize, int maxOutputSize);

/*
LZ4_compress() :
    Compresses 'inputSize' bytes from 'source' into 'dest'.
    Destination buffer must be already allocated,
    and must be sized to handle worst cases situations (input data not compressible)
    Worst case size evaluation is provided by function LZ4_compressBound()
    inputSize : Max supported value is LZ4_MAX_INPUT_VALUE
    return : the number of bytes written in buffer dest
             or 0 if the compression fails

LZ4_decompress_safe() :
    maxOutputSize : is the size of the destination buffer (which must be already allocated)
    return : the number of bytes decoded in the destination buffer (necessarily <= maxOutputSize)
             If the source stream is detected malformed, the function will stop decoding and return a negative result.
             This function is protected against buffer overflow exploits (never writes outside of output buffer, and never reads outside of input buffer). Therefore, it is protected against malicious data packets
*/


/**************************************
   Advanced Functions
**************************************/
#define LZ4_MAX_INPUT_SIZE        0x7E000000   /* 2 113 929 216 bytes */
#define LZ4_COMPRESSBOUND(isize)  ((unsigned int)(isize) > (unsigned int)LZ4_MAX_INPUT_SIZE ? 0 : (isize) + ((isize)/255) + 16)

/*
LZ4_compressBound() :
    Provides the maximum size that LZ4 may output in a "worst case" scenario (input data not compressible)
    primarily useful for memory allocation of output buffer.
    inline function is recommended for the general case,
    macro is also provided when result needs to be evaluated at compilation (such as stack memory allocation).

    isize  : is the input size. Max supported value is LZ4_MAX_INPUT_SIZE
    return : maximum output size in a "worst case" scenario
             or 0, if input size is too large ( > LZ4_MAX_INPUT_SIZE)
*/
__declspec(dllimport) int LZ4_compressBound(int isize);


/*
LZ4_compress_limitedOutput() :
    Compress 'inputSize' bytes from 'source' into an output buffer 'dest' of maximum size 'maxOutputSize'.
    If it cannot achieve it, compression will stop, and result of the function will be zero.
    This function never writes outside of provided output buffer.

    inputSize  : Max supported value is LZ4_MAX_INPUT_VALUE
    maxOutputSize : is the size of the destination buffer (which must be already allocated)
    return : the number of bytes written in buffer 'dest'
             or 0 if the compression fails
*/
__declspec(dllimport) int LZ4_compress_limitedOutput(const char* source, char* dest, int inputSize, int maxOutputSize);


/*
LZ4_decompress_fast() :
    originalSize : is the original and therefore uncompressed size
    return : the number of bytes read from the source buffer (in other words, the compressed size)
             If the source stream is malformed, the function will stop decoding and return a negative result.
    note : This function is a bit faster than LZ4_decompress_safe()
           This function never writes outside of output buffers, but may read beyond input buffer in case of malicious data packet.
           Use this function preferably into a trusted environment (data to decode comes from a trusted source).
           Destination buffer must be already allocated. Its size must be a minimum of 'outputSize' bytes.
*/
__declspec(dllimport) int LZ4_decompress_fast(const char* source, char* dest, int originalSize);


/*
LZ4_decompress_safe_partial() :
    This function decompress a compressed block of size 'inputSize' at position 'source'
    into output buffer 'dest' of size 'maxOutputSize'.
    The function tries to stop decompressing operation as soon as 'targetOutputSize' has been reached,
    reducing decompression time.
    return : the number of bytes decoded in the destination buffer (necessarily <= maxOutputSize)
       Note : this number can be < 'targetOutputSize' should the compressed block to decode be smaller.
             Always control how many bytes were decoded.
             If the source stream is detected malformed, the function will stop decoding and return a negative result.
             This function never writes outside of output buffer, and never reads outside of input buffer. It is therefore protected against malicious data packets
*/
__declspec(dllimport) int LZ4_decompress_safe_partial(const char* source, char* dest, int inputSize, int targetOutputSize, int maxOutputSize);


/*
These functions are provided should you prefer to allocate memory for compression tables with your own allocation methods.
To know how much memory must be allocated for the compression tables, use :
int LZ4_sizeofState();

Note that tables must be aligned on 4-bytes boundaries, otherwise compression will fail (return code 0).

The allocated memory can be provided to the compressions functions using 'void* state' parameter.
LZ4_compress_withState() and LZ4_compress_limitedOutput_withState() are equivalent to previously described functions.
They just use the externally allocated memory area instead of allocating their own (on stack, or on heap).
*/
__declspec(dllimport) int LZ4_sizeofState(void);
__declspec(dllimport) int LZ4_compress_withState(void* state, const char* source, char* dest, int inputSize);
__declspec(dllimport) int LZ4_compress_limitedOutput_withState(void* state, const char* source, char* dest, int inputSize, int maxOutputSize);


/**************************************
   Streaming Functions
**************************************/
__declspec(dllimport) void* LZ4_create(const char* inputBuffer);
__declspec(dllimport) int   LZ4_compress_continue(void* LZ4_Data, const char* source, char* dest, int inputSize);
__declspec(dllimport) int   LZ4_compress_limitedOutput_continue(void* LZ4_Data, const char* source, char* dest, int inputSize, int maxOutputSize);
__declspec(dllimport) char* LZ4_slideInputBuffer(void* LZ4_Data);
__declspec(dllimport) int   LZ4_free(void* LZ4_Data);

/*
These functions allow the compression of dependent blocks, where each block benefits from prior 64 KB within preceding blocks.
In order to achieve this, it is necessary to start creating the LZ4 Data Structure, thanks to the function :

void* LZ4_create (const char* inputBuffer);
The result of the function is the (void*) pointer on the LZ4 Data Structure.
This pointer will be needed in all other functions.
If the pointer returned is NULL, then the allocation has failed, and compression must be aborted.
The only parameter 'const char* inputBuffer' must, obviously, point at the beginning of input buffer.
The input buffer must be already allocated, and size at least 192KB.
'inputBuffer' will also be the 'const char* source' of the first block.

All blocks are expected to lay next to each other within the input buffer, starting from 'inputBuffer'.
To compress each block, use either LZ4_compress_continue() or LZ4_compress_limitedOutput_continue().
Their behavior are identical to LZ4_compress() or LZ4_compress_limitedOutput(),
but require the LZ4 Data Structure as their first argument, and check that each block starts right after the previous one.
If next block does not begin immediately after the previous one, the compression will fail (return 0).

When it's no longer possible to lay the next block after the previous one (not enough space left into input buffer), a call to :
char* LZ4_slideInputBuffer(void* LZ4_Data);
must be performed. It will typically copy the latest 64KB of input at the beginning of input buffer.
Note that, for this function to work properly, minimum size of an input buffer must be 192KB.
==> The memory position where the next input data block must start is provided as the result of the function.

Compression can then resume, using LZ4_compress_continue() or LZ4_compress_limitedOutput_continue(), as usual.

When compression is completed, a call to LZ4_free() will release the memory used by the LZ4 Data Structure.
*/


__declspec(dllimport) int LZ4_sizeofStreamState(void);
__declspec(dllimport) int LZ4_resetStreamState(void* state, const char* inputBuffer);

/*
These functions achieve the same result as :
void* LZ4_create (const char* inputBuffer);

They are provided here to allow the user program to allocate memory using its own routines.

To know how much space must be allocated, use LZ4_sizeofStreamState();
Note also that space must be 4-bytes aligned.

Once space is allocated, you must initialize it using : LZ4_resetStreamState(void* state, const char* inputBuffer);
void* state is a pointer to the space allocated.
It must be aligned on 4-bytes boundaries, and be large enough.
The parameter 'const char* inputBuffer' must, obviously, point at the beginning of input buffer.
The input buffer must be already allocated, and size at least 192KB.
'inputBuffer' will also be the 'const char* source' of the first block.

The same space can be re-used multiple times, just by initializing it each time with LZ4_resetStreamState().
return value of LZ4_resetStreamState() must be 0 is OK.
Any other value means there was an error (typically, pointer is not aligned on 4-bytes boundaries).
*/


__declspec(dllimport) int LZ4_decompress_safe_withPrefix64k(const char* source, char* dest, int inputSize, int maxOutputSize);
__declspec(dllimport) int LZ4_decompress_fast_withPrefix64k(const char* source, char* dest, int outputSize);

/*
*_withPrefix64k() :
    These decoding functions work the same as their "normal name" versions,
    but can use up to 64KB of data in front of 'char* dest'.
    These functions are necessary to decode inter-dependant blocks.
*/


/**************************************
   Obsolete Functions
**************************************/
/*
These functions are deprecated and should no longer be used.
They are provided here for compatibility with existing user programs.
*/
__declspec(dllimport) int LZ4_uncompress(const char* source, char* dest, int outputSize);
__declspec(dllimport) int LZ4_uncompress_unknownOutputSize(const char* source, char* dest, int isize, int maxOutputSize);


#if defined (__cplusplus)
}
#endif

#endif //_LZ4_H


================================================
File: ClawSearch/pluginsdk/lz4/lz4file.h
================================================
#ifndef _LZ4FILE_H
#define _LZ4FILE_H

typedef enum _LZ4_STATUS
{
    LZ4_SUCCESS,
    LZ4_FAILED_OPEN_INPUT,
    LZ4_FAILED_OPEN_OUTPUT,
    LZ4_NOT_ENOUGH_MEMORY,
    LZ4_INVALID_ARCHIVE,
    LZ4_CORRUPTED_ARCHIVE
} LZ4_STATUS;

#if defined (__cplusplus)
extern "C"
{
#endif

__declspec(dllimport) LZ4_STATUS LZ4_compress_file(const char* input_filename, const char* output_filename);
__declspec(dllimport) LZ4_STATUS LZ4_compress_fileW(const wchar_t* input_filename, const wchar_t* output_filename);
__declspec(dllimport) LZ4_STATUS LZ4_decompress_file(const char* input_filename, const char* output_filename);
__declspec(dllimport) LZ4_STATUS LZ4_decompress_fileW(const wchar_t* input_filename, const wchar_t* output_filename);

#if defined (__cplusplus)
}
#endif

#endif //_LZ4FILE_H


================================================
File: ClawSearch/pluginsdk/lz4/lz4hc.h
================================================
/*
   LZ4 HC - High Compression Mode of LZ4
   Header File
   Copyright (C) 2011-2014, Yann Collet.
   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following disclaimer
   in the documentation and/or other materials provided with the
   distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

   You can contact the author at :
   - LZ4 homepage : http://fastcompression.blogspot.com/p/lz4.html
   - LZ4 source repository : http://code.google.com/p/lz4/
*/
#ifndef _LZ4HC_H
#define _LZ4HC_H

#if defined (__cplusplus)
extern "C"
{
#endif


__declspec(dllimport) int LZ4_compressHC(const char* source, char* dest, int inputSize);
/*
LZ4_compressHC :
    return : the number of bytes in compressed buffer dest
             or 0 if compression fails.
    note : destination buffer must be already allocated.
        To avoid any problem, size it to handle worst cases situations (input data not compressible)
        Worst case size evaluation is provided by function LZ4_compressBound() (see "lz4.h")
*/

__declspec(dllimport) int LZ4_compressHC_limitedOutput(const char* source, char* dest, int inputSize, int maxOutputSize);
/*
LZ4_compress_limitedOutput() :
    Compress 'inputSize' bytes from 'source' into an output buffer 'dest' of maximum size 'maxOutputSize'.
    If it cannot achieve it, compression will stop, and result of the function will be zero.
    This function never writes outside of provided output buffer.

    inputSize  : Max supported value is 1 GB
    maxOutputSize : is maximum allowed size into the destination buffer (which must be already allocated)
    return : the number of output bytes written in buffer 'dest'
             or 0 if compression fails.
*/


__declspec(dllimport) int LZ4_compressHC2(const char* source, char* dest, int inputSize, int compressionLevel);
__declspec(dllimport) int LZ4_compressHC2_limitedOutput(const char* source, char* dest, int inputSize, int maxOutputSize, int compressionLevel);
/*
    Same functions as above, but with programmable 'compressionLevel'.
    Recommended values are between 4 and 9, although any value between 0 and 16 will work.
    'compressionLevel'==0 means use default 'compressionLevel' value.
    Values above 16 behave the same as 16.
    Equivalent variants exist for all other compression functions below.
*/

/* Note :
Decompression functions are provided within LZ4 source code (see "lz4.h") (BSD license)
*/


/**************************************
   Using an external allocation
**************************************/
__declspec(dllimport) int LZ4_sizeofStateHC(void);
__declspec(dllimport) int LZ4_compressHC_withStateHC(void* state, const char* source, char* dest, int inputSize);
__declspec(dllimport) int LZ4_compressHC_limitedOutput_withStateHC(void* state, const char* source, char* dest, int inputSize, int maxOutputSize);

__declspec(dllimport) int LZ4_compressHC2_withStateHC(void* state, const char* source, char* dest, int inputSize, int compressionLevel);
__declspec(dllimport) int LZ4_compressHC2_limitedOutput_withStateHC(void* state, const char* source, char* dest, int inputSize, int maxOutputSize, int compressionLevel);

/*
These functions are provided should you prefer to allocate memory for compression tables with your own allocation methods.
To know how much memory must be allocated for the compression tables, use :
int LZ4_sizeofStateHC();

Note that tables must be aligned for pointer (32 or 64 bits), otherwise compression will fail (return code 0).

The allocated memory can be provided to the compressions functions using 'void* state' parameter.
LZ4_compress_withStateHC() and LZ4_compress_limitedOutput_withStateHC() are equivalent to previously described functions.
They just use the externally allocated memory area instead of allocating their own (on stack, or on heap).
*/


/**************************************
   Streaming Functions
**************************************/
__declspec(dllimport) void* LZ4_createHC(const char* inputBuffer);
__declspec(dllimport) int   LZ4_compressHC_continue(void* LZ4HC_Data, const char* source, char* dest, int inputSize);
__declspec(dllimport) int   LZ4_compressHC_limitedOutput_continue(void* LZ4HC_Data, const char* source, char* dest, int inputSize, int maxOutputSize);
__declspec(dllimport) char* LZ4_slideInputBufferHC(void* LZ4HC_Data);
__declspec(dllimport) int   LZ4_freeHC(void* LZ4HC_Data);

__declspec(dllimport) int   LZ4_compressHC2_continue(void* LZ4HC_Data, const char* source, char* dest, int inputSize, int compressionLevel);
__declspec(dllimport) int   LZ4_compressHC2_limitedOutput_continue(void* LZ4HC_Data, const char* source, char* dest, int inputSize, int maxOutputSize, int compressionLevel);

/*
These functions allow the compression of dependent blocks, where each block benefits from prior 64 KB within preceding blocks.
In order to achieve this, it is necessary to start creating the LZ4HC Data Structure, thanks to the function :

void* LZ4_createHC (const char* inputBuffer);
The result of the function is the (void*) pointer on the LZ4HC Data Structure.
This pointer will be needed in all other functions.
If the pointer returned is NULL, then the allocation has failed, and compression must be aborted.
The only parameter 'const char* inputBuffer' must, obviously, point at the beginning of input buffer.
The input buffer must be already allocated, and size at least 192KB.
'inputBuffer' will also be the 'const char* source' of the first block.

All blocks are expected to lay next to each other within the input buffer, starting from 'inputBuffer'.
To compress each block, use either LZ4_compressHC_continue() or LZ4_compressHC_limitedOutput_continue().
Their behavior are identical to LZ4_compressHC() or LZ4_compressHC_limitedOutput(),
but require the LZ4HC Data Structure as their first argument, and check that each block starts right after the previous one.
If next block does not begin immediately after the previous one, the compression will fail (return 0).

When it's no longer possible to lay the next block after the previous one (not enough space left into input buffer), a call to :
char* LZ4_slideInputBufferHC(void* LZ4HC_Data);
must be performed. It will typically copy the latest 64KB of input at the beginning of input buffer.
Note that, for this function to work properly, minimum size of an input buffer must be 192KB.
==> The memory position where the next input data block must start is provided as the result of the function.

Compression can then resume, using LZ4_compressHC_continue() or LZ4_compressHC_limitedOutput_continue(), as usual.

When compression is completed, a call to LZ4_freeHC() will release the memory used by the LZ4HC Data Structure.
*/

__declspec(dllimport) int LZ4_sizeofStreamStateHC(void);
__declspec(dllimport) int LZ4_resetStreamStateHC(void* state, const char* inputBuffer);

/*
These functions achieve the same result as :
void* LZ4_createHC (const char* inputBuffer);

They are provided here to allow the user program to allocate memory using its own routines.

To know how much space must be allocated, use LZ4_sizeofStreamStateHC();
Note also that space must be aligned for pointers (32 or 64 bits).

Once space is allocated, you must initialize it using : LZ4_resetStreamStateHC(void* state, const char* inputBuffer);
void* state is a pointer to the space allocated.
It must be aligned for pointers (32 or 64 bits), and be large enough.
The parameter 'const char* inputBuffer' must, obviously, point at the beginning of input buffer.
The input buffer must be already allocated, and size at least 192KB.
'inputBuffer' will also be the 'const char* source' of the first block.

The same space can be re-used multiple times, just by initializing it each time with LZ4_resetStreamState().
return value of LZ4_resetStreamStateHC() must be 0 is OK.
Any other value means there was an error (typically, state is not aligned for pointers (32 or 64 bits)).
*/


#if defined (__cplusplus)
}
#endif

#endif //_LZ4HC_H



================================================
File: ClawSearch/scratch2/s2list.h
================================================
#pragma once

#define S2_USING_LIST

#include <cstdlib>
#include <cstring>
#include <new>
#include <initializer_list>

namespace s2
{
	template<typename T>
	class list;

	template<typename LT, typename T>
	class listiterator
	{
	private:
		LT* m_list;
		size_t m_index;

	public:
		listiterator(LT* list, size_t index)
		{
			m_list = list;
			m_index = index;
		}

		bool operator ==(const listiterator &other)
		{
			return !operator !=(other);
		}

		bool operator !=(const listiterator &other)
		{
			return m_list != other.m_list || m_index != other.m_index;
		}

		listiterator &operator ++()
		{
			m_index++;
			return *this;
		}

		T &operator *()
		{
			return (*m_list)[m_index];
		}
	};

	template<typename T>
	class list
	{
	public:
		typedef listiterator<list<T>, T> iterator;
		typedef listiterator<const list<T>, const T> constiterator;

	private:
		T* m_buffer;
		size_t m_length;
		size_t m_allocSize;

	public:
		list()
		{
			m_buffer = nullptr;
			m_length = 0;
			m_allocSize = 0;
		}

		list(const list &copy)
			: list()
		{
			size_t copylen = copy.len();
			ensure_memory(copylen);
			for (size_t i = 0; i < copylen; i++) {
				add(copy[i]);
			}
		}

		list(std::initializer_list<T> l)
			: list()
		{
			ensure_memory(l.size());
			for (const T &o : l) {
				add(o);
			}
		}

		~list()
		{
			clear_memory();
		}

		list &operator =(const list &copy)
		{
			clear_memory();
			size_t copylen = copy.len();
			ensure_memory(copylen);
			for (size_t i = 0; i < copylen; i++) {
				add(copy[i]);
			}
			return *this;
		}

		list &operator =(std::initializer_list<T> l)
		{
			clear_memory();
			ensure_memory(l.size());
			for (const T &o : l) {
				add(o);
			}
			return *this;
		}

		void clear()
		{
			for (size_t i = 0; i < m_length; i++) {
				m_buffer[i].~T();
			}
			m_length = 0;
		}

		size_t len() const
		{
			return m_length;
		}

		void add(const T &o)
		{
			ensure_memory(m_length + 1);
			new (m_buffer + m_length) T(o);
			m_length++;
		}

		T &add()
		{
			ensure_memory(m_length + 1);
			T* ret = new (m_buffer + m_length) T;
			m_length++;
			return *ret;
		}

		void insert(int index, const T &o)
		{
			if (index == m_length) {
				add(o);
				return;
			}

			ensure_memory(m_length + 1);
			memmove(m_buffer + index + 1, m_buffer + index, (m_length - index) * sizeof(T));
			new (m_buffer + index) T(o);
			m_length++;
		}

		T &insert(int index)
		{
			if (index == m_length) {
				return add();
			}

			ensure_memory(m_length + 1);
			memmove(m_buffer + index + 1, m_buffer + index, (m_length - index) * sizeof(T));
			T* ret = new (m_buffer + index) T;
			m_length++;
			return *ret;
		}

		void remove(size_t index)
		{
			if (index < 0 || index >= m_length) {
				return;
			}
			m_buffer[index].~T();
			if (index < m_length) {
				//NOTE: This is not safe if there are pointers to the items
				memmove(m_buffer + index, m_buffer + index + 1, (m_length - index) * sizeof(T));
			}
			m_length--;
		}

		T &push()
		{
			return add();
		}

		T pop()
		{
			T ret = top();
			remove(m_length - 1);
			return ret;
		}

		T &top()
		{
			return m_buffer[m_length - 1];
		}

		const T &top() const
		{
			return m_buffer[m_length - 1];
		}

		int indexof(const T &o) const
		{
			for (size_t i = 0; i < m_length; i++) {
				if (m_buffer[i] == o) {
					return (int)i;
				}
			}
			return -1;
		}

		bool contains(const T &o) const
		{
			return indexof(o) != -1;
		}

		void sort(int (*f)(const void *, const void *))
		{
			qsort(m_buffer, m_length, sizeof(T), f);
		}

		T &operator [](size_t index)
		{
			return m_buffer[index];
		}

		const T &operator [](size_t index) const
		{
			return m_buffer[index];
		}

		iterator begin()
		{
			return iterator(this, 0);
		}

		const constiterator begin() const
		{
			return constiterator(this, 0);
		}

		iterator end()
		{
			return iterator(this, m_length);
		}

		const constiterator end() const
		{
			return constiterator(this, m_length);
		}

		void ensure_memory(size_t count)
		{
			if (m_allocSize >= count) {
				return;
			}

			size_t resize = m_allocSize + m_allocSize / 2;
			if (resize < SIZE_MAX && resize > count) {
				count = resize;
			}

			m_buffer = (T*)realloc(m_buffer, count * sizeof(T));
			m_allocSize = count;
		}

	private:
		void clear_memory()
		{
			clear();
			if (m_buffer != nullptr) {
				free(m_buffer);
				m_buffer = nullptr;
				m_allocSize = 0;
			}
		}
	};
}



================================================
File: ClawSearch/scratch2/s2string.h
================================================
#pragma once

#define S2_USING_STRING

#include <cstddef>
#include <cstdint>

namespace s2
{
	class stringsplit;

	class string
	{
	friend class stringsplit;

	private:
		char* m_buffer;
		size_t m_length;
		size_t m_allocSize;

	public:
		string();
		string(const char* sz);
		string(const char* sz, size_t len);
		string(const char* sz, size_t start, size_t len);
		string(const string &str);
		~string();

		size_t len() const;
		size_t allocsize() const;
		const char* c_str() const;

		int indexof(char c) const;
		int indexof(const char* sz) const;

		bool contains(const char* sz) const;
		bool startswith(const char* sz) const;
		bool endswith(const char* sz) const;
		stringsplit split(const char* delim, int limit = 0) const;
		stringsplit commandlinesplit() const;

		string substr(intptr_t start) const;
		string substr(intptr_t start, intptr_t len) const;

		void append(char c);

		void append(const char* sz);
		void append(const char* sz, size_t len);
		void append(const char* sz, size_t start, size_t len);

		void insert(const char* sz, size_t pos);
		void insert(const char* sz, size_t pos, size_t len);
		void remove(size_t pos, size_t len);

		string replace(char find, char replace) const;
		string replace(const char* find, const char* replace) const;

		void setf(const char* format, ...);
		void appendf(const char* format, ...);

		string &operator =(const char* sz);
		string &operator =(const string &str);

		string &operator +=(const char* sz);
		string &operator +=(const string &str);

		string operator +(const char* sz);
		string operator +(const string &str);

		string trim() const;
		string trim(const char* sz) const;

		string tolower() const;
		string toupper() const;

		bool operator ==(const char* sz) const;
		bool operator ==(const string &str) const;

		bool operator !=(const char* sz) const;
		bool operator !=(const string &str) const;

		operator const char*() const;

		char &operator [](int index);
		const char &operator [](int index) const;

		void ensure_memory(size_t size);

	private:
		void resize_memory(size_t size);
	};

	bool operator ==(const char* sz, const string &str);

	string operator +(const char* lhs, const string &rhs);

	string strprintf(const char* format, ...);

	class stringsplit
	{
	private:
		char** m_buffer = nullptr;
		size_t m_length = 0;

	public:
		stringsplit(const char* sz, const char* delim, int limit = 0);
		stringsplit(const char* sz, bool commandLine);
		stringsplit(const stringsplit &copy);
		~stringsplit();

		size_t len() const;
		string operator[](size_t index) const;

	private:
		void add(const char* sz, size_t len);
	};
}

#ifdef S2_IMPL
#include <cstdlib>
#include <cstring>
#include <cstdint>
#include <cassert>
#include <cstdarg>
#include <cstdio>
#include <cctype>

const size_t min_buffer_size = 24;

s2::string::string()
{
	m_length = 0;
	m_buffer = nullptr;
	resize_memory(1);
	m_buffer[0] = '\0';
}

s2::string::string(const char* sz)
	: string(sz, 0, strlen(sz))
{
}

s2::string::string(const char* sz, size_t len)
	: string(sz, 0, len)
{
}

s2::string::string(const char* sz, size_t start, size_t len)
{
	m_length = len;
	m_buffer = nullptr;
	resize_memory(len + 1);
	memcpy(m_buffer + start, sz, len);
	m_buffer[len] = '\0';
}

s2::string::string(const s2::string &str)
	: string(str.m_buffer)
{
}

s2::string::~string()
{
	free(m_buffer);
}

size_t s2::string::len() const
{
	return m_length;
}

size_t s2::string::allocsize() const
{
	return m_allocSize;
}

const char* s2::string::c_str() const
{
	return m_buffer;
}

int s2::string::indexof(char c) const
{
	char* p = m_buffer;
	while (*p != '\0') {
		if (*p == c) {
			return (int)(p - m_buffer);
		}
		p++;
	}
	return -1;
}

int s2::string::indexof(const char* sz) const
{
	char* p = strstr(m_buffer, sz);
	if (p == nullptr) {
		return -1;
	}
	return (int)(p - m_buffer);
}

bool s2::string::contains(const char* sz) const
{
	return strstr(m_buffer, sz) != nullptr;
}

bool s2::string::startswith(const char* sz) const
{
	return strstr(m_buffer, sz) == m_buffer;
}

bool s2::string::endswith(const char* sz) const
{
	return !strcmp(m_buffer + m_length - strlen(sz), sz);
}

s2::stringsplit s2::string::split(const char* delim, int limit) const
{
	return stringsplit(m_buffer, delim, limit);
}

s2::stringsplit s2::string::commandlinesplit() const
{
	return stringsplit(m_buffer, true);
}

s2::string s2::string::substr(intptr_t start) const
{
	if (m_length == 0) {
		return "";
	}
	while (start < 0) {
		start += (intptr_t)m_length;
	}
	if ((size_t)start >= m_length) {
		return "";
	}
	return string(m_buffer + start);
}

s2::string s2::string::substr(intptr_t start, intptr_t len) const
{
	if (m_length == 0) {
		return "";
	}
	while (start < 0) {
		start += (intptr_t)m_length;
	}
	if ((size_t)start >= m_length) {
		return "";
	}
	intptr_t remainder = (intptr_t)strlen(m_buffer) + start;
	if (len > remainder) {
		len = remainder;
	}
	return string(m_buffer + start, len);
}

void s2::string::append(char c)
{
	append(&c, 0, 1);
}

void s2::string::append(const char* sz)
{
	append(sz, 0, strlen(sz));
}

void s2::string::append(const char* sz, size_t len)
{
	append(sz, 0, len);
}

void s2::string::append(const char* sz, size_t start, size_t len)
{
	ensure_memory(m_length + len + 1);
	memcpy(m_buffer + m_length, sz + start, len);
	m_length += len;
	m_buffer[m_length] = '\0';
}

void s2::string::insert(const char* sz, size_t pos)
{
	insert(sz, pos, strlen(sz));
}

void s2::string::insert(const char* sz, size_t pos, size_t len)
{
	ensure_memory(m_length + len + 1);
	memmove(m_buffer + pos + len, m_buffer + pos, m_length - pos);
	memcpy(m_buffer + pos, sz, len);
	m_length += len;
	m_buffer[m_length] = '\0';
}

void s2::string::remove(size_t pos, size_t len)
{
	memmove(m_buffer + pos, m_buffer + pos + len, m_length - pos - len);
	m_length -= len;
	m_buffer[m_length] = '\0';
}

s2::string s2::string::replace(char find, char replace) const
{
	s2::string ret(*this);
	char* p = ret.m_buffer;
	while (*p != '\0') {
		if (*p == find) {
			*p = replace;
		}
		p++;
	}
	return ret;
}

s2::string s2::string::replace(const char* find, const char* replace) const
{
	size_t findlen = strlen(find);
	size_t replacelen = strlen(replace);

	s2::string ret(*this);
	int index = 0;
	while (true) {
		char* p = strstr(ret.m_buffer + index, find);
		if (p == nullptr) {
			break;
		}
		index = (int)(p - ret.m_buffer);

		ret.remove(index, findlen);
		ret.insert(replace, index, replacelen);

		index += (int)replacelen;
	}
	return ret;
}

void s2::string::setf(const char* format, ...)
{
	ensure_memory(min_buffer_size);

	va_list vl;
	va_start(vl, format);
	int len = vsnprintf(m_buffer, m_allocSize, format, vl);
	va_end(vl);

	if (len >= min_buffer_size) {
		ensure_memory(len + 1);

		va_list vl;
		va_start(vl, format);
		vsnprintf(m_buffer, m_allocSize, format, vl);
		va_end(vl);
	}

	m_length = len;
}

void s2::string::appendf(const char* format, ...)
{
	char* buffer = (char*)malloc(min_buffer_size);

	va_list vl;
	va_start(vl, format);
	int len = vsnprintf(buffer, min_buffer_size, format, vl);
	va_end(vl);

	if (len >= min_buffer_size) {
		buffer = (char*)realloc(buffer, len + 1);

		va_list vl;
		va_start(vl, format);
		len = vsnprintf(buffer, len + 1, format, vl);
		va_end(vl);
	}

	append(buffer, 0, len);

	free(buffer);
}

s2::string &s2::string::operator =(const char* sz)
{
	m_length = strlen(sz);
	ensure_memory(m_length + 1);
	memcpy(m_buffer, sz, m_length);
	m_buffer[m_length] = '\0';
	return *this;
}

s2::string &s2::string::operator =(const s2::string &str)
{
	return operator =(str.m_buffer);
}

s2::string &s2::string::operator +=(const char* sz)
{
	append(sz);
	return *this;
}

s2::string &s2::string::operator +=(const s2::string &str)
{
	return operator +=(str.m_buffer);
}

s2::string s2::string::operator +(const char* sz)
{
	return string(*this) += sz;
}

s2::string s2::string::operator +(const string &str)
{
	return string(*this) += str;
}

s2::string s2::string::trim() const
{
	return trim("\n\r\t ");
}

s2::string s2::string::trim(const char* sz) const
{
	if (strlen(sz) == 0) {
		return *this;
	}

	int len = (int)strlen(m_buffer);
	char* p = m_buffer;
	while (*p != '\0') {
		if (strchr(sz, *p) == nullptr) {
			break;
		}
		p++;
	}

	char* pp = m_buffer + (len - 1);
	while (pp > p) {
		if (strchr(sz, *pp) == nullptr) {
			break;
		}
		pp--;
	}

	return string(p, (pp - p) + 1);
}

s2::string s2::string::tolower() const
{
	s2::string ret = *this;
	char* p = ret.m_buffer;
	while (*p != '\0') {
		*p = ::tolower(*p);
		p++;
	}
	return ret;
}

s2::string s2::string::toupper() const
{
	s2::string ret = *this;
	char* p = ret.m_buffer;
	while (*p != '\0') {
		*p = ::toupper(*p);
		p++;
	}
	return ret;
}

bool s2::string::operator ==(const char* sz) const
{
	return !strcmp(m_buffer, sz);
}

bool s2::string::operator ==(const s2::string &str) const
{
	return !strcmp(m_buffer, str.m_buffer);
}

bool s2::string::operator !=(const char* sz) const
{
	return !!strcmp(m_buffer, sz);
}

bool s2::string::operator !=(const string &str) const
{
	return !!strcmp(m_buffer, str.m_buffer);
}

s2::string::operator const char*() const
{
	return m_buffer;
}

char &s2::string::operator [](int index)
{
	return m_buffer[index];
}

const char &s2::string::operator [](int index) const
{
	return m_buffer[index];
}

void s2::string::ensure_memory(size_t size)
{
	if (m_allocSize >= size) {
		return;
	}
	resize_memory(size);
}

void s2::string::resize_memory(size_t size)
{
	m_allocSize = size;
	m_buffer = (char*)realloc(m_buffer, m_allocSize);
}

bool s2::operator ==(const char* sz, const string &str)
{
	return str == sz;
}

s2::string s2::operator +(const char* lhs, const string &rhs)
{
	return string(lhs) += rhs;
}

s2::string s2::strprintf(const char* format, ...)
{
	char* buffer = (char*)malloc(min_buffer_size);

	va_list vl;
	va_start(vl, format);
	int len = vsnprintf(buffer, min_buffer_size, format, vl);
	va_end(vl);

	if (len >= min_buffer_size) {
		buffer = (char*)realloc(buffer, len + 1);

		va_list vl;
		va_start(vl, format);
		len = vsnprintf(buffer, len + 1, format, vl);
		va_end(vl);
	}

	s2::string ret = buffer;
	free(buffer);
	return ret;
}

s2::stringsplit::stringsplit(const char* sz, const char* delim, int limit)
{
	const char* p = sz;
	size_t len = strlen(sz);
	size_t lenDelim = strlen(delim);

	while (*p != '\0') {
		const char* pos = strstr(p, delim);

		if (pos == nullptr || (limit > 0 && m_length + 1 == limit)) {
			add(p, len - (p - sz));
			return;
		}

		add(p, pos - p);
		p = pos + lenDelim;
	}
}

s2::stringsplit::stringsplit(const char* sz, bool commandLine)
{
	const char* p = sz;
	s2::string buffer;
	buffer.ensure_memory(128);
	bool inString = false;

	char c;
	do {
		c = *p;
		char cn = *(p + 1);

		if (c == '\\') {
			buffer.append(cn);
			p++;
			continue;
		}

		if (inString) {
			if (c == '"' && (cn == ' ' || cn == '\0')) {
				inString = false;
				continue;
			}

		} else {
			if (c == '"' && buffer.len() == 0) {
				inString = true;
				continue;
			}

			if (c == ' ' && buffer.len() != 0) {
				add(buffer, buffer.len());
				buffer = "";
				continue;
			}
		}

		buffer.append(c);
	} while (*(++p) != '\0');

	if (buffer.len() > 0) {
		add(buffer, buffer.len());
	}
}

s2::stringsplit::stringsplit(const stringsplit &copy)
{
	for (size_t i = 0; i < copy.m_length; i++) {
		const char* s = copy.m_buffer[i];
		add(s, strlen(s));
	}
}

s2::stringsplit::~stringsplit()
{
	for (size_t i = 0; i < m_length; i++) {
		free(m_buffer[i]);
	}
	free(m_buffer);
}

size_t s2::stringsplit::len() const
{
	return m_length;
}

s2::string s2::stringsplit::operator[](size_t index) const
{
	return m_buffer[index];
}

void s2::stringsplit::add(const char* sz, size_t len)
{
	m_length++;
	m_buffer = (char**)realloc(m_buffer, m_length * sizeof(char*));
	char* p = (char*)malloc(len + 1);
	memcpy(p, sz, len);
	p[len] = '\0';
	m_buffer[m_length - 1] = p;
}
#endif



================================================
File: cd/include/cd.h
================================================
/** \file
 * \brief User API
 * CD - Canvas Draw
 * Tecgraf: Computer Graphics Technology Group, PUC-Rio, Brazil
 * http://www.tecgraf.puc-rio.br/cd	
 * mailto:cd@tecgraf.puc-rio.br
 *
 * See Copyright Notice at the end of this file
 */
 
#ifndef __CD_H
#define __CD_H

#ifdef __cplusplus
extern "C" {
#endif


#define CD_NAME "CD - A 2D Graphics Library"
#define CD_DESCRIPTION "Vector Graphics Toolkit with Device Independent Output"
#define CD_COPYRIGHT "Copyright (C) 1994-2016 Tecgraf/PUC-Rio"
#define CD_VERSION "5.11"              /* bug fixes are reported only by cdVersion functions */
#define CD_VERSION_NUMBER 511000
#define CD_VERSION_DATE "2016/09/30"  /* does not include bug fix releases */

typedef struct _cdContext cdContext;
typedef struct _cdCanvas cdCanvas;
typedef struct _cdCanvas cdState;
typedef struct _cdImage cdImage;

/* client images using bitmap structure */
typedef struct _cdBitmap {
  int w;
  int h;
  int type;
  void *data;
} cdBitmap;


/* library */
char*         cdVersion(void);
char*         cdVersionDate(void);
int           cdVersionNumber(void);

/* canvas init */
cdCanvas*   cdCreateCanvas(cdContext *context, void *data);
cdCanvas*   cdCreateCanvasf(cdContext *context, const char* format, ...);
void        cdKillCanvas(cdCanvas* canvas);

cdContext*  cdCanvasGetContext(cdCanvas* canvas);
int         cdCanvasActivate(cdCanvas* canvas);
void        cdCanvasDeactivate(cdCanvas* canvas);
int         cdUseContextPlus(int use);
void        cdInitContextPlus(void);   /* need an external library */
void        cdFinishContextPlus(void);   /* need an external library */

/* context */
typedef int (*cdCallback)(cdCanvas* canvas, ...);
int cdContextRegisterCallback(cdContext *context, int cb, cdCallback func);
unsigned long cdContextCaps(cdContext *context);
int cdContextIsPlus(cdContext *context);
int cdContextType(cdContext *context);

/* control */
int      cdCanvasSimulate(cdCanvas* canvas, int mode);
void     cdCanvasFlush(cdCanvas* canvas);
void     cdCanvasClear(cdCanvas* canvas);
cdState* cdCanvasSaveState(cdCanvas* canvas);
void     cdCanvasRestoreState(cdCanvas* canvas, cdState* state);
void     cdReleaseState(cdState* state);
void     cdCanvasSetAttribute(cdCanvas* canvas, const char* name, char* data);
void     cdCanvasSetfAttribute(cdCanvas* canvas, const char* name, const char* format, ...);
char*    cdCanvasGetAttribute(cdCanvas* canvas, const char* name);

/* interpretation */
int cdCanvasPlay(cdCanvas* canvas, cdContext *context, int xmin, int xmax, int ymin, int ymax, void *data);

/* coordinate transformation */
void cdCanvasGetSize(cdCanvas* canvas, int *width, int *height, double *width_mm, double *height_mm);
int cdCanvasUpdateYAxis(cdCanvas* canvas, int* y);
double cdfCanvasUpdateYAxis(cdCanvas* canvas, double* y);
int cdCanvasInvertYAxis(cdCanvas* canvas, int y);
double cdfCanvasInvertYAxis(cdCanvas* canvas, double y);
void cdCanvasMM2Pixel(cdCanvas* canvas, double mm_dx, double mm_dy, int *dx, int *dy);
void cdCanvasPixel2MM(cdCanvas* canvas, int dx, int dy, double *mm_dx, double *mm_dy);
void cdfCanvasMM2Pixel(cdCanvas* canvas, double mm_dx, double mm_dy, double *dx, double *dy);
void cdfCanvasPixel2MM(cdCanvas* canvas, double dx, double dy, double *mm_dx, double *mm_dy);
void cdCanvasOrigin(cdCanvas* canvas, int x, int y);
void cdfCanvasOrigin(cdCanvas* canvas, double x, double y);
void cdCanvasGetOrigin(cdCanvas* canvas, int *x, int *y);
void cdfCanvasGetOrigin(cdCanvas* canvas, double *x, double *y);
void cdCanvasTransform(cdCanvas* canvas, const double* matrix);
double* cdCanvasGetTransform(cdCanvas* canvas);
void cdCanvasTransformMultiply(cdCanvas* canvas, const double* matrix);
void cdCanvasTransformRotate(cdCanvas* canvas, double angle);
void cdCanvasTransformScale(cdCanvas* canvas, double sx, double sy);
void cdCanvasTransformTranslate(cdCanvas* canvas, double dx, double dy);
void cdCanvasTransformPoint(cdCanvas* canvas, int x, int y, int *tx, int *ty);
void cdfCanvasTransformPoint(cdCanvas* canvas, double x, double y, double *tx, double *ty);

/* clipping */
int  cdCanvasClip(cdCanvas* canvas, int mode);
void cdCanvasClipArea(cdCanvas* canvas, int xmin, int xmax, int ymin, int ymax);
int  cdCanvasGetClipArea(cdCanvas* canvas, int *xmin, int *xmax, int *ymin, int *ymax);
void cdfCanvasClipArea(cdCanvas* canvas, double xmin, double xmax, double ymin, double ymax);
int  cdfCanvasGetClipArea(cdCanvas* canvas, double *xmin, double *xmax, double *ymin, double *ymax);

/* clipping region */
int  cdCanvasIsPointInRegion(cdCanvas* canvas, int x, int y);
void cdCanvasOffsetRegion(cdCanvas* canvas, int x, int y);
void cdCanvasGetRegionBox(cdCanvas* canvas, int *xmin, int *xmax, int *ymin, int *ymax);
int  cdCanvasRegionCombineMode(cdCanvas* canvas, int mode);

/* primitives */
void cdCanvasPixel(cdCanvas* canvas, int x, int y, long color);
void cdCanvasMark(cdCanvas* canvas, int x, int y);
void cdfCanvasPixel(cdCanvas* canvas, double x, double y, long color);
void cdfCanvasMark(cdCanvas* canvas, double x, double y);

void cdCanvasBegin(cdCanvas* canvas, int mode);
void cdCanvasPathSet(cdCanvas* canvas, int action);
void cdCanvasEnd(cdCanvas* canvas);

void cdCanvasLine(cdCanvas* canvas, int x1, int y1, int x2, int y2);
void cdCanvasVertex(cdCanvas* canvas, int x, int y);
void cdCanvasRect(cdCanvas* canvas, int xmin, int xmax, int ymin, int ymax);
void cdCanvasBox(cdCanvas* canvas, int xmin, int xmax, int ymin, int ymax);
void cdCanvasArc(cdCanvas* canvas, int xc, int yc, int w, int h, double angle1, double angle2);
void cdCanvasSector(cdCanvas* canvas, int xc, int yc, int w, int h, double angle1, double angle2);
void cdCanvasChord(cdCanvas* canvas, int xc, int yc, int w, int h, double angle1, double angle2);
void cdCanvasText(cdCanvas* canvas, int x, int y, const char* s);

void cdfCanvasLine(cdCanvas* canvas, double x1, double y1, double x2, double y2);
void cdfCanvasVertex(cdCanvas* canvas, double x, double y);
void cdfCanvasRect(cdCanvas* canvas, double xmin, double xmax, double ymin, double ymax);
void cdfCanvasBox(cdCanvas* canvas, double xmin, double xmax, double ymin, double ymax);
void cdfCanvasArc(cdCanvas* canvas, double xc, double yc, double w, double h, double angle1, double angle2);
void cdfCanvasSector(cdCanvas* canvas, double xc, double yc, double w, double h, double angle1, double angle2);
void cdfCanvasChord(cdCanvas* canvas, double xc, double yc, double w, double h, double angle1, double angle2);
void cdfCanvasText(cdCanvas* canvas, double x, double y, const char* s);

/* attributes */
void cdCanvasSetBackground(cdCanvas* canvas, long color);
void cdCanvasSetForeground(cdCanvas* canvas, long color);
long cdCanvasBackground(cdCanvas* canvas, long color);
long cdCanvasForeground(cdCanvas* canvas, long color);
int  cdCanvasBackOpacity(cdCanvas* canvas, int opacity);
int  cdCanvasWriteMode(cdCanvas* canvas, int mode);
int  cdCanvasLineStyle(cdCanvas* canvas, int style);
void cdCanvasLineStyleDashes(cdCanvas* canvas, const int* dashes, int count);
int  cdCanvasLineWidth(cdCanvas* canvas, int width);
int  cdCanvasLineJoin(cdCanvas* canvas, int join);
int  cdCanvasLineCap(cdCanvas* canvas, int cap);
int  cdCanvasInteriorStyle(cdCanvas* canvas, int style);
int  cdCanvasHatch(cdCanvas* canvas, int style);
void cdCanvasStipple(cdCanvas* canvas, int w, int h, const unsigned char* stipple);
unsigned char* cdCanvasGetStipple(cdCanvas* canvas, int *n, int *m);
void   cdCanvasPattern(cdCanvas* canvas, int w, int h, long const int *pattern);
long*  cdCanvasGetPattern(cdCanvas* canvas, int* n, int* m);
int    cdCanvasFillMode(cdCanvas* canvas, int mode);
int    cdCanvasFont(cdCanvas* canvas, const char* type_face, int style, int size);
void   cdCanvasGetFont(cdCanvas* canvas, char *type_face, int *style, int *size);
char*  cdCanvasNativeFont(cdCanvas* canvas, const char* font);
int    cdCanvasTextAlignment(cdCanvas* canvas, int alignment);
double cdCanvasTextOrientation(cdCanvas* canvas, double angle);
int    cdCanvasMarkType(cdCanvas* canvas, int type);
int    cdCanvasMarkSize(cdCanvas* canvas, int size);

/* vector text */
void cdCanvasVectorText(cdCanvas* canvas, int x, int y, const char* s);
void cdCanvasMultiLineVectorText(cdCanvas* canvas, int x, int y, const char* s);

/* vector text attributes */
char* cdCanvasVectorFont(cdCanvas* canvas, const char *filename);
void  cdCanvasVectorTextDirection(cdCanvas* canvas, int x1, int y1, int x2, int y2);
double* cdCanvasVectorTextTransform(cdCanvas* canvas, const double* matrix);
void  cdCanvasVectorTextSize(cdCanvas* canvas, int size_x, int size_y, const char* s);
int   cdCanvasVectorCharSize(cdCanvas* canvas, int size);
void  cdCanvasVectorFontSize(cdCanvas* canvas, double size_x, double size_y);
void  cdCanvasGetVectorFontSize(cdCanvas* canvas, double *size_x, double *size_y);

/* vector text properties */
void cdCanvasGetVectorTextSize(cdCanvas* canvas, const char* s, int *x, int *y);
void cdCanvasGetVectorTextBounds(cdCanvas* canvas, const char* s, int x, int y, int *rect);
void cdCanvasGetVectorTextBox(cdCanvas* canvas, int x, int y, const char *s, int *xmin, int *xmax, int *ymin, int *ymax);

void cdfCanvasVectorTextDirection(cdCanvas* canvas, double x1, double y1, double x2, double y2);
void cdfCanvasVectorTextSize(cdCanvas* canvas, double size_x, double size_y, const char* s);
void cdfCanvasGetVectorTextSize(cdCanvas* canvas, const char* s, double *x, double *y);
double cdfCanvasVectorCharSize(cdCanvas* canvas, double size);
void cdfCanvasVectorText(cdCanvas* canvas, double x, double y, const char* s);
void cdfCanvasMultiLineVectorText(cdCanvas* canvas, double x, double y, const char* s);
void cdfCanvasGetVectorTextBounds(cdCanvas* canvas, const char* s, double x, double y, double *rect);
void cdfCanvasGetVectorTextBox(cdCanvas* canvas, double x, double y, const char *s, double *xmin, double *xmax, double *ymin, double *ymax);

/* properties */
void cdCanvasGetFontDim(cdCanvas* canvas, int *max_width, int *height, int *ascent, int *descent);
void cdCanvasGetTextSize(cdCanvas* canvas, const char* s, int *width, int *height);
void cdCanvasGetTextBox(cdCanvas* canvas, int x, int y, const char* s, int *xmin, int *xmax, int *ymin, int *ymax);
void cdfCanvasGetTextBox(cdCanvas* canvas, double x, double y, const char *s, double *xmin, double *xmax, double *ymin, double *ymax);
void cdCanvasGetTextBounds(cdCanvas* canvas, int x, int y, const char* s, int *rect);
void cdfCanvasGetTextBounds(cdCanvas* canvas, double x, double y, const char *s, double *rect);
int  cdCanvasGetColorPlanes(cdCanvas* canvas);

/* color */
void cdCanvasPalette(cdCanvas* canvas, int n, const long *palette, int mode);

/* client images */
void cdCanvasGetImageRGB(cdCanvas* canvas, unsigned char* r, unsigned char* g, unsigned char* b, int x, int y, int iw, int ih);

void cdCanvasPutImageRectRGB(cdCanvas* canvas, int iw, int ih, const unsigned char* r, const unsigned char* g, const unsigned char* b, int x, int y, int w, int h, int xmin, int xmax, int ymin, int ymax);
void cdCanvasPutImageRectRGBA(cdCanvas* canvas, int iw, int ih, const unsigned char* r, const unsigned char* g, const unsigned char* b, const unsigned char* a, int x, int y, int w, int h, int xmin, int xmax, int ymin, int ymax);
void cdCanvasPutImageRectMap(cdCanvas* canvas, int iw, int ih, const unsigned char* index, const long* colors, int x, int y, int w, int h, int xmin, int xmax, int ymin, int ymax);

void cdfCanvasPutImageRectRGB(cdCanvas* canvas, int iw, int ih, const unsigned char* r, const unsigned char* g, const unsigned char* b, double x, double y, double w, double h, int xmin, int xmax, int ymin, int ymax);
void cdfCanvasPutImageRectRGBA(cdCanvas* canvas, int iw, int ih, const unsigned char* r, const unsigned char* g, const unsigned char* b, const unsigned char* a, double x, double y, double w, double h, int xmin, int xmax, int ymin, int ymax);
void cdfCanvasPutImageRectMap(cdCanvas* canvas, int iw, int ih, const unsigned char* index, const long* colors, double x, double y, double w, double h, int xmin, int xmax, int ymin, int ymax);

/* server images - deprecated (use double buffer drivers) */
cdImage* cdCanvasCreateImage(cdCanvas* canvas, int w, int h);
void cdKillImage(cdImage* image);
void cdCanvasGetImage(cdCanvas* canvas, cdImage* image, int x, int y);
void cdCanvasPutImageRect(cdCanvas* canvas, cdImage* image, int x, int y, int xmin, int xmax, int ymin, int ymax);
void cdCanvasScrollArea(cdCanvas* canvas, int xmin, int xmax, int ymin, int ymax, int dx, int dy);

/* bitmap - deprecated (use imImage) */
cdBitmap* cdCreateBitmap(int w, int h, int type);
cdBitmap* cdInitBitmap(int w, int h, int type, ...);
void cdKillBitmap(cdBitmap* bitmap);
unsigned char* cdBitmapGetData(cdBitmap* bitmap, int dataptr);
void cdBitmapSetRect(cdBitmap* bitmap, int xmin, int xmax, int ymin, int ymax);
void cdCanvasPutBitmap(cdCanvas* canvas, cdBitmap* bitmap, int x, int y, int w, int h);
void cdCanvasGetBitmap(cdCanvas* canvas, cdBitmap* bitmap, int x, int y);
void cdBitmapRGB2Map(cdBitmap* bitmap_rgb, cdBitmap* bitmap_map);

/* color */
long cdEncodeColor(unsigned char red, unsigned char green, unsigned char blue);
long cdEncodeColorAlpha(unsigned char red, unsigned char green, unsigned char blue, unsigned char alpha);
long cdEncodeAlpha(long color, unsigned char alpha);
void cdDecodeColor(long color, unsigned char* red, unsigned char* green, unsigned char* blue);
void cdDecodeColorAlpha(long color, unsigned char* red, unsigned char* green, unsigned char* blue, unsigned char* alpha);
unsigned char cdDecodeAlpha(long color);

#define cdAlpha(_)    (unsigned char)(~(((_) >> 24) & 0xFF))
#define cdReserved(_) (unsigned char)(((_) >> 24) & 0xFF)
#define cdRed(_)      (unsigned char)(((_) >> 16) & 0xFF)
#define cdGreen(_)    (unsigned char)(((_) >>  8) & 0xFF)
#define cdBlue(_)     (unsigned char)(((_) >>  0) & 0xFF)

/* client image color conversion */
void cdRGB2Map(int width, int height, const unsigned char* red, const unsigned char* green, const unsigned char* blue, unsigned char* index, int pal_size, long *color);


/* CD Values */

#define CD_QUERY -1             /* query value */

enum {                        /* bitmap type */
 CD_RGB,                      /* these definitions are compatible with the IM library */
 CD_MAP,
 CD_RGBA = 0x100 
};

enum {                         /* bitmap data */
 CD_IRED,
 CD_IGREEN,
 CD_IBLUE,
 CD_IALPHA,
 CD_INDEX,
 CD_COLORS
};

enum {                          /* status report */
 CD_ERROR = -1,
 CD_OK    =  0
};

enum {                          /* clip mode */
 CD_CLIPOFF,
 CD_CLIPAREA,
 CD_CLIPPOLYGON,
 CD_CLIPREGION
};

enum {                          /* region combine mode */
 CD_UNION,
 CD_INTERSECT,
 CD_DIFFERENCE,
 CD_NOTINTERSECT
};

enum {                          /* polygon mode (begin...end) */
 CD_FILL,
 CD_OPEN_LINES,
 CD_CLOSED_LINES,
 CD_CLIP,
 CD_BEZIER,
 CD_REGION,
 CD_PATH
};

#define CD_POLYCUSTOM 10

enum {                          /* path actions */
 CD_PATH_NEW,
 CD_PATH_MOVETO,
 CD_PATH_LINETO,
 CD_PATH_ARC,
 CD_PATH_CURVETO,
 CD_PATH_CLOSE,
 CD_PATH_FILL,
 CD_PATH_STROKE,
 CD_PATH_FILLSTROKE,
 CD_PATH_CLIP
};

enum {                          /* fill mode */
 CD_EVENODD,
 CD_WINDING
};

enum {                          /* line join  */
 CD_MITER,
 CD_BEVEL,
 CD_ROUND
};  

enum {                          /* line cap  */
 CD_CAPFLAT,  
 CD_CAPSQUARE,
 CD_CAPROUND
};  

enum {                          /* background opacity mode */
 CD_OPAQUE,
 CD_TRANSPARENT
};

enum {                          /* write mode */
 CD_REPLACE,
 CD_XOR,
 CD_NOT_XOR
};

enum {                          /* color allocation mode (palette) */
 CD_POLITE,
 CD_FORCE
};

enum {                          /* line style */
 CD_CONTINUOUS,
 CD_DASHED,
 CD_DOTTED,
 CD_DASH_DOT,
 CD_DASH_DOT_DOT,
 CD_CUSTOM
};

enum {                          /* marker type */
 CD_PLUS,
 CD_STAR,
 CD_CIRCLE,
 CD_X,
 CD_BOX,
 CD_DIAMOND,
 CD_HOLLOW_CIRCLE,
 CD_HOLLOW_BOX,
 CD_HOLLOW_DIAMOND
};

enum {                          /* hatch type */
 CD_HORIZONTAL,
 CD_VERTICAL,
 CD_FDIAGONAL,
 CD_BDIAGONAL,
 CD_CROSS,
 CD_DIAGCROSS
};

enum {                          /* interior style */
 CD_SOLID,
 CD_HATCH,
 CD_STIPPLE,
 CD_PATTERN,
 CD_HOLLOW
};

enum {                          /* text alignment */
 CD_NORTH,
 CD_SOUTH,
 CD_EAST,
 CD_WEST,
 CD_NORTH_EAST,
 CD_NORTH_WEST,
 CD_SOUTH_EAST,
 CD_SOUTH_WEST,
 CD_CENTER,
 CD_BASE_LEFT,
 CD_BASE_CENTER,
 CD_BASE_RIGHT
};

enum {                          /* style */
 CD_PLAIN  = 0,
 CD_BOLD   = 1,
 CD_ITALIC = 2,
 CD_UNDERLINE = 4,
 CD_STRIKEOUT = 8
};

#define CD_BOLD_ITALIC (CD_BOLD|CD_ITALIC)  /* compatibility name */

enum {                          /* some font sizes */
 CD_SMALL    =  8,
 CD_STANDARD = 12,
 CD_LARGE    = 18
};

/* Context Capabilities */
#define CD_CAP_NONE             0x00000000
#define CD_CAP_FLUSH            0x00000001
#define CD_CAP_CLEAR            0x00000002
#define CD_CAP_PLAY             0x00000004
#define CD_CAP_YAXIS            0x00000008
#define CD_CAP_CLIPAREA         0x00000010
#define CD_CAP_CLIPPOLY         0x00000020
#define CD_CAP_REGION           0x00000040
#define CD_CAP_RECT             0x00000080
#define CD_CAP_CHORD            0x00000100
#define CD_CAP_IMAGERGB         0x00000200
#define CD_CAP_IMAGERGBA        0x00000400
#define CD_CAP_IMAGEMAP         0x00000800
#define CD_CAP_GETIMAGERGB      0x00001000
#define CD_CAP_IMAGESRV         0x00002000
#define CD_CAP_BACKGROUND       0x00004000
#define CD_CAP_BACKOPACITY      0x00008000
#define CD_CAP_WRITEMODE        0x00010000
#define CD_CAP_LINESTYLE        0x00020000
#define CD_CAP_LINEWITH         0x00040000
#define CD_CAP_FPRIMTIVES       0x00080000
#define CD_CAP_HATCH            0x00100000
#define CD_CAP_STIPPLE          0x00200000
#define CD_CAP_PATTERN          0x00400000
#define CD_CAP_FONT             0x00800000
#define CD_CAP_FONTDIM          0x01000000
#define CD_CAP_TEXTSIZE         0x02000000
#define CD_CAP_TEXTORIENTATION  0x04000000
#define CD_CAP_PALETTE          0x08000000
#define CD_CAP_LINECAP          0x10000000
#define CD_CAP_LINEJOIN         0x20000000
#define CD_CAP_PATH             0x40000000
#define CD_CAP_BEZIER           0x80000000
#define CD_CAP_ALL              0xFFFFFFFF

/* Context Types */
enum { 
  CD_CTX_WINDOW, 
  CD_CTX_DEVICE, 
  CD_CTX_IMAGE,
  CD_CTX_FILE
};

/* cdPlay definitions */
#define CD_SIZECB 0        /* size callback */
typedef int(*cdSizeCB)(cdCanvas *canvas, int w, int h, double w_mm, double h_mm);
#define CD_ABORT 1
#define CD_CONTINUE 0

/* simulation flags */
#define CD_SIM_NONE         0x0000
#define CD_SIM_LINE         0x0001
#define CD_SIM_RECT         0x0002
#define CD_SIM_BOX          0x0004
#define CD_SIM_ARC          0x0008
#define CD_SIM_SECTOR       0x0010
#define CD_SIM_CHORD        0x0020
#define CD_SIM_POLYLINE     0x0040
#define CD_SIM_POLYGON      0x0080
#define CD_SIM_TEXT         0x0100
#define CD_SIM_ALL          0xFFFF

#define CD_SIM_LINES (CD_SIM_LINE | CD_SIM_RECT | CD_SIM_ARC | CD_SIM_POLYLINE)
#define CD_SIM_FILLS (CD_SIM_BOX | CD_SIM_SECTOR | CD_SIM_CHORD | CD_SIM_POLYGON)

/* some predefined colors for convenience */
#define  CD_RED           0xFF0000L   /* 255,  0,  0 */
#define  CD_DARK_RED      0x800000L   /* 128,  0,  0 */
#define  CD_GREEN         0x00FF00L   /*   0,255,  0 */
#define  CD_DARK_GREEN    0x008000L   /*   0,128,  0 */
#define  CD_BLUE          0x0000FFL   /*   0,  0,255 */
#define  CD_DARK_BLUE     0x000080L   /*   0,  0,128 */

#define  CD_YELLOW        0xFFFF00L   /* 255,255,  0 */
#define  CD_DARK_YELLOW   0x808000L   /* 128,128,  0 */
#define  CD_MAGENTA       0xFF00FFL   /* 255,  0,255 */
#define  CD_DARK_MAGENTA  0x800080L   /* 128,  0,128 */
#define  CD_CYAN          0x00FFFFL   /*   0,255,255 */
#define  CD_DARK_CYAN     0x008080L   /*   0,128,128 */

#define  CD_WHITE         0xFFFFFFL   /* 255,255,255 */
#define  CD_BLACK         0x000000L   /*   0,  0,  0 */

#define  CD_DARK_GRAY     0x808080L   /* 128,128,128 */
#define  CD_GRAY          0xC0C0C0L   /* 192,192,192 */

/* some usefull conversion factors */
#define CD_MM2PT     2.834645669   /* milimeters to points (pt = CD_MM2PT * mm) */
#define CD_RAD2DEG  57.295779513   /* radians to degrees (deg = CD_RAD2DEG * rad) */
#define CD_DEG2RAD  0.01745329252  /* degrees to radians (rad = CD_DEG2RAD * deg) */

/* paper sizes */
enum {
  CD_A0,
  CD_A1,
  CD_A2,
  CD_A3,
  CD_A4,
  CD_A5,
  CD_LETTER,
  CD_LEGAL
};


#ifdef __cplusplus
}
#endif



/******************************************************************************
Copyright (C) 1994-2016 Tecgraf/PUC-Rio.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
******************************************************************************/

#endif /* ifndef CD_H */




================================================
File: cd/include/cd_canvas.hpp
================================================
/** \file
 * \brief Canvas Class 
 *
 * DEPRECATED API. USE NAMESPACE BASED CLASSES.
 *
 * See Copyright Notice in cd.h
 */
 
#ifndef __CD_CANVAS_HPP
#define __CD_CANVAS_HPP

#include "cd.h"
#include "wd.h"

class cdCanvasC
{
  cdCanvas* canvas;

  cdCanvasC() {};

public:

/* canvas init */
  cdCanvasC(cdCanvas* _canvas) 
    { this->canvas = _canvas; }

  ~cdCanvasC()
    { cdKillCanvas(this->canvas); }

cdContext*  GetContext()
  { return cdCanvasGetContext(canvas); }
int         Activate()
  { return cdCanvasActivate(canvas); }
void        Deactivate()
  { cdCanvasDeactivate(canvas); }

/* control */
int      Simulate(int mode)
  { return cdCanvasSimulate(canvas, mode); }
void     Flush()
  { cdCanvasFlush(canvas); }
void     Clear()
  { cdCanvasClear(canvas); }
cdState* SaveState()
  { return cdCanvasSaveState(canvas); }
void     RestoreState(cdState* state)
  { cdCanvasRestoreState(canvas, state); }
void     SetAttribute(const char* name, char* data)
  { cdCanvasSetAttribute(canvas, name, data); }
char*    GetAttribute(const char* name)
  { return cdCanvasGetAttribute(canvas, name); }

/* interpretation */
int  Play(cdContext *context, int xmin, int xmax, int ymin, int ymax, void *data)
  { return cdCanvasPlay(canvas, context, xmin, xmax, ymin, ymax, data); }

/* coordinate transformation */
void GetSize(int *width, int *height, double *width_mm, double *height_mm)
  { cdCanvasGetSize(canvas, width, height, width_mm, height_mm); }
int UpdateYAxis(int* y)
  { return cdCanvasUpdateYAxis(canvas, y); }
void MM2Pixel(double mm_dx, double mm_dy, int *dx, int *dy)
  { cdCanvasMM2Pixel(canvas, mm_dx, mm_dy, dx, dy); }
void Pixel2MM(int dx, int dy, double *mm_dx, double *mm_dy)
  { cdCanvasPixel2MM(canvas, dx, dy, mm_dx, mm_dy); }
void MM2Pixel(double mm_dx, double mm_dy, double *dx, double *dy)
  { cdfCanvasMM2Pixel(canvas, mm_dx, mm_dy, dx, dy); }
void Pixel2MM(double dx, double dy, double *mm_dx, double *mm_dy)
  { cdfCanvasPixel2MM(canvas, dx, dy, mm_dx, mm_dy); }
void Origin(int x, int y)
  { cdCanvasOrigin(canvas, x, y); }
void Origin(double x, double y)
  { cdfCanvasOrigin(canvas, x, y); }
void GetOrigin(int *x, int *y)
  { cdCanvasGetOrigin(canvas, x, y); }
void GetOrigin(double *x, double *y)
  { cdfCanvasGetOrigin(canvas, x, y); }

/* clipping */
int  Clip(int mode)
  { return cdCanvasClip(canvas, mode); }
void ClipArea(int xmin, int xmax, int ymin, int ymax)
  { cdCanvasClipArea(canvas, xmin, xmax, ymin, ymax); }
int  GetClipArea(int *xmin, int *xmax, int *ymin, int *ymax)
  { return cdCanvasGetClipArea(canvas, xmin, xmax, ymin, ymax); }
void ClipArea(double xmin, double xmax, double ymin, double ymax)
  { cdfCanvasClipArea(canvas, xmin, xmax, ymin, ymax); }
int  GetClipArea(double *xmin, double *xmax, double *ymin, double *ymax)
  { return cdfCanvasGetClipArea(canvas, xmin, xmax, ymin, ymax); }

/* clipping region */
int  IsPointInRegion(int x, int y)
  { return cdCanvasIsPointInRegion(canvas, x, y); }
void OffsetRegion(int x, int y)
  { cdCanvasOffsetRegion(canvas, x, y); }
void GetRegionBox(int *xmin, int *xmax, int *ymin, int *ymax)
  { cdCanvasGetRegionBox(canvas, xmin, xmax, ymin, ymax); }
int  RegionCombineMode(int mode)
  { return cdCanvasRegionCombineMode(canvas, mode); }

/* primitives */
void Pixel(int x, int y, long color)
  { cdCanvasPixel(canvas, x, y,  color); }
void Mark(int x, int y)
  { cdCanvasMark(canvas, x, y); }

void Line(int x1, int y1, int x2, int y2)
  { cdCanvasLine(canvas, x1, y1, x2, y2); }
void Begin(int mode)
  { cdCanvasBegin(canvas, mode); }
void Vertex(int x, int y)
  { cdCanvasVertex(canvas, x, y); }
void End()
  { cdCanvasEnd(canvas); }
void Rect(int xmin, int xmax, int ymin, int ymax)
  { cdCanvasRect(canvas, xmin, xmax, ymin, ymax); }
void Box(int xmin, int xmax, int ymin, int ymax)
  { cdCanvasBox(canvas, xmin, xmax, ymin, ymax); }
void Arc(int xc, int yc, int w, int h, double angle1, double angle2)
  { cdCanvasArc(canvas, xc, yc, w, h, angle1, angle2); }
void Sector(int xc, int yc, int w, int h, double angle1, double angle2)
  { cdCanvasSector(canvas, xc, yc, w, h, angle1, angle2); }
void Chord(int xc, int yc, int w, int h, double angle1, double angle2)
  { cdCanvasChord(canvas, xc, yc, w, h, angle1, angle2); }
void Text(int x, int y, const char* s)
  { cdCanvasText(canvas, x, y, s); }

void Line(double x1, double y1, double x2, double y2)
  { cdfCanvasLine(canvas, x1, y1, x2, y2); }
void Vertex(double x, double y)
  { cdfCanvasVertex(canvas, x, y); }
void Rect(double xmin, double xmax, double ymin, double ymax)
  { cdfCanvasRect(canvas, xmin, xmax, ymin, ymax); }
void Box(double xmin, double xmax, double ymin, double ymax)
  { cdfCanvasBox(canvas, xmin, xmax, ymin, ymax); }
void Arc(double xc, double yc, double w, double h, double angle1, double angle2)
  { cdfCanvasArc(canvas, xc, yc, w, h, angle1, angle2); }
void Sector(double xc, double yc, double w, double h, double angle1, double angle2)
  { cdfCanvasSector(canvas, xc, yc, w, h, angle1, angle2); }
void Chord(double xc, double yc, double w, double h, double angle1, double angle2)
  { cdfCanvasChord(canvas, xc, yc, w, h, angle1, angle2); }
void Text(double x, double y, const char* s)
  { cdfCanvasText(canvas, x, y, s); }

/* attributes */
long Background(long color)
  { return cdCanvasBackground(canvas,  color); }
long Foreground(long color)
  { return cdCanvasForeground(canvas,  color); }
int  BackOpacity(int opacity)
  { return cdCanvasBackOpacity(canvas, opacity); }
int  WriteMode(int mode)
  { return cdCanvasWriteMode(canvas, mode); }
int  LineStyle(int style)
  { return cdCanvasLineStyle(canvas, style); }
void LineStyleDashes(const int* dashes, int count)
  { cdCanvasLineStyleDashes(canvas, dashes, count); }
int  LineWidth(int width)
  { return cdCanvasLineWidth(canvas, width); }
int  LineJoin(int join)
  { return cdCanvasLineJoin(canvas, join); }
int  LineCap(int cap)
  { return cdCanvasLineCap(canvas, cap); }
int  InteriorStyle(int style)
  { return cdCanvasInteriorStyle(canvas, style); }
int  Hatch(int style)
  { return cdCanvasHatch(canvas, style); }
void Stipple(int w, int h, const unsigned char* stipple)
  { cdCanvasStipple(canvas, w, h, stipple); }
unsigned char* GetStipple(int *n, int *m)
  { return cdCanvasGetStipple(canvas, n, m); }
void   Pattern(int w, int h, long const int *pattern)
  { cdCanvasPattern(canvas, w, h, pattern); }
long*  GetPattern(int* n, int* m)
  { return cdCanvasGetPattern(canvas, n, m); }
int    FillMode(int mode)
  { return cdCanvasFillMode(canvas, mode); }
int   Font(const char* type_face, int style, int size)
  { return cdCanvasFont(canvas, type_face, style, size); }
void   GetFont(char *type_face, int *style, int *size)
  { cdCanvasGetFont(canvas, type_face, style, size); }
char*  NativeFont(const char* font)
  { return cdCanvasNativeFont(canvas, font); }
int    TextAlignment(int alignment)
  { return cdCanvasTextAlignment(canvas, alignment); }
double TextOrientation(double angle)
  { return cdCanvasTextOrientation(canvas, angle); }
int    MarkType(int type)
  { return cdCanvasMarkType(canvas, type); }
int    MarkSize(int size)
  { return cdCanvasMarkSize(canvas, size); }

/* vector text */
void VectorText(int x, int y, const char* s)
  { cdCanvasVectorText(canvas, x, y, s); }
void MultiLineVectorText(int x, int y, const char* s)
  { cdCanvasMultiLineVectorText(canvas, x, y, s); }

/* vector text attributes */
char *VectorFont(const char *filename)
  { return cdCanvasVectorFont(canvas, filename); }
void VectorTextDirection(int x1, int y1, int x2, int y2)
  { cdCanvasVectorTextDirection(canvas, x1, y1, x2, y2); }
double* VectorTextTransform(const double* matrix)
  { return cdCanvasVectorTextTransform(canvas, matrix); }
void VectorTextSize(int size_x, int size_y, const char* s)
  { cdCanvasVectorTextSize(canvas, size_x, size_y, s); }
int  VectorCharSize(int size)
  { return cdCanvasVectorCharSize(canvas, size); }


/* vector text properties */
void GetVectorTextSize(const char* s, int *x, int *y)
  { cdCanvasGetVectorTextSize(canvas, s, x, y); }
void GetVectorTextBounds(const char* s, int x, int y, int *rect)
  { cdCanvasGetVectorTextBounds(canvas, s, x, y, rect); }

/* properties */
void GetFontDim(int *max_width, int *height, int *ascent, int *descent)
  { cdCanvasGetFontDim(canvas, max_width, height, ascent, descent); }
void GetTextSize(const char* s, int *width, int *height)
  { cdCanvasGetTextSize(canvas, s, width, height); }
void GetTextBox(int x, int y, const char* s, int *xmin, int *xmax, int *ymin, int *ymax)
  { cdCanvasGetTextBox(canvas, x, y, s, xmin, xmax, ymin, ymax); }
void GetTextBounds(int x, int y, const char* s, int *rect)
  { cdCanvasGetTextBounds(canvas, x, y, s, rect); }
int  GetColorPlanes()
  { return cdCanvasGetColorPlanes(canvas); }

/* color */
void Palette(int n, const long *palette, int mode)
  { cdCanvasPalette(canvas, n, palette, mode); }

/* client images */
void GetImageRGB(unsigned char* r, unsigned char* g, unsigned char* b, int x, int y, int w, int h)
  { cdCanvasGetImageRGB(canvas, r, g, b, x, y, w, h); }
void PutImageRectRGB(int iw, int ih, const unsigned char* r, const unsigned char* g, const unsigned char* b, int x, int y, int w, int h, int xmin, int xmax, int ymin, int ymax)
  { cdCanvasPutImageRectRGB(canvas, iw, ih, r, g, b, x, y, w, h, xmin, xmax, ymin, ymax); }
void PutImageRectRGBA(int iw, int ih, const unsigned char* r, const unsigned char* g, const unsigned char* b, const unsigned char* a, int x, int y, int w, int h, int xmin, int xmax, int ymin, int ymax)
  { cdCanvasPutImageRectRGBA(canvas, iw, ih, r, g, b, a, x, y, w, h, xmin, xmax, ymin, ymax); }
void PutImageRectMap(int iw, int ih, const unsigned char* index, const long* colors, int x, int y, int w, int h, int xmin, int xmax, int ymin, int ymax)
  { cdCanvasPutImageRectMap(canvas, iw, ih, index, colors, x, y, w, h, xmin, xmax, ymin, ymax); }

/* server images */
cdImage* CreateImage(int w, int h)
  { return cdCanvasCreateImage(canvas, w, h); }
void GetImage(cdImage* image, int x, int y)
  { cdCanvasGetImage(canvas, image, x, y); }
void PutImageRect(cdImage* image, int x, int y, int xmin, int xmax, int ymin, int ymax)
  { cdCanvasPutImageRect(canvas, image, x, y, xmin, xmax, ymin, ymax); }
void ScrollArea(int xmin, int xmax, int ymin, int ymax, int dx, int dy)
  { cdCanvasScrollArea(canvas, xmin, xmax, ymin, ymax, dx, dy); }

void PutBitmap(cdBitmap* bitmap, int x, int y, int w, int h)
  { cdCanvasPutBitmap(canvas, bitmap, x, y, w, h); }
void GetBitmap(cdBitmap* bitmap, int x, int y)
  { cdCanvasGetBitmap(canvas, bitmap, x, y); }

/* coordinate transformation */
void wWindow(double xmin, double xmax, double  ymin, double ymax)
  { wdCanvasWindow(canvas, xmin, xmax, ymin, ymax); }
void wGetWindow(double *xmin, double  *xmax,  double  *ymin, double *ymax)
  { wdCanvasGetWindow(canvas, xmin, xmax, ymin, ymax); }
void wViewport(int xmin, int xmax, int ymin, int ymax)
  { wdCanvasViewport(canvas, xmin, xmax, ymin, ymax); }
void wGetViewport(int *xmin, int  *xmax,  int  *ymin, int *ymax)
  { wdCanvasGetViewport(canvas, xmin, xmax, ymin, ymax); }
void wWorld2Canvas(double xw, double yw, int *xv, int *yv)
  { wdCanvasWorld2Canvas(canvas, xw, yw, xv, yv); }
void wWorld2CanvasSize(double hw, double vw, int *hv, int *vv)
  { wdCanvasWorld2CanvasSize(canvas, hw, vw, hv, vv); }
void wCanvas2World(int xv, int yv, double *xw, double *yw)
  { wdCanvasCanvas2World(canvas, xv, yv, xw, yw); }

void wClipArea(double xmin, double xmax, double  ymin, double ymax)
  { wdCanvasClipArea(canvas, xmin, xmax, ymin, ymax); }
int  wGetClipArea(double *xmin, double *xmax, double *ymin, double *ymax)
  { return wdCanvasGetClipArea(canvas, xmin, xmax, ymin, ymax); }
int  wIsPointInRegion(double x, double y)
  { return wdCanvasIsPointInRegion(canvas, x, y); }
void wOffsetRegion(double x, double y)
  { wdCanvasOffsetRegion(canvas, x, y); }
void wGetRegionBox(double *xmin, double *xmax, double *ymin, double *ymax)
  { wdCanvasGetRegionBox(canvas, xmin, xmax, ymin, ymax); }

/* primitives */
void wPixel(double x, double y, long color)
  { wdCanvasPixel(canvas, x, y,  color); }
void wMark(double x, double y)
  { wdCanvasMark(canvas, x, y); }
void wLine(double x1, double y1, double x2, double y2)
  { wdCanvasLine(canvas, x1, y1, x2, y2); }
void wVertex(double x, double y)
  { wdCanvasVertex(canvas, x, y); }
void wRect(double xmin, double xmax, double ymin, double ymax)
  { wdCanvasRect(canvas, xmin, xmax, ymin, ymax); }
void wBox(double xmin, double xmax, double ymin, double ymax)
  { wdCanvasBox(canvas, xmin, xmax, ymin, ymax); }
void wArc(double xc, double yc, double w, double h, double angle1, double angle2)
  { wdCanvasArc(canvas, xc, yc, w, h, angle1, angle2); }
void wSector(double xc, double yc, double w, double h, double angle1, double angle2)
  { wdCanvasSector(canvas, xc, yc, w, h, angle1, angle2); }
void wChord(double xc, double yc, double w, double h, double angle1, double angle2)
  { wdCanvasChord(canvas, xc, yc, w, h, angle1, angle2); }
void wText(double x, double y, const char* s)
  { wdCanvasText(canvas, x, y, s); }

void wPutImageRect(cdImage* image, double x, double y, int xmin, int xmax, int ymin, int ymax)
  { wdCanvasPutImageRect(canvas, image, x, y, xmin, xmax, ymin, ymax); }
void wPutImageRectRGB(int iw, int ih, const unsigned char* r, const unsigned char* g, const unsigned char* b, double x, double y, double w, double h, int xmin, int xmax, int ymin, int ymax)
  { wdCanvasPutImageRectRGB(canvas, iw, ih, r, g, b, x, y, w, h, xmin, xmax, ymin, ymax); }
void wPutImageRectRGBA(int iw, int ih, const unsigned char* r, const unsigned char* g, const unsigned char* b, const unsigned char* a, double x, double y, double w, double h, int xmin, int xmax, int ymin, int ymax)
  { wdCanvasPutImageRectRGBA(canvas, iw, ih, r, g, b, a, x, y, w, h, xmin, xmax, ymin, ymax); }
void wPutImageRectMap(int iw, int ih, const unsigned char* index, const long* colors, double x, double y, double w, double h, int xmin, int xmax, int ymin, int ymax)
  { wdCanvasPutImageRectMap(canvas, iw, ih, index, colors, x, y, w, h, xmin, xmax, ymin, ymax); }
void wPutBitmap(cdBitmap* bitmap, double x, double y, double w, double h)
  { wdCanvasPutBitmap(canvas, bitmap, x, y, w, h); }

/* attributes */
double wLineWidth(double width)
  { return wdCanvasLineWidth(canvas, width); }
int wFont(const char* type_face, int style, double size)
  { return wdCanvasFont(canvas, type_face, style, size); }
void wGetFont(char *type_face, int *style, double *size)
  { wdCanvasGetFont(canvas, type_face, style, size); }
double wMarkSize(double size)
  { return wdCanvasMarkSize(canvas, size); }
void wGetFontDim(double *max_width, double *height, double *ascent, double *descent)
  { wdCanvasGetFontDim(canvas, max_width, height, ascent, descent); }
void wGetTextSize(const char* s, double *width, double *height)
  { wdCanvasGetTextSize(canvas, s, width, height); }
void wGetTextBox(double x, double y, const char* s, double *xmin, double *xmax, double *ymin, double *ymax)
  { wdCanvasGetTextBox(canvas, x, y, s, xmin, xmax, ymin, ymax); }
void wGetTextBounds(double x, double y, const char* s, double *rect)
  { wdCanvasGetTextBounds(canvas, x, y, s, rect); }
void wStipple(int w, int h, const unsigned char*fgbg, double w_mm, double h_mm)
  { wdCanvasStipple(canvas, w, h, fgbg, w_mm, h_mm); }
void wPattern(int w, int h, const long *color, double w_mm, double h_mm)
  { wdCanvasPattern(canvas, w, h, color, w_mm, h_mm); }

/* vector text */
void wVectorTextDirection(double x1, double y1, double x2, double y2)
  { wdCanvasVectorTextDirection(canvas, x1, y1, x2, y2); }
void wVectorTextSize(double size_x, double size_y, const char* s)
  { wdCanvasVectorTextSize(canvas, size_x, size_y, s); }
void wGetVectorTextSize(const char* s, double *x, double *y)
  { wdCanvasGetVectorTextSize(canvas, s, x, y); }
double wVectorCharSize(double size)
  { return wdCanvasVectorCharSize(canvas, size); }
void wVectorText(double x, double y, const char* s)
  { wdCanvasVectorText(canvas, x, y, s); }
void wMultiLineVectorText(double x, double y, const char* s)
  { wdCanvasMultiLineVectorText(canvas, x, y, s); }
void wGetVectorTextBounds(const char* s, double x, double y, double *rect)
  { wdCanvasGetVectorTextBounds(canvas, s, x, y, rect); }

};

#endif




================================================
File: cd/include/cd_old.h
================================================
/** \file
 * \brief Old User API
 *
 * See Copyright Notice in cd.h
 */
 
#ifndef __CD_OLD_H
#define __CD_OLD_H

#ifdef __cplusplus
extern "C" {
#endif


/* canvas control */
int       cdActivate(cdCanvas* canvas);
cdCanvas* cdActiveCanvas(void);
int       cdSimulate(int mode);
void      cdFlush(void);
void      cdClear(void);
cdState*  cdSaveState(void);
void      cdRestoreState(cdState* state);
void      cdSetAttribute(const char* name, char* data);
void      cdSetfAttribute(const char* name, const char* format, ...);
char*     cdGetAttribute(const char* name);
cdContext*  cdGetContext(cdCanvas* canvas);

/* interpretation */
int cdRegisterCallback(cdContext *context, int cb, cdCallback func);
int cdPlay(cdContext *context, int xmin, int xmax, int ymin, int ymax, void *data);

/* coordinate transformation */
void cdGetCanvasSize(int *width, int *height, double *width_mm, double *height_mm);
int cdUpdateYAxis(int *y);
void cdMM2Pixel(double mm_dx, double mm_dy, int *dx, int *dy);
void cdPixel2MM(int dx, int dy, double *mm_dx, double *mm_dy);
void cdOrigin(int x, int y);

/* clipping */
int   cdClip(int mode);
int * cdGetClipPoly(int *n);
void  cdClipArea(int xmin, int xmax, int ymin, int ymax);
int   cdGetClipArea(int *xmin, int *xmax, int *ymin, int *ymax);

/* clipping region */
int  cdPointInRegion(int x, int y);
void cdOffsetRegion(int x, int y);
void cdRegionBox(int *xmin, int *xmax, int *ymin, int *ymax);
int  cdRegionCombineMode(int mode);

/* primitives */
void cdPixel(int x, int y, long color);
void cdMark(int x, int y);
void cdLine(int x1, int y1, int x2, int y2);
void cdBegin(int mode);
void cdVertex(int x, int y);
void cdEnd(void);
void cdRect(int xmin, int xmax, int ymin, int ymax);
void cdBox(int xmin, int xmax, int ymin, int ymax);
void cdArc(int xc, int yc, int w, int h, double angle1, double angle2);
void cdSector(int xc, int yc, int w, int h, double angle1, double angle2);
void cdChord(int xc, int yc, int w, int h, double angle1, double angle2);
void cdText(int x, int y, const char* s);

/* attributes */
long cdBackground(long color);
long cdForeground(long color);
int  cdBackOpacity(int opacity);
int  cdWriteMode(int mode);
int  cdLineStyle(int style);
void cdLineStyleDashes(const int* dashes, int count);
int  cdLineWidth(int width);
int  cdLineJoin(int join);
int  cdLineCap(int cap);
int  cdInteriorStyle(int style);
int  cdHatch(int style);
void cdStipple(int w, int h, const unsigned char* stipple);
unsigned char* cdGetStipple(int *n, int *m);
void   cdPattern(int w, int h, const long *pattern);
long*  cdGetPattern(int* n, int* m);
int    cdFillMode(int mode);
void   cdFont(int type_face, int style, int size);
void   cdGetFont(int *type_face, int *style, int *size);
char*  cdNativeFont(const char* font);
int    cdTextAlignment(int alignment);
double cdTextOrientation(double angle);
int    cdMarkType(int type);
int    cdMarkSize(int size);

/* vector text */
void cdVectorText(int x, int y, const char* s);
void cdMultiLineVectorText(int x, int y, const char* s);

/* vector text attributes */
char *cdVectorFont(const char *filename);
void cdVectorTextDirection(int x1, int y1, int x2, int y2);
double* cdVectorTextTransform(const double* matrix);
void cdVectorTextSize(int size_x, int size_y, const char* s);
int  cdVectorCharSize(int size);

/* vector text properties */
void cdGetVectorTextSize(const char* s, int *x, int *y);
void cdGetVectorTextBounds(const char* s, int x, int y, int *rect);

/* properties */
void cdFontDim(int *max_width, int *height, int *ascent, int *descent);
void cdTextSize(const char* s, int *width, int *height);
void cdTextBox(int x, int y, const char* s, int *xmin, int *xmax, int *ymin, int *ymax);
void cdTextBounds(int x, int y, const char* s, int *rect);
int  cdGetColorPlanes(void);

/* color */
void cdPalette(int n, const long* palette, int mode);

/* client images */
void cdGetImageRGB(unsigned char* r, unsigned char* g, unsigned char* b, int x, int y, int w, int h);
void cdPutImageRectRGB(int iw, int ih, const unsigned char* r, const unsigned char* g, const unsigned char* b, int x, int y, int w, int h, int xmin, int xmax, int ymin, int ymax);
void cdPutImageRectRGBA(int iw, int ih, const unsigned char* r, const unsigned char* g, const unsigned char* b, const unsigned char* a, int x, int y, int w, int h, int xmin, int xmax, int ymin, int ymax);
void cdPutImageRectMap(int iw, int ih, const unsigned char* index, const long* colors, int x, int y, int w, int h, int xmin, int xmax, int ymin, int ymax);

/* defined for backward compatibility */
#define cdPutImageRGB(iw, ih, r, g, b, x, y, w, h) cdPutImageRectRGB((iw), (ih), (r), (g), (b), (x), (y), (w), (h), 0, 0, 0, 0)
#define cdPutImageRGBA(iw, ih, r, g, b, a, x, y, w, h) cdPutImageRectRGBA((iw), (ih), (r), (g), (b), (a), (x), (y), (w), (h), 0, 0, 0, 0)
#define cdPutImageMap(iw, ih, index, colors, x, y, w, h) cdPutImageRectMap((iw), (ih), (index), (colors), (x), (y), (w), (h), 0, 0, 0, 0)
#define cdPutImage(image, x, y) cdPutImageRect((image), (x), (y), 0, 0, 0, 0)

/* server images */
cdImage* cdCreateImage(int w, int h);
void cdGetImage(cdImage* image, int x, int y);
void cdPutImageRect(cdImage* image, int x, int y, int xmin, int xmax, int ymin, int ymax);
void cdScrollArea(int xmin, int xmax, int ymin, int ymax, int dx, int dy);

/* bitmap */
void cdPutBitmap(cdBitmap* bitmap, int x, int y, int w, int h);
void cdGetBitmap(cdBitmap* bitmap, int x, int y);

enum {          /* OLD type face ->  new names */
 CD_SYSTEM,                     /* "System"    */
 CD_COURIER,                    /* "Courier"   */
 CD_TIMES_ROMAN,                /* "Times"     */
 CD_HELVETICA,                  /* "Helvetica" */
 CD_NATIVE
};

/* OLD definitions, defined for backward compatibility */
#define CD_CLIPON       CD_CLIPAREA   
#define CD_CENTER_BASE  CD_BASE_CENTER
#define CD_LEFT_BASE    CD_BASE_LEFT
#define CD_RIGHT_BASE   CD_BASE_RIGHT
#define CD_ITALIC_BOLD  CD_BOLD_ITALIC
#define cdScrollImage cdScrollArea
#define cdCanvas2Raster(x, y) {(void)x; cdUpdateYAxis(y);}

#ifdef __cplusplus
}
#endif

#endif



================================================
File: cd/include/cd_plus.h
================================================
/** \file
 * \brief Name space for C++ high level API
 *
 * See Copyright Notice in cd.h
 */
 
#ifndef __CD_PLUS_H
#define __CD_PLUS_H


#include "cd.h"
#include "wd.h"

#include "cdiup.h"
#include "cddbuf.h"
#include "cdprint.h"
#include "cdnative.h"
#include "cdgdiplus.h"
#include "cdcgm.h"
#include "cddgn.h"
#include "cddxf.h"
#include "cdclipbd.h"
#include "cdemf.h"
#include "cdirgb.h"
#include "cdmf.h"
#include "cdps.h"
#include "cdpdf.h"
#include "cdsvg.h"
#include "cdwmf.h"
#include "cddebug.h"
#include "cdgl.h"
#include "cdpicture.h"
#include "cdim.h"




/** \brief Name space for C++ high level API
 *
 * \par
 * Defines wrapper classes for all C structures.
 *
 * See \ref cd_plus.h
 */
namespace cd
{
  inline char* Version() { return cdVersion(); }
  inline char* VersionDate() { return cdVersionDate(); }
  inline int VersionNumber() { return cdVersionNumber(); }


  inline long ColorEncode(unsigned char red, unsigned char green, unsigned char blue, unsigned char alpha = 255) {
    return cdEncodeColorAlpha(red, green, blue, alpha); }
  inline unsigned char ColorAlpha(long color) { return cdAlpha(color); }
  inline unsigned char ColorRed(long color) { return cdRed(color); }
  inline unsigned char ColorGreen(long color) { return cdGreen(color); }
  inline unsigned char ColorBlue(long color) { return cdBlue(color); }


  class Context
  {
    cdContext* cd_context;

    friend class Canvas;

  public:
    Context(cdContext* ref_context) { cd_context = ref_context; }

    unsigned long Caps() { return cdContextCaps(cd_context); }
    bool IsPlus() { return cdContextIsPlus(cd_context) != 0; }
    int Type() { return cdContextType(cd_context); }

    static void UsePlus(bool use) { cdUseContextPlus(use); }
    static void InitPlus() { cdInitContextPlus(); }
    static void FinishPlus() { cdFinishContextPlus(); }

    static void GetScreenSize(int &width, int &height, double &width_mm, double &height_mm) { cdGetScreenSize(&width, &height, &width_mm, &height_mm); }
    static int GetScreenColorPlanes() { return cdGetScreenColorPlanes(); }
  };


  class Canvas
  {
  protected:
    cdCanvas* canvas;

    /* forbidden */
    Canvas() { canvas = 0; }
    Canvas(const Canvas&) {}

    static inline int PlaySize_CB(cdCanvas *cd_canvas, int w, int h, double w_mm, double h_mm) { 
      Canvas* canvas = (Canvas*)cdCanvasGetAttribute(cd_canvas, "USERDATA");
      return canvas->PlaySizeCallback(w, h, w_mm, h_mm); 
    }

  public:
    Canvas(cdCanvas* ref_canvas) { canvas = ref_canvas; }
    ~Canvas() { 
      if (canvas) 
        cdKillCanvas(canvas); 
    }

    cdCanvas* GetHandle() const { return canvas; }

    Context GetContext() { return cdCanvasGetContext(canvas); }
    int Activate() { return cdCanvasActivate(canvas); }
    void Deactivate() { cdCanvasDeactivate(canvas); }

    /* control */
    int Simulate(int mode) { return cdCanvasSimulate(canvas, mode); }
    void Flush() { cdCanvasFlush(canvas); }
    void Clear() { cdCanvasClear(canvas); }

    cdState* SaveState() { return cdCanvasSaveState(canvas); }
    void RestoreState(cdState* state) { cdCanvasRestoreState(canvas, state); }
    void ReleaseState(cdState* state) { cdReleaseState(state); }

    void SetAttribute(const char* name, char* data) { cdCanvasSetAttribute(canvas, name, data); }
    char* GetAttribute(const char* name) { return cdCanvasGetAttribute(canvas, name); }

    virtual int PlaySizeCallback(int /* w */, int /* h */, double /* w_mm */, double /* h_mm */) { return CD_CONTINUE; }
    /* interpretation */
    int Play(const Context& context, int xmin, int xmax, int ymin, int ymax, void *data) { 
      cdCanvasSetAttribute(canvas, "USERDATA", (char*)this);
      cdContextRegisterCallback(context.cd_context, CD_SIZECB, (cdCallback)PlaySize_CB);
      return cdCanvasPlay(canvas, context.cd_context, xmin, xmax, ymin, ymax, data); 
    }
    int wPlay(const Context& context, double xmin, double xmax, double ymin, double ymax, void *data) { 
      cdCanvasSetAttribute(canvas, "USERDATA", (char*)this);
      cdContextRegisterCallback(context.cd_context, CD_SIZECB, (cdCallback)PlaySize_CB);
      return wdCanvasPlay(canvas, context.cd_context, xmin, xmax, ymin, ymax, data); 
    }

    /* coordinates utilities */
    void GetSize(int &width, int &height, double &width_mm, double &height_mm) { cdCanvasGetSize(canvas, &width, &height, &width_mm, &height_mm); }
    int UpdateYAxis(int &y) { return cdCanvasUpdateYAxis(canvas, &y); }
    double UpdateYAxis(double &y) { return cdfCanvasUpdateYAxis(canvas, &y); }
    int InvertYAxis(int y) { return cdCanvasInvertYAxis(canvas, y); }
    double InvertYAxis(double y) { return cdfCanvasInvertYAxis(canvas, y); }
    void MM2Pixel(double mm_dx, double mm_dy, int &dx, int &dy) { cdCanvasMM2Pixel(canvas, mm_dx, mm_dy, &dx, &dy); }
    void MM2Pixel(double mm_dx, double mm_dy, double &dx, double &dy) { cdfCanvasMM2Pixel(canvas, mm_dx, mm_dy, &dx, &dy); }
    void Pixel2MM(int dx, int dy, double &mm_dx, double &mm_dy) { cdCanvasPixel2MM(canvas, dx, dy, &mm_dx, &mm_dy); }
    void Pixel2MM(double dx, double dy, double &mm_dx, double &mm_dy) { cdfCanvasPixel2MM(canvas, dx, dy, &mm_dx, &mm_dy); }
    void Origin(int x, int y) { cdCanvasOrigin(canvas, x, y); }
    void Origin(double x, double y) { cdfCanvasOrigin(canvas, x, y); }
    void GetOrigin(int &x, int &y) { cdCanvasGetOrigin(canvas, &x, &y); }
    void GetOrigin(double &x, double &y) { cdfCanvasGetOrigin(canvas, &x, &y); }

    /* coordinates transformation */
    void Transform(const double* matrix) { cdCanvasTransform(canvas, matrix); }
    double* GetTransform() { return cdCanvasGetTransform(canvas); }
    void TransformMultiply(const double* matrix) { cdCanvasTransformMultiply(canvas, matrix); }
    void TransformRotate(double angle) { cdCanvasTransformRotate(canvas, angle); }
    void TransformScale(double sx, double sy) { cdCanvasTransformScale(canvas, sx, sy); }
    void TransformTranslate(double dx, double dy) { cdCanvasTransformTranslate(canvas, dx, dy); }
    void TransformPoint(int x, int y, int &tx, int &ty) { cdCanvasTransformPoint(canvas, x, y, &tx, &ty); }
    void TransformPoint(double x, double y, double &tx, double &ty) { cdfCanvasTransformPoint(canvas, x, y, &tx, &ty); }

    /* world coordinate transformation */
    void wWindow(double xmin, double xmax, double  ymin, double ymax) { wdCanvasWindow(canvas, xmin, xmax, ymin, ymax); }
    void wGetWindow(double &xmin, double  &xmax, double  &ymin, double &ymax) { wdCanvasGetWindow(canvas, &xmin, &xmax, &ymin, &ymax); }
    void wViewport(int xmin, int xmax, int ymin, int ymax) { wdCanvasViewport(canvas, xmin, xmax, ymin, ymax); }
    void wGetViewport(int &xmin, int  &xmax, int  &ymin, int &ymax) { wdCanvasGetViewport(canvas, &xmin, &xmax, &ymin, &ymax); }
    void wWorld2Canvas(double xw, double yw, int &xv, int &yv) { wdCanvasWorld2Canvas(canvas, xw, yw, &xv, &yv); }
    void wWorld2CanvasSize(double hw, double vw, int &hv, int &vv) { wdCanvasWorld2CanvasSize(canvas, hw, vw, &hv, &vv); }
    void wCanvas2World(int xv, int yv, double &xw, double &yw) { wdCanvasCanvas2World(canvas, xv, yv, &xw, &yw); }
    void wSetTransform(double sx, double sy, double tx, double ty) { wdCanvasSetTransform(canvas, sx, sy, tx, ty); }
    void wGetTransform(double &sx, double &sy, double &tx, double &ty) { wdCanvasGetTransform(canvas, &sx, &sy, &tx, &ty); }
    void wTranslate(double dtx, double dty) { wdCanvasTranslate(canvas, dtx, dty); }
    void wScale(double dsx, double dsy) { wdCanvasScale(canvas, dsx, dsy); }


    /* clipping */
    int Clip(int mode) { return cdCanvasClip(canvas, mode); }
    void ClipArea(int xmin, int xmax, int ymin, int ymax) { cdCanvasClipArea(canvas, xmin, xmax, ymin, ymax); }
    void ClipArea(double xmin, double xmax, double ymin, double ymax) { cdfCanvasClipArea(canvas, xmin, xmax, ymin, ymax); }
    void wClipArea(double xmin, double xmax, double  ymin, double ymax) { wdCanvasClipArea(canvas, xmin, xmax, ymin, ymax); }
    int GetClipArea(int &xmin, int &xmax, int &ymin, int &ymax) { return cdCanvasGetClipArea(canvas, &xmin, &xmax, &ymin, &ymax); }
    int GetClipArea(double &xmin, double &xmax, double &ymin, double &ymax) { return cdfCanvasGetClipArea(canvas, &xmin, &xmax, &ymin, &ymax); }
    int wGetClipArea(double &xmin, double &xmax, double &ymin, double &ymax) { return wdCanvasGetClipArea(canvas, &xmin, &xmax, &ymin, &ymax); }

    /* clipping region */
    int IsPointInRegion(int x, int y) { return cdCanvasIsPointInRegion(canvas, x, y); }
    int wIsPointInRegion(double x, double y) { return wdCanvasIsPointInRegion(canvas, x, y); }
    void OffsetRegion(int x, int y) { cdCanvasOffsetRegion(canvas, x, y); }
    void wOffsetRegion(double x, double y) { wdCanvasOffsetRegion(canvas, x, y); }
    void GetRegionBox(int &xmin, int &xmax, int &ymin, int &ymax) { cdCanvasGetRegionBox(canvas, &xmin, &xmax, &ymin, &ymax); }
    void wGetRegionBox(double &xmin, double &xmax, double &ymin, double &ymax) { wdCanvasGetRegionBox(canvas, &xmin, &xmax, &ymin, &ymax); }
    int RegionCombineMode(int mode) { return cdCanvasRegionCombineMode(canvas, mode); }

    /* primitives */
    void Pixel(int x, int y, long color) { cdCanvasPixel(canvas, x, y, color); }
    void Pixel(double x, double y, long color) { cdfCanvasPixel(canvas, x, y, color); }
    void wPixel(double x, double y, long color) { wdCanvasPixel(canvas, x, y, color); }
    void Mark(int x, int y) { cdCanvasMark(canvas, x, y); }
    void Mark(double x, double y) { cdfCanvasMark(canvas, x, y); }
    void wMark(double x, double y) { wdCanvasMark(canvas, x, y); }

    void Begin(int mode) { cdCanvasBegin(canvas, mode); }
    void PathSet(int action) { cdCanvasPathSet(canvas, action); }
    void End() { cdCanvasEnd(canvas); }

    void Line(int x1, int y1, int x2, int y2) { cdCanvasLine(canvas, x1, y1, x2, y2); }
    void Line(double x1, double y1, double x2, double y2) { cdfCanvasLine(canvas, x1, y1, x2, y2); }
    void wLine(double x1, double y1, double x2, double y2) { wdCanvasLine(canvas, x1, y1, x2, y2); }
    void Vertex(int x, int y) { cdCanvasVertex(canvas, x, y); }
    void wVertex(double x, double y) { wdCanvasVertex(canvas, x, y); }
    void Vertex(double x, double y) { cdfCanvasVertex(canvas, x, y); }
    void Rect(int xmin, int xmax, int ymin, int ymax) { cdCanvasRect(canvas, xmin, xmax, ymin, ymax); }
    void Rect(double xmin, double xmax, double ymin, double ymax) { cdfCanvasRect(canvas, xmin, xmax, ymin, ymax); }
    void wRect(double xmin, double xmax, double ymin, double ymax) { wdCanvasRect(canvas, xmin, xmax, ymin, ymax); }
    void Box(int xmin, int xmax, int ymin, int ymax) { cdCanvasBox(canvas, xmin, xmax, ymin, ymax); }
    void Box(double xmin, double xmax, double ymin, double ymax) { cdfCanvasBox(canvas, xmin, xmax, ymin, ymax); }
    void wBox(double xmin, double xmax, double ymin, double ymax) { wdCanvasBox(canvas, xmin, xmax, ymin, ymax); }
    void Arc(int xc, int yc, int w, int h, double angle1, double angle2) { cdCanvasArc(canvas, xc, yc, w, h, angle1, angle2); }
    void Arc(double xc, double yc, double w, double h, double angle1, double angle2) { cdfCanvasArc(canvas, xc, yc, w, h, angle1, angle2); }
    void wArc(double xc, double yc, double w, double h, double angle1, double angle2) { wdCanvasArc(canvas, xc, yc, w, h, angle1, angle2); }
    void Sector(int xc, int yc, int w, int h, double angle1, double angle2) { cdCanvasSector(canvas, xc, yc, w, h, angle1, angle2); }
    void Sector(double xc, double yc, double w, double h, double angle1, double angle2) { cdfCanvasSector(canvas, xc, yc, w, h, angle1, angle2); }
    void wSector(double xc, double yc, double w, double h, double angle1, double angle2) { wdCanvasSector(canvas, xc, yc, w, h, angle1, angle2); }
    void Chord(double xc, double yc, double w, double h, double angle1, double angle2) { cdfCanvasChord(canvas, xc, yc, w, h, angle1, angle2); }
    void Chord(int xc, int yc, int w, int h, double angle1, double angle2) { cdCanvasChord(canvas, xc, yc, w, h, angle1, angle2); }
    void wChord(double xc, double yc, double w, double h, double angle1, double angle2) { wdCanvasChord(canvas, xc, yc, w, h, angle1, angle2); }
    void Text(int x, int y, const char* s) { cdCanvasText(canvas, x, y, s); }
    void Text(double x, double y, const char* s) { cdfCanvasText(canvas, x, y, s); }
    void wText(double x, double y, const char* s) { wdCanvasText(canvas, x, y, s); }

    /* attributes */
    void SetBackground(long color) { cdCanvasSetBackground(canvas, color); }
    void SeForeground(long color) { cdCanvasSetForeground(canvas, color); }
    long Background(long color) { return cdCanvasBackground(canvas, color); }
    long Foreground(long color) { return cdCanvasForeground(canvas, color); }
    int BackOpacity(int opacity) { return cdCanvasBackOpacity(canvas, opacity); }
    int WriteMode(int mode) { return cdCanvasWriteMode(canvas, mode); }
    int LineStyle(int style) { return cdCanvasLineStyle(canvas, style); }
    void LineStyleDashes(const int* dashes, int count) { cdCanvasLineStyleDashes(canvas, dashes, count); }
    int LineWidth(int width) { return cdCanvasLineWidth(canvas, width); }
    double wLineWidth(double width) { return wdCanvasLineWidth(canvas, width); }
    int LineJoin(int join) { return cdCanvasLineJoin(canvas, join); }
    int LineCap(int cap) { return cdCanvasLineCap(canvas, cap); }
    int InteriorStyle(int style) { return cdCanvasInteriorStyle(canvas, style); }
    int Hatch(int style) { return cdCanvasHatch(canvas, style); }
#ifdef __IM_PLUS_H
    void Stipple(const im::Image& stipple) { cdCanvasStippleImImage(canvas, stipple.GetHandle()); }
    unsigned char* GetStipple(int &n, int &m) { return cdCanvasGetStipple(canvas, &n, &m); }
    void Pattern(const im::Image& pattern) { cdCanvasPatternImImage(canvas, pattern.GetHandle()); }
    long* GetPattern(int& n, int& m) { return cdCanvasGetPattern(canvas, &n, &m); }
#endif    
    int FillMode(int mode) { return cdCanvasFillMode(canvas, mode); }
    int Font(const char* type_face, int style, int size) { return cdCanvasFont(canvas, type_face, style, size); }
    int wFont(const char* type_face, int style, double size) { return wdCanvasFont(canvas, type_face, style, size); }
    void GetFont(char *type_face, int &style, int &size) { cdCanvasGetFont(canvas, type_face, &style, &size); }
    void wGetFont(char *type_face, int &style, double &size) { wdCanvasGetFont(canvas, type_face, &style, &size); }
    char* NativeFont(const char* font) { return cdCanvasNativeFont(canvas, font); }
    int TextAlignment(int alignment) { return cdCanvasTextAlignment(canvas, alignment); }
    double TextOrientation(double angle) { return cdCanvasTextOrientation(canvas, angle); }
    int MarkType(int type) { return cdCanvasMarkType(canvas, type); }
    int MarkSize(int size) { return cdCanvasMarkSize(canvas, size); }
    double wMarkSize(double size) { return wdCanvasMarkSize(canvas, size); }

    /* vector text */
    void VectorText(int x, int y, const char* s) { cdCanvasVectorText(canvas, x, y, s); }
    void VectorText(double x, double y, const char* s) { cdfCanvasVectorText(canvas, x, y, s); }
    void wVectorText(double x, double y, const char* s) { wdCanvasVectorText(canvas, x, y, s); }
    void MultiLineVectorText(int x, int y, const char* s) { cdCanvasMultiLineVectorText(canvas, x, y, s); }
    void MultiLineVectorText(double x, double y, const char* s) { cdfCanvasMultiLineVectorText(canvas, x, y, s); }
    void wMultiLineVectorText(double x, double y, const char* s) { wdCanvasMultiLineVectorText(canvas, x, y, s); }

    /* vector text attributes */
    char *VectorFont(const char *filename) { return cdCanvasVectorFont(canvas, filename); }
    void VectorTextDirection(int x1, int y1, int x2, int y2) { cdCanvasVectorTextDirection(canvas, x1, y1, x2, y2); }
    void VectorTextDirection(double x1, double y1, double x2, double y2) { cdfCanvasVectorTextDirection(canvas, x1, y1, x2, y2); }
    void wVectorTextDirection(double x1, double y1, double x2, double y2) { wdCanvasVectorTextDirection(canvas, x1, y1, x2, y2); }
    double* VectorTextTransform(const double* matrix) { return cdCanvasVectorTextTransform(canvas, matrix); }
    void VectorTextSize(int size_x, int size_y, const char* s) { cdCanvasVectorTextSize(canvas, size_x, size_y, s); }
    void VectorTextSize(double size_x, double size_y, const char* s) { cdfCanvasVectorTextSize(canvas, size_x, size_y, s); }
    void wVectorTextSize(double size_x, double size_y, const char* s) { wdCanvasVectorTextSize(canvas, size_x, size_y, s); }
    int VectorCharSize(int size) { return cdCanvasVectorCharSize(canvas, size); }
    double VectorCharSize(double size) { return cdfCanvasVectorCharSize(canvas, size); }
    double wVectorCharSize(double size) { return wdCanvasVectorCharSize(canvas, size); }
    void VectorFontSize(double size_x, double size_y) { cdCanvasVectorFontSize(canvas, size_x, size_y); }
    void GetVectorFontSize(double &size_x, double &size_y) { cdCanvasGetVectorFontSize(canvas, &size_x, &size_y); }


    /* vector text properties */
    void GetVectorTextSize(const char* s, int &x, int &y) { cdCanvasGetVectorTextSize(canvas, s, &x, &y); }
    void GetVectorTextSize(const char* s, double &x, double &y) { cdfCanvasGetVectorTextSize(canvas, s, &x, &y); }
    void wGetVectorTextSize(const char* s, double &x, double &y) { wdCanvasGetVectorTextSize(canvas, s, &x, &y); }
    void GetVectorTextBounds(const char* s, int x, int y, int *rect) { cdCanvasGetVectorTextBounds(canvas, s, x, y, rect); }
    void GetVectorTextBounds(const char* s, double x, double y, double *rect) { cdfCanvasGetVectorTextBounds(canvas, s, x, y, rect); }
    void wGetVectorTextBounds(const char* s, double x, double y, double *rect) { wdCanvasGetVectorTextBounds(canvas, s, x, y, rect); }
    void GetVectorTextBox(int x, int y, const char *s, int &xmin, int &xmax, int &ymin, int &ymax) { cdCanvasGetVectorTextBox(canvas, x, y, s, &xmin, &xmax, &ymin, &ymax); }
    void GetVectorTextBox(double x, double y, const char *s, double &xmin, double &xmax, double &ymin, double &ymax) { cdfCanvasGetVectorTextBox(canvas, x, y, s, &xmin, &xmax, &ymin, &ymax); }
    void wGetVectorTextBox(double x, double y, const char *s, double &xmin, double &xmax, double &ymin, double &ymax) { wdCanvasGetVectorTextBox(canvas, x, y, s, &xmin, &xmax, &ymin, &ymax); }

    /* properties */
    void GetFontDim(int &max_width, int &height, int &ascent, int &descent) { cdCanvasGetFontDim(canvas, &max_width, &height, &ascent, &descent); }
    void wGetFontDim(double &max_width, double &height, double &ascent, double &descent) { wdCanvasGetFontDim(canvas, &max_width, &height, &ascent, &descent); }
    void GetTextSize(const char* s, int &width, int &height) { cdCanvasGetTextSize(canvas, s, &width, &height); }
    void wGetTextSize(const char* s, double &width, double &height) { wdCanvasGetTextSize(canvas, s, &width, &height); }
    void GetTextBox(int x, int y, const char* s, int &xmin, int &xmax, int &ymin, int &ymax) { cdCanvasGetTextBox(canvas, x, y, s, &xmin, &xmax, &ymin, &ymax); }
    void GetTextBox(double x, double y, const char* s, double &xmin, double &xmax, double &ymin, double &ymax) { cdfCanvasGetTextBox(canvas, x, y, s, &xmin, &xmax, &ymin, &ymax); }
    void wGetTextBox(double x, double y, const char* s, double &xmin, double &xmax, double &ymin, double &ymax) { wdCanvasGetTextBox(canvas, x, y, s, &xmin, &xmax, &ymin, &ymax); }
    void GetTextBounds(int x, int y, const char* s, int *rect) { cdCanvasGetTextBounds(canvas, x, y, s, rect); }
    void GetTextBounds(double x, double y, const char* s, double *rect) { cdfCanvasGetTextBounds(canvas, x, y, s, rect); }
    void wGetTextBounds(double x, double y, const char* s, double *rect) { wdCanvasGetTextBounds(canvas, x, y, s, rect); }
    int GetColorPlanes() { return cdCanvasGetColorPlanes(canvas); }


    /* client images */
#ifdef __IM_PLUS_H
    void PutImage(const im::Image& image, int x, int y, int w, int h) { cdCanvasPutImImage(canvas, image.GetHandle(), x, y, w, h); }
    void PutImage(const im::Image& image, double x, double y, double w, double h) { cdfCanvasPutImImage(canvas, image.GetHandle(), x, y, w, h); }
    void wPutImage(const im::Image& image, double x, double y, double w, double h) { wdCanvasPutImImage(canvas, image.GetHandle(), x, y, w, h); }

    void GetImage(im::Image& image, int x, int y) { cdCanvasGetImImage(canvas, image.GetHandle(), x, y); }
    void wGetImage(im::Image& image, double x, double y) { wdCanvasGetImImage(canvas, image.GetHandle(), x, y); }
#endif    
  };


  class CanvasImageRGB : public Canvas
  {
  public:
    CanvasImageRGB(int width, int height, bool has_alpha = false, double res = 0)
      : Canvas() { const char *alpha = "";
      if (has_alpha)
        alpha = "-a";

      if (res)
        canvas = cdCreateCanvasf(CD_IMAGERGB, "%dx%d %g %s", width, height, res, alpha);
      else
        canvas = cdCreateCanvasf(CD_IMAGERGB, "%dx%d %s", width, height, alpha); }
  };
#ifdef __IM_PLUS_H
  class CanvasImImage : public Canvas
  {
  public:
    CanvasImImage(im::Image& image, double res = 0)
      : Canvas() { canvas = cdCreateCanvas(CD_IMIMAGE, image.GetHandle());
      if (canvas && res)
        cdCanvasSetfAttribute(canvas, "RESOLUTION", "%g", res); 
    }
  };
#endif
  class CanvasMetafileEMF : public Canvas
  {
  public:
    CanvasMetafileEMF(const char* filename, int width, int height, double res = 0)
      : Canvas() { if (res)
        canvas = cdCreateCanvasf(CD_EMF, "\"%s\" %dx%d %g", filename, width, height, res);
      else
        canvas = cdCreateCanvasf(CD_EMF, "\"%s\" %dx%d", filename, width, height); 
    }
  };
  class CanvasMetafileWMF : public Canvas
  {
  public:
    CanvasMetafileWMF(const char* filename, int width, int height, double res = 0)
      : Canvas() { if (res)
        canvas = cdCreateCanvasf(CD_WMF, "\"%s\" %dx%d %g", filename, width, height, res);
      else
        canvas = cdCreateCanvasf(CD_WMF, "\"%s\" %dx%d", filename, width, height); 
    }
  };
  class CanvasMetafileMF : public Canvas
  {
  public:
    CanvasMetafileMF(const char* filename, double res = 0)
      : Canvas() { if (res)
        canvas = cdCreateCanvasf(CD_METAFILE, "\"%s\" %g", filename, res);
      else
        canvas = cdCreateCanvasf(CD_METAFILE, "\"%s\"", filename); 
    }
    CanvasMetafileMF(const char* filename, double width_mm, double height_mm, double res = 0)
      : Canvas() { if (res)
        canvas = cdCreateCanvasf(CD_METAFILE, "\"%s\" %gx%g %g", filename, width_mm, height_mm, res);
      else
        canvas = cdCreateCanvasf(CD_METAFILE, "\"%s\" %gx%g", filename, width_mm, height_mm); 
    }
  };
  class CanvasMetafileSVG : public Canvas
  {
  public:
    CanvasMetafileSVG(const char* filename, double res = 0)
      : Canvas() { if (res)
        canvas = cdCreateCanvasf(CD_SVG, "\"%s\" %g", filename, res);
      else
        canvas = cdCreateCanvasf(CD_SVG, "\"%s\"", filename); 
    }
    CanvasMetafileSVG(const char* filename, double width_mm, double height_mm, double res = 0)
      : Canvas() { if (res)
        canvas = cdCreateCanvasf(CD_SVG, "\"%s\" %gx%g %g", filename, width_mm, height_mm, res);
      else
        canvas = cdCreateCanvasf(CD_SVG, "\"%s\" %gx%g", filename, width_mm, height_mm); 
    }
  };
  class CanvasMetafileDebug : public Canvas
  {
  public:
    CanvasMetafileDebug(const char* filename, double res = 0)
      : Canvas() { if (res)
        canvas = cdCreateCanvasf(CD_DEBUG, "\"%s\" %g", filename, res);
      else
        canvas = cdCreateCanvasf(CD_DEBUG, "\"%s\"", filename); 
    }
    CanvasMetafileDebug(const char* filename, double width_mm, double height_mm, double res = 0)
      : Canvas() { if (res)
        canvas = cdCreateCanvasf(CD_DEBUG, "\"%s\" %gx%g %g", filename, width_mm, height_mm, res);
      else
        canvas = cdCreateCanvasf(CD_DEBUG, "\"%s\" %gx%g", filename, width_mm, height_mm); 
    }
  };
  class CanvasPrinter : public Canvas
  {
  public:
    CanvasPrinter(const char* name, bool show_dialog = false)
      : Canvas() { if (show_dialog)
        canvas = cdCreateCanvasf(CD_PRINTER, "%s -d", name);
      else
        canvas = cdCreateCanvasf(CD_PRINTER, "%s", name); 
    }
  };
  class CanvasOpenGL : public Canvas
  {
  public:
    CanvasOpenGL(int width, int height, double res = 0)
      : Canvas() { if (res)
        canvas = cdCreateCanvasf(CD_GL, "%dx%d %g", width, height, res);
      else
        canvas = cdCreateCanvasf(CD_GL, "%dx%d", width, height); 
    }
  };
  class CanvasPicture : public Canvas
  {
  public:
    CanvasPicture(double res = 0)
      : Canvas() { if (res)
        canvas = cdCreateCanvasf(CD_PICTURE, "%g", res);
      else
        canvas = cdCreateCanvas(CD_PICTURE, ""); 
    }
  };
  class CanvasMetafileDGN : public Canvas
  {
  public:
    CanvasMetafileDGN(const char* filename, double res = 0, bool polygon_filling = true, const char* seed_file = 0)
      : Canvas() { char* polygon_filling_str = "";
      if (!polygon_filling)
        polygon_filling_str = "-f";

      char* seed_file_str = "";
      if (seed_file)
        seed_file_str = "-s";
      else
        seed_file = "";

      if (res)
        canvas = cdCreateCanvasf(CD_DGN, "\"%s\" %g %s %s%s", filename, res, polygon_filling_str, seed_file_str, seed_file);
      else
        canvas = cdCreateCanvasf(CD_DGN, "\"%s\" %s %s%s", filename, polygon_filling_str, seed_file_str, seed_file); 
    }
    CanvasMetafileDGN(const char* filename, double width_mm, double height_mm, double res = 0, bool polygon_filling = true, const char* seed_file = 0)
      : Canvas() { char* polygon_filling_str = "";
      if (!polygon_filling)
        polygon_filling_str = "-f";

      char* seed_file_str = "";
      if (seed_file)
        seed_file_str = "-s";
      else
        seed_file = "";

      if (res)
        canvas = cdCreateCanvasf(CD_DGN, "\"%s\" %gx%g %g %s %s%s", filename, width_mm, height_mm, res, polygon_filling_str, seed_file_str, seed_file);
      else
        canvas = cdCreateCanvasf(CD_DGN, "\"%s\" %gx%g %s %s%s", filename, width_mm, height_mm, polygon_filling_str, seed_file_str, seed_file); 
    }
  };
  class CanvasMetafileDXF : public Canvas
  {
  public:
    CanvasMetafileDXF(const char* filename, double res = 0, bool acad2000 = true, double xmin = 0, double ymin = 0, double xmax = 0, double ymax = 0)
      : Canvas() { char* acad2000_str = "";
      if (acad2000)
        acad2000_str = "-ac2000";

      if (xmin || ymin || xmax || ymax)
      {   if (res)
          canvas = cdCreateCanvasf(CD_DXF, "\"%s\" %g %s -limits %g %g %g %g", filename, res, acad2000_str, xmin, ymin, xmax, ymax);
        else
          canvas = cdCreateCanvasf(CD_DXF, "\"%s\" %s -limits %g %g %g %g", filename, acad2000_str, xmin, ymin, xmax, ymax);
      }
      else
      {   if (res)
          canvas = cdCreateCanvasf(CD_DXF, "\"%s\" %g %s", filename, res, acad2000_str);
        else
          canvas = cdCreateCanvasf(CD_DXF, "\"%s\" %s", filename, acad2000_str);
      }
    }
    CanvasMetafileDXF(const char* filename, double width_mm, double height_mm, double res = 0, bool acad2000 = true, double xmin = 0, double ymin = 0, double xmax = 0, double ymax = 0)
      : Canvas() { char* acad2000_str = "";
      if (acad2000)
        acad2000_str = "-ac2000";

      if (xmin || ymin || xmax || ymax)
      {   if (res)
          canvas = cdCreateCanvasf(CD_DXF, "\"%s\" %gx%g %g %s -limits %g %g %g %g", filename, width_mm, height_mm, res, acad2000_str, xmin, ymin, xmax, ymax);
        else
          canvas = cdCreateCanvasf(CD_DXF, "\"%s\" %gx%g %s -limits %g %g %g %g", filename, width_mm, height_mm, acad2000_str, xmin, ymin, xmax, ymax);
      }
      else
      {   if (res)
          canvas = cdCreateCanvasf(CD_DXF, "\"%s\" %gx%g %g %s %s%s", filename, width_mm, height_mm, res, acad2000_str);
        else
          canvas = cdCreateCanvasf(CD_DXF, "\"%s\" %gx%g %s %s%s", filename, width_mm, height_mm, acad2000_str);
      }
    }
  };
  class CanvasMetafileCGM : public Canvas
  {
  public:
    CanvasMetafileCGM(const char* filename, double res = 0, bool text_encoding = false, const char* precision = 0, const char* description = 0)
      : Canvas() { char* text_encoding_str = "";
      if (text_encoding)
        text_encoding_str = "-d";

      if (!precision)   /* can be "16" (short), "32" (int), "F" (float), "D" (double) */
        precision = "16";

      char* description_str = "";
      if (description)
        description_str = "-s";
      else
        description = "";

      if (res)
        canvas = cdCreateCanvasf(CD_CGM, "\"%s\" %g %s -p%s %s%s", filename, res, text_encoding_str, precision, description_str, description);
      else
        canvas = cdCreateCanvasf(CD_CGM, "\"%s\" %s -p%s %s%s", filename, text_encoding_str, precision, description_str, description); 
    }
    CanvasMetafileCGM(const char* filename, double width_mm, double height_mm, double res = 0, bool text_encoding = false, const char* precision = 0, const char* description = 0)
      : Canvas() { char* text_encoding_str = "";
      if (text_encoding)
        text_encoding_str = "-t";

      if (!precision)   /* can be "16" (short), "32" (int), "F" (float), "D" (double) */
        precision = "16";

      char* description_str = "";
      if (description)
        description_str = "-d";
      else
        description = "";

      if (res)
        canvas = cdCreateCanvasf(CD_CGM, "\"%s\" %gx%g %g %s -p%s %s%s", filename, width_mm, height_mm, res, text_encoding_str, precision, description_str, description);
      else
        canvas = cdCreateCanvasf(CD_CGM, "\"%s\" %gx%g %s -p%s %s%s", filename, width_mm, height_mm, text_encoding_str, precision, description_str, description); 
    }
  };
  class CanvasMetafilePDF : public Canvas
  {
  public:
    CanvasMetafilePDF(const char* filename, int paper, int res_dpi = 0, bool landscape = false)
      : Canvas() { char* landscape_str = "";
      if (landscape)
        landscape_str = "-o";

      char* res_dpi_str = "";
      if (res_dpi)
        res_dpi_str = "-s";

      canvas = cdCreateCanvasf(CD_PDF, "\"%s\" -p%d %s%s %s", filename, paper, res_dpi_str, res_dpi, landscape_str); 
    }
    CanvasMetafilePDF(const char* filename, double width_mm, double height_mm, int res_dpi = 0, bool landscape = false)
      : Canvas() { char* landscape_str = "";
      if (landscape)
        landscape_str = "-o";

      char* res_dpi_str = "";
      if (res_dpi)
        res_dpi_str = "-s";

      canvas = cdCreateCanvasf(CD_PDF, "\"%s\" -w%g -h%g %s%s %s", filename, width_mm, height_mm, res_dpi_str, res_dpi, landscape_str); 
    }
  };
  class CanvasMetafilePS : public Canvas
  {
  public:
    CanvasMetafilePS(const char* filename, int paper, int res_dpi = 0, bool landscape = false)
      : Canvas() { char* landscape_str = "";
      if (landscape)
        landscape_str = "-o";

      char* res_dpi_str = "";
      if (res_dpi)
        res_dpi_str = "-s";

      canvas = cdCreateCanvasf(CD_PS, "\"%s\" -p%d %s%s %s", filename, paper, res_dpi_str, res_dpi, landscape_str); 
    }
    CanvasMetafilePS(const char* filename, double width_mm, double height_mm, int res_dpi = 0, bool landscape = false)
      : Canvas() { char* landscape_str = "";
      if (landscape)
        landscape_str = "-o";

      char* res_dpi_str = "";
      if (res_dpi)
        res_dpi_str = "-s";

      canvas = cdCreateCanvasf(CD_PS, "\"%s\" -w%g -h%g %s%s %s", filename, width_mm, height_mm, res_dpi_str, res_dpi, landscape_str); 
    }
    CanvasMetafilePS(const char* filename, int res_dpi = 0, bool landscape = false)
      : Canvas() { char* landscape_str = "";
      if (landscape)
        landscape_str = "-o";

      char* res_dpi_str = "";
      if (res_dpi)
        res_dpi_str = "-s";

      canvas = cdCreateCanvasf(CD_PS, "\"%s\" -e %s%s %s", filename, res_dpi_str, res_dpi, landscape_str); 
    }
  };
}

#endif



================================================
File: cd/include/cd_private.h
================================================
/** \file
 * \brief Private CD declarations
 *
 * See Copyright Notice in cd.h
 */

#ifndef __CD_PRIVATE_H
#define __CD_PRIVATE_H

#include <stdarg.h>

#ifdef __cplusplus
extern "C" {
#endif

/* All context canvas must have at least the base canvas pointer. */
typedef struct _cdCtxCanvasBase 
{
  cdCanvas* canvas;
} cdCtxCanvasBase;

typedef struct _cdCtxCanvas cdCtxCanvas;
typedef struct _cdCtxImage cdCtxImage;

typedef struct _cdVectorFont cdVectorFont;
typedef struct _cdSimulation cdSimulation;

typedef struct _cdPoint 
{
  int x, y; 
} cdPoint; 

typedef struct _cdfPoint 
{
  double x, y; 
} cdfPoint; 

typedef struct _cdRect 
{
  int xmin, xmax, ymin, ymax; 
} cdRect; 

typedef struct _cdfRect 
{
  double xmin, xmax, ymin, ymax; 
} cdfRect; 

typedef struct _cdAttribute
{
  const char *name;

  /* can be NULL one of them */
  void (*set)(cdCtxCanvas* ctxcanvas, char* data);
  char* (*get)(cdCtxCanvas* ctxcanvas);
} cdAttribute; 

struct _cdImage
{
  int w, h;
  cdCtxImage* ctximage;

  /* can NOT be NULL */
  void   (*cxGetImage)(cdCtxCanvas* ctxcanvas, cdCtxImage* ctximage, int x, int y);
  void   (*cxPutImageRect)(cdCtxCanvas* ctxcanvas, cdCtxImage* ctximage, int x, int y, int xmin, int xmax, int ymin, int ymax);
  void   (*cxKillImage)(cdCtxImage* ctximage);
};

struct _cdContext
{
  unsigned long caps;  /* canvas capabilities, combination of CD_CAP_*  */
  int type; /* context type WINDOW, DEVICE, IMAGE or FILE, combined with PLUS */

  /* can NOT be NULL */
  void  (*cxCreateCanvas)(cdCanvas* canvas, void *data);
  void  (*cxInitTable)(cdCanvas* canvas);

  /* can be NULL */
  int   (*cxPlay)(cdCanvas* canvas, int xmin, int xmax, int ymin, int ymax, void *data); 
  int   (*cxRegisterCallback)(int cb, cdCallback func);
};

struct _cdCanvas
{
  char signature[2];  /* must be "CD" */

  /* can NOT be NULL */
  void   (*cxPixel)(cdCtxCanvas* ctxcanvas, int x, int y, long color);
  void   (*cxLine)(cdCtxCanvas* ctxcanvas, int x1, int y1, int x2, int y2);
  void   (*cxPoly)(cdCtxCanvas* ctxcanvas, int mode, cdPoint* points, int n);
  void   (*cxRect)(cdCtxCanvas* ctxcanvas, int xmin, int xmax, int ymin, int ymax);
  void   (*cxBox)(cdCtxCanvas* ctxcanvas, int xmin, int xmax, int ymin, int ymax);
  void   (*cxArc)(cdCtxCanvas* ctxcanvas, int xc, int yc, int w, int h, double angle1, double angle2);
  void   (*cxSector)(cdCtxCanvas* ctxcanvas, int xc, int yc, int w, int h, double angle1, double angle2);
  void   (*cxChord)(cdCtxCanvas* ctxcanvas, int xc, int yc, int w, int h, double angle1, double angle2);
  void   (*cxText)(cdCtxCanvas* ctxcanvas, int x, int y, const char *s, int len);
  void   (*cxKillCanvas)(cdCtxCanvas* ctxcanvas);
  int    (*cxFont)(cdCtxCanvas* ctxcanvas, const char *type_face, int style, int size);
  void   (*cxPutImageRectMap)(cdCtxCanvas* ctxcanvas, int iw, int ih, const unsigned char *index, const long *colors, int x, int y, int w, int h, int xmin, int xmax, int ymin, int ymax);

  /* default implementation uses the simulation driver */
  void   (*cxGetFontDim)(cdCtxCanvas* ctxcanvas, int *max_width, int *height, int *ascent, int *descent);
  void   (*cxGetTextSize)(cdCtxCanvas* ctxcanvas, const char *s, int len, int *width, int *height);

  /* all the following function pointers can be NULL */

  void   (*cxFlush)(cdCtxCanvas* ctxcanvas);
  void   (*cxClear)(cdCtxCanvas* ctxcanvas);

  void   (*cxFPixel)(cdCtxCanvas* ctxcanvas, double x, double y, long color);
  void   (*cxFLine)(cdCtxCanvas* ctxcanvas, double x1, double y1, double x2, double y2);
  void   (*cxFPoly)(cdCtxCanvas* ctxcanvas, int mode, cdfPoint* points, int n);
  void   (*cxFRect)(cdCtxCanvas* ctxcanvas, double xmin, double xmax, double ymin, double ymax);
  void   (*cxFBox)(cdCtxCanvas* ctxcanvas, double xmin, double xmax, double ymin, double ymax);
  void   (*cxFArc)(cdCtxCanvas* ctxcanvas, double xc, double yc, double w, double h, double angle1, double angle2);
  void   (*cxFSector)(cdCtxCanvas* ctxcanvas, double xc, double yc, double w, double h, double angle1, double angle2);
  void   (*cxFChord)(cdCtxCanvas* ctxcanvas, double xc, double yc, double w, double h, double angle1, double angle2);
  void   (*cxFText)(cdCtxCanvas* ctxcanvas, double x, double y, const char *s, int len);

  int    (*cxClip)(cdCtxCanvas* ctxcanvas, int mode);
  void   (*cxClipArea)(cdCtxCanvas* ctxcanvas, int xmin, int xmax, int ymin, int ymax);
  void   (*cxFClipArea)(cdCtxCanvas* ctxcanvas, double xmin, double xmax, double ymin, double ymax);
  int    (*cxBackOpacity)(cdCtxCanvas* ctxcanvas, int opacity);
  int    (*cxWriteMode)(cdCtxCanvas* ctxcanvas, int mode);
  int    (*cxLineStyle)(cdCtxCanvas* ctxcanvas, int style);
  int    (*cxLineWidth)(cdCtxCanvas* ctxcanvas, int width);
  int    (*cxLineJoin)(cdCtxCanvas* ctxcanvas, int join);
  int    (*cxLineCap)(cdCtxCanvas* ctxcanvas, int cap);
  int    (*cxInteriorStyle)(cdCtxCanvas* ctxcanvas, int style);
  int    (*cxHatch)(cdCtxCanvas* ctxcanvas, int style);
  void   (*cxStipple)(cdCtxCanvas* ctxcanvas, int w, int h, const unsigned char *stipple);
  void   (*cxPattern)(cdCtxCanvas* ctxcanvas, int w, int h, const long *pattern);
  int    (*cxNativeFont)(cdCtxCanvas* ctxcanvas, const char* font);
  int    (*cxTextAlignment)(cdCtxCanvas* ctxcanvas, int alignment);
  double (*cxTextOrientation)(cdCtxCanvas* ctxcanvas, double angle);
  void   (*cxPalette)(cdCtxCanvas* ctxcanvas, int n, const long *palette, int mode);
  long   (*cxBackground)(cdCtxCanvas* ctxcanvas, long color);
  long   (*cxForeground)(cdCtxCanvas* ctxcanvas, long color);
  void   (*cxTransform)(cdCtxCanvas* ctxcanvas, const double* matrix);

  void   (*cxGetImageRGB)(cdCtxCanvas* ctxcanvas, unsigned char *r, unsigned char *g, unsigned char *b, int x, int y, int w, int h);
  void   (*cxPutImageRectRGB)(cdCtxCanvas* ctxcanvas, int iw, int ih, const unsigned char *r, const unsigned char *g, const unsigned char *b, int x, int y, int w, int h, int xmin, int xmax, int ymin, int ymax);
  void   (*cxPutImageRectRGBA)(cdCtxCanvas* ctxcanvas, int iw, int ih, const unsigned char *r, const unsigned char *g, const unsigned char *b, const unsigned char *a, int x, int y, int w, int h, int xmin, int xmax, int ymin, int ymax);

  void   (*cxFPutImageRectRGB)(cdCtxCanvas* ctxcanvas, int iw, int ih, const unsigned char* r, const unsigned char* g, const unsigned char* b, double x, double y, double w, double h, int xmin, int xmax, int ymin, int ymax);
  void   (*cxFPutImageRectRGBA)(cdCtxCanvas* ctxcanvas, int iw, int ih, const unsigned char* r, const unsigned char* g, const unsigned char* b, const unsigned char* a, double x, double y, double w, double h, int xmin, int xmax, int ymin, int ymax);
  void   (*cxFPutImageRectMap)(cdCtxCanvas* ctxcanvas, int iw, int ih, const unsigned char* index, const long* colors, double x, double y, double w, double h, int xmin, int xmax, int ymin, int ymax);

  void   (*cxScrollArea)(cdCtxCanvas* ctxcanvas, int xmin, int xmax, int ymin, int ymax, int dx, int dy);

  cdCtxImage* (*cxCreateImage)(cdCtxCanvas* ctxcanvas, int w, int h);
  void   (*cxKillImage)(cdCtxImage* ctximage);
  void   (*cxGetImage)(cdCtxCanvas* ctxcanvas, cdCtxImage* ctximage, int x, int y);
  void   (*cxPutImageRect)(cdCtxCanvas* ctxcanvas, cdCtxImage* ctximage, int x, int y, int xmin, int xmax, int ymin, int ymax);

  void   (*cxNewRegion)(cdCtxCanvas* ctxcanvas);
  int    (*cxIsPointInRegion)(cdCtxCanvas* ctxcanvas, int x, int y);
  void   (*cxOffsetRegion)(cdCtxCanvas* ctxcanvas, int x, int y);
  void   (*cxGetRegionBox)(cdCtxCanvas* ctxcanvas, int *xmin, int *xmax, int *ymin, int *ymax);

  int    (*cxActivate)(cdCtxCanvas* ctxcanvas);
  void   (*cxDeactivate)(cdCtxCanvas* ctxcanvas);

  /* the driver must update these, when the canvas is created and
     whenever the canvas change its size or bpp. */
  int w,h;            /* size in pixels */              /****  pixel =   mm   * res  ****/
  double w_mm, h_mm;  /* size in mm */                  /****   mm   =  pixel / res  ****/
  double xres, yres;  /* resolution in pixels/mm */     /****   res  =  pixel / mm   ****/
  int bpp;            /* number of bits per pixel */
  int invert_yaxis;   /* invert Y coordinates before calling the driver, 
                         used only when the native Y axis orientation is top-bottom "!(cap&CD_CAP_YAXIS)".
                         It is turned off by the driver if native transformation matrix is used. */
  double matrix[6];
  int use_matrix;

  /* clipping attributes */
  int clip_mode;
  cdRect clip_rect;
  cdfRect clip_frect;
  int clip_poly_n;
  cdPoint* clip_poly;    /* only defined if integer polygon created, if exist clip_fpoly is NULL, and ->Poly exists */
  cdfPoint* clip_fpoly;  /* only defined if real polygon created, if exist clip_poly is NULL, and ->fPoly exists  */

  /* clipping region attributes */
  int new_region;
  int combine_mode;
  
  /* color attributes */
  long foreground, background;
  int back_opacity, write_mode;

  /* primitive attributes */
  int mark_type, mark_size;

  int line_style, line_width;
  int line_cap, line_join;
  int* line_dashes;
  int line_dashes_count;

  int interior_style, hatch_style;
  int fill_mode;

  char font_type_face[1024];
  int font_style, font_size;
  int text_alignment;
  double text_orientation;
  char native_font[1024];

  int pattern_w, pattern_h, pattern_size;
  long* pattern;
  int stipple_w, stipple_h, stipple_size;
  unsigned char* stipple;

  /* origin */
  int use_origin;
  cdPoint origin;            /* both points contains the same coordinate always */
  cdfPoint forigin;

  /* last polygon */
  int poly_mode, 
      poly_n,                /* current number of vertices */
      poly_size, fpoly_size; /* allocated number of vertices, only increases */
  cdPoint* poly;             /* used during an integer polygon creation */
  cdfPoint* fpoly;           /* used during an real polygon creation, only if ->cxFPoly exists */
  int use_fpoly;

  /* last path */
  int path_n,                /* current number of actions */
      path_size;             /* allocated number of actions, only increases */
  int* path;                 /* used during path creation */
  int path_arc_index;        /* used for arc */

  /* simulation flags */
  int sim_mode;

  /* WC */
  double s, sx, tx, sy, ty;   /* Transform Window -> Viewport (scale+translation)*/
  cdfRect window;             /* Window in WC */
  cdRect viewport;            /* Viewport in pixels */

  cdAttribute* attrib_list[50];
  int attrib_n;

  cdVectorFont* vector_font;
  cdSimulation* simulation;
  cdCtxCanvas* ctxcanvas;
  cdContext* context;

  void* userdata;
};

enum{CD_BASE_WIN, CD_BASE_X, CD_BASE_GDK, CD_BASE_HAIKU};
int cdBaseDriver(void);

/***************/
/* attributes  */
/***************/
void cdRegisterAttribute(cdCanvas* canvas, cdAttribute* attrib);
void cdUpdateAttributes(cdCanvas* canvas);

/***************/
/* vector font */
/***************/
cdVectorFont* cdCreateVectorFont(cdCanvas* canvas);
void cdKillVectorFont(cdVectorFont* vector_font_data);

/**********/
/*   WC   */
/**********/
void wdSetDefaults(cdCanvas* canvas);

/********************/
/*   Context Plus   */
/********************/
void cdInitContextPlusList(cdContext* ctx_list[]);
cdContext* cdGetContextPlus(int ctx);
enum{CD_CTXPLUS_NATIVEWINDOW, CD_CTXPLUS_IMAGE, CD_CTXPLUS_DBUFFER, CD_CTXPLUS_PRINTER, CD_CTXPLUS_EMF, CD_CTXPLUS_CLIPBOARD}; 
#define CD_CTXPLUS_COUNT 6
#define CD_CTX_PLUS 0xFF00  /* to combine with context type */

/*************/
/* utilities */
/*************/
int cdRound(double x);
int cdCheckBoxSize(int *xmin, int *xmax, int *ymin, int *ymax);
int cdfCheckBoxSize(double *xmin, double *xmax, double *ymin, double *ymax);
void cdNormalizeLimits(int w, int h, int *xmin, int *xmax, int *ymin, int *ymax);
int cdGetFileName(const char* strdata, char* filename);
int cdStrEqualNoCase(const char* str1, const char* str2);
int cdStrEqualNoCasePartial(const char* str1, const char* str2);
int cdStrLineCount(const char* str);
char* cdStrDup(const char* str);
char* cdStrDupN(const char* str, int len);
int cdStrIsAscii(const char* str);
char* cdStrConvertToUTF8(const char* str, int len, char* utf8_buffer, int *utf8_buffer_len, int utf8mode);
void cdSetPaperSize(int size, double *w_pt, double *h_pt);
int cdGetFontFileName(const char* type_face, char* filename);
int cdGetFontFileNameDefault(const char *type_face, int style, char* filename);
int cdGetFontFileNameSystem(const char *type_face, int style, char* filename);
int cdStrTmpFileName(char* filename);
int cdMakeDirectory(const char *path);
int cdIsDirectory(const char* path);
int cdRemoveDirectory(const char *path);
void cdCopyFile(const char* srcFile, const char* destFile);

typedef struct _cdDirData
{
  const char* path;
  char filename[1024];
  int isDir;
  int closed;
  void* handle;
} cdDirData;

cdDirData* cdDirIterOpen(const char *path);
int cdDirIter(cdDirData * dirData);
void cdDirClose(cdDirData* dirData);

void cdPoly(cdCanvas* canvas, int mode, cdPoint* points, int n);

void cdGetArcBox(int xc, int yc, int w, int h, double a1, double a2, int *xmin, int *xmax, int *ymin, int *ymax);
int cdGetArcPathF(const cdPoint* poly, double *xc, double *yc, double *w, double *h, double *a1, double *a2);
int cdfGetArcPath(const cdfPoint* poly, double *xc, double *yc, double *w, double *h, double *a1, double *a2);
int cdGetArcPath(const cdPoint* poly, int *xc, int *yc, int *w, int *h, double *a1, double *a2);
void cdGetArcStartEnd(int xc, int yc, int w, int h, double a1, double a2, int *x1, int *y1, int *x2, int *y2);
void cdfGetArcStartEnd(double xc, double yc, double w, double h, double a1, double a2, double *x1, double *y1, double *x2, double *y2);

#define _cdCheckCanvas(_canvas) (_canvas!=NULL && ((unsigned char*)_canvas)[0] == 'C' && ((unsigned char*)_canvas)[1] == 'D')
#define _cdSwapInt(_a,_b) {int _c=_a;_a=_b;_b=_c;}
#define _cdSwapDouble(_a,_b) {double _c=_a;_a=_b;_b=_c;}
#define _cdRound(_x) ((int)(_x < 0? (_x-0.5): (_x+0.5)))
#define _cdRotateHatch(_x)  ((_x) = ((_x)<< 1) | ((_x)>>7))
#define _cdInvertYAxis(_canvas, _y) (_canvas->h - (_y) - 1)


/******************/
/* Transformation */
/******************/
void cdMatrixTransformPoint(double* matrix, int x, int y, int *rx, int *ry);
void cdfMatrixTransformPoint(double* matrix, double x, double y, double *rx, double *ry);
void cdMatrixMultiply(const double* matrix, double* mul_matrix);
void cdMatrixInverse(const double* matrix, double* inv_matrix);
void cdfRotatePoint(cdCanvas* canvas, double x, double y, double cx, double cy, double *rx, double *ry, double sin_theta, double cos_theta);
void cdRotatePoint(cdCanvas* canvas, int x, int y, int cx, int cy, int *rx, int *ry, double sin_teta, double cos_teta);
void cdRotatePointY(cdCanvas* canvas, int x, int y, int cx, int cy, int *ry, double sin_theta, double cos_theta);
void cdfRotatePointY(cdCanvas* canvas, double x, double y, double cx, double cy, double *ry, double sin_theta, double cos_theta);
void cdTextTranslatePoint(cdCanvas* canvas, int x, int y, int w, int h, int baseline, int *rx, int *ry);
void cdfTextTranslatePoint(cdCanvas* canvas, double x, double y, int w, int h, int baseline, double *rx, double *ry);
void cdMovePoint(int *x, int *y, double dx, double dy, double sin_theta, double cos_theta);
void cdfMovePoint(double *x, double *y, double dx, double dy, double sin_theta, double cos_theta);

/*************/
/*   Fonts   */
/*************/
int cdParsePangoFont(const char *nativefont, char *type_face, int *style, int *size);
int cdParseIupWinFont(const char *nativefont, char *type_face, int *style, int *size);
int cdParseXWinFont(const char *nativefont, char *type_face, int *style, int *size);
int cdGetFontSizePixels(cdCanvas* canvas, int size);
int cdGetFontSizePoints(cdCanvas* canvas, int size);

/* Replacements for Font using estimation */
/* cdfontex.c */
void cdgetfontdimEX(cdCtxCanvas* ctxcanvas, int *max_width, int *height, int *ascent, int *descent);
void cdgettextsizeEX(cdCtxCanvas* ctxcanvas, const char *s, int len, int *width, int *height);

/****************/
/*  For Images  */
/****************/
unsigned char cdZeroOrderInterpolation(int width, int height, const unsigned char *map, double xl, double yl);
unsigned char cdBilinearInterpolation(int width, int height, const unsigned char *map, double xl, double yl);
void cdImageRGBInitInverseTransform(int w, int h, int xmin, int xmax, int ymin, int ymax, double *xfactor, double *yfactor, const double* matrix, double* inv_matrix);
void cdImageRGBInverseTransform(int t_x, int t_y, double *i_x, double *i_y, double xfactor, double yfactor, int xmin, int ymin, int x, int y, double *inv_matrix);
void cdImageRGBCalcDstLimits(cdCanvas* canvas, int x, int y, int w, int h, int *xmin, int *xmax, int *ymin, int *ymax, int* rect);
void cdRGB2Gray(int width, int height, const unsigned char* red, const unsigned char* green, const unsigned char* blue, unsigned char* index, long *color);

#define CD_ALPHA_BLEND(_src,_dst,_alpha) (unsigned char)(((_src) * (_alpha) + (_dst) * (255 - (_alpha))) / 255)

int* cdGetZoomTable(int w, int rw, int xmin);
int cdCalcZoom(int canvas_size, int cnv_rect_pos, int cnv_rect_size, 
               int *new_cnv_rect_pos, int *new_cnv_rect_size, 
               int img_rect_pos, int img_rect_size, 
               int *new_img_rect_pos, int *new_img_rect_size, int is_horizontal);

/**************/
/* simulation */
/**************/

/* sim.c */
/* simulation base driver. */
cdSimulation* cdCreateSimulation(cdCanvas* canvas);
void cdKillSimulation(cdSimulation* simulation);
void cdSimulationInitText(cdSimulation* simulation);

/* sim_text.c */
/* Replacements for Text and Font using FreeType library */
void cdSimulationText(cdCtxCanvas* ctxcanvas, int x, int y, const char *s, int len);
int  cdSimulationFont(cdCtxCanvas* ctxcanvas, const char *type_face, int style, int size);
void cdSimulationGetFontDim(cdCtxCanvas* ctxcanvas, int *max_width, int *height, int *ascent, int *descent);
void cdSimulationGetTextSize(cdCtxCanvas* ctxcanvas, const char *s, int len, int *width, int *height);

/* sim_linepolyfill.c */
void cdfSimulationPoly(cdCtxCanvas* ctxcanvas, int mode, cdfPoint* fpoly, int n);
void cdSimulationPoly(cdCtxCanvas* ctxcanvas, int mode, cdPoint* poly, int n);

/* sim_primitives.c */
/* Simulation functions that are >> independent << of the simulation base driver. */

void cdSimMark(cdCanvas* canvas, int x, int y);
void cdfSimMark(cdCanvas* canvas, double x, double y);
void cdSimPutImageRectRGBA(cdCanvas* canvas, int iw, int ih, const unsigned char *r, const unsigned char *g, const unsigned char *b, const unsigned char *a, int x, int y, int w, int h, int xmin, int xmax, int ymin, int ymax);
void cdSimPutImageRectRGB(cdCanvas* canvas, int iw, int ih, const unsigned char *r, const unsigned char *g, const unsigned char *b, int x, int y, int w, int h, int xmin, int xmax, int ymin, int ymax);
void cdfSimPutImageRectRGB(cdCanvas* canvas, int iw, int ih, const unsigned char *r, const unsigned char *g, const unsigned char *b, double x, double y, double w, double h, int xmin, int xmax, int ymin, int ymax);
void cdfSimPutImageRectRGBA(cdCanvas* canvas, int iw, int ih, const unsigned char *r, const unsigned char *g, const unsigned char *b, const unsigned char *a, double x, double y, double w, double h, int xmin, int xmax, int ymin, int ymax);

/* All these use cdPoly. */
void cdSimLine(cdCtxCanvas* ctxcanvas, int x1, int y1, int x2, int y2);
void cdSimRect(cdCtxCanvas* ctxcanvas, int xmin, int xmax, int ymin, int ymax);
void cdSimBox(cdCtxCanvas* ctxcanvas, int xmin, int xmax, int ymin, int ymax);
void cdSimArc(cdCtxCanvas* ctxcanvas, int xc, int yc, int width, int height, double angle1, double angle2);
void cdSimSector(cdCtxCanvas* ctxcanvas, int xc, int yc, int width, int height, double angle1, double angle2);
void cdSimChord(cdCtxCanvas* ctxcanvas, int xc, int yc, int width, int height, double angle1, double angle2);
void cdSimPolyBezier(cdCanvas* canvas, const cdPoint* points, int n);
void cdSimPolyPath(cdCanvas* canvas, const cdPoint* points, int n);

/* All these use the polygon method ->cxFPoly only. */
/* can be used only by drivers that implement cxFPoly */
void cdfSimLine(cdCtxCanvas* ctxcanvas, double x1, double y1, double x2, double y2);
void cdfSimRect(cdCtxCanvas *ctxcanvas, double xmin, double xmax, double ymin, double ymax);
void cdfSimBox(cdCtxCanvas *ctxcanvas, double xmin, double xmax, double ymin, double ymax);
void cdfSimArc(cdCtxCanvas *ctxcanvas, double xc, double yc, double width, double height, double angle1, double angle2);
void cdfSimSector(cdCtxCanvas *ctxcanvas, double xc, double yc, double width, double height, double angle1, double angle2);
void cdfSimChord(cdCtxCanvas *ctxcanvas, double xc, double yc, double width, double height, double angle1, double angle2);
void cdfSimPolyBezier(cdCanvas* canvas, const cdfPoint* points, int n);
void cdfSimPolyPath(cdCanvas* canvas, const cdfPoint* points, int n);


#ifdef __cplusplus
}
#endif

#endif



================================================
File: cd/include/cdcairo.h
================================================
/** \file
 * \brief Cairo extra drivers.
 *        Rendering PDF, PS, SVG and IMAGERGB.
 *
 * See Copyright Notice in cd.h
 */

#ifndef __CD_CAIRO_H
#define __CD_CAIRO_H

#ifdef __cplusplus
extern "C" {
#endif

/* Some of these context can be used directly or by cdInitContextPlus,
   as  CD_NATIVEWINDOW, CD_IMAGE, CD_EMF, CD_PRINTER and CD_DBUFFER.
   The others only directly. 
*/

cdContext* cdContextCairoNativeWindow(void);
cdContext* cdContextCairoImage(void);
cdContext* cdContextCairoDBuffer(void);
cdContext* cdContextCairoPrinter(void);
cdContext* cdContextCairoPS(void);
cdContext* cdContextCairoPDF(void);
cdContext* cdContextCairoSVG(void);
cdContext* cdContextCairoImageRGB(void);
cdContext* cdContextCairoEMF(void);

#define CD_CAIRO_NATIVEWINDOW cdContextCairoNativeWindow()
#define CD_CAIRO_IMAGE cdContextCairoImage()
#define CD_CAIRO_DBUFFER cdContextCairoDBuffer()
#define CD_CAIRO_PRINTER cdContextCairoPrinter()
#define CD_CAIRO_PS cdContextCairoPS()
#define CD_CAIRO_PDF cdContextCairoPDF()
#define CD_CAIRO_SVG cdContextCairoSVG()
#define CD_CAIRO_IMAGERGB cdContextCairoImageRGB()
#define CD_CAIRO_EMF cdContextCairoEMF()


#ifdef __cplusplus
}
#endif

#endif /* ifndef __CD_CAIRO_ */



================================================
File: cd/include/cdcgm.h
================================================
/** \file
 * \brief CGM driver
 *
 * See Copyright Notice in cd.h
 */

#ifndef __CD_CGM_H
#define __CD_CGM_H

#ifdef __cplusplus
extern "C" {
#endif

cdContext* cdContextCGM(void);
#define CD_CGM cdContextCGM()

#define CD_CGMCOUNTERCB 1
#define CD_CGMSCLMDECB 2
#define CD_CGMVDCEXTCB 3
#define CD_CGMBEGPICTCB 4
#define CD_CGMBEGPICTBCB 5
#define CD_CGMBEGMTFCB 6

/* OLD definitions, defined for backward compatibility */
#define CDPLAY_ABORT CD_ABORT
#define CDPLAY_GO CD_CONTINUE

#ifdef __cplusplus
}
#endif

#endif /* ifndef __CD_CGM_ */





================================================
File: cd/include/cdclipbd.h
================================================
/** \file
 * \brief Clipboard driver
 *
 * See Copyright Notice in cd.h
 */

#ifndef __CD_CLIPBOARD_H
#define __CD_CLIPBOARD_H

#ifdef __cplusplus
extern "C" {
#endif

cdContext* cdContextClipboard(void);

#define CD_CLIPBOARD cdContextClipboard()

#ifdef __cplusplus
}
#endif

#endif



================================================
File: cd/include/cddbuf.h
================================================
/** \file
 * \brief Double Buffer driver
 *
 * See Copyright Notice in cd.h
 */

#ifndef __CD_DBUF_H
#define __CD_DBUF_H

#ifdef __cplusplus
extern "C" {
#endif

cdContext* cdContextDBuffer(void);

#define CD_DBUFFER cdContextDBuffer()

#ifdef __cplusplus
}
#endif

#endif /* ifndef __CD_DBUF_ */




================================================
File: cd/include/cddebug.h
================================================
/** \file
 * \brief CD Debug driver
 *
 * See Copyright Notice in cd.h
 */

#ifndef __CD_DEBUG_H
#define __CD_DEBUG_H

#ifdef __cplusplus
extern "C" {
#endif

cdContext* cdContextDebug(void);

#define CD_DEBUG cdContextDebug()

#ifdef __cplusplus
}
#endif

#endif /* ifndef __CD_DEBUG_H */





================================================
File: cd/include/cddgn.h
================================================
/** \file
 * \brief DGN driver
 *
 * See Copyright Notice in cd.h
 */

#ifndef __CD_DGN_H
#define __CD_DGN_H

#ifdef __cplusplus
extern "C" {
#endif

cdContext* cdContextDGN(void);

#define CD_DGN cdContextDGN()

#ifdef __cplusplus
}
#endif

#endif /* ifndef __CD_DGN_ */




================================================
File: cd/include/cddxf.h
================================================
/** \file
 * \brief DXF driver
 *
 * See Copyright Notice in cd.h
 */

#ifndef __CD_DXF_H
#define __CD_DXF_H

#ifdef __cplusplus
extern "C" {
#endif

cdContext* cdContextDXF(void);

#define CD_DXF cdContextDXF()

#ifdef __cplusplus
}
#endif

#endif /* ifndef __CD_DXF_ */



================================================
File: cd/include/cdemf.h
================================================
/** \file
 * \brief EMF driver
 *
 * See Copyright Notice in cd.h
 */

#ifndef __CD_EMF_H
#define __CD_EMF_H

#ifdef __cplusplus
extern "C" {
#endif

cdContext* cdContextEMF(void);

#define CD_EMF cdContextEMF()

#ifdef __cplusplus
}
#endif

#endif



================================================
File: cd/include/cdgdiplus.h
================================================
/** \file
 * \brief GDI+ Control
 *
 * See Copyright Notice in cd.h
 */
 
#ifndef __CD_GDIPLUS_H
#define __CD_GDIPLUS_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef WIN32
void cdInitGdiPlus(void);  /* old function, replaced by cdInitContextPlus */
#else
#define cdInitGdiPlus() (0)
#endif

/* Windows GDI+ Adicional Polygons */
#define CD_SPLINE       (CD_POLYCUSTOM+0)
#define CD_FILLSPLINE   (CD_POLYCUSTOM+1)
#define CD_FILLGRADIENT (CD_POLYCUSTOM+2)

#ifdef __cplusplus
}
#endif

#endif /* ifndef _CD_GDIPLUS_ */



================================================
File: cd/include/cdgl.h
================================================
/** \file
* \brief OpenGL driver
*
* See Copyright Notice in cd.h
*/

#ifndef __CD_GL_H
#define __CD_GL_H

#ifdef __cplusplus
extern "C" {
#endif

cdContext* cdContextGL(void);

#define CD_GL cdContextGL()

#ifdef __cplusplus
}
#endif

#endif /* ifndef __CD_GL_ */




================================================
File: cd/include/cdim.h
================================================
/** \file
 * \brief imImage driver
 *
 * See Copyright Notice in cd.h
 */

#ifndef __CD_IM_H
#define __CD_IM_H

#ifdef __cplusplus
extern "C" {
#endif

cdContext* cdContextImImage(void);

#define CD_IMIMAGE cdContextImImage()


#ifdef __IM_IMAGE_H
void cdCanvasPatternImImage(cdCanvas* canvas, const imImage* image);
void cdCanvasStippleImImage(cdCanvas* canvas, const imImage* image);
void cdCanvasPutImImage(cdCanvas* canvas, const imImage* image, int x, int y, int w, int h);
void cdCanvasGetImImage(cdCanvas* canvas, imImage* image, int x, int y);
void cdfCanvasPutImImage(cdCanvas* canvas, const imImage* image, double x, double y, double w, double h);
void wdCanvasPutImImage(cdCanvas* canvas, const imImage* image, double x, double y, double w, double h);
void wdCanvasGetImImage(cdCanvas* canvas, imImage* image, double x, double y);
#endif

#ifdef __cplusplus
}
#endif

#endif /* ifndef __CD_IM_ */



================================================
File: cd/include/cdimage.h
================================================
/** \file
 * \brief Server Image driver
 *
 * See Copyright Notice in cd.h
 */

#ifndef __CD_IMAGE_H
#define __CD_IMAGE_H

#ifdef __cplusplus
extern "C" {
#endif

cdContext* cdContextImage(void);

#define CD_IMAGE cdContextImage()

#ifdef __cplusplus
}
#endif

#endif /* ifndef __CD_IMAGE_ */




================================================
File: cd/include/cdirgb.h
================================================
/** \file
 * \brief IMAGERGB driver
 *
 * See Copyright Notice in cd.h
 */

#ifndef __CD_IRGB_H
#define __CD_IRGB_H

#ifdef __cplusplus
extern "C" {
#endif

cdContext* cdContextImageRGB(void);
cdContext* cdContextDBufferRGB(void);

#define CD_IMAGERGB cdContextImageRGB()
#define CD_DBUFFERRGB cdContextDBufferRGB()

/* DEPRECATED functions, use REDIMAGE, GREENIMAGE, 
   BLUEIMAGE, and ALPHAIMAGE attributes. */
unsigned char* cdRedImage(cdCanvas* cnv);
unsigned char* cdGreenImage(cdCanvas* cnv);
unsigned char* cdBlueImage(cdCanvas* cnv);
unsigned char* cdAlphaImage(cdCanvas* cnv);


#ifdef __cplusplus
}
#endif

#endif /* ifndef __CD_IRGB_ */



================================================
File: cd/include/cdiup.h
================================================
/** \file
 * \brief IUP driver
 *
 * See Copyright Notice in cd.h
 */

#ifndef __CD_IUP_H
#define __CD_IUP_H

#ifdef __cplusplus
extern "C" {
#endif

/* NOTICE: implemented done in IUP at the IUPCD library. 
   Only this files is at the CD files. */

cdContext* cdContextIup(void);
cdContext* cdContextIupDBuffer(void);
cdContext* cdContextIupDBufferRGB(void);

#define CD_IUP           cdContextIup()
#define CD_IUPDBUFFER    cdContextIupDBuffer()
#define CD_IUPDBUFFERRGB cdContextIupDBufferRGB()

#ifdef __cplusplus
}
#endif

#endif



================================================
File: cd/include/cdlua.h
================================================
/** \file
 * \brief Lua Binding Control
 *
 * See Copyright Notice in cd.h
 */

#ifndef __CD_LUA_H
#define __CD_LUA_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef LUA_NOOBJECT  /* Lua 3 */
void cdlua_open(void);
void cdlua_close(void);

/* utilities */
cdCanvas* cdlua_getcanvas(void);        /* pos=1, deprecated use cdlua_checkcanvas */
cdCanvas* cdlua_checkcanvas(int pos);
void cdlua_pushcanvas(cdCanvas* canvas);
#endif

#ifdef LUA_TNONE  /* Lua 5 */
int cdlua_open(lua_State *L);
int cdlua_close(lua_State *L);

/* utilities */
cdCanvas* cdlua_getcanvas(lua_State * L); /* pos=1, deprecated use cdlua_checkcanvas */
cdCanvas* cdlua_checkcanvas(lua_State * L, int pos);
void cdlua_pushcanvas(lua_State * L, cdCanvas* canvas);

#endif

#ifdef __cplusplus
}
#endif

#endif




================================================
File: cd/include/cdlua3_private.h
================================================
/** \file
 * \brief Private Lua 3 Binding Functions
 *
 * See Copyright Notice in cd.h
 */

#ifndef __CDLUA3_PRIVATE_H
#define __CDLUA3_PRIVATE_H

#ifdef __cplusplus
extern "C" {
#endif

#define COLOR_TAG     "CDLUA_COLOR_TAG"
#define CANVAS_TAG    "CDLUA_CANVAS_TAG"
#define STATE_TAG     "CDLUA_STATE_TAG"
#define BITMAP_TAG    "CDLUA_BITMAP_TAG"
#define IMAGE_TAG     "CDLUA_IMAGE_TAG"
#define IMAGERGB_TAG  "CDLUA_IMAGERGB_TAG"
#define IMAGERGBA_TAG "CDLUA_IMAGERGBA_TAG"
#define STIPPLE_TAG   "CDLUA_STIPPLE_TAG"
#define PATTERN_TAG   "CDLUA_PATTERN_TAG"
#define PALETTE_TAG   "CDLUA_PALETTE_TAG"
#define IMAGEMAP_TAG  "CDLUA_IMAGEMAP_TAG"
#define CHANNEL_TAG   "CDLUA_CHANNEL_TAG"

/* context management */

typedef struct _cdCallbackLUA {
  int lock;
  char *name;
  cdCallback func;
} cdCallbackLUA;

typedef struct _cdContextLUA {
  int id;
  char *name;
  cdContext* (*ctx)(void);
  void* (*checkdata)(int param);
  cdCallbackLUA* cb_list;
  int cb_n;
} cdContextLUA;

void cdlua_addcontext(cdContextLUA* luactx);
void cdlua_register(char* name, lua_CFunction func);
void cdlua_pushnumber(double num, char* name);

/* tag management */

typedef struct _canvas_t {
  cdCanvas *cd_canvas;
} canvas_t;

typedef struct _state_t {
  cdState *state;
} state_t;

typedef struct _stipple_t {
  unsigned char *value;
  int width;
  int height;
  long int size;
} stipple_t;

typedef struct _pattern_t {
  long int *color;
  int width;
  int height;
  long int size;
} pattern_t;

typedef struct _palette_t {
  long int *color;
  long int size;
} palette_t;

typedef struct _image_t {
  void *cd_image;
} image_t;

typedef struct _imagergb_t {
  unsigned char *red;
  unsigned char *green;
  unsigned char *blue;
  int width;
  int height;
  long int size;
} imagergb_t;

typedef struct _imagergba_t {
  unsigned char *red;
  unsigned char *green;
  unsigned char *blue;
  unsigned char *alpha;
  int width;
  int height;
  long int size;
} imagergba_t;
         
typedef struct _imagemap_t {
  unsigned char *index;
  int width;
  int height;
  long int size;
} imagemap_t;

typedef struct _channel_t {
  unsigned char *value;
  long int size;
} channel_t;

typedef struct _bitmap_t {
  cdBitmap *image;
} bitmap_t;

#ifdef __cplusplus
}
#endif

#endif



================================================
File: cd/include/cdlua5_private.h
================================================
/** \file
* \brief Private Lua 5 Binding Functions
* 
* See Copyright Notice in cd.h
*/

#ifndef __CDLUA5_PRIVATE_H
#define __CDLUA5_PRIVATE_H

#ifdef __cplusplus
extern "C" {
#endif


/* context management */

typedef struct _cdluaCallback {
  int lock;
  const char* name;
  cdCallback func;
} cdluaCallback;

typedef struct _cdluaContext {
  int id;
  const char* name;
  cdContext* (*ctx)(void);
  void* (*checkdata)(lua_State* L,int param);
  cdluaCallback* cb_list;
  int cb_n;
} cdluaContext;

typedef struct _cdluaLuaState {
  cdCanvas* void_canvas;            /* the VOID canvas to avoid a NULL active canvas */
  cdluaContext* drivers[50];  /* store the registered drivers, map integer values to cdContext */
  int numdrivers;
} cdluaLuaState;

/* metatables */

typedef struct _cdluaStipple {
  unsigned char* stipple;
  int width;
  int height;
  long int size;
} cdluaStipple;

typedef struct _cdluaPattern {
  long* pattern;
  int width;
  int height;
  long int size;
} cdluaPattern;

/* this is the same declaration used in the IM toolkit for imPalette in Lua */
typedef struct _cdluaPalette {
  long* color;
  int count;
} cdluaPalette;

typedef struct _cdluaImageRGB {
  unsigned char* red;
  unsigned char* green;
  unsigned char* blue;
  int width;
  int height;
  long int size;
  int free;
} cdluaImageRGB;

typedef struct _cdluaImageRGBA {
  unsigned char* red;
  unsigned char* green;
  unsigned char* blue;
  unsigned char* alpha;
  int width;
  int height;
  long int size;
  int free;
} cdluaImageRGBA;
         
typedef struct _cdluaImageMap {
  unsigned char* index;
  int width;
  int height;
  long int size;
} cdluaImageMap;

typedef struct _cdluaImageChannel {
  unsigned char* channel;
  long int size;
} cdluaImageChannel;


cdluaLuaState* cdlua_getstate(lua_State* L);
cdluaContext* cdlua_getcontext(lua_State* L, int param);

lua_State* cdlua_getplaystate(void);
void cdlua_setplaystate(lua_State* L);

void cdlua_register_lib(lua_State *L, const luaL_Reg* funcs);
void cdlua_register_funcs(lua_State *L, const luaL_Reg* funcs);

void cdlua_kill_active(lua_State* L, cdCanvas* canvas);
void cdlua_open_active(lua_State* L, cdluaLuaState* cdL);

void cdlua_open_canvas(lua_State* L);

void cdlua_addcontext(lua_State* L, cdluaLuaState* cdL, cdluaContext* luactx);
void cdlua_initdrivers(lua_State* L, cdluaLuaState* cdL);

cdluaPalette* cdlua_checkpalette(lua_State* L, int param);
cdluaStipple* cdlua_checkstipple(lua_State* L, int param);
cdluaPattern* cdlua_checkpattern(lua_State* L, int param);
cdluaImageRGB* cdlua_checkimagergb(lua_State* L, int param);
cdluaImageRGBA* cdlua_checkimagergba(lua_State* L, int param);
cdluaImageMap* cdlua_checkimagemap(lua_State* L, int param);
cdluaImageChannel* cdlua_checkchannel(lua_State* L, int param);

long cdlua_checkcolor(lua_State* L, int param);
cdImage* cdlua_checkimage(lua_State* L, int param);
cdState* cdlua_checkstate(lua_State* L, int param);
cdBitmap* cdlua_checkbitmap(lua_State* L, int param);

void cdlua_pushcolor(lua_State* L, long color);
void cdlua_pushpalette(lua_State* L, long* palette, int size);
void cdlua_pushstipple(lua_State* L, unsigned char* stipple, int width, int height);
void cdlua_pushpattern(lua_State* L, long int* pattern, int width, int height);
void cdlua_pushimagergb(lua_State* L, unsigned char* red, unsigned char* green, unsigned char* blue, int width, int height);
void cdlua_pushimagergba(lua_State* L, unsigned char* red, unsigned char* green, unsigned char* blue, unsigned char* alpha, int width, int height);
void cdlua_pushimagemap(lua_State* L, unsigned char* index, int width, int height);
void cdlua_pushchannel(lua_State* L, unsigned char* channel, int size);

void cdlua_pushimage(lua_State* L, cdImage* image);
void cdlua_pushstate(lua_State* L, cdState* state);
void cdlua_pushbitmap(lua_State* L, cdBitmap* bitmap);

void cdlua_pushimagergb_ex(lua_State* L, unsigned char* red, unsigned char* green, unsigned char* blue, int width, int height);
void cdlua_pushimagergba_ex(lua_State* L, unsigned char* red, unsigned char* green, unsigned char* blue, unsigned char* alpha, int width, int height);

#ifdef __cplusplus
}
#endif

#endif



================================================
File: cd/include/cdluagl.h
================================================
/** \file
 * \brief OpenGL Canvas Lua Binding
 *
 * See Copyright Notice in cd.h
 */

#ifndef __CD_LUAGL_H
#define __CD_LUAGL_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef LUA_NOOBJECT  /* Lua 3 */
void cdluagl_open(void);
#endif

#ifdef LUA_TNONE  /* Lua 5 */
int cdluagl_open(lua_State *L);
#endif

#ifdef __cplusplus
}
#endif

#endif




================================================
File: cd/include/cdluaim.h
================================================
/** \file
 * \brief CD+IM Lua Binding
 *
 * See Copyright Notice in cd.h
 */

#ifndef __CD_LUAIM_H
#define __CD_LUAIM_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef LUA_TNONE  /* Lua 5 */
int cdluaim_open(lua_State *L);
#endif

#ifdef __cplusplus
}
#endif

#endif



================================================
File: cd/include/cdluaiup.h
================================================
/** \file
 * \brief IUP Canvas Lua Binding
 *
 * See Copyright Notice in cd.h
 */

#ifndef __CD_LUAIUP_H
#define __CD_LUAIUP_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef LUA_NOOBJECT  /* Lua 3 */
void cdluaiup_open(void);
#endif

#ifdef LUA_TNONE  /* Lua 5 */
int cdluaiup_open(lua_State *L);
#endif

#ifdef __cplusplus
}
#endif

#endif




================================================
File: cd/include/cdluapdf.h
================================================
/** \file
 * \brief PDF Canvas Lua Binding
 *
 * See Copyright Notice in cd.h
 */

#ifndef __CD_LUAPDF_H
#define __CD_LUAPDF_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef LUA_NOOBJECT  /* Lua 3 */
void cdluapdf_open(void);
#endif

#ifdef LUA_TNONE  /* Lua 5 */
int cdluapdf_open(lua_State *L);
#endif

#ifdef __cplusplus
}
#endif

#endif




================================================
File: cd/include/cdmf.h
================================================
/** \file
 * \brief CD Metafile driver
 *
 * See Copyright Notice in cd.h
 */

#ifndef __CD_MF_H
#define __CD_MF_H

#ifdef __cplusplus
extern "C" {
#endif

cdContext* cdContextMetafile(void);

#define CD_METAFILE cdContextMetafile()

#ifdef __cplusplus
}
#endif

#endif /* ifndef __CD_MF_ */





================================================
File: cd/include/cdmf_private.h
================================================
/** \file
 * \brief CD Metafile driver private declarations
 *
 * See Copyright Notice in cd.h
 */

#ifndef __CDMF_PRIVATE_H
#define __CDMF_PRIVATE_H

#ifdef __cplusplus
extern "C" {
#endif

/* public part of the internal cdCtxCanvas */
typedef struct cdCanvasMF 
{
  cdCanvas* canvas;
  char* filename;       
  void* data;           
} cdCanvasMF;

void cdcreatecanvasMF(cdCanvas *canvas, void *data);
void cdinittableMF(cdCanvas* canvas);
void cdkillcanvasMF(cdCanvasMF *mfcanvas);

#ifdef __cplusplus
}
#endif

#endif 





================================================
File: cd/include/cdnative.h
================================================
/** \file
 * \brief NativeWindow driver
 *
 * See Copyright Notice in cd.h
 */

#ifndef __CD_NATIVE_H
#define __CD_NATIVE_H

#ifdef __cplusplus
extern "C" {
#endif

cdContext* cdContextNativeWindow(void);

#define CD_NATIVEWINDOW cdContextNativeWindow()

void cdGetScreenSize(int *width, int *height, double *width_mm, double *height_mm);
int cdGetScreenColorPlanes(void);

#ifdef __cplusplus
}
#endif

#endif /* ifndef __CD_NATIVE_ */




================================================
File: cd/include/cdpdf.h
================================================
/** \file
 * \brief PDF driver
 *
 * See Copyright Notice in cd.h
 */

#ifndef __CD_PDF_H
#define __CD_PDF_H

#ifdef __cplusplus
extern "C" {
#endif

cdContext* cdContextPDF(void);

#define CD_PDF cdContextPDF()
        
#ifdef __cplusplus
}
#endif

#endif /* ifndef _CD_PDF_ */




================================================
File: cd/include/cdpicture.h
================================================
/** \file
 * \brief CD Picture driver
 *
 * See Copyright Notice in cd.h
 */

#ifndef __CD_PICTURE_H
#define __CD_PICTURE_H

#ifdef __cplusplus
extern "C" {
#endif

cdContext* cdContextPicture(void);

#define CD_PICTURE cdContextPicture()

#ifdef __cplusplus
}
#endif

#endif



================================================
File: cd/include/cdpptx.h
================================================
/** \file
 * \brief PPTX driver
 *
 * See Copyright Notice in cd.h
 */

#ifndef __CD_PPTX_H
#define __CD_PPTX_H

#ifdef __cplusplus
extern "C" {
#endif

cdContext* cdContextPPTX(void);
#define CD_PPTX cdContextPPTX()

#ifdef __cplusplus
}
#endif

#endif /* ifndef __CD_PPTX_ */



================================================
File: cd/include/cdprint.h
================================================
/** \file
 * \brief Printer driver
 *
 * See Copyright Notice in cd.h
 */

#ifndef __CD_PRINTER_H
#define __CD_PRINTER_H

#ifdef __cplusplus
extern "C" {
#endif

cdContext* cdContextPrinter(void);

#define CD_PRINTER cdContextPrinter()

#ifdef __cplusplus
}
#endif

#endif /* ifndef __CD_PRINTER_ */




================================================
File: cd/include/cdps.h
================================================
/** \file
 * \brief PS driver
 *
 * See Copyright Notice in cd.h
 */

#ifndef __CD_PS_H
#define __CD_PS_H

#ifdef __cplusplus
extern "C" {
#endif

cdContext* cdContextPS(void);

#define CD_PS cdContextPS()

#ifdef __cplusplus
}
#endif

#endif /* ifndef __CD_PS_ */




================================================
File: cd/include/cdsvg.h
================================================
/** \file
 * \brief SVG driver
 *
 * See Copyright Notice in cd.h
 */

#ifndef __CD_SVG_H
#define __CD_SVG_H

#ifdef __cplusplus
extern "C" {
#endif

cdContext* cdContextSVG(void);

#define CD_SVG cdContextSVG()

#ifdef __cplusplus
}
#endif

#endif /* ifndef __CD_SVG_ */



================================================
File: cd/include/cdwmf.h
================================================
/** \file
 * \brief WMF driver
 *
 * See Copyright Notice in cd.h
 */

#ifndef __CD_WMF_H
#define __CD_WMF_H

#ifdef __cplusplus
extern "C" {
#endif

cdContext* cdContextWMF(void);

#define CD_WMF cdContextWMF()

#ifdef __cplusplus
}
#endif

#endif



================================================
File: cd/include/wd.h
================================================
/** \file
 * \brief World Coordinate Functions
 *
 * See Copyright Notice in cd.h
 */

#ifndef __WD_H
#define __WD_H

#ifdef __cplusplus
extern "C" {
#endif

int  wdCanvasPlay(cdCanvas* canvas, cdContext *context, double xmin, double xmax, double ymin, double ymax, void *data);

/* coordinate transformation */
void wdCanvasWindow(cdCanvas* canvas, double xmin, double xmax, double  ymin, double ymax);
void wdCanvasGetWindow(cdCanvas* canvas, double *xmin, double  *xmax,  double  *ymin, double *ymax);
void wdCanvasViewport(cdCanvas* canvas, int xmin, int xmax, int ymin, int ymax);
void wdCanvasGetViewport(cdCanvas* canvas, int *xmin, int  *xmax,  int  *ymin, int *ymax);
void wdCanvasWorld2Canvas(cdCanvas* canvas, double xw, double yw, int *xv, int *yv);
void wdCanvasWorld2CanvasSize(cdCanvas* canvas, double hw, double vw, int *hv, int *vv);
void wdCanvasCanvas2World(cdCanvas* canvas, int xv, int yv, double *xw, double *yw);
void wdCanvasSetTransform(cdCanvas* canvas, double sx, double sy, double tx, double ty);
void wdCanvasGetTransform(cdCanvas* canvas, double *sx, double *sy, double *tx, double *ty);
void wdCanvasTranslate(cdCanvas* canvas, double dtx, double dty);
void wdCanvasScale(cdCanvas* canvas, double dsx, double dsy);

void wdCanvasClipArea(cdCanvas* canvas, double xmin, double xmax, double  ymin, double ymax);
int  wdCanvasGetClipArea(cdCanvas* canvas, double *xmin, double *xmax, double *ymin, double *ymax);
int  wdCanvasIsPointInRegion(cdCanvas* canvas, double x, double y);
void wdCanvasOffsetRegion(cdCanvas* canvas, double x, double y);
void wdCanvasGetRegionBox(cdCanvas* canvas, double *xmin, double *xmax, double *ymin, double *ymax);

void wdCanvasHardcopy(cdCanvas* canvas, cdContext* ctx, void *data, void(*draw_func)(cdCanvas *canvas_copy));

/* primitives */
void wdCanvasPixel(cdCanvas* canvas, double x, double y, long color);
void wdCanvasMark(cdCanvas* canvas, double x, double y);
void wdCanvasLine(cdCanvas* canvas, double x1, double y1, double x2, double y2);
void wdCanvasVertex(cdCanvas* canvas, double x, double y);
void wdCanvasRect(cdCanvas* canvas, double xmin, double xmax, double ymin, double ymax);
void wdCanvasBox(cdCanvas* canvas, double xmin, double xmax, double ymin, double ymax);
void wdCanvasArc(cdCanvas* canvas, double xc, double yc, double w, double h, double angle1, double angle2);
void wdCanvasSector(cdCanvas* canvas, double xc, double yc, double w, double h, double angle1, double angle2);
void wdCanvasChord(cdCanvas* canvas, double xc, double yc, double w, double h, double angle1, double angle2);
void wdCanvasText(cdCanvas* canvas, double x, double y, const char* s);

void wdCanvasGetImageRGB(cdCanvas* canvas, unsigned char* r, unsigned char* g, unsigned char* b, double x, double y, int iw, int ih);
void wdCanvasPutImageRectRGB(cdCanvas* canvas, int iw, int ih, const unsigned char* r, const unsigned char* g, const unsigned char* b, double x, double y, double w, double h, int xmin, int xmax, int ymin, int ymax);
void wdCanvasPutImageRectRGBA(cdCanvas* canvas, int iw, int ih, const unsigned char* r, const unsigned char* g, const unsigned char* b, const unsigned char* a, double x, double y, double w, double h, int xmin, int xmax, int ymin, int ymax);
void wdCanvasPutImageRectMap(cdCanvas* canvas, int iw, int ih, const unsigned char* index, const long* colors, double x, double y, double w, double h, int xmin, int xmax, int ymin, int ymax);

void wdCanvasPutImageRect(cdCanvas* canvas, cdImage* image, double x, double y, int xmin, int xmax, int ymin, int ymax);

void wdCanvasPutBitmap(cdCanvas* canvas, cdBitmap* bitmap, double x, double y, double w, double h);

/* attributes */
double wdCanvasLineWidth(cdCanvas* canvas, double width);
int wdCanvasFont(cdCanvas* canvas, const char* type_face, int style, double size);
void wdCanvasGetFont(cdCanvas* canvas, char *type_face, int *style, double *size);
double wdCanvasMarkSize(cdCanvas* canvas, double size);
void wdCanvasGetFontDim(cdCanvas* canvas, double *max_width, double *height, double *ascent, double *descent);
void wdCanvasGetTextSize(cdCanvas* canvas, const char* s, double *width, double *height);
void wdCanvasGetTextBox(cdCanvas* canvas, double x, double y, const char* s, double *xmin, double *xmax, double *ymin, double *ymax);
void wdCanvasGetTextBounds(cdCanvas* canvas, double x, double y, const char* s, double *rect);
void wdCanvasStipple(cdCanvas* canvas, int w, int h, const unsigned char*fgbg, double w_mm, double h_mm);
void wdCanvasPattern(cdCanvas* canvas, int w, int h, const long *color, double w_mm, double h_mm);

/* vector text */
void wdCanvasVectorTextDirection(cdCanvas* canvas, double x1, double y1, double x2, double y2);
void wdCanvasVectorTextSize(cdCanvas* canvas, double size_x, double size_y, const char* s);
void wdCanvasGetVectorTextSize(cdCanvas* canvas, const char* s, double *x, double *y);
double wdCanvasVectorCharSize(cdCanvas* canvas, double size);
void wdCanvasVectorText(cdCanvas* canvas, double x, double y, const char* s);
void wdCanvasMultiLineVectorText(cdCanvas* canvas, double x, double y, const char* s);
void wdCanvasGetVectorTextBounds(cdCanvas* canvas, const char* s, double x, double y, double *rect);
void wdCanvasGetVectorTextBox(cdCanvas* canvas, double x, double y, const char *s, double *xmin, double *xmax, double *ymin, double *ymax);

#ifdef __cplusplus
}
#endif

#ifndef CD_NO_OLD_INTERFACE
#include "wd_old.h"
#endif

#endif



================================================
File: cd/include/wd_old.h
================================================
/** \file
 * \brief Old WC API
 *
 * See Copyright Notice in cd.h
 */

#ifndef WD_OLD_H
#define WD_OLD_H

#ifdef __cplusplus
extern "C" {
#endif

/* coordinate transformation */
void wdWindow(double xmin, double xmax, double  ymin, double ymax);
void wdGetWindow(double *xmin, double  *xmax,  double  *ymin, double *ymax);
void wdViewport(int xmin, int xmax, int ymin, int ymax);
void wdGetViewport(int *xmin, int  *xmax,  int  *ymin, int *ymax);
void wdWorld2Canvas(double xw, double yw, int *xv, int *yv);
void wdWorld2CanvasSize(double hw, double vw, int *hv, int *vv);
void wdCanvas2World(int xv, int yv, double *xw, double *yw);

void wdClipArea(double xmin, double xmax, double  ymin, double ymax);
int  wdGetClipArea(double *xmin, double *xmax, double *ymin, double *ymax);
double* wdGetClipPoly(int *n);
int  wdPointInRegion(double x, double y);
void wdOffsetRegion(double x, double y);
void wdRegionBox(double *xmin, double *xmax, double *ymin, double *ymax);

void wdHardcopy(cdContext* ctx, void *data, cdCanvas *cnv, void(*draw_func)(void));

/* primitives */
void wdPixel(double x, double y, long color);
void wdMark(double x, double y);
void wdLine(double x1, double y1, double x2, double y2);
void wdVertex(double x, double y);
void wdRect(double xmin, double xmax, double ymin, double ymax);
void wdBox(double xmin, double xmax, double ymin, double ymax);
void wdArc(double xc, double yc, double w, double h, double angle1, double angle2);
void wdSector(double xc, double yc, double w, double h, double angle1, double angle2);
void wdChord(double xc, double yc, double w, double h, double angle1, double angle2);
void wdText(double x, double y, const char* s);

void wdPutImageRect(cdImage* image, double x, double y, int xmin, int xmax, int ymin, int ymax);
void wdPutImageRectRGB(int iw, int ih, const unsigned char* r, const unsigned char* g, const unsigned char* b, double x, double y, double w, double h, int xmin, int xmax, int ymin, int ymax);
void wdPutImageRectRGBA(int iw, int ih, const unsigned char* r, const unsigned char* g, const unsigned char* b, const unsigned char* a, double x, double y, double w, double h, int xmin, int xmax, int ymin, int ymax);
void wdPutImageRectMap(int iw, int ih, const unsigned char* index, const long* colors, double x, double y, double w, double h, int xmin, int xmax, int ymin, int ymax);
void wdPutBitmap(cdBitmap* bitmap, double x, double y, double w, double h);

/* attributes */
double wdLineWidth(double width);
void wdFont(int type_face, int style, double size);
void wdGetFont(int *type_face, int *style, double *size);
double wdMarkSize(double size);
void wdFontDim(double *max_width, double *height, double *ascent, double *descent);
void wdTextSize(const char* s, double *width, double *height);
void wdTextBox(double x, double y, const char* s, double *xmin, double *xmax, double *ymin, double *ymax);
void wdTextBounds(double x, double y, const char* s, double *rect);
void wdStipple(int w, int h, const unsigned char* stipple, double w_mm, double h_mm);
void wdPattern(int w, int h, const long* pattern, double w_mm, double h_mm);

/* vector text */
void wdVectorTextDirection(double x1, double y1, double x2, double y2);
void wdVectorTextSize(double size_x, double size_y, const char* s);
void wdGetVectorTextSize(const char* s, double *x, double *y);
double wdVectorCharSize(double size);
void wdVectorText(double x, double y, const char* s);
void wdMultiLineVectorText(double x, double y, const char* s);
void wdGetVectorTextBounds(const char* s, double x, double y, double *rect);

/* OLD definitions, defined for backward compatibility */
#define wdVectorFont cdVectorFont
#define wdVectorTextTransform cdVectorTextTransform
#define wdActivate cdActivate
#define wdClip(mode) cdClip(mode)
#define wdBegin(mode) cdBegin(mode)
#define wdEnd() cdEnd();
#define wdMM2Pixel(mm_dx, mm_dy, dx, dy) cdMM2Pixel(mm_dx, mm_dy, dx, dy)
#define wdPixel2MM(dx, dy, mm_dx, mm_dy) cdPixel2MM(dx, dy, mm_dx, mm_dy)

#ifdef __cplusplus
}
#endif

#endif



================================================
File: iup/etc/iup.manifest
================================================
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0" xmlns:asmv3="urn:schemas-microsoft-com:asm.v3">
  <assemblyIdentity
      version="3.0.0.0"
      processorArchitecture="x86"
      name="IupApp"
      type="win32"
  />
  <description>Iup Application</description>
  <dependency>
      <dependentAssembly>
          <assemblyIdentity
              type="win32"
              name="Microsoft.Windows.Common-Controls"
              version="6.0.0.0"
              processorArchitecture="x86"
              publicKeyToken="6595b64144ccf1df"
              language="*"
          />
      </dependentAssembly>
  </dependency>
  <asmv3:application>
    <asmv3:windowsSettings xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">
      <dpiAware>true</dpiAware>
    </asmv3:windowsSettings>
  </asmv3:application>
  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">
    <security>
      <requestedPrivileges>
        <requestedExecutionLevel
            level="asInvoker"
            uiAccess="false"
                />
      </requestedPrivileges>
    </security>
  </trustInfo>
  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
    <application>
      <!-- Windows 10 -->
      <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>
      <!-- Windows 8.1 -->
      <supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}"/>
      <!-- Windows Vista -->
      <supportedOS Id="{e2011457-1546-43c5-a5fe-008deee3d3f0}"/>
      <!-- Windows 7 -->
      <supportedOS Id="{35138b9a-5d96-4fbd-8e2d-a2440225f93a}"/>
      <!-- Windows 8 -->
      <supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}"/>
    </application>
  </compatibility>
</assembly>



================================================
File: iup/etc/iup.rc
================================================
TECGRAF_ICON ICON "tecgraf.ico"  /* the first icon will also defines the executable icon in Explorer */
CURSOR_PEN CURSOR "pen.cur"

/****************************************************/
/* Applications can change or remove this */

1 VERSIONINFO
 FILEVERSION 3,20,0,0
 PRODUCTVERSION 3,20,0,0
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "Comments", "www.tecgraf.puc-rio.br/iup\0"
            VALUE "CompanyName", "Tecgraf/PUC-Rio\0"
            VALUE "FileDescription", "IUP - Portable User Interface\0"
            VALUE "FileVersion", "3.20.0\0"
            VALUE "LegalCopyright", "Copyright © 1994-2016 Tecgraf/PUC-Rio.\0"
            VALUE "OriginalFilename", "iup.dll\0"
            VALUE "ProductName", "IUP for Windows\0"
            VALUE "ProductVersion", "3.20.0\0"
        END
    END
END

/****************************************************/
/* Used by IupFileDlg when SHOWPREVIEW=Yes */

/* To avoid the inclusion of <winuser.h> */
#define WS_CHILD            0x40000000L
#define WS_VISIBLE          0x10000000L
#define WS_CLIPSIBLINGS     0x04000000L
#define DS_3DLOOK           0x0004L
#define DS_CONTROL          0x0400L
#define SS_OWNERDRAW        0x0000000DL
#define WS_EX_STATICEDGE    0x00020000L

#define IUP_PREVIEWCANVAS 3000  /* 0x0BB8 */

iupPreviewDlg DIALOG DISCARDABLE  0, 0, 250, 95
STYLE WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS | DS_3DLOOK | DS_CONTROL
FONT 8, "MS Shell Dlg"
BEGIN
  /* ..., SS_OWNERDRAW, x, y, width, height, ... */
  CONTROL  "", IUP_PREVIEWCANVAS, "STATIC", SS_OWNERDRAW, 70, 0, 120, 90, WS_EX_STATICEDGE
END

/****************************************************/
/* The following lines will enable Windows XP/Vista Visual Styles */

/* don't add this if building the DLL */
#ifndef IUP_DLL
#ifdef TEC_64
1 24 "iup64.manifest"
#else
1 24 "iup.manifest"
#endif
#endif

/****************************************************/



================================================
File: iup/etc/iup64.manifest
================================================
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0" xmlns:asmv3="urn:schemas-microsoft-com:asm.v3">
  <assemblyIdentity
      version="3.0.0.0"
      processorArchitecture="amd64"
      name="IupApp"
      type="win32"
  />
  <description>Iup Application</description>
  <dependency>
      <dependentAssembly>
          <assemblyIdentity
              type="win32"
              name="Microsoft.Windows.Common-Controls"
              version="6.0.0.0"
              processorArchitecture="amd64"
              publicKeyToken="6595b64144ccf1df"
              language="*"
          />
      </dependentAssembly>
  </dependency>
  <asmv3:application>
    <asmv3:windowsSettings xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">
      <dpiAware>true</dpiAware>
    </asmv3:windowsSettings>
  </asmv3:application>
  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">
    <security>
      <requestedPrivileges>
        <requestedExecutionLevel
            level="asInvoker"
            uiAccess="false"
                />
      </requestedPrivileges>
    </security>
  </trustInfo>
  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
    <application>
      <!-- Windows 10 -->
      <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>
      <!-- Windows 8.1 -->
      <supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}"/>
      <!-- Windows Vista -->
      <supportedOS Id="{e2011457-1546-43c5-a5fe-008deee3d3f0}"/>
      <!-- Windows 7 -->
      <supportedOS Id="{35138b9a-5d96-4fbd-8e2d-a2440225f93a}"/>
      <!-- Windows 8 -->
      <supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}"/>
    </application>
  </compatibility>
</assembly>



================================================
File: iup/etc/iupstub.c
================================================
/** 
 * When using IUP as a DLL you must link with the "iupstub.lib" static library.
 * But if you are using a compiler that is different 
 * from the one that built the "iupstub.lib" static library 
 * it can occour linking problems, usually argc and argv not being found.
 * If that happen do not use the "iupstub.lib" static library 
 * and use this file instead.
 *
 * See Copyright Notice in "iup.h"
 */

#include <windows.h>

#include <stdlib.h> /* declaration of __argc and __argv */

extern int main(int, char **);

/* WinMain is NOT called for Console applications */
int WINAPI WinMain (HINSTANCE hinst, HINSTANCE hprev, LPSTR cmdline, int ncmdshow)
{
  (void)hinst;  /* NOT used */
  (void)hprev;
  (void)cmdline;
  (void)ncmdshow;
  
  /* this seems to work for all the compilers we tested, except Watcom compilers */
  /* These are declared in <stdlib.h>, except for Cygwin. */
#ifdef __GNUC__
  extern int __argc;
  extern char** __argv;
#endif

  return main(__argc, __argv);
}



================================================
File: iup/etc/pen.cur
================================================
[Non-text file]


================================================
File: iup/include/iup.h
================================================
/** \file
 * \brief User API
 * IUP - A Portable User Interface Toolkit
 * Tecgraf: Computer Graphics Technology Group, PUC-Rio, Brazil
 * http://www.tecgraf.puc-rio.br/iup  mailto:iup@tecgraf.puc-rio.br
 *
 * See Copyright Notice at the end of this file
 */
 
#ifndef __IUP_H 
#define __IUP_H

#include "iupkey.h"
#include "iupdef.h"

#ifdef __cplusplus
extern "C" {
#endif


#define IUP_NAME "IUP - Portable User Interface"
#define IUP_DESCRIPTION	"Multi-platform Toolkit for Building Graphical User Interfaces"
#define IUP_COPYRIGHT "Copyright (C) 1994-2016 Tecgraf/PUC-Rio"
#define IUP_VERSION "3.20"         /* bug fixes are reported only by IupVersion functions */
#define IUP_VERSION_NUMBER 320000
#define IUP_VERSION_DATE "2016/09/30"  /* does not include bug fix releases */

typedef struct Ihandle_ Ihandle;
typedef int (*Icallback)(Ihandle*);

/************************************************************************/
/*                        Main API                                      */
/************************************************************************/

int       IupOpen          (int *argc, char ***argv);
void      IupClose         (void);
void      IupImageLibOpen  (void);

int       IupMainLoop      (void);
int       IupLoopStep      (void);
int       IupLoopStepWait  (void);
int       IupMainLoopLevel (void);
void      IupFlush         (void);
void      IupExitLoop      (void);

int       IupRecordInput(const char* filename, int mode);
int       IupPlayInput(const char* filename);

void      IupUpdate        (Ihandle* ih);
void      IupUpdateChildren(Ihandle* ih);
void      IupRedraw        (Ihandle* ih, int children);
void      IupRefresh       (Ihandle* ih);
void      IupRefreshChildren(Ihandle* ih);

int       IupExecute(const char *filename, const char* parameters);
int       IupExecuteWait(const char *filename, const char* parameters);
int       IupHelp(const char* url);

char*     IupLoad          (const char *filename);
char*     IupLoadBuffer    (const char *buffer);

char*     IupVersion       (void);
char*     IupVersionDate   (void);
int       IupVersionNumber (void);

void      IupSetLanguage   (const char *lng);
char*     IupGetLanguage   (void);
void      IupSetLanguageString(const char* name, const char* str);
void      IupStoreLanguageString(const char* name, const char* str);
char*     IupGetLanguageString(const char* name);
void      IupSetLanguagePack(Ihandle* ih);

void      IupDestroy      (Ihandle* ih);
void      IupDetach       (Ihandle* child);
Ihandle*  IupAppend       (Ihandle* ih, Ihandle* child);
Ihandle*  IupInsert       (Ihandle* ih, Ihandle* ref_child, Ihandle* child);
Ihandle*  IupGetChild     (Ihandle* ih, int pos);
int       IupGetChildPos  (Ihandle* ih, Ihandle* child);
int       IupGetChildCount(Ihandle* ih);
Ihandle*  IupGetNextChild (Ihandle* ih, Ihandle* child);
Ihandle*  IupGetBrother   (Ihandle* ih);
Ihandle*  IupGetParent    (Ihandle* ih);
Ihandle*  IupGetDialog    (Ihandle* ih);
Ihandle*  IupGetDialogChild(Ihandle* ih, const char* name);
int       IupReparent     (Ihandle* ih, Ihandle* new_parent, Ihandle* ref_child);

int       IupPopup         (Ihandle* ih, int x, int y);
int       IupShow          (Ihandle* ih);
int       IupShowXY        (Ihandle* ih, int x, int y);
int       IupHide          (Ihandle* ih);
int       IupMap           (Ihandle* ih);
void      IupUnmap         (Ihandle *ih);

void      IupResetAttribute(Ihandle *ih, const char* name);
int       IupGetAllAttributes(Ihandle* ih, char** names, int n);
Ihandle*  IupSetAtt(const char* handle_name, Ihandle* ih, const char* name, ...);
Ihandle*  IupSetAttributes (Ihandle* ih, const char *str);
char*     IupGetAttributes (Ihandle* ih);

void      IupSetAttribute   (Ihandle* ih, const char* name, const char* value);
void      IupSetStrAttribute(Ihandle* ih, const char* name, const char* value);
void      IupSetStrf        (Ihandle* ih, const char* name, const char* format, ...);
void      IupSetInt         (Ihandle* ih, const char* name, int value);
void      IupSetFloat       (Ihandle* ih, const char* name, float value);
void      IupSetDouble      (Ihandle* ih, const char* name, double value);
void      IupSetRGB         (Ihandle *ih, const char* name, unsigned char r, unsigned char g, unsigned char b);

char*     IupGetAttribute(Ihandle* ih, const char* name);
int       IupGetInt      (Ihandle* ih, const char* name);
int       IupGetInt2     (Ihandle* ih, const char* name);
int       IupGetIntInt   (Ihandle *ih, const char* name, int *i1, int *i2);
float     IupGetFloat    (Ihandle* ih, const char* name);
double    IupGetDouble(Ihandle* ih, const char* name);
void      IupGetRGB      (Ihandle *ih, const char* name, unsigned char *r, unsigned char *g, unsigned char *b);

void  IupSetAttributeId(Ihandle *ih, const char* name, int id, const char *value);
void  IupSetStrAttributeId(Ihandle *ih, const char* name, int id, const char *value);
void  IupSetStrfId(Ihandle *ih, const char* name, int id, const char* format, ...);
void  IupSetIntId(Ihandle* ih, const char* name, int id, int value);
void  IupSetFloatId(Ihandle* ih, const char* name, int id, float value);
void  IupSetDoubleId(Ihandle* ih, const char* name, int id, double value);
void  IupSetRGBId(Ihandle *ih, const char* name, int id, unsigned char r, unsigned char g, unsigned char b);

char*  IupGetAttributeId(Ihandle *ih, const char* name, int id);
int    IupGetIntId(Ihandle *ih, const char* name, int id);
float  IupGetFloatId(Ihandle *ih, const char* name, int id);
double IupGetDoubleId(Ihandle *ih, const char* name, int id);
void   IupGetRGBId(Ihandle *ih, const char* name, int id, unsigned char *r, unsigned char *g, unsigned char *b);

void  IupSetAttributeId2(Ihandle* ih, const char* name, int lin, int col, const char* value);
void  IupSetStrAttributeId2(Ihandle* ih, const char* name, int lin, int col, const char* value);
void  IupSetStrfId2(Ihandle* ih, const char* name, int lin, int col, const char* format, ...);
void  IupSetIntId2(Ihandle* ih, const char* name, int lin, int col, int value);
void  IupSetFloatId2(Ihandle* ih, const char* name, int lin, int col, float value);
void  IupSetDoubleId2(Ihandle* ih, const char* name, int lin, int col, double value);
void  IupSetRGBId2(Ihandle *ih, const char* name, int lin, int col, unsigned char r, unsigned char g, unsigned char b);

char*  IupGetAttributeId2(Ihandle* ih, const char* name, int lin, int col);
int    IupGetIntId2(Ihandle* ih, const char* name, int lin, int col);
float  IupGetFloatId2(Ihandle* ih, const char* name, int lin, int col);
double IupGetDoubleId2(Ihandle* ih, const char* name, int lin, int col);
void   IupGetRGBId2(Ihandle *ih, const char* name, int lin, int col, unsigned char *r, unsigned char *g, unsigned char *b);

void      IupSetGlobal  (const char* name, const char* value);
void      IupSetStrGlobal(const char* name, const char* value);
char*     IupGetGlobal  (const char* name);

Ihandle*  IupSetFocus     (Ihandle* ih);
Ihandle*  IupGetFocus     (void);
Ihandle*  IupPreviousField(Ihandle* ih);  
Ihandle*  IupNextField    (Ihandle* ih);

Icallback IupGetCallback (Ihandle* ih, const char *name);
Icallback IupSetCallback (Ihandle* ih, const char *name, Icallback func);
Ihandle*  IupSetCallbacks(Ihandle* ih, const char *name, Icallback func, ...);

Icallback IupGetFunction(const char *name);
Icallback IupSetFunction(const char *name, Icallback func);

Ihandle*  IupGetHandle    (const char *name);
Ihandle*  IupSetHandle    (const char *name, Ihandle* ih);
int       IupGetAllNames  (char** names, int n);
int       IupGetAllDialogs(char** names, int n);
char*     IupGetName      (Ihandle* ih);

void      IupSetAttributeHandle(Ihandle* ih, const char* name, Ihandle* ih_named);
Ihandle*  IupGetAttributeHandle(Ihandle* ih, const char* name);

char*     IupGetClassName(Ihandle* ih);
char*     IupGetClassType(Ihandle* ih);
int       IupGetAllClasses(char** names, int n);
int       IupGetClassAttributes(const char* classname, char** names, int n);
int       IupGetClassCallbacks(const char* classname, char** names, int n);
void      IupSaveClassAttributes(Ihandle* ih);
void      IupCopyClassAttributes(Ihandle* src_ih, Ihandle* dst_ih);
void      IupSetClassDefaultAttribute(const char* classname, const char *name, const char* value);
int       IupClassMatch(Ihandle* ih, const char* classname);

Ihandle*  IupCreate (const char *classname);
Ihandle*  IupCreatev(const char *classname, void* *params);
Ihandle*  IupCreatep(const char *classname, void *first, ...);

/************************************************************************/
/*                        Elements                                      */
/************************************************************************/

Ihandle*  IupFill       (void);
Ihandle*  IupRadio      (Ihandle* child);
Ihandle*  IupVbox       (Ihandle* child, ...);
Ihandle*  IupVboxv      (Ihandle* *children);
Ihandle*  IupZbox       (Ihandle* child, ...);
Ihandle*  IupZboxv      (Ihandle* *children);
Ihandle*  IupHbox       (Ihandle* child,...);
Ihandle*  IupHboxv      (Ihandle* *children);

Ihandle*  IupNormalizer (Ihandle* ih_first, ...);
Ihandle*  IupNormalizerv(Ihandle* *ih_list);

Ihandle*  IupCbox       (Ihandle* child, ...);
Ihandle*  IupCboxv      (Ihandle* *children);
Ihandle*  IupSbox       (Ihandle *child);
Ihandle*  IupSplit      (Ihandle* child1, Ihandle* child2);
Ihandle*  IupScrollBox  (Ihandle* child);
Ihandle*  IupGridBox    (Ihandle* child, ...);
Ihandle*  IupGridBoxv   (Ihandle **children);
Ihandle*  IupExpander   (Ihandle *child);
Ihandle*  IupDetachBox  (Ihandle *child);
Ihandle*  IupBackgroundBox(Ihandle *child);

Ihandle*  IupFrame      (Ihandle* child);
Ihandle*  IupFlatFrame  (Ihandle* child);

Ihandle*  IupImage      (int width, int height, const unsigned char *pixmap);
Ihandle*  IupImageRGB   (int width, int height, const unsigned char *pixmap);
Ihandle*  IupImageRGBA  (int width, int height, const unsigned char *pixmap);

Ihandle*  IupItem       (const char* title, const char* action);
Ihandle*  IupSubmenu    (const char* title, Ihandle* child);
Ihandle*  IupSeparator  (void);
Ihandle*  IupMenu       (Ihandle* child,...);
Ihandle*  IupMenuv      (Ihandle* *children);

Ihandle*  IupButton     (const char* title, const char* action);
Ihandle*  IupCanvas     (const char* action);
Ihandle*  IupDialog     (Ihandle* child);
Ihandle*  IupUser       (void);
Ihandle*  IupLabel      (const char* title);
Ihandle*  IupList       (const char* action);
Ihandle*  IupText       (const char* action);
Ihandle*  IupMultiLine  (const char* action);
Ihandle*  IupToggle     (const char* title, const char* action);
Ihandle*  IupTimer      (void);
Ihandle*  IupClipboard  (void);
Ihandle*  IupProgressBar(void);
Ihandle*  IupVal        (const char *type);
Ihandle*  IupTabs       (Ihandle* child, ...);
Ihandle*  IupTabsv      (Ihandle* *children);
Ihandle*  IupTree       (void);
Ihandle*  IupLink       (const char* url, const char* title);
Ihandle*  IupFlatButton (const char* title);
Ihandle*  IupAnimatedLabel(Ihandle* animation);
Ihandle*  IupDatePick   (void);
Ihandle*  IupCalendar   (void);

/* Old controls, use SPIN attribute of IupText */
Ihandle*  IupSpin       (void);
Ihandle*  IupSpinbox    (Ihandle* child);


/************************************************************************/
/*                      Utilities                                       */
/************************************************************************/

/* String compare utility */
int IupStringCompare(const char* str1, const char* str2, int casesensitive, int lexicographic);

/* IupImage utility */
int IupSaveImageAsText(Ihandle* ih, const char* file_name, const char* format, const char* name);

/* IupText and IupScintilla utilities */
void  IupTextConvertLinColToPos(Ihandle* ih, int lin, int col, int *pos);
void  IupTextConvertPosToLinCol(Ihandle* ih, int pos, int *lin, int *col);

/* IupText, IupList, IupTree, IupMatrix and IupScintilla utility */
int   IupConvertXYToPos(Ihandle* ih, int x, int y);

/* OLD names, kept for backward compatibility, will never be removed. */
void IupStoreGlobal(const char* name, const char* value);
void IupStoreAttribute(Ihandle* ih, const char* name, const char* value);
void IupSetfAttribute(Ihandle* ih, const char* name, const char* format, ...);
void IupStoreAttributeId(Ihandle *ih, const char* name, int id, const char *value);
void IupSetfAttributeId(Ihandle *ih, const char* name, int id, const char* f, ...);
void IupStoreAttributeId2(Ihandle* ih, const char* name, int lin, int col, const char* value);
void IupSetfAttributeId2(Ihandle* ih, const char* name, int lin, int col, const char* format, ...);

/* IupTree utilities */
int   IupTreeSetUserId(Ihandle* ih, int id, void* userid);
void* IupTreeGetUserId(Ihandle* ih, int id);
int   IupTreeGetId(Ihandle* ih, void *userid);
void  IupTreeSetAttributeHandle(Ihandle* ih, const char* name, int id, Ihandle* ih_named);


/************************************************************************/
/*                      Pre-defined dialogs                           */
/************************************************************************/

Ihandle* IupFileDlg(void);
Ihandle* IupMessageDlg(void);
Ihandle* IupColorDlg(void);
Ihandle* IupFontDlg(void);
Ihandle* IupProgressDlg(void);

int  IupGetFile(char *arq);
void IupMessage(const char *title, const char *msg);
void IupMessagef(const char *title, const char *format, ...);
int  IupAlarm(const char *title, const char *msg, const char *b1, const char *b2, const char *b3);
int  IupScanf(const char *format, ...);
int  IupListDialog(int type, const char *title, int size, const char** list,
                   int op, int max_col, int max_lin, int* marks);
int  IupGetText(const char* title, char* text, int maxsize);
int  IupGetColor(int x, int y, unsigned char* r, unsigned char* g, unsigned char* b);

typedef int (*Iparamcb)(Ihandle* dialog, int param_index, void* user_data);
int IupGetParam(const char* title, Iparamcb action, void* user_data, const char* format,...);
int IupGetParamv(const char* title, Iparamcb action, void* user_data, const char* format, int param_count, int param_extra, void** param_data);
Ihandle* IupParam(const char* format);
Ihandle*  IupParamBox(Ihandle* child, ...);
Ihandle*  IupParamBoxv(Ihandle* *children);

Ihandle* IupLayoutDialog(Ihandle* dialog);
Ihandle* IupElementPropertiesDialog(Ihandle* elem);


#ifdef __cplusplus
}
#endif

/************************************************************************/
/*                   Common Flags and Return Values                     */
/************************************************************************/
#define IUP_ERROR     1
#define IUP_NOERROR   0
#define IUP_OPENED   -1
#define IUP_INVALID  -1
#define IUP_INVALID_ID -10


/************************************************************************/
/*                   Callback Return Values                             */
/************************************************************************/
#define IUP_IGNORE    -1
#define IUP_DEFAULT   -2
#define IUP_CLOSE     -3
#define IUP_CONTINUE  -4

/************************************************************************/
/*           IupPopup and IupShowXY Parameter Values                    */
/************************************************************************/
#define IUP_CENTER        0xFFFF  /* 65535 */
#define IUP_LEFT          0xFFFE  /* 65534 */
#define IUP_RIGHT         0xFFFD  /* 65533 */
#define IUP_MOUSEPOS      0xFFFC  /* 65532 */
#define IUP_CURRENT       0xFFFB  /* 65531 */
#define IUP_CENTERPARENT  0xFFFA  /* 65530 */
#define IUP_TOP       IUP_LEFT
#define IUP_BOTTOM    IUP_RIGHT

/************************************************************************/
/*               SHOW_CB Callback Values                                */
/************************************************************************/
enum{IUP_SHOW, IUP_RESTORE, IUP_MINIMIZE, IUP_MAXIMIZE, IUP_HIDE};

/************************************************************************/
/*               SCROLL_CB Callback Values                              */
/************************************************************************/
enum{IUP_SBUP,   IUP_SBDN,    IUP_SBPGUP,   IUP_SBPGDN,    IUP_SBPOSV, IUP_SBDRAGV, 
     IUP_SBLEFT, IUP_SBRIGHT, IUP_SBPGLEFT, IUP_SBPGRIGHT, IUP_SBPOSH, IUP_SBDRAGH};

/************************************************************************/
/*               Mouse Button Values and Macros                         */
/************************************************************************/
#define IUP_BUTTON1   '1'
#define IUP_BUTTON2   '2'
#define IUP_BUTTON3   '3'
#define IUP_BUTTON4   '4'
#define IUP_BUTTON5   '5'

#define iup_isshift(_s)    (_s[0]=='S')
#define iup_iscontrol(_s)  (_s[1]=='C')
#define iup_isbutton1(_s)  (_s[2]=='1')
#define iup_isbutton2(_s)  (_s[3]=='2')
#define iup_isbutton3(_s)  (_s[4]=='3')
#define iup_isdouble(_s)   (_s[5]=='D')
#define iup_isalt(_s)      (_s[6]=='A')
#define iup_issys(_s)      (_s[7]=='Y')
#define iup_isbutton4(_s)  (_s[8]=='4')
#define iup_isbutton5(_s)  (_s[9]=='5')

/* Old definitions for backward compatibility */
#define isshift     iup_isshift
#define iscontrol   iup_iscontrol
#define isbutton1   iup_isbutton1
#define isbutton2   iup_isbutton2
#define isbutton3   iup_isbutton3
#define isdouble    iup_isdouble
#define isalt       iup_isalt
#define issys       iup_issys
#define isbutton4   iup_isbutton4
#define isbutton5   iup_isbutton5


/************************************************************************/
/*                      Pre-Defined Masks                               */
/************************************************************************/
#define IUP_MASK_FLOAT       "[+/-]?(/d+/.?/d*|/./d+)"
#define IUP_MASK_UFLOAT            "(/d+/.?/d*|/./d+)"
#define IUP_MASK_EFLOAT      "[+/-]?(/d+/.?/d*|/./d+)([eE][+/-]?/d+)?"
#define IUP_MASK_FLOATCOMMA  "[+/-]?(/d+/,?/d*|/,/d+)"
#define IUP_MASK_UFLOATCOMMA       "(/d+/,?/d*|/,/d+)"
#define IUP_MASK_INT          "[+/-]?/d+"
#define IUP_MASK_UINT               "/d+"

/* Old definitions for backward compatibility */
#define IUPMASK_FLOAT     IUP_MASK_FLOAT
#define IUPMASK_UFLOAT    IUP_MASK_UFLOAT
#define IUPMASK_EFLOAT    IUP_MASK_EFLOAT
#define IUPMASK_INT	      IUP_MASK_INT
#define IUPMASK_UINT      IUP_MASK_UINT


/************************************************************************/
/*                   IupGetParam Callback situations                    */
/************************************************************************/
#define IUP_GETPARAM_BUTTON1 -1
#define IUP_GETPARAM_INIT    -2
#define IUP_GETPARAM_BUTTON2 -3
#define IUP_GETPARAM_BUTTON3 -4
#define IUP_GETPARAM_CLOSE   -5
#define IUP_GETPARAM_OK     IUP_GETPARAM_BUTTON1
#define IUP_GETPARAM_CANCEL IUP_GETPARAM_BUTTON2
#define IUP_GETPARAM_HELP   IUP_GETPARAM_BUTTON3


/************************************************************************/
/*                   Record Input Modes                                 */
/************************************************************************/
enum {IUP_RECBINARY, IUP_RECTEXT};


/************************************************************************/
/*              Replacement for the WinMain in Windows,                 */
/*        this allows the application to start from "main".             */
/*        Used only for Watcom.                                         */
/************************************************************************/
#if defined (__WATCOMC__)
#ifdef __cplusplus
extern "C" {
int IupMain (int argc, char** argv); /* In C++ we have to declare the prototype */
}
#endif
#define main IupMain /* this is the trick for Watcom and MetroWerks */
#endif

/******************************************************************************
* Copyright (C) 1994-2016 Tecgraf/PUC-Rio.
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
******************************************************************************/

#endif



================================================
File: iup/include/iup_class_cbs.hpp
================================================
/** \file
 * \brief Class Callback Utilities.
 */

#ifndef __IUP_CLASS_CBS_HPP
#define __IUP_CLASS_CBS_HPP


#define IUP_CLASS_GET_OBJECT(__ih, __class) dynamic_cast<__class*>((__class*)IupGetAttribute(__ih, #__class "->this"))


#define IUP_CLASS_INITCALLBACK(__ih, __class)  \
  IupSetAttribute(__ih, #__class "->this", (char*)this)

#define IUP_CLASS_SETCALLBACK(__ih, __name, __cb)  \
  IupSetCallback(__ih, __name, (Icallback)CB_##__cb)



#define IUP_CLASS_DECLARECALLBACK_IFn(__class, __cb)  \
       int      __cb(Ihandle* ih);         \
static int CB_##__cb(Ihandle* ih)          \
{                                                                   \
  __class* obj = IUP_CLASS_GET_OBJECT(ih, __class);  \
  return obj->__cb(ih);                                  \
}                                                           

#define IUP_CLASS_DECLARECALLBACK_IFni(__class, __cb)  \
       int      __cb(Ihandle* ih, int i1);         \
static int CB_##__cb(Ihandle* ih, int i1)          \
{                                                                   \
  __class* obj = IUP_CLASS_GET_OBJECT(ih, __class);  \
  return obj->__cb(ih, i1);                                  \
}                                                           

#define IUP_CLASS_DECLARECALLBACK_IFnii(__class, __cb)  \
       int      __cb(Ihandle* ih, int i1, int i2);         \
static int CB_##__cb(Ihandle* ih, int i1, int i2)          \
{                                                                   \
  __class* obj = IUP_CLASS_GET_OBJECT(ih, __class);  \
  return obj->__cb(ih, i1, i2);                                  \
}                                                           

#define IUP_CLASS_DECLARECALLBACK_IFniii(__class, __cb)  \
       int      __cb(Ihandle* ih, int i1, int i2, int i3);         \
static int CB_##__cb(Ihandle* ih, int i1, int i2, int i3)          \
{                                                                   \
  __class* obj = IUP_CLASS_GET_OBJECT(ih, __class);  \
  return obj->__cb(ih, i1, i2, i3);                                  \
}                                                           

#define IUP_CLASS_DECLARECALLBACK_IFniiii(__class, __cb)  \
       int      __cb(Ihandle* ih, int i1, int i2, int i3, int i4);         \
static int CB_##__cb(Ihandle* ih, int i1, int i2, int i3, int i4)          \
{                                                                   \
  __class* obj = IUP_CLASS_GET_OBJECT(ih, __class);  \
  return obj->__cb(ih, i1, i2, i3, i4);                                  \
}                                                           

#define IUP_CLASS_DECLARECALLBACK_IFniiiii(__class, __cb)  \
       int      __cb(Ihandle* ih, int i1, int i2, int i3, int i4, int i5);         \
static int CB_##__cb(Ihandle* ih, int i1, int i2, int i3, int i4, int i5)          \
{                                                                   \
  __class* obj = IUP_CLASS_GET_OBJECT(ih, __class);  \
  return obj->__cb(ih, i1, i2, i3, i4, i5);                                  \
}                                                           

#define IUP_CLASS_DECLARECALLBACK_IFniiiiii(__class, __cb)  \
       int      __cb(Ihandle* ih, int i1, int i2, int i3, int i4, int i5, int i6);         \
static int CB_##__cb(Ihandle* ih, int i1, int i2, int i3, int i4, int i5, int i6)          \
{                                                                   \
  __class* obj = IUP_CLASS_GET_OBJECT(ih, __class);  \
  return obj->__cb(ih, i1, i2, i3, i4, i5, i6);                                  \
}                                                           

#define IUP_CLASS_DECLARECALLBACK_IFniiiiiiC(__class, __cb)  \
       int      __cb(Ihandle* ih, int i1, int i2, int i3, int i4, int i5, int i6, struct _cdCanvas* canvas);         \
static int CB_##__cb(Ihandle* ih, int i1, int i2, int i3, int i4, int i5, int i6, struct _cdCanvas* canvas)          \
{                                                                   \
  __class* obj = IUP_CLASS_GET_OBJECT(ih, __class);  \
  return obj->__cb(ih, i1, i2, i3, i4, i5, i6, canvas);             \
}                                                           

#define IUP_CLASS_DECLARECALLBACK_IFnC(__class, __cb)  \
       int      __cb(Ihandle* ih, struct _cdCanvas* canvas);         \
static int CB_##__cb(Ihandle* ih, struct _cdCanvas* canvas)          \
{                                                                   \
  __class* obj = IUP_CLASS_GET_OBJECT(ih, __class);  \
  return obj->__cb(ih, canvas);             \
}                                                           

#define IUP_CLASS_DECLARECALLBACK_dIFnii(__class, __cb)  \
       double      __cb(Ihandle* ih, int i1, int i2);    \
static double CB_##__cb(Ihandle* ih, int i1, int i2)     \
{                                                                   \
  __class* obj = IUP_CLASS_GET_OBJECT(ih, __class);  \
  return obj->__cb(ih, i1, i2);                                     \
}                                                           

#define IUP_CLASS_DECLARECALLBACK_sIFni(__class, __cb)  \
       char*      __cb(Ihandle* ih, int i1);    \
static char* CB_##__cb(Ihandle* ih, int i1)     \
{                                                                   \
  __class* obj = IUP_CLASS_GET_OBJECT(ih, __class);  \
  return obj->__cb(ih, i1);                                     \
}                                                           

#define IUP_CLASS_DECLARECALLBACK_sIFnii(__class, __cb)  \
       char*      __cb(Ihandle* ih, int i1, int i2);    \
static char* CB_##__cb(Ihandle* ih, int i1, int i2)     \
{                                                                   \
  __class* obj = IUP_CLASS_GET_OBJECT(ih, __class);  \
  return obj->__cb(ih, i1, i2);                                     \
}                                                           

#define IUP_CLASS_DECLARECALLBACK_sIFniis(__class, __cb)  \
       char*      __cb(Ihandle* ih, int i1, int i2, char* s);         \
static char* CB_##__cb(Ihandle* ih, int i1, int i2, char* s)          \
{                                                                   \
  __class* obj = IUP_CLASS_GET_OBJECT(ih, __class);  \
  return obj->__cb(ih, i1, i2, s);                                  \
}                                                           

#define IUP_CLASS_DECLARECALLBACK_IFnff(__class, __cb)  \
       int      __cb(Ihandle* ih, float f1, float f2);         \
static int CB_##__cb(Ihandle* ih, float f1, float f2)          \
{                                                                   \
  __class* obj = IUP_CLASS_GET_OBJECT(ih, __class);  \
  return obj->__cb(ih, f1, f2);                                  \
}                                                           

#define IUP_CLASS_DECLARECALLBACK_IFniff(__class, __cb)  \
       int      __cb(Ihandle* ih, int i1, float f1, float f2);         \
static int CB_##__cb(Ihandle* ih, int i1, float f1, float f2)          \
{                                                                   \
  __class* obj = IUP_CLASS_GET_OBJECT(ih, __class);  \
  return obj->__cb(ih, i1, f1, f2);                                  \
}                                                           

#define IUP_CLASS_DECLARECALLBACK_IFnfiis(__class, __cb)  \
       int      __cb(Ihandle* ih, float f1, int i1, int i2, char* s);         \
static int CB_##__cb(Ihandle* ih, float f1, int i1, int i2, char* s)          \
{                                                                   \
  __class* obj = IUP_CLASS_GET_OBJECT(ih, __class);  \
  return obj->__cb(ih, f1, i1, i2, s);                                  \
}                                                           

#define IUP_CLASS_DECLARECALLBACK_IFniiff(__class, __cb)  \
       int      __cb(Ihandle* ih, int i1, int i2, float f1, float f2);         \
static int CB_##__cb(Ihandle* ih, int i1, int i2, float f1, float f2)          \
{                                                                   \
  __class* obj = IUP_CLASS_GET_OBJECT(ih, __class);  \
  return obj->__cb(ih, i1, i2, f1, f2);                                  \
}                                                           

#define IUP_CLASS_DECLARECALLBACK_IFniiffi(__class, __cb)  \
       int      __cb(Ihandle* ih, int i1, int i2, float f1, float f2, int i3);         \
static int CB_##__cb(Ihandle* ih, int i1, int i2, float f1, float f2, int i3)          \
{                                                                   \
  __class* obj = IUP_CLASS_GET_OBJECT(ih, __class);  \
  return obj->__cb(ih, i1, i2, f1, f2, i3);                                  \
}                                                           

#define IUP_CLASS_DECLARECALLBACK_IFniiffFF(__class, __cb)  \
       int      __cb(Ihandle* ih, int i1, int i2, float f1, float f2, float *f3, float *f4);         \
static int CB_##__cb(Ihandle* ih, int i1, int i2, float f1, float f2, float *f3, float *f4)          \
{                                                                   \
  __class* obj = IUP_CLASS_GET_OBJECT(ih, __class);  \
  return obj->__cb(ih, i1, i2, f1, f2, f3, f4);                                  \
}                                                           

#define IUP_CLASS_DECLARECALLBACK_IFniiffs(__class, __cb)  \
       int      __cb(Ihandle* ih, int i1, int i2, float f1, float f2, char* s);         \
static int CB_##__cb(Ihandle* ih, int i1, int i2, float f1, float f2, char* s)          \
{                                                                   \
  __class* obj = IUP_CLASS_GET_OBJECT(ih, __class);  \
  return obj->__cb(ih, i1, i2, f1, f2, s);                                  \
}                                                           

#define IUP_CLASS_DECLARECALLBACK_IFnd(__class, __cb)  \
       int      __cb(Ihandle* ih, double d1);         \
static int CB_##__cb(Ihandle* ih, double d1)          \
{                                                                   \
  __class* obj = IUP_CLASS_GET_OBJECT(ih, __class);  \
  return obj->__cb(ih, d1);                                  \
}                                                           

#define IUP_CLASS_DECLARECALLBACK_IFndds(__class, __cb)  \
       int      __cb(Ihandle* ih, double d1, double d2, char* s);         \
static int CB_##__cb(Ihandle* ih, double d1, double d2, char* s)          \
{                                                                   \
  __class* obj = IUP_CLASS_GET_OBJECT(ih, __class);  \
  return obj->__cb(ih, d1, d2, s);                                  \
}                                                           

#define IUP_CLASS_DECLARECALLBACK_IFniid(__class, __cb)  \
       int      __cb(Ihandle* ih, int i1, int i2, double d1);         \
static int CB_##__cb(Ihandle* ih, int i1, int i2, double d1)          \
{                                                                   \
  __class* obj = IUP_CLASS_GET_OBJECT(ih, __class);  \
  return obj->__cb(ih, i1, i2, d1);                                  \
}                                                           

#define IUP_CLASS_DECLARECALLBACK_IFniidd(__class, __cb)  \
       int      __cb(Ihandle* ih, int i1, int i2, double d1, double d2);         \
static int CB_##__cb(Ihandle* ih, int i1, int i2, double d1, double d2)          \
{                                                                   \
  __class* obj = IUP_CLASS_GET_OBJECT(ih, __class);  \
  return obj->__cb(ih, i1, i2, d1, d2);                                  \
}                                                           

#define IUP_CLASS_DECLARECALLBACK_IFniiddi(__class, __cb)  \
       int      __cb(Ihandle* ih, int i1, int i2, double d1, double d2, int i3);         \
static int CB_##__cb(Ihandle* ih, int i1, int i2, double d1, double d2, int i3)          \
{                                                                   \
  __class* obj = IUP_CLASS_GET_OBJECT(ih, __class);  \
  return obj->__cb(ih, i1, i2, d1, d2, i3);                                  \
}                                                           

#define IUP_CLASS_DECLARECALLBACK_IFniidds(__class, __cb)  \
       int      __cb(Ihandle* ih, int i1, int i2, double d1, double d2, char* s);         \
static int CB_##__cb(Ihandle* ih, int i1, int i2, double d1, double d2, char* s)          \
{                                                                   \
  __class* obj = IUP_CLASS_GET_OBJECT(ih, __class);  \
  return obj->__cb(ih, i1, i2, d1, d2, s);                                  \
}                                                           

#define IUP_CLASS_DECLARECALLBACK_IFniiIII(__class, __cb)  \
       int      __cb(Ihandle* ih, int i1, int i2, int *I1, int *I2, int *I3);  \
static int CB_##__cb(Ihandle* ih, int i1, int i2, int *I1, int *I2, int *I3)   \
{                                                                   \
  __class* obj = IUP_CLASS_GET_OBJECT(ih, __class);  \
  return obj->__cb(ih, i1, i2, I1, I2, I3);                         \
}                                                           

#define IUP_CLASS_DECLARECALLBACK_IFniIIII(__class, __cb)  \
       int      __cb(Ihandle* ih, int i1, int *I1, int *I2, int *I3, int *I4);  \
static int CB_##__cb(Ihandle* ih, int i1, int *I1, int *I2, int *I3, int *I4)   \
{                                                                   \
  __class* obj = IUP_CLASS_GET_OBJECT(ih, __class);  \
  return obj->__cb(ih, i1, I1, I2, I3, I4);                         \
}                                                           

#define IUP_CLASS_DECLARECALLBACK_IFnIi(__class, __cb)  \
       int      __cb(Ihandle* ih, int *I1, int i1);  \
static int CB_##__cb(Ihandle* ih, int *I1, int i1)   \
{                                                                   \
  __class* obj = IUP_CLASS_GET_OBJECT(ih, __class);  \
  return obj->__cb(ih, I1, i1);                         \
}                                                           

#define IUP_CLASS_DECLARECALLBACK_IFnccc(__class, __cb)  \
       int      __cb(Ihandle* ih, char c1, char c2, char c3);         \
static int CB_##__cb(Ihandle* ih, char c1, char c2, char c3)          \
{                                                                   \
  __class* obj = IUP_CLASS_GET_OBJECT(ih, __class);  \
  return obj->__cb(ih, c1, c2, c3);                                  \
}                                                           

#define IUP_CLASS_DECLARECALLBACK_IFnis(__class, __cb)  \
       int      __cb(Ihandle* ih, int i1, char* s);         \
static int CB_##__cb(Ihandle* ih, int i1, char* s)          \
{                                                                   \
  __class* obj = IUP_CLASS_GET_OBJECT(ih, __class);  \
  return obj->__cb(ih, i1, s);                                  \
}                                                           

#define IUP_CLASS_DECLARECALLBACK_IFniis(__class, __cb)  \
       int      __cb(Ihandle* ih, int i1, int i2, char* s);         \
static int CB_##__cb(Ihandle* ih, int i1, int i2, char* s)          \
{                                                                   \
  __class* obj = IUP_CLASS_GET_OBJECT(ih, __class);  \
  return obj->__cb(ih, i1, i2, s);                                  \
}                                                           

#define IUP_CLASS_DECLARECALLBACK_IFniiis(__class, __cb)  \
       int      __cb(Ihandle* ih, int i1, int i2, int i3, char* s);         \
static int CB_##__cb(Ihandle* ih, int i1, int i2, int i3, char* s)          \
{                                                                   \
  __class* obj = IUP_CLASS_GET_OBJECT(ih, __class);  \
  return obj->__cb(ih, i1, i2, i3, s);                                  \
}                                                           

#define IUP_CLASS_DECLARECALLBACK_IFniiiis(__class, __cb)  \
       int      __cb(Ihandle* ih, int i1, int i2, int i3, int i4, char* s);         \
static int CB_##__cb(Ihandle* ih, int i1, int i2, int i3, int i4, char* s)          \
{                                                                   \
  __class* obj = IUP_CLASS_GET_OBJECT(ih, __class);  \
  return obj->__cb(ih, i1, i2, i3, i4, s);                                  \
}                                                           

#define IUP_CLASS_DECLARECALLBACK_IFniiiiis(__class, __cb)  \
       int      __cb(Ihandle* ih, int i1, int i2, int i3, int i4, int i5, char* s);         \
static int CB_##__cb(Ihandle* ih, int i1, int i2, int i3, int i4, int i5, char* s)          \
{                                                                   \
  __class* obj = IUP_CLASS_GET_OBJECT(ih, __class);  \
  return obj->__cb(ih, i1, i2, i3, i4, i5, s);                                  \
}                                                           

#define IUP_CLASS_DECLARECALLBACK_IFniiiiiis(__class, __cb)  \
       int      __cb(Ihandle* ih, int i1, int i2, int i3, int i4, int i5, int i6, char* s);         \
static int CB_##__cb(Ihandle* ih, int i1, int i2, int i3, int i4, int i5, int i6, char* s)          \
{                                                                   \
  __class* obj = IUP_CLASS_GET_OBJECT(ih, __class);  \
  return obj->__cb(ih, i1, i2, i3, i4, i5, i6, s);                                  \
}                                                           

#define IUP_CLASS_DECLARECALLBACK_IFnss(__class, __cb)  \
       int      __cb(Ihandle* ih, char* s1, char* s2);         \
static int CB_##__cb(Ihandle* ih, char* s1, char* s2)          \
{                                                                   \
  __class* obj = IUP_CLASS_GET_OBJECT(ih, __class);  \
  return obj->__cb(ih, s1, s2);                                  \
}                                                           

#define IUP_CLASS_DECLARECALLBACK_IFns(__class, __cb)  \
       int      __cb(Ihandle* ih, char* s1);         \
static int CB_##__cb(Ihandle* ih, char* s1)          \
{                                                                   \
  __class* obj = IUP_CLASS_GET_OBJECT(ih, __class);  \
  return obj->__cb(ih, s1);                                  \
}                                                           

#define IUP_CLASS_DECLARECALLBACK_IFnsi(__class, __cb)  \
       int      __cb(Ihandle* ih, char* s1, int i1);         \
static int CB_##__cb(Ihandle* ih, char* s1, int i1)          \
{                                                                   \
  __class* obj = IUP_CLASS_GET_OBJECT(ih, __class);  \
  return obj->__cb(ih, s1, i1);                                  \
}                                                           

#define IUP_CLASS_DECLARECALLBACK_IFnsii(__class, __cb)  \
       int      __cb(Ihandle* ih, char* s1, int i1, int i2);         \
static int CB_##__cb(Ihandle* ih, char* s1, int i1, int i2)          \
{                                                                   \
  __class* obj = IUP_CLASS_GET_OBJECT(ih, __class);  \
  return obj->__cb(ih, s1, i1, i2);                                  \
}                                                           

#define IUP_CLASS_DECLARECALLBACK_IFnsiii(__class, __cb)  \
       int      __cb(Ihandle* ih, char* s1, int i1, int i2, int i3);         \
static int CB_##__cb(Ihandle* ih, char* s1, int i1, int i2, int i3)          \
{                                                                   \
  __class* obj = IUP_CLASS_GET_OBJECT(ih, __class);  \
  return obj->__cb(ih, s1, i1, i2, i3);                                  \
}                                                           

#define IUP_CLASS_DECLARECALLBACK_IFnnii(__class, __cb)  \
       int      __cb(Ihandle* ih, Ihandle* ih1, int i1, int i2);         \
static int CB_##__cb(Ihandle* ih, Ihandle* ih1, int i1, int i2)          \
{                                                                   \
  __class* obj = IUP_CLASS_GET_OBJECT(ih, __class);  \
  return obj->__cb(ih, ih1, i1, i2);                                  \
}                                                           

#define IUP_CLASS_DECLARECALLBACK_IFnnn(__class, __cb)  \
       int      __cb(Ihandle* ih, Ihandle* ih1, Ihandle *ih2);         \
static int CB_##__cb(Ihandle* ih, Ihandle* ih1, Ihandle *ih2)          \
{                                                                   \
  __class* obj = IUP_CLASS_GET_OBJECT(ih, __class);  \
  return obj->__cb(ih, ih1, ih2);                                  \
}                                                           

#define IUP_CLASS_DECLARECALLBACK_IFniinsii(__class, __cb)  \
       int      __cb(Ihandle* ih, int i1, int i2, Ihandle* ih1, char* s, int i3, int i4);         \
static int CB_##__cb(Ihandle* ih, int i1, int i2, Ihandle* ih1, char* s, int i3, int i4)          \
{                                                                   \
  __class* obj = IUP_CLASS_GET_OBJECT(ih, __class);  \
  return obj->__cb(ih, i1, i2, ih1, s, i3, i4);                                  \
}                                                           

#define IUP_CLASS_DECLARECALLBACK_IFnsVi(__class, __cb)  \
       int      __cb(Ihandle* ih, char* s1, void* V1, int i1);         \
static int CB_##__cb(Ihandle* ih, char* s1, void* V1, int i1)          \
{                                                                   \
  __class* obj = IUP_CLASS_GET_OBJECT(ih, __class);  \
  return obj->__cb(ih, s1, V1, i1);                                  \
}                                                           

#define IUP_CLASS_DECLARECALLBACK_IFnsViii(__class, __cb)  \
       int      __cb(Ihandle* ih, char* s1, void* V1, int i1, int i2, int i3);         \
static int CB_##__cb(Ihandle* ih, char* s1, void* V1, int i1, int i2, int i3)          \
{                                                                   \
  __class* obj = IUP_CLASS_GET_OBJECT(ih, __class);  \
  return obj->__cb(ih, s1, V1, i1, i2, i3);                                  \
}                                                           



/* #define IUP_CLASS_DEBUG */
#ifdef IUP_CLASS_DEBUG
class IUP_CLASS_DUMMY
{
  // Used to check for errors in the definitions
  IUP_CLASS_DECLARECALLBACK_IFn(IUP_CLASS_DUMMY, IFn);
  IUP_CLASS_DECLARECALLBACK_IFni(IUP_CLASS_DUMMY, IFni);
  IUP_CLASS_DECLARECALLBACK_IFnii(IUP_CLASS_DUMMY, IFnii);
  IUP_CLASS_DECLARECALLBACK_IFniii(IUP_CLASS_DUMMY, IFniii);
  IUP_CLASS_DECLARECALLBACK_IFniiii(IUP_CLASS_DUMMY, IFniiii);
  IUP_CLASS_DECLARECALLBACK_IFniiiii(IUP_CLASS_DUMMY, IFniiiii);
  IUP_CLASS_DECLARECALLBACK_IFniiiiii(IUP_CLASS_DUMMY, IFniiiiii);
  IUP_CLASS_DECLARECALLBACK_IFniiiiiiC(IUP_CLASS_DUMMY, IFniiiiiiC);
  IUP_CLASS_DECLARECALLBACK_IFnC(IUP_CLASS_DUMMY, IFnC);
  IUP_CLASS_DECLARECALLBACK_dIFnii(IUP_CLASS_DUMMY, dIFnii);
  IUP_CLASS_DECLARECALLBACK_sIFni(IUP_CLASS_DUMMY, sIFni);
  IUP_CLASS_DECLARECALLBACK_sIFnii(IUP_CLASS_DUMMY, sIFnii);
  IUP_CLASS_DECLARECALLBACK_sIFniis(IUP_CLASS_DUMMY, sIFniis);
  IUP_CLASS_DECLARECALLBACK_IFnff(IUP_CLASS_DUMMY, IFnff);
  IUP_CLASS_DECLARECALLBACK_IFniff(IUP_CLASS_DUMMY, IFniff);
  IUP_CLASS_DECLARECALLBACK_IFnfiis(IUP_CLASS_DUMMY, IFnfiis);
  IUP_CLASS_DECLARECALLBACK_IFniiff(IUP_CLASS_DUMMY, IFniiff);
  IUP_CLASS_DECLARECALLBACK_IFniiffi(IUP_CLASS_DUMMY, IFniiffi);
  IUP_CLASS_DECLARECALLBACK_IFniiffFF(IUP_CLASS_DUMMY, IFniiffFF);
  IUP_CLASS_DECLARECALLBACK_IFniiffs(IUP_CLASS_DUMMY, IFniiffs);
  IUP_CLASS_DECLARECALLBACK_IFnd(IUP_CLASS_DUMMY, IFnd);
  IUP_CLASS_DECLARECALLBACK_IFndds(IUP_CLASS_DUMMY, IFndds);
  IUP_CLASS_DECLARECALLBACK_IFniid(IUP_CLASS_DUMMY, IFniid);
  IUP_CLASS_DECLARECALLBACK_IFniidd(IUP_CLASS_DUMMY, IFniidd);
  IUP_CLASS_DECLARECALLBACK_IFniiddi(IUP_CLASS_DUMMY, IFniiddi);
  IUP_CLASS_DECLARECALLBACK_IFniidds(IUP_CLASS_DUMMY, IFniidds);
  IUP_CLASS_DECLARECALLBACK_IFniiIII(IUP_CLASS_DUMMY, IFniiIII);
  IUP_CLASS_DECLARECALLBACK_IFniIIII(IUP_CLASS_DUMMY, IFniIIII);
  IUP_CLASS_DECLARECALLBACK_IFnIi(IUP_CLASS_DUMMY, IFnIi);
  IUP_CLASS_DECLARECALLBACK_IFnccc(IUP_CLASS_DUMMY, IFnccc);
  IUP_CLASS_DECLARECALLBACK_IFnis(IUP_CLASS_DUMMY, IFnis);
  IUP_CLASS_DECLARECALLBACK_IFniis(IUP_CLASS_DUMMY, IFniis);
  IUP_CLASS_DECLARECALLBACK_IFniiis(IUP_CLASS_DUMMY, IFniiis);
  IUP_CLASS_DECLARECALLBACK_IFniiiis(IUP_CLASS_DUMMY, IFniiiis);
  IUP_CLASS_DECLARECALLBACK_IFniiiiis(IUP_CLASS_DUMMY, IFniiiiis);
  IUP_CLASS_DECLARECALLBACK_IFniiiiiis(IUP_CLASS_DUMMY, IFniiiiiis);
  IUP_CLASS_DECLARECALLBACK_IFnss(IUP_CLASS_DUMMY, IFnss);
  IUP_CLASS_DECLARECALLBACK_IFns(IUP_CLASS_DUMMY, IFns);
  IUP_CLASS_DECLARECALLBACK_IFnsi(IUP_CLASS_DUMMY, IFnsi);
  IUP_CLASS_DECLARECALLBACK_IFnsii(IUP_CLASS_DUMMY, IFnsii);
  IUP_CLASS_DECLARECALLBACK_IFnsiii(IUP_CLASS_DUMMY, IFnsiii);
  IUP_CLASS_DECLARECALLBACK_IFnnii(IUP_CLASS_DUMMY, IFnnii);
  IUP_CLASS_DECLARECALLBACK_IFnnn(IUP_CLASS_DUMMY, IFnnn);
  IUP_CLASS_DECLARECALLBACK_IFniinsii(IUP_CLASS_DUMMY, IFniinsii);
  IUP_CLASS_DECLARECALLBACK_IFnsVi(IUP_CLASS_DUMMY, IFnsVi);
  IUP_CLASS_DECLARECALLBACK_IFnsViii(IUP_CLASS_DUMMY, IFnsViii);
};

class SampleClass
{
  int sample_count;
  
public:
  SampleClass()
  {
    sample_count = 0;
    
    Ihandle* button = IupButton("Inc", NULL);
    // 2) Associate the callback with the button
    IUP_CLASS_SETCALLBACK(button, "ACTION", ButtonAction);

    Ihandle* dialog = IupDialog(button);
    // 1) Register this object as a callback receiver (only once)
    IUP_CLASS_INITCALLBACK(dialog, SampleClass);

    IupShow(dialog);
  };

protected:
  // 3) Declare the callback as a member function
  IUP_CLASS_DECLARECALLBACK_IFn(SampleClass, ButtonAction);
};

// 4) Define the callback as a member function
int SampleClass::ButtonAction(Ihandle*)
{
  sample_count++;
  return IUP_DEFAULT;
}

#endif // IUP_CLASS_DEBUG

#endif



================================================
File: iup/include/iup_config.h
================================================
/** \file
 * \brief Configuration file Utilities
 *
 * See Copyright Notice in "iup.h"
 */

#ifndef IUP_CONFIG_H
#define IUP_CONFIG_H

#if	defined(__cplusplus)
extern "C" {
#endif

Ihandle* IupConfig(void);

int IupConfigLoad(Ihandle* ih);
int IupConfigSave(Ihandle* ih);

/****************************************************************/

void IupConfigSetVariableStr(Ihandle* ih, const char* group, const char* key, const char* value);
void IupConfigSetVariableStrId(Ihandle* ih, const char* group, const char* key, int id, const char* value);
void IupConfigSetVariableInt(Ihandle* ih, const char* group, const char* key, int value);
void IupConfigSetVariableIntId(Ihandle* ih, const char* group, const char* key, int id, int value);
void IupConfigSetVariableDouble(Ihandle* ih, const char* group, const char* key, double value);
void IupConfigSetVariableDoubleId(Ihandle* ih, const char* group, const char* key, int id, double value);

const char* IupConfigGetVariableStr(Ihandle* ih, const char* group, const char* key);
const char* IupConfigGetVariableStrId(Ihandle* ih, const char* group, const char* key, int id);
int    IupConfigGetVariableInt(Ihandle* ih, const char* group, const char* key);
int    IupConfigGetVariableIntId(Ihandle* ih, const char* group, const char* key, int id);
double IupConfigGetVariableDouble(Ihandle* ih, const char* group, const char* key);
double IupConfigGetVariableDoubleId(Ihandle* ih, const char* group, const char* key, int id);

const char* IupConfigGetVariableStrDef(Ihandle* ih, const char* group, const char* key, const char* def);
const char* IupConfigGetVariableStrIdDef(Ihandle* ih, const char* group, const char* key, int id, const char* def);
int    IupConfigGetVariableIntDef(Ihandle* ih, const char* group, const char* key, int def);
int    IupConfigGetVariableIntIdDef(Ihandle* ih, const char* group, const char* key, int id, int def);
double IupConfigGetVariableDoubleDef(Ihandle* ih, const char* group, const char* key, double def);
double IupConfigGetVariableDoubleIdDef(Ihandle* ih, const char* group, const char* key, int id, double def);

/****************************************************************/

void IupConfigRecentInit(Ihandle* ih, Ihandle* menu, Icallback recent_cb, int max_recent);
void IupConfigRecentUpdate(Ihandle* ih, const char* filename);

void IupConfigDialogShow(Ihandle* ih, Ihandle* dialog, const char* name);
void IupConfigDialogClosed(Ihandle* ih, Ihandle* dialog, const char* name);


#if defined(__cplusplus)
}
#endif

#endif



================================================
File: iup/include/iup_mglplot.h
================================================
/** \file
 * \brief Plot component for Iup.
 *
 * See Copyright Notice in "iup.h"
 */
 
#ifndef __IUP_MGLPLOT_H 
#define __IUP_MGLPLOT_H

#ifdef __cplusplus
extern "C" {
#endif

/* Initialize IupMglPlot widget class */
void IupMglPlotOpen(void);

/* Create an IupMglPlot widget instance */
Ihandle* IupMglPlot(void);

/***********************************************/
/*           Additional API                    */

/* Linear Data Only */
void IupMglPlotBegin(Ihandle *ih, int dim);
void IupMglPlotAdd1D(Ihandle *ih, const char* name, double y);
void IupMglPlotAdd2D(Ihandle *ih, double x, double y);
void IupMglPlotAdd3D(Ihandle *ih, double x, double y, double z);
int  IupMglPlotEnd(Ihandle *ih);

/* Linear (dim=1,2,3), Planar (dim=1), Volumetric (dim=1) */
int IupMglPlotNewDataSet(Ihandle *ih, int dim);

/* Linear Data Only */
void IupMglPlotInsert1D(Ihandle* ih, int ds_index, int sample_index, const char** names, const double* y, int count);
void IupMglPlotInsert2D(Ihandle* ih, int ds_index, int sample_index, const double* x, const double* y, int count);
void IupMglPlotInsert3D(Ihandle* ih, int ds_index, int sample_index, const double* x, const double* y, const double* z, int count);

/* Linear Data Only */
void IupMglPlotSet1D(Ihandle* ih, int ds_index, const char** names, const double* y, int count);
void IupMglPlotSet2D(Ihandle* ih, int ds_index, const double* x, const double* y, int count);
void IupMglPlotSet3D(Ihandle* ih, int ds_index, const double* x, const double* y, const double* z, int count);
void IupMglPlotSetFormula(Ihandle* ih, int ds_index, const char* formulaX, const char* formulaY, const char* formulaZ, int count);

/* Linear (dim=1), Planar (dim=1), Volumetric (dim=1) */
void IupMglPlotSetData(Ihandle* ih, int ds_index, const double* data, int count_x, int count_y, int count_z);
void IupMglPlotLoadData(Ihandle* ih, int ds_index, const char* filename, int count_x, int count_y, int count_z);
void IupMglPlotSetFromFormula(Ihandle* ih, int ds_index, const char* formula, int count_x, int count_y, int count_z);

/* Only inside callbacks */
void IupMglPlotTransform(Ihandle* ih, double x, double y, double z, int *ix, int *iy);
void IupMglPlotTransformTo(Ihandle* ih, int ix, int iy, double *x, double *y, double *z);

/* Only inside callbacks */
void IupMglPlotDrawMark(Ihandle* ih, double x, double y, double z);
void IupMglPlotDrawLine(Ihandle* ih, double x1, double y1, double z1, double x2, double y2, double z2);
void IupMglPlotDrawText(Ihandle* ih, const char* text, double x, double y, double z);

void IupMglPlotPaintTo(Ihandle *ih, const char* format, int w, int h, double dpi, void *data);

/***********************************************/

/* Utility label for showing TeX labels */
Ihandle* IupMglLabel(const char* title);


#ifdef __cplusplus
}
#endif

#endif



================================================
File: iup/include/iup_plot.h
================================================
/** \file
 * \brief Plot component for Iup.
 *
 * See Copyright Notice in "iup.h"
 */
 
#ifndef __IUP_PLOT_H 
#define __IUP_PLOT_H

#ifdef __cplusplus
extern "C" {
#endif

/* Initialize IupPlot widget class */
void IupPlotOpen(void);

/* Create an IupPlot widget instance */
Ihandle* IupPlot(void);

/***********************************************/
/*           Additional API                    */

void IupPlotBegin(Ihandle *ih, int strXdata);
void IupPlotAdd(Ihandle *ih, double x, double y);
void IupPlotAddStr(Ihandle *ih, const char* x, double y);
void IupPlotAddSegment(Ihandle *ih, double x, double y);
int  IupPlotEnd(Ihandle *ih);

int  IupPlotLoadData(Ihandle* ih, const char* filename, int strXdata);

/* available only when linking with "iupluaplot" */
int IupPlotSetFormula(Ihandle* ih, int sample_count, const char* formula, const char* init);

void IupPlotInsert(Ihandle *ih, int ds_index, int sample_index, double x, double y);
void IupPlotInsertStr(Ihandle *ih, int ds_index, int sample_index, const char* x, double y);
void IupPlotInsertSegment(Ihandle *ih, int ds_index, int sample_index, double x, double y);

void IupPlotInsertStrSamples(Ihandle* ih, int ds_index, int sample_index, const char** x, double* y, int count);
void IupPlotInsertSamples(Ihandle* ih, int ds_index, int sample_index, double *x, double *y, int count);

void IupPlotAddSamples(Ihandle* ih, int ds_index, double *x, double *y, int count);
void IupPlotAddStrSamples(Ihandle* ih, int ds_index, const char** x, double* y, int count);

void IupPlotGetSample(Ihandle* ih, int ds_index, int sample_index, double *x, double *y);
void IupPlotGetSampleStr(Ihandle* ih, int ds_index, int sample_index, const char* *x, double *y);
int  IupPlotGetSampleSelection(Ihandle* ih, int ds_index, int sample_index);
double IupPlotGetSampleExtra(Ihandle* ih, int ds_index, int sample_index);
void IupPlotSetSample(Ihandle* ih, int ds_index, int sample_index, double x, double y);
void IupPlotSetSampleStr(Ihandle* ih, int ds_index, int sample_index, const char* x, double y);
void IupPlotSetSampleSelection(Ihandle* ih, int ds_index, int sample_index, int selected);
void IupPlotSetSampleExtra(Ihandle* ih, int ds_index, int sample_index, double extra);

void IupPlotTransform(Ihandle* ih, double x, double y, double *cnv_x, double *cnv_y);
void IupPlotTransformTo(Ihandle* ih, double cnv_x, double cnv_y, double *x, double *y);

int  IupPlotFindSample(Ihandle* ih, double cnv_x, double cnv_y, int *ds_index, int *sample_index);

struct _cdCanvas;

void IupPlotPaintTo(Ihandle *ih, struct _cdCanvas* cnv);

/***********************************************/


#ifdef __cplusplus
}
#endif

#endif



================================================
File: iup/include/iup_plus.h
================================================
/** \file
 * \brief Name space for C++ high level API
 *
 * See Copyright Notice in iup.h
 */

#ifndef __IUP_PLUS_H
#define __IUP_PLUS_H


#include "iup.h"
#include "iupkey.h"
#include "iupdraw.h"
#include "iup_class_cbs.hpp"
#include "iupcontrols.h"
#include "iupmatrixex.h"
#include "iupgl.h"
#include "iupglcontrols.h"
#include "iupim.h"
#include "iup_config.h"
#include "iup_mglplot.h"
#include "iup_plot.h"
#include "iupole.h"
#include "iupweb.h"
#include "iup_scintilla.h"
#include "iuptuio.h"
#include <string>


#if 0 //TODO

#ifdef _STRING_
std::string
#endif
void cdCanvasSetfAttribute(cdCanvas* canvas, const char* name, const char* format, ...);
void IupSetStrf(Ihandle* ih, const char* name, const char* format, ...);
void IupSetStrfId(Ihandle *ih, const char* name, int id, const char* format, ...);
void IupSetStrfId2(Ihandle* ih, const char* name, int lin, int col, const char* format, ...);
void IupMessagef(const char *title, const char *format, ...);

int IupScanf(const char *format, ...);
int IupGetParam(const char* title, Iparamcb action, void* user_data, const char* format, ...);
int IupGetParamv(const char* title, Iparamcb action, void* user_data, const char* format, int param_count, int param_extra, void** param_data);

Icallback IupGetCallback(Ihandle* ih, const char *name);
Icallback IupSetCallback(Ihandle* ih, const char *name, Icallback func);

void IupTreeSetAttributeHandle(Ihandle* ih, const char* name, int id, Ihandle* ih_named);

#endif

/** \brief Name space for C++ high level API
 *
 * \par
 * Defines wrapper classes for all C structures.
 *
 * See \ref iup_plus.h
 */
namespace iup
{
  inline char* Version() { return IupVersion(); }
  inline char* VersionDate() { return IupVersionDate(); }
  inline int VersionNumber() { return IupVersionNumber(); }

  inline int Open(int &argc, char **&argv) { return IupOpen(&argc, &argv); }
  inline void Close() { IupClose(); }
  inline void ImageLibOpen() { IupImageLibOpen(); }

  inline int MainLoop() { return IupMainLoop(); }
  inline int LoopStep() { return IupLoopStep(); }
  inline int LoopStepWait() { return IupLoopStepWait(); }
  inline int MainLoopLevel() { return IupMainLoopLevel(); }
  inline void Flush() { IupFlush(); }
  inline void ExitLoop() { IupExitLoop(); }

  inline int RecordInput(const char* filename, int mode) { return IupRecordInput(filename, mode); }
  inline int  PlayInput(const char* filename) { return IupPlayInput(filename); }

  inline int Help(const char* url) { return IupHelp(url); }
  inline const char* Load(const char *filename) { return IupLoad(filename); }
  inline const char* LoadBuffer(const char *buffer) { return IupLoadBuffer(buffer); }

  inline void SetLanguage(const char *lng) { IupSetLanguage(lng); }
  inline const char* GetLanguage() { return IupGetLanguage(); }
  inline void SetLanguageString(const char* name, const char* str) { IupSetLanguageString(name, str); }
  inline void StoreLanguageString(const char* name, const char* str) { IupStoreLanguageString(name, str); }
  inline const char* GetLanguageString(const char* name) { return IupGetLanguageString(name); }

  inline int GetAllClasses(char** names, int n) { return IupGetAllClasses(names, n); }
  inline int GetClassAttributes(const char* classname, char** names, int n) { return IupGetClassAttributes(classname, names, n); }
  inline int GetClassCallbacks(const char* classname, char** names, int n) { return IupGetClassCallbacks(classname, names, n); }
  inline void SetClassDefaultAttribute(const char* classname, const char *name, const char* value) { IupSetClassDefaultAttribute(classname, name, value); }

  inline void SetGlobal(const char* name, const char* value) { IupSetGlobal(name, value); }
  inline void SetStringGlobal(const char* name, const char* value) { IupSetStrGlobal(name, value); }
  inline char* GetGlobal(const char* name) { return IupGetGlobal(name); }

  inline int GetFile(char *arq) { return IupGetFile(arq); }
  inline void Message(const char *title, const char *msg) { IupMessage(title, msg); }
  inline int Alarm(const char *title, const char *msg, const char *b1, const char *b2, const char *b3) { return IupAlarm(title, msg, b1, b2, b3); }
  inline int ListDialog(int type, const char *title, int size, const char** list, int op, int max_col, int max_lin, int* marks) { return IupListDialog(type, title, size, list, op, max_col, max_lin, marks); }
  inline int GetText(const char* title, char* text, int maxsize = 10240) { return IupGetText(title, text, maxsize); }
  inline int GetColor(int x, int y, unsigned char &r, unsigned char &g, unsigned char &b) { return IupGetColor(x, y, &r, &g, &b); }

  inline int GetAllNames(char** names, int n) { return IupGetAllNames(names, n); }
  inline int GetAllDialogs(char** names, int n) { return IupGetAllDialogs(names, n); }


  class Handle
  {
  protected:
    Ihandle* ih;

    /* forbidden */
    Handle() { ih = 0; };

  public:
    Handle(Ihandle* ref_ih) { ih = ref_ih; }
    // There is no destructor because all iup::Handle are just a reference to the Ihandle*,
    // since several IUP elements are automatically destroyed when the dialog is destroyed
    // So, to force an element to be destructed call the Destroy method

    Ihandle* GetHandle() const { return ih; }

    void SetAttribute(const char* name, const char* value) { IupSetAttribute(ih, name, value); }
    char* GetAttribute(const char* name) { return IupGetAttribute(ih, name); }
    void SetUserData(const char* name, void* data) { IupSetAttribute(ih, name, (char*)data); }
    void* GetUserData(const char* name) { return (void*)IupGetAttribute(ih, name); }
    void SetString(const char* name, const char* value) { IupSetStrAttribute(ih, name, value); }
    const char* GetString(const char* name) { return IupGetAttribute(ih, name); }
    void SetInteger(const char* name, int value) { IupSetInt(ih, name, value); }
    int GetInteger(const char* name) { return IupGetInt(ih, name); }
    void GetIntegerInteger(const char* name, int &i1, int &i2) { IupGetIntInt(ih, name, &i1, &i2); }
    void SetNumber(const char* name, double value) { IupSetDouble(ih, name, value); }
    double GetNumber(const char* name) { return IupGetDouble(ih, name); }
    void SetRGB(const char* name, unsigned char r, unsigned char g, unsigned char b) { IupSetRGB(ih, name, r, g, b); }
    void GetRGB(const char* name, unsigned char &r, unsigned char &g, unsigned char &b) { IupGetRGB(ih, name, &r, &g, &b); }

    void SetAttributeId(const char* name, int id, const char* value) { IupSetAttributeId(ih, name, id, value); }
    char* GetAttributeId(const char* name, int id) { return IupGetAttributeId(ih, name, id); }
    void SetUserDataId(const char* name, int id, void* data) { IupSetAttributeId(ih, name, id, (char*)data); }
    void* GetUserDataId(const char* name, int id) { return (void*)IupGetAttributeId(ih, name, id); }
    void SetStringId(const char* name, int id, const char* value) { IupSetStrAttributeId(ih, name, id, value); }
    const char* GetStringId(const char* name, int id) { return IupGetAttributeId(ih, name, id); }
    void SetIntegerId(const char* name, int id, int value) { IupSetIntId(ih, name, id, value); }
    int GetIntegerId(const char* name, int id) { return IupGetIntId(ih, name, id); }
    void SetNumberId(const char* name, int id, double value) { IupSetDoubleId(ih, name, id, value); }
    double GetNumberId(const char* name, int id) { return IupGetDoubleId(ih, name, id); }
    void SetRGBId(const char* name, int id, unsigned char r, unsigned char g, unsigned char b) { IupSetRGBId(ih, name, id, r, g, b); }
    void GetRGBId(const char* name, int id, unsigned char &r, unsigned char &g, unsigned char &b) { IupGetRGBId(ih, name, id, &r, &g, &b); }

    void SetAttributeId2(const char* name, int lin, int col, const char* value) { IupSetAttributeId2(ih, name, lin, col, value); }
    char* GetAttributeId2(const char* name, int lin, int col) { return IupGetAttributeId2(ih, name, lin, col); }
    void SetUserDataId2(const char* name, int lin, int col, void* data) { IupSetAttributeId2(ih, name, lin, col, (char*)data); }
    void* GetUserDataId2(const char* name, int lin, int col) { return (void*)IupGetAttributeId2(ih, name, lin, col); }
    void SetStringId2(const char* name, int lin, int col, const char* value) { IupSetStrAttributeId2(ih, name, lin, col, value); }
    const char* GetStringId2(const char* name, int lin, int col) { return IupGetAttributeId2(ih, name, lin, col); }
    void SetIntegerId2(const char* name, int lin, int col, int value) { IupSetIntId2(ih, name, lin, col, value); }
    int GetIntegerId2(const char* name, int lin, int col) { return IupGetIntId2(ih, name, lin, col); }
    void SetNumberId2(const char* name, int lin, int col, double value) { IupSetDoubleId2(ih, name, lin, col, value); }
    double GetNumberId2(const char* name, int lin, int col) { return IupGetDoubleId2(ih, name, lin, col); }
    void SetRGBId2(const char* name, int lin, int col, unsigned char r, unsigned char g, unsigned char b) { IupSetRGBId2(ih, name, lin, col, r, g, b); }
    void GetRGBId2(const char* name, int lin, int col, unsigned char &r, unsigned char &g, unsigned char &b) { IupGetRGBId2(ih, name, lin, col, &r, &g, &b); }

    void ResetAttribute(const char* name) { IupResetAttribute(ih, name); }
    int GetAllAttributes(char** names, int n) { return IupGetAllAttributes(ih, names, n); }
    void SetAttributeHandle(const char* name, const  Handle& handle) { IupSetAttributeHandle(ih, name, handle.GetHandle()); }
    Handle GetAttributeHandle(const char* name) { return IupGetAttributeHandle(ih, name); }

    void Destroy() { IupDestroy(ih); }

    int Map() { return IupMap(ih); }
    void Unmap() { IupUnmap(ih); }

    char* GetName() { return IupGetName(ih); }

    char* GetClassName() { return IupGetClassName(ih); }
    char* GetClassType() { return IupGetClassType(ih); }
    void SaveClassAttributes() { IupSaveClassAttributes(ih); }
    void CopyClassAttributesTo(const Handle& dst) { IupCopyClassAttributes(ih, dst.ih); }
    int ClassMatch(const char* classname) { return IupClassMatch(ih, classname); }

  };

  inline Handle GetHandle(const char *name) { return Handle(IupGetHandle(name)); }
  inline Handle SetHandle(const char *name, const Handle& handle) { return Handle(IupSetHandle(name, handle.GetHandle())); }
  inline void SetLanguagePack(const Handle& handle) { IupSetLanguagePack(handle.GetHandle()); }

  class Dialog;
  class Container;

  class Control : public Handle
  {
  public:
    Control(Ihandle* _ih) : Handle(_ih) {}

    void Update() { IupUpdate(ih); }
    void Redraw() { IupRedraw(ih, 0); }
    void Refresh() { IupRefresh(ih); }

    void Detach(const Control& child) { IupDetach(child.ih); }

    Control GetBrother() { return Control(IupGetBrother(ih)); }
    Container GetParent();
    Dialog GetDialog();
    Control GetDialogChild(const char* name) { return Control(IupGetDialogChild(ih, name)); }
    int Reparent(const Container& new_parent, const Control& ref_child);

    Control SetFocus() { return Control(IupSetFocus(ih)); }
    Control PreviousField() { return Control(IupPreviousField(ih)); }
    Control NextField() { return Control(IupNextField(ih)); }
    
    void ConvertLinColToPos(int lin, int col, int &pos) { IupTextConvertLinColToPos(ih, lin, col, &pos); }
    void ConvertPosToLinCol(int pos, int &lin, int &col) { IupTextConvertPosToLinCol(ih, pos, &lin, &col); }
    int ConvertXYToPos(int x, int y) { return IupConvertXYToPos(ih, x, y); }
  };

  inline Control GetFocus() { return Control(IupGetFocus()); }

  class Container : public Control
  {
  public:
    Container(Ihandle* _ih) : Control(_ih) {}
    Container(Ihandle* _ih, const Control* child_array, int count) : Control(_ih) {
      for (int i = 0; i < count; i++)
        IupAppend(ih, child_array[i].GetHandle());
    }
    Container(Ihandle* _ih, const Control* child0, const Control* child1 = 0, const Control* child2 = 0, const Control* child3 = 0, const Control* child4 = 0, const Control* child5 = 0, const Control* child6 = 0, const Control* child7 = 0, const Control* child8 = 0, const Control* child9 = 0)
      : Control(_ih) {
      if (child0) IupAppend(ih, child0->GetHandle());
      if (child1) IupAppend(ih, child1->GetHandle());
      if (child2) IupAppend(ih, child2->GetHandle());
      if (child3) IupAppend(ih, child3->GetHandle());
      if (child4) IupAppend(ih, child4->GetHandle());
      if (child5) IupAppend(ih, child5->GetHandle());
      if (child6) IupAppend(ih, child6->GetHandle());
      if (child7) IupAppend(ih, child7->GetHandle());
      if (child8) IupAppend(ih, child8->GetHandle());
      if (child9) IupAppend(ih, child9->GetHandle());
    }

    Control Append(const Control& child) { return IupAppend(ih, child.GetHandle()); }
    Control Insert(const Control& ref_child, const  Control& child) { return IupInsert(ih, ref_child.GetHandle(), child.GetHandle()); }
    Control GetChild(int pos) { return IupGetChild(ih, pos); }
    int GetChildPos(const  Control& child) { return IupGetChildPos(ih, child.GetHandle()); }
    int GetChildCount() { return IupGetChildCount(ih); }

    Control GetFirstChild() { return Control(IupGetNextChild(ih, 0)); }
    Control GetNextChild(const Control& ref_child) { return Control(IupGetNextChild(ih, ref_child.GetHandle())); }

    void UpdateChildren() { IupUpdateChildren(ih); }
    void RedrawChildren() { IupRedraw(ih, 1); }
    void RefreshChildren() { IupRefreshChildren(ih); }
  };
  class Dialog : public Container
  {
  public:
    Dialog(Ihandle* _ih) : Container(_ih) {}
    Dialog(const Control& child) : Container(IupDialog(child.GetHandle())) { }

    int Popup(int x, int y) { return IupPopup(ih, x, y); }
    int Show() { return IupShow(ih); }
    int ShowXY(int x, int y) { return IupShowXY(ih, x, y); }
    int Hide() { return IupHide(ih); }
  };

  inline Dialog Control::GetDialog() { return Dialog(IupGetDialog(ih)); }
  inline Dialog LayoutDialog(const Dialog& dialog) { return Dialog(IupLayoutDialog(dialog.GetHandle())); }
  inline Dialog ElementPropertiesDialog(const Control& control) { return Dialog(IupElementPropertiesDialog(control.GetHandle())); }
  inline Container Control::GetParent() { return Container(IupGetParent(ih)); }
  inline int Control::Reparent(const Container& new_parent, const Control& ref_child) { return IupReparent(ih, new_parent.GetHandle(), ref_child.GetHandle()); }

  class Menu : public Container
  {
  public:
    Menu() : Container(IupMenu(0)) {}
    Menu(const Control& child) : Container(IupMenu(child.GetHandle(), 0)) {}
    Menu(const Control* child0, const Control* child1 = 0, const Control* child2 = 0, const Control* child3 = 0, const Control* child4 = 0, const Control* child5 = 0, const Control* child6 = 0, const Control* child7 = 0, const Control* child8 = 0, const Control* child9 = 0)
      : Container(IupMenu(0), child0, child1, child2, child3, child4, child5, child6, child7, child8, child9) {}
    Menu(const Control* child_array, int count) : Container(IupMenu(0), child_array, count) {}

    int Popup(int x, int y) { return IupPopup(ih, x, y); }
  };

#ifdef __IM_PLUS_H
  class Image : public Handle
  {
  public:
    Image(const char* filename) : Handle(IupLoadImage(filename)) {}
    Image(const im::Image& image) : Handle(IupImageFromImImage(image.GetHandle())) {}

    int Save(const char* filename, const char* im_format) { return IupSaveImage(ih, filename, im_format); }
    int SaveAsText(const char* filename, const char* iup_format, const char* name) { return IupSaveImageAsText(ih, filename, iup_format, name); }
  };
  class Clipboard : public Handle
  {
  public:
    Clipboard() : Handle(IupClipboard()) {}

    void SetImage(const im::Image& image) { SetUserData("NATIVEIMAGE", IupGetImageNativeHandle(image.GetHandle())); }

    im::Image GetImage(void) { return im::Image(IupGetNativeHandleImage(GetUserData("NATIVEIMAGE"))); }
  };
#endif
  class User : public Handle
  {
  public:
    User() : Handle(IupUser()) {}
  };
  class Param : public Handle
  {
  public:
    Param(const char* format) : Handle(IupParam(format)) {}
  };
  class Timer : public Handle
  {
  public:
    Timer() : Handle(IupTimer()) {}
  };
  class MenuSeparator : public Control
  {
  public:
    MenuSeparator() : Control(IupSeparator()) {}
  };
  class MenuItem : public Control
  {
  public:
    MenuItem(const char* title = 0) : Control(IupItem(title, 0)) {}
  };
  class Canvas : public Control
  {
  public:
    Canvas() : Control(IupCanvas(0)) {}
                   
    void DrawBegin() { IupDrawBegin(ih); }
    void DrawEnd() { IupDrawEnd(ih); }
    void DrawSetClipRect(int x1, int y1, int x2, int y2) { IupDrawSetClipRect(ih, x1, y1, x2, y2); }
    void DrawResetClip() { IupDrawResetClip(ih); }
    void DrawParentBackground() { IupDrawParentBackground(ih); }
    void DrawLine(int x1, int y1, int x2, int y2) { IupDrawLine(ih, x1, y1, x2, y2); }
    void DrawRectangle(int x1, int y1, int x2, int y2) { IupDrawRectangle(ih, x1, y1, x2, y2); }
    void DrawArc(int x1, int y1, int x2, int y2, double a1, double a2) { IupDrawArc(ih, x1, y1, x2, y2, a1, a2); }
    void DrawPolygon(int* points, int count) { IupDrawPolygon(ih, points, count); }
    void DrawText(const char* text, int len, int x, int y) { IupDrawText(ih, text, len, x, y); }
    void DrawImage(const char* name, int make_inactive, int x, int y) { IupDrawImage(ih, name, make_inactive, x, y); }
    void DrawSelectRect(int x1, int y1, int x2, int y2) { IupDrawSelectRect(ih, x1, y1, x2, y2); }
    void DrawFocusRect(int x1, int y1, int x2, int y2) { IupDrawFocusRect(ih, x1, y1, x2, y2); }
    void DrawGetSize(int &w, int &h) { IupDrawGetSize(ih, &w, &h); }
    void DrawGetTextSize(const char* str, int &w, int &h) { IupDrawGetTextSize(ih, str, &w, &h); }
    void DrawGetImageInfo(const char* name, int &w, int &h, int &bpp) { IupDrawGetImageInfo(name, &w, &h, &bpp); }
  };
  class Link : public Control
  {
  public:
    Link(const char* url = 0, const char* title = 0) : Control(IupLink(url, title)) {}
  };
  class Label : public Control
  {
  public:
    Label(const char* title = 0) : Control(IupLabel(title)) {}
  };
  class Button : public Control
  {
  public:
    Button(const char* title = 0) : Control(IupButton(title, 0)) {}
  };
  class FlatButton : public Control
  {
  public:
    FlatButton(const char* title = 0) : Control(IupFlatButton(title)) {}
  };
  class AnimatedLabel : public Control
  {
  public:
    AnimatedLabel(Ihandle* animation = 0) : Control(IupAnimatedLabel(animation)) {}
  };
  class Toggle : public Control
  {
  public:
    Toggle(const char* title = 0) : Control(IupToggle(title, 0)) {}
  };
  class Fill: public Control
  {
  public:
    Fill() : Control(IupFill()) {}
  };
  class Spin: public Control
  {
  public:
    Spin() : Control(IupSpin()) {}
  };
  class Tree: public Control
  {
  public:
    Tree() : Control(IupTree()) {}
    
    int SetUserId(int id, void* userid) { return IupTreeSetUserId(ih, id, userid); }
    void* GetUserId(int id) { return IupTreeGetUserId(ih, id); }
    int GetId(void *userid) { return IupTreeGetId(ih, userid); }
  };
  class Val : public Control
  {
  public:
    Val(const char* orientation = 0) : Control(IupVal(orientation)) {}
  };
  class ProgressBar: public Control
  {
  public:
    ProgressBar() : Control(IupProgressBar()) {}
  };
  class List: public Control
  {
  public:
    List() : Control(IupList(0)) {}
  };
  class Text: public Control
  {
  public:
    Text() : Control(IupText(0)) {}
  };
  class Split : public Container
  {
  public:
    Split() : Container(IupSplit(0, 0)) {}
    Split(const Control& child) : Container(IupSplit(child.GetHandle(), 0)) {}
    Split(const Control& child1, const Control& child2) : Container(IupSplit(child1.GetHandle(), child2.GetHandle())) {}
  };
  class Submenu : public Container
  {
  public:
    Submenu(const char* title = 0) : Container(IupSubmenu(title, 0)) {}
    Submenu(const char* title, const Control& child) : Container(IupSubmenu(title, child.GetHandle())) {}
  };
  class Radio : public Container
  {
  public:
    Radio() : Container(IupRadio(0)) {}
    Radio(const Control& child) : Container(IupRadio(child.GetHandle())) {}
  };
  class Sbox : public Container
  {
  public:
    Sbox() : Container(IupSbox(0)) {}
    Sbox(const Control& child) : Container(IupSbox(child.GetHandle())) {}
  };
  class ScrollBox : public Container
  {
  public:
    ScrollBox() : Container(IupScrollBox(0)) {}
    ScrollBox(const Control& child) : Container(IupScrollBox(child.GetHandle())) {}
  };
  class Expander : public Container
  {
  public:
    Expander() : Container(IupExpander(0)) {}
    Expander(const Control& child) : Container(IupExpander(child.GetHandle())) {}
  };
  class DetachBox : public Container
  {
  public:
    DetachBox() : Container(IupDetachBox(0)) {}
    DetachBox(const Control& child) : Container(IupDetachBox(child.GetHandle())) {}
  };
  class BackgroundBox : public Container
  {
  public:
    BackgroundBox() : Container(IupBackgroundBox(0)) {}
    BackgroundBox(const Control& child) : Container(IupBackgroundBox(child.GetHandle())) {}

    void DrawBegin() { IupDrawBegin(ih); }
    void DrawEnd() { IupDrawEnd(ih); }
    void DrawSetClipRect(int x1, int y1, int x2, int y2) { IupDrawSetClipRect(ih, x1, y1, x2, y2); }
    void DrawResetClip() { IupDrawResetClip(ih); }
    void DrawParentBackground() { IupDrawParentBackground(ih); }
    void DrawLine(int x1, int y1, int x2, int y2) { IupDrawLine(ih, x1, y1, x2, y2); }
    void DrawRectangle(int x1, int y1, int x2, int y2) { IupDrawRectangle(ih, x1, y1, x2, y2); }
    void DrawArc(int x1, int y1, int x2, int y2, double a1, double a2) { IupDrawArc(ih, x1, y1, x2, y2, a1, a2); }
    void DrawPolygon(int* points, int count) { IupDrawPolygon(ih, points, count); }
    void DrawText(const char* text, int len, int x, int y) { IupDrawText(ih, text, len, x, y); }
    void DrawImage(const char* name, int make_inactive, int x, int y) { IupDrawImage(ih, name, make_inactive, x, y); }
    void DrawSelectRect(int x1, int y1, int x2, int y2) { IupDrawSelectRect(ih, x1, y1, x2, y2); }
    void DrawFocusRect(int x1, int y1, int x2, int y2) { IupDrawFocusRect(ih, x1, y1, x2, y2); }
    void DrawGetSize(int &w, int &h) { IupDrawGetSize(ih, &w, &h); }
    void DrawGetTextSize(const char* str, int &w, int &h) { IupDrawGetTextSize(ih, str, &w, &h); }
    void DrawGetImageInfo(const char* name, int &w, int &h, int &bpp) { IupDrawGetImageInfo(name, &w, &h, &bpp); }
  };
  class Frame : public Container
  {
  public:
    Frame() : Container(IupFrame(0)) {}
    Frame(const Control& child) : Container(IupFrame(child.GetHandle())) {}
  };
  class FlatFrame : public Container
  {
  public:
    FlatFrame() : Container(IupFlatFrame(0)) {}
    FlatFrame(const Control& child) : Container(IupFlatFrame(child.GetHandle())) {}
  };
  class Spinbox : public Container
  {
  public:
    Spinbox() : Container(IupSpinbox(0)) {}
    Spinbox(const Control& child) : Container(IupSpinbox(child.GetHandle())) {}
  };
  class Vbox : public Container
  {
  public:
    Vbox() : Container(IupVbox(0)) {}
    Vbox(const Control& child) : Container(IupVbox(child.GetHandle(), 0)) {}
    Vbox(const Control* child0, const Control* child1 = 0, const Control* child2 = 0, const Control* child3 = 0, const Control* child4 = 0, const Control* child5 = 0, const Control* child6 = 0, const Control* child7 = 0, const Control* child8 = 0, const Control* child9 = 0)
      : Container(IupVbox(0), child0, child1, child2, child3, child4, child5, child6, child7, child8, child9) {}
    Vbox(const Control* child_array, int count) : Container(IupVbox(0), child_array, count) {}
  };
  class Hbox : public Container
  {
  public:
    Hbox() : Container(IupHbox(0)) {}
    Hbox(const Control& child) : Container(IupHbox(child.GetHandle(), 0)) {}
    Hbox(const Control* child0, const Control* child1 = 0, const Control* child2 = 0, const Control* child3 = 0, const Control* child4 = 0, const Control* child5 = 0, const Control* child6 = 0, const Control* child7 = 0, const Control* child8 = 0, const Control* child9 = 0)
      : Container(IupHbox(0), child0, child1, child2, child3, child4, child5, child6, child7, child8, child9) {}
    Hbox(const Control* child_array, int count) : Container(IupHbox(0), child_array, count) {}
  };
  class Zbox : public Container
  {
  public:
    Zbox() : Container(IupZbox(0)) {}
    Zbox(const Control& child) : Container(IupZbox(child.GetHandle(), 0)) {}
    Zbox(const Control* child0, const Control* child1 = 0, const Control* child2 = 0, const Control* child3 = 0, const Control* child4 = 0, const Control* child5 = 0, const Control* child6 = 0, const Control* child7 = 0, const Control* child8 = 0, const Control* child9 = 0)
      : Container(IupZbox(0), child0, child1, child2, child3, child4, child5, child6, child7, child8, child9) {}
    Zbox(const Control* child_array, int count) : Container(IupZbox(0), child_array, count) {}
  };
  class Cbox : public Container
  {
  public:
    Cbox() : Container(IupCbox(0)) {}
    Cbox(const Control& child) : Container(IupCbox(child.GetHandle(), 0)) {}
    Cbox(const Control* child0, const Control* child1 = 0, const Control* child2 = 0, const Control* child3 = 0, const Control* child4 = 0, const Control* child5 = 0, const Control* child6 = 0, const Control* child7 = 0, const Control* child8 = 0, const Control* child9 = 0)
      : Container(IupCbox(0), child0, child1, child2, child3, child4, child5, child6, child7, child8, child9) {}
    Cbox(const Control* child_array, int count) : Container(IupCbox(0), child_array, count) {}
  };
  class Tabs : public Container
  {
  public:
    Tabs() : Container(IupTabs(0)) {}
    Tabs(const Control& child) : Container(IupTabs(child.GetHandle(), 0)) {}
    Tabs(const Control* child0, const Control* child1 = 0, const Control* child2 = 0, const Control* child3 = 0, const Control* child4 = 0, const Control* child5 = 0, const Control* child6 = 0, const Control* child7 = 0, const Control* child8 = 0, const Control* child9 = 0)
      : Container(IupTabs(0), child0, child1, child2, child3, child4, child5, child6, child7, child8, child9) {}
    Tabs(const Control* child_array, int count) : Container(IupTabs(0), child_array, count) {}
  };
  class GridBox : public Container
  {
  public:
    GridBox() : Container(IupGridBox(0)) {}
    GridBox(const Control& child) : Container(IupGridBox(child.GetHandle(), 0)) {}
    GridBox(const Control* child0, const Control* child1 = 0, const Control* child2 = 0, const Control* child3 = 0, const Control* child4 = 0, const Control* child5 = 0, const Control* child6 = 0, const Control* child7 = 0, const Control* child8 = 0, const Control* child9 = 0)
      : Container(IupGridBox(0), child0, child1, child2, child3, child4, child5, child6, child7, child8, child9) {}
    GridBox(const Control* child_array, int count) : Container(IupGridBox(0), child_array, count) {}
  };
  class ParamBox : public Container
  {
    ParamBox() : Container(IupParamBox(0)) {}
  public:
    ParamBox(const Control& child) : Container(IupParamBox(child.GetHandle(), 0)) {}
    ParamBox(const Control* child0, const Control* child1 = 0, const Control* child2 = 0, const Control* child3 = 0, const Control* child4 = 0, const Control* child5 = 0, const Control* child6 = 0, const Control* child7 = 0, const Control* child8 = 0, const Control* child9 = 0)
      : Container(IupParamBox(child0->GetHandle(), child1->GetHandle(), child2->GetHandle(), child3->GetHandle(), child4->GetHandle(), child5->GetHandle(), child6->GetHandle(), child7->GetHandle(), child8->GetHandle(), child9->GetHandle(), 0)) {}
  };
  class Normalizer : public Container
  {
  public:
    Normalizer() : Container(IupNormalizer(0)) {}
    Normalizer(const Control& child) : Container(IupNormalizer(child.GetHandle(), 0)) {}
    Normalizer(const Control* child0, const Control* child1 = 0, const Control* child2 = 0, const Control* child3 = 0, const Control* child4 = 0, const Control* child5 = 0, const Control* child6 = 0, const Control* child7 = 0, const Control* child8 = 0, const Control* child9 = 0)
      : Container(IupNormalizer(0), child0, child1, child2, child3, child4, child5, child6, child7, child8, child9) {}
    Normalizer(const Control* child_array, int count) : Container(IupNormalizer(0), child_array, count) {}
  };


  class FileDialog : public Dialog
  {
  public:
    FileDialog() : Dialog(IupFileDlg()) {}
  };
  class MessageDialog : public Dialog
  {
  public:
    MessageDialog() : Dialog(IupMessageDlg()) {}
  };
  class ColorDialog : public Dialog
  {
  public:
    ColorDialog() : Dialog(IupColorDlg()) {}
  };
  class FontDialog : public Dialog
  {
  public:
    FontDialog() : Dialog(IupFontDlg()) {}
  };
  class ProgressDialog : public Dialog
  {
  public:
    ProgressDialog() : Dialog(IupProgressDlg()) {}
  };
  class GLCanvas : public Control
  {
  public:
    GLCanvas() : Control(IupGLCanvas(0)) {}

    static void Open() { IupGLCanvasOpen(); }

    void MakeCurrent() { IupGLMakeCurrent(ih); }
    int IsCurrent() { return IupGLIsCurrent(ih); }
    void SwapBuffers() { IupGLSwapBuffers(ih); }
    void Palette(int index, float r, float g, float b) { IupGLPalette(ih, index, r, g, b); }
    void UseFont(int first, int count, int list_base) { IupGLUseFont(ih, first, count, list_base); }

    static void Wait(int gl) { IupGLWait(gl); }
  };
  class GLBackgroundBox : public Container
  {
  public:
    GLBackgroundBox() : Container(IupGLBackgroundBox(0)) {}
    GLBackgroundBox(const Control& child) : Container(IupGLBackgroundBox(child.GetHandle())) {}
  };

  class Controls
  {
  public:
    static void Open() { IupControlsOpen(); }
  };
  class Dial : public Control
  {
  public:
    Dial(const char* orientation = 0) : Control(IupDial(orientation)) {}
  };
  class Gauge : public Control
  {
  public:
    Gauge() : Control(IupGauge()) {}
  };
  class ColorBrowser : public Control
  {
  public:
    ColorBrowser() : Control(IupColorBrowser()) {}
  };
  class Cells : public Control
  {
  public:
    Cells() : Control(IupCells()) {}
  };
  class Colorbar : public Control
  {
  public:
    Colorbar() : Control(IupColorbar()) {}
  };
  class Matrix : public Control
  {
  public:
    Matrix() : Control(IupMatrix(0)) {}

    void SetFormula(int col, const char* formula, const char* init = 0) { IupMatrixSetFormula(ih, col, formula, init); }
    void SetDynamic(Ihandle* ih, const char* init = 0) { IupMatrixSetDynamic(ih, init); }
  };
  class MatrixList : public Control
  {
  public:
    MatrixList() : Control(IupMatrixList()) {}
  };
  class MatrixEx : public Control
  {
  public:
    MatrixEx() : Control(IupMatrixEx()) {}

    static void Open() { IupMatrixExOpen(); }
  };
  class GLControls
  {
  public:
    static void Open() { IupGLControlsOpen(); }
  };
  class GLSubCanvas : public Control
  {
  public:
    GLSubCanvas() : Control(IupGLSubCanvas()) {}
  };
  class GLSeparator : public Control
  {
  public:
    GLSeparator() : Control(IupGLSeparator()) {}
  };
  class GLProgressBar : public Control
  {
  public:
    GLProgressBar() : Control(IupGLProgressBar()) {}
  };
  class GLVal : public Control
  {
  public:
    GLVal() : Control(IupGLVal()) {}
  };
  class GLLabel : public Control
  {
  public:
    GLLabel(const char* title = 0) : Control(IupGLLabel(title)) {}
  };
  class GLButton : public Control
  {
  public:
    GLButton(const char* title = 0) : Control(IupGLButton(title)) {}
  };
  class GLToggle : public Control
  {
  public:
    GLToggle(const char* title = 0) : Control(IupGLToggle(title)) {}
  };
  class GLLink : public Control
  {
  public:
    GLLink(const char *url = 0, const char* title = 0) : Control(IupGLLink(url, title)) {}
  };
  class GLFrame : public Container
  {
  public:
    GLFrame(const Control& child) : Container(IupGLFrame(child.GetHandle())) {}
    GLFrame() : Container(IupGLFrame(0)) {}
  };
  class GLExpander : public Container
  {
  public:
    GLExpander(const Control& child) : Container(IupGLExpander(child.GetHandle())) {}
    GLExpander() : Container(IupGLExpander(0)) {}
  };
  class GLScrollBox : public Container
  {
  public:
    GLScrollBox(const Control& child) : Container(IupGLScrollBox(child.GetHandle())) {}
    GLScrollBox() : Container(IupGLScrollBox(0)) {}
  };
  class GLSizeBox : public Container
  {
  public:
    GLSizeBox(const Control& child) : Container(IupGLSizeBox(child.GetHandle())) {}
    GLSizeBox() : Container(IupGLSizeBox(0)) {}
  };
  class GLCanvasBox : public Container
  {
  public:
    GLCanvasBox() : Container(IupGLCanvasBox(0)) {}
    GLCanvasBox(const Control& child) : Container(IupGLCanvasBox(child.GetHandle(), 0)) {}
    GLCanvasBox(const Control* child0, const Control* child1 = 0, const Control* child2 = 0, const Control* child3 = 0, const Control* child4 = 0, const Control* child5 = 0, const Control* child6 = 0, const Control* child7 = 0, const Control* child8 = 0, const Control* child9 = 0) 
      : Container(IupGLCanvasBox(0), child0, child1, child2, child3, child4, child5, child6, child7, child8, child9) {}
    GLCanvasBox(const Control* child_array, int count) : Container(IupGLCanvasBox(0), child_array, count) {}
  };
  class Plot : public Control
  {
  public:
    Plot() : Control(IupPlot()) {}

    static void Open() { IupPlotOpen(); }

    void Begin(int strXdata) { IupPlotBegin(ih, strXdata); }
    void Add(double x, double y) { IupPlotAdd(ih, x, y); }
    void AddStr(const char* x, double y) { IupPlotAddStr(ih, x, y); }
    void AddSegment(double x, double y) { IupPlotAddSegment(ih, x, y); }
    int End(Ihandle *ih) { return IupPlotEnd(ih); }

    int LoadData(const char* filename, int strXdata) { return IupPlotLoadData(ih, filename, strXdata); }

    int SetFormula(int sample_count, const char* formula, const char* init) { return IupPlotSetFormula(ih, sample_count, formula, init); }

    void Insert(int ds_index, int sample_index, double x, double y) { IupPlotInsert(ih, ds_index, sample_index, x, y); }
    void InsertStr(int ds_index, int sample_index, const char* x, double y) { IupPlotInsertStr(ih, ds_index, sample_index, x, y); }
    void InsertSegment(int ds_index, int sample_index, double x, double y) { IupPlotInsertSegment(ih, ds_index, sample_index, x, y); }

    void InsertStrSamples(int ds_index, int sample_index, const char** x, double* y, int count) { IupPlotInsertStrSamples(ih, ds_index, sample_index, x, y, count); }
    void InsertSamples(int ds_index, int sample_index, double *x, double *y, int count) { IupPlotInsertSamples(ih, ds_index, sample_index, x, y, count); }

    void AddSamples(int ds_index, double *x, double *y, int count) { IupPlotAddSamples(ih, ds_index, x, y, count); }
    void AddStrSamples(int ds_index, const char** x, double* y, int count) { IupPlotAddStrSamples(ih, ds_index, x, y, count); }

    void GetSample(int ds_index, int sample_index, double &x, double &y) { IupPlotGetSample(ih, ds_index, sample_index, &x, &y); }
    void GetSampleStr(int ds_index, int sample_index, const char* &x, double &y) { IupPlotGetSampleStr(ih, ds_index, sample_index, &x, &y); }
    int GetSampleSelection(int ds_index, int sample_index) { return IupPlotGetSampleSelection(ih, ds_index, sample_index); }
    double GetSampleExtra(int ds_index, int sample_index) { return IupPlotGetSampleExtra(ih, ds_index, sample_index); }
    void SetSample(int ds_index, int sample_index, double x, double y) { IupPlotSetSample(ih, ds_index, sample_index, x, y); }
    void SetSampleStr(int ds_index, int sample_index, const char* x, double y) { IupPlotSetSampleStr(ih, ds_index, sample_index, x, y); }
    void SetSampleSelection(int ds_index, int sample_index, int selected) { IupPlotSetSampleSelection(ih, ds_index, sample_index, selected); }
    void SetSampleExtra(int ds_index, int sample_index, double extra) { IupPlotSetSampleExtra(ih, ds_index, sample_index, extra); }

    void Transform(double x, double y, double &cnv_x, double &cnv_y) { IupPlotTransform(ih, x, y, &cnv_x, &cnv_y); }
    void TransformTo(double cnv_x, double cnv_y, double &x, double &y) { IupPlotTransformTo(ih, cnv_x, cnv_y, &x, &y); }

    int FindSample(double cnv_x, double cnv_y, int &ds_index, int &sample_index) { return IupPlotFindSample(ih, cnv_x, cnv_y, &ds_index, &sample_index); }

#ifdef __CD_PLUS_H
    void PaintTo(cd::Canvas& cd_canvas) { IupPlotPaintTo(ih, cd_canvas.GetHandle()); }
#endif
  };
  class MglPlot : public Control
  {
  public:
    MglPlot() : Control(IupMglPlot()) {}

    static void Open() { IupMglPlotOpen(); }

    void Begin(int dim) { IupMglPlotBegin(ih, dim); }
    void Add1D(const char* name, double y) { IupMglPlotAdd1D(ih, name, y); }
    void Add2D(double x, double y) { IupMglPlotAdd2D(ih, x, y); }
    void Add3D(double x, double y, double z) { IupMglPlotAdd3D(ih, x, y, z); }
    int End() { return IupMglPlotEnd(ih); }

    int NewDataSet(int dim) { return IupMglPlotNewDataSet(ih, dim); }

    void Insert1D(int ds_index, int sample_index, const char** names, const double* y, int count) { IupMglPlotInsert1D(ih, ds_index, sample_index, names, y, count); }
    void Insert2D(int ds_index, int sample_index, const double* x, const double* y, int count) { IupMglPlotInsert2D(ih, ds_index, sample_index, x, y, count); }
    void Insert3D(int ds_index, int sample_index, const double* x, const double* y, const double* z, int count) { IupMglPlotInsert3D(ih, ds_index, sample_index, x, y, z, count); }

    void Set1D(int ds_index, const char** names, const double* y, int count) { IupMglPlotSet1D(ih, ds_index, names, y, count); }
    void Set2D(int ds_index, const double* x, const double* y, int count) { IupMglPlotSet2D(ih, ds_index, x, y, count); }
    void Set3D(int ds_index, const double* x, const double* y, const double* z, int count) { IupMglPlotSet3D(ih, ds_index, x, y, z, count); }
    void SetFormula(int ds_index, const char* formulaX, const char* formulaY, const char* formulaZ, int count) { IupMglPlotSetFormula(ih, ds_index, formulaX, formulaY, formulaZ, count); }

    void SetData(int ds_index, const double* data, int count_x, int count_y, int count_z) { IupMglPlotSetData(ih, ds_index, data, count_x, count_y, count_z); }
    void LoadData(int ds_index, const char* filename, int count_x, int count_y, int count_z) { IupMglPlotLoadData(ih, ds_index, filename, count_x, count_y, count_z); }
    void SetFromFormula(int ds_index, const char* formula, int count_x, int count_y, int count_z) { IupMglPlotSetFromFormula(ih, ds_index, formula, count_x, count_y, count_z); }

    void Transform(double x, double y, double z, int &ix, int &iy) { IupMglPlotTransform(ih, x, y, z, &ix, &iy); }
    void TransformTo(int ix, int iy, double &x, double &y, double &z) { IupMglPlotTransformTo(ih, ix, iy, &x, &y, &z); }

    void DrawMark(double x, double y, double z) { IupMglPlotDrawMark(ih, x, y, z); }
    void DrawLine(double x1, double y1, double z1, double x2, double y2, double z2) { IupMglPlotDrawLine(ih, x1, y1, z1, x2, y2, z2); }
    void DrawText(const char* text, double x, double y, double z) { IupMglPlotDrawText(ih, text, x, y, z); }

    void PaintTo(const char* format, int w, int h, double dpi, unsigned char* data) { IupMglPlotPaintTo(ih, format, w, h, dpi, (void*)data); }
    void PaintTo(const char* format, int w, int h, double dpi, const char* filename) { IupMglPlotPaintTo(ih, format, w, h, dpi, (void*)filename); }

  };
  class MglLabel : public Control
  {
  public:
    MglLabel(const char* title) : Control(IupMglLabel(title)) {}
  };
  class OleControl : public Control
  {
  public:
    OleControl(const char* progid) : Control(IupOleControl(progid)) {}

    static void Open() { IupOleControlOpen(); }
  };
  class WebBrowser : public Control
  {
  public:
    WebBrowser() : Control(IupWebBrowser()) {}

    static void Open() { IupWebBrowserOpen(); }
  };
  class Scintilla : public Control
  {
  public:
    Scintilla(): Control(IupScintilla()) {}

    static void Open() { IupScintillaOpen(); }
  };
  class TuioClient : public Handle
  {
  public:
    TuioClient(int port) : Handle(IupTuioClient(port)) {}

    static void Open() { IupTuioOpen(); }
  };

  class Config: public Handle
  {
  public:
    Config(): Handle(IupConfig()) { }

    int LoadConfig() { return IupConfigLoad(ih); }
    int SaveConfig() { return IupConfigSave(ih); }

    void SetVariableStrId(const char* group, const char* key, int id, const char* value) { IupConfigSetVariableStrId(ih, group, key, id, value); }
    void SetVariableIntId(const char* group, const char* key, int id, int value) { IupConfigSetVariableIntId(ih, group, key, id, value); }
    void SetVariableDoubleId(const char* group, const char* key, int id, double value) { IupConfigSetVariableDoubleId(ih, group, key, id, value); }
    void SetVariableStr(const char* group, const char* key, const char* value) { IupConfigSetVariableStr(ih, group, key, value); }
    void SetVariableInt(const char* group, const char* key, int value) { IupConfigSetVariableInt(ih, group, key, value); }
    void SetVariableDouble(const char* group, const char* key, double value) { IupConfigSetVariableDouble(ih, group, key, value); }

    char* GetVariableStr(const char* group, const char* key) { return (char*)IupConfigGetVariableStr(ih, group, key); }
    int GetVariableInt(const char* group, const char* key) { return IupConfigGetVariableInt(ih, group, key); }
    double GetVariableDouble(const char* group, const char* key) { return IupConfigGetVariableDouble(ih, group, key); }
    char* GetVariableStrId(const char* group, const char* key, int id) { return (char*)IupConfigGetVariableStrId(ih, group, key, id); }
    int GetVariableIntId(const char* group, const char* key, int id) { return IupConfigGetVariableIntId(ih, group, key, id); }
    double GetVariableDoubleId(const char* group, const char* key, int id) { return IupConfigGetVariableDoubleId(ih, group, key, id); }

    char* GetVariableStrDef(const char* group, const char* key, const char* def) { return (char*)IupConfigGetVariableStrDef(ih, group, key, def); }
    int GetVariableIntDef(const char* group, const char* key, int def) { return IupConfigGetVariableIntDef(ih, group, key, def); }
    double GetVariableDoubleDef(const char* group, const char* key, double def) { return IupConfigGetVariableDoubleDef(ih, group, key, def); }
    char* GetVariableStrIdDef(const char* group, const char* key, int id, const char* def) { return (char*)IupConfigGetVariableStrIdDef(ih, group, key, id, def); }
    int GetVariableIntIdDef(const char* group, const char* key, int id, int def) { return IupConfigGetVariableIntIdDef(ih, group, key, id, def); }
    double GetVariableDoubleIdDef(const char* group, const char* key, int id, double def) { return IupConfigGetVariableDoubleIdDef(ih, group, key, id, def); }

    void RecentInit(Ihandle* menu, Icallback recent_cb, int max_recent) { IupConfigRecentInit(ih, menu, recent_cb, max_recent); }
    void RecentUpdate(const char* filename) { IupConfigRecentUpdate(ih, filename); }

    void DialogShow(Ihandle* dialog, const char* name) { IupConfigDialogShow(ih, dialog, name); }
    void DialogClosed(Ihandle* dialog, const char* name) { IupConfigDialogClosed(ih, dialog, name); }
  };
}

#ifdef __CD_PLUS_H
namespace cd
{
  class CanvasIup : public Canvas
  {
  public:
    CanvasIup(iup::Canvas& iup_canvas)
      : Canvas() { canvas = cdCreateCanvas(CD_IUP, iup_canvas.GetHandle()); }
  };
  class CanvasIupDoubleBuffer : public Canvas
  {
  public:
    CanvasIupDoubleBuffer(iup::Canvas& iup_canvas)
      : Canvas() { canvas = cdCreateCanvas(CD_IUPDBUFFER, iup_canvas.GetHandle()); }
  };
  class CanvasIupDoubleBufferRGB : public Canvas
  {
  public:
    CanvasIupDoubleBufferRGB(iup::Canvas& iup_canvas)
      : Canvas() { canvas = cdCreateCanvas(CD_IUPDBUFFERRGB, iup_canvas.GetHandle()); }
  };
}
#endif

#endif



================================================
File: iup/include/iup_scintilla.h
================================================
/** \file
 * \brief Scintilla control.
 *
 * See Copyright Notice in "iup.h"
 */
 
#ifndef __IUP_SCINTILLA_H 
#define __IUP_SCINTILLA_H

#ifdef __cplusplus
extern "C" {
#endif


void IupScintillaOpen(void);

Ihandle *IupScintilla(void);

#ifdef SCINTILLA_H
sptr_t IupScintillaSendMessage(Ihandle* ih, unsigned int iMessage, uptr_t wParam, sptr_t lParam);
#endif


#ifdef __cplusplus
}
#endif

#endif



================================================
File: iup/include/iupcbs.h
================================================
/** \file
 * \brief Contains all function pointer typedefs.
 *
 * See Copyright Notice in "iup.h"
 */
 
#ifndef __IUPCBS_H 
#define __IUPCBS_H

struct _cdCanvas;

typedef int (*IFidle)(void);  /* idle */

typedef void(*IFi)(int); /* globalentermodal_cb, globalleavemodal_cb,  */
typedef void(*IFii)(int, int); /* globalkeypress_cb */
typedef void (*IFiis)(int, int, char*);  /* globalmotion_cb */
typedef void (*IFiiiis)(int, int, int, int, char*);  /* globalbutton_cb */
typedef void (*IFfiis)(float,int,int,char*);  /* globalwheel_cb */

typedef int (*IFn)(Ihandle*);  /* default definition, same as Icallback */
typedef int (*IFni)(Ihandle*, int);   /* k_any, show_cb, toggle_action, spin_cb, branchopen_cb, branchclose_cb, executeleaf_cb, showrename_cb, rightclick_cb, extended_cb, height_cb, width_cb */
typedef int (*IFnii)(Ihandle*, int, int);  /* resize_cb, caret_cb, matrix_mousemove_cb, enteritem_cb, leaveitem_cb, scrolltop_cb, dropcheck_cb, selection_cb, select_cb, switch_cb, scrolling_cb, vspan_cb, hspan_cb */
typedef int (*IFniii)(Ihandle*, int, int, int); /* trayclick_cb, edition_cb */
typedef int (*IFniiii)(Ihandle*, int, int, int, int); /* dragdrop_cb */
typedef int(*IFniiiiiiC)(Ihandle*, int, int, int, int, int, int, struct _cdCanvas*);  /* draw_cb */
typedef int (*IFniiiiii)(Ihandle*, int, int, int, int, int, int);  /* OLD draw_cb */

typedef int (*IFnff)(Ihandle*, float, float);    /* canvas_action, plotmotion_cb (pplot) */
typedef int (*IFniff)(Ihandle*,int,float,float);  /* scroll_cb */
typedef int (*IFnfiis)(Ihandle*,float,int,int,char*);  /* wheel_cb */

typedef int (*IFnsVi)(Ihandle*, char*, void*, int);  /* dragdata_cb */
typedef int (*IFnsViii)(Ihandle*, char*, void*, int, int, int);  /* dropdata_cb */
typedef int (*IFnsiii)(Ihandle*, char*, int, int, int);  /* dropfiles_cb */

typedef int (*IFnnii)(Ihandle*, Ihandle*, int, int); /* drop_cb */
typedef int (*IFnnn)(Ihandle*, Ihandle*, Ihandle*); /* tabchange_cb */
typedef int (*IFnss)(Ihandle*, char *, char *);  /* file_cb */
typedef int (*IFns)(Ihandle*, char *);  /* multiselect_cb */
typedef int (*IFnsi)(Ihandle*, char *, int);  /* copydata_cb */
typedef int (*IFnis)(Ihandle*, int, char *);  /* text_action, multiline_action, edit_cb, rename_cb */
typedef int (*IFnsii)(Ihandle*, char*, int, int);  /* list_action */
typedef int (*IFniis)(Ihandle*, int, int, char*);  /* motion_cb, click_cb, value_edit_cb */
typedef int (*IFniiis)(Ihandle*, int, int, int, char*);  /* touch_cb, dblclick_cb */
typedef int (*IFniiiis)(Ihandle*, int, int, int, int, char*);  /* button_cb, matrix_action, mousemotion_cb */
typedef int (*IFniiiiiis)(Ihandle*, int, int, int, int, int, int, char*);  /* mouseclick_cb */

typedef int (*IFnIi)(Ihandle*, int*, int); /* multiselection_cb, multiunselection_cb */
typedef int (*IFnd)(Ihandle*, double);  /* mousemove_cb, button_press_cb, button_release_cb */
typedef int (*IFniiIII)(Ihandle*, int, int, int*, int*, int*); /* fgcolor_cb, bgcolor_cb */
typedef int (*IFniinsii)(Ihandle*, int, int, Ihandle*, char*, int, int); /* dropselect_cb */
typedef int (*IFnccc)(Ihandle*, unsigned char, unsigned char, unsigned char); /* drag_cb, change_cb */
typedef int (*IFniIIII)(Ihandle*, int, int*, int*, int*, int*); /* multitouch_cb */

typedef int (*IFnC)(Ihandle*, struct _cdCanvas*); /* postdraw_cb, predraw_cb */
typedef int (*IFniiff)(Ihandle*, int, int, float, float); /* delete_cb (pplot) */
typedef int (*IFniiffi)(Ihandle*, int, int, float, float, int); /* select_cb (pplot) */
typedef int (*IFniidd)(Ihandle*, int, int, double, double); /* delete_cb */
typedef int (*IFniiddi)(Ihandle*, int, int, double, double, int); /* select_cb */
typedef int (*IFniiffFF)(Ihandle*, int, int, float, float, float*, float*); /* edit_cb */
typedef int (*IFniiffs)(Ihandle*, int, int, float, float, char*);  /* plotbutton_cb (pplot) */
typedef int (*IFniidds)(Ihandle*, int, int, double, double, char*);  /* plotbutton_cb */
typedef int (*IFndds)(Ihandle*, double, double, char*);    /* plotmotion_cb */

typedef char* (*sIFnii)(Ihandle*, int, int);  /* value_cb, font_cb */
typedef char* (*sIFni)(Ihandle*, int);  /* cell_cb */
typedef char* (*sIFniis)(Ihandle*, int, int, char*);  /* translatevalue_cb */

typedef double (*dIFnii)(Ihandle*, int, int);  /* numericgetvalue_cb */
typedef int    (*IFniid)(Ihandle*, int, int, double);  /* numericsetvalue_cb */

#endif



================================================
File: iup/include/iupcontrols.h
================================================
/** \file
 * \brief initializes dial, gauge, colorbrowser, colorbar controls.
 *
 * See Copyright Notice in "iup.h"
 */
 
#ifndef __IUPCONTROLS_H 
#define __IUPCONTROLS_H

#ifdef __cplusplus
extern "C" {
#endif


int  IupControlsOpen(void);

Ihandle* IupColorbar(void);
Ihandle* IupCells(void);
Ihandle *IupColorBrowser(void);
Ihandle *IupGauge(void);
Ihandle *IupDial(const char* type);
Ihandle* IupMatrix(const char *action);
Ihandle* IupMatrixList(void);

/* Used by IupColorbar */
#define IUP_PRIMARY -1
#define IUP_SECONDARY -2

/* available only when linking with "iupluamatrix" */
void IupMatrixSetFormula(Ihandle* ih, int col, const char* formula, const char* init);
void IupMatrixSetDynamic(Ihandle* ih, const char* init);


#ifdef __cplusplus
}
#endif

#endif



================================================
File: iup/include/iupdef.h
================================================
/** \file
 * \brief Callbacks, Attributes and Attribute Values definitions.    
 * Avoid using these definitions. Use the strings instead.
 *
 * See Copyright Notice in iup.h
 */
 
#ifndef __IUPDEF_H 
#define __IUPDEF_H

/* ATTENTION: these are OLD definitions and they are NOT updated anymore since IUP 3.0 */
/* Avoid using them, directly use the strings instead. */
/* Define __IUPDEF_H to avoid the inclusion of this header */

#define IUP_RUN            "RUN"
#define IUP_ENGLISH        "ENGLISH"
#define IUP_PORTUGUESE     "PORTUGUESE"
#define IUP_SBH            "SBH"
#define IUP_SBV            "SBV"

/************************************************************************/
/*                            Callbacks                                 */
/************************************************************************/

#define IUP_IDLE_ACTION    "IDLE_ACTION"

#define IUP_ACTION         "ACTION"
#define IUP_GETFOCUS_CB    "GETFOCUS_CB"
#define IUP_KILLFOCUS_CB   "KILLFOCUS_CB"
#define IUP_K_ANY          "K_ANY"
#define IUP_KEYPRESS_CB    "KEYPRESS_CB"
#define IUP_HELP_CB        "HELP_CB"

#define IUP_SCROLL_CB      "SCROLL_CB"
#define IUP_RESIZE_CB      "RESIZE_CB"
#define IUP_MOTION_CB      "MOTION_CB"
#define IUP_BUTTON_CB      "BUTTON_CB"
#define IUP_ENTERWINDOW_CB "ENTERWINDOW_CB"
#define IUP_LEAVEWINDOW_CB "LEAVEWINDOW_CB"
#define IUP_WHEEL_CB       "WHEEL_CB"

#define IUP_MASK_CB        "MASK_CB"
#define IUP_OPEN_CB        "OPEN_CB"
#define IUP_HIGHLIGHT_CB   "HIGHLIGHT_CB"
#define IUP_MENUCLOSE_CB   "MENUCLOSE_CB"

#define IUP_MAP_CB         "MAP_CB"
#define IUP_CLOSE_CB       "CLOSE_CB"
#define IUP_SHOW_CB        "SHOW_CB"

#define IUP_DROPFILES_CB   "DROPFILES_CB"
#define IUP_WOM_CB         "WOM_CB"

/************************************************************************/
/*                            Attributes                                */
/************************************************************************/

#define IUP_DIRECTION      "DIRECTION"
#define IUP_ACTIVE         "ACTIVE"
#define IUP_BGCOLOR        "BGCOLOR"
#define IUP_FRAMECOLOR     "FRAMECOLOR"
#define IUP_FGCOLOR        "FGCOLOR"
#define IUP_COLOR          "COLOR"
#define IUP_WID            "WID"
#define IUP_SIZE           "SIZE"
#define IUP_RASTERSIZE     "RASTERSIZE"
#define IUP_TITLE          "TITLE"
#define IUP_VALUE          "VALUE"
#define IUP_VISIBLE        "VISIBLE"
#define IUP_FONT           "FONT"
#define IUP_TIP            "TIP"
#define IUP_EXPAND         "EXPAND"
#define IUP_SEPARATOR      "SEPARATOR"

#define IUP_HOTSPOT        "HOTSPOT"
#define IUP_HEIGHT         "HEIGHT"
#define IUP_WIDTH          "WIDTH"

#define IUP_KEY            "KEY"

#define IUP_MULTIPLE       "MULTIPLE"
#define IUP_DROPDOWN       "DROPDOWN"
#define IUP_VISIBLE_ITEMS  "VISIBLE_ITEMS"

#define IUP_MARGIN         "MARGIN"
#define IUP_GAP            "GAP"
#define IUP_ALIGNMENT      "ALIGNMENT"

#define IUP_IMAGE          "IMAGE"
#define IUP_IMINACTIVE     "IMINACTIVE"
#define IUP_IMPRESS        "IMPRESS"
#define IUP_WIN_SAVEBITS   "WIN_SAVEBITS"

#define IUP_NC             "NC"
#define IUP_MASK           "MASK"

#define IUP_APPEND         "APPEND"
#define IUP_BORDER         "BORDER"

#define IUP_CARET          "CARET"
#define IUP_SELECTION      "SELECTION"
#define IUP_SELECTEDTEXT   "SELECTEDTEXT"
#define IUP_INSERT         "INSERT"

#define IUP_CONID          "CONID"
#define IUP_CURSOR         "CURSOR"

#define IUP_ICON           "ICON"
#define IUP_MENUBOX        "MENUBOX"
#define IUP_MINBOX         "MINBOX"
#define IUP_MAXBOX         "MAXBOX"
#define IUP_RESIZE         "RESIZE"
#define IUP_MENU           "MENU"
#define IUP_STARTFOCUS     "STARTFOCUS"
#define IUP_PARENTDIALOG   "PARENTDIALOG"
#define IUP_SHRINK         "SHRINK"
#define IUP_DEFAULTENTER   "DEFAULTENTER"
#define IUP_DEFAULTESC     "DEFAULTESC"
#define IUP_X              "X"
#define IUP_Y              "Y"
#define IUP_TOOLBOX        "TOOLBOX"
#define IUP_CONTROL        "CONTROL"
#define IUP_READONLY       "READONLY"

#define IUP_SCROLLBAR      "SCROLLBAR"
#define IUP_POSY           "POSY"
#define IUP_POSX           "POSX"
#define IUP_DX             "DX"
#define IUP_DY             "DY"
#define IUP_XMAX           "XMAX"
#define IUP_XMIN           "XMIN"
#define IUP_YMAX           "YMAX"
#define IUP_YMIN           "YMIN"

#define IUP_RED            "255 0 0"
#define IUP_GREEN          "0 255 0"
#define IUP_BLUE           "0 0 255"

#define IUP_MIN            "MIN"
#define IUP_MAX            "MAX"

#define IUP_TIME           "TIME"
#define IUP_DRAG           "DRAG"
#define IUP_DROP           "DROP"
#define IUP_REPAINT        "REPAINT"
#define IUP_TOPMOST        "TOPMOST"
#define IUP_CLIPCHILDREN   "CLIPCHILDREN"

#define IUP_DIALOGTYPE     "DIALOGTYPE"
#define IUP_FILE           "FILE"
#define IUP_MULTIPLEFILES  "MULTIPLEFILES"
#define IUP_FILTER         "FILTER"
#define IUP_FILTERUSED     "FILTERUSED"
#define IUP_FILTERINFO     "FILTERINFO"
#define IUP_EXTFILTER      "EXTFILTER"
#define IUP_DIRECTORY      "DIRECTORY"
#define IUP_ALLOWNEW       "ALLOWNEW"
#define IUP_NOOVERWRITEPROMPT "NOOVERWRITEPROMPT"
#define IUP_NOCHANGEDIR    "NOCHANGEDIR"
#define IUP_FILEEXIST      "FILEEXIST"
#define IUP_STATUS         "STATUS"

#define IUP_LOCKLOOP       "LOCKLOOP"
#define IUP_SYSTEM         "SYSTEM"
#define IUP_DRIVER         "DRIVER"
#define IUP_SCREENSIZE     "SCREENSIZE"
#define IUP_SYSTEMLANGUAGE "SYSTEMLANGUAGE"
#define IUP_COMPUTERNAME   "COMPUTERNAME"
#define IUP_USERNAME       "USERNAME"

#define IUP_OPEN "OPEN"
#define IUP_SAVE "SAVE"
#define IUP_DIR  "DIR"

#define IUP_HORIZONTAL     "HORIZONTAL"
#define IUP_VERTICAL       "VERTICAL"

/************************************************************************/
/*                       Attribute Values                               */
/************************************************************************/

#define IUP_YES       "YES"
#define IUP_NO        "NO"
#define IUP_ON        "ON"
#define IUP_OFF       "OFF"

#define IUP_ACENTER   "ACENTER"
#define IUP_ALEFT     "ALEFT"
#define IUP_ARIGHT    "ARIGHT"
#define IUP_ATOP      "ATOP"
#define IUP_ABOTTOM   "ABOTTOM"

#define IUP_NORTH     "NORTH"
#define IUP_SOUTH     "SOUTH"
#define IUP_WEST      "WEST"
#define IUP_EAST      "EAST"
#define IUP_NE        "NE"
#define IUP_SE        "SE"
#define IUP_NW        "NW"
#define IUP_SW        "SW"

#define IUP_FULLSCREEN "FULLSCREEN"
#define IUP_FULL      "FULL"
#define IUP_HALF      "HALF"
#define IUP_THIRD     "THIRD"
#define IUP_QUARTER   "QUARTER"
#define IUP_EIGHTH    "EIGHTH"

#define IUP_ARROW     "ARROW"
#define IUP_BUSY      "BUSY"
#define IUP_RESIZE_N  "RESIZE_N"
#define IUP_RESIZE_S  "RESIZE_S"
#define IUP_RESIZE_E  "RESIZE_E"
#define IUP_RESIZE_W  "RESIZE_W"
#define IUP_RESIZE_NE "RESIZE_NE"
#define IUP_RESIZE_NW "RESIZE_NW"
#define IUP_RESIZE_SE "RESIZE_SE"
#define IUP_RESIZE_SW "RESIZE_SW"
#define IUP_MOVE      "MOVE"
#define IUP_HAND      "HAND"
#define IUP_NONE      "NONE"
#define IUP_IUP       "IUP"
#define IUP_CROSS     "CROSS"
#define IUP_PEN       "PEN"
#define IUP_TEXT      "TEXT"
#define IUP_RESIZE_C  "RESIZE_C"
#define IUP_OPENHAND  "OPENHAND"

/************************************************************************/
/*                           Keys                                       */
/************************************************************************/

#define IUP_K_exclam            "K_exclam"
#define IUP_K_quotedbl          "K_quotedbl"
#define IUP_K_numbersign        "K_numbersign"
#define IUP_K_dollar            "K_dollar"
#define IUP_K_percent           "K_percent"
#define IUP_K_ampersand         "K_ampersand"
#define IUP_K_quoteright        "K_quoteright"
#define IUP_K_parentleft        "K_parentleft"
#define IUP_K_parentright       "K_parentright"
#define IUP_K_asterisk          "K_asterisk"
#define IUP_K_plus              "K_plus"
#define IUP_K_comma             "K_comma"
#define IUP_K_minus             "K_minus"
#define IUP_K_period            "K_period"
#define IUP_K_slash             "K_slash"
#define IUP_K_0                 "K_0"
#define IUP_K_1                 "K_1"
#define IUP_K_2                 "K_2"
#define IUP_K_3                 "K_3"
#define IUP_K_4                 "K_4"
#define IUP_K_5                 "K_5"
#define IUP_K_6                 "K_6"
#define IUP_K_7                 "K_7"
#define IUP_K_8                 "K_8"
#define IUP_K_9                 "K_9"
#define IUP_K_colon             "K_colon"
#define IUP_K_semicolon         "K_semicolon "
#define IUP_K_less              "K_less"
#define IUP_K_equal             "K_equal"
#define IUP_K_greater           "K_greater"
#define IUP_K_question          "K_question"
#define IUP_K_at                "K_at"
#define IUP_K_A                 "K_A"
#define IUP_K_B                 "K_B"
#define IUP_K_C                 "K_C"
#define IUP_K_D                 "K_D"
#define IUP_K_E                 "K_E"
#define IUP_K_F                 "K_F"
#define IUP_K_G                 "K_G"
#define IUP_K_H                 "K_H"
#define IUP_K_I                 "K_I"
#define IUP_K_J                 "K_J"
#define IUP_K_K                 "K_K"
#define IUP_K_L                 "K_L"
#define IUP_K_M                 "K_M"
#define IUP_K_N                 "K_N"
#define IUP_K_O                 "K_O"
#define IUP_K_P                 "K_P"
#define IUP_K_Q                 "K_Q"
#define IUP_K_R                 "K_R"
#define IUP_K_S                 "K_S"
#define IUP_K_T                 "K_T"
#define IUP_K_U                 "K_U"
#define IUP_K_V                 "K_V"
#define IUP_K_W                 "K_W"
#define IUP_K_X                 "K_X"
#define IUP_K_Y                 "K_Y"
#define IUP_K_Z                 "K_Z"
#define IUP_K_bracketleft       "K_bracketleft"
#define IUP_K_backslash         "K_backslash"
#define IUP_K_bracketright      "K_bracketright"
#define IUP_K_circum            "K_circum"
#define IUP_K_underscore        "K_underscore"
#define IUP_K_quoteleft         "K_quoteleft"
#define IUP_K_a                 "K_a"
#define IUP_K_b                 "K_b"
#define IUP_K_c                 "K_c"
#define IUP_K_d                 "K_d"
#define IUP_K_e                 "K_e"
#define IUP_K_f                 "K_f"
#define IUP_K_g                 "K_g"
#define IUP_K_h                 "K_h"
#define IUP_K_i                 "K_i"
#define IUP_K_j                 "K_j"
#define IUP_K_k                 "K_k"
#define IUP_K_l                 "K_l"
#define IUP_K_m                 "K_m"
#define IUP_K_n                 "K_n"
#define IUP_K_o                 "K_o"
#define IUP_K_p                 "K_p"
#define IUP_K_q                 "K_q"
#define IUP_K_r                 "K_r"
#define IUP_K_s                 "K_s"
#define IUP_K_t                 "K_t"
#define IUP_K_u                 "K_u"
#define IUP_K_v                 "K_v"
#define IUP_K_w                 "K_w"
#define IUP_K_x                 "K_x"
#define IUP_K_y                 "K_y"
#define IUP_K_z                 "K_z"
#define IUP_K_braceleft         "K_braceleft"
#define IUP_K_bar               "K_bar"
#define IUP_K_braceright        "K_braceright"
#define IUP_K_tilde             "K_tilde"

#define IUP_K_cA       "K_cA"
#define IUP_K_cB       "K_cB"
#define IUP_K_cC       "K_cC"
#define IUP_K_cD       "K_cD"
#define IUP_K_cE       "K_cE"
#define IUP_K_cF       "K_cF"
#define IUP_K_cG       "K_cG"
#define IUP_K_cJ       "K_cJ"
#define IUP_K_cK       "K_cK"
#define IUP_K_cL       "K_cL"
#define IUP_K_cN       "K_cN"
#define IUP_K_cO       "K_cO"
#define IUP_K_cP       "K_cP"
#define IUP_K_cQ       "K_cQ"
#define IUP_K_cR       "K_cR"
#define IUP_K_cS       "K_cS"
#define IUP_K_cT       "K_cT"
#define IUP_K_cU       "K_cU"
#define IUP_K_cV       "K_cV"
#define IUP_K_cW       "K_cW"
#define IUP_K_cX       "K_cX"
#define IUP_K_cY       "K_cY"
#define IUP_K_cZ       "K_cZ"
#define IUP_K_mA       "K_mA"
#define IUP_K_mB       "K_mB"
#define IUP_K_mC       "K_mC"
#define IUP_K_mD       "K_mD"
#define IUP_K_mE       "K_mE"
#define IUP_K_mF       "K_mF"
#define IUP_K_mG       "K_mG"
#define IUP_K_mH       "K_mH"
#define IUP_K_mI       "K_mI"
#define IUP_K_mJ       "K_mJ"
#define IUP_K_mK       "K_mK"
#define IUP_K_mL       "K_mL"
#define IUP_K_mM       "K_mM"
#define IUP_K_mN       "K_mN"
#define IUP_K_mO       "K_mO"
#define IUP_K_mP       "K_mP"
#define IUP_K_mQ       "K_mQ"
#define IUP_K_mR       "K_mR"
#define IUP_K_mS       "K_mS"
#define IUP_K_mT       "K_mT"
#define IUP_K_mU       "K_mU"
#define IUP_K_mV       "K_mV"
#define IUP_K_mW       "K_mW"
#define IUP_K_mX       "K_mX"
#define IUP_K_mY       "K_mY"
#define IUP_K_mZ       "K_mZ"
#define IUP_K_BS       "K_BS"
#define IUP_K_TAB      "K_TAB"
#define IUP_K_CR       "K_CR"
#define IUP_K_SP       "K_SP"
#define IUP_K_ESC      "K_ESC"
#define IUP_K_sCR      "K_sCR"
#define IUP_K_sTAB     "K_sTAB"
#define IUP_K_cTAB     "K_cTAB"
#define IUP_K_mTAB     "K_mTAB"
#define IUP_K_HOME     "K_HOME"
#define IUP_K_UP       "K_UP"
#define IUP_K_PGUP     "K_PGUP"
#define IUP_K_LEFT     "K_LEFT"
#define IUP_K_RIGHT    "K_RIGHT"
#define IUP_K_END      "K_END"
#define IUP_K_DOWN     "K_DOWN"
#define IUP_K_PGDN     "K_PGDN"
#define IUP_K_MIDDLE   "K_MIDDLE"
#define IUP_K_INS      "K_INS"
#define IUP_K_DEL      "K_DEL"
#define IUP_K_sHOME    "K_sHOME"
#define IUP_K_sUP      "K_sUP"
#define IUP_K_sPGUP    "K_sPGUP"
#define IUP_K_sLEFT    "K_sLEFT"
#define IUP_K_sRIGHT   "K_sRIGHT"
#define IUP_K_sEND     "K_sEND"
#define IUP_K_sDOWN    "K_sDOWN"
#define IUP_K_sPGDN    "K_sPGDN"
#define IUP_K_cHOME    "K_cHOME"
#define IUP_K_cPGUP    "K_cPGUP"
#define IUP_K_cLEFT    "K_cLEFT"
#define IUP_K_cRIGHT   "K_cRIGHT"
#define IUP_K_cEND     "K_cEND"
#define IUP_K_cPGDN    "K_cPGDN"
#define IUP_K_cUP      "K_cUP"
#define IUP_K_cDOWN    "K_cDOWN"
#define IUP_K_cMIDDLE  "K_cMIDDLE"
#define IUP_K_cINS     "K_cINS"
#define IUP_K_cDEL     "K_cDEL"
#define IUP_K_mHOME    "K_mHOME"
#define IUP_K_mPGUP    "K_mPGUP"
#define IUP_K_mLEFT    "K_mLEFT"
#define IUP_K_mRIGHT   "K_mRIGHT"
#define IUP_K_mEND     "K_mEND"
#define IUP_K_mPGDN    "K_mPGDN"
#define IUP_K_mUP      "K_mUP"
#define IUP_K_mDOWN    "K_mDOWN"
#define IUP_K_mINS     "K_mINS"
#define IUP_K_mDEL     "K_mDEL"
#define IUP_K_F1       "K_F1"
#define IUP_K_F2       "K_F2"
#define IUP_K_F3       "K_F3"
#define IUP_K_F4       "K_F4"
#define IUP_K_F5       "K_F5"
#define IUP_K_F6       "K_F6"
#define IUP_K_F7       "K_F7"
#define IUP_K_F8       "K_F8"
#define IUP_K_F9       "K_F9"
#define IUP_K_F10      "K_F10"
#define IUP_K_F11      "K_F11"
#define IUP_K_F12      "K_F12"
#define IUP_K_sF1      "K_sF1"
#define IUP_K_sF2      "K_sF2"
#define IUP_K_sF3      "K_sF3"
#define IUP_K_sF4      "K_sF4"
#define IUP_K_sF5      "K_sF5"
#define IUP_K_sF6      "K_sF6"
#define IUP_K_sF7      "K_sF7"
#define IUP_K_sF8      "K_sF8"
#define IUP_K_sF9      "K_sF9"
#define IUP_K_sF10     "K_sF10"
#define IUP_K_sF11     "K_sF11"
#define IUP_K_sF12     "K_sF12"
#define IUP_K_cF1      "K_cF1"
#define IUP_K_cF2      "K_cF2"
#define IUP_K_cF3      "K_cF3"
#define IUP_K_cF4      "K_cF4"
#define IUP_K_cF5      "K_cF5"
#define IUP_K_cF6      "K_cF6"
#define IUP_K_cF7      "K_cF7"
#define IUP_K_cF8      "K_cF8"
#define IUP_K_cF9      "K_cF9"
#define IUP_K_cF10     "K_cF10"
#define IUP_K_cF11     "K_cF11"
#define IUP_K_cF12     "K_cF12"
#define IUP_K_mF1      "K_mF1"
#define IUP_K_mF2      "K_mF2"
#define IUP_K_mF3      "K_mF3"
#define IUP_K_mF4      "K_mF4"
#define IUP_K_mF5      "K_mF5"
#define IUP_K_mF6      "K_mF6"
#define IUP_K_mF7      "K_mF7"
#define IUP_K_mF8      "K_mF8"
#define IUP_K_mF9      "K_mF9"
#define IUP_K_mF10     "K_mF10"
#define IUP_K_m1       "K_m1"
#define IUP_K_m2       "K_m2"
#define IUP_K_m3       "K_m3"
#define IUP_K_m4       "K_m4"
#define IUP_K_m5       "K_m5"
#define IUP_K_m6       "K_m6"
#define IUP_K_m7       "K_m7"
#define IUP_K_m8       "K_m8"
#define IUP_K_m9       "K_m9"
#define IUP_K_m0       "K_m0"

/************/
/* Colorbar */
/************/

#define IUP_NUM_PARTS  "NUM_PARTS"
#define IUP_NUM_CELLS "NUM_CELLS"
#define IUP_CELL "CELL"
#define IUP_PREVIEW_SIZE "PREVIEW_SIZE"
#define IUP_SHOW_PREVIEW "SHOW_PREVIEW"
#define IUP_SHOW_SECONDARY "SHOW_SECONDARY"
#define IUP_PRIMARY_CELL "PRIMARY_CELL"
#define IUP_SECONDARY_CELL "SECONDARY_CELL"
#define IUP_ORIENTATION  "ORIENTATION"
#define IUP_SQUARED  "SQUARED"
#define IUP_SHADOWED  "SHADOWED"
#define IUP_BUFFERIZE  "BUFFERIZE"
#define IUP_TRANSPARENCY  "TRANSPARENCY"
#define IUP_CELL_CB "CELL_CB"
#define IUP_EXTENDED_CB "EXTENDED_CB"
#define IUP_SELECT_CB "SELECT_CB"
#define IUP_SWITCH_CB "SWITCH_CB"
#define IUP_VERTICAL    "VERTICAL"
#define IUP_HORIZONTAL  "HORIZONTAL"

/************/
/* Cells    */
/************/

#define IUP_ALL  "ALL"
#define IUP_BOXED  "BOXED"
#define IUP_CLIPPED  "CLIPPED"
#define IUP_TRANSPARENT  "TRANSPARENT"
#define IUP_NON_SCROLLABLE_LINES  "NON_SCROLLABLE_LINES"
#define IUP_NON_SCROLLABLE_COLS  "NON_SCROLLABLE_COLS"
#define IUP_ORIGIN  "ORIGIN"
#define IUP_NO_COLOR  "NO_COLOR"
#define IUP_FIRST_LINE  "FIRST_LINE"
#define IUP_FIRST_COL  "FIRST_COL"
#define IUP_DOUBLE_BUFFER  "DOUBLE_BUFFER"
#define IUP_LIMITS  "LIMITS"
#define IUP_CANVAS  "CANVAS"
#define IUP_IMAGE_CANVAS  "IMAGE_CANVAS"
#define IUP_FULL_VISIBLE  "FULL_VISIBLE"
#define IUP_MOUSECLICK_CB "MOUSECLICK_CB"
#define IUP_MOUSEMOTION_CB "MOUSEMOTION_CB"
#define IUP_DRAW_CB "DRAW_CB"
#define IUP_WIDTH_CB "WIDTH_CB"
#define IUP_HEIGHT_CB "HEIGHT_CB"
#define IUP_NLINES_CB "NLINES_CB"
#define IUP_NCOLS_CB "NCOLS_CB"
#define IUP_HSPAN_CB "HSPAN_CB"
#define IUP_VSPAN_CB "VSPAN_CB"
#define IUP_SCROLLING_CB "SCROLLING_CB"

/*****************/
/* ColorBrowser  */
/*****************/

#define IUP_RGB "RGB"
#define IUP_CHANGE_CB "CHANGE_CB"
#define IUP_DRAG_CB "DRAG_CB"

/*****************/
/* Val           */
/*****************/

#define ICTL_MOUSEMOVE_CB "MOUSEMOVE_CB"
#define ICTL_BUTTON_PRESS_CB "BUTTON_PRESS_CB"
#define ICTL_BUTTON_RELEASE_CB "BUTTON_RELEASE_CB"
#define ICTL_HORIZONTAL "HORIZONTAL"
#define ICTL_VERTICAL "VERTICAL"
#define ICTL_SHOWTICKS "SHOWTICKS"

/*****************/
/* Tabs          */
/*****************/

#define ICTL_TOP "TOP"
#define ICTL_BOTTOM "BOTTOM"
#define ICTL_LEFT "LEFT"
#define ICTL_RIGHT "RIGHT"
#define ICTL_TABTYPE "TABTYPE"
#define ICTL_TABTITLE "TABTITLE"
#define ICTL_TABSIZE "TABSIZE"
#define ICTL_TABCHANGE_CB "TABCHANGE_CB"
#define ICTL_FONT "FONT"
#define ICTL_FONT_ACTIVE "FONT_ACTIVE"
#define ICTL_FONT_INACTIVE "FONT_INACTIVE"

/*****************/
/* Gauge         */
/*****************/

#define ICTL_SHOW_TEXT "SHOW_TEXT"
#define ICTL_DASHED "DASHED"
#define ICTL_MARGIN "MARGIN"
#define ICTL_TEXT "TEXT"

/*****************/
/* Dial          */
/*****************/

#define ICTL_DENSITY "DENSITY"
#define ICTL_HORIZONTAL "HORIZONTAL"
#define ICTL_VERTICAL "VERTICAL"
#define ICTL_CIRCULAR "CIRCULAR"
#define ICTL_UNIT "UNIT"

/*****************/
/* Matrix        */
/*****************/

#define IUP_ENTERITEM_CB   "ENTERITEM_CB"
#define IUP_LEAVEITEM_CB   "LEAVEITEM_CB"
#define IUP_EDITION_CB     "EDITION_CB"
#define IUP_CLICK_CB       "CLICK_CB"
#define IUP_DROP_CB        "DROP_CB"
#define IUP_DROPSELECT_CB  "DROPSELECT_CB"
#define IUP_DROPCHECK_CB   "DROPCHECK_CB"
#define IUP_SCROLL_CB      "SCROLL_CB"
#define IUP_VALUE_CB       "VALUE_CB"
#define IUP_VALUE_EDIT_CB  "VALUE_EDIT_CB"
#define IUP_FIELD_CB       "FIELD_CB"
#define IUP_RESIZEMATRIX   "RESIZEMATRIX"
#define IUP_ADDLIN         "ADDLIN"
#define IUP_ADDCOL         "ADDCOL"
#define IUP_DELLIN         "DELLIN"
#define IUP_DELCOL         "DELCOL"
#define IUP_NUMLIN         "NUMLIN"
#define IUP_NUMCOL         "NUMCOL"
#define IUP_NUMLIN_VISIBLE "NUMLIN_VISIBLE"
#define IUP_NUMCOL_VISIBLE "NUMCOL_VISIBLE"
#define IUP_MARKED         "MARKED"
#define IUP_WIDTHDEF       "WIDTHDEF"
#define IUP_HEIGHTDEF      "HEIGHTDEF"
#define IUP_AREA           "AREA"
#define IUP_MARK_MODE      "MARK_MODE"
#define IUP_LIN            "LIN"
#define IUP_COL            "COL"
#define IUP_LINCOL         "LINCOL"
#define IUP_CELL           "CELL"
#define IUP_EDIT_MODE      "EDIT_MODE"
#define IUP_FOCUS_CELL     "FOCUS_CELL"
#define IUP_ORIGIN         "ORIGIN"
#define IUP_REDRAW         "REDRAW"
#define IUP_PREVIOUSVALUE  "PREVIOUSVALUE"
#define IUP_MOUSEMOVE_CB   "MOUSEMOVE_CB"

/*****************/
/* Tree          */
/*****************/

#define IUP_ADDLEAF          "ADDLEAF"
#define IUP_ADDBRANCH        "ADDBRANCH"
#define IUP_DELNODE          "DELNODE"
#define IUP_IMAGELEAF        "IMAGELEAF"
#define IUP_IMAGEBRANCHCOLLAPSED "IMAGEBRANCHCOLLAPSED"
#define IUP_IMAGEBRANCHEXPANDED  "IMAGEBRANCHEXPANDED"
#define IUP_IMAGEEXPANDED     "IMAGEEXPANDED"
#define IUP_KIND             "KIND"
#define IUP_PARENT           "PARENT"
#define IUP_DEPTH            "DEPTH"
#define IUP_MARKED           "MARKED"
#define IUP_ADDEXPANDED      "ADDEXPANDED"
#define IUP_CTRL             "CTRL"
#define IUP_SHIFT            "SHIFT"
#define IUP_STATE            "STATE"
#define IUP_STARTING         "STARTING"
#define IUP_LEAF             "LEAF"
#define IUP_BRANCH           "BRANCH"
#define IUP_SELECTED         "SELECTED"
#define IUP_CHILDREN         "CHILDREN"
#define IUP_MARKED           "MARKED"
#define IUP_ROOT             "ROOT"
#define IUP_LAST             "LAST"
#define IUP_PGUP             "PGUP"
#define IUP_PGDN             "PGDN"
#define IUP_NEXT             "NEXT"
#define IUP_PREVIOUS         "PREVIOUS"
#define IUP_INVERT           "INVERT"
#define IUP_BLOCK            "BLOCK"
#define IUP_CLEARALL         "CLEARALL"
#define IUP_MARKALL          "MARKALL"
#define IUP_INVERTALL        "INVERTALL"
#define IUP_REDRAW           "REDRAW"
#define IUP_COLLAPSED        "COLLAPSED"
#define IUP_EXPANDED         "EXPANDED"
#define IUP_SELECTION_CB "SELECTION_CB"
#define IUP_BRANCHOPEN_CB    "BRANCHOPEN_CB"
#define IUP_BRANCHCLOSE_CB   "BRANCHCLOSE_CB"
#define IUP_RIGHTCLICK_CB    "RIGHTCLICK_CB"
#define IUP_EXECUTELEAF_CB   "EXECUTELEAF_CB"
#define IUP_RENAMENODE_CB    "RENAMENODE_CB"
#define IUP_IMGLEAF             "IMGLEAF"
#define IUP_IMGCOLLAPSED        "IMGCOLLAPSED"
#define IUP_IMGEXPANDED         "IMGEXPANDED"
#define IUP_IMGBLANK            "IMGBLANK"
#define IUP_IMGPAPER            "IMGPAPER"

#endif




================================================
File: iup/include/iupdraw.h
================================================
/** \file
 * \brief Canvas Draw API
 *
 * See Copyright Notice in "iup.h"
 */
 
#ifndef __IUPDRAW_H 
#define __IUPDRAW_H

#ifdef __cplusplus
extern "C" {
#endif

/* all functions can be used only in IUP canvas and inside the ACTION callback */

void IupDrawBegin(Ihandle* ih);
void IupDrawEnd(Ihandle* ih);

/* all primitives can be called only between calls to Begin and End */

void IupDrawSetClipRect(Ihandle* ih, int x1, int y1, int x2, int y2);
void IupDrawResetClip(Ihandle* ih);

/* color controlled by the attribute DRAWCOLOR */
/* line style or fill controlled by the attribute DRAWSTYLE */

void IupDrawParentBackground(Ihandle* ih);
void IupDrawLine(Ihandle* ih, int x1, int y1, int x2, int y2);
void IupDrawRectangle(Ihandle* ih, int x1, int y1, int x2, int y2);
void IupDrawArc(Ihandle* ih, int x1, int y1, int x2, int y2, double a1, double a2);
void IupDrawPolygon(Ihandle* ih, int* points, int count);
void IupDrawText(Ihandle* ih, const char* text, int len, int x, int y);
void IupDrawImage(Ihandle* ih, const char* name, int make_inactive, int x, int y);
void IupDrawSelectRect(Ihandle* ih, int x1, int y1, int x2, int y2);
void IupDrawFocusRect(Ihandle* ih, int x1, int y1, int x2, int y2);

void IupDrawGetSize(Ihandle* ih, int *w, int *h);
void IupDrawGetTextSize(Ihandle* ih, const char* str, int *w, int *h);
void IupDrawGetImageInfo(const char* name, int *w, int *h, int *bpp);


#ifdef __cplusplus
}
#endif

#endif



================================================
File: iup/include/iupgl.h
================================================
/** \file
 * \brief OpenGL canvas for Iup.
 *
 * See Copyright Notice in "iup.h"
 */
 
#ifndef __IUPGL_H 
#define __IUPGL_H

#ifdef __cplusplus
extern "C" {
#endif

/* Attributes 
** To set the appropriate visual (pixel format) the following
** attributes may be specified. Their values should be set
** before the canvas is mapped to the scrren.
** After mapping, changing their values has no effect.
*/
#ifndef IUP_BUFFER    /* IUP_SINGLE (defaut) or IUP_DOUBLE */
#define IUP_BUFFER    "BUFFER"
#endif
#ifndef IUP_STEREO    /* IUP_NO (defaut) or IUP_YES */
#define IUP_STEREO     "STEREO"
#endif
#ifndef IUP_BUFFER_SIZE    /* Number of bits if index mode */
#define IUP_BUFFER_SIZE    "BUFFER_SIZE"
#endif
#ifndef IUP_RED_SIZE    /* Number of red bits */
#define IUP_RED_SIZE    "RED_SIZE"
#endif
#ifndef IUP_GREEN_SIZE    /* Number of green bits */
#define IUP_GREEN_SIZE    "GREEN_SIZE"
#endif
#ifndef IUP_BLUE_SIZE    /* Number of blue bits */
#define IUP_BLUE_SIZE    "BLUE_SIZE"
#endif
#ifndef IUP_ALPHA_SIZE    /* Number of alpha bits */
#define IUP_ALPHA_SIZE    "ALPHA_SIZE"
#endif
#ifndef IUP_DEPTH_SIZE    /* Number of bits in depth buffer */
#define IUP_DEPTH_SIZE    "DEPTH_SIZE"
#endif
#ifndef IUP_STENCIL_SIZE  /* Number of bits in stencil buffer */
#define IUP_STENCIL_SIZE  "STENCIL_SIZE"
#endif
#ifndef IUP_ACCUM_RED_SIZE  /* Number of red bits in accum. buffer */
#define IUP_ACCUM_RED_SIZE  "ACCUM_RED_SIZE"
#endif
#ifndef IUP_ACCUM_GREEN_SIZE  /* Number of green bits in accum. buffer */
#define IUP_ACCUM_GREEN_SIZE  "ACCUM_GREEN_SIZE"
#endif
#ifndef IUP_ACCUM_BLUE_SIZE  /* Number of blue bits in accum. buffer */
#define IUP_ACCUM_BLUE_SIZE  "ACCUM_BLUE_SIZE"
#endif
#ifndef IUP_ACCUM_ALPHA_SIZE  /* Number of alpha bits in accum. buffer */
#define IUP_ACCUM_ALPHA_SIZE  "ACCUM_ALPHA_SIZE"
#endif


/* Attribute values */
#ifndef IUP_DOUBLE
#define IUP_DOUBLE  "DOUBLE"
#endif
#ifndef IUP_SINGLE
#define IUP_SINGLE  "SINGLE"
#endif
#ifndef IUP_INDEX
#define IUP_INDEX  "INDEX"
#endif
#ifndef IUP_RGBA
#define IUP_RGBA  "RGBA"
#endif
#ifndef IUP_YES
#define IUP_YES    "YES"
#endif
#ifndef IUP_NO
#define IUP_NO    "NO"
#endif

void IupGLCanvasOpen(void);

Ihandle *IupGLCanvas(const char *action);
Ihandle* IupGLBackgroundBox(Ihandle* child);

void IupGLMakeCurrent(Ihandle* ih);
int IupGLIsCurrent(Ihandle* ih);
void IupGLSwapBuffers(Ihandle* ih);
void IupGLPalette(Ihandle* ih, int index, float r, float g, float b);
void IupGLUseFont(Ihandle* ih, int first, int count, int list_base);
void IupGLWait(int gl);

#ifdef __cplusplus
}
#endif

#endif



================================================
File: iup/include/iupglcontrols.h
================================================
/** \file
 * \brief GL Controls.
 *
 * See Copyright Notice in "iup.h"
 */
 
#ifndef __IUPGLCONTROLS_H 
#define __IUPGLCONTROLS_H

#ifdef __cplusplus
extern "C" {
#endif


int  IupGLControlsOpen(void);

Ihandle* IupGLCanvasBoxv(Ihandle** children);
Ihandle* IupGLCanvasBox(Ihandle* child, ...);

Ihandle* IupGLSubCanvas(void);

Ihandle* IupGLLabel(const char* title);
Ihandle* IupGLSeparator(void);
Ihandle* IupGLButton(const char* title);
Ihandle* IupGLToggle(const char* title);
Ihandle* IupGLLink(const char *url, const char * title);
Ihandle* IupGLProgressBar(void);
Ihandle* IupGLVal(void);
Ihandle* IupGLFrame(Ihandle* child);
Ihandle* IupGLExpander(Ihandle* child);
Ihandle* IupGLScrollBox(Ihandle* child);
Ihandle* IupGLSizeBox(Ihandle* child);
Ihandle* IupGLText(void);


/* Utilities */
void IupGLDrawImage(Ihandle* ih, const char* name, int x, int y, int active);
void IupGLDrawText(Ihandle* ih, const char* str, int len, int x, int y);
void IupGLDrawGetTextSize(Ihandle* ih, const char* str, int *w, int *h);
void IupGLDrawGetImageInfo(const char* name, int *w, int *h, int *bpp);


#ifdef __cplusplus
}
#endif

#endif



================================================
File: iup/include/iupim.h
================================================
/** \file
 * \brief Utilities using IM
 *
 * See Copyright Notice in "iup.h"
 */

#ifndef __IUPIM_H
#define __IUPIM_H

#if	defined(__cplusplus)
extern "C" {
#endif


Ihandle* IupLoadImage(const char* file_name);
int IupSaveImage(Ihandle* ih, const char* file_name, const char* format);

Ihandle* IupLoadAnimation(const char* file_name);
Ihandle* IupLoadAnimationFrames(const char** file_name_list, int file_count);

#ifdef __IM_IMAGE_H
imImage* IupGetNativeHandleImage(void* handle);
void* IupGetImageNativeHandle(const imImage* image);

Ihandle* IupImageFromImImage(const imImage* image);
#endif


#if defined(__cplusplus)
}
#endif

#endif



================================================
File: iup/include/iupkey.h
================================================
/** \file
 * \brief Keyboard Keys definitions.
 *
 * See Copyright Notice in "iup.h"
 */
 
#ifndef __IUPKEY_H 
#define __IUPKEY_H

/* from 32 to 126, all character sets are equal,
   the key code is the same as the ASCii character code. */

#define K_SP          ' '   /* 32 (0x20) */
#define K_exclam      '!'   /* 33 */
#define K_quotedbl    '\"'  /* 34 */
#define K_numbersign  '#'   /* 35 */
#define K_dollar      '$'   /* 36 */
#define K_percent     '%'   /* 37 */
#define K_ampersand   '&'   /* 38 */
#define K_apostrophe  '\''  /* 39 */
#define K_parentleft  '('   /* 40 */
#define K_parentright ')'   /* 41 */
#define K_asterisk    '*'   /* 42 */
#define K_plus        '+'   /* 43 */
#define K_comma       ','   /* 44 */
#define K_minus       '-'   /* 45 */
#define K_period      '.'   /* 46 */
#define K_slash       '/'   /* 47 */
#define K_0           '0'   /* 48 (0x30) */
#define K_1           '1'   /* 49 */
#define K_2           '2'   /* 50 */
#define K_3           '3'   /* 51 */
#define K_4           '4'   /* 52 */
#define K_5           '5'   /* 53 */
#define K_6           '6'   /* 54 */
#define K_7           '7'   /* 55 */
#define K_8           '8'   /* 56 */
#define K_9           '9'   /* 57 */
#define K_colon       ':'   /* 58 */
#define K_semicolon   ';'   /* 59 */
#define K_less        '<'   /* 60 */
#define K_equal       '='   /* 61 */
#define K_greater     '>'   /* 62 */
#define K_question    '?'   /* 63 */
#define K_at          '@'   /* 64 */
#define K_A           'A'   /* 65 (0x41) */
#define K_B           'B'   /* 66 */
#define K_C           'C'   /* 67 */
#define K_D           'D'   /* 68 */
#define K_E           'E'   /* 69 */
#define K_F           'F'   /* 70 */
#define K_G           'G'   /* 71 */
#define K_H           'H'   /* 72 */
#define K_I           'I'   /* 73 */
#define K_J           'J'   /* 74 */
#define K_K           'K'   /* 75 */
#define K_L           'L'   /* 76 */
#define K_M           'M'   /* 77 */
#define K_N           'N'   /* 78 */
#define K_O           'O'   /* 79 */
#define K_P           'P'   /* 80 */
#define K_Q           'Q'   /* 81 */
#define K_R           'R'   /* 82 */
#define K_S           'S'   /* 83 */
#define K_T           'T'   /* 84 */
#define K_U           'U'   /* 85 */
#define K_V           'V'   /* 86 */
#define K_W           'W'   /* 87 */
#define K_X           'X'   /* 88 */
#define K_Y           'Y'   /* 89 */
#define K_Z           'Z'   /* 90 */
#define K_bracketleft '['   /* 91 */
#define K_backslash   '\\'  /* 92 */
#define K_bracketright ']'  /* 93 */
#define K_circum      '^'   /* 94 */
#define K_underscore  '_'   /* 95 */
#define K_grave       '`'   /* 96 */
#define K_a           'a'   /* 97 (0x61) */
#define K_b           'b'   /* 98 */
#define K_c           'c'   /* 99 */
#define K_d           'd'   /* 100 */
#define K_e           'e'   /* 101 */
#define K_f           'f'   /* 102 */
#define K_g           'g'   /* 103 */
#define K_h           'h'   /* 104 */
#define K_i           'i'   /* 105 */
#define K_j           'j'   /* 106 */
#define K_k           'k'   /* 107 */
#define K_l           'l'   /* 108 */
#define K_m           'm'   /* 109 */
#define K_n           'n'   /* 110 */
#define K_o           'o'   /* 111 */
#define K_p           'p'   /* 112 */
#define K_q           'q'   /* 113 */
#define K_r           'r'   /* 114 */
#define K_s           's'   /* 115 */
#define K_t           't'   /* 116 */
#define K_u           'u'   /* 117 */
#define K_v           'v'   /* 118 */
#define K_w           'w'   /* 119 */
#define K_x           'x'   /* 120 */
#define K_y           'y'   /* 121 */
#define K_z           'z'   /* 122 */
#define K_braceleft   '{'   /* 123 */
#define K_bar         '|'   /* 124 */
#define K_braceright  '}'   /* 125 */
#define K_tilde       '~'   /* 126 (0x7E) */

/* Printable ASCii keys */

#define iup_isprint(_c) ((_c) > 31 && (_c) < 127)

/* also define the escape sequences that have keys associated */

#define K_BS     '\b'       /* 8 */
#define K_TAB    '\t'       /* 9 */
#define K_LF     '\n'       /* 10 (0x0A) not a real key, is a combination of CR with a modifier, just to document */
#define K_CR     '\r'       /* 13 (0x0D) */

/* backward compatible definitions */

#define  K_quoteleft   K_grave
#define  K_quoteright  K_apostrophe
#define  isxkey        iup_isXkey

/* IUP Extended Key Codes, range start at 128      */

#define iup_isXkey(_c)      ((_c) >= 128)

/* These use the same definition as X11 and GDK.
   This also means that any X11 or GDK definition can also be used. */

#define K_PAUSE    0xFF13
#define K_ESC      0xFF1B
#define K_HOME     0xFF50           
#define K_LEFT     0xFF51
#define K_UP       0xFF52
#define K_RIGHT    0xFF53
#define K_DOWN     0xFF54 
#define K_PGUP     0xFF55
#define K_PGDN     0xFF56
#define K_END      0xFF57
#define K_MIDDLE   0xFF0B
#define K_Print    0xFF61 
#define K_INS      0xFF63
#define K_Menu     0xFF67
#define K_DEL      0xFFFF
#define K_F1       0xFFBE
#define K_F2       0xFFBF
#define K_F3       0xFFC0
#define K_F4       0xFFC1
#define K_F5       0xFFC2
#define K_F6       0xFFC3
#define K_F7       0xFFC4
#define K_F8       0xFFC5
#define K_F9       0xFFC6
#define K_F10      0xFFC7
#define K_F11      0xFFC8
#define K_F12      0xFFC9

/* no Shift/Ctrl/Alt */
#define K_LSHIFT   0xFFE1
#define K_RSHIFT   0xFFE2
#define K_LCTRL    0xFFE3
#define K_RCTRL    0xFFE4
#define K_LALT     0xFFE9
#define K_RALT     0xFFEA

#define K_NUM      0xFF7F
#define K_SCROLL   0xFF14
#define K_CAPS     0xFFE5

/* Also, these are the same as the Latin-1 definition */

#define K_ccedilla  0x00E7
#define K_Ccedilla  0x00C7
#define K_acute     0x00B4  /* no Shift/Ctrl/Alt */
#define K_diaeresis 0x00A8

/******************************************************/
/* Modifiers use last 4 bits. Since IUP 3.9           */
/* These modifiers definitions are specific to IUP    */
/******************************************************/

#define iup_isShiftXkey(_c) ((_c) & 0x10000000)
#define iup_isCtrlXkey(_c)  ((_c) & 0x20000000)
#define iup_isAltXkey(_c)   ((_c) & 0x40000000)
#define iup_isSysXkey(_c)   ((_c) & 0x80000000)

#define iup_XkeyBase(_c)  ((_c) & 0x0FFFFFFF)
#define iup_XkeyShift(_c) ((_c) | 0x10000000)   /* Shift  */
#define iup_XkeyCtrl(_c)  ((_c) | 0x20000000)   /* Ctrl   */
#define iup_XkeyAlt(_c)   ((_c) | 0x40000000)   /* Alt    */
#define iup_XkeySys(_c)   ((_c) | 0x80000000)   /* Sys (Win or Apple) */

/* These definitions are here for backward compatibility 
   and to simplify some key combination usage.
   But since IUP 3.9, modifiers can be combined with any key
   and they can be mixed together. */

#define K_sHOME    iup_XkeyShift(K_HOME   )
#define K_sUP      iup_XkeyShift(K_UP     )
#define K_sPGUP    iup_XkeyShift(K_PGUP   )
#define K_sLEFT    iup_XkeyShift(K_LEFT   )
#define K_sMIDDLE  iup_XkeyShift(K_MIDDLE )
#define K_sRIGHT   iup_XkeyShift(K_RIGHT  )
#define K_sEND     iup_XkeyShift(K_END    )
#define K_sDOWN    iup_XkeyShift(K_DOWN   )
#define K_sPGDN    iup_XkeyShift(K_PGDN   )
#define K_sINS     iup_XkeyShift(K_INS    )
#define K_sDEL     iup_XkeyShift(K_DEL    )
#define K_sSP      iup_XkeyShift(K_SP     )
#define K_sTAB     iup_XkeyShift(K_TAB    )
#define K_sCR      iup_XkeyShift(K_CR     )
#define K_sBS      iup_XkeyShift(K_BS     )
#define K_sPAUSE   iup_XkeyShift(K_PAUSE  )
#define K_sESC     iup_XkeyShift(K_ESC    )
#define K_sF1      iup_XkeyShift(K_F1     )
#define K_sF2      iup_XkeyShift(K_F2     )
#define K_sF3      iup_XkeyShift(K_F3     )
#define K_sF4      iup_XkeyShift(K_F4     )
#define K_sF5      iup_XkeyShift(K_F5     )
#define K_sF6      iup_XkeyShift(K_F6     )
#define K_sF7      iup_XkeyShift(K_F7     )
#define K_sF8      iup_XkeyShift(K_F8     )
#define K_sF9      iup_XkeyShift(K_F9     )
#define K_sF10     iup_XkeyShift(K_F10    )
#define K_sF11     iup_XkeyShift(K_F11    )
#define K_sF12     iup_XkeyShift(K_F12    )
#define K_sPrint   iup_XkeyShift(K_Print  )
#define K_sMenu    iup_XkeyShift(K_Menu   )

#define K_cHOME     iup_XkeyCtrl(K_HOME    )
#define K_cUP       iup_XkeyCtrl(K_UP      )
#define K_cPGUP     iup_XkeyCtrl(K_PGUP    )
#define K_cLEFT     iup_XkeyCtrl(K_LEFT    )
#define K_cMIDDLE   iup_XkeyCtrl(K_MIDDLE  )
#define K_cRIGHT    iup_XkeyCtrl(K_RIGHT   )
#define K_cEND      iup_XkeyCtrl(K_END     )
#define K_cDOWN     iup_XkeyCtrl(K_DOWN    )
#define K_cPGDN     iup_XkeyCtrl(K_PGDN    )
#define K_cINS      iup_XkeyCtrl(K_INS     )
#define K_cDEL      iup_XkeyCtrl(K_DEL     )
#define K_cSP       iup_XkeyCtrl(K_SP      )
#define K_cTAB      iup_XkeyCtrl(K_TAB     )
#define K_cCR       iup_XkeyCtrl(K_CR      )
#define K_cBS       iup_XkeyCtrl(K_BS      )
#define K_cPAUSE    iup_XkeyCtrl(K_PAUSE   )
#define K_cESC      iup_XkeyCtrl(K_ESC     )
#define K_cCcedilla iup_XkeyCtrl(K_Ccedilla)
#define K_cF1       iup_XkeyCtrl(K_F1      )
#define K_cF2       iup_XkeyCtrl(K_F2      )
#define K_cF3       iup_XkeyCtrl(K_F3      )
#define K_cF4       iup_XkeyCtrl(K_F4      )
#define K_cF5       iup_XkeyCtrl(K_F5      )
#define K_cF6       iup_XkeyCtrl(K_F6      )
#define K_cF7       iup_XkeyCtrl(K_F7      )
#define K_cF8       iup_XkeyCtrl(K_F8      )
#define K_cF9       iup_XkeyCtrl(K_F9      )
#define K_cF10      iup_XkeyCtrl(K_F10     )
#define K_cF11      iup_XkeyCtrl(K_F11     )
#define K_cF12      iup_XkeyCtrl(K_F12     )
#define K_cPrint    iup_XkeyCtrl(K_Print   )
#define K_cMenu     iup_XkeyCtrl(K_Menu    )

#define K_mHOME     iup_XkeyAlt(K_HOME    )
#define K_mUP       iup_XkeyAlt(K_UP      )
#define K_mPGUP     iup_XkeyAlt(K_PGUP    )
#define K_mLEFT     iup_XkeyAlt(K_LEFT    )
#define K_mMIDDLE   iup_XkeyAlt(K_MIDDLE  )
#define K_mRIGHT    iup_XkeyAlt(K_RIGHT   )
#define K_mEND      iup_XkeyAlt(K_END     )
#define K_mDOWN     iup_XkeyAlt(K_DOWN    )
#define K_mPGDN     iup_XkeyAlt(K_PGDN    )
#define K_mINS      iup_XkeyAlt(K_INS     )
#define K_mDEL      iup_XkeyAlt(K_DEL     )
#define K_mSP       iup_XkeyAlt(K_SP      )
#define K_mTAB      iup_XkeyAlt(K_TAB     )
#define K_mCR       iup_XkeyAlt(K_CR      )
#define K_mBS       iup_XkeyAlt(K_BS      )
#define K_mPAUSE    iup_XkeyAlt(K_PAUSE   )
#define K_mESC      iup_XkeyAlt(K_ESC     )
#define K_mCcedilla iup_XkeyAlt(K_Ccedilla)
#define K_mF1       iup_XkeyAlt(K_F1      )
#define K_mF2       iup_XkeyAlt(K_F2      )
#define K_mF3       iup_XkeyAlt(K_F3      )
#define K_mF4       iup_XkeyAlt(K_F4      )
#define K_mF5       iup_XkeyAlt(K_F5      )
#define K_mF6       iup_XkeyAlt(K_F6      )
#define K_mF7       iup_XkeyAlt(K_F7      )
#define K_mF8       iup_XkeyAlt(K_F8      )
#define K_mF9       iup_XkeyAlt(K_F9      )
#define K_mF10      iup_XkeyAlt(K_F10     )
#define K_mF11      iup_XkeyAlt(K_F11     )
#define K_mF12      iup_XkeyAlt(K_F12     )
#define K_mPrint    iup_XkeyAlt(K_Print   )
#define K_mMenu     iup_XkeyAlt(K_Menu    )

#define K_yHOME     iup_XkeySys(K_HOME    )
#define K_yUP       iup_XkeySys(K_UP      )
#define K_yPGUP     iup_XkeySys(K_PGUP    )
#define K_yLEFT     iup_XkeySys(K_LEFT    )
#define K_yMIDDLE   iup_XkeySys(K_MIDDLE  )
#define K_yRIGHT    iup_XkeySys(K_RIGHT   )
#define K_yEND      iup_XkeySys(K_END     )
#define K_yDOWN     iup_XkeySys(K_DOWN    )
#define K_yPGDN     iup_XkeySys(K_PGDN    )
#define K_yINS      iup_XkeySys(K_INS     )
#define K_yDEL      iup_XkeySys(K_DEL     )
#define K_ySP       iup_XkeySys(K_SP      )
#define K_yTAB      iup_XkeySys(K_TAB     )
#define K_yCR       iup_XkeySys(K_CR      )
#define K_yBS       iup_XkeySys(K_BS      )
#define K_yPAUSE    iup_XkeySys(K_PAUSE   )
#define K_yESC      iup_XkeySys(K_ESC     )
#define K_yCcedilla iup_XkeySys(K_Ccedilla)
#define K_yF1       iup_XkeySys(K_F1      )
#define K_yF2       iup_XkeySys(K_F2      )
#define K_yF3       iup_XkeySys(K_F3      )
#define K_yF4       iup_XkeySys(K_F4      )
#define K_yF5       iup_XkeySys(K_F5      )
#define K_yF6       iup_XkeySys(K_F6      )
#define K_yF7       iup_XkeySys(K_F7      )
#define K_yF8       iup_XkeySys(K_F8      )
#define K_yF9       iup_XkeySys(K_F9      )
#define K_yF10      iup_XkeySys(K_F10     )
#define K_yF11      iup_XkeySys(K_F11     )
#define K_yF12      iup_XkeySys(K_F12     )
#define K_yPrint    iup_XkeySys(K_Print   )
#define K_yMenu     iup_XkeySys(K_Menu    )

#define K_sPlus         iup_XkeyShift(K_plus    )   
#define K_sComma        iup_XkeyShift(K_comma   )   
#define K_sMinus        iup_XkeyShift(K_minus   )   
#define K_sPeriod       iup_XkeyShift(K_period  )   
#define K_sSlash        iup_XkeyShift(K_slash   )   
#define K_sAsterisk     iup_XkeyShift(K_asterisk)
                        
#define K_cA     iup_XkeyCtrl(K_A)
#define K_cB     iup_XkeyCtrl(K_B)
#define K_cC     iup_XkeyCtrl(K_C)
#define K_cD     iup_XkeyCtrl(K_D)
#define K_cE     iup_XkeyCtrl(K_E)
#define K_cF     iup_XkeyCtrl(K_F)
#define K_cG     iup_XkeyCtrl(K_G)
#define K_cH     iup_XkeyCtrl(K_H)
#define K_cI     iup_XkeyCtrl(K_I)
#define K_cJ     iup_XkeyCtrl(K_J)
#define K_cK     iup_XkeyCtrl(K_K)
#define K_cL     iup_XkeyCtrl(K_L)
#define K_cM     iup_XkeyCtrl(K_M)
#define K_cN     iup_XkeyCtrl(K_N)
#define K_cO     iup_XkeyCtrl(K_O)
#define K_cP     iup_XkeyCtrl(K_P)
#define K_cQ     iup_XkeyCtrl(K_Q)
#define K_cR     iup_XkeyCtrl(K_R)
#define K_cS     iup_XkeyCtrl(K_S)
#define K_cT     iup_XkeyCtrl(K_T)
#define K_cU     iup_XkeyCtrl(K_U)
#define K_cV     iup_XkeyCtrl(K_V)
#define K_cW     iup_XkeyCtrl(K_W)
#define K_cX     iup_XkeyCtrl(K_X)
#define K_cY     iup_XkeyCtrl(K_Y)
#define K_cZ     iup_XkeyCtrl(K_Z)
#define K_c1     iup_XkeyCtrl(K_1)
#define K_c2     iup_XkeyCtrl(K_2)
#define K_c3     iup_XkeyCtrl(K_3)
#define K_c4     iup_XkeyCtrl(K_4)
#define K_c5     iup_XkeyCtrl(K_5)
#define K_c6     iup_XkeyCtrl(K_6)
#define K_c7     iup_XkeyCtrl(K_7)        
#define K_c8     iup_XkeyCtrl(K_8)         
#define K_c9     iup_XkeyCtrl(K_9)
#define K_c0     iup_XkeyCtrl(K_0)
#define K_cPlus         iup_XkeyCtrl(K_plus        )   
#define K_cComma        iup_XkeyCtrl(K_comma       )   
#define K_cMinus        iup_XkeyCtrl(K_minus       )   
#define K_cPeriod       iup_XkeyCtrl(K_period      )   
#define K_cSlash        iup_XkeyCtrl(K_slash       )   
#define K_cSemicolon    iup_XkeyCtrl(K_semicolon   ) 
#define K_cEqual        iup_XkeyCtrl(K_equal       )
#define K_cBracketleft  iup_XkeyCtrl(K_bracketleft )
#define K_cBracketright iup_XkeyCtrl(K_bracketright)
#define K_cBackslash    iup_XkeyCtrl(K_backslash   )
#define K_cAsterisk     iup_XkeyCtrl(K_asterisk    )

#define K_mA     iup_XkeyAlt(K_A)
#define K_mB     iup_XkeyAlt(K_B)
#define K_mC     iup_XkeyAlt(K_C)
#define K_mD     iup_XkeyAlt(K_D)
#define K_mE     iup_XkeyAlt(K_E)
#define K_mF     iup_XkeyAlt(K_F)
#define K_mG     iup_XkeyAlt(K_G)
#define K_mH     iup_XkeyAlt(K_H)
#define K_mI     iup_XkeyAlt(K_I)
#define K_mJ     iup_XkeyAlt(K_J)
#define K_mK     iup_XkeyAlt(K_K)
#define K_mL     iup_XkeyAlt(K_L)
#define K_mM     iup_XkeyAlt(K_M)
#define K_mN     iup_XkeyAlt(K_N)
#define K_mO     iup_XkeyAlt(K_O)
#define K_mP     iup_XkeyAlt(K_P)
#define K_mQ     iup_XkeyAlt(K_Q)
#define K_mR     iup_XkeyAlt(K_R)
#define K_mS     iup_XkeyAlt(K_S)
#define K_mT     iup_XkeyAlt(K_T)
#define K_mU     iup_XkeyAlt(K_U)
#define K_mV     iup_XkeyAlt(K_V)
#define K_mW     iup_XkeyAlt(K_W)
#define K_mX     iup_XkeyAlt(K_X)
#define K_mY     iup_XkeyAlt(K_Y)
#define K_mZ     iup_XkeyAlt(K_Z)
#define K_m1     iup_XkeyAlt(K_1)
#define K_m2     iup_XkeyAlt(K_2)
#define K_m3     iup_XkeyAlt(K_3)
#define K_m4     iup_XkeyAlt(K_4)
#define K_m5     iup_XkeyAlt(K_5)
#define K_m6     iup_XkeyAlt(K_6)
#define K_m7     iup_XkeyAlt(K_7)        
#define K_m8     iup_XkeyAlt(K_8)         
#define K_m9     iup_XkeyAlt(K_9)
#define K_m0     iup_XkeyAlt(K_0)
#define K_mPlus         iup_XkeyAlt(K_plus        )   
#define K_mComma        iup_XkeyAlt(K_comma       )   
#define K_mMinus        iup_XkeyAlt(K_minus       )   
#define K_mPeriod       iup_XkeyAlt(K_period      )   
#define K_mSlash        iup_XkeyAlt(K_slash       )   
#define K_mSemicolon    iup_XkeyAlt(K_semicolon   ) 
#define K_mEqual        iup_XkeyAlt(K_equal       )
#define K_mBracketleft  iup_XkeyAlt(K_bracketleft )
#define K_mBracketright iup_XkeyAlt(K_bracketright)
#define K_mBackslash    iup_XkeyAlt(K_backslash   )
#define K_mAsterisk     iup_XkeyAlt(K_asterisk    )

#define K_yA     iup_XkeySys(K_A)
#define K_yB     iup_XkeySys(K_B)
#define K_yC     iup_XkeySys(K_C)
#define K_yD     iup_XkeySys(K_D)
#define K_yE     iup_XkeySys(K_E)
#define K_yF     iup_XkeySys(K_F)
#define K_yG     iup_XkeySys(K_G)
#define K_yH     iup_XkeySys(K_H)
#define K_yI     iup_XkeySys(K_I)
#define K_yJ     iup_XkeySys(K_J)
#define K_yK     iup_XkeySys(K_K)
#define K_yL     iup_XkeySys(K_L)
#define K_yM     iup_XkeySys(K_M)
#define K_yN     iup_XkeySys(K_N)
#define K_yO     iup_XkeySys(K_O)
#define K_yP     iup_XkeySys(K_P)
#define K_yQ     iup_XkeySys(K_Q)
#define K_yR     iup_XkeySys(K_R)
#define K_yS     iup_XkeySys(K_S)
#define K_yT     iup_XkeySys(K_T)
#define K_yU     iup_XkeySys(K_U)
#define K_yV     iup_XkeySys(K_V)
#define K_yW     iup_XkeySys(K_W)
#define K_yX     iup_XkeySys(K_X)
#define K_yY     iup_XkeySys(K_Y)
#define K_yZ     iup_XkeySys(K_Z)
#define K_y1     iup_XkeySys(K_1)
#define K_y2     iup_XkeySys(K_2)
#define K_y3     iup_XkeySys(K_3)
#define K_y4     iup_XkeySys(K_4)
#define K_y5     iup_XkeySys(K_5)
#define K_y6     iup_XkeySys(K_6)
#define K_y7     iup_XkeySys(K_7)        
#define K_y8     iup_XkeySys(K_8)         
#define K_y9     iup_XkeySys(K_9)
#define K_y0     iup_XkeySys(K_0)
#define K_yPlus         iup_XkeySys(K_plus        )   
#define K_yComma        iup_XkeySys(K_comma       )   
#define K_yMinus        iup_XkeySys(K_minus       )   
#define K_yPeriod       iup_XkeySys(K_period      )   
#define K_ySlash        iup_XkeySys(K_slash       )   
#define K_ySemicolon    iup_XkeySys(K_semicolon   ) 
#define K_yEqual        iup_XkeySys(K_equal       )
#define K_yBracketleft  iup_XkeySys(K_bracketleft )
#define K_yBracketright iup_XkeySys(K_bracketright)
#define K_yBackslash    iup_XkeySys(K_backslash   )
#define K_yAsterisk     iup_XkeySys(K_asterisk    )


#endif



================================================
File: iup/include/iuplua.h
================================================
/** \file
 * \brief IUP Binding for Lua.
 *
 * See Copyright Notice in "iup.h"
 */
 
#ifndef __IUPLUA_H 
#define __IUPLUA_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef LUA_NOOBJECT  /* Lua 3 */
int iuplua_open (void);
int iupkey_open (void);

/* utilities */
Ihandle* iuplua_checkihandle(int pos);
void iuplua_pushihandle(Ihandle *n);
int iuplua_dofile (char *filename);
#endif

#ifdef LUA_TNONE  /* Lua 5 */
int iuplua_open(lua_State *L);
int iupkey_open(lua_State *L);  /* does nothing, kept for backward compatibility */
int iuplua_close(lua_State * L);

/* utilities */
int iuplua_isihandle(lua_State *L, int pos);
Ihandle* iuplua_checkihandle(lua_State *L, int pos);
void iuplua_pushihandle(lua_State *L, Ihandle *n);
int iuplua_dofile(lua_State *L, const char *filename);
int iuplua_dostring(lua_State *L, const char *string, const char *chunk_name);
int iuplua_dobuffer(lua_State *L, const char *buffer, int len, const char *chunk_name);
void iuplua_show_error_message(const char *pname, const char* msg);

#endif

#ifdef __cplusplus
}
#endif

#endif



================================================
File: iup/include/iuplua_mglplot.h
================================================
/** \file
 * \brief IupMglPlot Binding for Lua.
 *
 * See Copyright Notice in "iup.h"
 */
 
#ifndef __IUPLUA_MGLPLOT_H 
#define __IUPLUA_MGLPLOT_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef LUA_NOOBJECT  /* Lua 3 */
int iup_mglplotlua_open (void);
#endif

#ifdef LUA_TNONE  /* Lua 5 */
int iup_mglplotlua_open (lua_State * L);
#endif

#ifdef __cplusplus
}
#endif

#endif



================================================
File: iup/include/iuplua_plot.h
================================================
/** \file
 * \brief iup_plot Binding for Lua.
 *
 * See Copyright Notice in "iup.h"
 */
 
#ifndef __IUPLUA_PLOT_H 
#define __IUPLUA_PLOT_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef LUA_TNONE  /* Lua 5 */
int iup_plotlua_open (lua_State * L);
#endif

#ifdef __cplusplus
}
#endif

#endif



================================================
File: iup/include/iuplua_scintilla.h
================================================
/** \file
 * \brief IupScintilla Binding for Lua.
 *
 * See Copyright Notice in "iup.h"
 */
 
#ifndef __IUPLUA_SCINTILLA_H 
#define __IUPLUA_SCINTILLA_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef LUA_NOOBJECT  /* Lua 3 */
int iup_scintillalua_open (void);
#endif

#ifdef LUA_TNONE  /* Lua 5 */
int iup_scintillalua_open (lua_State * L);
#endif

#ifdef __cplusplus
}
#endif

#endif



================================================
File: iup/include/iupluacontrols.h
================================================
/** \file
 * \brief iupcontrols Binding for Lua.
 *
 * See Copyright Notice in "iup.h"
 */
 
#ifndef __IUPLUACONTROLS_H 
#define __IUPLUACONTROLS_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef LUA_NOOBJECT  /* Lua 3 */
int iupcontrolslua_open (void);
#endif

#ifdef LUA_TNONE  /* Lua 5 */
int iupcontrolslua_open (lua_State * L);
#endif

#ifdef __cplusplus
}
#endif

#endif



================================================
File: iup/include/iupluagl.h
================================================
/** \file
 * \brief Binding of iupglcanvas to Lua.
 *
 * See Copyright Notice in "iup.h"
 */
 
#ifndef __IUPLUAGL_H 
#define __IUPLUAGL_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef LUA_NOOBJECT  /* Lua 3 */
int iupgllua_open(void);
#endif

#ifdef LUA_TNONE  /* Lua 5 */
int iupgllua_open (lua_State * L);
#endif

#ifdef __cplusplus
}
#endif

#endif



================================================
File: iup/include/iupluaglcontrols.h
================================================
/** \file
 * \brief iupglcontrols Binding for Lua.
 *
 * See Copyright Notice in "iup.h"
 */
 
#ifndef __IUPLUAGLCONTROLS_H 
#define __IUPLUAGLCONTROLS_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef LUA_TNONE  /* Lua 5 */
int iupglcontrolslua_open (lua_State * L);
#endif

#ifdef __cplusplus
}
#endif

#endif



================================================
File: iup/include/iupluaim.h
================================================
/** \file
 * \brief Bindig of iupim functions to Lua.
 *
 * See Copyright Notice in "iup.h"
 */
 
#ifndef __IUPLUAIM_H
#define __IUPLUAIM_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef LUA_NOOBJECT  /* Lua 3 */
void iupimlua_open(void);
#endif

#ifdef LUA_TNONE  /* Lua 5 */
int iupimlua_open(lua_State * L);
#endif

#ifdef __cplusplus
}
#endif

#endif



================================================
File: iup/include/iupluamatrixex.h
================================================
/** \file
 * \brief iupmatrixex Binding for Lua.
 *
 * See Copyright Notice in "iup.h"
 */
 
#ifndef __IUPLUAMATRIXEX_H 
#define __IUPLUAMATRIXEX_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef LUA_TNONE  /* Lua 5 */
int iupmatrixexlua_open (lua_State * L);
#endif

#ifdef __cplusplus
}
#endif

#endif



================================================
File: iup/include/iupluaole.h
================================================
/** \file
 * \brief Binding of iupolecontrol to Lua.
 *
 * See Copyright Notice in "iup.h"
 */
 
#ifndef __IUPLUAOLE_H 
#define __IUPLUAOLE_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef LUA_NOOBJECT  /* Lua 3 */
int iupolelua_open(void);
#endif

#ifdef LUA_TNONE  /* Lua 5 */
int iupolelua_open (lua_State * L);
#endif

#ifdef __cplusplus
}
#endif

#endif



================================================
File: iup/include/iupluatuio.h
================================================
/** \file
 * \brief Binding of iuptuio to Lua.
 *
 * See Copyright Notice in "iup.h"
 */
 
#ifndef __IUPLUATUIO_H 
#define __IUPLUATUIO_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef LUA_TNONE  /* Lua 5 */
int iuptuiolua_open (lua_State * L);
#endif

#ifdef __cplusplus
}
#endif

#endif



================================================
File: iup/include/iupluaweb.h
================================================
/** \file
 * \brief Binding of iupwebbrowser to Lua.
 *
 * See Copyright Notice in "iup.h"
 */
 
#ifndef __IUPLUAWEB_H 
#define __IUPLUAWEB_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef LUA_NOOBJECT  /* Lua 3 */
int iupweblua_open(void);
#endif

#ifdef LUA_TNONE  /* Lua 5 */
int iupweblua_open (lua_State * L);
#endif

#ifdef __cplusplus
}
#endif

#endif



================================================
File: iup/include/iupmatrixex.h
================================================
/** \file
 * \brief IupMatrix Expansion Library.
 *
 * See Copyright Notice in "iup.h"
 */
 
#ifndef __IUPMATRIXEX_H 
#define __IUPMATRIXEX_H


#ifdef __cplusplus
extern "C" {
#endif


void IupMatrixExOpen(void);

Ihandle* IupMatrixEx(void);

void IupMatrixExInit(Ihandle* ih);


#ifdef __cplusplus
}
#endif

#endif



================================================
File: iup/include/iupole.h
================================================
/** \file
 * \brief Ole control.
 *
 * See Copyright Notice in "iup.h"
 */
 
#ifndef __IUPOLE_H 
#define __IUPOLE_H

#ifdef __cplusplus
extern "C" {
#endif


Ihandle *IupOleControl(const char* progid);

int IupOleControlOpen(void);


#ifdef __cplusplus
}
#endif

#endif



================================================
File: iup/include/iuptuio.h
================================================
/** \file
 * \brief IupTuioClient control
 *
 * See Copyright Notice in "iup.h"
 */

#ifndef __IUPTUIO_H
#define __IUPTUIO_H

#if	defined(__cplusplus)
extern "C" {
#endif

int IupTuioOpen(void);
Ihandle* IupTuioClient(int port);

#if defined(__cplusplus)
}
#endif

#endif



================================================
File: iup/include/iupweb.h
================================================
/** \file
 * \brief Web control.
 *
 * See Copyright Notice in "iup.h"
 */
 
#ifndef __IUPWEB_H 
#define __IUPWEB_H

#ifdef __cplusplus
extern "C" {
#endif

int IupWebBrowserOpen(void);

Ihandle *IupWebBrowser(void);


#ifdef __cplusplus
}
#endif

#endif



================================================
File: .github/FUNDING.yml
================================================
github: [codecat]



================================================
File: .github/workflows/build.yml
================================================
name: Visual Studio

on: [push, pull_request]

jobs:
  build:
    # Skip building pull requests from the same repository
    if: ${{ github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.pull_request.head.repo.full_name != github.repository) }}
    runs-on: windows-2019
    steps:
    - name: Checkout
      uses: actions/checkout@v2
      with:
        submodules: recursive
    
    - name: Add msbuild to PATH
      uses: microsoft/setup-msbuild@v1.0.2
    
    - name: Build
      run: |
        msbuild.exe ${{ github.event.repository.name }}.sln /m /verbosity:minimal /t:Rebuild /p:Configuration=Release /p:Platform=x64
        xcopy x64\Release\*.dp64 package\x64\plugins\
        msbuild.exe ${{ github.event.repository.name }}.sln /m /verbosity:minimal /t:Rebuild /p:Configuration=Release /p:Platform=x86
        xcopy Release\*.dp32 package\x32\plugins\
    
    - uses: actions/upload-artifact@v2
      with:
        name: ${{ github.event.repository.name }}-${{ github.sha }}
        path: package/
    
    - name: Compress artifacts
      uses: papeloto/action-zip@v1
      if: ${{ startsWith(github.ref, 'refs/tags/') }}
      with:
        files: package/
        dest: ${{ github.event.repository.name }}-${{ github.ref_name }}.zip

    - name: Release
      uses: softprops/action-gh-release@v1
      if: ${{ startsWith(github.ref, 'refs/tags/') }}
      with:
        prerelease: ${{ contains(github.ref, '-pre') }}
        files: ${{ github.event.repository.name }}-${{ github.ref_name }}.zip
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}


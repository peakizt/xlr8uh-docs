Directory structure:
└── jonatan1024-cpuidspoofer/
    ├── README.md
    ├── CpuidSpoofer.sln
    ├── LICENSE.md
    ├── CpuidSpoofer/
    │   ├── CpuidSpoofer.vcxproj
    │   ├── CpuidSpoofer.vcxproj.filters
    │   ├── INFO.txt
    │   ├── dialog.cpp
    │   ├── dialog.h
    │   ├── dialog.rc
    │   ├── localdecoder.h
    │   ├── plugin.cpp
    │   ├── plugin.h
    │   ├── pluginmain.cpp
    │   ├── pluginmain.h
    │   ├── presets.cpp
    │   ├── presets.h
    │   └── resource.h
    ├── PluginTemplate/
    └── .github/
        └── workflows/
            └── msbuild.yml

================================================
File: README.md
================================================
# CPUID Spoofer
[![GitHub release (latest by date)](https://img.shields.io/github/v/release/jonatan1024/CpuidSpoofer?label=Latest%20release)](https://github.com/jonatan1024/CpuidSpoofer/releases/latest)
[![GitHub Workflow Status](https://img.shields.io/github/workflow/status/jonatan1024/CpuidSpoofer/MSBuild?label=MSBuild)](https://github.com/jonatan1024/CpuidSpoofer/actions/workflows/msbuild.yml)

CpuidSpoofer is a [x64dbg](https://x64dbg.com/) plugin which helps you to modify the behaviour of the CPUID instruction.

For example, you can easily change the *manufacturer ID string*:

![Custom processor name](README.custom-name.png)

## Installation
1. Go to [Latest Release page](https://github.com/jonatan1024/CpuidSpoofer/releases/latest)
2. Download `CpuidSpoofer.dp64` into `x64dbg\x64\plugins\`
3. Download `CpuidSpoofer.dp32` into `x64dbg\x32\plugins\`

## Usage
Everything is accessible from the top menu bar, under the *Plugins â†’ CPUID* Spoofer submenu.

### Options
The options/presets dialog allows you to prepare various triggers and actions that should happen upon CPUID instruction execution.

These presets are global. They are shared between debugged files.

### Find CPUIDs and set breakpoints
Once the debugged file is fully loaded, breakpoints must be placed onto the CPUID instructions.

Click the convenient *Find CPUIDs and set breakpoints* menu option to automatically place those breakpoints.

Two breakpoints will be created for each CPUID instruciton.
First, directly on the said instr., for trigger evaluation. Second, after the said instr., for action evaluation.

You can place these breakpoints manually by selecting a CPUID instruction in the CPU tab and clicking *Set breakpoint here*.

If you find yourself overwhelmed by the number of breakpoints created, just click on *Remove all breakpoints*.
This will remove both automatically and manually placed breakpoints (by this tool only).

## Advanced usage
This plugin exports two commands: `CpuidSpooferBegin` and `CpuidSpooferEnd`.
When CPUID instruction is found, two breakpoints are created, as described above. Each of them executes one of these exported commands.

The "Begin" command evaluates all triggers from all enabled presets. If the trigger condition is true, preset action is selected to be executed.

The "End" command executes all perviously selected actions.

To break execution during trigger or action evaluation, append `$breakpointcondition=1;` into the *Custom* field.



================================================
File: CpuidSpoofer.sln
================================================
ï»¿
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30524.135
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "CpuidSpoofer", "CpuidSpoofer\CpuidSpoofer.vcxproj", "{9CCCAE98-B542-4945-B0AE-D715140A50F5}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{9CCCAE98-B542-4945-B0AE-D715140A50F5}.Debug|x64.ActiveCfg = Debug|x64
		{9CCCAE98-B542-4945-B0AE-D715140A50F5}.Debug|x64.Build.0 = Debug|x64
		{9CCCAE98-B542-4945-B0AE-D715140A50F5}.Debug|x86.ActiveCfg = Debug|Win32
		{9CCCAE98-B542-4945-B0AE-D715140A50F5}.Debug|x86.Build.0 = Debug|Win32
		{9CCCAE98-B542-4945-B0AE-D715140A50F5}.Release|x64.ActiveCfg = Release|x64
		{9CCCAE98-B542-4945-B0AE-D715140A50F5}.Release|x64.Build.0 = Release|x64
		{9CCCAE98-B542-4945-B0AE-D715140A50F5}.Release|x86.ActiveCfg = Release|Win32
		{9CCCAE98-B542-4945-B0AE-D715140A50F5}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {9210B38D-54C5-4A08-A4E8-44CCAB4A61BA}
	EndGlobalSection
EndGlobal



================================================
File: LICENSE.md
================================================
MIT License

Copyright (c) 2021 Jonatan MatÄ›jka

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


================================================
File: CpuidSpoofer/CpuidSpoofer.vcxproj
================================================
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{9cccae98-b542-4945-b0ae-d715140a50f5}</ProjectGuid>
    <RootNamespace>CpuidSpoofer</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <TargetExt>.dp$(PlatformArchitecture)</TargetExt>
    <IncludePath>..\PluginTemplate\PluginTemplate;$(IncludePath)</IncludePath>
    <LibraryPath>..\PluginTemplate\PluginTemplate;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <TargetExt>.dp$(PlatformArchitecture)</TargetExt>
    <IncludePath>..\PluginTemplate\PluginTemplate;$(IncludePath)</IncludePath>
    <LibraryPath>..\PluginTemplate\PluginTemplate;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <TargetExt>.dp$(PlatformArchitecture)</TargetExt>
    <IncludePath>..\PluginTemplate\PluginTemplate;$(IncludePath)</IncludePath>
    <LibraryPath>..\PluginTemplate\PluginTemplate;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <TargetExt>.dp$(PlatformArchitecture)</TargetExt>
    <IncludePath>..\PluginTemplate\PluginTemplate;$(IncludePath)</IncludePath>
    <LibraryPath>..\PluginTemplate\PluginTemplate;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="dialog.cpp" />
    <ClCompile Include="presets.cpp" />
    <ClCompile Include="plugin.cpp" />
    <ClCompile Include="pluginmain.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="dialog.h" />
    <ClInclude Include="localdecoder.h" />
    <ClInclude Include="presets.h" />
    <ClInclude Include="plugin.h" />
    <ClInclude Include="pluginmain.h" />
    <ClInclude Include="resource.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="dialog.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>


================================================
File: CpuidSpoofer/CpuidSpoofer.vcxproj.filters
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="plugin.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="pluginmain.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="dialog.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="presets.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="plugin.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="pluginmain.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="dialog.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="presets.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="localdecoder.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="dialog.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>


================================================
File: CpuidSpoofer/INFO.txt
================================================
pluginmain.cpp and pluginmain.h are direct copies from PluginTemplate/PluginTemplate
plugin.h was copied and modified



================================================
File: CpuidSpoofer/dialog.cpp
================================================
#include <Windows.h>
#include <stdio.h>
#include "resource.h"

#include "presets.h"

#include <string>

std::wstring getWindowTextString(HWND hWnd) {
	std::wstring text;
	text.resize(GetWindowTextLengthW(hWnd));
	GetWindowTextW(hWnd, (LPWSTR)text.data(), (int)text.size() + 1);
	return text;
}

void enableSetRegister(HWND hDialog, UINT set, UINT mask, UINT value, BOOL enable) {
	if(enable)
		enable = IsDlgButtonChecked(hDialog, set);
	EnableWindow(GetDlgItem(hDialog, mask), enable);
	EnableWindow(GetDlgItem(hDialog, value), enable);
}

#pragma warning( disable : 4002 )

#define ENABLE_SET_INPUTS(register, enable) \
	enableSetRegister(hDialog, IDC_SET_ ## register, IDC_SET_ ## register ## _MASK, IDC_SET_ ## register ## _VALUE, enable)

#define ENABLE_SET_GROUP(register, enable) \
	do { \
		EnableWindow(GetDlgItem(hDialog, IDC_SET_ ## register), enable); \
		ENABLE_SET_INPUTS(register, enable); \
	} while(false)

#define ENABLE_ON_CLICKED_SET(register) \
	case IDC_SET_ ## register: \
		ENABLE_SET_INPUTS(register, TRUE); \
		return

#define FOR_EACH_REGISTER(statement, ...) \
	do { \
		statement(EAX, __VA_ARGS__); \
		statement(EBX, __VA_ARGS__); \
		statement(ECX, __VA_ARGS__); \
		statement(EDX, __VA_ARGS__); \
	} while(false)

void enableControls(HWND hDialog, UINT message, UINT control) {
	switch(message) {
	case BN_CLICKED:
		switch(control) {
		case IDC_TRIGGER_EAX:
		case IDC_TRIGGER_CUSTOM:
		{
			bool custom = control == IDC_TRIGGER_CUSTOM;
			EnableWindow(GetDlgItem(hDialog, IDC_TRIGGER_EAX_VALUE), custom ? FALSE : TRUE);
			EnableWindow(GetDlgItem(hDialog, IDC_TRIGGER_CUSTOM_VALUE), custom ? TRUE : FALSE);
			return;
		}
		case IDC_ACTION_VALUES:
		case IDC_ACTION_CUSTOM:
		{
			bool custom = control == IDC_ACTION_CUSTOM;
			FOR_EACH_REGISTER(ENABLE_SET_GROUP, custom ? FALSE : TRUE);
			EnableWindow(GetDlgItem(hDialog, IDC_ACTION_CUSTOM_VALUE), custom ? TRUE : FALSE);
			return;
		}
		FOR_EACH_REGISTER(ENABLE_ON_CLICKED_SET);
		}
	}
}

template<int maxLength>
class StringBuilder {
	WCHAR string[maxLength] = {};
	int position = 0;

public:
	void putChar(WCHAR c) {
		if(position < maxLength)
			string[position++] = c;
	}

	void putString(LPCWSTR str) {
		for(int i = 0; str[i] != L'\0'; i++)
			putChar(str[i]);
	}

	void putWindowText(HWND hWnd) {
		position += GetWindowTextW(hWnd, string + position, maxLength - position);
	}

	LPCWSTR getString() const {
		return string;
	}
};

void fillCustomTrigger(HWND hDialog) {
	StringBuilder<32> customValue;

	HWND hValue = GetDlgItem(hDialog, IDC_TRIGGER_EAX_VALUE);

	if(GetWindowTextLengthW(hValue) > 0) {
		customValue.putString(L"eax == ");
		customValue.putWindowText(GetDlgItem(hDialog, IDC_TRIGGER_EAX_VALUE));
	}
	SetWindowTextW(GetDlgItem(hDialog, IDC_TRIGGER_CUSTOM_VALUE), customValue.getString());
}

template<int maxLength>
void putCustomAction(StringBuilder<maxLength>* customValue, HWND hDialog, LPCWSTR name, UINT set, UINT mask, UINT value) {
	if(!IsDlgButtonChecked(hDialog, set))
	   return;
	HWND hMask = GetDlgItem(hDialog, mask);
	HWND hValue = GetDlgItem(hDialog, value);
	int maskLength = GetWindowTextLengthW(hMask);
	int valueLength = GetWindowTextLengthW(hValue);
	if(maskLength == 0 && valueLength == 0)
		return;
	customValue->putString(name);
	customValue->putString(L" = ");
	if(maskLength > 0) {
		if(valueLength > 0)
			customValue->putChar(L'(');

		customValue->putString(name);
		customValue->putString(L" & ~");
		customValue->putWindowText(hMask);

		if(valueLength > 0)
			customValue->putString(L") | ");
	}
	customValue->putWindowText(hValue);
	customValue->putString(L"; ");
}

#define PUT_CUSTOM_ACTION(register, registerName) \
	putCustomAction(&customValue, hDialog, registerName, IDC_SET_ ## register, IDC_SET_ ## register ## _MASK, IDC_SET_ ## register ## _VALUE)

void fillCustomAction(HWND hDialog) {
	StringBuilder<256> customValue;
	PUT_CUSTOM_ACTION(EAX, L"eax");
	PUT_CUSTOM_ACTION(EBX, L"ebx");
	PUT_CUSTOM_ACTION(ECX, L"ecx");
	PUT_CUSTOM_ACTION(EDX, L"edx");
	SetWindowTextW(GetDlgItem(hDialog, IDC_ACTION_CUSTOM_VALUE), customValue.getString());
}

#define FILL_ON_CHANGED(register) \
	case IDC_SET_ ## register ## _MASK: \
	case IDC_SET_ ## register ## _VALUE: \
		fillCustomAction(hDialog); \
		return

#define FILL_ON_CLICKED_SET(register) \
	case IDC_SET_ ## register: \
		fillCustomAction(hDialog); \
		return

void fillCustoms(HWND hDialog, UINT message, UINT control) {
	switch(message) {
	case EN_CHANGE:
		switch(control) {
		case IDC_TRIGGER_EAX_VALUE:
			fillCustomTrigger(hDialog);
			return;
			FOR_EACH_REGISTER(FILL_ON_CHANGED);
		}
	case BN_CLICKED:
		switch(control) {
		case IDC_TRIGGER_EAX:
			fillCustomTrigger(hDialog);
			return;
		case IDC_ACTION_VALUES:
			fillCustomAction(hDialog);
			FOR_EACH_REGISTER(FILL_ON_CLICKED_SET);
		}
	}
}

bool dirty = false;
int listIndex = CB_ERR;

std::wstring getSelectedPresetName(HWND hDialog) {
	std::wstring presetName;
	if(listIndex == CB_ERR)
		return presetName;
	HWND list = GetDlgItem(hDialog, IDC_LIST);
	presetName.resize(SendMessageW(list, LB_GETTEXTLEN, listIndex, 0));
	SendMessageW(list, LB_GETTEXT, listIndex, (LPARAM)presetName.data());
	return presetName;
}

#define LOAD_PRESET_REGISTERS(register) \
	do { \
		SendMessageW(GetDlgItem(hDialog, IDC_SET_ ## register), BM_SETCHECK, preset.actionRegisters[regIndex] ? BST_CHECKED : BST_UNCHECKED, 0); \
		SetWindowTextW(GetDlgItem(hDialog, IDC_SET_ ## register ## _MASK), preset.actionMasks[regIndex].c_str()); \
		SetWindowTextW(GetDlgItem(hDialog, IDC_SET_ ## register ## _VALUE), preset.actionValues[regIndex].c_str()); \
		regIndex++; \
	} while(false)

void fillFromPreset(HWND hDialog, const Preset& preset) {
	SetWindowTextW(GetDlgItem(hDialog, IDC_NAME), preset.name.c_str());
	SendMessageW(GetDlgItem(hDialog, IDC_ENABLED), BM_SETCHECK, preset.isEnabled ? BST_CHECKED : BST_UNCHECKED, 0);

	SetWindowTextW(GetDlgItem(hDialog, IDC_TRIGGER_EAX_VALUE), preset.triggerEaxValue.c_str());
	SetWindowTextW(GetDlgItem(hDialog, IDC_TRIGGER_CUSTOM_VALUE), preset.triggerCustomValue.c_str());

	int regIndex = 0;
	FOR_EACH_REGISTER(LOAD_PRESET_REGISTERS);
	SetWindowTextW(GetDlgItem(hDialog, IDC_ACTION_CUSTOM_VALUE), preset.actionCustomValue.c_str());

	SendMessageW(GetDlgItem(hDialog, preset.isTriggerCustom ? IDC_TRIGGER_CUSTOM : IDC_TRIGGER_EAX), BM_CLICK, 0, 0);
	SendMessageW(GetDlgItem(hDialog, preset.isActionCustom ? IDC_ACTION_CUSTOM : IDC_ACTION_VALUES), BM_CLICK, 0, 0);
	SetFocus(GetDlgItem(hDialog, IDC_LIST));

	dirty = false;
}

#define SAVE_PRESET_REGISTERS(register) \
	do { \
		preset.actionRegisters[regIndex] = SendMessageW(GetDlgItem(hDialog, IDC_SET_ ## register), BM_GETCHECK, 0, 0) == BST_CHECKED; \
		preset.actionMasks[regIndex] = getWindowTextString(GetDlgItem(hDialog, IDC_SET_ ## register ## _MASK)); \
		preset.actionValues[regIndex] = getWindowTextString(GetDlgItem(hDialog, IDC_SET_ ## register ## _VALUE)); \
		regIndex++; \
	} while(false)

void storeDialogToPreset(HWND hDialog) {
	Preset preset;
	preset.name = getWindowTextString(GetDlgItem(hDialog, IDC_NAME));
	if(preset.name.empty()) {
		MessageBoxW(hDialog, L"Name must be set!", L"Empty name", MB_OK);
		return;
	}
	preset.isEnabled = SendMessageW(GetDlgItem(hDialog, IDC_ENABLED), BM_GETCHECK, 0, 0) == BST_CHECKED;

	preset.isTriggerCustom = SendMessageW(GetDlgItem(hDialog, IDC_TRIGGER_CUSTOM), BM_GETCHECK, 0, 0) == BST_CHECKED;
	preset.triggerEaxValue = getWindowTextString(GetDlgItem(hDialog, IDC_TRIGGER_EAX_VALUE));
	preset.triggerCustomValue = getWindowTextString(GetDlgItem(hDialog, IDC_TRIGGER_CUSTOM_VALUE));

	preset.isActionCustom = SendMessageW(GetDlgItem(hDialog, IDC_ACTION_CUSTOM), BM_GETCHECK, 0, 0) == BST_CHECKED;
	int regIndex = 0;
	FOR_EACH_REGISTER(SAVE_PRESET_REGISTERS);
	preset.actionCustomValue = getWindowTextString(GetDlgItem(hDialog, IDC_ACTION_CUSTOM_VALUE));
	setPreset(preset);

	HWND list = GetDlgItem(hDialog, IDC_LIST);
	listIndex = (int)SendMessageW(list, LB_FINDSTRINGEXACT, -1, (LPARAM)preset.name.c_str());
	if(listIndex == LB_ERR) {
		listIndex = (int)SendMessageW(list, LB_ADDSTRING, 0, (LPARAM)preset.name.c_str());
	}
	SendMessageW(list, LB_SETCURSEL, listIndex, 0);

	dirty = false;
}

void deletePresetFromList(HWND hDialog) {
	if(listIndex == LB_ERR)
		return;

	if(MessageBoxW(hDialog, L"Are you sure you want to delete this preset?", L"Delete this preset", MB_YESNO) == IDNO)
		return;

	if(!deletePreset(getSelectedPresetName(hDialog)))
		return;

	SendMessageW(GetDlgItem(hDialog, IDC_LIST), LB_DELETESTRING, listIndex, 0);
	listIndex = CB_ERR;

	//clear the form
	fillFromPreset(hDialog, Preset());

	dirty = false;
}

bool checkForChanges(HWND hDialog) {
	if(!dirty)
		return true;
	return MessageBoxW(hDialog, L"This preset contains unsaved changes. Do you want to discard these changes?", L"Discard changes?", MB_OKCANCEL) == IDOK;
}

void onControlMessage(HWND hDialog, UINT message, UINT control) {
	//cancel button
	if(control == IDCANCEL) {
		if(checkForChanges(hDialog))
			EndDialog(hDialog, NULL);
		return;
	}
	
	//ok button
	if(control == IDOK) {
		storeDialogToPreset(hDialog);
		EndDialog(hDialog, NULL);
		return;
	}

	//apply button
	if(control == IDC_APPLY) {
		storeDialogToPreset(hDialog);
		return;
	}

	//delete button
	if(control == IDC_DELETE) {
		deletePresetFromList(hDialog);
		return;
	}

	//list control action
	if(control == IDC_LIST) {
		if(message == LBN_SELCHANGE) {
			HWND list = GetDlgItem(hDialog, IDC_LIST);
			if(!checkForChanges(hDialog)) {
				SendMessageW(list, LB_SETCURSEL, listIndex, 0);
				return;
			}

			listIndex = (int)SendMessageW(list, LB_GETCURSEL, 0, 0);
			auto preset = getPreset(getSelectedPresetName(hDialog));
			fillFromPreset(hDialog, preset);
		}
		return;
	}

	if(message == BN_CLICKED || message == EN_CHANGE) {
		dirty = true;
	}

	//other control action
	enableControls(hDialog, message, control);
	fillCustoms(hDialog, message, control);
}

void initDialog(HWND hDialog) {
	//center the dialog
	{
		RECT dialogRect;
		GetWindowRect(hDialog, &dialogRect);
		HWND parent = GetParent(hDialog);
		RECT parentRect;
		GetWindowRect(parent, &parentRect);

		int x = ((parentRect.right - parentRect.left) - (dialogRect.right - dialogRect.left)) / 2 + parentRect.left;
		int y = ((parentRect.bottom - parentRect.top) - (dialogRect.bottom - dialogRect.top)) / 2 + parentRect.top;
		SetWindowPos(hDialog, 0, x, y, 0, 0, SWP_ASYNCWINDOWPOS | SWP_NOACTIVATE | SWP_NOOWNERZORDER | SWP_NOSIZE | SWP_NOZORDER);
	}

	{
		auto font = (HFONT)GetStockObject(ANSI_FIXED_FONT);
		HWND ignoreControl = GetDlgItem(hDialog, IDC_NAME);
		HWND hControl = NULL;
		while(true) {
			hControl = FindWindowExW(hDialog, hControl, L"Edit", NULL);
			if(hControl == NULL)
				break;
			if(hControl == ignoreControl)
				continue;
			SendMessageW(hControl, WM_SETFONT, (WPARAM)font, 0);
		}
	}

	HWND list = GetDlgItem(hDialog, IDC_LIST);
	for(const auto& presetName : getPresetNames()) {
		SendMessageW(list, LB_ADDSTRING, 0, (LPARAM)presetName.c_str());
	}
	listIndex = (int)SendMessageW(list, LB_ADDSTRING, 0, (LPARAM)L"(New preset)");
	SendMessageW(list, LB_SETCURSEL, listIndex, 0);

	//clear the form
	fillFromPreset(hDialog, Preset());
}

INT_PTR CALLBACK onDialogMessage(HWND hDialog, UINT message, WPARAM wParam, LPARAM lParam) {
	switch(message) {
	case WM_INITDIALOG:
		initDialog(hDialog);
		return TRUE;
	case WM_COMMAND:
		onControlMessage(hDialog, HIWORD(wParam), LOWORD(wParam));
		return TRUE;
	case WM_CLOSE:
		if(checkForChanges(hDialog))
			EndDialog(hDialog, NULL);
		return TRUE;
	}
	return FALSE;
}

HINSTANCE hInst;

void showPresetsDialog(HWND hWndParent) {
	dirty = false;
	DialogBoxW(hInst, MAKEINTRESOURCE(IDD_PRESETS), hWndParent, &onDialogMessage);
	;
}

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved) {
	if(fdwReason == DLL_PROCESS_ATTACH) {
		hInst = hinstDLL;

		WCHAR pluginPath[MAX_PATH];
		DWORD pluginPathLen = GetModuleFileNameW(hInst, pluginPath, MAX_PATH);
		if(pluginPathLen == 0)
			return FALSE;

		WCHAR* presetsFile = pluginPath;
		int presetsFileLen = pluginPathLen;
		while(presetsFile[presetsFileLen] != L'.' && presetsFileLen)
			presetsFileLen--;

		if(!presetsFileLen)
			return FALSE;

		presetsFile[presetsFileLen++] = L'.';
		presetsFile[presetsFileLen++] = L'd';
		presetsFile[presetsFileLen++] = L'a';
		presetsFile[presetsFileLen++] = L't';
		presetsFile[presetsFileLen++] = L'\0';
		loadPresets(presetsFile);
	}
	return TRUE;
}



================================================
File: CpuidSpoofer/dialog.h
================================================
#pragma once

void showPresetsDialog(HWND hWndParent);


================================================
File: CpuidSpoofer/dialog.rc
================================================
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
#pragma code_page(1252)

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Dialog
//

IDD_PRESETS DIALOGEX 0, 0, 417, 182
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Presets"
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    LISTBOX         IDC_LIST,6,6,96,168,LBS_SORT | LBS_NOINTEGRALHEIGHT | WS_VSCROLL | WS_TABSTOP
    EDITTEXT        IDC_NAME,132,6,78,12,ES_AUTOHSCROLL
    CONTROL         "Enabled",IDC_ENABLED,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,372,6,36,12
    CONTROL         "EAX value",IDC_TRIGGER_EAX,"Button",BS_AUTORADIOBUTTON | WS_GROUP | WS_TABSTOP,114,36,48,14
    EDITTEXT        IDC_TRIGGER_EAX_VALUE,168,36,54,14,ES_AUTOHSCROLL | WS_DISABLED
    CONTROL         "Custom",IDC_TRIGGER_CUSTOM,"Button",BS_AUTORADIOBUTTON | WS_TABSTOP,114,54,40,14
    EDITTEXT        IDC_TRIGGER_CUSTOM_VALUE,168,54,234,14,ES_AUTOHSCROLL | WS_DISABLED
    CONTROL         "Set values",IDC_ACTION_VALUES,"Button",BS_AUTORADIOBUTTON | WS_GROUP | WS_TABSTOP,114,84,49,10
    CONTROL         "Set EAX",IDC_SET_EAX,"Button",BS_AUTOCHECKBOX | WS_DISABLED | WS_TABSTOP,168,84,41,10
    EDITTEXT        IDC_SET_EAX_MASK,168,96,54,14,ES_AUTOHSCROLL | WS_DISABLED
    EDITTEXT        IDC_SET_EAX_VALUE,168,114,54,14,ES_AUTOHSCROLL | WS_DISABLED
    CONTROL         "Set EBX",IDC_SET_EBX,"Button",BS_AUTOCHECKBOX | WS_DISABLED | WS_TABSTOP,228,84,41,10
    EDITTEXT        IDC_SET_EBX_MASK,228,96,54,14,ES_AUTOHSCROLL | WS_DISABLED
    EDITTEXT        IDC_SET_EBX_VALUE,228,114,54,14,ES_AUTOHSCROLL | WS_DISABLED
    CONTROL         "Set ECX",IDC_SET_ECX,"Button",BS_AUTOCHECKBOX | WS_DISABLED | WS_TABSTOP,288,84,41,10
    EDITTEXT        IDC_SET_ECX_MASK,288,96,54,14,ES_AUTOHSCROLL | WS_DISABLED
    EDITTEXT        IDC_SET_ECX_VALUE,288,114,54,14,ES_AUTOHSCROLL | WS_DISABLED
    CONTROL         "Set EDX",IDC_SET_EDX,"Button",BS_AUTOCHECKBOX | WS_DISABLED | WS_TABSTOP,348,84,41,10
    EDITTEXT        IDC_SET_EDX_MASK,348,96,54,14,ES_AUTOHSCROLL | WS_DISABLED
    EDITTEXT        IDC_SET_EDX_VALUE,348,114,54,14,ES_AUTOHSCROLL | WS_DISABLED
    CONTROL         "Custom",IDC_ACTION_CUSTOM,"Button",BS_AUTORADIOBUTTON | WS_TABSTOP,114,132,40,12
    EDITTEXT        IDC_ACTION_CUSTOM_VALUE,168,132,234,14,ES_AUTOHSCROLL | WS_DISABLED
    PUSHBUTTON      "Delete",IDC_DELETE,108,156,54,18
    PUSHBUTTON      "Apply",IDC_APPLY,294,156,54,18
    DEFPUSHBUTTON   "OK",IDOK,354,156,54,18
    LTEXT           "Name",IDC_STATIC,108,6,24,12,SS_CENTERIMAGE
    GROUPBOX        "Trigger condition",IDC_STATIC,108,24,300,48
    GROUPBOX        "Action",IDC_STATIC,108,72,300,78
    RTEXT           "Mask",IDC_STATIC,132,96,30,12,SS_CENTERIMAGE
    RTEXT           "Value",IDC_STATIC,132,114,30,12,SS_CENTERIMAGE
END


/////////////////////////////////////////////////////////////////////////////
//
// DESIGNINFO
//

#ifdef APSTUDIO_INVOKED
GUIDELINES DESIGNINFO
BEGIN
    IDD_PRESETS, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 410
        TOPMARGIN, 7
        BOTTOMMARGIN, 175
    END
END
#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// AFX_DIALOG_LAYOUT
//

IDD_PRESETS AFX_DIALOG_LAYOUT
BEGIN
    0,
    0, 0, 0, 100,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0
END

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED




================================================
File: CpuidSpoofer/localdecoder.h
================================================
#pragma once
#include "plugin.h"
#include <queue>

class LocalDecoder {
	enum class PositionType {
		DESIRED,
		OTHER,

		MAX_TYPES
	};

	struct QPosition {
		duint addr;
		PositionType type;

		QPosition(duint addr, PositionType type) {
			this->addr = addr;
			this->type = type;
		}
		constexpr bool operator<(const QPosition& that) const {
			return this->addr < that.addr;
		}
	};

	const int maxInstructionLength = 16;
	const int maxSteps = 256;

	duint addr;
	int instructionLength;
	std::priority_queue<QPosition> queue;
	int count[(int)PositionType::MAX_TYPES] = {};

	void QAdd(duint addr, PositionType type) {
		queue.emplace(addr, type);
		count[(int)type]++;
	}

	QPosition QGet() {
		QPosition position = queue.top();
		queue.pop();
		count[(int)position.type]--;
		return position;
	}

public:
	LocalDecoder(duint addr, int instructionLength) : addr(addr), instructionLength(instructionLength) {}

	bool IsDesired() {
		//check possible disassembly after
		BASIC_INSTRUCTION_INFO info;
		DbgDisasmFastAt(addr + instructionLength, &info);
		if(info.instruction[0] == '?')
			return false;

		//check possible disassemblies before
		QAdd(addr, PositionType::DESIRED);
		for(int offset = 1; offset <= maxInstructionLength; offset++) {
			DbgDisasmFastAt(addr - offset, &info);
			if(info.size > offset && info.instruction[0] != '?')
				QAdd(addr - offset, PositionType::OTHER);
		}
		int steps = 0;
		while(count[(int)PositionType::DESIRED] > 0 && count[(int)PositionType::OTHER] > 0 && steps < maxSteps) {
			QPosition pos = QGet();
			for(int offset = 1; offset <= maxInstructionLength; offset++) {
				memset(&info, 0, sizeof(info));
				DbgDisasmFastAt(pos.addr - offset, &info);
				if(info.size == offset && info.instruction[0] != '?')
					QAdd(pos.addr - offset, pos.type);
			}
			steps++;
		}
		if(steps >= maxSteps) {
			dprintf("Couldn't decide the decoding of an instuction at " DUINT_FMT " after %d steps! Please inspect the breakpoint manually.\n", addr, steps);
			return true;
		}
		return count[(int)PositionType::DESIRED] > 0;
	}
};


================================================
File: CpuidSpoofer/plugin.cpp
================================================
#include "plugin.h"
#include <string>
#include <unordered_map>
#include <unordered_set>
#include "localdecoder.h"
#include "dialog.h"
#include "presets.h"

enum class MenuEntries {
	OPTIONS_DIALOG,
	SET_BPS,
	SET_BP_HERE,
	REMOVE_BPS,
};

const unsigned char cpuidBytes[2] = {0x0F, 0xA2};

bool checkCpuidAt(duint addr) {
	BASIC_INSTRUCTION_INFO info;
	DbgDisasmFastAt(addr, &info);
	return strcmp("cpuid", info.instruction) == 0;
}

std::unordered_map<duint, std::string> actions;

bool onCpuidSpooferBegin(int argc, char** argv) {
	duint cip = GetContextData(UE_CIP);
	if(!checkCpuidAt(cip)) {
		dprintf("Not a CPUID instruction on current address " DUINT_FMT "!\n", cip);
		return false;
	}

	auto actionIt = actions.find(cip);
	if(actionIt != actions.cend()) {
		dprintf("Overwriting previous stored action at address " DUINT_FMT "!\n", cip);
		actions.erase(cip);
	}

	DbgCmdExecDirect("$breakpointcondition=0");

	std::string action;
	for(const auto& preset : getEnabledPresets()) {
		auto trigger = preset.getTrigger();
		bool triggerOk;
		if(DbgEval(trigger.c_str(), &triggerOk) && triggerOk) {
			action.append(";");
			action.append(preset.getAction());
		}
		else if(!triggerOk) {
			dprintf("Failed to evaluate trigger condition of preset %s!\n", preset.getName().c_str());
			DbgCmdExecDirect("$breakpointcondition=1");
		}
	}

	actions.emplace(cip, action);
	return true;
}

bool onCpuidSpooferEnd(int argc, char** argv) {
	duint prevCip = GetContextData(UE_CIP) - sizeof(cpuidBytes);
	if(!checkCpuidAt(prevCip)) {
		dprintf("Not a CPUID instruction on previous address " DUINT_FMT "!\n", prevCip);
		return false;
	}
	auto actionIt = actions.find(prevCip);
	if(actionIt == actions.cend()) {
		dprintf("No action stored on previous address " DUINT_FMT "!\n", prevCip);
		return false;
	}

	DbgCmdExecDirect("$breakpointcondition=0");
	const auto& action = actionIt->second;
	if(!DbgCmdExecDirect(action.c_str())) {
		dprintf("Failed to execute an action: %s!\n", action.c_str());
		DbgCmdExecDirect("$breakpointcondition=1");
	}
	actions.erase(actionIt);

	return true;
}

#define COMMAND_BEGIN "CpuidSpooferBegin"
#define COMMAND_END "CpuidSpooferEnd"

bool pluginInit(PLUG_INITSTRUCT* initStruct) {
	_plugin_registercommand(pluginHandle, COMMAND_BEGIN, onCpuidSpooferBegin, true);
	_plugin_registercommand(pluginHandle, COMMAND_END, onCpuidSpooferEnd, true);
	return true;
}

void pluginStop() {}

void pluginSetup() {
	_plugin_menuaddentry(hMenu, (int)MenuEntries::OPTIONS_DIALOG, "&Options");
	_plugin_menuaddentry(hMenu, (int)MenuEntries::SET_BPS, "Find CPUIDs and &set breakpoints");
	_plugin_menuaddentry(hMenu, (int)MenuEntries::SET_BP_HERE, "Set breakpoint &here");
	_plugin_menuaddentry(hMenu, (int)MenuEntries::REMOVE_BPS, "&Remove all Breakpoints");
}

void setBreakpoint(duint addr) {
	char cmdBuffer[256];
	//Create "begin" breakpoint
	sprintf_s(cmdBuffer, "SetBPX " DUINT_FMT ", \"" PLUGIN_NAME " " DUINT_FMT " begin\"", addr, addr);
	if(!DbgCmdExecDirect(cmdBuffer)) {
		dprintf("Breakpoint on address " DUINT_FMT " already set!\n", addr);
		return;
	}
	sprintf_s(cmdBuffer, "SetBreakpointCommand " DUINT_FMT ", \"" COMMAND_BEGIN "\"", addr);
	DbgCmdExecDirect(cmdBuffer);

	//Create "end" breakpoint
	duint endAddr = addr + sizeof(cpuidBytes);
	sprintf_s(cmdBuffer, "SetBPX " DUINT_FMT ", \"" PLUGIN_NAME " " DUINT_FMT " end\"", endAddr, addr);
	if(!DbgCmdExecDirect(cmdBuffer)) {
		dprintf("Breakpoint on address " DUINT_FMT " already set!\n", endAddr);
		//Delete "begin" breakpoint
		sprintf_s(cmdBuffer, "DeleteBPX " DUINT_FMT, addr);
		DbgCmdExecDirect(cmdBuffer);
		return;
	}
	sprintf_s(cmdBuffer, "SetBreakpointCommand " DUINT_FMT ", \"" COMMAND_END "\"", endAddr);
	DbgCmdExecDirect(cmdBuffer);
}

void maybeSetBreakpoint(duint addr, const std::unordered_set<duint>& knownBPs) {
	if(knownBPs.find(addr) != knownBPs.cend())
		return;
	LocalDecoder localDecoder(addr, sizeof(cpuidBytes));
	if(!localDecoder.IsDesired())
		return;
	setBreakpoint(addr);
}

std::unordered_set<duint> getKnownBreakpoints() {
	std::unordered_set<duint> knownBPs;

	BPMAP bpMap;
	memset(&bpMap, 0, sizeof(bpMap));
	DbgGetBpList(bp_normal, &bpMap);
	for(int bpIdx = 0; bpIdx < bpMap.count; bpIdx++) {
		const auto& bp = bpMap.bp[bpIdx];
		if(strncmp(PLUGIN_NAME, bp.name, sizeof(PLUGIN_NAME) - 1) == 0) {
			knownBPs.emplace(bp.addr);
		}
	}
	if(bpMap.count > 0)
		BridgeFree(bpMap.bp);
	return knownBPs;
}

const int pageBufferSize = PAGE_SIZE;
unsigned char pageBuffer[pageBufferSize];

void setBreakpoints() {
	MEMMAP memMap;
	memset(&memMap, 0, sizeof(memMap));
	auto memMapOk = DbgMemMap(&memMap);
	if(!memMapOk) {
		dprintf("Failed to get memory map!\n");
		return;
	}

	const auto knownBPs = getKnownBreakpoints();

	duint firstByteMatch = 0;
	for(int pageIdx = 0; pageIdx < memMap.count; pageIdx++) {
		const auto& page = memMap.page[pageIdx];
		if((page.mbi.Protect & (PAGE_EXECUTE | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY)) == 0)
			continue;
		duint baseAddr = (duint)page.mbi.BaseAddress;
		for(duint pageAddr = baseAddr; pageAddr < baseAddr + page.mbi.RegionSize; pageAddr += pageBufferSize) {
			auto memReadOk = DbgMemRead(pageAddr, pageBuffer, pageBufferSize);
			if(!memReadOk) {
				dprintf("Failed to read memory chunk " DUINT_FMT " - " DUINT_FMT "!\n", pageAddr, pageAddr + pageBufferSize);
				continue;
			}
			if(firstByteMatch + 1 == pageAddr && pageBuffer[0] == cpuidBytes[1]) {
				maybeSetBreakpoint(firstByteMatch, knownBPs);
			}
			for(int byteIdx = 0; byteIdx < pageBufferSize; byteIdx++) {
				if(pageBuffer[byteIdx] == cpuidBytes[0]) {
					duint byteAddr = pageAddr + byteIdx;
					if(byteIdx + 1 == pageBufferSize) {
						firstByteMatch = byteAddr;
					}
					else if(pageBuffer[byteIdx + 1] == cpuidBytes[1]) {
						maybeSetBreakpoint(byteAddr, knownBPs);
					}
				}
			}
		}
	}
	BridgeFree(memMap.page);
}

void removeBreakpoints() {
	char cmdBuffer[256];
	for(duint addr : getKnownBreakpoints()) {
		sprintf_s(cmdBuffer, "DeleteBPX " DUINT_FMT, addr);
		DbgCmdExecDirect(cmdBuffer);
	}
}

PLUG_EXPORT void CBMENUENTRY(CBTYPE cbType, PLUG_CB_MENUENTRY* info) {
	switch((MenuEntries)info->hEntry) {
	case MenuEntries::OPTIONS_DIALOG:
		showPresetsDialog(hwndDlg);
		return;
	case MenuEntries::SET_BPS:
		setBreakpoints();
		return;
	case MenuEntries::SET_BP_HERE:
		SELECTIONDATA selection;
		GuiSelectionGet(GUI_DISASSEMBLY, &selection);
		maybeSetBreakpoint(selection.start, getKnownBreakpoints());
		return;
	case MenuEntries::REMOVE_BPS:
		removeBreakpoints();
		return;
	}
	assert(false);
}



================================================
File: CpuidSpoofer/plugin.h
================================================
#pragma once

#include "pluginmain.h"

//plugin data
#define PLUGIN_NAME "CPUID Spoofer"
#define PLUGIN_VERSION 1

//functions
bool pluginInit(PLUG_INITSTRUCT* initStruct);
void pluginStop();
void pluginSetup();

#ifdef _WIN64
#define DUINT_FMT "0x%016llX"
#else
#define DUINT_FMT "0x%016lX"
#endif //_WIN64


================================================
File: CpuidSpoofer/pluginmain.cpp
================================================
#include "pluginmain.h"
#include "plugin.h"

int pluginHandle;
HWND hwndDlg;
int hMenu;
int hMenuDisasm;
int hMenuDump;
int hMenuStack;

PLUG_EXPORT bool pluginit(PLUG_INITSTRUCT* initStruct)
{
    initStruct->pluginVersion = PLUGIN_VERSION;
    initStruct->sdkVersion = PLUG_SDKVERSION;
    strncpy_s(initStruct->pluginName, PLUGIN_NAME, _TRUNCATE);
    pluginHandle = initStruct->pluginHandle;
    return pluginInit(initStruct);
}

PLUG_EXPORT bool plugstop()
{
    pluginStop();
    return true;
}

PLUG_EXPORT void plugsetup(PLUG_SETUPSTRUCT* setupStruct)
{
    hwndDlg = setupStruct->hwndDlg;
    hMenu = setupStruct->hMenu;
    hMenuDisasm = setupStruct->hMenuDisasm;
    hMenuDump = setupStruct->hMenuDump;
    hMenuStack = setupStruct->hMenuStack;
    pluginSetup();
}


================================================
File: CpuidSpoofer/pluginmain.h
================================================
#pragma once

#include "pluginsdk/bridgemain.h"
#include "pluginsdk/_plugins.h"

#include "pluginsdk/_scriptapi_argument.h"
#include "pluginsdk/_scriptapi_assembler.h"
#include "pluginsdk/_scriptapi_bookmark.h"
#include "pluginsdk/_scriptapi_comment.h"
#include "pluginsdk/_scriptapi_debug.h"
#include "pluginsdk/_scriptapi_flag.h"
#include "pluginsdk/_scriptapi_function.h"
#include "pluginsdk/_scriptapi_gui.h"
#include "pluginsdk/_scriptapi_label.h"
#include "pluginsdk/_scriptapi_memory.h"
#include "pluginsdk/_scriptapi_misc.h"
#include "pluginsdk/_scriptapi_module.h"
#include "pluginsdk/_scriptapi_pattern.h"
#include "pluginsdk/_scriptapi_register.h"
#include "pluginsdk/_scriptapi_stack.h"
#include "pluginsdk/_scriptapi_symbol.h"

#include "pluginsdk/capstone/capstone.h"
#include "pluginsdk/DeviceNameResolver/DeviceNameResolver.h"
#include "pluginsdk/jansson/jansson.h"
#include "pluginsdk/lz4/lz4file.h"
#include "pluginsdk/TitanEngine/TitanEngine.h"
#include "pluginsdk/XEDParse/XEDParse.h"
#include "pluginsdk/yara/yara.h"

#ifdef _WIN64
#pragma comment(lib, "pluginsdk/x64dbg.lib")
#pragma comment(lib, "pluginsdk/x64bridge.lib")
#pragma comment(lib, "pluginsdk/capstone/capstone_x64.lib")
#pragma comment(lib, "pluginsdk/DeviceNameResolver/DeviceNameResolver_x64.lib")
#pragma comment(lib, "pluginsdk/jansson/jansson_x64.lib")
#pragma comment(lib, "pluginsdk/lz4/lz4_x64.lib")
#pragma comment(lib, "pluginsdk/TitanEngine/TitanEngine_x64.lib")
#pragma comment(lib, "pluginsdk/XEDParse/XEDParse_x64.lib")
#pragma comment(lib, "pluginsdk/yara/yara_x64.lib")
#else
#pragma comment(lib, "pluginsdk/x32dbg.lib")
#pragma comment(lib, "pluginsdk/x32bridge.lib")
#pragma comment(lib, "pluginsdk/capstone/capstone_x86.lib")
#pragma comment(lib, "pluginsdk/DeviceNameResolver/DeviceNameResolver_x86.lib")
#pragma comment(lib, "pluginsdk/jansson/jansson_x86.lib")
#pragma comment(lib, "pluginsdk/lz4/lz4_x86.lib")
#pragma comment(lib, "pluginsdk/TitanEngine/TitanEngine_x86.lib")
#pragma comment(lib, "pluginsdk/XEDParse/XEDParse_x86.lib")
#pragma comment(lib, "pluginsdk/yara/yara_x86.lib")
#endif //_WIN64

#define Cmd(x) DbgCmdExecDirect(x)
#define Eval(x) DbgValFromString(x)
#define dprintf(x, ...) _plugin_logprintf("[" PLUGIN_NAME "] " x, __VA_ARGS__)
#define dputs(x) _plugin_logputs("[" PLUGIN_NAME "] " x)
#define PLUG_EXPORT extern "C" __declspec(dllexport)

//superglobal variables
extern int pluginHandle;
extern HWND hwndDlg;
extern int hMenu;
extern int hMenuDisasm;
extern int hMenuDump;
extern int hMenuStack;


================================================
File: CpuidSpoofer/presets.cpp
================================================
ï»¿#include "presets.h"

#include <Windows.h>

const int fileVersion = 1;
std::vector<Preset> presets;
Preset emptyPreset;

const int maxFilenameLen = 1024;
wchar_t filename[maxFilenameLen];

void loadString(std::wstring& string, FILE* file) {
	int strlen = 0;
	fread(&strlen, sizeof(strlen), 1, file);
	string.resize(strlen);
	fread(&string[0], sizeof(string[0]), strlen, file);
}

void loadPreset(Preset& preset, FILE* file) {
	loadString(preset.name, file);
	fread(&preset.isEnabled, sizeof(preset.isEnabled), 1, file);

	fread(&preset.isTriggerCustom, sizeof(preset.isTriggerCustom), 1, file);
	loadString(preset.triggerEaxValue, file);
	loadString(preset.triggerCustomValue, file);

	fread(&preset.isActionCustom, sizeof(preset.isActionCustom), 1, file);
	for(int i = 0; i < 4; i++) {
		fread(&preset.actionRegisters[i], sizeof(preset.actionRegisters[i]), 1, file);
		loadString(preset.actionMasks[i], file);
		loadString(preset.actionValues[i], file);
	}
	loadString(preset.actionCustomValue, file);
}

void loadPresets(const wchar_t* inFilename) {
	for(int i = 0; i < maxFilenameLen; i++) {
		filename[i] = inFilename[i];
		if(filename[i] == L'\0')
			break;
	}
	FILE* file;
	_wfopen_s(&file, filename, L"rb");
	if(file == NULL)
		return;

	int version = 0;
	fread(&version, sizeof(version), 1, file);
	if(version == fileVersion) {
		int numPresets = 0;
		fread(&numPresets, sizeof(numPresets), 1, file);
		presets.resize(numPresets);
		for(int i = 0; i < numPresets; i++) {
			loadPreset(presets[i], file);
		}
	}
	fclose(file);
}

void saveString(const std::wstring& string, FILE* file) {
	int strlen = (int)string.length();
	fwrite(&strlen, sizeof(strlen), 1, file);
	fwrite(&string[0], sizeof(string[0]), strlen, file);
}

void savePreset(const Preset& preset, FILE* file) {
	saveString(preset.name, file);
	fwrite(&preset.isEnabled, sizeof(preset.isEnabled), 1, file);

	fwrite(&preset.isTriggerCustom, sizeof(preset.isTriggerCustom), 1, file);
	saveString(preset.triggerEaxValue, file);
	saveString(preset.triggerCustomValue, file);

	fwrite(&preset.isActionCustom, sizeof(preset.isActionCustom), 1, file);
	for(int i = 0; i < 4; i++) {
		fwrite(&preset.actionRegisters[i], sizeof(preset.actionRegisters[i]), 1, file);
		saveString(preset.actionMasks[i], file);
		saveString(preset.actionValues[i], file);
	}
	saveString(preset.actionCustomValue, file);
}

void savePresets() {
	if(filename[0] == L'\0')
		return;

	FILE* file;
	_wfopen_s(&file, filename, L"wb");
	if(file == NULL)
		return;
	fwrite(&fileVersion, sizeof(fileVersion), 1, file);
	int numPresets = (int)presets.size();
	fwrite(&numPresets, sizeof(numPresets), 1, file);
	for(const auto& preset : presets) {
		savePreset(preset, file);
	}
	fclose(file);
}

std::vector<std::wstring> getPresetNames() {
	std::vector<std::wstring> names;
	for(const auto& preset : presets) {
		names.emplace_back(preset.name);
	}
	return names;
}

const Preset& getPreset(const std::wstring& name) {
	for(const auto& preset : presets) {
		if(preset.name == name)
			return preset;
	}
	return emptyPreset;
}

void setPreset(const Preset& preset) {
	for(auto& existingPreset : presets) {
		if(existingPreset.name == preset.name) {
			existingPreset = preset;
			goto setPresetSave;
		}
	}
	presets.emplace_back(preset);
setPresetSave:
	savePresets();
}

bool deletePreset(const std::wstring& name) {
	for(auto presetIt = presets.cbegin(); presetIt != presets.cend(); ++presetIt) {
		if(presetIt->name == name) {
			presets.erase(presetIt);
			savePresets();
			return true;
		}
	}
	return false;
}

std::string wstringToString(const std::wstring& wstr) {
	int len = WideCharToMultiByte(CP_UTF8, 0, wstr.c_str(), (int)wstr.length(), nullptr, 0, NULL, NULL);
	std::string str;
	str.resize(len);
	WideCharToMultiByte(CP_UTF8, 0, wstr.c_str(), (int)wstr.length(), &str[0], len, NULL, NULL);
	return str;
}

std::string Preset::getName() const{
	return wstringToString(this->name);
}

std::string Preset::getTrigger() const{
	return wstringToString(this->triggerCustomValue);
}

std::string Preset::getAction() const{
	return wstringToString(this->actionCustomValue);
}

std::vector<Preset> getEnabledPresets() {
	std::vector<Preset> enabledPresets;
	for(const auto& preset : presets)
		if(preset.isEnabled)
			enabledPresets.emplace_back(preset);

	return enabledPresets;
}


================================================
File: CpuidSpoofer/presets.h
================================================
#pragma once
#include <string>
#include <vector>

// when modyfing this struct, make sure you also modify:
// > the dialog, if necessary
// > loadPreset()
// > savePreset()
// > increment fileVersion

struct Preset {
	std::wstring name;
	bool isEnabled = true;

	bool isTriggerCustom = false;
	std::wstring triggerEaxValue;
	std::wstring triggerCustomValue;

	bool isActionCustom = false;
	bool actionRegisters[4] = {};
	std::wstring actionMasks[4];
	std::wstring actionValues[4];
	std::wstring actionCustomValue;

	std::string getName() const;
	std::string getTrigger() const;
	std::string getAction() const;
};

void loadPresets(const wchar_t* filename);
void savePresets();

std::vector<std::wstring> getPresetNames();
const Preset& getPreset(const std::wstring& name);
void setPreset(const Preset& preset);
bool deletePreset(const std::wstring& name);

std::vector<Preset> getEnabledPresets();



================================================
File: CpuidSpoofer/resource.h
================================================
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by dialog.rc
//
#define IDD_PRESETS                     101
#define IDC_LIST                        1002
#define IDC_NAME                        1003
#define IDC_TRIGGER_EAX                 1004
#define IDC_TRIGGER_CUSTOM              1005
#define IDC_TRIGGER_EAX_VALUE           1006
#define IDC_TRIGGER_CUSTOM_VALUE        1007
#define IDC_SET_EAX_MASK                1008
#define IDC_ACTION_VALUES               1009
#define IDC_ACTION_CUSTOM               1010
#define IDC_SET_EAX                     1011
#define IDC_SET_EBX                     1012
#define IDC_SET_ECX                     1013
#define IDC_SET_EDX                     1014
#define IDC_SET_EAX_VALUE               1015
#define IDC_SET_EBX_MASK                1016
#define IDC_SET_EBX_VALUE               1017
#define IDC_SET_ECX_MASK                1018
#define IDC_SET_ECX_VALUE               1019
#define IDC_SET_EDX_MASK                1020
#define IDC_SET_EDX_VALUE               1021
#define IDC_ACTION_CUSTOM_VALUE         1022
#define IDC_APPLY                       1024
#define IDC_DELETE                      1025
#define IDC_CHECK1                      1026
#define IDC_ENABLED                     1026

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1027
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif




================================================
File: .github/workflows/msbuild.yml
================================================
name: MSBuild

on: [push]

jobs:
  build:
    runs-on: windows-latest
    strategy:
      matrix:
        platform: [x64, x86]
    steps:
    - name: Checkout
      uses: actions/checkout@v2
      with:
        submodules: recursive

    - name: Add MSBuild to PATH
      uses: microsoft/setup-msbuild@v1

    - name: Build
      working-directory: ${{env.GITHUB_WORKSPACE}}
      run: msbuild /m /p:Configuration=Release /p:Platform=${{matrix.platform}} .

    - name: Release
      uses: softprops/action-gh-release@v1
      if: startsWith(github.ref, 'refs/tags/')
      with:
        files: |
          x64/Release/CpuidSpoofer.dp64
          Release/CpuidSpoofer.dp32
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}



Directory structure:
└── codecracker-tools-confuser-methods-decryptor/
    ├── Confuser_Methods_Decryptor.exe.config
    ├── Confuser_Methods_Decryptor.sln
    └── Confuser_Methods_Decryptor/
        ├── Confuser_Methods_Decryptor.csproj
        ├── MainForm.Designer.cs
        ├── MainForm.cs
        ├── MainForm.resx
        ├── Program.cs
        └── Properties/
            └── AssemblyInfo.cs

================================================
File: Confuser_Methods_Decryptor.exe.config
================================================
<configuration>
  <startup useLegacyV2RuntimeActivationPolicy="true">
    <supportedRuntime version="v4.0"/>
  </startup>
  <runtime>         
    <loadFromRemoteSources enabled="true"/>
  </runtime> 
</configuration>



================================================
File: Confuser_Methods_Decryptor.sln
================================================
ï»¿
Microsoft Visual Studio Solution File, Format Version 10.00
# Visual Studio 2008
# SharpDevelop 3.2.1.6466
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Confuser_Methods_Decryptor", "Confuser_Methods_Decryptor\Confuser_Methods_Decryptor.csproj", "{13B4F697-9A2D-41EC-B6DF-DFF2C22868DC}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x86 = Debug|x86
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{13B4F697-9A2D-41EC-B6DF-DFF2C22868DC}.Debug|x86.Build.0 = Debug|x86
		{13B4F697-9A2D-41EC-B6DF-DFF2C22868DC}.Debug|x86.ActiveCfg = Debug|x86
		{13B4F697-9A2D-41EC-B6DF-DFF2C22868DC}.Release|x86.Build.0 = Release|x86
		{13B4F697-9A2D-41EC-B6DF-DFF2C22868DC}.Release|x86.ActiveCfg = Release|x86
	EndGlobalSection
EndGlobal



================================================
File: Confuser_Methods_Decryptor/Confuser_Methods_Decryptor.csproj
================================================
ï»¿<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ProjectGuid>{13B4F697-9A2D-41EC-B6DF-DFF2C22868DC}</ProjectGuid>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">x86</Platform>
    <OutputType>WinExe</OutputType>
    <RootNamespace>Confuser_Methods_Decryptor</RootNamespace>
    <AssemblyName>Confuser_Methods_Decryptor</AssemblyName>
    <TargetFrameworkVersion>v2.0</TargetFrameworkVersion>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <SourceAnalysisOverrideSettingsFile>C:\Documents and Settings\Mihai\Application Data\ICSharpCode/SharpDevelop3.0\Settings.SourceAnalysis</SourceAnalysisOverrideSettingsFile>
    <AllowUnsafeBlocks>True</AllowUnsafeBlocks>
    <NoStdLib>False</NoStdLib>
    <WarningLevel>4</WarningLevel>
    <TreatWarningsAsErrors>false</TreatWarningsAsErrors>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Platform)' == 'x86' ">
    <PlatformTarget>x86</PlatformTarget>
    <RegisterForComInterop>False</RegisterForComInterop>
    <GenerateSerializationAssemblies>Auto</GenerateSerializationAssemblies>
    <BaseAddress>4194304</BaseAddress>
    <FileAlignment>4096</FileAlignment>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)' == 'Debug' ">
    <OutputPath>bin\Debug\</OutputPath>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>Full</DebugType>
    <Optimize>False</Optimize>
    <CheckForOverflowUnderflow>False</CheckForOverflowUnderflow>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)' == 'Release' ">
    <OutputPath>bin\Release\</OutputPath>
    <DebugSymbols>False</DebugSymbols>
    <DebugType>None</DebugType>
    <Optimize>True</Optimize>
    <CheckForOverflowUnderflow>False</CheckForOverflowUnderflow>
    <DefineConstants>TRACE</DefineConstants>
  </PropertyGroup>
  <Import Project="$(MSBuildBinPath)\Microsoft.CSharp.Targets" />
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Data" />
    <Reference Include="System.Drawing" />
    <Reference Include="System.Windows.Forms" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="MainForm.cs" />
    <Compile Include="MainForm.Designer.cs">
      <DependentUpon>MainForm.cs</DependentUpon>
    </Compile>
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <EmbeddedResource Include="MainForm.resx">
      <DependentUpon>MainForm.cs</DependentUpon>
    </EmbeddedResource>
  </ItemGroup>
</Project>


================================================
File: Confuser_Methods_Decryptor/MainForm.Designer.cs
================================================
ï»¿/*
 * Created by SharpDevelop.
 * User: Bogdan
 * Date: 29.12.2012
 * Time: 18:25
 * 
 * To change this template use Tools | Options | Coding | Edit Standard Headers.
 */
namespace Confuser_Methods_Decryptor
{
	partial class MainForm
	{
		/// <summary>
		/// Designer variable used to keep track of non-visual components.
		/// </summary>
		private System.ComponentModel.IContainer components = null;
		
		/// <summary>
		/// Disposes resources used by the form.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing) {
				if (components != null) {
					components.Dispose();
				}
			}
			base.Dispose(disposing);
		}
		
		/// <summary>
		/// This method is required for Windows Forms designer support.
		/// Do not change the method contents inside the source code editor. The Forms designer might
		/// not be able to load this method if it was changed manually.
		/// </summary>
		private void InitializeComponent()
		{
			this.textBox1 = new System.Windows.Forms.TextBox();
			this.label1 = new System.Windows.Forms.Label();
			this.button1 = new System.Windows.Forms.Button();
			this.textBox2 = new System.Windows.Forms.TextBox();
			this.label4 = new System.Windows.Forms.Label();
			this.button3 = new System.Windows.Forms.Button();
			this.button2 = new System.Windows.Forms.Button();
			this.label2 = new System.Windows.Forms.Label();
			this.label3 = new System.Windows.Forms.Label();
			this.SuspendLayout();
			// 
			// textBox1
			// 
			this.textBox1.AllowDrop = true;
			this.textBox1.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
									| System.Windows.Forms.AnchorStyles.Right)));
			this.textBox1.Location = new System.Drawing.Point(42, 43);
			this.textBox1.Name = "textBox1";
			this.textBox1.Size = new System.Drawing.Size(589, 20);
			this.textBox1.TabIndex = 21;
			this.textBox1.DragDrop += new System.Windows.Forms.DragEventHandler(this.TextBox1DragDrop);
			this.textBox1.DragEnter += new System.Windows.Forms.DragEventHandler(this.TextBox1DragEnter);
			// 
			// label1
			// 
			this.label1.BackColor = System.Drawing.Color.Transparent;
			this.label1.ForeColor = System.Drawing.Color.Black;
			this.label1.Location = new System.Drawing.Point(42, 25);
			this.label1.Name = "label1";
			this.label1.Size = new System.Drawing.Size(100, 14);
			this.label1.TabIndex = 20;
			this.label1.Text = "Name of assembly:";
			// 
			// button1
			// 
			this.button1.Location = new System.Drawing.Point(7, 42);
			this.button1.Name = "button1";
			this.button1.Size = new System.Drawing.Size(29, 20);
			this.button1.TabIndex = 19;
			this.button1.Text = "...";
			this.button1.UseVisualStyleBackColor = true;
			this.button1.Click += new System.EventHandler(this.Button1Click);
			// 
			// textBox2
			// 
			this.textBox2.AllowDrop = true;
			this.textBox2.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
									| System.Windows.Forms.AnchorStyles.Right)));
			this.textBox2.Location = new System.Drawing.Point(42, 82);
			this.textBox2.Name = "textBox2";
			this.textBox2.Size = new System.Drawing.Size(589, 20);
			this.textBox2.TabIndex = 37;
			this.textBox2.DragDrop += new System.Windows.Forms.DragEventHandler(this.TextBox2DragDrop);
			this.textBox2.DragEnter += new System.Windows.Forms.DragEventHandler(this.TextBox2DragEnter);
			// 
			// label4
			// 
			this.label4.BackColor = System.Drawing.Color.Transparent;
			this.label4.ForeColor = System.Drawing.Color.Black;
			this.label4.Location = new System.Drawing.Point(42, 65);
			this.label4.Name = "label4";
			this.label4.Size = new System.Drawing.Size(100, 14);
			this.label4.TabIndex = 36;
			this.label4.Text = "Additional module:";
			// 
			// button3
			// 
			this.button3.Location = new System.Drawing.Point(7, 82);
			this.button3.Name = "button3";
			this.button3.Size = new System.Drawing.Size(29, 20);
			this.button3.TabIndex = 35;
			this.button3.Text = "...";
			this.button3.UseVisualStyleBackColor = true;
			this.button3.Click += new System.EventHandler(this.Button3Click);
			// 
			// button2
			// 
			this.button2.Location = new System.Drawing.Point(42, 144);
			this.button2.Name = "button2";
			this.button2.Size = new System.Drawing.Size(75, 23);
			this.button2.TabIndex = 38;
			this.button2.Text = "Decrypt";
			this.button2.UseVisualStyleBackColor = true;
			this.button2.Click += new System.EventHandler(this.Button2Click);
			// 
			// label2
			// 
			this.label2.Location = new System.Drawing.Point(42, 105);
			this.label2.Name = "label2";
			this.label2.Size = new System.Drawing.Size(100, 14);
			this.label2.TabIndex = 39;
			this.label2.Text = "Status:";
			// 
			// label3
			// 
			this.label3.Location = new System.Drawing.Point(42, 119);
			this.label3.Name = "label3";
			this.label3.Size = new System.Drawing.Size(589, 22);
			this.label3.TabIndex = 40;
			// 
			// MainForm
			// 
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.ClientSize = new System.Drawing.Size(668, 192);
			this.Controls.Add(this.label3);
			this.Controls.Add(this.label2);
			this.Controls.Add(this.button2);
			this.Controls.Add(this.textBox2);
			this.Controls.Add(this.label4);
			this.Controls.Add(this.button3);
			this.Controls.Add(this.textBox1);
			this.Controls.Add(this.label1);
			this.Controls.Add(this.button1);
			this.Name = "MainForm";
			this.Text = "Confuser Methods Decryptor 1.0 by CodeCracker / SnD";
			this.ResumeLayout(false);
			this.PerformLayout();
		}
		public System.Windows.Forms.TextBox textBox2;
		private System.Windows.Forms.Label label3;
		private System.Windows.Forms.Label label2;
		private System.Windows.Forms.Button button2;
		private System.Windows.Forms.Button button3;
		private System.Windows.Forms.Label label4;
		private System.Windows.Forms.Button button1;
		private System.Windows.Forms.Label label1;
		public System.Windows.Forms.TextBox textBox1;
		

	}
}



================================================
File: Confuser_Methods_Decryptor/MainForm.cs
================================================
ï»¿/*
 * Created by SharpDevelop.
 * User: Bogdan
 * Date: 29.12.2012
 * Time: 18:25
 * 
 * To change this template use Tools | Options | Coding | Edit Standard Headers.
 */
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Windows.Forms;
using System.IO;
using System.Runtime.InteropServices;
using System.Reflection;

namespace Confuser_Methods_Decryptor
{
	/// <summary>
	/// Description of MainForm.
	/// </summary>
	public partial class MainForm : Form
	{
		public MainForm()
		{
			//
			// The InitializeComponent() call is required for Windows Forms designer support.
			//
			InitializeComponent();
			
			//
			// TODO: Add constructor code after the InitializeComponent() call.
			//
		}
		
		public string DirectoryName = "";
		void Button1Click(object sender, EventArgs e)
		{
		label3.Text="";
		OpenFileDialog fdlg = new OpenFileDialog();
		fdlg.Title = "Browse for target assembly";
		fdlg.InitialDirectory = @"c:\";
		if (DirectoryName!="") fdlg.InitialDirectory = DirectoryName;
		fdlg.Filter = "Executable files (*.exe,*.dll)|*.exe;*.dll";
		fdlg.FilterIndex = 2;
		fdlg.RestoreDirectory = true;
		if(fdlg.ShowDialog() == DialogResult.OK)
		{
		string FileName = fdlg.FileName;
		textBox1.Text = FileName;
		int lastslash = FileName.LastIndexOf("\\");
		if (lastslash!=-1) DirectoryName = FileName.Remove(lastslash,FileName.Length-lastslash);
        if (DirectoryName.Length==2) DirectoryName=DirectoryName+"\\";
		}
		}
		
		void Button3Click(object sender, EventArgs e)
		{
		label3.Text="";
		OpenFileDialog fdlg = new OpenFileDialog();
		fdlg.Title = "Browse for module";
		fdlg.InitialDirectory = @"c:\";
		if (DirectoryName!="") fdlg.InitialDirectory = DirectoryName;
		fdlg.Filter = "Net module file (*.netmodule)|*.netmodule";
		fdlg.FilterIndex = 2;
		fdlg.RestoreDirectory = true;
		if(fdlg.ShowDialog() == DialogResult.OK)
		{
		string FileName = fdlg.FileName;
		textBox2.Text = FileName;
		int lastslash = FileName.LastIndexOf("\\");
		if (lastslash!=-1) DirectoryName = FileName.Remove(lastslash,FileName.Length-lastslash);
        if (DirectoryName.Length==2) DirectoryName=DirectoryName+"\\";
		}
		}
		
		void TextBox1DragEnter(object sender, DragEventArgs e)
		{
		if (e.Data.GetDataPresent(DataFormats.FileDrop))
        e.Effect = DragDropEffects.Copy;
    	else
    	e.Effect = DragDropEffects.None;
		}
		
		void TextBox2DragEnter(object sender, DragEventArgs e)
		{
		if (e.Data.GetDataPresent(DataFormats.FileDrop))
        e.Effect = DragDropEffects.Copy;
    	else
    	e.Effect = DragDropEffects.None;
		}
		
		void TextBox1DragDrop(object sender, System.Windows.Forms.DragEventArgs e)
		{
		try
        {
        Array a = (Array) e.Data.GetData(DataFormats.FileDrop);
        if(a != null)
        {
        string s = a.GetValue(0).ToString();
        int lastoffsetpoint = s.LastIndexOf(".");
        if (lastoffsetpoint != -1)
        {
        string Extension = s.Substring(lastoffsetpoint);
        Extension=Extension.ToLower();
        if (Extension == ".exe"||Extension == ".dll")
        {
        this.Activate();
        textBox1.Text = s;
        int lastslash = s.LastIndexOf("\\");
        if (lastslash!=-1) DirectoryName = s.Remove(lastslash,s.Length-lastslash);
        if (DirectoryName.Length==2) DirectoryName=DirectoryName+"\\";
        }
        }
        }
        }
        catch
        {

        }
		}
		
		void TextBox2DragDrop(object sender, DragEventArgs e)
		{
		try
        {
        Array a = (Array) e.Data.GetData(DataFormats.FileDrop);
        if(a != null)
        {
        string s = a.GetValue(0).ToString();
        int lastoffsetpoint = s.LastIndexOf(".");
        if (lastoffsetpoint != -1)
        {
        string Extension = s.Substring(lastoffsetpoint);
        Extension=Extension.ToLower();
        if (Extension == ".netmodule")
        {
        this.Activate();
        textBox2.Text = s;
        int lastslash = s.LastIndexOf("\\");
        if (lastslash!=-1) DirectoryName = s.Remove(lastslash,s.Length-lastslash);
        if (DirectoryName.Length==2) DirectoryName=DirectoryName+"\\";
        }
        }
        }
        }
        catch
        {

        }
		}
		
		const byte CorILMethod_TinyFormat = 0x02;
		const byte CorILMethod_FatFormat = 0x03;

[DllImport("kernel32.dll")]
public static extern Boolean AllocConsole();
[DllImport("kernel32.dll")]
public static extern Boolean FreeConsole();
public static Boolean isConsoleon;

		void Button2Click(object sender, EventArgs e)
		{
		string inputfile = textBox1.Text;
		string modulename = textBox2.Text;
		Module mainmodule = null;
		Assembly assembly=null;
		bool isModule = false;
		try
		{

AssemblyName an = AssemblyName.GetAssemblyName(inputfile);
assembly = Assembly.Load(an);
mainmodule = assembly.ManifestModule;
if (File.Exists(modulename))
{
byte[] bytes = File.ReadAllBytes(modulename);
string modname = Path.GetFileName(modulename);
mainmodule = assembly.LoadModule(modname,bytes);
isModule = true;
}
		}
  		catch (Exception loadexception)
		{
  		label3.ForeColor = Color.Red;
  		label3.Text = loadexception.ToString();
  		return;
		}

if (File.Exists(modulename))
{
inputfile = modulename;
}

		MetadataReader mr = new MetadataReader();
		FileStream input = null;
		BinaryReader reader = null;
		MethodBase ep = null;
		bool isConsoleon = false;

if (File.Exists(inputfile))
{
input = new FileStream(inputfile, FileMode.Open, System.IO.FileAccess.Read, FileShare.ReadWrite);
reader = new BinaryReader(input);
if (mr.Intialize(reader))
{
if (mr.netdir.EntryPointToken!=0&&
(mr.netdir.EntryPointToken&0x0FF000000)==0x06000000)
{
int internalEntryPointToken = mr.netdir.EntryPointToken&0x0FFFFFF;
if (internalEntryPointToken>0&&internalEntryPointToken<=mr.TableLengths[6])
{
try
{ // ResolveMethod since on Framework 4.0 System.Reflection.Assembly.EntryPoint()
  // throw new NotImplementedException();
ep = mainmodule.ResolveMethod(mr.netdir.EntryPointToken);
}
catch
{
}
}
if (ep!=null&&mr.inh.ioh.Subsystem==03)
{
try
{

isConsoleon = AllocConsole();
}
catch
{
}
}
// Invoke the entry point (changed to ret) for initing the protector!
if (ep!=null)//
{
// string[] args -> new string[]{null}
object[] parametersers = new object[] { };  // no parameters

try
{
if (ep.GetParameters().Length > 0)
{
if (ep.GetParameters()[0].ParameterType != typeof(string[]))
parametersers = new string[]{null};
else
parametersers = new object[] {null};;
}
}
catch
{
}


try
{
if (ep.IsStatic)
{
ep.Invoke(null, parametersers);
}
else
{
object obj = Activator.CreateInstance(ep.DeclaringType);
ep.Invoke(obj, parametersers);
}
}
catch
{

}
}
if (isConsoleon)
{

try
{
FreeConsole();
}
catch
{
}

}
}
}
reader.Close();
input.Close();
}


  		byte[] filebytes = File.ReadAllBytes(inputfile);
		input = new FileStream(inputfile, FileMode.Open, System.IO.FileAccess.Read, FileShare.ReadWrite);
		reader = new BinaryReader(input);
		mr = new MetadataReader();
		if (mr.Intialize(reader))
		{
long MethodPosition = mr.TablesOffset;
for (int g=0;g<06;g++)
MethodPosition = MethodPosition+mr.tablesize[g].TotalSize*mr.TableLengths[g];

IntPtr hinstance = Marshal.GetHINSTANCE(mainmodule);
for (int i = 0; i < mr.TableLengths[06]; i++)
{
reader.BaseStream.Position=(long)MethodPosition + mr.tablesize[06].TotalSize*i;
int methodRVA = reader.ReadInt32();
if (methodRVA<=0)
continue;

int methodsoffset = mr.Rva2Offset(methodRVA);
if (methodsoffset<=0)
continue;

byte Flag = 0;
if (isModule)
Flag = (byte)(Marshal.ReadByte(hinstance,methodsoffset)&255);
else
Flag = (byte)(Marshal.ReadByte(hinstance,methodRVA)&255);
int codesize=0;

		if (( Flag & 3)==CorILMethod_FatFormat)
		{
		if (isModule)
		codesize = Marshal.ReadInt32(hinstance,methodsoffset+4);
		else
		codesize = Marshal.ReadInt32(hinstance,methodRVA+4);
		codesize = codesize+12;

		}
		else if (( Flag & 3)==CorILMethod_TinyFormat)
		{
		codesize=Flag>>2;
		codesize = codesize+1;
		}
		
		
		try
		{
		byte[]methodbody = new byte[codesize];
		for (int j=0;j<methodbody.Length;j++)
		{
		if (isModule)
		methodbody[j]=Marshal.ReadByte(hinstance,methodsoffset+j);
		else
		methodbody[j]=Marshal.ReadByte(hinstance,methodRVA+j);
		}
		Array.Copy(methodbody,0,filebytes,methodsoffset,methodbody.Length);
		}
		catch (Exception ecx)
		{
		MessageBox.Show(ecx.ToString());

		}

				
		}
		
string directoryname = Path.GetDirectoryName(inputfile);
if (!directoryname.EndsWith("\\")) directoryname=directoryname+"\\";
string newFile = directoryname+Path.GetFileNameWithoutExtension(inputfile)+"_decryptedmethods"+Path.GetExtension(inputfile);
	
		File.WriteAllBytes(newFile,filebytes);
		label3.ForeColor = Color.Blue;
		label3.Text = "Saved on:"+newFile;
		}
		reader.Close();
		input.Close();
		
		}
	}
	
	public class MetadataReader
	{
	
	public enum Types
	{
		//Tables
		Module = 0,
		TypeRef = 1,
		TypeDef = 2,
		FieldPtr = 3, 
		Field = 4,
		MethodPtr = 5,
		Method = 6,
		ParamPtr = 7, 
		Param = 8,
		InterfaceImpl = 9,
		MemberRef = 10,
		Constant = 11, 
		CustomAttribute = 12,
		FieldMarshal = 13,
		Permission = 14,
		ClassLayout = 15, 
		FieldLayout = 16,
		StandAloneSig = 17,
		EventMap = 18,
		EventPtr = 19, 
		Event = 20,
		PropertyMap = 21,
		PropertyPtr = 22,
		Property = 23, 
		MethodSemantics = 24,
		MethodImpl = 25,
		ModuleRef = 26,
		TypeSpec = 27, 
		ImplMap = 28, //lidin book is wrong again here?  It has enclog at 28
		FieldRVA = 29,
		ENCLog = 30,
		ENCMap = 31, 
		Assembly = 32,
		AssemblyProcessor= 33,
		AssemblyOS = 34,
		AssemblyRef = 35, 
		AssemblyRefProcessor = 36,
		AssemblyRefOS = 37,
		File = 38,
		ExportedType = 39, 
		ManifestResource = 40,
		NestedClass = 41,
		TypeTyPar = 42,
		MethodTyPar = 43,

		//Coded Token Types
		TypeDefOrRef = 64,
		HasConstant = 65,
		CustomAttributeType = 66,
		HasSemantic = 67,
		ResolutionScope = 68,
		HasFieldMarshal = 69,
		HasDeclSecurity = 70,
		MemberRefParent = 71,
		MethodDefOrRef = 72,
		MemberForwarded = 73,
		Implementation = 74,
		HasCustomAttribute = 75,

		//Simple
		UInt16 = 97,
		UInt32 = 99,
		String = 101,
		Blob = 102,
		Guid = 103,
		UserString = 112
	}
	
	
unsafe public struct IMAGE_DOS_HEADER
{
     public short e_magic;
     public short e_cblp;
     public short e_cp;
     public short e_crlc;
     public short e_cparhdr;
     public short e_minalloc;
     public short e_maxalloc;
     public short e_ss;
     public short e_sp;
     public short e_csum;
     public short e_ip;
     public short e_cs;
     public short e_lfarlc;
     public short e_ovno;
     fixed short e_res1[4];
     public short e_oeminfo;
     fixed short e_res2[10];
     public int e_lfanew;
}

unsafe public struct IMAGE_NT_HEADERS
{
public int Signature;
public IMAGE_FILE_HEADER ifh;
public IMAGE_OPTIONAL_HEADER ioh;
}
public struct IMAGE_DATA_DIRECTORY
{
public int RVA;
public int Size;
}

public struct IMAGE_FILE_HEADER
{
  public short  Machine;
  public short  NumberOfSections;
  public int TimeDateStamp;
  public int PointerToSymbolTable;
  public int NumberOfSymbols;
  public short  SizeOfOptionalHeader;
  public short  Characteristics;
}

unsafe public struct IMAGE_OPTIONAL_HEADER
{
  public short     Magic;
  public byte      MajorLinkerVersion;
  public byte      MinorLinkerVersion;
  public int       SizeOfCode;
  public int       SizeOfInitializedData;
  public int       SizeOfUninitializedData;
  public int       AddressOfEntryPoint;
  public int       BaseOfCode;
  public int       BaseOfData;
  public int       ImageBase;
  public int       SectionAlignment;
  public int       FileAlignment;
  public short     MajorOperatingSystemVersion;
  public short     MinorOperatingSystemVersion;
  public short     MajorImageVersion;
  public short     MinorImageVersion;
  public short     MajorSubsystemVersion;
  public short     MinorSubsystemVersion;
  public int       Win32VersionValue;
  public int       SizeOfImage;
  public int       SizeOfHeaders;
  public int       CheckSum;
  public short     Subsystem;
  public short     DllCharacteristics;
  public int       SizeOfStackReserve;
  public int       SizeOfStackCommit;
  public int       SizeOfHeapReserve;
  public int       SizeOfHeapCommit;
  public int       LoaderFlags;
  public int       NumberOfRvaAndSizes;
  public IMAGE_DATA_DIRECTORY ExportDirectory;
  public IMAGE_DATA_DIRECTORY ImportDirectory;
  public IMAGE_DATA_DIRECTORY ResourceDirectory;
  public IMAGE_DATA_DIRECTORY ExceptionDirectory;
  public IMAGE_DATA_DIRECTORY SecurityDirectory;
  public IMAGE_DATA_DIRECTORY RelocationDirectory;
  public IMAGE_DATA_DIRECTORY DebugDirectory;
  public IMAGE_DATA_DIRECTORY ArchitectureDirectory;
  public IMAGE_DATA_DIRECTORY Reserved;
  public IMAGE_DATA_DIRECTORY TLSDirectory;
  public IMAGE_DATA_DIRECTORY ConfigurationDirectory;
  public IMAGE_DATA_DIRECTORY BoundImportDirectory;
  public IMAGE_DATA_DIRECTORY ImportAddressTableDirectory;
  public IMAGE_DATA_DIRECTORY DelayImportDirectory;
  public IMAGE_DATA_DIRECTORY MetaDataDirectory;
}

public unsafe struct image_section_header
{
  public fixed byte name[8];
  public int  virtual_size;
  public int  virtual_address;
  public int  size_of_raw_data;
  public int  pointer_to_raw_data;
  public int  pointer_to_relocations;
  public int  pointer_to_linenumbers;
  public short number_of_relocations;
  public short number_of_linenumbers;
  public int  characteristics;
};

public struct NETDirectory
{
public int cb;
public short MajorRuntimeVersion;
public short MinorRuntimeVersion;
public int MetaDataRVA;
public int MetaDataSize;
public int Flags;
public int EntryPointToken;
public int ResourceRVA;
public int ResourceSize;
public int StrongNameSignatureRVA;
public int StrongNameSignatureSize;
public int CodeManagerTableRVA;
public int CodeManagerTableSize;
public int VTableFixupsRVA;
public int VTableFixupsSize;
public int ExportAddressTableJumpsRVA;
public int ExportAddressTableJumpsSize;
public int ManagedNativeHeaderRVA;
public int ManagedNativeHeaderSize;
}

unsafe public struct MetaDataHeader
{
public int Signature;
public short MajorVersion;
public short MinorVersion;
public int Reserved;
public int VerionLenght;
public byte[] VersionString;
public short Flags;
public short NumberOfStreams;
}

unsafe public struct TableHeader
{
public int Reserved_1;
public byte MajorVersion;
public byte MinorVersion;
public byte HeapOffsetSizes;
public byte Reserved_2;
public long MaskValid;
public long MaskSorted;
}

public struct MetaDataStream
{
public int Offset;
public int Size;
public string Name;
}

public struct TableInfo
{
public string Name;
public string[] names;
public Types type;
public Types[] ctypes;
}

public struct RefTableInfo
{
public Types type;
public Types[] reftypes;
public int[] refindex;
}

public struct TableSize
{
public int TotalSize;
public int[] Sizes;
}

public struct Table
{
public long[][] members;
}


		public IMAGE_DOS_HEADER idh;
		public IMAGE_NT_HEADERS inh;
		public image_section_header[] sections;
		public NETDirectory netdir;
		public MetaDataHeader mh;
		public MetaDataStream[] streams;
		public MetaDataStream MetadataRoot;
		public byte[] Strings;
		public byte[] US;
		public byte[] GUID;
		public byte[] Blob;
		public long TablesOffset;
		public TableHeader tableheader;
		public int[] TableLengths;
		public TableInfo[] tablesinfo;
		public RefTableInfo[] reftables;
		public TableSize[] tablesize;
		public int[] codedTokenBits;
		public long BlobOffset;
		public long StringOffset;
		
		public void InitTablesInfo()
		{
tablesinfo = new TableInfo[0x2D];
tablesinfo[0].Name = "Module";
tablesinfo[0].names = new String[] { "Generation", "Name", "Mvid", "EncId", "EncBaseId" };
tablesinfo[0].type = Types.Module;
tablesinfo[0].ctypes = new Types[] { Types.UInt16, Types.String, Types.Guid, Types.Guid, Types.Guid };
tablesinfo[1].Name = "TypeRef";
tablesinfo[1].names = new String[] { "ResolutionScope", "Name", "Namespace" };
tablesinfo[1].type = Types.TypeRef;
tablesinfo[1].ctypes = new Types[] { Types.ResolutionScope, Types.String, Types.String };
tablesinfo[2].Name = "TypeDef";
tablesinfo[2].names = new String[] { "Flags", "Name", "Namespace", "Extends", "FieldList", "MethodList" };
tablesinfo[2].type = Types.TypeDef;
tablesinfo[2].ctypes = new Types[] { Types.UInt32, Types.String, Types.String, Types.TypeDefOrRef, Types.Field, Types.Method };
tablesinfo[3].Name = "FieldPtr";
tablesinfo[3].names = new String[] { "Field" };
tablesinfo[3].type = Types.FieldPtr;
tablesinfo[3].ctypes = new Types[] { Types.Field };
tablesinfo[4].Name = "Field";
tablesinfo[4].names = new String[] { "Flags", "Name", "Signature" };
tablesinfo[4].type = Types.Field;
tablesinfo[4].ctypes = new Types[] { Types.UInt16, Types.String, Types.Blob };
tablesinfo[5].Name = "MethodPtr";
tablesinfo[5].names = new String[] { "Method"};
tablesinfo[5].type = Types.MethodPtr;
tablesinfo[5].ctypes = new Types[] { Types.Method };
tablesinfo[6].Name = "Method";
tablesinfo[6].names = new String[] { "RVA", "ImplFlags", "Flags", "Name", "Signature", "ParamList" };
tablesinfo[6].type = Types.Method;
tablesinfo[6].ctypes = new Types[] { Types.UInt32, Types.UInt16, Types.UInt16, Types.String, Types.Blob, Types.Param };
tablesinfo[7].Name = "ParamPtr";
tablesinfo[7].names = new String[] { "Param" };
tablesinfo[7].type = Types.ParamPtr;
tablesinfo[7].ctypes = new Types[] { Types.Param };
tablesinfo[8].Name = "Param";
tablesinfo[8].names = new String[] { "Flags", "Sequence", "Name" };
tablesinfo[8].type = Types.Param;
tablesinfo[8].ctypes = new Types[] { Types.UInt16, Types.UInt16, Types.String };
tablesinfo[9].Name = "InterfaceImpl";
tablesinfo[9].names = new String[] { "Class", "Interface" };
tablesinfo[9].type = Types.InterfaceImpl;
tablesinfo[9].ctypes = new Types[] { Types.TypeDef, Types.TypeDefOrRef };
tablesinfo[0x0A].Name = "MemberRef";
tablesinfo[0x0A].names = new String[] { "Class", "Name", "Signature" };
tablesinfo[0x0A].type = Types.MemberRef;
tablesinfo[0x0A].ctypes = new Types[] { Types.MemberRefParent, Types.String, Types.Blob };
tablesinfo[0x0B].Name = "Constant";
tablesinfo[0x0B].names = new String[] { "Type", "Parent", "Value" };
tablesinfo[0x0B].type = Types.Constant;
tablesinfo[0x0B].ctypes = new Types[] { Types.UInt16, Types.HasConstant, Types.Blob };
tablesinfo[0x0C].Name = "CustomAttribute";
tablesinfo[0x0C].names = new String[] { "Type", "Parent", "Value" };
tablesinfo[0x0C].type = Types.CustomAttribute;
tablesinfo[0x0C].ctypes = new Types[] { Types.HasCustomAttribute, Types.CustomAttributeType, Types.Blob };
tablesinfo[0x0D].Name = "FieldMarshal";
tablesinfo[0x0D].names = new String[] { "Parent", "Native" };
tablesinfo[0x0D].type = Types.FieldMarshal;
tablesinfo[0x0D].ctypes = new Types[] { Types.HasFieldMarshal, Types.Blob };
tablesinfo[0x0E].Name = "Permission";
tablesinfo[0x0E].names = new String[] { "Action", "Parent", "PermissionSet" };
tablesinfo[0x0E].type = Types.Permission;
tablesinfo[0x0E].ctypes = new Types[] { Types.UInt16, Types.HasDeclSecurity, Types.Blob };
tablesinfo[0x0F].Name = "ClassLayout";
tablesinfo[0x0F].names = new String[] { "PackingSize", "ClassSize", "Parent" };
tablesinfo[0x0F].type = Types.ClassLayout;
tablesinfo[0x0F].ctypes = new Types[] { Types.UInt16, Types.UInt32, Types.TypeDef };
tablesinfo[0x10].Name = "FieldLayout";
tablesinfo[0x10].names = new String[] { "Offset", "Field" };
tablesinfo[0x10].type = Types.FieldLayout;
tablesinfo[0x10].ctypes = new Types[] { Types.UInt32, Types.Field };
tablesinfo[0x11].Name = "StandAloneSig";
tablesinfo[0x11].names = new String[] { "Signature" };
tablesinfo[0x11].type = Types.StandAloneSig;
tablesinfo[0x11].ctypes = new Types[] { Types.Blob };
tablesinfo[0x12].Name = "EventMap";
tablesinfo[0x12].names = new String[] { "Parent", "EventList" };
tablesinfo[0x12].type = Types.EventMap;
tablesinfo[0x12].ctypes = new Types[] { Types.TypeDef, Types.Event };
tablesinfo[0x13].Name = "EventPtr";
tablesinfo[0x13].names = new String[] { "Event" };
tablesinfo[0x13].type = Types.EventPtr;
tablesinfo[0x13].ctypes = new Types[] { Types.Event };
tablesinfo[0x14].Name = "Event";
tablesinfo[0x14].names = new String[] { "EventFlags", "Name", "EventType" };
tablesinfo[0x14].type = Types.Event;
tablesinfo[0x14].ctypes = new Types[] { Types.UInt16, Types.String, Types.TypeDefOrRef };
tablesinfo[0x15].Name = "PropertyMap";
tablesinfo[0x15].names = new String[] { "Parent", "PropertyList" };
tablesinfo[0x15].type = Types.PropertyMap;
tablesinfo[0x15].ctypes = new Types[] { Types.TypeDef, Types.Property };
tablesinfo[0x16].Name = "PropertyPtr";
tablesinfo[0x16].names = new String[] { "Property" };
tablesinfo[0x16].type = Types.PropertyPtr;
tablesinfo[0x16].ctypes = new Types[] { Types.Property };
tablesinfo[0x17].Name = "Property";
tablesinfo[0x17].names = new String[] { "PropFlags", "Name", "Type" };
tablesinfo[0x17].type = Types.Property;
tablesinfo[0x17].ctypes = new Types[] { Types.UInt16, Types.String, Types.Blob };
tablesinfo[0x18].Name = "MethodSemantics";
tablesinfo[0x18].names = new String[] { "Semantic", "Method", "Association" };
tablesinfo[0x18].type = Types.MethodSemantics;
tablesinfo[0x18].ctypes = new Types[] { Types.UInt16, Types.Method, Types.HasSemantic };
tablesinfo[0x19].Name = "MethodImpl";
tablesinfo[0x19].names = new String[] { "Class", "MethodBody", "MethodDeclaration" };
tablesinfo[0x19].type = Types.MethodImpl;
tablesinfo[0x19].ctypes = new Types[] { Types.TypeDef, Types.MethodDefOrRef, Types.MethodDefOrRef };
tablesinfo[0x1A].Name = "ModuleRef";
tablesinfo[0x1A].names = new String[] { "Name" };
tablesinfo[0x1A].type = Types.ModuleRef;
tablesinfo[0x1A].ctypes = new Types[] { Types.String };
tablesinfo[0x1B].Name = "TypeSpec";
tablesinfo[0x1B].names = new String[] { "Signature" };
tablesinfo[0x1B].type = Types.TypeSpec;
tablesinfo[0x1B].ctypes = new Types[] { Types.Blob };
tablesinfo[0x1C].Name = "ImplMap";
tablesinfo[0x1C].names = new String[] { "MappingFlags", "MemberForwarded", "ImportName", "ImportScope" };
tablesinfo[0x1C].type = Types.ImplMap;
tablesinfo[0x1C].ctypes = new Types[] { Types.UInt16, Types.MemberForwarded, Types.String, Types.ModuleRef };
tablesinfo[0x1D].Name = "FieldRVA";
tablesinfo[0x1D].names = new String[] { "RVA", "Field" };
tablesinfo[0x1D].type = Types.FieldRVA;
tablesinfo[0x1D].ctypes = new Types[] { Types.UInt32, Types.Field };
tablesinfo[0x1E].Name = "ENCLog";
tablesinfo[0x1E].names = new String[] { "Token", "FuncCode" };
tablesinfo[0x1E].type = Types.ENCLog;
tablesinfo[0x1E].ctypes = new Types[] { Types.UInt32, Types.UInt32 };
tablesinfo[0x1F].Name = "ENCMap";
tablesinfo[0x1F].names = new String[] { "Token" };
tablesinfo[0x1F].type = Types.ENCMap;
tablesinfo[0x1F].ctypes = new Types[] { Types.UInt32 };
tablesinfo[0x20].Name = "Assembly";
tablesinfo[0x20].names = new String[] { "HashAlgId", "MajorVersion", "MinorVersion", "BuildNumber", "RevisionNumber", "Flags", "PublicKey", "Name", "Locale" };
tablesinfo[0x20].type = Types.Assembly;
tablesinfo[0x20].ctypes = new Types[] { Types.UInt32, Types.UInt16, Types.UInt16, Types.UInt16, Types.UInt16, Types.UInt32, Types.Blob, Types.String, Types.String };
tablesinfo[0x21].Name = "AssemblyProcessor";
tablesinfo[0x21].names = new String[] { "Processor" };
tablesinfo[0x21].type = Types.AssemblyProcessor;
tablesinfo[0x21].ctypes = new Types[] { Types.UInt32 };
tablesinfo[0x22].Name = "AssemblyOS";
tablesinfo[0x22].names = new String[] { "OSPlatformId", "OSMajorVersion", "OSMinorVersion" };
tablesinfo[0x22].type = Types.AssemblyOS;
tablesinfo[0x22].ctypes = new Types[] { Types.UInt32, Types.UInt32, Types.UInt32 };
tablesinfo[0x23].Name = "AssemblyRef";
tablesinfo[0x23].names = new String[] { "MajorVersion", "MinorVersion", "BuildNumber", "RevisionNumber", "Flags", "PublicKeyOrToken", "Name", "Locale", "HashValue" };
tablesinfo[0x23].type = Types.AssemblyRef;
tablesinfo[0x23].ctypes = new Types[] { Types.UInt16, Types.UInt16, Types.UInt16, Types.UInt16, Types.UInt32, Types.Blob, Types.String, Types.String, Types.Blob };
tablesinfo[0x24].Name = "AssemblyRefProcessor";
tablesinfo[0x24].names = new String[] { "Processor", "AssemblyRef" };
tablesinfo[0x24].type = Types.AssemblyRefProcessor;
tablesinfo[0x24].ctypes = new Types[] { Types.UInt32, Types.AssemblyRef };
tablesinfo[0x25].Name = "AssemblyRefOS";
tablesinfo[0x25].names = new String[] { "OSPlatformId", "OSMajorVersion", "OSMinorVersion", "AssemblyRef" };
tablesinfo[0x25].type = Types.AssemblyRefOS;
tablesinfo[0x25].ctypes = new Types[] { Types.UInt32, Types.UInt32, Types.UInt32, Types.AssemblyRef };
tablesinfo[0x26].Name = "File";
tablesinfo[0x26].names = new String[] { "Flags", "Name", "HashValue" };
tablesinfo[0x26].type = Types.File;
tablesinfo[0x26].ctypes = new Types[] { Types.UInt32, Types.String, Types.Blob };
tablesinfo[0x27].Name = "ExportedType";
tablesinfo[0x27].names = new String[] { "Flags", "TypeDefId", "TypeName", "TypeNamespace", "TypeImplementation" };
tablesinfo[0x27].type = Types.ExportedType;
tablesinfo[0x27].ctypes = new Types[] { Types.UInt32, Types.UInt32, Types.String, Types.String, Types.Implementation };
tablesinfo[0x28].Name = "ManifestResource";
tablesinfo[0x28].names = new String[] { "Offset", "Flags", "Name", "Implementation" };
tablesinfo[0x28].type = Types.ManifestResource;
tablesinfo[0x28].ctypes = new Types[] { Types.UInt32, Types.UInt32, Types.String, Types.Implementation };
tablesinfo[0x29].Name = "NestedClass";
tablesinfo[0x29].names = new String[] { "NestedClass", "EnclosingClass"};
tablesinfo[0x29].type = Types.NestedClass;
tablesinfo[0x29].ctypes = new Types[] { Types.TypeDef, Types.TypeDef };
//unused TyPar tables taken from Roeder's reflector... are these documented anywhere?  Since they are always empty, does it matter
tablesinfo[0x2A].Name = "TypeTyPar";
tablesinfo[0x2A].names = new String[] { "Number", "Class", "Bound", "Name" };
tablesinfo[0x2A].type = Types.TypeTyPar;
tablesinfo[0x2A].ctypes = new Types[] { Types.UInt16, Types.TypeDef, Types.TypeDefOrRef, Types.String };
tablesinfo[0x2B].Name = "MethodTyPar";
tablesinfo[0x2B].names = new String[] { "Number", "Method", "Bound", "Name" };
tablesinfo[0x2B].type = Types.MethodTyPar;
tablesinfo[0x2B].ctypes = new Types[] { Types.UInt16, Types.Method, Types.TypeDefOrRef, Types.String };
tablesinfo[0x2C].Name = "MethodTyPar";
tablesinfo[0x2C].names = new String[] { "Number", "Method", "Bound", "Name" };
tablesinfo[0x2C].type = Types.MethodTyPar;
tablesinfo[0x2C].ctypes = new Types[] { Types.UInt16, Types.Method, Types.TypeDefOrRef, Types.String };

//number of bits in coded token tag for a coded token that refers to n tables.
//values 5-17 are not used :I		
codedTokenBits = new int[] { 0, 1, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 };
reftables = new RefTableInfo[12];
reftables[0].type = Types.TypeDefOrRef;
reftables[0].reftypes = new Types[] { Types.TypeDef, Types.TypeRef, Types.TypeSpec};
reftables[0].refindex = new int[] { 1, 2, 0x1B};
reftables[1].type = Types.HasConstant;
reftables[1].reftypes = new Types[] { Types.Field, Types.Param, Types.Property };
reftables[1].refindex = new int[] { 04, 08, 0x17};
reftables[2].type = Types.CustomAttributeType;
reftables[2].reftypes = new Types[] { Types.TypeRef, Types.TypeDef, Types.Method, Types.MemberRef, Types.UserString };
reftables[2].refindex = new int[] { 01, 02, 06, 0x0A,01};  //????????
reftables[3].type = Types.HasSemantic;
reftables[3].reftypes = new Types[] { Types.Event, Types.Property };
reftables[3].refindex = new int[] { 0x14, 0x17};
reftables[4].type = Types.ResolutionScope;
reftables[4].reftypes = new Types[] { Types.Module, Types.ModuleRef, Types.AssemblyRef, Types.TypeRef };
reftables[4].refindex = new int[] { 00, 0x1A,0x23, 0x01};
reftables[5].type = Types.HasFieldMarshal;
reftables[5].reftypes = new Types[] { Types.Field, Types.Param };
reftables[5].refindex = new int[] { 04, 08};
reftables[6].type = Types.HasDeclSecurity;
reftables[6].reftypes = new Types[] { Types.TypeDef, Types.Method, Types.Assembly };
reftables[6].refindex = new int[] { 02, 06, 0x20};
reftables[7].type = Types.MemberRefParent;
reftables[7].reftypes = new Types[] { Types.TypeDef, Types.TypeRef, Types.ModuleRef, Types.Method, Types.TypeSpec };
reftables[7].refindex = new int[] { 02,01,0x1A,06,0x1B };
reftables[8].type = Types.MethodDefOrRef;
reftables[8].reftypes = new Types[] { Types.Method, Types.MemberRef };
reftables[8].refindex = new int[] { 06,0x0A };
reftables[9].type = Types.MemberForwarded;
reftables[9].reftypes = new Types[] { Types.Field, Types.Method };
reftables[9].refindex = new int[] { 04,06 };
reftables[10].type = Types.Implementation;
reftables[10].reftypes = new Types[] { Types.File, Types.AssemblyRef, Types.ExportedType };
reftables[10].refindex = new int[] { 0x26, 0x23,0x27 };
reftables[11].type = Types.HasCustomAttribute;
reftables[11].reftypes = new Types[] { Types.Method, Types.Field, Types.TypeRef, Types.TypeDef, Types.Param, Types.InterfaceImpl, Types.MemberRef, Types.Module, Types.Permission, Types.Property, Types.Event, Types.StandAloneSig, Types.ModuleRef, Types.TypeSpec, Types.Assembly, Types.AssemblyRef, Types.File, Types.ExportedType, Types.ManifestResource };
reftables[11].refindex = new int[] { 06, 04, 01,02,08,09,0x0A,00,0x0E,0x17,0x14,0x11,0x1A,0x1B,0x20,0x23,0x26,0x27,0x28};
	}

		public int Rva2Offset(int rva)
		{
			for (int i = 0; i < sections.Length; i++)
			{
					if ((sections[i].virtual_address <= rva) && (sections[i].virtual_address + sections[i].size_of_raw_data >= rva))
					return (sections[i].pointer_to_raw_data + (rva - sections[i].virtual_address));
			}
		
			return 0;
		}
		
		public int Offset2Rva(int uOffset)
		{
			for (int i = 0; i < sections.Length; i++)
			{
				if ((sections[i].pointer_to_raw_data <= uOffset) && ((sections[i].pointer_to_raw_data + sections[i].size_of_raw_data) >= uOffset))
				return (sections[i].virtual_address + (uOffset - sections[i].pointer_to_raw_data));
			}
		
			return 0;
		}
		
		public int GetTypeSize(Types trans)
		{
		if (trans == Types.UInt16) return 2;
		if (trans == Types.UInt32) return 4;
		
		// Heap
		if (trans == Types.String) return GetStringIndexSize();
		if (trans == Types.Guid) return GetGuidIndexSize();
		if (trans == Types.Blob) return GetBlobIndexSize();

		// Rid
		if ((int)trans < 64)
		{
		if (TableLengths[(int)trans] > 65535) return 4;
		else return 2;
		}
		// Coded token (may need to be uncompressed from 2-byte form)
		else if ((int)trans < 97)
		{
		int index = (int)trans-64;
		int codedtokenbits = codedTokenBits[reftables[index].refindex.Length];
		int maxsizekeeped = 65535;
		maxsizekeeped = maxsizekeeped >> codedtokenbits;
		for (int i=0;i<reftables[index].refindex.Length;i++)
		{
		if (TableLengths[reftables[index].refindex[i]] > maxsizekeeped) return 4;
		}
		return 2;
		
		}
		
		return 0;
		}

		public int GetStringIndexSize()
		{
		return ((tableheader.HeapOffsetSizes & 0x01) != 0) ? 4 : 2;
		}
				
		public int GetGuidIndexSize()
		{
		return ((tableheader.HeapOffsetSizes & 0x02) != 0) ? 4 : 2;
		}
		
		public int GetBlobIndexSize()
		{
		return ((tableheader.HeapOffsetSizes & 0x04) != 0) ? 4 : 2;
		}
		
		public unsafe bool Intialize(BinaryReader reader)
		{
		reader.BaseStream.Position=0;
		byte[] buffer;
		IntPtr pointer;
		long NewPos;
		
		try
		{
		buffer = reader.ReadBytes(sizeof(IMAGE_DOS_HEADER));
		
		fixed (byte* p = buffer)
		{
		pointer = (IntPtr)p;
		}
		idh = (IMAGE_DOS_HEADER)Marshal.PtrToStructure(pointer, typeof(IMAGE_DOS_HEADER));
		if (idh.e_magic!=0x5A4D) return false;
		reader.BaseStream.Position=idh.e_lfanew;
		buffer = reader.ReadBytes(sizeof(IMAGE_NT_HEADERS));

		fixed (byte* p = buffer)
		{
		pointer = (IntPtr)p;
		}
		inh = (IMAGE_NT_HEADERS)Marshal.PtrToStructure(pointer, typeof(IMAGE_NT_HEADERS));
		if (inh.Signature!=0x4550) return false;
		
		reader.BaseStream.Position=idh.e_lfanew+4+sizeof(IMAGE_FILE_HEADER)+inh.ifh.SizeOfOptionalHeader;
		sections=new image_section_header[inh.ifh.NumberOfSections];
		buffer = reader.ReadBytes(sizeof(image_section_header)*inh.ifh.NumberOfSections);
		fixed (byte* p = buffer)
		{
		pointer = (IntPtr)p;
		}
		
		for (int i = 0; i < sections.Length; i++)
		{
		sections[i] = (image_section_header)Marshal.PtrToStructure(pointer, typeof(image_section_header));
		pointer = (IntPtr)(pointer.ToInt32() + Marshal.SizeOf(typeof(image_section_header)));
		}
		
		
		// NET Directory
		if (inh.ioh.MetaDataDirectory.RVA==0) return false;
		NewPos = (long)Rva2Offset(inh.ioh.MetaDataDirectory.RVA);
		if (NewPos==0) return false;
		reader.BaseStream.Position=NewPos;
		buffer = reader.ReadBytes(sizeof(NETDirectory));

		fixed (byte* p = buffer)
		{
		pointer = (IntPtr)p;
		}
		// After .NET Directory comes body of methods!
		netdir = (NETDirectory)Marshal.PtrToStructure(pointer, typeof(NETDirectory));
		
		reader.BaseStream.Position=(long)Rva2Offset(netdir.MetaDataRVA);
		mh = new MetadataReader.MetaDataHeader();
		mh.Signature = reader.ReadInt32();
		mh.MajorVersion = reader.ReadInt16();
		mh.MinorVersion = reader.ReadInt16();
		mh.Reserved = reader.ReadInt32();
		mh.VerionLenght = reader.ReadInt32();
		mh.VersionString = reader.ReadBytes(mh.VerionLenght);
		mh.Flags = reader.ReadInt16();
		mh.NumberOfStreams = reader.ReadInt16();
		
		streams = new MetaDataStream[mh.NumberOfStreams];
			
			for(int i=0; i< mh.NumberOfStreams;++i)
			{
			streams[i].Offset=reader.ReadInt32();
			streams[i].Size=reader.ReadInt32();
			char[] chars = new char[32];
			int index = 0;
			byte character = 0;
			while ((character = reader.ReadByte()) != 0) 
				chars[index++] = (char) character;
	
			index++;
			int padding = ((index % 4) != 0) ? (4 - (index % 4)) : 0;
			reader.ReadBytes(padding);
	
			streams[i].Name = new String(chars).Trim(new Char[] {'\0'});
			
			if (streams[i].Name == "#~"||streams[i].Name == "#-")
			{
			MetadataRoot.Name=streams[i].Name;
			MetadataRoot.Offset=streams[i].Offset;
			MetadataRoot.Size=streams[i].Size;
			}

			if (streams[i].Name == "#Strings") 
			{
			long savepoz = reader.BaseStream.Position;
			reader.BaseStream.Position = (long)(Rva2Offset(netdir.MetaDataRVA)+streams[i].Offset);
			StringOffset=reader.BaseStream.Position;
			Strings = reader.ReadBytes(streams[i].Size);
			reader.BaseStream.Position = savepoz;
			}
			
			if (streams[i].Name == "#US")
			{
			long savepoz = reader.BaseStream.Position;
			reader.BaseStream.Position = (long)(Rva2Offset(netdir.MetaDataRVA)+streams[i].Offset);
			US = reader.ReadBytes(streams[i].Size);
			reader.BaseStream.Position = savepoz;
			}
			
			if (streams[i].Name == "#Blob")
			{
			long savepoz = reader.BaseStream.Position;
			reader.BaseStream.Position = (long)(Rva2Offset(netdir.MetaDataRVA)+streams[i].Offset);
			BlobOffset=reader.BaseStream.Position;
			Blob = reader.ReadBytes(streams[i].Size);
			reader.BaseStream.Position = savepoz;
			}
			
			if (streams[i].Name == "#GUID")
			{
			long savepoz = reader.BaseStream.Position;
			reader.BaseStream.Position = (long)(Rva2Offset(netdir.MetaDataRVA)+streams[i].Offset);
			GUID = reader.ReadBytes(streams[i].Size);
			reader.BaseStream.Position = savepoz;
			}
			
			}
			
			reader.BaseStream.Position=(long)(Rva2Offset(netdir.MetaDataRVA)+MetadataRoot.Offset);
			buffer = reader.ReadBytes(sizeof(TableHeader));
			fixed (byte* p = buffer)
			{
			pointer = (IntPtr)p;
			}
			tableheader = (TableHeader)Marshal.PtrToStructure(pointer, typeof(TableHeader));
			TableLengths = new int[64];
			

			//read as many uints as there are bits set in maskvalid
			for (int i = 0; i < 64; i++)
			{
				int count = (((tableheader.MaskValid >> i) & 1) == 0) ? 0 : reader.ReadInt32();
				TableLengths[i] = count;
			}
			
TablesOffset = reader.BaseStream.Position;
InitTablesInfo();
// Get Table sizes and all Tables
tablesize = new TableSize[0x2D];

for (int i=0;i<tablesize.Length;i++)
{
tablesize[i].Sizes=new int[tablesinfo[i].ctypes.Length];
tablesize[i].TotalSize=0;
 for (int j=0;j<tablesinfo[i].ctypes.Length;j++)
 {
 tablesize[i].Sizes[j]=GetTypeSize(tablesinfo[i].ctypes[j]);
 tablesize[i].TotalSize=tablesize[i].TotalSize+tablesize[i].Sizes[j];
 }

}


 }
 catch
 {
 return false;
 }
return true;

	}
	}
}



================================================
File: Confuser_Methods_Decryptor/MainForm.resx
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>


================================================
File: Confuser_Methods_Decryptor/Program.cs
================================================
ï»¿/*
 * Created by SharpDevelop.
 * User: Bogdan
 * Date: 29.12.2012
 * Time: 18:25
 * 
 * To change this template use Tools | Options | Coding | Edit Standard Headers.
 */
using System;
using System.Windows.Forms;

namespace Confuser_Methods_Decryptor
{
	/// <summary>
	/// Class with program entry point.
	/// </summary>
	internal sealed class Program
	{
		/// <summary>
		/// Program entry point.
		/// </summary>
		[STAThread]
		private static void Main(string[] args)
		{
			Application.EnableVisualStyles();
			Application.SetCompatibleTextRenderingDefault(false);
			Application.Run(new MainForm());
		}
		
	}
}



================================================
File: Confuser_Methods_Decryptor/Properties/AssemblyInfo.cs
================================================
ï»¿#region Using directives

using System;
using System.Reflection;
using System.Runtime.InteropServices;

#endregion

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Confuser_Methods_Decryptor")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("Confuser_Methods_Decryptor")]
[assembly: AssemblyCopyright("Copyright 2012")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// This sets the default COM visibility of types in the assembly to invisible.
// If you need to expose a type to COM, use [ComVisible(true)] on that type.
[assembly: ComVisible(false)]

// The assembly version has following format :
//
// Major.Minor.Build.Revision
//
// You can specify all the values or you can use the default the Revision and 
// Build Numbers by using the '*' as shown below:
[assembly: AssemblyVersion("1.0.*")]



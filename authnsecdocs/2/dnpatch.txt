Directory structure:
└── ioncodes-dnpatch/
    ├── README.md
    ├── LICENSE
    ├── PULL_REQUEST_TEMPLATE.md
    ├── dnpatch.sln
    ├── Example/
    │   ├── App.config
    │   ├── Example.csproj
    │   ├── Program.cs
    │   └── Properties/
    │       └── AssemblyInfo.cs
    ├── ExampleDeobfuscation/
    │   ├── App.config
    │   ├── ExampleDeobfuscation.csproj
    │   ├── Program.cs
    │   └── Properties/
    │       └── AssemblyInfo.cs
    ├── Libraries/
    ├── Test/
    │   ├── App.config
    │   ├── Foo.cs
    │   ├── I.cs
    │   ├── Program.cs
    │   ├── Test.csproj
    │   └── Properties/
    │       └── AssemblyInfo.cs
    ├── TestObfuscated/
    │   ├── App.config
    │   ├── Program.cs
    │   ├── TestObfuscated.csproj
    │   └── Properties/
    │       └── AssemblyInfo.cs
    ├── TestScript/
    │   ├── App.config
    │   ├── Program.cs
    │   ├── TestScript.csproj
    │   └── Properties/
    │       └── AssemblyInfo.cs
    ├── UnpackMe1/
    │   ├── App.config
    │   ├── Program.cs
    │   ├── UnpackMe1.csproj
    │   └── Properties/
    │       └── AssemblyInfo.cs
    ├── UnpackMe2/
    │   ├── App.config
    │   ├── Program.cs
    │   ├── UnpackMe2.csproj
    │   └── Properties/
    │       └── AssemblyInfo.cs
    ├── dnpatch/
    │   ├── README.md
    │   ├── Extensions.cs
    │   ├── ObfuscatedTarget.cs
    │   ├── PatchHelper.cs
    │   ├── Patcher.cs
    │   ├── ResourcePatcher.cs
    │   ├── Target.cs
    │   ├── dnpatch.csproj
    │   └── Properties/
    │       └── AssemblyInfo.cs
    ├── dnpatch.deobfuscation/
    │   ├── README.md
    │   ├── CommandLineParser.cs
    │   ├── Deobfuscation.cs
    │   ├── FilesDeobfuscator.cs
    │   ├── dnpatch.deobfuscation.csproj
    │   └── Properties/
    │       └── AssemblyInfo.cs
    └── dnpatch.script/
        ├── README.md
        ├── Script.cs
        ├── dnpatch.script.csproj
        └── Properties/
            └── AssemblyInfo.cs

================================================
File: README.md
================================================
# dnpatch
[WIP] .NET Patcher library using dnlib.

*If you have questions feel free to ask me via Gitter! I'm glad to help you out! Taking feature requests!*

[![Build status](https://ci.appveyor.com/api/projects/status/39jhu0noimfkgfw2?svg=true)](https://ci.appveyor.com/project/ioncodes/dnpatch)
[![Github All Releases](https://img.shields.io/github/downloads/ioncodes/dnpatch/total.svg)](https://github.com/ioncodes/dnpatch/releases)
[![Join the chat at https://gitter.im/dnpatch/Lobby](https://badges.gitter.im/dnpatch/Lobby.svg)](https://gitter.im/dnpatch/Lobby?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)

## IMPORTANT
The master branch provides you the current stable build of dnpatch. However, I will most likely not provide support for it anymore since version 1.0 is on it's way in the v1 branch.

## What is dnpatch?
dnpatch is the ultimate library for all your .NET patching needs. It offers automated assembly patching, signature scanning and last but but not least bypassing of obfuscators by its ability to find methods in renamed/obfuscated types. Since the stars on GitHub exploded in a few days, dnpatch has been extended by a couple of projects. The most important one is dnpatch.deobfuscation which integrates de4dot directly into dnpatch. Also there is dnpatch.script, which gives you the ability to write patchers with pure JSON!
The library itself uses dnlib (see next part).

## Notes
Since dnpatch uses dnlib, it is highly recommended to use dnSpy to analyze your assemblies first, to ensure that you use the correct names, offsets, etc, because it uses dnlib aswell.

## Recommendations
It is highly recommended that you calculate the instruction's index instead of defining it, to improve the likelihood of compatibility with future updates.

## Patching
The constructor takes the filename of the assembly.
```cs
Patcher patcher = new Patcher("Test.exe");
```
If you want to keep the old maxstack (for example for obfuscated assemblies) use the overload:
```cs
Patcher patcher = new Patcher("Test.exe", true);
```

### Targeting Methods
All methods take an object called Target as an argument. The object is defined as follows:
```cs
public string Namespace { get; set; } // needed
public string Class { get; set; } // needed
public string Method { get; set; } // needed

/* If you want to patch multiple indexes in the method */
public int[] Indexes { get; set; }
public Instruction[] Instructions { get; set; }

/* If you want to patch 1 index in the method */
public int Index { get; set; } = -1;
public Instruction Instruction { get; set; }

/* If the path to the method has more than 1 nested class use this */
public string[] NestedClasses { get; set; }

/* If the path to the method has 1 nested class use this */
public string NestedClass { get; set; }

/* If you want to set the parameters for the method (if it's overloaded) use this */
public string[] Parameters { get; set; }

/* If you want to set the return type for the method use this */
public string ReturnType { get; set; }

/* If you want to rewrite the getters or setters of a property use this */
public string Property { get; set; } // The name
public PropertyMethod PropertyMethod { get; set; } // See below, determines patch target
```
ReturnType and Parameters are case sensitive!
Example:
* String[]
* Int32
* etc

PropertyMethod is defined as this:
```cs
public enum PropertyMethod
{
	Get,
	Set
}
```

Please make sure that you don't assign inconsistent values, e.g.
```cs
var target = new Target
{
    Instructions = ...
    Instruction = ...
}
```

If you want to patch multiple methods create a Target[] and pass it to the functions, it is accepted by the most of them.

### Creating Instructions
Reference dnlib and create an Instruction[] or Instruction with your Instruction(s), then assign assign indexes where the Instructions are.You can find them by reverse engineering your assembly via dnSpy or any other decompiler.

Small Example:
```cs
Instruction[] opCodes = {
    Instruction.Create(OpCodes.Ldstr, "Hello Sir 1"),
    Instruction.Create(OpCodes.Ldstr, "Hello Sir 2")
};
int[] indexes = {
    0, // index of Instruction
    2
};
Target target = new Target()
{
    Namespace = "Test",
    Class = "Program",
    Method = "Print",
    Instructions = opCodes,
    Indexes = indexes
};
```

### Patch the whole methodbody
To clear the whole methodbody and write your instructions, make sure that you don't assign the Indexes or Index property.

Here is an example:
```cs
Instruction[] opCodes = {
    Instruction.Create(OpCodes.Ldstr, "Hello Sir"),
    Instruction.Create(OpCodes.Call, p.BuildCall(typeof(Console), "WriteLine", typeof(void), new[] { typeof(string) })),
    Instruction.Create(OpCodes.Ret)
};
Target target = new Target()
{
    Namespace = "Test",
    Class = "Program",
    Method = "Print",
    Instructions = opCodes
};
```

### Apply the patch
To apply your modified instructions you can call the method 'Patch':
```cs
patcher.Patch(Target);
```
or
```cs
patcher.Patch(Target[]);
```

### Finding an instruction
In some cases, it might be useful to find an instruction within a method, for example if the method was updated.
```cs
Instruction opCode = Instruction.Create(OpCodes.Ldstr, "TheTrain");
Instruction toFind = Instruction.Create(OpCodes.Ldstr, "TheWord");
Target target = new Target()
{
    Namespace = "Test",
    Class = "Program",
    Method = "FindMe",
    Instruction = opCode // you can also set it later
};
target.Index = p.FindInstruction(target, toFind);
// now you have the full Target object
```

Let's say there are multiple identical instructions. What now, baoss? Well, it's simple. There's an overload that takes an int which is the occurence of the instruction which you'd like to find.
```cs
Instruction opCode = Instruction.Create(OpCodes.Ldstr, "TheTrain");
Instruction toFind = Instruction.Create(OpCodes.Ldstr, "TheWord");
Target target = new Target()
{
    Namespace = "Test",
    Class = "Program",
    Method = "FindMe",
    Instruction = opCode // you can also set it later
};
target.Index = p.FindInstruction(target, toFind, 2); // Sir, find the second occurence!
```

### Finding methods by OpCode signature
You can find methods (Target[]) by scanning their body for an OpCode signature
```cs
OpCode[] codes = new OpCode[] {
	OpCodes.Ldstr,
	OpCodes.Call
};
var result = p.FindMethodsByOpCodeSignature(codes); // holds Target[]
```

### Replacing instructions
In some cases it might be easier to just replace an instruction. At this point of development, it doesn't make much sense, but the features will come soon.
```cs
Instruction opCode = Instruction.Create(OpCodes.Ldstr, "I love kittens");
Target target = new Target()
{
    Namespace = "Test",
    Class = "Program",
    Method = "ReplaceMe",
    Instruction = opCode,
    Index = 0
};
p.ReplaceInstruction(target);
```

### Removing instructions
Let's say you want to remove instructions... Well it's simple as this:
```cs
Target target = new Target()
{
    Namespace = "Test",
    Class = "Program",
    Method = "RemoveMe",
    Indexes = new[]{0,1} // the indexes, you can also just use 'Index'
};
p.RemoveInstruction(target);
```

### Patching operands
Hmmm.... What if you find the console output offending? You can modify the Ldstr without even creating an instruction :)
```cs
Target target = new Target()
{
    Namespace = "Test",
    Class = "Program",
    Method = "PrintAlot",
    Index = 0
};
p.PatchOperand(target, "PatchedOperand"); // pass the Target and a string to replace
```
or incase you need to modify an int:
```cs
p.PatchOperand(target, 1337);
```
It is also able to patch multiple operands in the same method by using int[] or string[].

### Returning true/false
If you want to overwrite the methodbody with a return true/false statement you can do this:
```cs
target = new Target()
{
    Namespace = "Test",
    Class = "Program",
    Method = "VerifyMe"
};
p.WriteReturnBody(target, bool); // bool represents the return value
```

### Clearing methodbodies
If you just want to empty a methodbody, use this amigo:
```cs
target = new Target()
{
    Namespace = "Test",
    Class = "Program",
    Method = "WriteLog"
};
p.WriteEmptyBody(target);
```

### Getting instructions from target
Simply do this if you want to get instructions of the Target object:
```cs
target = new Target()
{
    Namespace = "Test",
    Class = "Program",
    Method = "WriteLog"
};
Instruction[] instructions = p.GetInstructions(target);
```

### Writing return bodies
If you want to overwrite the body with a return true/false do this:
```cs
target = new Target()
{
    Namespace = "Test",
    Class = "Program",
    Method = "WriteLog"
};
p.WriteReturnBody(target, bool);
// bool is the return value, e.g. true will return true ;)
```
If you want to remove the body simply call this:
```cs
target = new Target()
{
    Namespace = "Test",
    Class = "Program",
    Method = "WriteLog"
};
p.WriteEmptyBody(target);
```

### Find methods
If you want to find a method, you can simply scan the whole file by 2 ways:
```cs
p.FindInstructionsByOperand(string[]);
// or p.FindInstructionsByOperand(int[]);
// string[] with all operands in the method, if there are multiple identical operands, make sure to have the same amount as in the method.

// or do this via opcodes:
p.FindInstructionsByOpcode(OpCode[]);
```
Both ways return an Target[] which contains all targets pointing to the findings.

#### Find instructions in methods or classes
If you want to find the instructions and you know the class (and optionally the method), you can let this method return a Target[] with the pathes and indexes.
```cs
p.FindInstructionsByOperand(Target,int[],bool);
// int[]: the operands
// bool: if true it will search for the operands once, it will delete the index if the index was found

// for opcodes:
p.FindInstructionsByOpcode(Target,int[],bool);
```

### Patch properties
Now you can rewrite a property's getter and setter like this:
```cs
target = new Target()
{
	Namespace = "Test",
	Class = "Program",
	Property = "IsPremium", // Property name
	PropertyMethod = PropertyMethod.Get, // Getter or Setter
	Instructions = new []
	{
		Instruction.Create(OpCodes.Ldc_I4_1),
		Instruction.Create(OpCodes.Ret)  
	} // the new instructions
};
p.RewriteProperty(target); // Will overwrite it with return true in getter
```
The property called 'Property' holds the name of the target property.  
PropertyMethod can be 'PropertyMethod.Get' or 'PropertyMethod.Set'.  
Instructions are the new Instructions for the getter or setter.

### Building calls
To build calls like "Console.WriteLine(string)" you can use this method:
```cs
p.BuildCall(typeof(Console), "WriteLine", typeof(void), new[] { typeof(string) })
/* 
 * Type -> type, a Type instance
 * string -> method, the name of the method
 * Type -> returnType, a Type instance of the return value
 * Type[] -> parameters, an array with the parameter's Types
 */
```
Here is an IL example for Console.WriteLine:
```cs
Patcher p = new Patcher("Test.exe");
Instruction[] opcodesConsoleWriteLine = {
    Instruction.Create(OpCodes.Ldstr, "Hello Sir"), // String to print
    Instruction.Create(OpCodes.Call, p.BuildCall(typeof(Console), "WriteLine", typeof(void), new[] { typeof(string) })), // Console.WriteLine call
    Instruction.Create(OpCodes.Ret) // Always return smth
};
Target target = new Target()
{
    Namespace = "Test",
    Class = "Program",
    Method = "Print",
    Instructions = opcodesConsoleWriteLine
};
p.Patch(target);
p.Save("Test1.exe");
```

### Injecting methods (Untested)
If you want to inject methods into classes, call InjectMethod. Make sure to set MethodDef and Instructions. Optionally set Locals, ParameterDefs.
```cs
Target target = new Target();
MethodImplAttributes methImplFlags = MethodImplAttributes.IL | MethodImplAttributes.Managed;
MethodAttributes methFlags = MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.HideBySig | MethodAttributes.ReuseSlot;
MethodDef meth1 = new MethodDefUser("MyMethod",
            MethodSig.CreateStatic(mod.CorLibTypes.Int32, mod.CorLibTypes.Int32, mod.CorLibTypes.Int32),
            methImplFlags, methFlags);
target.ParameterDefs = new[] { new ParamDefUser("a", 1) };
target.Locals = new[] { new Local(mod.CorLibTypes.Int32) };
target.MethodDef = meth1;
target.Class = "";
// ... target as always...
patcher.InjectMethod(target);
```
For now refer to this page: https://github.com/0xd4d/dnlib/blob/master/Examples/Example2.cs

### Saving the patched assembly
If you want to save the assembly under a different name use this:
```cs
patcher.Save(String); // filename here
```
Or if you want to replace the original file:
```cs
patcher.Save(bool); // if true it will create a backup first (filename.bak)
```

## Deobfuscation [BETA]
Baoss, what can I do if it's heavily obfuscated?! Well, listen careful to your grandpa Joe. Use 'dnpatch.deobfuscation'! It has magic powers! Nah, Joe is just kiddin', it uses the de4dot libraries.
Reference the library dnpatch.deobfuscation and make sure that you also copy all others from the zip!
Then do this:
```cs
Deobfuscation d = new Deobfuscation(string, string);
// string 1 -> file to deobfuscate
// string 2 -> new filename for the deobfuscated file
d.Deobfuscate(); // Deobfuscates the file and writes it to the disk
```

## Scripting
With dnpatch.script you're now able to script patchers with JSON!
Example JSON:
```json
{
    "target":"Test.exe",
    "targets":[{
        "ns":"Test",
        "cl":"Program",
        "me":"ReplaceMe",
        "ac":"replace",
        "index":0,
        "instructions":[{
            "opcode":"ldstr",
            "operand":"script working"
        }]
    },{
        "ns":"Test",
        "cl":"Program",
        "me":"RemoveMe",
        "ac":"empty"
    }]
}
```
Name this file script.json and place it into TestScript build folder and use it with Test.exe. For more info please refer to the [standalone repo](https://github.com/ioncodes/dnpatch.script).

# Credits
I'd like to thank these people:
* [0xd4d](https://github.com/0xd4d) for creating [dnlib](https://github.com/0xd4d/dnlib)
* [0xd4d](https://github.com/0xd4d) for creating [de4dot](https://github.com/0xd4d/de4dot)
* [Rottweiler](https://github.com/Rottweiler) for the PRs and help!
* [0megaD](https://github.com/0megaD) for the fixes which my eyes missed and for using dnpatch in his projects!
* [DivideREiS](https://github.com/dividereis) for fixing my typos and getting my lazy ass back to work on the BuildMemberRef/BuildCall method!



================================================
File: LICENSE
================================================
MIT License

Copyright (c) 2017 Luca Marcelli

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
File: PULL_REQUEST_TEMPLATE.md
================================================
* Add examples
* If possible include screenshots from dnSpy


================================================
File: dnpatch.sln
================================================
ï»¿
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 14
VisualStudioVersion = 14.0.25420.1
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "dnpatch", "dnpatch\dnpatch.csproj", "{14CA7A28-7FA8-40A0-ABC6-81E9F36318DE}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Example", "Example\Example.csproj", "{B38BB1AE-DE16-41F1-926F-A1DA233B0A30}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Test", "Test\Test.csproj", "{773F8B20-46D8-4DCC-A146-92E92E8B76F5}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "dnpatch.deobfuscation", "dnpatch.deobfuscation\dnpatch.deobfuscation.csproj", "{D2A5E850-4078-4C19-B2F4-7F8556CAD473}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "TestObfuscated", "TestObfuscated\TestObfuscated.csproj", "{E4C1C1DD-B655-405D-9477-4A305D29236F}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ExampleDeobfuscation", "ExampleDeobfuscation\ExampleDeobfuscation.csproj", "{29D63DBA-F2EB-4C8A-9DAC-74A6BFDD087E}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Examples", "Examples", "{0C4D98EE-E1F6-4C46-941D-24CEB4C4F64B}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "UnpackMe1", "UnpackMe1\UnpackMe1.csproj", "{80ED992E-77C3-43DF-8A41-54838719F7A8}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "UnpackMe2", "UnpackMe2\UnpackMe2.csproj", "{055F8169-03F0-40A1-B9EB-020AE5810CA7}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Tests", "Tests", "{29051463-2FA8-4444-B02E-5AA3D784F06F}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "dnpatch.script", "dnpatch.script\dnpatch.script.csproj", "{34AAC8D2-EC71-43A4-B107-3085F07D6B35}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "dnpatch", "dnpatch", "{E09E6B09-7513-4F57-B651-FD7EFEC50652}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "dnpatch.deobfuscation", "dnpatch.deobfuscation", "{10115910-5349-40D0-8C87-FB04950429A4}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "dnpatch.script", "dnpatch.script", "{91A594B0-6AAC-436A-9962-F4F55164F145}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "TestScript", "TestScript\TestScript.csproj", "{1C0FA309-87CB-48D3-8C0E-BE2155B05E86}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{14CA7A28-7FA8-40A0-ABC6-81E9F36318DE}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{14CA7A28-7FA8-40A0-ABC6-81E9F36318DE}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{14CA7A28-7FA8-40A0-ABC6-81E9F36318DE}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{14CA7A28-7FA8-40A0-ABC6-81E9F36318DE}.Release|Any CPU.Build.0 = Release|Any CPU
		{B38BB1AE-DE16-41F1-926F-A1DA233B0A30}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{B38BB1AE-DE16-41F1-926F-A1DA233B0A30}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{B38BB1AE-DE16-41F1-926F-A1DA233B0A30}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{B38BB1AE-DE16-41F1-926F-A1DA233B0A30}.Release|Any CPU.Build.0 = Release|Any CPU
		{773F8B20-46D8-4DCC-A146-92E92E8B76F5}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{773F8B20-46D8-4DCC-A146-92E92E8B76F5}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{773F8B20-46D8-4DCC-A146-92E92E8B76F5}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{773F8B20-46D8-4DCC-A146-92E92E8B76F5}.Release|Any CPU.Build.0 = Release|Any CPU
		{D2A5E850-4078-4C19-B2F4-7F8556CAD473}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{D2A5E850-4078-4C19-B2F4-7F8556CAD473}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{D2A5E850-4078-4C19-B2F4-7F8556CAD473}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{D2A5E850-4078-4C19-B2F4-7F8556CAD473}.Release|Any CPU.Build.0 = Release|Any CPU
		{E4C1C1DD-B655-405D-9477-4A305D29236F}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{E4C1C1DD-B655-405D-9477-4A305D29236F}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{E4C1C1DD-B655-405D-9477-4A305D29236F}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{E4C1C1DD-B655-405D-9477-4A305D29236F}.Release|Any CPU.Build.0 = Release|Any CPU
		{29D63DBA-F2EB-4C8A-9DAC-74A6BFDD087E}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{29D63DBA-F2EB-4C8A-9DAC-74A6BFDD087E}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{29D63DBA-F2EB-4C8A-9DAC-74A6BFDD087E}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{29D63DBA-F2EB-4C8A-9DAC-74A6BFDD087E}.Release|Any CPU.Build.0 = Release|Any CPU
		{80ED992E-77C3-43DF-8A41-54838719F7A8}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{80ED992E-77C3-43DF-8A41-54838719F7A8}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{80ED992E-77C3-43DF-8A41-54838719F7A8}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{80ED992E-77C3-43DF-8A41-54838719F7A8}.Release|Any CPU.Build.0 = Release|Any CPU
		{055F8169-03F0-40A1-B9EB-020AE5810CA7}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{055F8169-03F0-40A1-B9EB-020AE5810CA7}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{055F8169-03F0-40A1-B9EB-020AE5810CA7}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{055F8169-03F0-40A1-B9EB-020AE5810CA7}.Release|Any CPU.Build.0 = Release|Any CPU
		{34AAC8D2-EC71-43A4-B107-3085F07D6B35}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{34AAC8D2-EC71-43A4-B107-3085F07D6B35}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{34AAC8D2-EC71-43A4-B107-3085F07D6B35}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{34AAC8D2-EC71-43A4-B107-3085F07D6B35}.Release|Any CPU.Build.0 = Release|Any CPU
		{1C0FA309-87CB-48D3-8C0E-BE2155B05E86}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{1C0FA309-87CB-48D3-8C0E-BE2155B05E86}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{1C0FA309-87CB-48D3-8C0E-BE2155B05E86}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{1C0FA309-87CB-48D3-8C0E-BE2155B05E86}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(NestedProjects) = preSolution
		{B38BB1AE-DE16-41F1-926F-A1DA233B0A30} = {E09E6B09-7513-4F57-B651-FD7EFEC50652}
		{773F8B20-46D8-4DCC-A146-92E92E8B76F5} = {29051463-2FA8-4444-B02E-5AA3D784F06F}
		{E4C1C1DD-B655-405D-9477-4A305D29236F} = {29051463-2FA8-4444-B02E-5AA3D784F06F}
		{29D63DBA-F2EB-4C8A-9DAC-74A6BFDD087E} = {10115910-5349-40D0-8C87-FB04950429A4}
		{80ED992E-77C3-43DF-8A41-54838719F7A8} = {E09E6B09-7513-4F57-B651-FD7EFEC50652}
		{055F8169-03F0-40A1-B9EB-020AE5810CA7} = {10115910-5349-40D0-8C87-FB04950429A4}
		{E09E6B09-7513-4F57-B651-FD7EFEC50652} = {0C4D98EE-E1F6-4C46-941D-24CEB4C4F64B}
		{10115910-5349-40D0-8C87-FB04950429A4} = {0C4D98EE-E1F6-4C46-941D-24CEB4C4F64B}
		{91A594B0-6AAC-436A-9962-F4F55164F145} = {0C4D98EE-E1F6-4C46-941D-24CEB4C4F64B}
		{1C0FA309-87CB-48D3-8C0E-BE2155B05E86} = {29051463-2FA8-4444-B02E-5AA3D784F06F}
	EndGlobalSection
EndGlobal



================================================
File: Example/App.config
================================================
ï»¿<?xml version="1.0" encoding="utf-8" ?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5.2" />
    </startup>
</configuration>


================================================
File: Example/Example.csproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="14.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{B38BB1AE-DE16-41F1-926F-A1DA233B0A30}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>Example</RootNamespace>
    <AssemblyName>Example</AssemblyName>
    <TargetFrameworkVersion>v4.5.2</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="dnlib, Version=1.6.0.0, Culture=neutral, PublicKeyToken=50e96378b6e77999, processorArchitecture=MSIL">
      <SpecificVersion>False</SpecificVersion>
      <HintPath>..\Libraries\dnlib.dll</HintPath>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Net.Http" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\dnpatch\dnpatch.csproj">
      <Project>{14ca7a28-7fa8-40a0-abc6-81e9f36318de}</Project>
      <Name>dnpatch</Name>
    </ProjectReference>
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>


================================================
File: Example/Program.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using dnpatch;

namespace Example
{
    class Program
    {
        static void Main(string[] args)
        {
            /*
             * Replaces all instructions with your own body
             */
            Patcher p = new Patcher("Test.exe");
            Instruction[] opcodesConsoleWriteLine = {
                Instruction.Create(OpCodes.Ldstr, "Hello Sir"), // String to print
                Instruction.Create(OpCodes.Call, p.BuildCall(typeof(Console), "WriteLine", typeof(void), new[] { typeof(string) })), // Console.WriteLine call
                Instruction.Create(OpCodes.Ret) // Always return smth
            };
            Target target = new Target()
            {
                Namespace = "Test",
                Class = "Program",
                Method = "Print",
                Instructions = opcodesConsoleWriteLine
            };
            p.Patch(target);
            p.Save("Test1.exe");


            /*
             * Replaces the instructions at the given index
             */
            p = new Patcher("Test.exe");
            Instruction[] opCodesManipulateOffset = {
                Instruction.Create(OpCodes.Ldstr, "Place easter egg here 1"),
                Instruction.Create(OpCodes.Ldstr, "Place easter egg here 2")
            };
            int[] Indices = {
                4,
                8
            };
            target = new Target()
            {
                Namespace = "Test",
                Class = "Program",
                Method = "PrintAlot",
                Instructions = opCodesManipulateOffset,
                Indices = Indices
            };
            p.Patch(target);
            p.Save("Test2.exe");


            /*
             * Replaces the instructions at the given index in a nested class
             */
            p = new Patcher("Test.exe");
            Instruction opCodeManipulateOffsetNestedClass = Instruction.Create(OpCodes.Ldstr, "FooBarCode");
            int index = 0;
            string nestedClass = "Bar";
            target = new Target()
            {
                Namespace = "Test",
                Class = "Foo",
                NestedClass = nestedClass,
                Method = "NestedPrint",
                Instruction = opCodeManipulateOffsetNestedClass,
                Index = index
            };
            p.Patch(target);
            p.Save("Test3.exe");


            /*
             * Replaces the instructions at the given index in a big nested class
             */
            p = new Patcher("Test.exe");
            Instruction opCodeManipulateOffsetNestedClasses = Instruction.Create(OpCodes.Ldstr, "Eat fruits");
            index = 0;
            string[] nestedClasses = {
                "Am",
                "A",
                "Burger"
            };
            target = new Target()
            {
                Namespace = "Test",
                Class = "I",
                NestedClasses = nestedClasses,
                Method = "Eat",
                Instruction = opCodeManipulateOffsetNestedClasses,
                Index = index
            };
            p.Patch(target);
            p.Save("Test4.exe");


            /*
             * Replaces the instructions at the given index which has been find via FindInstruction
             */
            p = new Patcher("Test.exe");
            Instruction opCodeReplaceInstruction = Instruction.Create(OpCodes.Ldstr, "TheTrain");
            Instruction toFind = Instruction.Create(OpCodes.Ldstr, "TheWord");
            target = new Target()
            {
                Namespace = "Test",
                Class = "Program",
                Method = "FindMe",
                Instruction = opCodeReplaceInstruction
            };
            target.Index = p.FindInstruction(target, toFind);
            p.Patch(target);
            p.Save("Test5.exe");


            /*
             * Replaces a instruction at the given index
             */
            p = new Patcher("Test.exe");
            Instruction opCodeReplaceMe = Instruction.Create(OpCodes.Ldstr, "I love kittens");
            target = new Target()
            {
                Namespace = "Test",
                Class = "Program",
                Method = "ReplaceMe",
                Instruction = opCodeReplaceMe,
                Index = 0
            };
            p.ReplaceInstruction(target);
            p.Save("Test6.exe");


            /*
             * Removes the instrutions at the given Indices
             */
            p = new Patcher("Test.exe");
            target = new Target()
            {
                Namespace = "Test",
                Class = "Program",
                Method = "RemoveMe",
                Indices = new[]{1,2}
            };
            p.RemoveInstruction(target);
            p.Save("Test7.exe");


            /*
             * Patches the operands at the given index
             */
            p = new Patcher("Test.exe");
            target = new Target()
            {
                Namespace = "Test",
                Class = "Program",
                Method = "PrintAlot",
                Index = 0
            };
            p.PatchOperand(target, "PatchedOperand");
            p.Save("Test8.exe");


            /*
             * Overwrites methodbody with return true
             */
            target = new Target()
            {
                Namespace = "Test",
                Class = "Program",
                Method = "VerifyMe"
            };
            p.WriteReturnBody(target, true);
            p.Save("Test9.exe");


            /*
             * Overwrites methodbody with return false
             */
            target = new Target()
            {
                Namespace = "Test",
                Class = "Program",
                Method = "VerifyMeNot"
            };
            p.WriteReturnBody(target, false);
            p.Save("Test10.exe");


            /*
             * Clears the methodbody
             */
            target = new Target()
            {
                Namespace = "Test",
                Class = "Program",
                Method = "WriteLog"
            };
            p.WriteEmptyBody(target);
            p.Save("Test11.exe");


            /*
             * Overload selection & manipulation
             */
            target = new Target()
            {
                Namespace = "Test",
                Class = "Program",
                Method = "SameName",
                Parameters = new [] {"String", "Int32"}
            };
            p.WriteEmptyBody(target);
            p.Save("Test12.exe");


            /*
             * Rewrite property getter to return true
             */
            target = new Target()
            {
                Namespace = "Test",
                Class = "Program",
                Property = "IsPremium",
                PropertyMethod = PropertyMethod.Get,
                Instructions = new []
                {
                    Instruction.Create(OpCodes.Ldc_I4_1),
                    Instruction.Create(OpCodes.Ret)  
                }
            };
            p.RewriteProperty(target);
            p.Save("Test13.exe");


            /*
             * Find Instructions by Regex
             */
            target = new Target()
            {
                Namespace = "Test",
                Class = "Program",
                Method = "FindSomeILByRegex",
            };
            var regexed = p.FindInstructionsByRegex(target, "ldc\\.i4\\s+1123[\\W\\d\\w]+\"Damn\"", false);
            foreach(var @int in regexed[0].Indices)
            {
                Console.Write(@int);
            }
            p.Save("Test14.exe");
            

            /*
             * OBFUSCATED EXAMPLES HERE, BECAUSE WE DONT WANT TO OVERWRITE THE OBFUSCATED ASSEMBLY INTERNALLY 
             */


            /*
             * Tries to find Indices in a obfuscated assembly by string operands
             */
            var op = new Patcher("TestObfuscated.exe", true);
            string[] operands = {
                "Find",
                "TheWord",
                "The",
                "Word",
                "You",
                "Wont"
            };
            var obfuscatedTargets = op.FindInstructionsByOperand(operands);
            foreach (var obfTarget in obfuscatedTargets)
            {
                obfTarget.Instructions = new Instruction[]
                {
                    Instruction.Create(OpCodes.Ldstr, "Obfuscator"),
                    Instruction.Create(OpCodes.Ldstr, "Got"),
                    Instruction.Create(OpCodes.Ldstr, "Rekt"),
                    Instruction.Create(OpCodes.Ldstr, "Hell"),
                    Instruction.Create(OpCodes.Ldstr, "Yeah"),
                    Instruction.Create(OpCodes.Ldstr, "!")
                };
            }
            op.Patch(obfuscatedTargets);
            op.Save("TestObfuscated1.exe");


            /*
             * Find method in obfuscated assembly by OpCodes
             */
            op = new Patcher("TestObfuscated.exe", true);
            OpCode[] opc = { 
                OpCodes.Ldstr,
                OpCodes.Call,
                OpCodes.Call,
                OpCodes.Call,
                OpCodes.Call,
                OpCodes.Brfalse_S,
                OpCodes.Stloc_0,
                OpCodes.Ldc_I4_0,
                OpCodes.Br_S,
                OpCodes.Ldloc_1,
                OpCodes.Add,
                OpCodes.Blt_S
            }; // find these
            obfuscatedTargets = op.FindInstructionsByOpcode(opc);
            foreach (var obfTarget in obfuscatedTargets)
            {
                obfTarget.Instructions = new Instruction[]
                {
                    Instruction.Create(OpCodes.Ldstr, "Obfuscators cant beat my library :P"),
                    Instruction.Create(OpCodes.Call,  op.BuildCall(typeof(Console), "WriteLine", typeof(void), new[]{typeof(string)})),
                    Instruction.Create(OpCodes.Ret)  
                };
                obfTarget.Indices = null; // Replace whole body
            }
            op.Patch(obfuscatedTargets);
            op.Save("TestObfuscated2.exe");

            Console.Read();
        }
    }
}


================================================
File: Example/Properties/AssemblyInfo.cs
================================================
ï»¿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Example")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("Example")]
[assembly: AssemblyCopyright("Copyright Â©  2016")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("b38bb1ae-de16-41f1-926f-a1da233b0a30")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]



================================================
File: ExampleDeobfuscation/App.config
================================================
ï»¿<?xml version="1.0" encoding="utf-8" ?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5.2" />
    </startup>
</configuration>


================================================
File: ExampleDeobfuscation/ExampleDeobfuscation.csproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="14.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{29D63DBA-F2EB-4C8A-9DAC-74A6BFDD087E}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>ExampleDeobfuscation</RootNamespace>
    <AssemblyName>ExampleDeobfuscation</AssemblyName>
    <TargetFrameworkVersion>v4.5.2</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Net.Http" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\dnpatch.deobfuscation\dnpatch.deobfuscation.csproj">
      <Project>{d2a5e850-4078-4c19-b2f4-7f8556cad473}</Project>
      <Name>dnpatch.deobfuscation</Name>
    </ProjectReference>
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>


================================================
File: ExampleDeobfuscation/Program.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using dnpatch.deobfuscation;

namespace ExampleDeobfuscation
{
    class Program
    {
        static void Main(string[] args)
        {
            Deobfuscation d = new Deobfuscation("Dotfuscator.exe", "Dotfuscator.deob.exe");
            d.Deobfuscate();

            d = new Deobfuscation("SmartAssembly.exe", "SmartAssembly.deob.exe");
            d.Deobfuscate();

            d = new Deobfuscation("Babel.exe", "Babel.deob.exe");
            d.Deobfuscate();

            d = new Deobfuscation("Eazfuscator.exe", "Eazfuscator.deob.exe");
            d.Deobfuscate();

            d = new Deobfuscation("ILProtector.exe", "ILProtector.deob.exe");
            d.Deobfuscate();

            d = new Deobfuscation("Confuser.exe", "Confuser.deob.exe");
            d.Deobfuscate();

            Console.Read();
        }
    }
}



================================================
File: ExampleDeobfuscation/Properties/AssemblyInfo.cs
================================================
ï»¿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("ExampleDeobfuscation")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("ExampleDeobfuscation")]
[assembly: AssemblyCopyright("Copyright Â©  2016")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("29d63dba-f2eb-4c8a-9dac-74a6bfdd087e")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]




================================================
File: Test/App.config
================================================
ï»¿<?xml version="1.0" encoding="utf-8" ?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5.2" />
    </startup>
</configuration>


================================================
File: Test/Foo.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Test
{
    class Foo
    {
        public class Bar
        {
            public void NestedPrint()
            {
                Console.WriteLine("Coded with Swag");
            }
        }
    }
}



================================================
File: Test/I.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Test
{
    class I
    {
        public class Am
        {
            public class A
            {
                public class Burger
                {
                    public void Eat()
                    {
                        Console.WriteLine("Eating... Hold on.");
                    }
                }
            }
        }
    }
}



================================================
File: Test/Program.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Test
{
    class Program
    {
        private bool _isPremium = false;

        public bool IsPremium
        {
            get { return _isPremium; }
        }

        static void Main(string[] args)
        {
            Print();
            Check(10);
            PrintAlot();
            Foo.Bar foobar = new Foo.Bar();
            foobar.NestedPrint();
            I.Am.A.Burger burger = new I.Am.A.Burger();
            burger.Eat();
            FindMe();
            ReplaceMe();
            RemoveMe();
            VerifyMe();
            VerifyMeNot();
            WriteLog();
            BigMethodBootySorryIMeanBody();
            SameName();
            SameName("SameName: 1 string param");
            SameName(1337);
            SameName("SameName: 2 param; string, int ", 1337);
            FindSomeILByRegex();
            Console.Read();
        }

        static void Print()
        {
            Console.WriteLine("Hello");
        }

        static void Check(int i)
        {
            Console.WriteLine(i > 0 ? "Error" : "Secret Key Here");
        }

        static void PrintAlot()
        {
            Console.WriteLine("Hello");
            Console.WriteLine("Hello");
            Console.WriteLine("Hello");
            Console.WriteLine("Hello");
            Console.WriteLine("Hello");
            Console.WriteLine("Hello");
            Console.WriteLine("Hello");
            Console.WriteLine("Hello");
        }

        static void FindMe()
        {
            Console.WriteLine("You");
            Console.WriteLine("Wont");
            Console.WriteLine("Find");
            Console.WriteLine("TheWord");
            Console.WriteLine("The");
            Console.WriteLine("Word");
        }

        static void ReplaceMe()
        {
            Console.WriteLine("I love dogs");
        }

        static void RemoveMe()
        {
            Console.WriteLine("The next sentence is a lie");
            Console.WriteLine("ion is best");
        }

        static bool VerifyMe()
        {
            Console.WriteLine("Verification failed");
            return false;
        }

        static bool VerifyMeNot()
        {
            Console.WriteLine("Verification worked, but that's not good");
            return true;
        }

        static void WriteLog()
        {
            Console.WriteLine("harmful log 1");
            Console.WriteLine("harmful log 2");
            Console.WriteLine("harmful log 3");
            Console.WriteLine("harmful log 4");
        }

        static void BigMethodBootySorryIMeanBody()
        {
            Console.WriteLine("need to get some ideas");
            if (VerifyMe())
            {
                Console.WriteLine("for my console prints...");
            }
            int imUseless = 1337;
            for (int i = 0; i < imUseless; i++)
            {
                Console.WriteLine(i);
            }
        }

        static void SameName()
        {
            Console.WriteLine("SameName: No params");
        }

        static void SameName(string t)
        {
            Console.WriteLine(t);
        }

        static void SameName(int i)
        {
            Console.WriteLine("SameName: 1 int param " + i);
        }

        static void SameName(string t, int i)
        {
            Console.WriteLine(t + i);
        }

        static void FindSomeILByRegex()
        {
            int imUseless = 1337;
            for (int i = 0; i < imUseless; i++)
            {
                Console.WriteLine(i);
            }
            imUseless = 1233;
            for (int i = 0; i < imUseless; i++)
            {
                Console.WriteLine(i);
            }
            imUseless = 3123;
            for (int i = 0; i < imUseless; i++)
            {
                Console.WriteLine(i);
            }
            imUseless = 1231;
            for (int i = 0; i < imUseless; i++)
            {
                Console.WriteLine(i);
            }
            imUseless = 1123;
            for (int i = 0; i < imUseless; i++)
            {
                for(int j = 0; j < 9; j++) Console.WriteLine("Damn");
                Console.WriteLine(i);
            }
        }
    }
}



================================================
File: Test/Test.csproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="14.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{773F8B20-46D8-4DCC-A146-92E92E8B76F5}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>Test</RootNamespace>
    <AssemblyName>Test</AssemblyName>
    <TargetFrameworkVersion>v4.5.2</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>..\Example\bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Net.Http" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Foo.cs" />
    <Compile Include="I.cs" />
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>


================================================
File: Test/Properties/AssemblyInfo.cs
================================================
ï»¿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Test")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("Test")]
[assembly: AssemblyCopyright("Copyright Â©  2016")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("773f8b20-46d8-4dcc-a146-92e92e8b76f5")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]



================================================
File: TestObfuscated/App.config
================================================
ï»¿<?xml version="1.0" encoding="utf-8" ?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5.2" />
    </startup>
</configuration>


================================================
File: TestObfuscated/Program.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace TestObfuscated
{
    class Program
    {
        /*
         * Summary: Prints Hello World. As simple as that.
         */
        static void Main(string[] args)
        {
            int[,] y = new int[,]  {{p(), p(), p(), n(), n(), n(), p(), n(), },
                                    {p(), p(), n(), n(), p(), p(), p(), p(), },
                                    {p(), p(), n(), n(), n(), p(), p(), n(), },
                                    {p(), p(), n(), n(), n(), p(), p(), n(), },
                                    {p(), p(), n(), n(), n(), p(), n(), p(), },
                                    {p(), n(), n(), n(), p(), n(), p(), n(), },
                                    {p(), p(), p(), p(), p(), p(), n(), p(), },
                                    {p(), p(), n(), n(), n(), p(), n(), p(), },
                                    {p(), p(), n(), p(), p(), n(), n(), n(), },
                                    {p(), p(), n(), n(), n(), p(), p(), n(), },
                                    {p(), p(), n(), n(), p(), p(), p(), n(), },
                                    {p(), n(), n(), n(), p(), n(), p(), p(), }, };
            for (int i = 0; i < s(gr().ToArray()[21], 1) / gr().ToArray()[1]; i++)
            {
                bool[] h = new bool[8];
                for (int j = 0; j < 8; j++)
                {
                    h[j] = pr(y[i, j]);
                }
                cw(Encoding.ASCII.GetString(new byte[] { o(b(h), b()) }));
            }

            Console.Read();
        }
        static void cw(string st)
        {
            using (StreamWriter s = new StreamWriter(Console.OpenStandardOutput()))
            {
                foreach (char c in st)
                    s.Write(c);
            }
        }
        static byte o(byte c, byte z)
        {
            int l = s((0xAA00 ^ 0x0), -8);
            l |= z;
            return (byte)(c ^ l);
        }
        static byte b()
        {
            return (byte)s(0xFF, s(4097, 3));
        }
        static byte b(bool[] a)
        {
            byte v = 0;
            foreach (bool b in a)
            {
                v = (byte)s(v, 1);
                if (b) v |= 1;
            }
            return v;
        }
        static int s(int i, int s)
        {
            if (s > 0)
            {
                i <<= s;
                return i;
            }
            i >>= s + (s << 1);
            return i;
        }
        static string pa(string st)
        {
            for (int il = 0; il < s(gr().ToArray()[11], 1) - st.Length; il++)
                st = "0" + st;
            return st;
        }
        static IEnumerable<byte> gr()
        {
            byte[] m = Convert.FromBase64String("AwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWltcXV5fYGFiY2RlZg==");
            foreach (byte bh in m)
                yield return o(o(bh, b()), b());
        }
        static byte eb(bool[] ar)
        {
            byte v = 0;
            foreach (bool b in ar)
            {
                v <<= gr().ToArray()[1] - 3;
                if (b) v |= (byte)(gr().ToArray()[8] - gr().ToArray()[7]);
            }
            return v;
        }
        static int p()
        {
            foreach (byte b in gr())
                if (pr(b))
                    return b;
            return gr().ToArray()[gr().ToArray()[8] - gr().ToArray()[6]];
        }
        static int n()
        {
            foreach (byte b in gr())
                if (!pr(b))
                    return b;
            return gr().ToArray()[gr().ToArray()[0]];
        }
        static bool f(bool g)
        {
            return ((l(g) << gr().ToArray()[0] - 2) % gr().ToArray()[3] - 3 == 0);
        }
        static int l(bool k)
        {
            return (k ? (gr().ToArray()[12] >> gr().ToArray()[1]) : 0);
        }
        static bool pr(int t)
        {
            for (int i = gr().ToArray()[0] - 1; i < t; i++)
                if (t % i == 0)
                    return false;
            return true;
        }
    }
}



================================================
File: TestObfuscated/TestObfuscated.csproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="14.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{E4C1C1DD-B655-405D-9477-4A305D29236F}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>TestObfuscated</RootNamespace>
    <AssemblyName>TestObfuscated</AssemblyName>
    <TargetFrameworkVersion>v4.5.2</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>..\ExampleDeobfuscation\bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Net.Http" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>


================================================
File: TestObfuscated/Properties/AssemblyInfo.cs
================================================
ï»¿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("TestObfuscated")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("TestObfuscated")]
[assembly: AssemblyCopyright("Copyright Â©  2016")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("e4c1c1dd-b655-405d-9477-4a305d29236f")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]



================================================
File: TestScript/App.config
================================================
ï»¿<?xml version="1.0" encoding="utf-8" ?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5.2" />
    </startup>
</configuration>


================================================
File: TestScript/Program.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using dnpatch.script;

namespace TestScript
{
    class Program
    {
        static void Main(string[] args)
        {
            Script script = new Script("script.json");
            script.Patch();
            script.Save("scripted.exe");
        }
    }
}



================================================
File: TestScript/TestScript.csproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="14.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{1C0FA309-87CB-48D3-8C0E-BE2155B05E86}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>TestScript</RootNamespace>
    <AssemblyName>TestScript</AssemblyName>
    <TargetFrameworkVersion>v4.5.2</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Net.Http" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\dnpatch.script\dnpatch.script.csproj">
      <Project>{34aac8d2-ec71-43a4-b107-3085f07d6b35}</Project>
      <Name>dnpatch.script</Name>
    </ProjectReference>
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>


================================================
File: TestScript/Properties/AssemblyInfo.cs
================================================
ï»¿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("TestScript")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("TestScript")]
[assembly: AssemblyCopyright("Copyright Â©  2016")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("1c0fa309-87cb-48d3-8c0e-be2155b05e86")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]



================================================
File: UnpackMe1/App.config
================================================
ï»¿<?xml version="1.0" encoding="utf-8" ?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5.2" />
    </startup>
</configuration>


================================================
File: UnpackMe1/Program.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using dnlib.DotNet.Emit;
using dnpatch;
using dnpatch.deobfuscation;

namespace UnpackMe1
{
    class Program
    {
        static void Main(string[] args)
        {
            const string file = "UnpackMe_Confuser 1.7.exe";
            const string newFile = "UnpackMe_Confuser 1.7.deob.exe";
            Deobfuscation deobfuscation = new Deobfuscation(file, newFile);
            deobfuscation.Deobfuscate();

            Patcher patcher = new Patcher(newFile);
            Target target = new Target()
            {
                Class = "Form1",
                Namespace = "Confuser_1._7",
                Method = "Form1_Load",
                Indices = new []
                {
                    0,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6
                }
            };
            patcher.RemoveInstruction(target);
            target.Indices = null;
            target.Index = 2;
            patcher.PatchOperand(target, "Patched!");
            patcher.Save("UnpackMe_Confuser 1.7.deob.patch.exe");
        }
    }
}



================================================
File: UnpackMe1/UnpackMe1.csproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="14.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{80ED992E-77C3-43DF-8A41-54838719F7A8}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>UnpackMe1</RootNamespace>
    <AssemblyName>UnpackMe1</AssemblyName>
    <TargetFrameworkVersion>v4.5.2</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="dnlib">
      <HintPath>..\Libraries\dnlib.dll</HintPath>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Net.Http" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\dnpatch.deobfuscation\dnpatch.deobfuscation.csproj">
      <Project>{d2a5e850-4078-4c19-b2f4-7f8556cad473}</Project>
      <Name>dnpatch.deobfuscation</Name>
    </ProjectReference>
    <ProjectReference Include="..\dnpatch\dnpatch.csproj">
      <Project>{14ca7a28-7fa8-40a0-abc6-81e9f36318de}</Project>
      <Name>dnpatch</Name>
    </ProjectReference>
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>


================================================
File: UnpackMe1/Properties/AssemblyInfo.cs
================================================
ï»¿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("UnpackMe1")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("UnpackMe1")]
[assembly: AssemblyCopyright("Copyright Â©  2016")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("80ed992e-77c3-43df-8a41-54838719f7a8")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]



================================================
File: UnpackMe2/App.config
================================================
ï»¿<?xml version="1.0" encoding="utf-8" ?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5.2" />
    </startup>
</configuration>


================================================
File: UnpackMe2/Program.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using dnlib.DotNet.Emit;
using dnpatch;
using dnpatch.deobfuscation;

namespace UnpackMe2
{
    class Program
    {
        /*
         * First field: ioncodes
         * Click Button 1
         * Second field: ionCODES
         * Click Button 2
         * Enjoy Patches MessageBox
         */
        static void Main(string[] args)
        {
            Deobfuscation deobfuscation = new Deobfuscation("UnpackMe2.ori.exe", "UnpackMe2.deob1.exe");
            deobfuscation.Deobfuscate();
            deobfuscation = new Deobfuscation("UnpackMe2.deob1.exe", "UnpackMe2.deob2.exe");
            deobfuscation.Deobfuscate();

            Patcher obfuscationPatcher = new Patcher("UnpackMe2.deob2.exe", false);
            Target[] targets = obfuscationPatcher.FindInstructionsByOperand(new[]
            {
                "bBbBbBbBb",
                "AaAaA",
                "Good"
            });
            foreach (var target in targets)
            {
                target.Instructions = new[]
                {
                    Instruction.Create(OpCodes.Ldstr, "ion"),
                    Instruction.Create(OpCodes.Ldstr, "codes"),
                    Instruction.Create(OpCodes.Ldstr, "Patched!")
                };
            }
            obfuscationPatcher.Patch(targets);

            targets = obfuscationPatcher.FindInstructionsByOperand(new []
            {
                "ameereagle"
            });
            foreach (var target in targets)
            {
                target.Instruction = Instruction.Create(OpCodes.Ldstr, "ioncodes");
            }
            obfuscationPatcher.Patch(targets);

            obfuscationPatcher.Save("UnpackMe2.patched.exe");
        }
    }
}



================================================
File: UnpackMe2/UnpackMe2.csproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="14.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{055F8169-03F0-40A1-B9EB-020AE5810CA7}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>UnpackMe2</RootNamespace>
    <AssemblyName>UnpackMe2</AssemblyName>
    <TargetFrameworkVersion>v4.5.2</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="dnlib">
      <HintPath>..\Libraries\dnlib.dll</HintPath>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Net.Http" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\dnpatch.deobfuscation\dnpatch.deobfuscation.csproj">
      <Project>{d2a5e850-4078-4c19-b2f4-7f8556cad473}</Project>
      <Name>dnpatch.deobfuscation</Name>
    </ProjectReference>
    <ProjectReference Include="..\dnpatch\dnpatch.csproj">
      <Project>{14ca7a28-7fa8-40a0-abc6-81e9f36318de}</Project>
      <Name>dnpatch</Name>
    </ProjectReference>
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>


================================================
File: UnpackMe2/Properties/AssemblyInfo.cs
================================================
ï»¿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("UnpackMe2")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("UnpackMe2")]
[assembly: AssemblyCopyright("Copyright Â©  2016")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("055f8169-03f0-40a1-b9eb-020ae5810ca7")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]



================================================
File: dnpatch/README.md
================================================
# dnpatch
[WIP] .NET Patcher library using dnlib.

*If you have questions feel free to ask me via Gitter! I'm glad to help you out!*

[![Build status](https://ci.appveyor.com/api/projects/status/39jhu0noimfkgfw2?svg=true)](https://ci.appveyor.com/project/ioncodes/dnpatch)
[![Github All Releases](https://img.shields.io/github/downloads/ioncodes/dnpatch/total.svg)]
(https://github.com/ioncodes/dnpatch/releases)
[![Join the chat at https://gitter.im/dnpatch/Lobby](https://badges.gitter.im/dnpatch/Lobby.svg)](https://gitter.im/dnpatch/Lobby?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)

## Patching
The constructor takes the filename of the assembly.
```cs
Patcher patcher = new Patcher("Test.exe");
```
If you want to keep the old maxstack (for example for obfuscated assemblies) use the overload:
```cs
Patcher patcher = new Patcher("Test.exe", true);
```

### Targeting Methods
All methods take an object called Target as argument. The object is defined as follows:
```cs
public string Namespace { get; set; } // needed
public string Class { get; set; } // needed
public string Method { get; set; } // needed

/* If you want to patch multiple indexes in the method */
public int[] Indexes { get; set; }
public Instruction[] Instructions { get; set; }

/* If you want to patch 1 index in the method */
public int Index { get; set; } = -1;
public Instruction Instruction { get; set; }

/* If the path to the method has more than 1 nested class use this */
public string[] NestedClasses { get; set; }

/* If the path to the method has 1 nested class use this */
public string NestedClass { get; set; }
```
Please make sure that you don't assign inconsistent values, e.g.
```cs
var target = new Target
{
    Instructions = ...
    Instruction = ...
}
```

If you want to patch multiple methods create a Target[] and pass it to the functions, it is accepted by the most of them.

### Creating Instructions
Reference dnlib and create an Instruction[] or Instruction with your Instruction(s) and assign Indexes (int[]) or Index with the indexes where the Instructions are. You can find them by reverse engineering your assembly via dnSpy or some other decompiler.

Small Example:
```cs
Instruction[] opCodes = {
    Instruction.Create(OpCodes.Ldstr, "Hello Sir 1"),
    Instruction.Create(OpCodes.Ldstr, "Hello Sir 2")
};
int[] indexes = {
    0, // index of Instruction
    2
};
Target target = new Target()
{
    Namespace = "Test",
    Class = "Program",
    Method = "Print",
    Instructions = opCodes,
    Indexes = indexes
};
```

### Patch the whole methodbody
To clear the whole methodbody and write your instructions, make sure that you don't assign the Indexes or Index property.

Here is an example:
```cs
Instruction[] opCodes = {
    Instruction.Create(OpCodes.Ldstr, "Hello Sir"), // String to print
    Instruction.Create(OpCodes.Call, p.BuildMemberRef("System", "Console", "WriteLine")), // Console.WriteLine call -> BUILDMEMBERREF IS ONLY FOR CONSOLE.WRITELINE
    Instruction.Create(OpCodes.Ret) // Alaway return smth
};
Target target = new Target()
{
    Namespace = "Test",
    Class = "Program",
    Method = "Print",
    Instructions = opCodes
};
```

### Apply the patch
To apply your modified instructions you can call the method 'Patch':
```cs
patcher.Patch(Target);
```
or
```cs
patcher.Patch(Target[]);
```

### Finding an instruction
In some cases it might be useful to have find an instruction within a method, for example if the method got updated.
```cs
Instruction opCode = Instruction.Create(OpCodes.Ldstr, "TheTrain");
Instruction toFind = Instruction.Create(OpCodes.Ldstr, "TheWord");
Target target = new Target()
{
    Namespace = "Test",
    Class = "Program",
    Method = "FindMe",
    Instruction = opCode // you can also set it later
};
target.Index = p.FindInstruction(target, toFind);
// now you have the full Target object
```

Let's say there are multiple identical instructions. What now, baoss? Well, it's simple. There's an overload that takes and int which is the occurence of the instruction which you'd like to find.
```cs
Instruction opCode = Instruction.Create(OpCodes.Ldstr, "TheTrain");
Instruction toFind = Instruction.Create(OpCodes.Ldstr, "TheWord");
Target target = new Target()
{
    Namespace = "Test",
    Class = "Program",
    Method = "FindMe",
    Instruction = opCode // you can also set it later
};
target.Index = p.FindInstruction(target, toFind, 2); // Sir, find the second occurence!
```

### Replacing instructions
In some cases it might be easier to just replace an instruction. At this point of development, it doesn't make much sense, but the features will come soon.
```cs
Instruction opCode = Instruction.Create(OpCodes.Ldstr, "I love kittens");
Target target = new Target()
{
    Namespace = "Test",
    Class = "Program",
    Method = "ReplaceMe",
    Instruction = opCode,
    Index = 0
};
p.ReplaceInstruction(target);
```

### Removing instructions
Let's say you want to remove instructions... Well it's simple as this:
```cs
Target target = new Target()
{
    Namespace = "Test",
    Class = "Program",
    Method = "RemoveMe",
    Indexes = new[]{0,1} // the indexes, you can also just use 'Index'
};
p.RemoveInstruction(target);
```

### Patching operands
Hmmm.... What if you find the console output offending? You can modify the Ldstr without even creating an instruction :)
```cs
Target target = new Target()
{
    Namespace = "Test",
    Class = "Program",
    Method = "PrintAlot",
    Index = 0
};
p.PatchOperand(target, "PatchedOperand"); // pass the Target and a string to replace
```
or incase you need to modify an int:
```cs
p.PatchOperand(target, 1337);
```
It is also able to patch multiple operands in the same method by using int[] or string[].

### Returning true/false
If you want to overwrite the methodbody with a return true/false statement you can do this:
```cs
target = new Target()
{
    Namespace = "Test",
    Class = "Program",
    Method = "VerifyMe"
};
p.WriteReturnBody(target, bool); // bool represents the return value
```

### Clearing methodbodies
If you just want to empty a methodbody, use this amigo:
```cs
target = new Target()
{
    Namespace = "Test",
    Class = "Program",
    Method = "WriteLog"
};
p.WriteEmptyBody(target);
```

### Getting instructions from target
Simply do this if you want to get instructions of the Target object:
```cs
target = new Target()
{
    Namespace = "Test",
    Class = "Program",
    Method = "WriteLog"
};
Instruction[] instructions = p.GetInstructions(target);
```

### Writing return bodies
If you want to overwrite the body with a return true/false do this:
```cs
target = new Target()
{
    Namespace = "Test",
    Class = "Program",
    Method = "WriteLog"
};
p.WriteReturnBody(target, bool);
// bool is the return value, e.g. true will return true ;)
```
If you want to remove the body simply call this:
```cs
target = new Target()
{
    Namespace = "Test",
    Class = "Program",
    Method = "WriteLog"
};
p.WriteEmptyBody(target);
```

### Find methods
If you want to find a method, you can simply scan the whole file by 2 ways:
```cs
p.FindInstructionsByOperand(string[]);
// or p.FindInstructionsByOperand(int[]);
// string[] with all operands in the method, if there are multiple identical operands, make sure to have the same amount as in the method.

// or do this via opcodes:
p.FindInstructionsByOpcode(OpCode[]);
```
Both ways return an Target[] which contains all targets pointing to the findings.

#### Find instructions in methods or classes
If you want to find the instructions and you know the class and optionally the method you can let this method return a Target[] with the pathes and indexes.
```cs
p.FindInstructionsByOperand(Target,int[],bool);
// int[]: the operands
// bool: if true it will search for the operands once, it will delete the index if the index was found

// for opcodes:
p.FindInstructionsByOpcode(Target,int[],bool);
```
mbo
### Building calls
To build calls like "Console.WriteLine()" you can use this method:
```cs
p.BuildMemberRef(string, string, string, Patcher.MemberRefType);
/* 
 * string 1 -> namespace, e.g. "System"
 * string 2 -> class, e.g. "Console"
 * string 3 -> method, e.g. "WriteLine"
 * MemberRefType -> the reference type, e.g. Static
 */
```
MemberRefType is defined as follows:
```cs
public enum MemberRefType
{
    Static,
    Instance
}
```
Here is an IL example for Console.WriteLine:
```cs
Instruction.Create(OpCodes.Call, p.BuildMemberRef("System", "Console", "WriteLine", Patcher.MemberRefType.Static));
```

### Saving the patched assembly
If you want to safe the assembly under a different name use this:
```cs
patcher.Save(String); // filename here
```
Or if you want to replace the original file:
```cs
patcher.Save(bool); // if true it will create a backup first (filename.bak)
```


================================================
File: dnpatch/Extensions.cs
================================================
ï»¿using dnlib.DotNet.Emit;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace dnpatch
{
    public static class Extensions
    {
        /// <summary>
        /// Dynamic IndexOf
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="haystack"></param>
        /// <param name="needle"></param>
        /// <returns></returns>
        public static IEnumerable<int> IndexOf<T>(this T[] haystack, T[] needle)
        {
            if ((needle != null) && (haystack.Length >= needle.Length))
            {
                for (int l = 0; l < haystack.Length - needle.Length + 1; l++)
                {
                    if (!needle.Where((data, index) => !haystack[l + index].Equals(data)).Any())
                    {
                        yield return l;
                    }
                }
            }
        }

        /// <summary>
        /// Get OpCode[] from Instruction[]
        /// </summary>
        /// <param name="main"></param>
        /// <returns></returns>
        public static IEnumerable<OpCode> GetOpCodes(this ICollection<Instruction> main)
        {
            return from instruction in main select instruction.OpCode;
        }
    }
}



================================================
File: dnpatch/ObfuscatedTarget.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using dnlib.DotNet;

namespace dnpatch
{
    public class ObfuscatedTarget
    {
        public TypeDef Type { get; set; }
        public MethodDef Method { get; set; }
        public List<int> Indices { get; set; }
        public List<string> NestedTypes = new List<string>();
    }
}



================================================
File: dnpatch/PatchHelper.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using dnlib.DotNet.Writer;

namespace dnpatch
{
    internal class PatchHelper
    {
        public readonly ModuleDef Module;
        private readonly string _file;
        private readonly bool _keepOldMaxStack = false;

        public PatchHelper(string file)
        {
            _file = file;
            Module = ModuleDefMD.Load(file);
        }

        public PatchHelper(string file, bool keepOldMaxStack)
        {
            _file = file;
            Module = ModuleDefMD.Load(file);
            _keepOldMaxStack = keepOldMaxStack;
        }

        public PatchHelper(ModuleDefMD module, bool keepOldMaxStack)
        {
            Module = module;
            _keepOldMaxStack = keepOldMaxStack;
        }

        public PatchHelper(ModuleDef module, bool keepOldMaxStack)
        {
            Module = module;
            _keepOldMaxStack = keepOldMaxStack;
        }

        public PatchHelper(Stream stream, bool keepOldMaxStack)
        {
            Module = ModuleDefMD.Load(stream);
            _keepOldMaxStack = keepOldMaxStack;
        }

        public  void PatchAndClear(Target target)
        {
            string[] nestedClasses = { };
            if (target.NestedClasses != null)
            {
                nestedClasses = target.NestedClasses;
            }
            else if (target.NestedClass != null)
            {
                nestedClasses = new[] { target.NestedClass };
            }
            var type = FindType(target.Namespace + "." + target.Class, nestedClasses);
            var method = FindMethod(type, target.Method, target.Parameters, target.ReturnType);
            var instructions = method.Body.Instructions;
            instructions.Clear();
            if (target.Instructions != null)
            {
                for (int i = 0; i < target.Instructions.Length; i++)
                {
                    instructions.Insert(i, target.Instructions[i]);
                }
            }
            else
            {
                instructions.Insert(0, target.Instruction);
            }
        }

        public  void PatchOffsets(Target target)
        {
            string[] nestedClasses = { };
            if (target.NestedClasses != null)
            {
                nestedClasses = target.NestedClasses;
            }
            else if (target.NestedClass != null)
            {
                nestedClasses = new[] { target.NestedClass };
            }
            var type = FindType(target.Namespace + "." + target.Class, nestedClasses);
            var method = FindMethod(type, target.Method, target.Parameters, target.ReturnType);
            var instructions = method.Body.Instructions;
            if (target.Indices != null && target.Instructions != null)
            {
                for (int i = 0; i < target.Indices.Length; i++)
                {
                    instructions[target.Indices[i]] = target.Instructions[i];
                }
            }
            else if (target.Index != -1 && target.Instruction != null)
            {
                instructions[target.Index] = target.Instruction;
            }
            else if (target.Index == -1)
            {
                throw new Exception("No index specified");
            }
            else if (target.Instruction == null)
            {
                throw new Exception("No instruction specified");
            }
            else if (target.Indices == null)
            {
                throw new Exception("No Indices specified");
            }
            else if (target.Instructions == null)
            {
                throw new Exception("No instructions specified");
            }
        }

        public  TypeDef FindType(string classPath, string[] nestedClasses)
        {
            if (classPath.First() == '.')
                classPath = classPath.Remove(0, 1);
            foreach (var module in Module.Assembly.Modules)
            {
                foreach (var type in Module.Types)
                {
                    if (type.FullName == classPath)
                    {
                        TypeDef t = null;
                        if (nestedClasses != null && nestedClasses.Length > 0)
                        {
                            foreach (var nc in nestedClasses)
                            {
                                if (t == null)
                                {
                                    if (!type.HasNestedTypes) continue;
                                    foreach (var typeN in type.NestedTypes)
                                    {
                                        if (typeN.Name == nc)
                                        {
                                            t = typeN;
                                        }
                                    }
                                }
                                else
                                {
                                    if (!t.HasNestedTypes) continue;
                                    foreach (var typeN in t.NestedTypes)
                                    {
                                        if (typeN.Name == nc)
                                        {
                                            t = typeN;
                                        }
                                    }
                                }
                            }
                        }
                        else
                        {
                            t = type;
                        }
                        return t;
                    }
                }
            }
            return null;
        }

        public PropertyDef FindProperty(TypeDef type, string property)
        {
            return type.Properties.FirstOrDefault(prop => prop.Name == property);
        }

        public  MethodDef FindMethod(TypeDef type, string methodName, string[] parameters, string returnType)
        {
            bool checkParams = parameters != null;
            foreach (var m in type.Methods)
            {
                bool isMethod = true;
                if (checkParams && parameters.Length != m.Parameters.Count) continue;
                if (methodName != m.Name) continue;
                if (!string.IsNullOrEmpty(returnType) && returnType != m.ReturnType.TypeName) continue;
                if (checkParams)
                {
                    if (m.Parameters.Where((param, i) => param.Type.TypeName != parameters[i]).Any())
                    {
                        isMethod = false;
                    }
                }
                if(isMethod) return m;
            }
            return null;
        }

        public  Target FixTarget(Target target)
        {
            target.Indices = new int[] { };
            target.Index = -1;
            target.Instruction = null;
            return target;
        }

        public  void Save(string name)
        {
            if (_keepOldMaxStack)
                Module.Write(name, new ModuleWriterOptions(Module)
                {
                    MetaDataOptions = {Flags = MetaDataFlags.KeepOldMaxStack}
                });
            else
                Module.Write(name);
        }

        public  void Save(bool backup)
        {
            if (string.IsNullOrEmpty(_file))
            {
                throw new Exception("Assembly/module was loaded in memory, and no file was specified. Use Save(string) method to save the patched assembly.");
            }
            if (_keepOldMaxStack)
                Module.Write(_file + ".tmp", new ModuleWriterOptions(Module)
                {
                    MetaDataOptions = { Flags = MetaDataFlags.KeepOldMaxStack }
                });
            else
                Module.Write(_file + ".tmp");
            Module.Dispose();
            if (backup)
            {
                if (File.Exists(_file + ".bak"))
                {
                    File.Delete(_file + ".bak");
                }
                File.Move(_file, _file + ".bak");
            }
            else
            {
                File.Delete(_file);
            }
            File.Move(_file + ".tmp", _file);
        }

        public Target[] FindInstructionsByOperand(string[] operand)
        {
            List<ObfuscatedTarget> obfuscatedTargets = new List<ObfuscatedTarget>();
            List<string> operands = operand.ToList();
            foreach (var type in Module.Types)
            {
                if (!type.HasNestedTypes)
                {
                    foreach (var method in type.Methods)
                    {
                        if (method.Body != null)
                        {
                            List<int> indexList = new List<int>();
                            var obfuscatedTarget = new ObfuscatedTarget()
                            {
                                Type = type,
                                Method = method
                            };
                            int i = 0;
                            foreach (var instruction in method.Body.Instructions)
                            {
                                if (instruction.Operand != null)
                                {
                                    if (operands.Contains(instruction.Operand.ToString()))
                                    {
                                        indexList.Add(i);
                                        operands.Remove(instruction.Operand.ToString());
                                    }
                                }
                                i++;
                            }
                            if (indexList.Count == operand.Length)
                            {
                                obfuscatedTarget.Indices = indexList;
                                obfuscatedTargets.Add(obfuscatedTarget);
                            }
                            operands = operand.ToList();
                        }
                    }
                }
                else
                {
                    var nestedTypes = type.NestedTypes;
                    NestedWorker:
                    foreach (var nestedType in nestedTypes)
                    {
                        foreach (var method in type.Methods)
                        {
                            if (method.Body != null)
                            {
                                List<int> indexList = new List<int>();
                                var obfuscatedTarget = new ObfuscatedTarget()
                                {
                                    Type = type,
                                    Method = method
                                };
                                int i = 0;
                                obfuscatedTarget.NestedTypes.Add(nestedType.Name);
                                foreach (var instruction in method.Body.Instructions)
                                {
                                    if (instruction.Operand != null)
                                    {
                                        if (operands.Contains(instruction.Operand.ToString()))
                                        {
                                            indexList.Add(i);
                                            operands.Remove(instruction.Operand.ToString());
                                        }
                                    }
                                    i++;
                                }
                                if (indexList.Count == operand.Length)
                                {
                                    obfuscatedTarget.Indices = indexList;
                                    obfuscatedTargets.Add(obfuscatedTarget);
                                }
                                operands = operand.ToList();
                            }
                        }
                        if (nestedType.HasNestedTypes)
                        {
                            nestedTypes = nestedType.NestedTypes;
                            goto NestedWorker;
                        }
                    }
                }
            }
            List<Target> targets = new List<Target>();
            foreach (var obfuscatedTarget in obfuscatedTargets)
            {
                Target t = new Target()
                {
                    Namespace = obfuscatedTarget.Type.Namespace,
                    Class = obfuscatedTarget.Type.Name,
                    Method = obfuscatedTarget.Method.Name,
                    NestedClasses = obfuscatedTarget.NestedTypes.ToArray()
                };
                if (obfuscatedTarget.Indices.Count == 1)
                {
                    t.Index = obfuscatedTarget.Indices[0];
                }
                else if (obfuscatedTarget.Indices.Count > 1)
                {
                    t.Indices = obfuscatedTarget.Indices.ToArray();
                }

                targets.Add(t);
            }
            return targets.ToArray();
        }

        public  Target[] FindInstructionsByOperand(int[] operand)
        {
            List<ObfuscatedTarget> obfuscatedTargets = new List<ObfuscatedTarget>();
            List<int> operands = operand.ToList();
            foreach (var type in Module.Types)
            {
                if (!type.HasNestedTypes)
                {
                    foreach (var method in type.Methods)
                    {
                        if (method.Body != null)
                        {
                            List<int> indexList = new List<int>();
                            var obfuscatedTarget = new ObfuscatedTarget()
                            {
                                Type = type,
                                Method = method
                            };
                            int i = 0;
                            foreach (var instruction in method.Body.Instructions)
                            {
                                if (instruction.Operand != null)
                                {
                                    if (operands.Contains(Convert.ToInt32(instruction.Operand.ToString())))
                                    {
                                        indexList.Add(i);
                                        operands.Remove(Convert.ToInt32(instruction.Operand.ToString()));
                                    }
                                }
                                i++;
                            }
                            if (indexList.Count == operand.Length)
                            {
                                obfuscatedTarget.Indices = indexList;
                                obfuscatedTargets.Add(obfuscatedTarget);
                            }
                            operands = operand.ToList();
                        }
                    }
                }
                else
                {
                    var nestedTypes = type.NestedTypes;
                    NestedWorker:
                    foreach (var nestedType in nestedTypes)
                    {
                        foreach (var method in type.Methods)
                        {
                            if (method.Body != null)
                            {
                                List<int> indexList = new List<int>();
                                var obfuscatedTarget = new ObfuscatedTarget()
                                {
                                    Type = type,
                                    Method = method
                                };
                                int i = 0;
                                obfuscatedTarget.NestedTypes.Add(nestedType.Name);
                                foreach (var instruction in method.Body.Instructions)
                                {
                                    if (instruction.Operand != null)
                                    {
                                        if (operands.Contains(Convert.ToInt32(instruction.Operand.ToString())))
                                        {
                                            indexList.Add(i);
                                            operands.Remove(Convert.ToInt32(instruction.Operand.ToString()));
                                        }
                                    }
                                    i++;
                                }
                                if (indexList.Count == operand.Length)
                                {
                                    obfuscatedTarget.Indices = indexList;
                                    obfuscatedTargets.Add(obfuscatedTarget);
                                }
                                operands = operand.ToList();
                            }
                        }
                        if (nestedType.HasNestedTypes)
                        {
                            nestedTypes = nestedType.NestedTypes;
                            goto NestedWorker;
                        }
                    }
                }
            }
            List<Target> targets = new List<Target>();
            foreach (var obfuscatedTarget in obfuscatedTargets)
            {
                Target t = new Target()
                {
                    Namespace = obfuscatedTarget.Type.Namespace,
                    Class = obfuscatedTarget.Type.Name,
                    Method = obfuscatedTarget.Method.Name,
                    NestedClasses = obfuscatedTarget.NestedTypes.ToArray()
                };
                if (obfuscatedTarget.Indices.Count == 1)
                {
                    t.Index = obfuscatedTarget.Indices[0];
                }
                else if (obfuscatedTarget.Indices.Count > 1)
                {
                    t.Indices = obfuscatedTarget.Indices.ToArray();
                }

                targets.Add(t);
            }
            return targets.ToArray();
        }

        public  Target[] FindInstructionsByOpcode(OpCode[] opcode)
        {
            List<ObfuscatedTarget> obfuscatedTargets = new List<ObfuscatedTarget>();
            List<string> operands = opcode.Select(o => o.Name).ToList();
            foreach (var type in Module.Types)
            {
                if (!type.HasNestedTypes)
                {
                    foreach (var method in type.Methods)
                    {
                        if (method.Body != null)
                        {
                            List<int> indexList = new List<int>();
                            var obfuscatedTarget = new ObfuscatedTarget()
                            {
                                Type = type,
                                Method = method
                            };
                            int i = 0;
                            foreach (var instruction in method.Body.Instructions)
                            {
                                if (operands.Contains(instruction.OpCode.Name))
                                {
                                    indexList.Add(i);
                                    operands.Remove(instruction.OpCode.Name);
                                }
                                i++;
                            }
                            if (indexList.Count == opcode.Length)
                            {
                                obfuscatedTarget.Indices = indexList;
                                obfuscatedTargets.Add(obfuscatedTarget);
                            }
                            operands = opcode.Select(o => o.Name).ToList();
                        }
                    }
                }
                else
                {
                    var nestedTypes = type.NestedTypes;
                    NestedWorker:
                    foreach (var nestedType in nestedTypes)
                    {
                        foreach (var method in type.Methods)
                        {
                            if (method.Body != null)
                            {
                                List<int> indexList = new List<int>();
                                var obfuscatedTarget = new ObfuscatedTarget()
                                {
                                    Type = type,
                                    Method = method
                                };
                                int i = 0;
                                obfuscatedTarget.NestedTypes.Add(nestedType.Name);
                                foreach (var instruction in method.Body.Instructions)
                                {
                                    if (operands.Contains(instruction.OpCode.Name))
                                    {
                                        indexList.Add(i);
                                        operands.Remove(instruction.OpCode.Name);
                                    }
                                    i++;
                                }
                                if (indexList.Count == opcode.Length)
                                {
                                    obfuscatedTarget.Indices = indexList;
                                    obfuscatedTargets.Add(obfuscatedTarget);
                                }
                                operands = opcode.Select(o => o.Name).ToList();
                            }
                        }
                        if (nestedType.HasNestedTypes)
                        {
                            nestedTypes = nestedType.NestedTypes;
                            goto NestedWorker;
                        }
                    }
                }
            }
            List<Target> targets = new List<Target>();
            foreach (var obfuscatedTarget in obfuscatedTargets)
            {
                Target t = new Target()
                {
                    Namespace = obfuscatedTarget.Type.Namespace,
                    Class = obfuscatedTarget.Type.Name,
                    Method = obfuscatedTarget.Method.Name,
                    NestedClasses = obfuscatedTarget.NestedTypes.ToArray()
                };
                if (obfuscatedTarget.Indices.Count == 1)
                {
                    t.Index = obfuscatedTarget.Indices[0];
                }
                else if (obfuscatedTarget.Indices.Count > 1)
                {
                    t.Indices = obfuscatedTarget.Indices.ToArray();
                }

                targets.Add(t);
            }
            return targets.ToArray();
        }

        public  Target[] FindInstructionsByOperand(Target target, int[] operand, bool removeIfFound = false)
        {
            List<ObfuscatedTarget> obfuscatedTargets = new List<ObfuscatedTarget>();
            List<int> operands = operand.ToList();
            TypeDef type = FindType(target.Namespace + "." + target.Class, target.NestedClasses);
            MethodDef m = null;
            if (target.Method != null)
                m = FindMethod(type, target.Method, target.Parameters, target.ReturnType);
            if (m != null)
            {
                List<int> indexList = new List<int>();
                var obfuscatedTarget = new ObfuscatedTarget()
                {
                    Type = type,
                    Method = m
                };
                int i = 0;
                foreach (var instruction in m.Body.Instructions)
                {
                    if (instruction.Operand != null)
                    {
                        if (operands.Contains(Convert.ToInt32(instruction.Operand.ToString())))
                        {
                            indexList.Add(i);
                            if (removeIfFound)
                                operands.Remove(Convert.ToInt32(instruction.Operand.ToString()));
                        }
                    }
                    i++;
                }
                if (indexList.Count == operand.Length || removeIfFound == false)
                {
                    obfuscatedTarget.Indices = indexList;
                    obfuscatedTargets.Add(obfuscatedTarget);
                }
                operands = operand.ToList();
            }
            else
            {
                foreach (var method in type.Methods)
                {
                    if (method.Body != null)
                    {
                        List<int> indexList = new List<int>();
                        var obfuscatedTarget = new ObfuscatedTarget()
                        {
                            Type = type,
                            Method = method
                        };
                        int i = 0;
                        foreach (var instruction in method.Body.Instructions)
                        {
                            if (instruction.Operand != null)
                            {
                                if (operands.Contains(Convert.ToInt32(instruction.Operand.ToString())))
                                {
                                    indexList.Add(i);
                                    if (removeIfFound)
                                        operands.Remove(Convert.ToInt32(instruction.Operand.ToString()));
                                }
                            }
                            i++;
                        }
                        if (indexList.Count == operand.Length || removeIfFound == false)
                        {
                            obfuscatedTarget.Indices = indexList;
                            obfuscatedTargets.Add(obfuscatedTarget);
                        }
                        operands = operand.ToList();
                    }
                }
            }

            List<Target> targets = new List<Target>();
            foreach (var obfuscatedTarget in obfuscatedTargets)
            {
                Target t = new Target()
                {
                    Namespace = obfuscatedTarget.Type.Namespace,
                    Class = obfuscatedTarget.Type.Name,
                    Method = obfuscatedTarget.Method.Name,
                    NestedClasses = obfuscatedTarget.NestedTypes.ToArray()
                };
                if (obfuscatedTarget.Indices.Count == 1)
                {
                    t.Index = obfuscatedTarget.Indices[0];
                }
                else if (obfuscatedTarget.Indices.Count > 1)
                {
                    t.Indices = obfuscatedTarget.Indices.ToArray();
                }

                targets.Add(t);
            }
            return targets.ToArray();
        }

        /// <summary>
        /// Find methods that contain a certain OpCode[] signature
        /// </summary>
        /// <returns></returns>
        public Target[] FindMethodsByOpCodeSignature(OpCode[] signature)
        {
            HashSet<MethodDef> found = new HashSet<MethodDef>();

            foreach (TypeDef td in Module.Types)
            {
                foreach (MethodDef md in td.Methods)
                {
                    if (md.HasBody)
                    {
                        if (md.Body.HasInstructions)
                        {
                            OpCode[] codes = md.Body.Instructions.GetOpCodes().ToArray();
                            if (codes.IndexOf<OpCode>(signature).Count() > 0)
                            {
                                found.Add(md);
                            }
                        }
                    }
                }
            }

            //cast each to Target
            return (from method in found select (Target)method).ToArray();
        }

        public  Target[] FindInstructionsByOpcode(Target target, OpCode[] opcode, bool removeIfFound = false)
        {
            List<ObfuscatedTarget> obfuscatedTargets = new List<ObfuscatedTarget>();
            List<string> operands = opcode.Select(o => o.Name).ToList();
            TypeDef type = FindType(target.Namespace + "." + target.Class, target.NestedClasses);
            MethodDef m = null;
            if (target.Method != null)
                m = FindMethod(type, target.Method, target.Parameters, target.ReturnType);
            if (m != null)
            {
                List<int> indexList = new List<int>();
                var obfuscatedTarget = new ObfuscatedTarget()
                {
                    Type = type,
                    Method = m
                };
                int i = 0;
                foreach (var instruction in m.Body.Instructions)
                {
                    if (operands.Contains(instruction.OpCode.Name))
                    {
                        indexList.Add(i);
                        if (removeIfFound)
                            operands.Remove(instruction.OpCode.Name);
                    }
                    i++;
                }
                if (indexList.Count == opcode.Length || removeIfFound == false)
                {
                    obfuscatedTarget.Indices = indexList;
                    obfuscatedTargets.Add(obfuscatedTarget);
                }
            }
            else
            {
                foreach (var method in type.Methods)
                {
                    if (method.Body != null)
                    {
                        List<int> indexList = new List<int>();
                        var obfuscatedTarget = new ObfuscatedTarget()
                        {
                            Type = type,
                            Method = method
                        };
                        int i = 0;
                        foreach (var instruction in method.Body.Instructions)
                        {
                            if (operands.Contains(instruction.OpCode.Name))
                            {
                                indexList.Add(i);
                                if (removeIfFound)
                                    operands.Remove(instruction.OpCode.Name);
                            }
                            i++;
                        }
                        if (indexList.Count == opcode.Length || removeIfFound == false)
                        {
                            obfuscatedTarget.Indices = indexList;
                            obfuscatedTargets.Add(obfuscatedTarget);
                        }
                        operands = opcode.Select(o => o.Name).ToList();
                    }
                }
            }

            List<Target> targets = new List<Target>();
            foreach (var obfuscatedTarget in obfuscatedTargets)
            {
                Target t = new Target()
                {
                    Namespace = obfuscatedTarget.Type.Namespace,
                    Class = obfuscatedTarget.Type.Name,
                    Method = obfuscatedTarget.Method.Name,
                    NestedClasses = obfuscatedTarget.NestedTypes.ToArray()
                };
                if (obfuscatedTarget.Indices.Count == 1)
                {
                    t.Index = obfuscatedTarget.Indices[0];
                }
                else if (obfuscatedTarget.Indices.Count > 1)
                {
                    t.Indices = obfuscatedTarget.Indices.ToArray();
                }

                targets.Add(t);
            }
            return targets.ToArray();
        }

        public Target[] FindInstructionsByRegex(Target target, string pattern, bool ignoreOperand)
        {
            var targets = new List<Target>();
            if(target.Namespace != null)
            {
                var type = FindType(target.Namespace + "." + target.Class, target.NestedClasses);
                if(target.Method != null) 
                {
                    string body = "";
                    var method = FindMethod(type, target.Method, target.Parameters, target.ReturnType);
                    foreach(var instruction in method.Body.Instructions) 
                    {
                        if(!ignoreOperand) 
                        {
                            body += instruction.OpCode + " " + instruction.Operand + "\n";
                        }
                        else
                        {
                            body += instruction.OpCode + "\n";
                        }
                    }
                    foreach(Match match in Regex.Matches(body, pattern))
                    {
                        int startIndex = body.Split(new string[] {match.Value}, StringSplitOptions.None)[0].Split('\n').Length-1;
                        int[] indices = {};
                        for(int i = 0; i < match.Value.Split('\n').Length; i++)
                        {
                            indices[i] = startIndex + i;
                        }
                        var t = new Target()
                        {
                            Indices = indices,
                            Method = target.Method,
                            Class = target.Class,
                            Namespace = target.Namespace,
                            NestedClasses = target.NestedClasses,
                            NestedClass = target.NestedClass
                        };
                        targets.Add(t);
                    }
                }
            }
            return targets.ToArray();
        }

        private bool CheckParametersByType(ParameterInfo[] parameters, Type[] types)
        {
            return !parameters.Where((t, i) => types[i] != t.ParameterType).Any();
        }

        public IMethod BuildCall(Type type, string method, Type returnType, Type[] parameters)
        {
            Importer importer = new Importer(Module);
            foreach (var m in type.GetMethods())
            {
                if (m.Name == method && m.ReturnType == returnType)
                {
                    if (m.GetParameters().Length == 0  && parameters == null)
                    {
                        IMethod meth = importer.Import(m);
                        return meth;
                    }
                    if ( m.GetParameters().Length == parameters.Length && CheckParametersByType(m.GetParameters(), parameters))
                    {
                        IMethod meth = importer.Import(m);
                        return meth;
                    }
                }
            }
            return null;
        }

        public  void ReplaceInstruction(Target target)
        {
            string[] nestedClasses = { };
            if (target.NestedClasses != null)
            {
                nestedClasses = target.NestedClasses;
            }
            else if (target.NestedClass != null)
            {
                nestedClasses = new[] { target.NestedClass };
            }
            var type = FindType(target.Namespace + "." + target.Class, nestedClasses);
            var method = FindMethod(type, target.Method, target.Parameters, target.ReturnType);
            var instructions = method.Body.Instructions;
            if (target.Index != -1 && target.Instruction != null)
            {
                instructions[target.Index] = target.Instruction;
            }
            else if (target.Indices != null && target.Instructions != null)
            {
                for(int i = 0;i<target.Indices.Length;i++) {
                    var index = target.Indices[i];
                    instructions[index] = target.Instructions[i];
                }
            }
            else
            {
                throw new Exception("Target object built wrong");
            }
        }

        public  void RemoveInstruction(Target target)
        {
            string[] nestedClasses = { };
            if (target.NestedClasses != null)
            {
                nestedClasses = target.NestedClasses;
            }
            else if (target.NestedClass != null)
            {
                nestedClasses = new[] { target.NestedClass };
            }
            var type = FindType(target.Namespace + "." + target.Class, nestedClasses);
            var method = FindMethod(type, target.Method, target.Parameters, target.ReturnType);
            var instructions = method.Body.Instructions;
            if (target.Index != -1 && target.Indices == null)
            {
                instructions.RemoveAt(target.Index);
            }
            else if (target.Index == -1 && target.Indices != null)
            {
                foreach (var index in target.Indices.OrderByDescending(v => v))
                {
                    instructions.RemoveAt(index);
                }
            }
            else
            {
                throw new Exception("Target object built wrong");
            }
        }

        public  Instruction[] GetInstructions(Target target)
        {
            var type = FindType(target.Namespace + "." + target.Class, target.NestedClasses);
            MethodDef method = FindMethod(type, target.Method, target.Parameters, target.ReturnType);
            return method.Body.Instructions.ToArray();
        }

        public  void PatchOperand(Target target, string operand)
        {
            TypeDef type = FindType(target.Namespace + "." + target.Class, target.NestedClasses);
            MethodDef method = FindMethod(type, target.Method, target.Parameters, target.ReturnType);
            var instructions = method.Body.Instructions;
            if (target.Indices == null && target.Index != -1)
            {
                instructions[target.Index].Operand = operand;
            }
            else if (target.Indices != null && target.Index == -1)
            {
                foreach (var index in target.Indices)
                {
                    instructions[index].Operand = operand;
                }
            }
            else
            {
                throw new Exception("Operand error");
            }
        }

        public  void PatchOperand(Target target, int operand)
        {
            TypeDef type = FindType(target.Namespace + "." + target.Class, target.NestedClasses);
            MethodDef method = FindMethod(type, target.Method, target.Parameters, target.ReturnType);
            var instructions = method.Body.Instructions;
            if (target.Indices == null && target.Index != -1)
            {
                instructions[target.Index].Operand = operand;
            }
            else if (target.Indices != null && target.Index == -1)
            {
                foreach (var index in target.Indices)
                {
                    instructions[index].Operand = operand;
                }
            }
            else
            {
                throw new Exception("Operand error");
            }
        }

        public void PatchOperand(Target target, string[] operand)
        {
            TypeDef type = FindType(target.Namespace + "." + target.Class, target.NestedClasses);
            MethodDef method = FindMethod(type, target.Method, target.Parameters, target.ReturnType);
            var instructions = method.Body.Instructions;
            if (target.Indices != null && target.Index == -1)
            {
                foreach (var index in target.Indices)
                {
                    instructions[index].Operand = operand[index];
                }
            }
            else
            {
                throw new Exception("Operand error");
            }
        }

        public  void PatchOperand(Target target, int[] operand)
        {
            TypeDef type = FindType(target.Namespace + "." + target.Class, target.NestedClasses);
            MethodDef method = FindMethod(type, target.Method, target.Parameters, target.ReturnType);
            var instructions = method.Body.Instructions;
            if (target.Indices != null && target.Index == -1)
            {
                foreach (var index in target.Indices)
                {
                    instructions[index].Operand = operand[index];
                }
            }
            else
            {
                throw new Exception("Operand error");
            }
        }

        public  string GetOperand(Target target)
        {
            TypeDef type = FindType(target.Namespace + "." + target.Class, target.NestedClasses);
            MethodDef method = FindMethod(type, target.Method, target.Parameters, target.ReturnType);
            return method.Body.Instructions[target.Index].Operand.ToString();
        }

        public int GetLdcI4Operand(Target target)
        {
            TypeDef type = FindType(target.Namespace + "." + target.Class, target.NestedClasses);
            MethodDef method = FindMethod(type, target.Method, target.Parameters, target.ReturnType);
            return method.Body.Instructions[target.Index].GetLdcI4Value();
        }

        public  int FindInstruction(Target target, Instruction instruction, int occurence)
        {
            occurence--; // Fix the occurence, e.g. second occurence must be 1 but hoomans like to write like they speak so why don't assist them?
            var type = FindType(target.Namespace + "." + target.Class, target.NestedClasses);
            MethodDef method = FindMethod(type, target.Method, target.Parameters, target.ReturnType);
            var instructions = method.Body.Instructions;
            int index = 0;
            int occurenceCounter = 0;
            foreach (var i in instructions)
            {
                if (i.Operand == null && instruction.Operand == null)
                {
                    if (i.OpCode.Name == instruction.OpCode.Name && occurenceCounter < occurence)
                    {
                        occurenceCounter++;
                    }
                    else if (i.OpCode.Name == instruction.OpCode.Name && occurenceCounter == occurence)
                    {
                        return index;
                    }
                }
                else if (i.OpCode.Name == instruction.OpCode.Name && i.Operand.ToString() == instruction.Operand.ToString() &&
                         occurenceCounter < occurence)
                {
                    occurenceCounter++;
                }
                else if (i.OpCode.Name == instruction.OpCode.Name && i.Operand.ToString() == instruction.Operand.ToString() &&
                         occurenceCounter == occurence)
                {
                    return index;
                }
                index++;
            }
            return -1;
        }

        public void RewriteProperty(Target target)
        {
            TypeDef type = FindType(target.Namespace + "." + target.Class, target.NestedClasses);
            PropertyDef property = FindProperty(type, target.Property);
            IList<Instruction> instructions = null;
            if (target.PropertyMethod == PropertyMethod.Get)
            {
                instructions = property.GetMethod.Body.Instructions;
            }
            else
            {
                instructions = property.SetMethod.Body.Instructions;
            }
            instructions.Clear();
            foreach (var instruction in target.Instructions)
            {
                instructions.Add(instruction);
            }
        }

        // See this: https://github.com/0xd4d/dnlib/blob/master/Examples/Example2.cs
        public void InjectMethod(Target target)
        {
            var type = FindType(target.Namespace + "." + target.Class, target.NestedClasses);
            type.Methods.Add(target.MethodDef);
            CilBody body = new CilBody();
            target.MethodDef.Body = body;
            if (target.ParameterDefs != null)
            {
                foreach (var param in target.ParameterDefs)
                {
                    target.MethodDef.ParamDefs.Add(param);
                }
            }
            if (target.Locals != null)
            {
                foreach (var local in target.Locals)
                {
                    body.Variables.Add(local);
                }
            }
            foreach (var il in target.Instructions)
            {
                body.Instructions.Add(il);
            }
        }

        public void AddCustomAttribute(Target target, CustomAttribute attribute)
        {
            TypeDef type = FindType(target.Namespace + "." + target.Class, target.NestedClasses);
            if (target.Method != null)
            {
                MethodDef method = FindMethod(type, target.Method, target.Parameters, target.ReturnType);
                method.CustomAttributes.Add(attribute);
            }
            else
            {
                type.CustomAttributes.Add(attribute);
            }
        }
        public void RemoveCustomAttribute(Target target, CustomAttribute attribute)
        {
            TypeDef type = FindType(target.Namespace + "." + target.Class, target.NestedClasses);
            if (target.Method != null)
            {
                MethodDef method = FindMethod(type, target.Method, target.Parameters, target.ReturnType);
                method.CustomAttributes.Remove(attribute);
            }
            else
            {
                type.CustomAttributes.Remove(attribute);
            }
        }

        public void RemoveCustomAttribute(Target target, int attributeIndex)
        {
            TypeDef type = FindType(target.Namespace + "." + target.Class, target.NestedClasses);
            if (target.Method != null)
            {
                MethodDef method = FindMethod(type, target.Method, target.Parameters, target.ReturnType);
                method.CustomAttributes.RemoveAt(attributeIndex);
            }
            else
            {
                type.CustomAttributes.RemoveAt(attributeIndex);
            }
        }

        public void ClearCustomAttributes(Target target)
        {
            TypeDef type = FindType(target.Namespace + "." + target.Class, target.NestedClasses);
            if (target.Method != null)
            {
                MethodDef method = FindMethod(type, target.Method, target.Parameters, target.ReturnType);
                method.CustomAttributes.Clear();
            }
            else
            {
                type.CustomAttributes.Clear();
            }
        }

        public Target GetEntryPoint()
        {
            return new Target()
            {
                Namespace = Module.EntryPoint.DeclaringType.Namespace,
                Class = Module.EntryPoint.DeclaringType.Name,
                Method = Module.EntryPoint.Name
            };
        }
    }
}



================================================
File: dnpatch/Patcher.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using dnlib.DotNet.Writer;
using CallingConvention = dnlib.DotNet.CallingConvention;

namespace dnpatch
{
    public class Patcher
    {
        private readonly PatchHelper _patcher = null;

        public Patcher(string file)
        {
            _patcher = new PatchHelper(file);
        }

        public Patcher(string file, bool keepOldMaxStack)
        {
            _patcher = new PatchHelper(file, keepOldMaxStack);
        }

        public Patcher(ModuleDefMD module, bool keepOldMaxStack)
        {
            _patcher = new PatchHelper(module, keepOldMaxStack);
        }

        public Patcher(ModuleDef module, bool keepOldMaxStack)
        {
            _patcher = new PatchHelper(module, keepOldMaxStack);
        }

        public Patcher(Stream stream, bool keepOldMaxStack)
        {
            _patcher = new PatchHelper(stream, keepOldMaxStack);
        }

        public ModuleDef GetModule()
        {
            return _patcher.Module;
        }

        public void Patch(Target target)
        {
            if ((target.Indices != null || target.Index != -1) &&
                (target.Instruction != null || target.Instructions != null))
            {
                _patcher.PatchOffsets(target);
            }
            else if ((target.Index == -1 && target.Indices == null) &&
                     (target.Instruction != null || target.Instructions != null))
            {
                _patcher.PatchAndClear(target);
            }
            else
            {
                throw new Exception("Check your Target object for inconsistent assignments");
            }
        }

        public void Patch(Target[] targets)
        {
            foreach (Target target in targets)
            {
                if ((target.Indices != null || target.Index != -1) &&
                    (target.Instruction != null || target.Instructions != null))
                {
                    _patcher.PatchOffsets(target);
                }
                else if ((target.Index == -1 && target.Indices == null) &&
                         (target.Instruction != null || target.Instructions != null))
                {
                    _patcher.PatchAndClear(target);
                }
                else
                {
                    throw new Exception("Check your Target object for inconsistent assignments");
                }
            }
        }

        public void Save(string name)
        {
            _patcher.Save(name);
        }

        public void Save(bool backup)
        {
           _patcher.Save(backup);
        }

        public int FindInstruction(Target target, Instruction instruction)
        {
            return _patcher.FindInstruction(target, instruction, 1);
        }

        public int FindInstruction(Target target, Instruction instruction, int occurence)
        {
            return _patcher.FindInstruction(target, instruction, occurence);
        }

        public void ReplaceInstruction(Target target)
        {
            _patcher.ReplaceInstruction(target);
        }

        public void RemoveInstruction(Target target)
        {
            _patcher.RemoveInstruction(target);
        }

        public Instruction[] GetInstructions(Target target)
        {
            return _patcher.GetInstructions(target);
        }

        public void PatchOperand(Target target, string operand)
        {
            _patcher.PatchOperand(target, operand);
        }

        public void PatchOperand(Target target, int operand)
        {
            _patcher.PatchOperand(target, operand);
        }

        public void PatchOperand(Target target, string[] operand)
        {
            _patcher.PatchOperand(target, operand);
        }

        public void PatchOperand(Target target, int[] operand)
        {
            _patcher.PatchOperand(target, operand);
        }

        public void WriteReturnBody(Target target, bool trueOrFalse)
        {
            target = _patcher.FixTarget(target);
            if (trueOrFalse)
            {
                target.Instructions = new Instruction[]
                {
                    Instruction.Create(OpCodes.Ldc_I4_1),
                    Instruction.Create(OpCodes.Ret)
                };
            }
            else
            {
                target.Instructions = new Instruction[]
                {
                    Instruction.Create(OpCodes.Ldc_I4_0),
                    Instruction.Create(OpCodes.Ret)
                };
            }

            _patcher.PatchAndClear(target);
        }

        /// <summary>
        /// Find methods that contain a certain OpCode[] signature
        /// </summary>
        /// <param name="signature"></param>
        /// <returns></returns>
        public Target[] FindMethodsByOpCodeSignature(params OpCode[] signature)
        {
            return _patcher.FindMethodsByOpCodeSignature(signature);
        }

        public void WriteEmptyBody(Target target)
        {
            target = _patcher.FixTarget(target);
            target.Instruction = Instruction.Create(OpCodes.Ret);
            _patcher.PatchAndClear(target);
        }

        public Target[] FindInstructionsByOperand(string[] operand)
        {
            return _patcher.FindInstructionsByOperand(operand);
        }

        public Target[] FindInstructionsByOperand(int[] operand)
        {
            return _patcher.FindInstructionsByOperand(operand);
        }

        public Target[] FindInstructionsByOpcode(OpCode[] opcode)
        {
            return _patcher.FindInstructionsByOpcode(opcode);
        }

        public Target[] FindInstructionsByOperand(Target target, int[] operand, bool removeIfFound = false)
        {
            return _patcher.FindInstructionsByOperand(target, operand, removeIfFound);
        }

        public Target[] FindInstructionsByOpcode(Target target, OpCode[] opcode, bool removeIfFound = false)
        {
            return _patcher.FindInstructionsByOpcode(target, opcode, removeIfFound);
        }

        [Obsolete("This functions is still in development")]
        public Target[] FindInstructionsByRegex(Target target, string pattern, bool ignoreOperand)
        {
            return _patcher.FindInstructionsByRegex(target, pattern, ignoreOperand);
        }

        public string GetOperand(Target target)
        {
            return _patcher.GetOperand(target);
        }

        public int GetLdcI4Operand(Target target)
        {
            return _patcher.GetLdcI4Operand(target);
        }

        public IMethod BuildCall(Type type, string method, Type returnType, Type[] parameters)
        {
            return _patcher.BuildCall(type, method, returnType, parameters);
        }

        public void RewriteProperty(Target target)
        {
            _patcher.RewriteProperty(target);
        }

        public void InjectMethod(Target target)
        {
            /*
             *  Example: https://github.com/0xd4d/dnlib/blob/master/Examples/Example2.cs
             *  MethodImplAttributes methImplFlags = MethodImplAttributes.IL | MethodImplAttributes.Managed;
			 *  MethodAttributes methFlags = MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.HideBySig | MethodAttributes.ReuseSlot;
			 *  MethodDef meth1 = new MethodDefUser("MyMethod", MethodSig.CreateStatic(mod.CorLibTypes.Int32, mod.CorLibTypes.Int32, mod.CorLibTypes.Int32), methImplFlags, methFlags);
             */
            _patcher.InjectMethod(target);
        }

        public void AddCustomAttribute(Target target, CustomAttribute attribute)
        {
            _patcher.AddCustomAttribute(target, attribute);
        }

        public void RemoveCustomAttribute(Target target, CustomAttribute attribute)
        {
            _patcher.RemoveCustomAttribute(target, attribute);
        }

        public void RemoveCustomAttribute(Target target, int attributeIndex)
        {
            _patcher.RemoveCustomAttribute(target, attributeIndex);
        }

        public void ClearCustomAttributes(Target target)
        {
            _patcher.ClearCustomAttributes(target);
        }

        public Target GetEntryPointTarget()
        {
            return _patcher.GetEntryPoint();
        }
    }
}



================================================
File: dnpatch/ResourcePatcher.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using dnlib.DotNet;

namespace dnpatch
{
    public class ResourcePatcher
    {
        private string file;
        private readonly ModuleDefMD module;
        private readonly ResourceCollection resources;

        public ResourcePatcher(string file)
        {
            this.file = file;
            module = ModuleDefMD.Load(file);
            resources = module.Resources;
        }

        public ResourceCollection GetResources()
        {
            return resources;
        }

        public void RemoveResource(int index)
        {
            resources.RemoveAt(index);
        }

        public void RemoveResources()
        {
            resources.Clear();
        }

        public void ReplaceResource(int index, string name, byte[] data)
        {
            resources[index] = new EmbeddedResource(name, data);
        }

        public void ReplaceResource(int index, string name, string file)
        {
            resources[index] = new EmbeddedResource(name, File.ReadAllBytes(file));
        }

        public void InsertResource(string name, byte[] data)
        {
            resources.Insert(resources.Count - 1, new EmbeddedResource(name, data));
        }

        public void InsertResource(string name, string file)
        {
            resources.Insert(resources.Count - 1, new EmbeddedResource(name, File.ReadAllBytes(file)));
        }

        public void Save(string name)
        {
            module.Write(name);
        }

        public void Save(bool backup)
        {
            module.Write(file + ".tmp");
            module.Dispose();
            if (backup)
            {
                if (File.Exists(file + ".bak"))
                {
                    File.Delete(file + ".bak");
                }
                File.Move(file, file + ".bak");
            }
            else
            {
                File.Delete(file);
            }
            File.Move(file + ".tmp", file);
        }
    }
}



================================================
File: dnpatch/Target.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using dnlib.DotNet.Emit;
using dnlib.DotNet;

namespace dnpatch
{
    public partial class Target
    {
        public Target() { }
        
        public Target(MethodDef method)
        {
            Namespace = method.DeclaringType.Namespace;
            Class = method.DeclaringType.Name;
            Method = method.Name;
        }

        /// <summary>
        /// Cast MethodDef to Target -> (Target)MethodDef
        /// </summary>
        /// <param name="value"></param>
        static public implicit operator Target(MethodDef value)
        {
            return new Target(value);
        }
    }

    public partial class Target
    {
        public string Namespace { get; set; }
        public string Class { get; set; }
        public string Method { get; set; }
    }

    public partial class Target
    {
        public int[] Indices { get; set; }
        public Instruction[] Instructions { get; set; }
    }

    public partial class Target
    {
        public int Index { get; set; } = -1;
        public Instruction Instruction { get; set; }
    }

    public partial class Target
    {
        public string[] NestedClasses { get; set; }
    }

    public partial class Target
    {
        public string NestedClass { get; set; }
    }

    public partial class Target
    {
        public string[] Parameters { get; set; } // String[] etc.. if null it means that you dont want to check it
    }

    public partial class Target
    {
        public string ReturnType { get; set; } // String[] etc.. if null or empty it means that you dont want to check it
    }

    public partial class Target
    {
        public string Property { get; set; }
        public PropertyMethod PropertyMethod { get; set; }
    }

    public partial class Target
    {
        public ParamDef[] ParameterDefs { get; set; }
    }

    public partial class Target
    {
        public MethodDef MethodDef { get; set; }
    }

    public partial class Target
    {
        public Local[] Locals { get; set; }
    }

    public enum PropertyMethod
    {
        Get,
        Set
    }
}



================================================
File: dnpatch/dnpatch.csproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="14.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{14CA7A28-7FA8-40A0-ABC6-81E9F36318DE}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>dnpatch</RootNamespace>
    <AssemblyName>dnpatch</AssemblyName>
    <TargetFrameworkVersion>v4.5.2</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup>
    <RunPostBuildEvent>OnBuildSuccess</RunPostBuildEvent>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="dnlib, Version=1.6.0.0, Culture=neutral, PublicKeyToken=50e96378b6e77999, processorArchitecture=MSIL">
      <SpecificVersion>False</SpecificVersion>
      <HintPath>..\Libraries\dnlib.dll</HintPath>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Net.Http" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Extensions.cs" />
    <Compile Include="ObfuscatedTarget.cs" />
    <Compile Include="Patcher.cs" />
    <Compile Include="PatchHelper.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="ResourcePatcher.cs" />
    <Compile Include="Target.cs" />
  </ItemGroup>
  <ItemGroup />
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>


================================================
File: dnpatch/Properties/AssemblyInfo.cs
================================================
ï»¿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("dnpatch")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("dnpatch")]
[assembly: AssemblyCopyright("Copyright Â©  2016")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("14ca7a28-7fa8-40a0-abc6-81e9f36318de")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]



================================================
File: dnpatch.deobfuscation/README.md
================================================
## Deobfuscation [BETA]
Baoss, what can I do if it's heavily obfuscated?! Well, listen careful to your grandpa Joe. Use 'dnpatch.deobfuscation'! It has magic powers! Nah, Joe is just kiddin', it uses the de4dot libraries.
Reference the library dnpatch.deobfuscation and make sure that you also copy all others from the zip!
Then do this:
```cs
Deobfuscation d = new Deobfuscation(string, string);
// string 1 -> file to deobfuscate
// string 2 -> new filename for the deobfuscated file
d.Deobfuscate(); // Deobfuscates the file and writes it to the disk
```


================================================
File: dnpatch.deobfuscation/CommandLineParser.cs
================================================
ï»¿/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.IO;
using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Writer;
using de4dot.code;
using de4dot.code.deobfuscators;
using de4dot.code.AssemblyClient;
using de4dot.code.renamer;

namespace de4dot.cui {
	class CommandLineParser {
		static Infos stringDecrypterTypes = new Infos();

		ObfuscatedFile.Options newFileOptions = null;
		IList<IObfuscatedFile> files = new List<IObfuscatedFile>();
		Dictionary<string, Option> optionsDict = new Dictionary<string, Option>(StringComparer.Ordinal);
		IList<IDeobfuscatorInfo> deobfuscatorInfos;
		IList<Option> miscOptions = new List<Option>();
		IList<Option> fileOptions = new List<Option>();
		Option defaultOption;
		FilesDeobfuscator.Options filesOptions;
		FilesDeobfuscator.SearchDir searchDir;
		DecrypterType? defaultStringDecrypterType;
		List<string> defaultStringDecrypterMethods = new List<string>();

		class Info {
			public object value;
			public string name;
			public string desc;

			public Info(object value, string name, string desc) {
				this.value = value;
				this.name = name;
				this.desc = desc;
			}
		}

		class Infos {
			List<Info> infos = new List<Info>();

			public void add(object value, string name, string desc) {
				infos.Add(new Info(value, name, desc));
			}

			public IEnumerable<Info> GetInfos() {
				return infos;
			}

			public bool GetValue(string name, out object value) {
				foreach (var info in infos) {
					if (name.Equals(info.name, StringComparison.OrdinalIgnoreCase)) {
						value = info.value;
						return true;
					}
				}
				value = null;
				return false;
			}
		}

		static CommandLineParser() {
			stringDecrypterTypes.add(DecrypterType.None, "none", "Don't decrypt strings");
			stringDecrypterTypes.add(DecrypterType.Default, "default", "Use default string decrypter type (usually static)");
			stringDecrypterTypes.add(DecrypterType.Static, "static", "Use static string decrypter if available");
			stringDecrypterTypes.add(DecrypterType.Delegate, "delegate", "Use a delegate to call the real string decrypter");
			stringDecrypterTypes.add(DecrypterType.Emulate, "emulate", "Call real string decrypter and emulate certain instructions");
		}

		public CommandLineParser(IList<IDeobfuscatorInfo> deobfuscatorInfos, FilesDeobfuscator.Options filesOptions) {
			this.deobfuscatorInfos = deobfuscatorInfos;
			this.filesOptions = filesOptions;
			this.filesOptions.DeobfuscatorInfos = deobfuscatorInfos;
			this.filesOptions.AssemblyClientFactory = new NewAppDomainAssemblyClientFactory();

			AddAllOptions();
		}

		void AddAllOptions() {
			miscOptions.Add(new OneArgOption("r", null, "Scan for .NET files in all subdirs", "dir", (val) => {
				AddSearchDir();
				searchDir = new FilesDeobfuscator.SearchDir();
				if (!Utils.PathExists(val))
					ExitError(string.Format("Directory {0} does not exist", val));
				searchDir.InputDirectory = val;
			}));
			miscOptions.Add(new OneArgOption("ro", null, "Output base dir for recursively found files", "dir", (val) => {
				if (searchDir == null)
					ExitError("Missing -r option");
				searchDir.OutputDirectory = val;
			}));
			miscOptions.Add(new NoArgOption("ru", null, "Skip recursively found files with unsupported obfuscator", () => {
				if (searchDir == null)
					ExitError("Missing -r option");
				searchDir.SkipUnknownObfuscators = true;
			}));
			miscOptions.Add(new NoArgOption("d", null, "Detect obfuscators and exit", () => {
				filesOptions.DetectObfuscators = true;
			}));
			miscOptions.Add(new OneArgOption(null, "asm-path", "Add an assembly search path", "path", (val) => {
				TheAssemblyResolver.Instance.AddSearchDirectory(val);
			}));
			miscOptions.Add(new NoArgOption(null, "dont-rename", "Don't rename classes, methods, etc.", () => {
				filesOptions.RenameSymbols = false;
				filesOptions.RenamerFlags = 0;
			}));
			miscOptions.Add(new OneArgOption(null, "keep-names", "Don't rename n(amespaces), t(ypes), p(rops), e(vents), f(ields), m(ethods), a(rgs), g(enericparams), d(elegate fields). Can be combined, eg. efm", "flags", (val) => {
				foreach (var c in val) {
					switch (c) {
					case 'n': filesOptions.RenamerFlags &= ~RenamerFlags.RenameNamespaces; break;
					case 't': filesOptions.RenamerFlags &= ~RenamerFlags.RenameTypes; break;
					case 'p': filesOptions.RenamerFlags &= ~RenamerFlags.RenameProperties; break;
					case 'e': filesOptions.RenamerFlags &= ~RenamerFlags.RenameEvents; break;
					case 'f': filesOptions.RenamerFlags &= ~RenamerFlags.RenameFields; break;
					case 'm': filesOptions.RenamerFlags &= ~RenamerFlags.RenameMethods; break;
					case 'a': filesOptions.RenamerFlags &= ~RenamerFlags.RenameMethodArgs; break;
					case 'g': filesOptions.RenamerFlags &= ~RenamerFlags.RenameGenericParams; break;
					case 'd': filesOptions.RenamerFlags |= RenamerFlags.DontRenameDelegateFields; break;
					default: throw new UserException(string.Format("Unrecognized --keep-names char: '{0}'", c));
					}
				}
			}));
			miscOptions.Add(new NoArgOption(null, "dont-create-params", "Don't create method params when renaming", () => {
				filesOptions.RenamerFlags |= RenamerFlags.DontCreateNewParamDefs;
			}));
			miscOptions.Add(new NoArgOption(null, "dont-restore-props", "Don't restore properties/events", () => {
				filesOptions.RenamerFlags &= ~(RenamerFlags.RestorePropertiesFromNames | RenamerFlags.RestoreEventsFromNames);
			}));
			miscOptions.Add(new OneArgOption(null, "default-strtyp", "Default string decrypter type", "type", (val) => {
				object decrypterType;
				if (!stringDecrypterTypes.GetValue(val, out decrypterType))
					ExitError(string.Format("Invalid string decrypter type '{0}'", val));
				defaultStringDecrypterType = (DecrypterType)decrypterType;
			}));
			miscOptions.Add(new OneArgOption(null, "default-strtok", "Default string decrypter method token or [type::][name][(args,...)]", "method", (val) => {
				defaultStringDecrypterMethods.Add(val);
			}));
			miscOptions.Add(new NoArgOption(null, "no-cflow-deob", "No control flow deobfuscation (NOT recommended)", () => {
				filesOptions.ControlFlowDeobfuscation = false;
			}));
			miscOptions.Add(new NoArgOption(null, "only-cflow-deob", "Only control flow deobfuscation", () => {
				filesOptions.ControlFlowDeobfuscation = true;
				// --strtyp none
				defaultStringDecrypterType = DecrypterType.None;
				// --keep-types
				filesOptions.KeepObfuscatorTypes = true;
				// --preserve-tokens
				filesOptions.MetaDataFlags |= MetaDataFlags.PreserveRids |
						MetaDataFlags.PreserveUSOffsets |
						MetaDataFlags.PreserveBlobOffsets |
						MetaDataFlags.PreserveExtraSignatureData;
				// --dont-rename
				filesOptions.RenameSymbols = false;
				filesOptions.RenamerFlags = 0;
			}));
			miscOptions.Add(new NoArgOption(null, "load-new-process", "Load executed assemblies into a new process", () => {
				filesOptions.AssemblyClientFactory = new NewProcessAssemblyClientFactory();
			}));
			miscOptions.Add(new NoArgOption(null, "keep-types", "Keep obfuscator types, fields, methods", () => {
				filesOptions.KeepObfuscatorTypes = true;
			}));
			miscOptions.Add(new NoArgOption(null, "preserve-tokens", "Preserve important tokens, #US, #Blob, extra sig data", () => {
				filesOptions.MetaDataFlags |= MetaDataFlags.PreserveRids |
						MetaDataFlags.PreserveUSOffsets |
						MetaDataFlags.PreserveBlobOffsets |
						MetaDataFlags.PreserveExtraSignatureData;
			}));
			miscOptions.Add(new OneArgOption(null, "preserve-table", "Preserve rids in table: tr (TypeRef), td (TypeDef), fd (Field), md (Method), pd (Param), mr (MemberRef), s (StandAloneSig), ed (Event), pr (Property), ts (TypeSpec), ms (MethodSpec), all (all previous tables). Use - to disable (eg. all,-pd). Can be combined: ed,fd,md", "flags", (val) => {
				foreach (var t in val.Split(',')) {
					var s = t.Trim();
					if (s.Length == 0)
						continue;
					bool clear = s[0] == '-';
					if (clear)
						s = s.Substring(1);
					MetaDataFlags flag;
					switch (s.Trim()) {
					case "": flag = 0; break;
					case "all": flag = MetaDataFlags.PreserveRids; break;
					case "tr": flag = MetaDataFlags.PreserveTypeRefRids; break;
					case "td": flag = MetaDataFlags.PreserveTypeDefRids; break;
					case "fd": flag = MetaDataFlags.PreserveFieldRids; break;
					case "md": flag = MetaDataFlags.PreserveMethodRids; break;
					case "pd": flag = MetaDataFlags.PreserveParamRids; break;
					case "mr": flag = MetaDataFlags.PreserveMemberRefRids; break;
					case "s": flag = MetaDataFlags.PreserveStandAloneSigRids; break;
					case "ed": flag = MetaDataFlags.PreserveEventRids; break;
					case "pr": flag = MetaDataFlags.PreservePropertyRids; break;
					case "ts": flag = MetaDataFlags.PreserveTypeSpecRids; break;
					case "ms": flag = MetaDataFlags.PreserveMethodSpecRids; break;
					default: throw new UserException(string.Format("Invalid --preserve-table option: {0}", s));
					}
					if (clear)
						filesOptions.MetaDataFlags &= ~flag;
					else
						filesOptions.MetaDataFlags |= flag;
				}
			}));
			miscOptions.Add(new NoArgOption(null, "preserve-strings", "Preserve #Strings heap offsets", () => {
				filesOptions.MetaDataFlags |= MetaDataFlags.PreserveStringsOffsets;
			}));
			miscOptions.Add(new NoArgOption(null, "preserve-us", "Preserve #US heap offsets", () => {
				filesOptions.MetaDataFlags |= MetaDataFlags.PreserveUSOffsets;
			}));
			miscOptions.Add(new NoArgOption(null, "preserve-blob", "Preserve #Blob heap offsets", () => {
				filesOptions.MetaDataFlags |= MetaDataFlags.PreserveBlobOffsets;
			}));
			miscOptions.Add(new NoArgOption(null, "preserve-sig-data", "Preserve extra data at the end of signatures", () => {
				filesOptions.MetaDataFlags |= MetaDataFlags.PreserveExtraSignatureData;
			}));
			miscOptions.Add(new NoArgOption(null, "one-file", "Deobfuscate one file at a time", () => {
				filesOptions.OneFileAtATime = true;
			}));
			miscOptions.Add(new NoArgOption("v", null, "Verbose", () => {
				Logger.Instance.MaxLoggerEvent = LoggerEvent.Verbose;
				Logger.Instance.CanIgnoreMessages = false;
			}));
			miscOptions.Add(new NoArgOption("vv", null, "Very verbose", () => {
				Logger.Instance.MaxLoggerEvent = LoggerEvent.VeryVerbose;
				Logger.Instance.CanIgnoreMessages = false;
			}));
			miscOptions.Add(new NoArgOption("h", "help", "Show this help message", () => {
				Usage();
				Exit(0);
			}));

			defaultOption = new OneArgOption("f", null, "Name of .NET file", "file", (val) => {
				AddFile();
				if (!Utils.FileExists(val))
					ExitError(string.Format("File \"{0}\" does not exist.", val));
				newFileOptions = new ObfuscatedFile.Options {
					Filename = val,
					ControlFlowDeobfuscation = filesOptions.ControlFlowDeobfuscation,
					KeepObfuscatorTypes = filesOptions.KeepObfuscatorTypes,
					MetaDataFlags = filesOptions.MetaDataFlags,
					RenamerFlags = filesOptions.RenamerFlags,
				};
				if (defaultStringDecrypterType != null)
					newFileOptions.StringDecrypterType = defaultStringDecrypterType.Value;
				newFileOptions.StringDecrypterMethods.AddRange(defaultStringDecrypterMethods);
			});
			fileOptions.Add(defaultOption);
			fileOptions.Add(new OneArgOption("o", null, "Name of output file", "file", (val) => {
				if (newFileOptions == null)
					ExitError("Missing input file");
				var newFilename = Utils.GetFullPath(val);
				if (string.Equals(Utils.GetFullPath(newFileOptions.Filename), newFilename, StringComparison.OrdinalIgnoreCase))
					ExitError(string.Format("Output file can't be same as input file ({0})", newFilename));
				newFileOptions.NewFilename = newFilename;
			}));
			fileOptions.Add(new OneArgOption("p", null, "Obfuscator type (see below)", "type", (val) => {
				if (newFileOptions == null)
					ExitError("Missing input file");
				if (!IsValidObfuscatorType(val))
					ExitError(string.Format("Invalid obfuscator type '{0}'", val));
				newFileOptions.ForcedObfuscatorType = val;
			}));
			fileOptions.Add(new OneArgOption(null, "strtyp", "String decrypter type", "type", (val) => {
				if (newFileOptions == null)
					ExitError("Missing input file");
				object decrypterType;
				if (!stringDecrypterTypes.GetValue(val, out decrypterType))
					ExitError(string.Format("Invalid string decrypter type '{0}'", val));
				newFileOptions.StringDecrypterType = (DecrypterType)decrypterType;
			}));
			fileOptions.Add(new OneArgOption(null, "strtok", "String decrypter method token or [type::][name][(args,...)]", "method", (val) => {
				if (newFileOptions == null)
					ExitError("Missing input file");
				newFileOptions.StringDecrypterMethods.Add(val);
			}));

			AddOptions(miscOptions);
			AddOptions(fileOptions);
			foreach (var info in deobfuscatorInfos)
				AddOptions(info.GetOptions());
		}

		void AddOptions(IEnumerable<Option> options) {
			foreach (var option in options) {
				AddOption(option, option.ShortName);
				AddOption(option, option.LongName);
			}
		}

		void AddOption(Option option, string name) {
			if (name == null)
				return;
			if (optionsDict.ContainsKey(name))
				throw new ApplicationException(string.Format("Option {0} is present twice!", name));
			optionsDict[name] = option;
		}

		public void Parse(string[] args) {
			if (args.Length == 0) {
				Usage();
				Exit(1);
			}

			for (int i = 0; i < args.Length; i++) {
				var arg = args[i];

				string val = null;
				Option option;
				if (optionsDict.TryGetValue(arg, out option)) {
					if (option.NeedArgument) {
						if (++i >= args.Length)
							ExitError("Missing options value");
						val = args[i];
					}
				}
				else {
					option = defaultOption;
					val = arg;
				}

				string errorString;
				if (!option.Set(val, out errorString))
					ExitError(errorString);
			}
			AddFile();
			AddSearchDir();
			filesOptions.Files = files;
			filesOptions.DefaultStringDecrypterMethods.AddRange(defaultStringDecrypterMethods);
			filesOptions.DefaultStringDecrypterType = defaultStringDecrypterType;
		}

	    public void AddFile() {
			if (newFileOptions == null)
				return;
			files.Add(new ObfuscatedFile(newFileOptions, filesOptions.ModuleContext, filesOptions.AssemblyClientFactory));
			newFileOptions = null;
		}

		void AddSearchDir() {
			if (searchDir == null)
				return;
			filesOptions.SearchDirs.Add(searchDir);
			searchDir = null;
		}

		bool IsValidObfuscatorType(string type) {
			foreach (var info in deobfuscatorInfos) {
				if (string.Equals(info.Type, type, StringComparison.OrdinalIgnoreCase))
					return true;
			}
			return false;
		}

		void ExitError(string msg) {
			Usage();
			Logger.Instance.LogErrorDontIgnore("\n\nERROR: {0}\n", msg);
			Exit(2);
		}

		void Exit(int exitCode) {
			throw new Exception(exitCode.ToString());
		}

		void Usage() {
			string progName = GetProgramBaseName();
			Logger.n("Some of the advanced options may be incompatible, causing a nice exception.");
			Logger.n("With great power comes great responsibility.");
			Logger.n("");
			Logger.n("{0} <options> <file options>", progName);
			Logger.n("Options:");
			foreach (var option in miscOptions)
				PrintOption(option);
			Logger.n("");
			Logger.n("File options:");
			foreach (var option in fileOptions)
				PrintOption(option);
			Logger.n("");
			Logger.n("Deobfuscator options:");
			foreach (var info in deobfuscatorInfos) {
				Logger.n("Type {0} ({1})", info.Type, info.Name);
				foreach (var option in info.GetOptions())
					PrintOption(option);
				Logger.n("");
			}
			PrintInfos("String decrypter types", stringDecrypterTypes);
			Logger.n("");
			Logger.n("Multiple regexes can be used if separated by '{0}'.", NameRegexes.regexSeparatorChar);
			Logger.n("Use '{0}' if you want to invert the regex. Example: {0}^[a-z\\d]{{1,2}}${1}{0}^[A-Z]_\\d+${1}^[\\w.]+$", NameRegex.invertChar, NameRegexes.regexSeparatorChar);
			Logger.n("");
			Logger.n("Examples:");
			Logger.n("{0} -r c:\\my\\files -ro c:\\my\\output", progName);
			Logger.n("{0} file1 file2 file3", progName);
			Logger.n("{0} file1 -f file2 -o file2.out -f file3 -o file3.out", progName);
			Logger.n("{0} file1 --strtyp delegate --strtok 06000123", progName);
		}

		string GetProgramBaseName() {
			return Utils.GetBaseName(Environment.GetCommandLineArgs()[0]);
		}

		void PrintInfos(string desc, Infos infos) {
			Logger.n("{0}", desc);
			foreach (var info in infos.GetInfos())
				PrintOptionAndExplanation(info.name, info.desc);
		}

		void PrintOption(Option option) {
			string defaultAndDesc;
			if (option.NeedArgument && option.Default != null)
				defaultAndDesc = string.Format("{0} ({1})", option.Description, option.Default);
			else
				defaultAndDesc = option.Description;
			PrintOptionAndExplanation(GetOptionAndArgName(option, option.ShortName ?? option.LongName), defaultAndDesc);
			if (option.ShortName != null && option.LongName != null)
				PrintOptionAndExplanation(option.LongName, string.Format("Same as {0}", option.ShortName));
		}

		void PrintOptionAndExplanation(string option, string explanation) {
			const int maxCols = 16;
			const string prefix = "  ";
			string left = string.Format(string.Format("{{0,-{0}}}", maxCols), option);
			if (option.Length > maxCols) {
				Logger.n("{0}{1}", prefix, left);
				Logger.n("{0}{1} {2}", prefix, new string(' ', maxCols), explanation);
			}
			else
				Logger.n("{0}{1} {2}", prefix, left, explanation);
		}

		string GetOptionAndArgName(Option option, string optionName) {
			if (option.NeedArgument)
				return optionName + " " + option.ArgumentValueName.ToUpperInvariant();
			else
				return optionName;
		}
	}
}



================================================
File: dnpatch.deobfuscation/Deobfuscation.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using de4dot.code;
using de4dot.code.AssemblyClient;
using de4dot.code.deobfuscators;
using de4dot.cui;
using dnlib.DotNet;

namespace dnpatch.deobfuscation
{
    /*
     * Credits go to 0xd4d for de4dot!
     */

    public class Deobfuscation
    {
        private string file;
        private string newFile;

        public Deobfuscation(string file, string newFile)
        {
            this.file = file;
            this.newFile = newFile;
        }

        public void Deobfuscate() // ALPHA TEST
        {
            FilesDeobfuscator.Options filesOptions = new FilesDeobfuscator.Options();
            filesOptions.ControlFlowDeobfuscation = true;
            new CommandLineParser(CreateDeobfuscatorInfos(), filesOptions).Parse(new []
            {
                file,
                "-o",
                newFile
            });
            new FilesDeobfuscator(filesOptions).DoIt();
        }

        static IList<IDeobfuscatorInfo> CreateDeobfuscatorInfos()
        {
            var local = new List<IDeobfuscatorInfo> {
                new de4dot.code.deobfuscators.Unknown.DeobfuscatorInfo(),
                new de4dot.code.deobfuscators.Agile_NET.DeobfuscatorInfo(),
                new de4dot.code.deobfuscators.Babel_NET.DeobfuscatorInfo(),
                new de4dot.code.deobfuscators.CodeFort.DeobfuscatorInfo(),
                new de4dot.code.deobfuscators.CodeVeil.DeobfuscatorInfo(),
                new de4dot.code.deobfuscators.CodeWall.DeobfuscatorInfo(),
                new de4dot.code.deobfuscators.Confuser.DeobfuscatorInfo(),
                new de4dot.code.deobfuscators.CryptoObfuscator.DeobfuscatorInfo(),
                new de4dot.code.deobfuscators.DeepSea.DeobfuscatorInfo(),
                new de4dot.code.deobfuscators.Dotfuscator.DeobfuscatorInfo(),
                new de4dot.code.deobfuscators.dotNET_Reactor.v3.DeobfuscatorInfo(),
                new de4dot.code.deobfuscators.dotNET_Reactor.v4.DeobfuscatorInfo(),
                new de4dot.code.deobfuscators.Eazfuscator_NET.DeobfuscatorInfo(),
                new de4dot.code.deobfuscators.Goliath_NET.DeobfuscatorInfo(),
                new de4dot.code.deobfuscators.ILProtector.DeobfuscatorInfo(),
                new de4dot.code.deobfuscators.MaxtoCode.DeobfuscatorInfo(),
                new de4dot.code.deobfuscators.MPRESS.DeobfuscatorInfo(),
                new de4dot.code.deobfuscators.Rummage.DeobfuscatorInfo(),
                new de4dot.code.deobfuscators.Skater_NET.DeobfuscatorInfo(),
                new de4dot.code.deobfuscators.SmartAssembly.DeobfuscatorInfo(),
                new de4dot.code.deobfuscators.Spices_Net.DeobfuscatorInfo(),
                new de4dot.code.deobfuscators.Xenocode.DeobfuscatorInfo(),
            };
            var dict = new Dictionary<string, IDeobfuscatorInfo>();
            foreach (var d in local)
                dict[d.Type] = d;
            return new List<IDeobfuscatorInfo>(dict.Values);
        }
    }
}



================================================
File: dnpatch.deobfuscation/FilesDeobfuscator.cs
================================================
ï»¿/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.IO;
using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Writer;
using de4dot.blocks;
using de4dot.code;
using de4dot.code.renamer;
using de4dot.code.deobfuscators;
using de4dot.code.AssemblyClient;

namespace de4dot.cui {
	class FilesDeobfuscator {
		Options options;
		IDeobfuscatorContext deobfuscatorContext = new DeobfuscatorContext();

		public class Options {
			public ModuleContext ModuleContext { get; set; }
			public IList<IDeobfuscatorInfo> DeobfuscatorInfos { get; set; }
			public IList<IObfuscatedFile> Files { get; set; }
			public IList<SearchDir> SearchDirs { get; set; }
			public MetaDataFlags MetaDataFlags { get; set; }
			public bool DetectObfuscators { get; set; }
			public RenamerFlags RenamerFlags { get; set; }
			public bool RenameSymbols { get; set; }
			public bool ControlFlowDeobfuscation { get; set; }
			public bool KeepObfuscatorTypes { get; set; }
			public bool OneFileAtATime { get; set; }
			public DecrypterType? DefaultStringDecrypterType { get; set; }
			public List<string> DefaultStringDecrypterMethods { get; private set; }
			public IAssemblyClientFactory AssemblyClientFactory { get; set; }

			public Options() {
				ModuleContext = new ModuleContext(TheAssemblyResolver.Instance);
				DeobfuscatorInfos = new List<IDeobfuscatorInfo>();
				Files = new List<IObfuscatedFile>();
				SearchDirs = new List<SearchDir>();
				DefaultStringDecrypterMethods = new List<string>();
				RenamerFlags = RenamerFlags.RenameNamespaces |
						RenamerFlags.RenameTypes |
						RenamerFlags.RenameProperties |
						RenamerFlags.RenameEvents |
						RenamerFlags.RenameFields |
						RenamerFlags.RenameMethods |
						RenamerFlags.RenameMethodArgs |
						RenamerFlags.RenameGenericParams |
						RenamerFlags.RestorePropertiesFromNames |
						RenamerFlags.RestoreEventsFromNames |
						RenamerFlags.RestoreProperties |
						RenamerFlags.RestoreEvents;
				RenameSymbols = true;
				ControlFlowDeobfuscation = true;
			}
		}

		public class SearchDir {
			public string InputDirectory { get; set; }
			public string OutputDirectory { get; set; }
			public bool SkipUnknownObfuscators { get; set; }
		}

		public FilesDeobfuscator(Options options) {
			this.options = options;
		}

		public void DoIt() {
			if (options.DetectObfuscators)
				DetectObfuscators();
			else if (options.OneFileAtATime)
				DeobfuscateOneAtATime();
			else
				DeobfuscateAll();
		}

		static void RemoveModule(ModuleDef module) {
			TheAssemblyResolver.Instance.Remove(module);
		}

		void DetectObfuscators() {
			foreach (var file in LoadAllFiles(true)) {
				RemoveModule(file.ModuleDefMD);
				file.Dispose();
				deobfuscatorContext.Clear();
			}
		}

		void DeobfuscateOneAtATime() {
			foreach (var file in LoadAllFiles()) {
				int oldIndentLevel = Logger.Instance.IndentLevel;
				try {
					file.DeobfuscateBegin();
					file.Deobfuscate();
					file.DeobfuscateEnd();
					Rename(new List<IObfuscatedFile> { file });
					file.Save();

					RemoveModule(file.ModuleDefMD);
					TheAssemblyResolver.Instance.ClearAll();
					deobfuscatorContext.Clear();
				}
				catch (Exception) {
					Logger.Instance.Log(false, null, LoggerEvent.Warning, "Could not deobfuscate {0}. Use -v to see stack trace", file.Filename);
				}
				finally {
					file.Dispose();
					Logger.Instance.IndentLevel = oldIndentLevel;
				}
			}
		}

		void DeobfuscateAll() {
			var allFiles = new List<IObfuscatedFile>(LoadAllFiles());
			try {
				DeobfuscateAllFiles(allFiles);
				Rename(allFiles);
				SaveAllFiles(allFiles);
			}
			finally {
				foreach (var file in allFiles) {
					if (file != null)
						file.Dispose();
				}
			}
		}

		IEnumerable<IObfuscatedFile> LoadAllFiles() {
			return LoadAllFiles(false);
		}

		IEnumerable<IObfuscatedFile> LoadAllFiles(bool onlyScan) {
			var loader = new DotNetFileLoader(new DotNetFileLoader.Options {
				ModuleContext = options.ModuleContext,
				PossibleFiles  = options.Files,
				SearchDirs = options.SearchDirs,
				CreateDeobfuscators = () => CreateDeobfuscators(),
				DefaultStringDecrypterType = options.DefaultStringDecrypterType,
				DefaultStringDecrypterMethods = options.DefaultStringDecrypterMethods,
				AssemblyClientFactory = options.AssemblyClientFactory,
				DeobfuscatorContext = deobfuscatorContext,
				ControlFlowDeobfuscation = options.ControlFlowDeobfuscation,
				KeepObfuscatorTypes = options.KeepObfuscatorTypes,
				MetaDataFlags = options.MetaDataFlags,
				RenamerFlags = options.RenamerFlags,
				CreateDestinationDir = !onlyScan,
			});

			foreach (var file in loader.Load())
				yield return file;
		}

		class DotNetFileLoader {
			Options options;
			Dictionary<string, bool> allFiles = new Dictionary<string, bool>(StringComparer.OrdinalIgnoreCase);
			Dictionary<string, bool> visitedDirectory = new Dictionary<string, bool>(StringComparer.OrdinalIgnoreCase);

			public class Options {
				public ModuleContext ModuleContext { get; set; }
				public IEnumerable<IObfuscatedFile> PossibleFiles { get; set; }
				public IEnumerable<SearchDir> SearchDirs { get; set; }
				public code.Func<IList<IDeobfuscator>> CreateDeobfuscators { get; set; }
				public DecrypterType? DefaultStringDecrypterType { get; set; }
				public List<string> DefaultStringDecrypterMethods { get; set; }
				public IAssemblyClientFactory AssemblyClientFactory { get; set; }
				public IDeobfuscatorContext DeobfuscatorContext { get; set; }
				public bool ControlFlowDeobfuscation { get; set; }
				public bool KeepObfuscatorTypes { get; set; }
				public MetaDataFlags MetaDataFlags { get; set; }
				public RenamerFlags RenamerFlags { get; set; }
				public bool CreateDestinationDir { get; set; }
			}

			public DotNetFileLoader(Options options) {
				this.options = options;
			}

			public IEnumerable<IObfuscatedFile> Load() {
				foreach (var file in options.PossibleFiles) {
					if (Add(file, false, true))
						yield return file;
				}

				foreach (var searchDir in options.SearchDirs) {
					foreach (var file in LoadFiles(searchDir))
						yield return file;
				}
			}

			bool Add(IObfuscatedFile file, bool skipUnknownObfuscator, bool isFromPossibleFiles) {
				var key = Utils.GetFullPath(file.Filename);
				if (allFiles.ContainsKey(key)) {
					Logger.Instance.Log(false, null, LoggerEvent.Warning, "Ingoring duplicate file: {0}", file.Filename);
					return false;
				}
				allFiles[key] = true;

				int oldIndentLevel = Logger.Instance.IndentLevel;
				try {
					file.DeobfuscatorContext = options.DeobfuscatorContext;
					file.Load(options.CreateDeobfuscators());
				}
				catch (NotSupportedException) {
					return false;	// Eg. unsupported architecture
				}
				catch (BadImageFormatException) {
					if (isFromPossibleFiles)
						Logger.Instance.Log(false, null, LoggerEvent.Warning, "The file isn't a .NET PE file: {0}", file.Filename);
					return false;	// Not a .NET file
				}
				catch (EndOfStreamException) {
					return false;
				}
				catch (IOException) {
					if (isFromPossibleFiles)
						Logger.Instance.Log(false, null, LoggerEvent.Warning, "The file isn't a .NET PE file: {0}", file.Filename);
					return false;	// Not a .NET file
				}
				catch (Exception ex) {
					Logger.Instance.Log(false, null, LoggerEvent.Warning, "Could not load file ({0}): {1}", ex.GetType(), file.Filename);
					return false;
				}
				finally {
					Logger.Instance.IndentLevel = oldIndentLevel;
				}

				var deob = file.Deobfuscator;
				if (skipUnknownObfuscator && deob.Type == "un") {
					Logger.v("Skipping unknown obfuscator: {0}", file.Filename);
					RemoveModule(file.ModuleDefMD);
					return false;
				}
				else {
					Logger.n("Detected {0} ({1})", deob.Name, file.Filename);
					if (options.CreateDestinationDir)
						CreateDirectories(Path.GetDirectoryName(file.NewFilename));
					return true;
				}
			}

			IEnumerable<IObfuscatedFile> LoadFiles(SearchDir searchDir) {
				DirectoryInfo di = null;
				bool ok = false;
				try {
					di = new DirectoryInfo(searchDir.InputDirectory);
					if (di.Exists)
						ok = true;
				}
				catch (System.Security.SecurityException) {
				}
				catch (ArgumentException) {
				}
				if (ok) {
					foreach (var filename in DoDirectoryInfo(searchDir, di)) {
						var obfuscatedFile = CreateObfuscatedFile(searchDir, filename);
						if (obfuscatedFile != null)
							yield return obfuscatedFile;
					}					
				}
			}

			IEnumerable<string> RecursiveAdd(SearchDir searchDir, IEnumerable<FileSystemInfo> fileSystemInfos) {
				foreach (var fsi in fileSystemInfos) {
					if ((int)(fsi.Attributes & System.IO.FileAttributes.Directory) != 0) {
						foreach (var filename in DoDirectoryInfo(searchDir, (DirectoryInfo)fsi))
							yield return filename;
					}
					else {
						var fi = (FileInfo)fsi;
						if (fi.Exists)
							yield return fi.FullName;
					}
				}
			}

			IEnumerable<string> DoDirectoryInfo(SearchDir searchDir, DirectoryInfo di) {
				if (!di.Exists)
					return new List<string>();

				if (visitedDirectory.ContainsKey(di.FullName))
					return new List<string>();
				visitedDirectory[di.FullName] = true;

				FileSystemInfo[] fsinfos;
				try {
					fsinfos = di.GetFileSystemInfos();
				}
				catch (UnauthorizedAccessException) {
					return new List<string>();
				}
				catch (IOException) {
					return new List<string>();
				}
				catch (System.Security.SecurityException) {
					return new List<string>();
				}
				return RecursiveAdd(searchDir, fsinfos);
			}

			IObfuscatedFile CreateObfuscatedFile(SearchDir searchDir, string filename) {
				var fileOptions = new ObfuscatedFile.Options {
					Filename = Utils.GetFullPath(filename),
					ControlFlowDeobfuscation = options.ControlFlowDeobfuscation,
					KeepObfuscatorTypes = options.KeepObfuscatorTypes,
					MetaDataFlags = options.MetaDataFlags,
					RenamerFlags = options.RenamerFlags,
				};
				if (options.DefaultStringDecrypterType != null)
					fileOptions.StringDecrypterType = options.DefaultStringDecrypterType.Value;
				fileOptions.StringDecrypterMethods.AddRange(options.DefaultStringDecrypterMethods);

				if (!string.IsNullOrEmpty(searchDir.OutputDirectory)) {
					var inDir = Utils.GetFullPath(searchDir.InputDirectory);
					var outDir = Utils.GetFullPath(searchDir.OutputDirectory);

					if (!Utils.StartsWith(fileOptions.Filename, inDir, StringComparison.OrdinalIgnoreCase))
						throw new UserException(string.Format("Filename {0} does not start with inDir {1}", fileOptions.Filename, inDir));

					var subDirs = fileOptions.Filename.Substring(inDir.Length);
					if (subDirs.Length > 0 && subDirs[0] == Path.DirectorySeparatorChar)
						subDirs = subDirs.Substring(1);
					fileOptions.NewFilename = Utils.GetFullPath(Path.Combine(outDir, subDirs));

					if (fileOptions.Filename.Equals(fileOptions.NewFilename, StringComparison.OrdinalIgnoreCase))
						throw new UserException(string.Format("Input and output filename is the same: {0}", fileOptions.Filename));
				}

				var obfuscatedFile = new ObfuscatedFile(fileOptions, options.ModuleContext, options.AssemblyClientFactory);
				if (Add(obfuscatedFile, searchDir.SkipUnknownObfuscators, false))
					return obfuscatedFile;
				obfuscatedFile.Dispose();
				return null;
			}

			void CreateDirectories(string path) {
				if (string.IsNullOrEmpty(path))
					return;
				try {
					var di = new DirectoryInfo(path);
					if (!di.Exists)
						di.Create();
				}
				catch (System.Security.SecurityException) {
				}
				catch (ArgumentException) {
				}
			}
		}

		void DeobfuscateAllFiles(IEnumerable<IObfuscatedFile> allFiles) {
			try {
				foreach (var file in allFiles)
					file.DeobfuscateBegin();
				foreach (var file in allFiles) {
					file.Deobfuscate();
					file.DeobfuscateEnd();
				}
			}
			finally {
				foreach (var file in allFiles)
					file.DeobfuscateCleanUp();
			}
		}

		void SaveAllFiles(IEnumerable<IObfuscatedFile> allFiles) {
			foreach (var file in allFiles)
				file.Save();
		}

		IList<IDeobfuscator> CreateDeobfuscators() {
			var list = new List<IDeobfuscator>(options.DeobfuscatorInfos.Count);
			foreach (var info in options.DeobfuscatorInfos)
				list.Add(info.CreateDeobfuscator());
			return list;
		}

		void Rename(IEnumerable<IObfuscatedFile> theFiles) {
			if (!options.RenameSymbols)
				return;
			var renamer = new Renamer(deobfuscatorContext, theFiles, options.RenamerFlags);
			renamer.Rename();
		}
	}
}



================================================
File: dnpatch.deobfuscation/dnpatch.deobfuscation.csproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="14.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{D2A5E850-4078-4C19-B2F4-7F8556CAD473}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>dnpatch.deobfuscation</RootNamespace>
    <AssemblyName>dnpatch.deobfuscation</AssemblyName>
    <TargetFrameworkVersion>v4.5.2</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="AssemblyData">
      <HintPath>..\Libraries\AssemblyData.dll</HintPath>
    </Reference>
    <Reference Include="de4dot.blocks">
      <HintPath>..\Libraries\de4dot.blocks.dll</HintPath>
    </Reference>
    <Reference Include="de4dot.code">
      <HintPath>..\Libraries\de4dot.code.dll</HintPath>
    </Reference>
    <Reference Include="de4dot.cui">
      <HintPath>..\Libraries\de4dot.cui.dll</HintPath>
    </Reference>
    <Reference Include="de4dot.mdecrypt">
      <HintPath>..\Libraries\de4dot.mdecrypt.dll</HintPath>
    </Reference>
    <Reference Include="dnlib">
      <HintPath>..\Libraries\dnlib.dll</HintPath>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Net.Http" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="CommandLineParser.cs" />
    <Compile Include="Deobfuscation.cs" />
    <Compile Include="FilesDeobfuscator.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>


================================================
File: dnpatch.deobfuscation/Properties/AssemblyInfo.cs
================================================
ï»¿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("dnpatch.deobfuscation")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("dnpatch.deobfuscation")]
[assembly: AssemblyCopyright("Copyright Â©  2016")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("d2a5e850-4078-4c19-b2f4-7f8556cad473")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]



================================================
File: dnpatch.script/README.md
================================================
## Scripting
With dnpatch.script you're now able to script patchers with JSON!
Example JSON:
```json
{
    "target":"Test.exe",
    "targets":[{
        "namespace":"Test",
        "class":"Program",
        "method":"ReplaceMe",
        "action":"replace",
        "index":0,
        "instructions":[{
            "opcode":"ldstr",
            "operand":"script working"
        }]
    },{
        "namespace":"Test",
        "class":"Program",
        "method":"RemoveMe",
        "action":"empty"
    }]
}
```
Name this file script.json and place it into TestScript build folder and use it with Test.exe. For more info please refer to the [standalone repo](https://github.com/ioncodes/dnpatch.script).



================================================
File: dnpatch.script/Script.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;
using dnlib.DotNet.Emit;
using Newtonsoft.Json.Linq;

namespace dnpatch.script
{
    public class Script
    {
        private string _scriptFile;                                                                     // Filepath
        private JObject _script;                                                                        // Script
        private Patcher _patcher;                                                                       // Patcher
        private readonly Dictionary<string, Target> _targets = new Dictionary<string, Target>();        // Target
        private string _optional;                                                                       // Optional arguments

        public Script(string path)
        {
            _scriptFile = path;
            _script = JObject.Parse(File.ReadAllText(path));
            BuildTarget();
            _patcher = new Patcher(_script.GetValue("target").ToString());
        }

        public void Patch()
        {
            foreach (var target in _targets)
            {
                if (target.Key == "empty")
                    _patcher.WriteEmptyBody(target.Value);
                else if (target.Key == "return")
                    _patcher.WriteReturnBody(target.Value, Convert.ToBoolean(_optional));
                else if (target.Key == "replace")
                    _patcher.ReplaceInstruction(target.Value);
                else if(target.Key == "remove")
                    _patcher.RemoveInstruction(target.Value);
            }

            if (_script["save"] != null)
            {
                if (_script.GetValue("save").ToString() == _script.GetValue("target").ToString())
                {
                    Save(true);
                }
                else
                {
                    Save(_script.GetValue("save").ToString());
                }
            }
        }

        public void Save(bool backup)
        {
            _patcher.Save(backup);
        }

        public void Save(string name)
        {
            _patcher.Save(name);
        }

        public void LoadScript(string path)
        {
            _scriptFile = path;
            _script = JObject.Parse(path);
            BuildTarget();
            _patcher = new Patcher(_script.GetValue("target").ToString());
        }

        private void BuildTarget()
        {
            JArray targets = (JArray) _script.GetValue("targets");
            foreach (var t in targets)
            {
                Target target = new Target
                {
                    Namespace = t["namespace"].ToString(),
                    Class = t["class"].ToString(),
                    Method = t["method"].ToString()
                };
                if (t["index"] != null)
                    target.Index = Convert.ToInt32(t["index"]);
                if (t["indices"] != null)
                    target.Indices = t["indices"].Values<int>().ToArray();
                if (t["optional"] != null)
                    _optional = t["optional"].ToString();
                if (t["instructions"] != null)
                {
                    JArray instructions = (JArray) t["instructions"];
                    if (instructions.Count == 1)
                    {
                        if (instructions[0]["opcode"] != null && instructions[0]["operand"] != null)
                        {
                            var operand = instructions[0].Last.Last;
                            if (operand.Type == JTokenType.Integer)
                            {
                                target.Instruction =
                                    Instruction.Create(
                                        (OpCode)
                                        GetInstructionField(instructions[0].First.First.ToString()).GetValue(this),
                                        operand.Value<int>());
                            }
                            else if (operand.Type == JTokenType.String)
                            {
                                target.Instruction =
                                    Instruction.Create(
                                        (OpCode)
                                        GetInstructionField(instructions[0].First.First.ToString()).GetValue(this),
                                        operand.Value<string>());
                            }
                        }
                        else if(instructions[0]["opcode"] != null)
                        {
                            target.Instruction =
                                Instruction.Create(
                                    (OpCode) GetInstructionField(instructions[0].First.First.ToString()).GetValue(this));
                        }
                    }
                    else
                    {
                        target.Instructions = new Instruction[instructions.Count];
                        for (int i = 0; i < instructions.Count; i++)
                        {
                            var instruction = instructions[i];
                            if (instruction["opcode"] != null && instruction["operand"] != null)
                                target.Instructions[i] =
                                    Instruction.Create((OpCode)GetInstructionField(instruction.First.First.ToString()).GetValue(this),
                                        instruction.Last.Last.Value<dynamic>());
                            else
                                target.Instructions[i] =
                                    Instruction.Create(
                                        (OpCode)GetInstructionField(instruction.First.First.ToString()).GetValue(this));
                        }
                    }
                }
                _targets.Add(t["action"].ToString(), target);
            }
        }

        private FieldInfo GetInstructionField(string name)
        {
            var type = typeof(OpCodes);
            var field = type.GetField(name, BindingFlags.Public | BindingFlags.IgnoreCase | BindingFlags.Static);
            return field;
        }
    }
}



================================================
File: dnpatch.script/dnpatch.script.csproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="14.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{34AAC8D2-EC71-43A4-B107-3085F07D6B35}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>dnpatch.script</RootNamespace>
    <AssemblyName>dnpatch.script</AssemblyName>
    <TargetFrameworkVersion>v4.5.2</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="dnlib, Version=1.6.0.0, Culture=neutral, PublicKeyToken=50e96378b6e77999, processorArchitecture=MSIL">
      <SpecificVersion>False</SpecificVersion>
      <HintPath>..\Libraries\dnlib.dll</HintPath>
    </Reference>
    <Reference Include="Newtonsoft.Json">
      <HintPath>..\Libraries\Newtonsoft.Json.dll</HintPath>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Net.Http" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Script.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\dnpatch\dnpatch.csproj">
      <Project>{14ca7a28-7fa8-40a0-abc6-81e9f36318de}</Project>
      <Name>dnpatch</Name>
    </ProjectReference>
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>


================================================
File: dnpatch.script/Properties/AssemblyInfo.cs
================================================
ï»¿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("dnpatch.script")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("dnpatch.script")]
[assembly: AssemblyCopyright("Copyright Â©  2016")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("34aac8d2-ec71-43a4-b107-3085f07d6b35")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]



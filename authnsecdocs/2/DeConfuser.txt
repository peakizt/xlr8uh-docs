Directory structure:
└── mbonacci-deconfuser/
    ├── README.md
    ├── DeConfuser.sln
    ├── LICENSE
    ├── ConfuseMe/
    │   ├── ConfuseMe.csproj
    │   ├── Program.cs
    │   ├── Properties/
    │   │   ├── AssemblyInfo.cs
    │   │   ├── Resources.Designer.cs
    │   │   └── Resources.resx
    │   └── Resources/
    │       └── TextFile1.txt
    └── DeConfuser/
        ├── DeConfuser.csproj
        ├── License.txt
        ├── Program.cs
        ├── MonoCecil/
        │   ├── ILProcessor.cs
        │   ├── Mono.Cecil/
        │   │   ├── AggressiveReflectionReader.cs
        │   │   ├── ArrayDimension.cs
        │   │   ├── ArrayDimensionCollection.cs
        │   │   ├── ArrayType.cs
        │   │   ├── AssemblyDefinition.cs
        │   │   ├── AssemblyFactory.cs
        │   │   ├── AssemblyFlags.cs
        │   │   ├── AssemblyHashAlgorithm.cs
        │   │   ├── AssemblyKind.cs
        │   │   ├── AssemblyLinkedResource.cs
        │   │   ├── AssemblyNameDefinition.cs
        │   │   ├── AssemblyNameReference.cs
        │   │   ├── AssemblyNameReferenceCollection.cs
        │   │   ├── BaseAssemblyResolver.cs
        │   │   ├── BaseReflectionReader.cs
        │   │   ├── BaseReflectionVisitor.cs
        │   │   ├── BaseStructureVisitor.cs
        │   │   ├── CallSite.cs
        │   │   ├── CompactFrameworkCompatibility.cs
        │   │   ├── Constants.cs
        │   │   ├── ConstraintCollection.cs
        │   │   ├── ConstructorCollection.cs
        │   │   ├── CustomAttribute.cs
        │   │   ├── CustomAttributeCollection.cs
        │   │   ├── DefaultAssemblyResolver.cs
        │   │   ├── EmbeddedResource.cs
        │   │   ├── EventAttributes.cs
        │   │   ├── EventDefinition.cs
        │   │   ├── EventDefinitionCollection.cs
        │   │   ├── EventReference.cs
        │   │   ├── ExternTypeCollection.cs
        │   │   ├── FieldAttributes.cs
        │   │   ├── FieldDefinition.cs
        │   │   ├── FieldDefinitionCollection.cs
        │   │   ├── FieldReference.cs
        │   │   ├── FileAttributes.cs
        │   │   ├── FunctionPointerType.cs
        │   │   ├── GenericArgumentCollection.cs
        │   │   ├── GenericContext.cs
        │   │   ├── GenericInstanceMethod.cs
        │   │   ├── GenericInstanceType.cs
        │   │   ├── GenericParameter.cs
        │   │   ├── GenericParameterAttributes.cs
        │   │   ├── GenericParameterCollection.cs
        │   │   ├── HashCodeProvider.cs
        │   │   ├── IAssemblyResolver.cs
        │   │   ├── ICustomAttributeProvider.cs
        │   │   ├── IDetailReader.cs
        │   │   ├── IGenericInstance.cs
        │   │   ├── IGenericParameterProvider.cs
        │   │   ├── IHasConstant.cs
        │   │   ├── IHasMarshalSpec.cs
        │   │   ├── IHasSecurity.cs
        │   │   ├── IMemberDefinition.cs
        │   │   ├── IMemberReference.cs
        │   │   ├── IMetadataScope.cs
        │   │   ├── IMetadataTokenProvider.cs
        │   │   ├── IMethodSignature.cs
        │   │   ├── IReflectionStructureVisitable.cs
        │   │   ├── IReflectionStructureVisitor.cs
        │   │   ├── IReflectionVisitable.cs
        │   │   ├── IReflectionVisitor.cs
        │   │   ├── IRequireResolving.cs
        │   │   ├── ImportContext.cs
        │   │   ├── InterfaceCollection.cs
        │   │   ├── LinkedResource.cs
        │   │   ├── ManifestResourceAttributes.cs
        │   │   ├── MarshalSpec.cs
        │   │   ├── MemberReference.cs
        │   │   ├── MemberReferenceCollection.cs
        │   │   ├── MethodAttributes.cs
        │   │   ├── MethodCallingConvention.cs
        │   │   ├── MethodDefinition.cs
        │   │   ├── MethodDefinitionCollection.cs
        │   │   ├── MethodImplAttributes.cs
        │   │   ├── MethodReference.cs
        │   │   ├── MethodReturnType.cs
        │   │   ├── MethodSemanticsAttributes.cs
        │   │   ├── MethodSpecification.cs
        │   │   ├── Modifiers.cs
        │   │   ├── ModuleDefinition.cs
        │   │   ├── ModuleDefinitionCollection.cs
        │   │   ├── ModuleReference.cs
        │   │   ├── ModuleReferenceCollection.cs
        │   │   ├── NativeType.cs
        │   │   ├── NestedTypeCollection.cs
        │   │   ├── OverrideCollection.cs
        │   │   ├── PInvokeAttributes.cs
        │   │   ├── PInvokeInfo.cs
        │   │   ├── ParameterAttributes.cs
        │   │   ├── ParameterDefinition.cs
        │   │   ├── ParameterDefinitionCollection.cs
        │   │   ├── ParameterReference.cs
        │   │   ├── PinnedType.cs
        │   │   ├── PointerType.cs
        │   │   ├── PropertyAttributes.cs
        │   │   ├── PropertyDefinition.cs
        │   │   ├── PropertyDefinitionCollection.cs
        │   │   ├── PropertyReference.cs
        │   │   ├── ReferenceType.cs
        │   │   ├── ReflectionController.cs
        │   │   ├── ReflectionException.cs
        │   │   ├── ReflectionHelper.cs
        │   │   ├── ReflectionReader.cs
        │   │   ├── ReflectionWriter.cs
        │   │   ├── Resource.cs
        │   │   ├── ResourceCollection.cs
        │   │   ├── SecurityAction.cs
        │   │   ├── SecurityDeclaration.cs
        │   │   ├── SecurityDeclarationCollection.cs
        │   │   ├── SecurityDeclarationReader.cs
        │   │   ├── SentinelType.cs
        │   │   ├── StructureReader.cs
        │   │   ├── StructureWriter.cs
        │   │   ├── TableComparers.cs
        │   │   ├── TargetRuntime.cs
        │   │   ├── TypeAttributes.cs
        │   │   ├── TypeDefinition.cs
        │   │   ├── TypeDefinitionCollection.cs
        │   │   ├── TypeReference.cs
        │   │   ├── TypeReferenceCollection.cs
        │   │   ├── TypeSpecification.cs
        │   │   └── VariantType.cs
        │   ├── Mono.Cecil.Binary/
        │   │   ├── BaseImageVisitor.cs
        │   │   ├── CLIHeader.cs
        │   │   ├── CopyImageVisitor.cs
        │   │   ├── DOSHeader.cs
        │   │   ├── DataDirectory.cs
        │   │   ├── DebugHeader.cs
        │   │   ├── DebugStoreType.cs
        │   │   ├── IBinaryVisitable.cs
        │   │   ├── IBinaryVisitor.cs
        │   │   ├── IHeader.cs
        │   │   ├── Image.cs
        │   │   ├── ImageCharacteristics.cs
        │   │   ├── ImageFormatException.cs
        │   │   ├── ImageInitializer.cs
        │   │   ├── ImageReader.cs
        │   │   ├── ImageWriter.cs
        │   │   ├── Imports.cs
        │   │   ├── MemoryBinaryWriter.cs
        │   │   ├── PEFileHeader.cs
        │   │   ├── PEOptionalHeader.cs
        │   │   ├── RVA.cs
        │   │   ├── ResourceDataEntry.cs
        │   │   ├── ResourceDirectoryEntry.cs
        │   │   ├── ResourceDirectoryString.cs
        │   │   ├── ResourceDirectoryTable.cs
        │   │   ├── ResourceNode.cs
        │   │   ├── ResourceReader.cs
        │   │   ├── ResourceWriter.cs
        │   │   ├── RuntimeImage.cs
        │   │   ├── Section.cs
        │   │   ├── SectionCharacteristics.cs
        │   │   ├── SectionCollection.cs
        │   │   └── SubSystem.cs
        │   ├── Mono.Cecil.Cil/
        │   │   ├── BaseCodeVisitor.cs
        │   │   ├── CilWorker.cs
        │   │   ├── Code.cs
        │   │   ├── CodeReader.cs
        │   │   ├── CodeWriter.cs
        │   │   ├── Document.cs
        │   │   ├── DocumentHashAlgorithm.cs
        │   │   ├── DocumentLanguage.cs
        │   │   ├── DocumentLanguageVendor.cs
        │   │   ├── DocumentType.cs
        │   │   ├── ExceptionHandler.cs
        │   │   ├── ExceptionHandlerCollection.cs
        │   │   ├── ExceptionHandlerType.cs
        │   │   ├── FlowControl.cs
        │   │   ├── GuidAttribute.cs
        │   │   ├── ICodeVisitable.cs
        │   │   ├── ICodeVisitor.cs
        │   │   ├── IScopeProvider.cs
        │   │   ├── ISymbolReader.cs
        │   │   ├── ISymbolStoreFactory.cs
        │   │   ├── ISymbolWriter.cs
        │   │   ├── IVariableDefinitionProvider.cs
        │   │   ├── Instruction.cs
        │   │   ├── InstructionCollection.cs
        │   │   ├── MethodBody.cs
        │   │   ├── MethodDataSection.cs
        │   │   ├── MethodHeader.cs
        │   │   ├── OpCode.cs
        │   │   ├── OpCodeType.cs
        │   │   ├── OpCodes.cs
        │   │   ├── OperandType.cs
        │   │   ├── Scope.cs
        │   │   ├── ScopeCollection.cs
        │   │   ├── SequencePoint.cs
        │   │   ├── StackBehaviour.cs
        │   │   ├── SymbolStoreHelper.cs
        │   │   ├── VariableDefinition.cs
        │   │   ├── VariableDefinitionCollection.cs
        │   │   └── VariableReference.cs
        │   ├── Mono.Cecil.Metadata/
        │   │   ├── Assembly.cs
        │   │   ├── AssemblyOS.cs
        │   │   ├── AssemblyProcessor.cs
        │   │   ├── AssemblyRef.cs
        │   │   ├── AssemblyRefOS.cs
        │   │   ├── AssemblyRefProcessor.cs
        │   │   ├── BaseMetadataVisitor.cs
        │   │   ├── BlobHeap.cs
        │   │   ├── ClassLayout.cs
        │   │   ├── CodedIndex.cs
        │   │   ├── Constant.cs
        │   │   ├── CultureUtils.cs
        │   │   ├── CustomAttribute.cs
        │   │   ├── DeclSecurity.cs
        │   │   ├── ElementType.cs
        │   │   ├── Event.cs
        │   │   ├── EventMap.cs
        │   │   ├── EventPtr.cs
        │   │   ├── ExportedType.cs
        │   │   ├── Field.cs
        │   │   ├── FieldLayout.cs
        │   │   ├── FieldMarshal.cs
        │   │   ├── FieldPtr.cs
        │   │   ├── FieldRVA.cs
        │   │   ├── File.cs
        │   │   ├── GenericParam.cs
        │   │   ├── GenericParamConstraint.cs
        │   │   ├── GuidHeap.cs
        │   │   ├── IMetadataRow.cs
        │   │   ├── IMetadataTable.cs
        │   │   ├── IMetadataVisitable.cs
        │   │   ├── IMetadataVisitor.cs
        │   │   ├── ImplMap.cs
        │   │   ├── InterfaceImpl.cs
        │   │   ├── ManifestResource.cs
        │   │   ├── MemberRef.cs
        │   │   ├── MetadataFormatException.cs
        │   │   ├── MetadataHeap.cs
        │   │   ├── MetadataInitializer.cs
        │   │   ├── MetadataReader.cs
        │   │   ├── MetadataRoot.cs
        │   │   ├── MetadataRowReader.cs
        │   │   ├── MetadataRowWriter.cs
        │   │   ├── MetadataStream.cs
        │   │   ├── MetadataStreamCollection.cs
        │   │   ├── MetadataTableReader.cs
        │   │   ├── MetadataTableWriter.cs
        │   │   ├── MetadataToken.cs
        │   │   ├── MetadataWriter.cs
        │   │   ├── Method.cs
        │   │   ├── MethodImpl.cs
        │   │   ├── MethodPtr.cs
        │   │   ├── MethodSemantics.cs
        │   │   ├── MethodSpec.cs
        │   │   ├── Module.cs
        │   │   ├── ModuleRef.cs
        │   │   ├── NestedClass.cs
        │   │   ├── Param.cs
        │   │   ├── ParamPtr.cs
        │   │   ├── Property.cs
        │   │   ├── PropertyMap.cs
        │   │   ├── PropertyPtr.cs
        │   │   ├── RowCollection.cs
        │   │   ├── StandAloneSig.cs
        │   │   ├── StringsHeap.cs
        │   │   ├── TableCollection.cs
        │   │   ├── TablesHeap.cs
        │   │   ├── TokenType.cs
        │   │   ├── TypeDef.cs
        │   │   ├── TypeRef.cs
        │   │   ├── TypeSpec.cs
        │   │   ├── UserStringsHeap.cs
        │   │   └── Utilities.cs
        │   ├── Mono.Cecil.Signatures/
        │   │   ├── Array.cs
        │   │   ├── ArrayShape.cs
        │   │   ├── BaseSignatureVisitor.cs
        │   │   ├── Class.cs
        │   │   ├── Constraint.cs
        │   │   ├── CustomAttrib.cs
        │   │   ├── CustomMod.cs
        │   │   ├── FieldSig.cs
        │   │   ├── FnPtr.cs
        │   │   ├── GenericArg.cs
        │   │   ├── GenericInst.cs
        │   │   ├── GenericInstSignature.cs
        │   │   ├── ISignatureVisitable.cs
        │   │   ├── ISignatureVisitor.cs
        │   │   ├── InputOutputItem.cs
        │   │   ├── LocalVarSig.cs
        │   │   ├── MVar.cs
        │   │   ├── MarshalSig.cs
        │   │   ├── MethodDefSig.cs
        │   │   ├── MethodRefSig.cs
        │   │   ├── MethodSig.cs
        │   │   ├── MethodSpec.cs
        │   │   ├── Param.cs
        │   │   ├── PropertySig.cs
        │   │   ├── Ptr.cs
        │   │   ├── RetType.cs
        │   │   ├── SigType.cs
        │   │   ├── Signature.cs
        │   │   ├── SignatureReader.cs
        │   │   ├── SignatureWriter.cs
        │   │   ├── SzArray.cs
        │   │   ├── TypeSpec.cs
        │   │   ├── ValueType.cs
        │   │   └── Var.cs
        │   └── Mono.Xml/
        │       ├── MiniParser.cs
        │       ├── SecurityParser.cs
        │       └── SmallXmlParser.cs
        ├── Properties/
        │   └── AssemblyInfo.cs
        └── Removers/
            ├── AntiDebug.cs
            ├── AntiDump.cs
            ├── ResourceDecrypter.cs
            └── StringDecrypter.cs

================================================
File: README.md
================================================
DeConfuser
==========

This is a deobfuscator for protected confuser assemblies
De4Dot did not support this yet so some one had to begun working at it :)
You can find about me more at codeplex, hackforums, darkhook

Long live deobfuscators/C++ !
Yet again this is a drag/drop deobfuscator
The confuser i



================================================
File: DeConfuser.sln
================================================
ï»¿
Microsoft Visual Studio Solution File, Format Version 11.00
# Visual Studio 2010
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "DeConfuser", "DeConfuser\DeConfuser.csproj", "{2C4B0612-EED0-4FD3-BAED-B7507FCD6BFF}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ConfuseMe", "ConfuseMe\ConfuseMe.csproj", "{D08E70D5-9DDE-43C3-A8EC-00E4E16E8947}"
EndProject
Global
	GlobalSection(SubversionScc) = preSolution
		Svn-Managed = True
		Manager = AnkhSVN - Subversion Support for Visual Studio
	EndGlobalSection
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x86 = Debug|x86
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{2C4B0612-EED0-4FD3-BAED-B7507FCD6BFF}.Debug|x86.ActiveCfg = Debug|x86
		{2C4B0612-EED0-4FD3-BAED-B7507FCD6BFF}.Debug|x86.Build.0 = Debug|x86
		{2C4B0612-EED0-4FD3-BAED-B7507FCD6BFF}.Release|x86.ActiveCfg = Release|x86
		{2C4B0612-EED0-4FD3-BAED-B7507FCD6BFF}.Release|x86.Build.0 = Release|x86
		{D08E70D5-9DDE-43C3-A8EC-00E4E16E8947}.Debug|x86.ActiveCfg = Debug|x86
		{D08E70D5-9DDE-43C3-A8EC-00E4E16E8947}.Debug|x86.Build.0 = Debug|x86
		{D08E70D5-9DDE-43C3-A8EC-00E4E16E8947}.Release|x86.ActiveCfg = Release|x86
		{D08E70D5-9DDE-43C3-A8EC-00E4E16E8947}.Release|x86.Build.0 = Release|x86
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal



================================================
File: LICENSE
================================================
GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    {one line to give the program's name and a brief idea of what it does.}
    Copyright (C) {year}  {name of author}

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    {project}  Copyright (C) {year}  {fullname}
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<http://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<http://www.gnu.org/philosophy/why-not-lgpl.html>.



================================================
File: ConfuseMe/ConfuseMe.csproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">x86</Platform>
    <ProductVersion>8.0.30703</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{D08E70D5-9DDE-43C3-A8EC-00E4E16E8947}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>ConfuseMe</RootNamespace>
    <AssemblyName>ConfuseMe</AssemblyName>
    <TargetFrameworkVersion>v2.0</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
    <PlatformTarget>x86</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
    <PlatformTarget>x86</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Data" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="Properties\Resources.Designer.cs">
      <AutoGen>True</AutoGen>
      <DesignTime>True</DesignTime>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
  </ItemGroup>
  <ItemGroup>
    <EmbeddedResource Include="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
    </EmbeddedResource>
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\TextFile1.txt" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>


================================================
File: ConfuseMe/Program.cs
================================================
ï»¿/*
Copyright (C) 2012 DragonHunter

This file is part of DeConfuser.

DeConfuser is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

DeConfuser is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with DeConfuser. If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Text;
using System.Diagnostics;

namespace ConfuseMe
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("oh my god a string D:");
            Console.WriteLine("OH snap... im decrypted");
            Process.GetCurrentProcess().WaitForExit();
        }
    }
}


================================================
File: ConfuseMe/Properties/AssemblyInfo.cs
================================================
ï»¿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("ConfuseMe")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Ingram")]
[assembly: AssemblyProduct("ConfuseMe")]
[assembly: AssemblyCopyright("Copyright Â© Ingram 2012")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("392dd801-65d1-463a-ae85-a3b63af58a77")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]



================================================
File: ConfuseMe/Properties/Resources.Designer.cs
================================================
ï»¿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.239
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace ConfuseMe.Properties {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("ConfuseMe.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to something encrypted....
        /// </summary>
        internal static string TextFile1 {
            get {
                return ResourceManager.GetString("TextFile1", resourceCulture);
            }
        }
    }
}



================================================
File: ConfuseMe/Properties/Resources.resx
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <assembly alias="System.Windows.Forms" name="System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />
  <data name="TextFile1" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\TextFile1.txt;System.String, mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089;Windows-1252</value>
  </data>
</root>


================================================
File: ConfuseMe/Resources/TextFile1.txt
================================================
something encrypted...


================================================
File: DeConfuser/DeConfuser.csproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">x86</Platform>
    <ProductVersion>8.0.30703</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{2C4B0612-EED0-4FD3-BAED-B7507FCD6BFF}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>DeConfuser</RootNamespace>
    <AssemblyName>DeConfuser</AssemblyName>
    <TargetFrameworkVersion>v2.0</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
    <PlatformTarget>x86</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
    <PlatformTarget>x86</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Data" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="MonoCecil\ILProcessor.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Binary\BaseImageVisitor.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Binary\CLIHeader.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Binary\CopyImageVisitor.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Binary\DataDirectory.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Binary\DebugHeader.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Binary\DebugStoreType.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Binary\DOSHeader.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Binary\IBinaryVisitable.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Binary\IBinaryVisitor.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Binary\IHeader.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Binary\Image.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Binary\ImageCharacteristics.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Binary\ImageFormatException.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Binary\ImageInitializer.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Binary\ImageReader.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Binary\ImageWriter.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Binary\Imports.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Binary\MemoryBinaryWriter.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Binary\PEFileHeader.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Binary\PEOptionalHeader.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Binary\ResourceDataEntry.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Binary\ResourceDirectoryEntry.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Binary\ResourceDirectoryString.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Binary\ResourceDirectoryTable.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Binary\ResourceNode.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Binary\ResourceReader.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Binary\ResourceWriter.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Binary\RuntimeImage.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Binary\RVA.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Binary\Section.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Binary\SectionCharacteristics.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Binary\SectionCollection.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Binary\SubSystem.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Cil\BaseCodeVisitor.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Cil\CilWorker.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Cil\Code.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Cil\CodeReader.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Cil\CodeWriter.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Cil\Document.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Cil\DocumentHashAlgorithm.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Cil\DocumentLanguage.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Cil\DocumentLanguageVendor.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Cil\DocumentType.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Cil\ExceptionHandler.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Cil\ExceptionHandlerCollection.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Cil\ExceptionHandlerType.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Cil\FlowControl.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Cil\GuidAttribute.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Cil\ICodeVisitable.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Cil\ICodeVisitor.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Cil\Instruction.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Cil\InstructionCollection.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Cil\IScopeProvider.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Cil\ISymbolReader.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Cil\ISymbolStoreFactory.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Cil\ISymbolWriter.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Cil\IVariableDefinitionProvider.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Cil\MethodBody.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Cil\MethodDataSection.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Cil\MethodHeader.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Cil\OpCode.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Cil\OpCodes.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Cil\OpCodeType.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Cil\OperandType.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Cil\Scope.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Cil\ScopeCollection.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Cil\SequencePoint.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Cil\StackBehaviour.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Cil\SymbolStoreHelper.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Cil\VariableDefinition.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Cil\VariableDefinitionCollection.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Cil\VariableReference.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\Assembly.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\AssemblyOS.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\AssemblyProcessor.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\AssemblyRef.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\AssemblyRefOS.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\AssemblyRefProcessor.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\BaseMetadataVisitor.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\BlobHeap.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\ClassLayout.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\CodedIndex.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\Constant.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\CultureUtils.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\CustomAttribute.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\DeclSecurity.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\ElementType.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\Event.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\EventMap.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\EventPtr.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\ExportedType.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\Field.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\FieldLayout.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\FieldMarshal.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\FieldPtr.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\FieldRVA.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\File.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\GenericParam.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\GenericParamConstraint.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\GuidHeap.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\IMetadataRow.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\IMetadataTable.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\IMetadataVisitable.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\IMetadataVisitor.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\ImplMap.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\InterfaceImpl.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\ManifestResource.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\MemberRef.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\MetadataFormatException.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\MetadataHeap.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\MetadataInitializer.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\MetadataReader.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\MetadataRoot.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\MetadataRowReader.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\MetadataRowWriter.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\MetadataStream.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\MetadataStreamCollection.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\MetadataTableReader.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\MetadataTableWriter.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\MetadataToken.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\MetadataWriter.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\Method.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\MethodImpl.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\MethodPtr.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\MethodSemantics.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\MethodSpec.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\Module.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\ModuleRef.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\NestedClass.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\Param.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\ParamPtr.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\Property.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\PropertyMap.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\PropertyPtr.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\RowCollection.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\StandAloneSig.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\StringsHeap.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\TableCollection.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\TablesHeap.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\TokenType.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\TypeDef.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\TypeRef.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\TypeSpec.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\UserStringsHeap.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Metadata\Utilities.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Signatures\Array.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Signatures\ArrayShape.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Signatures\BaseSignatureVisitor.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Signatures\Class.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Signatures\Constraint.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Signatures\CustomAttrib.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Signatures\CustomMod.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Signatures\FieldSig.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Signatures\FnPtr.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Signatures\GenericArg.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Signatures\GenericInst.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Signatures\GenericInstSignature.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Signatures\InputOutputItem.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Signatures\ISignatureVisitable.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Signatures\ISignatureVisitor.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Signatures\LocalVarSig.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Signatures\MarshalSig.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Signatures\MethodDefSig.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Signatures\MethodRefSig.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Signatures\MethodSig.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Signatures\MethodSpec.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Signatures\MVar.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Signatures\Param.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Signatures\PropertySig.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Signatures\Ptr.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Signatures\RetType.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Signatures\Signature.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Signatures\SignatureReader.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Signatures\SignatureWriter.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Signatures\SigType.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Signatures\SzArray.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Signatures\TypeSpec.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Signatures\ValueType.cs" />
    <Compile Include="MonoCecil\Mono.Cecil.Signatures\Var.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\AggressiveReflectionReader.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\ArrayDimension.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\ArrayDimensionCollection.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\ArrayType.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\AssemblyDefinition.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\AssemblyFactory.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\AssemblyFlags.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\AssemblyHashAlgorithm.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\AssemblyKind.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\AssemblyLinkedResource.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\AssemblyNameDefinition.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\AssemblyNameReference.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\AssemblyNameReferenceCollection.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\BaseAssemblyResolver.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\BaseReflectionReader.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\BaseReflectionVisitor.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\BaseStructureVisitor.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\CallSite.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\CompactFrameworkCompatibility.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\Constants.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\ConstraintCollection.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\ConstructorCollection.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\CustomAttribute.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\CustomAttributeCollection.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\DefaultAssemblyResolver.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\EmbeddedResource.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\EventAttributes.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\EventDefinition.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\EventDefinitionCollection.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\EventReference.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\ExternTypeCollection.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\FieldAttributes.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\FieldDefinition.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\FieldDefinitionCollection.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\FieldReference.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\FileAttributes.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\FunctionPointerType.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\GenericArgumentCollection.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\GenericContext.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\GenericInstanceMethod.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\GenericInstanceType.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\GenericParameter.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\GenericParameterAttributes.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\GenericParameterCollection.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\HashCodeProvider.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\IAssemblyResolver.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\ICustomAttributeProvider.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\IDetailReader.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\IGenericInstance.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\IGenericParameterProvider.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\IHasConstant.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\IHasMarshalSpec.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\IHasSecurity.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\IMemberDefinition.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\IMemberReference.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\IMetadataScope.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\IMetadataTokenProvider.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\IMethodSignature.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\ImportContext.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\InterfaceCollection.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\IReflectionStructureVisitable.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\IReflectionStructureVisitor.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\IReflectionVisitable.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\IReflectionVisitor.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\IRequireResolving.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\LinkedResource.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\ManifestResourceAttributes.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\MarshalSpec.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\MemberReference.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\MemberReferenceCollection.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\MethodAttributes.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\MethodCallingConvention.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\MethodDefinition.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\MethodDefinitionCollection.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\MethodImplAttributes.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\MethodReference.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\MethodReturnType.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\MethodSemanticsAttributes.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\MethodSpecification.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\Modifiers.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\ModuleDefinition.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\ModuleDefinitionCollection.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\ModuleReference.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\ModuleReferenceCollection.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\NativeType.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\NestedTypeCollection.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\OverrideCollection.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\ParameterAttributes.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\ParameterDefinition.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\ParameterDefinitionCollection.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\ParameterReference.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\PinnedType.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\PInvokeAttributes.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\PInvokeInfo.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\PointerType.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\PropertyAttributes.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\PropertyDefinition.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\PropertyDefinitionCollection.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\PropertyReference.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\ReferenceType.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\ReflectionController.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\ReflectionException.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\ReflectionHelper.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\ReflectionReader.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\ReflectionWriter.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\Resource.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\ResourceCollection.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\SecurityAction.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\SecurityDeclaration.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\SecurityDeclarationCollection.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\SecurityDeclarationReader.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\SentinelType.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\StructureReader.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\StructureWriter.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\TableComparers.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\TargetRuntime.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\TypeAttributes.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\TypeDefinition.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\TypeDefinitionCollection.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\TypeReference.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\TypeReferenceCollection.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\TypeSpecification.cs" />
    <Compile Include="MonoCecil\Mono.Cecil\VariantType.cs" />
    <Compile Include="MonoCecil\Mono.Xml\MiniParser.cs" />
    <Compile Include="MonoCecil\Mono.Xml\SecurityParser.cs" />
    <Compile Include="MonoCecil\Mono.Xml\SmallXmlParser.cs" />
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="Removers\AntiDebug.cs" />
    <Compile Include="Removers\AntiDump.cs" />
    <Compile Include="Removers\ResourceDecrypter.cs" />
    <Compile Include="Removers\StringDecrypter.cs" />
  </ItemGroup>
  <ItemGroup>
    <Content Include="License.txt" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>


================================================
File: DeConfuser/License.txt
================================================
ï»¿Copyright (C) 1989, 1991 Free Software Foundation, Inc.
59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

Everyone is permitted to copy and distribute verbatim copies
of this license document, but changing it is not allowed.

Preamble

The licenses for most software are designed to take away your freedom to share and change it. By contrast, the GNU General Public License is intended to guarantee your freedom to share and change free software--to make sure the software is free for all its users. This General Public License applies to most of the Free Software Foundation's software and to any other program whose authors commit to using it. (Some other Free Software Foundation software is covered by the GNU Library General Public License instead.) You can apply it to your programs, too.

When we speak of free software, we are referring to freedom, not price. Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for this service if you wish), that you receive source code or can get it if you want it, that you can change the software or use pieces of it in new free programs; and that you know you can do these things.

To protect your rights, we need to make restrictions that forbid anyone to deny you these rights or to ask you to surrender the rights. These restrictions translate to certain responsibilities for you if you distribute copies of the software, or if you modify it.

For example, if you distribute copies of such a program, whether gratis or for a fee, you must give the recipients all the rights that you have. You must make sure that they, too, receive or can get the source code. And you must show them these terms so they know their rights.

We protect your rights with two steps: (1) copyright the software, and (2) offer you this license which gives you legal permission to copy, distribute and/or modify the software.

Also, for each author's protection and ours, we want to make certain that everyone understands that there is no warranty for this free software. If the software is modified by someone else and passed on, we want its recipients to know that what they have is not the original, so that any problems introduced by others will not reflect on the original authors' reputations.

Finally, any free program is threatened constantly by software patents. We wish to avoid the danger that redistributors of a free program will individually obtain patent licenses, in effect making the program proprietary. To prevent this, we have made it clear that any patent must be licensed for everyone's free use or not licensed at all.

The precise terms and conditions for copying, distribution and modification follow.

TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

0. This License applies to any program or other work which contains a notice placed by the copyright holder saying it may be distributed under the terms of this General Public License. The "Program", below, refers to any such program or work, and a "work based on the Program" means either the Program or any derivative work under copyright law: that is to say, a work containing the Program or a portion of it, either verbatim or with modifications and/or translated into another language. (Hereinafter, translation is included without limitation in the term "modification".) Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not covered by this License; they are outside its scope. The act of running the Program is not restricted, and the output from the Program is covered only if its contents constitute a work based on the Program (independent of having been made by running the Program). Whether that is true depends on what the Program does.

1. You may copy and distribute verbatim copies of the Program's source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice and disclaimer of warranty; keep intact all the notices that refer to this License and to the absence of any warranty; and give any other recipients of the Program a copy of this License along with the Program.

You may charge a fee for the physical act of transferring a copy, and you may at your option offer warranty protection in exchange for a fee.

2. You may modify your copy or copies of the Program or any portion of it, thus forming a work based on the Program, and copy and distribute such modifications or work under the terms of Section 1 above, provided that you also meet all of these conditions:

a) You must cause the modified files to carry prominent notices stating that you changed the files and the date of any change.

b) You must cause any work that you distribute or publish, that in whole or in part contains or is derived from the Program or any part thereof, to be licensed as a whole at no charge to all third parties under the terms of this License.

c) If the modified program normally reads commands interactively when run, you must cause it, when started running for such interactive use in the most ordinary way, to print or display an announcement including an appropriate copyright notice and a notice that there is no warranty (or else, saying that you provide a warranty) and that users may redistribute the program under these conditions, and telling the user how to view a copy of this License. (Exception: if the Program itself is interactive but does not normally print such an announcement, your work based on the Program is not required to print an announcement.)

These requirements apply to the modified work as a whole. If identifiable sections of that work are not derived from the Program, and can be reasonably considered independent and separate works in themselves, then this License, and its terms, do not apply to those sections when you distribute them as separate works. But when you distribute the same sections as part of a whole which is a work based on the Program, the distribution of the whole must be on the terms of this License, whose permissions for other licensees extend to the entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest your rights to work written entirely by you; rather, the intent is to exercise the right to control the distribution of derivative or collective works based on the Program.

In addition, mere aggregation of another work not based on the Program with the Program (or with a work based on the Program) on a volume of a storage or distribution medium does not bring the other work under the scope of this License.

3. You may copy and distribute the Program (or a work based on it, under Section 2) in object code or executable form under the terms of Sections 1 and 2 above provided that you also do one of the following:

a) Accompany it with the complete corresponding machine-readable source code, which must be distributed under the terms of Sections 1 and 2 above on a medium customarily used for software interchange; or,

b) Accompany it with a written offer, valid for at least three years, to give any third party, for a charge no more than your cost of physically performing source distribution, a complete machine-readable copy of the corresponding source code, to be distributed under the terms of Sections 1 and 2 above on a medium customarily used for software interchange; or,

c) Accompany it with the information you received as to the offer to distribute corresponding source code. (This alternative is allowed only for noncommercial distribution and only if you received the program in object code or executable form with such an offer, in accord with Subsection b above.)

The source code for a work means the preferred form of the work for making modifications to it. For an executable work, complete source code means all the source code for all modules it contains, plus any associated interface definition files, plus the scripts used to control compilation and installation of the executable. However, as a special exception, the source code distributed need not include anything that is normally distributed (in either source or binary form) with the major components (compiler, kernel, and so on) of the operating system on which the executable runs, unless that component itself accompanies the executable.

If distribution of executable or object code is made by offering access to copy from a designated place, then offering equivalent access to copy the source code from the same place counts as distribution of the source code, even though third parties are not compelled to copy the source along with the object code.

4. You may not copy, modify, sublicense, or distribute the Program except as expressly provided under this License. Any attempt otherwise to copy, modify, sublicense or distribute the Program is void, and will automatically terminate your rights under this License. However, parties who have received copies, or rights, from you under this License will not have their licenses terminated so long as such parties remain in full compliance.

5. You are not required to accept this License, since you have not signed it. However, nothing else grants you permission to modify or distribute the Program or its derivative works. These actions are prohibited by law if you do not accept this License. Therefore, by modifying or distributing the Program (or any work based on the Program), you indicate your acceptance of this License to do so, and all its terms and conditions for copying, distributing or modifying the Program or works based on it.

6. Each time you redistribute the Program (or any work based on the Program), the recipient automatically receives a license from the original licensor to copy, distribute or modify the Program subject to these terms and conditions. You may not impose any further restrictions on the recipients' exercise of the rights granted herein. You are not responsible for enforcing compliance by third parties to this License.

7. If, as a consequence of a court judgment or allegation of patent infringement or for any other reason (not limited to patent issues), conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License. If you cannot distribute so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not distribute the Program at all. For example, if a patent license would not permit royalty-free redistribution of the Program by all those who receive copies directly or indirectly through you, then the only way you could satisfy both it and this License would be to refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under any particular circumstance, the balance of the section is intended to apply and the section as a whole is intended to apply in other circumstances.

It is not the purpose of this section to induce you to infringe any patents or other property right claims or to contest validity of any such claims; this section has the sole purpose of protecting the integrity of the free software distribution system, which is implemented by public license practices. Many people have made generous contributions to the wide range of software distributed through that system in reliance on consistent application of that system; it is up to the author/donor to decide if he or she is willing to distribute software through any other system and a licensee cannot impose that choice.

This section is intended to make thoroughly clear what is believed to be a consequence of the rest of this License.

8. If the distribution and/or use of the Program is restricted in certain countries either by patents or by copyrighted interfaces, the original copyright holder who places the Program under this License may add an explicit geographical distribution limitation excluding those countries, so that distribution is permitted only in or among countries not thus excluded. In such case, this License incorporates the limitation as if written in the body of this License.

9. The Free Software Foundation may publish revised and/or new versions of the General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns.

Each version is given a distinguishing version number. If the Program specifies a version number of this License which applies to it and "any later version", you have the option of following the terms and conditions either of that version or of any later version published by the Free Software Foundation. If the Program does not specify a version number of this License, you may choose any version ever published by the Free Software Foundation.

10. If you wish to incorporate parts of the Program into other free programs whose distribution conditions are different, write to the author to ask for permission. For software which is copyrighted by the Free Software Foundation, write to the Free Software Foundation; we sometimes make exceptions for this. Our decision will be guided by the two goals of preserving the free status of all derivatives of our free software and of promoting the sharing and reuse of software generally.

NO WARRANTY

11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. 


================================================
File: DeConfuser/Program.cs
================================================
ï»¿/*
Copyright (C) 2012 DragonHunter

This file is part of DeConfuser.

DeConfuser is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

DeConfuser is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with DeConfuser. If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using Mono.Cecil;
using System.Diagnostics;
using DeConfuser.Removers;
using Mono.Cecil.Cil;

namespace DeConfuser
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.Title = "DeConfuser - The De-Obfuscator for confuser v1.6";
            Console.WriteLine("Copyright Â© DragonHunter - 2012");
            Console.WriteLine("This deobfuscator might not work at every confused assembly, still BETA");
            Console.WriteLine("Checkout this project at http://deconfuser.codeplex.com");
            Console.WriteLine("Thanks also to Mono.Cecil there was no DeConfuser without Mono.Cecil");
            Console.WriteLine("This version of Mono.Cecil is modded by DragonHunter to do some evil shit");

            //hardcoded path atm...
            string inputPath = @"H:\DeConfuser\ConfuseMe\bin\Debug\confused\ConfuseMe.exe";
            string outputPath = @"H:\DeConfuser\ConfuseMe\bin\Debug\confused\ConfuseMe_cleaned.exe";

            //load assembly
            AssemblyDefinition asm = AssemblyFactory.GetAssembly(inputPath);

            #region Anti-Debug remover
            AntiDebug debug = new AntiDebug();
            TypeDefinition AntiType = null;
            MethodDefinition AntiMethod = null;
            Console.WriteLine("-------------------------------------------------------");
            if (debug.FindAntiDebug(asm, ref AntiType, ref AntiMethod))
            {
                Console.WriteLine("[Anti-Debugger] Anti-Debugger detected, removing...");
                debug.RemoveAntiDebug(asm, AntiType, AntiMethod);
                Console.WriteLine("[Anti-Debugger] Removed anti-debugger");
            }
            else
            {
                Console.WriteLine("This assembly is not protected with anti-debugging");
            }
            Console.WriteLine("-------------------------------------------------------");
            #endregion
            #region String Decryptor
            StringDecrypter decrypter = new StringDecrypter();
            TypeDefinition DecryptType = null;
            MethodDefinition DecryptMethod = null;
            if (decrypter.FindMethod(asm, ref DecryptType, ref DecryptMethod))
            {
                Console.WriteLine("[String Decryptor] Found string decryptor, decrypting strings...");
                byte[] StringData = decrypter.GetStringResource(asm, inputPath, DecryptMethod);
                decrypter.DecryptAllStrings(asm, DecryptMethod, StringData);
                decrypter.RemoveDecryptMethod(asm, DecryptType, DecryptMethod);
                Console.WriteLine("[String Decryptor] Removed the decrypt method");
            }
            else
            {
                Console.WriteLine("This assembly is not protected with encrypted strings");
            }
            Console.WriteLine("-------------------------------------------------------");
            #endregion
            #region Anti-Dump remover
            AntiDump dump = new AntiDump();
            TypeDefinition AntiDumpType = null;
            MethodDefinition AntiDumpMethod = null;
            if (dump.FindAntiDump(asm, ref AntiDumpType, ref AntiDumpMethod))
            {
                Console.WriteLine("[Anti-Dump] Anti-Dump detected, removing...");
                dump.RemoveAntiDump(asm, AntiDumpType, AntiDumpMethod);
                Console.WriteLine("[Anti-Dump] Removed anti-dump");
            }
            else
            {
                Console.WriteLine("This assembly is not protected with anti-dump");
            }
            Console.WriteLine("-------------------------------------------------------");
            #endregion
            #region Resource Decryptor
            ResourceDecrypter resourceDecrypter = new ResourceDecrypter();
            TypeDefinition ResourceType = null;
            MethodDefinition ResourceMethod = null;
            if (resourceDecrypter.FindMethod(asm, ref ResourceType, ref ResourceMethod))
            {
                Console.WriteLine("[Resource-Decrypter] Resource-Decrypter, decrypting");
                resourceDecrypter.DecryptAllResources(asm, inputPath, ResourceType, ResourceMethod);
            }
            else
            {
                Console.WriteLine("This assembly is not protected with encrypted resources");
            }
            Console.WriteLine("-------------------------------------------------------");
            #endregion


            AssemblyFactory.SaveAssembly(asm, outputPath);
            Console.WriteLine("File dumped to \"" + outputPath + "\"");
            Console.WriteLine("Thanks for using DeConfuser :)");
            Process.GetCurrentProcess().WaitForExit();
        }
        
        public static bool ScanSignature(MethodDefinition m, OpCode[] Signature)
        {
            bool found = true;
            for (int j = 0; j < m.Body.Instructions.Count && j < Signature.Length; j++)
            {
                if (m.Body.Instructions[j].OpCode != Signature[j])
                {
                    found = false;
                    break;
                }
            }
            return found;
        }
        public static bool ReadSigKey(MethodDefinition DecryptMethod, OpCode[] KeySig, ref int val)
        {
            object value = null;
            bool ret = ReadSigKey(DecryptMethod, KeySig, ref value);
            if (value != null)
                val = Convert.ToInt32(value);
            return ret;
        }
        public static bool ReadSigKey(MethodDefinition DecryptMethod, OpCode[] KeySig, ref string val)
        {
            object value = null;
            bool ret = ReadSigKey(DecryptMethod, KeySig, ref value);
            if (value != null)
                val = value.ToString();
            return ret;
        }
        public static bool ReadSigKey(MethodDefinition DecryptMethod, OpCode[] KeySig, ref object val)
        {
            int score = 0;
            for (int i = 0; i < DecryptMethod.Body.Instructions.Count; i++)
            {
                if (DecryptMethod.Body.Instructions[i].OpCode == KeySig[score])
                {
                    score++;
                    if (score == KeySig.Length)
                    {
                        if (DecryptMethod.Body.Instructions[i].Next != null)
                        {
                            if (DecryptMethod.Body.Instructions[i].Next.Operand != null)
                            {
                                val = DecryptMethod.Body.Instructions[i].Next.Operand;
                                return true;
                            }
                        }
                    }
                }
                else
                {
                    score = 0;
                }
            }
            return false;
        }
    }
}


================================================
File: DeConfuser/MonoCecil/ILProcessor.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Text;
using Mono.Cecil.Cil;
using Mono.Cecil;

namespace Anguis.NetFuscator.MonoCecil
{
    public sealed class ILProcessor
    {
        readonly MethodDefinition method;
        readonly InstructionCollection instructions;

        public MethodBody Body
        {
            get { return method.Body; }
            set { method.Body = value; }
        }

        internal ILProcessor(MethodDefinition method)
        {
            this.method = method;
            this.instructions = method.Body.Instructions;
        }

        public Instruction Create(OpCode opcode)
        {
            return Instruction.Create(opcode);
        }

        public Instruction Create(OpCode opcode, TypeReference type)
        {
            return Instruction.Create(opcode, type);
        }

        public Instruction Create(OpCode opcode, CallSite site)
        {
            return Instruction.Create(opcode, site);
        }

        public Instruction Create(OpCode opcode, MethodReference method)
        {
            return Instruction.Create(opcode, method);
        }

        public Instruction Create(OpCode opcode, FieldReference field)
        {
            return Instruction.Create(opcode, field);
        }

        public Instruction Create(OpCode opcode, string value)
        {
            return Instruction.Create(opcode, value);
        }

        public Instruction Create(OpCode opcode, sbyte value)
        {
            return Instruction.Create(opcode, value);
        }

        public Instruction Create(OpCode opcode, byte value)
        {
            if (opcode.OperandType == OperandType.ShortInlineVar)
                return Instruction.Create(opcode, Body.Variables[value]);

            if (opcode.OperandType == OperandType.ShortInlineArg)
                return Instruction.Create(opcode, method.Parameters[value]);

            return Instruction.Create(opcode, value);
        }

        public Instruction Create(OpCode opcode, int value)
        {
            if (opcode.OperandType == OperandType.InlineVar)
                return Instruction.Create(opcode, Body.Variables[value]);

            if (opcode.OperandType == OperandType.InlineArg)
                return Instruction.Create(opcode, method.Parameters[value]);

            return Instruction.Create(opcode, value);
        }

        public Instruction Create(OpCode opcode, long value)
        {
            return Instruction.Create(opcode, value);
        }

        public Instruction Create(OpCode opcode, float value)
        {
            return Instruction.Create(opcode, value);
        }

        public Instruction Create(OpCode opcode, double value)
        {
            return Instruction.Create(opcode, value);
        }

        public Instruction Create(OpCode opcode, Instruction target)
        {
            return Instruction.Create(opcode, target);
        }

        public Instruction Create(OpCode opcode, Instruction[] targets)
        {
            return Instruction.Create(opcode, targets);
        }

        public Instruction Create(OpCode opcode, VariableDefinition variable)
        {
            return Instruction.Create(opcode, variable);
        }

        public Instruction Create(OpCode opcode, ParameterDefinition parameter)
        {
            return Instruction.Create(opcode, parameter);
        }

        public void Emit(OpCode opcode)
        {
            Append(Create(opcode));
        }

        public void Emit(OpCode opcode, TypeReference type)
        {
            Append(Create(opcode, type));
        }

        public void Emit(OpCode opcode, MethodReference method)
        {
            Append(Create(opcode, method));
        }

        public void Emit(OpCode opcode, CallSite site)
        {
            Append(Create(opcode, site));
        }

        public void Emit(OpCode opcode, FieldReference field)
        {
            Append(Create(opcode, field));
        }

        public void Emit(OpCode opcode, string value)
        {
            Append(Create(opcode, value));
        }

        public void Emit(OpCode opcode, byte value)
        {
            Append(Create(opcode, value));
        }

        public void Emit(OpCode opcode, sbyte value)
        {
            Append(Create(opcode, value));
        }

        public void Emit(OpCode opcode, int value)
        {
            Append(Create(opcode, value));
        }

        public void Emit(OpCode opcode, long value)
        {
            Append(Create(opcode, value));
        }

        public void Emit(OpCode opcode, float value)
        {
            Append(Create(opcode, value));
        }

        public void Emit(OpCode opcode, double value)
        {
            Append(Create(opcode, value));
        }

        public void Emit(OpCode opcode, Instruction target)
        {
            Append(Create(opcode, target));
        }

        public void Emit(OpCode opcode, Instruction[] targets)
        {
            Append(Create(opcode, targets));
        }

        public void Emit(OpCode opcode, VariableDefinition variable)
        {
            Append(Create(opcode, variable));
        }

        public void Emit(OpCode opcode, ParameterDefinition parameter)
        {
            Append(Create(opcode, parameter));
        }

        public void InsertBefore(Instruction target, Instruction instruction)
        {
            if (target == null)
                throw new ArgumentNullException("target");
            if (instruction == null)
                throw new ArgumentNullException("instruction");

            var index = instructions.IndexOf(target);
            if (index == -1)
                throw new ArgumentOutOfRangeException("target");

            instructions.Insert(index, instruction);
        }
        public void InsertBefore(int targetIndex, Instruction instruction)
        {
            if (instruction == null)
                throw new ArgumentNullException("instruction");
            if (targetIndex > instructions.Count || targetIndex < 0)
                throw new ArgumentOutOfRangeException("targetIndex");

            instructions.Insert(targetIndex, instruction);
        }

        public void InsertAfter(Instruction target, Instruction instruction)
        {
            if (target == null)
                throw new ArgumentNullException("target");
            if (instruction == null)
                throw new ArgumentNullException("instruction");

            var index = instructions.IndexOf(target);
            if (index == -1)
                throw new ArgumentOutOfRangeException("target");

            instructions.Insert(index + 1, instruction);
        }
        public void InsertAfter(int targetIndex, Instruction instruction)
        {
            if (instruction == null)
                throw new ArgumentNullException("instruction");
            if (targetIndex > instructions.Count || targetIndex < 0)
                throw new ArgumentOutOfRangeException("targetIndex");

            instructions.Insert(targetIndex + 1, instruction);
        }

        public void Append(Instruction instruction)
        {
            if (instruction == null)
                throw new ArgumentNullException("instruction");

            instructions.Add(instruction);
        }

        public void Replace(Instruction target, Instruction instruction)
        {
            if (target == null)
                throw new ArgumentNullException("target");
            if (instruction == null)
                throw new ArgumentNullException("instruction");

            int index = instructions.IndexOf(target);
            instructions[index] = instruction;
            if (index != 0) instructions[index - 1].Next = instruction;
            if (index != instructions.Count - 1) instructions[index + 1].Previous = instruction;
            foreach (Instruction inst in instructions)
            {
                if (inst.Operand is Instruction && inst.Operand == target)
                    inst.Operand = instruction;
                else if (inst.Operand is Instruction[])
                {
                    Instruction[] s = inst.Operand as Instruction[];
                    for (int i = 0; i < s.Length; i++)
                        if (s[i] == target)
                            s[i] = instruction;
                    inst.Operand = s;
                }
            }

            if (Body.ExceptionHandlers != null)
            {
                foreach (ExceptionHandler eh in Body.ExceptionHandlers)
                {
                    if (eh.TryStart == target) eh.TryStart = instruction;
                    if (eh.TryEnd == target) eh.TryEnd = instruction;
                    if (eh.HandlerStart == target) eh.HandlerStart = instruction;
                    if (eh.HandlerEnd == target) eh.HandlerEnd = instruction;
                    if (eh.FilterStart == target) eh.FilterStart = instruction;
                }
            }
        }
        public void Replace(int targetIndex, Instruction instruction)
        {
            if (targetIndex > instructions.Count || targetIndex < 0)
                throw new ArgumentOutOfRangeException("target");
            if (instruction == null)
                throw new ArgumentNullException("instruction");

            Instruction target = instructions[targetIndex];
            instructions[targetIndex] = instruction;
            if (targetIndex != 0) instructions[targetIndex - 1].Next = instruction;
            if (targetIndex != instructions.Count - 1) instructions[targetIndex + 1].Previous = instruction;
            foreach (Instruction inst in instructions)
            {
                if (inst.Operand is Instruction && inst.Operand == target)
                    inst.Operand = instruction;
                else if (inst.Operand is Instruction[])
                {
                    Instruction[] s = inst.Operand as Instruction[];
                    for (int i = 0; i < s.Length; i++)
                        if (s[i] == target)
                            s[i] = instruction;
                    inst.Operand = s;
                }
            }

            if (Body.ExceptionHandlers != null)
            {
                foreach (ExceptionHandler eh in Body.ExceptionHandlers)
                {
                    if (eh.TryStart == target) eh.TryStart = instruction;
                    if (eh.TryEnd == target) eh.TryEnd = instruction;
                    if (eh.HandlerStart == target) eh.HandlerStart = instruction;
                    if (eh.HandlerEnd == target) eh.HandlerEnd = instruction;
                    if (eh.FilterStart == target) eh.FilterStart = instruction;
                }
            }
        }

        public void Remove(Instruction instruction)
        {
            if (instruction == null)
                throw new ArgumentNullException("instruction");
            instructions.Remove(instruction);
        }
        public void Remove(int targetIndex)
        {
            instructions.RemoveAt(targetIndex);
        }
    }
}


================================================
File: DeConfuser/MonoCecil/Mono.Cecil/AggressiveReflectionReader.cs
================================================
//
// AggressiveRefletionReader.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;

	using Mono.Cecil.Metadata;
	using Mono.Cecil.Signatures;

	internal sealed class AggressiveReflectionReader : ReflectionReader {

		public AggressiveReflectionReader (ModuleDefinition module) : base (module)
		{
		}

		public override void VisitTypeDefinitionCollection (TypeDefinitionCollection types)
		{
			base.VisitTypeDefinitionCollection (types);

			ReadGenericParameterConstraints ();
			ReadClassLayoutInfos ();
			ReadFieldLayoutInfos ();
			ReadPInvokeInfos ();
			ReadProperties ();
			ReadEvents ();
			ReadSemantics ();
			ReadInterfaces ();
			ReadOverrides ();
			ReadSecurityDeclarations ();
			ReadCustomAttributes ();
			ReadConstants ();
			ReadExternTypes ();
			ReadMarshalSpecs ();
			ReadInitialValues ();

			m_events = null;
			m_properties = null;
			m_parameters = null;
		}

		void ReadGenericParameterConstraints ()
		{
			if (!m_tHeap.HasTable (GenericParamConstraintTable.RId))
				return;

			GenericParamConstraintTable gpcTable = m_tableReader.GetGenericParamConstraintTable ();
			for (int i = 0; i < gpcTable.Rows.Count; i++) {
				GenericParamConstraintRow gpcRow = gpcTable [i];
				GenericParameter gp = GetGenericParameterAt (gpcRow.Owner);

				gp.Constraints.Add (GetTypeDefOrRef (gpcRow.Constraint, new GenericContext (gp.Owner)));
			}
		}

		void ReadClassLayoutInfos ()
		{
			if (!m_tHeap.HasTable (ClassLayoutTable.RId))
				return;

			ClassLayoutTable clTable = m_tableReader.GetClassLayoutTable ();
			for (int i = 0; i < clTable.Rows.Count; i++) {
				ClassLayoutRow clRow = clTable [i];
				TypeDefinition type = GetTypeDefAt (clRow.Parent);
				type.PackingSize = clRow.PackingSize;
				type.ClassSize = clRow.ClassSize;
			}
		}

		void ReadFieldLayoutInfos ()
		{
			if (!m_tHeap.HasTable (FieldLayoutTable.RId))
				return;

			FieldLayoutTable flTable = m_tableReader.GetFieldLayoutTable ();
			for (int i = 0; i < flTable.Rows.Count; i++) {
				FieldLayoutRow flRow = flTable [i];
				FieldDefinition field = GetFieldDefAt (flRow.Field);
				field.Offset = flRow.Offset;
			}
		}

		void ReadPInvokeInfos ()
		{
			if (!m_tHeap.HasTable (ImplMapTable.RId))
				return;

			ImplMapTable imTable = m_tableReader.GetImplMapTable ();
			for (int i = 0; i < imTable.Rows.Count; i++) {
				ImplMapRow imRow = imTable [i];
				if (imRow.MemberForwarded.TokenType == TokenType.Method) { // should always be true
					MethodDefinition meth = GetMethodDefAt (imRow.MemberForwarded.RID);
					meth.PInvokeInfo = new PInvokeInfo (
						meth, imRow.MappingFlags, MetadataRoot.Streams.StringsHeap [imRow.ImportName],
						Module.ModuleReferences [(int) imRow.ImportScope - 1]);
				}
			}
		}

		void ReadProperties ()
		{
			if (!m_tHeap.HasTable (PropertyTable.RId))
				return;

			PropertyTable propsTable = m_tableReader.GetPropertyTable ();
			PropertyMapTable pmapTable = m_tableReader.GetPropertyMapTable ();
			m_properties = new PropertyDefinition [propsTable.Rows.Count];
			for (int i = 0; i < pmapTable.Rows.Count; i++) {
				PropertyMapRow pmapRow = pmapTable [i];
				TypeDefinition owner = GetTypeDefAt (pmapRow.Parent);
				GenericContext context = new GenericContext (owner);

				int start = (int) pmapRow.PropertyList, end;
				if (i < pmapTable.Rows.Count - 1)
					end = (int) pmapTable [i + 1].PropertyList;
				else
					end = propsTable.Rows.Count + 1;

				for (int j = start; j < end; j++) {
					PropertyRow prow = propsTable [j - 1];
					PropertySig psig = m_sigReader.GetPropSig (prow.Type);
					PropertyDefinition pdef = new PropertyDefinition (
						m_root.Streams.StringsHeap [prow.Name],
						GetTypeRefFromSig (psig.Type, context),
					prow.Flags);
					pdef.MetadataToken = MetadataToken.FromMetadataRow (TokenType.Property, j - 1);

					if (psig.CustomMods != null && psig.CustomMods.Length > 0)
						pdef.PropertyType = GetModifierType (psig.CustomMods, pdef.PropertyType);

					owner.Properties.Add (pdef);
					m_properties [j - 1] = pdef;
				}
			}
		}

		void ReadEvents ()
		{
			if (!m_tHeap.HasTable (EventTable.RId))
				return;

			EventTable evtTable = m_tableReader.GetEventTable ();
			EventMapTable emapTable = m_tableReader.GetEventMapTable ();
			m_events = new EventDefinition [evtTable.Rows.Count];
			for (int i = 0; i < emapTable.Rows.Count; i++) {
				EventMapRow emapRow = emapTable [i];
				TypeDefinition owner = GetTypeDefAt (emapRow.Parent);
				GenericContext context = new GenericContext (owner);

				int start = (int) emapRow.EventList, end;
				if (i < (emapTable.Rows.Count - 1))
					end = (int) emapTable [i + 1].EventList;
				else
					end = evtTable.Rows.Count + 1;

				for (int j = start; j < end; j++) {
					EventRow erow = evtTable [j - 1];
					EventDefinition edef = new EventDefinition (
						m_root.Streams.StringsHeap [erow.Name],
						GetTypeDefOrRef (erow.EventType, context), erow.EventFlags);
					edef.MetadataToken = MetadataToken.FromMetadataRow (TokenType.Event, j - 1);

					owner.Events.Add (edef);
					m_events [j - 1] = edef;
				}
			}
		}

		void ReadSemantics ()
		{
			if (!m_tHeap.HasTable (MethodSemanticsTable.RId))
				return;

			MethodSemanticsTable semTable = m_tableReader.GetMethodSemanticsTable ();
			for (int i = 0; i < semTable.Rows.Count; i++) {
				MethodSemanticsRow semRow = semTable [i];
				MethodDefinition semMeth = GetMethodDefAt (semRow.Method);
				semMeth.SemanticsAttributes = semRow.Semantics;
				switch (semRow.Association.TokenType) {
				case TokenType.Event :
					EventDefinition evt = GetEventDefAt (semRow.Association.RID);
					if ((semRow.Semantics & MethodSemanticsAttributes.AddOn) != 0)
						evt.AddMethod = semMeth;
					else if ((semRow.Semantics & MethodSemanticsAttributes.Fire) != 0)
						evt.InvokeMethod = semMeth;
					else if ((semRow.Semantics & MethodSemanticsAttributes.RemoveOn) != 0)
						evt.RemoveMethod = semMeth;
					break;
				case TokenType.Property :
					PropertyDefinition prop = GetPropertyDefAt (semRow.Association.RID);
					if ((semRow.Semantics & MethodSemanticsAttributes.Getter) != 0)
						prop.GetMethod = semMeth;
					else if ((semRow.Semantics & MethodSemanticsAttributes.Setter) != 0)
						prop.SetMethod = semMeth;
					break;
				}
			}
		}

		void ReadInterfaces ()
		{
			if (!m_tHeap.HasTable (InterfaceImplTable.RId))
				return;

			InterfaceImplTable intfsTable = m_tableReader.GetInterfaceImplTable ();
			for (int i = 0; i < intfsTable.Rows.Count; i++) {
				InterfaceImplRow intfsRow = intfsTable [i];
				TypeDefinition owner = GetTypeDefAt (intfsRow.Class);
				owner.Interfaces.Add (GetTypeDefOrRef (intfsRow.Interface, new GenericContext (owner)));
			}
		}

		void ReadOverrides ()
		{
			if (!m_tHeap.HasTable (MethodImplTable.RId))
				return;

			MethodImplTable implTable = m_tableReader.GetMethodImplTable ();
			for (int i = 0; i < implTable.Rows.Count; i++) {
				MethodImplRow implRow = implTable [i];
				if (implRow.MethodBody.TokenType == TokenType.Method) {
					MethodDefinition owner = GetMethodDefAt (implRow.MethodBody.RID);
					switch (implRow.MethodDeclaration.TokenType) {
					case TokenType.Method :
						owner.Overrides.Add (
							GetMethodDefAt (implRow.MethodDeclaration.RID));
						break;
					case TokenType.MemberRef :
						owner.Overrides.Add (
							(MethodReference) GetMemberRefAt (
								implRow.MethodDeclaration.RID, new GenericContext (owner)));
						break;
					}
				}
			}
		}

		void ReadSecurityDeclarations ()
		{
			if (!m_tHeap.HasTable (DeclSecurityTable.RId))
				return;

			DeclSecurityTable dsTable = m_tableReader.GetDeclSecurityTable ();
			for (int i = 0; i < dsTable.Rows.Count; i++) {
				DeclSecurityRow dsRow = dsTable [i];
				SecurityDeclaration dec = BuildSecurityDeclaration (dsRow);

				IHasSecurity owner = null;
				switch (dsRow.Parent.TokenType) {
				case TokenType.Assembly :
					owner = this.Module.Assembly;
					break;
				case TokenType.TypeDef :
					owner = GetTypeDefAt (dsRow.Parent.RID);
					break;
				case TokenType.Method :
					owner = GetMethodDefAt (dsRow.Parent.RID);
					break;
				}

				owner.SecurityDeclarations.Add (dec);
			}
		}

		void ReadCustomAttributes ()
		{
			if (!m_tHeap.HasTable (CustomAttributeTable.RId))
				return;

			CustomAttributeTable caTable = m_tableReader.GetCustomAttributeTable ();
			for (int i = 0; i < caTable.Rows.Count; i++) {
				CustomAttributeRow caRow = caTable [i];
				MethodReference ctor;
				if (caRow.Type.TokenType == TokenType.Method)
					ctor = GetMethodDefAt (caRow.Type.RID);
				else
					ctor = GetMemberRefAt (caRow.Type.RID, new GenericContext ()) as MethodReference;

				CustomAttrib ca = m_sigReader.GetCustomAttrib (caRow.Value, ctor);
				CustomAttribute cattr;
				if (!ca.Read) {
					cattr = new CustomAttribute (ctor);
					cattr.Resolved = false;
					cattr.Blob = m_root.Streams.BlobHeap.Read (caRow.Value);
				} else
					cattr = BuildCustomAttribute (ctor, ca);

				ICustomAttributeProvider owner = null;
				switch (caRow.Parent.TokenType) {
				case TokenType.Assembly :
					owner = this.Module.Assembly;
					break;
				case TokenType.Module :
					owner = this.Module;
					break;
				case TokenType.TypeDef :
					owner = GetTypeDefAt (caRow.Parent.RID);
					break;
				case TokenType.TypeRef :
					owner = GetTypeRefAt (caRow.Parent.RID);
					break;
				case TokenType.Field :
					owner = GetFieldDefAt (caRow.Parent.RID);
					break;
				case TokenType.Method :
					owner = GetMethodDefAt (caRow.Parent.RID);
					break;
				case TokenType.Property :
					owner = GetPropertyDefAt (caRow.Parent.RID);
					break;
				case TokenType.Event :
					owner = GetEventDefAt (caRow.Parent.RID);
					break;
				case TokenType.Param :
					owner = GetParamDefAt (caRow.Parent.RID);
					break;
				case TokenType.GenericParam :
					owner = GetGenericParameterAt (caRow.Parent.RID);
					break;
				default :
					//TODO: support other ?
					break;
				}

				if (owner != null)
					owner.CustomAttributes.Add (cattr);
			}
		}

		void ReadConstants ()
		{
			if (!m_tHeap.HasTable (ConstantTable.RId))
				return;

			ConstantTable csTable = m_tableReader.GetConstantTable ();
			for (int i = 0; i < csTable.Rows.Count; i++) {
				ConstantRow csRow = csTable [i];

				object constant = GetConstant (csRow.Value, csRow.Type);

				IHasConstant owner = null;
				switch (csRow.Parent.TokenType) {
				case TokenType.Field :
					owner = GetFieldDefAt (csRow.Parent.RID);
					break;
				case TokenType.Property :
					owner = GetPropertyDefAt (csRow.Parent.RID);
					break;
				case TokenType.Param :
					owner = GetParamDefAt (csRow.Parent.RID);
					break;
				}

				owner.Constant = constant;
			}
		}

		void ReadExternTypes ()
		{
			base.VisitExternTypeCollection (Module.ExternTypes);
		}

		void ReadMarshalSpecs ()
		{
			if (!m_tHeap.HasTable (FieldMarshalTable.RId))
				return;

			FieldMarshalTable fmTable = m_tableReader.GetFieldMarshalTable ();
			for (int i = 0; i < fmTable.Rows.Count; i++) {
				FieldMarshalRow fmRow = fmTable [i];

				IHasMarshalSpec owner = null;
				switch (fmRow.Parent.TokenType) {
				case TokenType.Field:
					owner = GetFieldDefAt (fmRow.Parent.RID);
					break;
				case TokenType.Param:
					owner = GetParamDefAt (fmRow.Parent.RID);
					break;
				}

				owner.MarshalSpec = BuildMarshalDesc (
					m_sigReader.GetMarshalSig (fmRow.NativeType), owner);
			}
		}

		void ReadInitialValues ()
		{
			if (!m_tHeap.HasTable (FieldRVATable.RId))
				return;

			FieldRVATable frTable = m_tableReader.GetFieldRVATable ();
			for (int i = 0; i < frTable.Rows.Count; i++) {
				FieldRVARow frRow = frTable [i];
				FieldDefinition field = GetFieldDefAt (frRow.Field);
				field.RVA = frRow.RVA;
				SetInitialValue (field);
			}
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/ArrayDimension.cs
================================================
//
// ArrayDimension.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	public sealed class ArrayDimension {

		int m_lowerBound;
		int m_upperBound;

		public int LowerBound {
			get { return m_lowerBound; }
			set { m_lowerBound = value; }
		}

		public int UpperBound {
			get { return m_upperBound; }
			set { m_upperBound = value; }
		}

		public ArrayDimension (int lb, int ub)
		{
			m_lowerBound = lb;
			m_upperBound = ub;
		}

		public override string ToString ()
		{
			if (m_upperBound == 0)
				return string.Empty;
			return string.Concat (m_lowerBound, "...", m_upperBound);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/ArrayDimensionCollection.cs
================================================
//
// ArrayDimensionCollection.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Wed Sep 27 12:46:53 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;
	using System.Collections;

	using Mono.Cecil.Cil;

	public sealed class ArrayDimensionCollection : CollectionBase {

		ArrayType m_container;

		public ArrayDimension this [int index] {
			get { return List [index] as ArrayDimension; }
			set { List [index] = value; }
		}

		public ArrayType Container {
			get { return m_container; }
		}

		public ArrayDimensionCollection (ArrayType container)
		{
			m_container = container;
		}

		public void Add (ArrayDimension value)
		{
			List.Add (value);
		}

		public bool Contains (ArrayDimension value)
		{
			return List.Contains (value);
		}

		public int IndexOf (ArrayDimension value)
		{
			return List.IndexOf (value);
		}

		public void Insert (int index, ArrayDimension value)
		{
			List.Insert (index, value);
		}

		public void Remove (ArrayDimension value)
		{
			List.Remove (value);
		}

		protected override void OnValidate (object o)
		{
			if (! (o is ArrayDimension))
				throw new ArgumentException ("Must be of type " + typeof (ArrayDimension).FullName);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/ArrayType.cs
================================================
//
// ArrayType.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;
	using System.Text;

	using Mono.Cecil.Signatures;

	public sealed class ArrayType : TypeSpecification {

		private ArrayDimensionCollection m_dimensions;

		public ArrayDimensionCollection Dimensions {
			get { return m_dimensions; }
		}

		public int Rank {
			get { return m_dimensions.Count; }
		}

		public bool IsSizedArray {
			get {
				if (this.Rank != 1)
					return false;
				ArrayDimension dim = m_dimensions [0];
				return dim.UpperBound == 0;
			}
		}

		public override string Name {
			get { return string.Concat (base.Name, Suffix ()); }
		}

		public override string FullName {
			get { return string.Concat (base.FullName, Suffix ()); }
		}

		string Suffix ()
		{
			StringBuilder sb = new StringBuilder ();
			sb.Append ("[");
			for (int i = 0; i < m_dimensions.Count; i++) {
				ArrayDimension dim = m_dimensions [i];
				string rank = dim.ToString ();
				if (i < m_dimensions.Count - 1)
					sb.Append (",");
				if (rank.Length > 0) {
					sb.Append (" ");
					sb.Append (rank);
				}
			}
			sb.Append ("]");
			return sb.ToString ();
		}

		internal ArrayType (TypeReference elementsType, ArrayShape shape) : base (elementsType)
		{
			m_dimensions = new ArrayDimensionCollection (this);
			for (int i = 0; i < shape.Rank; i++) {
				int lower = 0, upper = 0;
				if (i < shape.NumSizes)
					if (i < shape.NumLoBounds) {
						lower = shape.LoBounds [i];
						upper = shape.LoBounds [i] + shape.Sizes [i] - 1;
					} else
						upper = shape.Sizes [i] - 1;

				m_dimensions.Add (new ArrayDimension (lower, upper));
			}
		}

		public ArrayType (TypeReference elementsType) : base (elementsType)
		{
			m_dimensions = new ArrayDimensionCollection (this);
			m_dimensions.Add (new ArrayDimension (0, 0));
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/AssemblyDefinition.cs
================================================
//
// AssemblyDefinition.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;

	using Mono.Cecil.Metadata;

	public class AssemblyDefinition : ICustomAttributeProvider,
		IHasSecurity, IReflectionStructureVisitable {

		MetadataToken m_token;
		AssemblyNameDefinition m_asmName;
		ModuleDefinitionCollection m_modules;
		SecurityDeclarationCollection m_secDecls;
		CustomAttributeCollection m_customAttrs;
		MethodDefinition m_ep;
		TargetRuntime m_runtime;
		AssemblyKind m_kind;

		ModuleDefinition m_mainModule;
		StructureReader m_reader;

		IAssemblyResolver m_resolver;

		public MetadataToken MetadataToken {
			get { return m_token; }
			set { m_token = value; }
		}

		public AssemblyNameDefinition Name {
			get { return m_asmName; }
		}

		public ModuleDefinitionCollection Modules {
			get { return m_modules; }
		}

		public SecurityDeclarationCollection SecurityDeclarations {
			get {
				if (m_secDecls == null)
					m_secDecls = new SecurityDeclarationCollection (this);

				return m_secDecls;
			}
		}

		public CustomAttributeCollection CustomAttributes {
			get {
				if (m_customAttrs == null)
					m_customAttrs = new CustomAttributeCollection (this);

				return m_customAttrs;
			}
		}

		public MethodDefinition EntryPoint {
			get { return m_ep; }
			set { m_ep = value as MethodDefinition; }
		}

		public TargetRuntime Runtime {
			get { return m_runtime; }
			set { m_runtime = value; }
		}

		public AssemblyKind Kind {
			get { return m_kind; }
			set { m_kind = value; }
		}

		public ModuleDefinition MainModule {
			get {
				if (m_mainModule == null)
					foreach (ModuleDefinition module in m_modules)
						if (module.Main)
							m_mainModule = module;

				return m_mainModule;
			}
		}

		internal StructureReader Reader {
			get { return m_reader; }
		}

		public IAssemblyResolver Resolver {
			get { return m_resolver; }
			set { m_resolver = value; }
		}

		internal AssemblyDefinition (AssemblyNameDefinition name)
		{
			if (name == null)
				throw new ArgumentNullException ("name");

			m_asmName = name;
			m_modules = new ModuleDefinitionCollection (this);
			m_resolver = new DefaultAssemblyResolver ();
		}

		internal AssemblyDefinition (AssemblyNameDefinition name, StructureReader reader) : this (name)
		{
			m_reader = reader;
		}

		public void Accept (IReflectionStructureVisitor visitor)
		{
			visitor.VisitAssemblyDefinition (this);

			m_asmName.Accept (visitor);
			m_modules.Accept (visitor);

			visitor.TerminateAssemblyDefinition (this);
		}

		public override string ToString ()
		{
			return m_asmName.FullName;
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/AssemblyFactory.cs
================================================
//
// AssemblyFactory.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;
	using System.IO;
	using SR = System.Reflection;

	using Mono.Cecil.Binary;

	public sealed class AssemblyFactory {

		AssemblyFactory ()
		{
		}

		static AssemblyDefinition GetAssembly (ImageReader irv, bool manifestOnly)
		{
			StructureReader srv = new StructureReader (irv, manifestOnly);
			AssemblyDefinition asm = new AssemblyDefinition (
				new AssemblyNameDefinition (), srv);

			asm.Accept (srv);
			return asm;
		}

		static AssemblyDefinition GetAssembly (ImageReader reader)
		{
			return GetAssembly (reader, false);
		}

		static AssemblyDefinition GetAssemblyManifest (ImageReader reader)
		{
			return GetAssembly (reader, true);
		}

		public static AssemblyDefinition GetAssembly (string file)
		{
			return GetAssembly (ImageReader.Read (file));
		}

		public static AssemblyDefinition GetAssembly (byte [] assembly)
		{
			return GetAssembly (ImageReader.Read (assembly));
		}

		public static AssemblyDefinition GetAssembly (Stream stream)
		{
			return GetAssembly (ImageReader.Read (stream));
		}

		public static AssemblyDefinition GetAssemblyManifest (string file)
		{
			return GetAssemblyManifest (ImageReader.Read (file));
		}

		public static AssemblyDefinition GetAssemblyManifest (byte [] assembly)
		{
			return GetAssemblyManifest (ImageReader.Read (assembly));
		}

		public static AssemblyDefinition GetAssemblyManifest (Stream stream)
		{
			return GetAssemblyManifest (ImageReader.Read (stream));
		}

		static TargetRuntime CurrentRuntime ()
		{
			Version corlib = typeof (object).Assembly.GetName ().Version;
			if (corlib.Major == 1)
				return corlib.Minor == 0 ? TargetRuntime.NET_1_0 : TargetRuntime.NET_1_1;
			else // if (corlib.Major == 2)
				return TargetRuntime.NET_2_0;
		}

		public static AssemblyDefinition DefineAssembly (string name, AssemblyKind kind)
		{
			return DefineAssembly (name, name, CurrentRuntime (), kind);
		}

		public static AssemblyDefinition DefineAssembly (string name, TargetRuntime rt, AssemblyKind kind)
		{
			return DefineAssembly (name, name, rt, kind);
		}

		public static AssemblyDefinition DefineAssembly (string assemblyName, string moduleName, TargetRuntime rt, AssemblyKind kind)
		{
			AssemblyNameDefinition asmName = new AssemblyNameDefinition ();
			asmName.Name = assemblyName;
			AssemblyDefinition asm = new AssemblyDefinition (asmName);
			asm.Runtime = rt;
			asm.Kind = kind;
			ModuleDefinition main = new ModuleDefinition (moduleName, asm, true);
			asm.Modules.Add (main);
			return asm;
		}

		static void WriteAssembly (AssemblyDefinition asm, BinaryWriter bw)
		{
			asm.Accept (new StructureWriter (asm, bw));
		}

		public static void SaveAssembly (AssemblyDefinition asm, string file)
		{
			using (FileStream fs = new FileStream (
				file, FileMode.Create, FileAccess.Write, FileShare.None)) {

				SaveAssembly (asm, fs);
			}
		}

		public static void SaveAssembly (AssemblyDefinition asm, out byte [] assembly)
		{
			MemoryBinaryWriter bw = new MemoryBinaryWriter ();
			SaveAssembly (asm, bw.BaseStream);
			assembly = bw.ToArray ();
		}

		public static void SaveAssembly (AssemblyDefinition asm, Stream stream)
		{
			BinaryWriter bw = new BinaryWriter (stream);
			try {
				WriteAssembly (asm, bw);
			} finally {
				bw.Close ();
			}

			foreach (ModuleDefinition module in asm.Modules)
				if (module.Controller.Writer.SaveSymbols)
					module.Controller.Writer.WriteSymbols (module);
		}

#if !CF_1_0 && !CF_2_0
		public static SR.Assembly CreateReflectionAssembly (AssemblyDefinition asm, AppDomain domain)
		{
			using (MemoryBinaryWriter writer = new MemoryBinaryWriter ()) {

				WriteAssembly (asm, writer);
				return domain.Load (writer.ToArray ());
			}
		}

		public static SR.Assembly CreateReflectionAssembly (AssemblyDefinition asm)
		{
			return CreateReflectionAssembly (asm, AppDomain.CurrentDomain);
		}
#endif
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/AssemblyFlags.cs
================================================
//
// AssemblyFlags.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;

	[Flags]
	public enum AssemblyFlags : uint {
		PublicKey					 	= 0x0001,
		SideBySideCompatible			= 0x0000,
		Retargetable					= 0x0100,
		EnableJITcompileTracking		= 0x8000,
		DisableJITcompileOptimizer	  	= 0x4000
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/AssemblyHashAlgorithm.cs
================================================
//
// AssemblyHashAlgorithm.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	public enum AssemblyHashAlgorithm : uint {
		None		= 0x0000,
		Reserved	= 0x8003,	// MD5
		SHA1		= 0x8004
	}
}




================================================
File: DeConfuser/MonoCecil/Mono.Cecil/AssemblyKind.cs
================================================
//
// AssemblyKind.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	public enum AssemblyKind {
		Dll,
		Console,
		Windows
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/AssemblyLinkedResource.cs
================================================
//
// AssemblyLinkedResource.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	public sealed class AssemblyLinkedResource : Resource {

		private AssemblyNameReference m_asmRef;

		public AssemblyNameReference Assembly {
			get { return m_asmRef; }
			set { m_asmRef = value; }
		}

		public AssemblyLinkedResource (string name, ManifestResourceAttributes flags,
			AssemblyNameReference asmRef) : base (name, flags)
		{
			m_asmRef = asmRef;
		}

		public override void Accept (IReflectionStructureVisitor visitor)
		{
			visitor.VisitAssemblyLinkedResource (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/AssemblyNameDefinition.cs
================================================
//
// AssemblyNameDefinition.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;

	public sealed class AssemblyNameDefinition : AssemblyNameReference {

		public override byte [] Hash {
			get { return new byte [0]; }
		}

		public AssemblyNameDefinition () : base()
		{
		}

		public AssemblyNameDefinition (string name, string culture, Version version) : base (name, culture, version)
		{
		}

		public override void Accept (IReflectionStructureVisitor visitor)
		{
			visitor.VisitAssemblyNameDefinition (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/AssemblyNameReference.cs
================================================
//
// AssemblyNameReference.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;
	using System.Globalization;
	using System.Security.Cryptography;
	using System.Text;

	using Mono.Cecil.Metadata;

	public class AssemblyNameReference : IMetadataScope, IReflectionStructureVisitable {

		string m_name;
		string m_culture;
		Version m_version;
		AssemblyFlags m_flags;
		byte [] m_publicKey;
		byte [] m_publicKeyToken;
		AssemblyHashAlgorithm m_hashAlgo;
		byte [] m_hash;
		MetadataToken m_token;

		public string Name {
			get { return m_name; }
			set { m_name = value; }
		}

		public string Culture {
			get { return m_culture; }
			set { m_culture = value; }
		}

		public Version Version {
			get { return m_version; }
			set { m_version = value; }
		}

		public AssemblyFlags Flags {
			get { return m_flags; }
			set { m_flags = value; }
		}

		public byte [] PublicKey {
			get { return m_publicKey; }
			set {
				m_publicKey = value;
				m_publicKeyToken = null;
			}
		}

		public byte [] PublicKeyToken {
			get {
#if !CF_1_0 && !CF_2_0
				if ((m_publicKeyToken == null || m_publicKeyToken.Length == 0) && (m_publicKey != null && m_publicKey.Length > 0)) {
					HashAlgorithm ha = null;
					switch (m_hashAlgo) {
					case AssemblyHashAlgorithm.Reserved:
						ha = MD5.Create (); break;
					default:
						// None default to SHA1
						ha = SHA1.Create (); break;
					}
					byte[] hash = ha.ComputeHash (m_publicKey);
					// we need the last 8 bytes in reverse order
					m_publicKeyToken = new byte [8];
					Array.Copy (hash, (hash.Length - 8), m_publicKeyToken, 0, 8);
					Array.Reverse (m_publicKeyToken, 0, 8);
				}
#endif
				return m_publicKeyToken;
			}
			set { m_publicKeyToken = value; }
		}

		public string FullName {
			get {
				StringBuilder sb = new StringBuilder ();
				string sep = ", ";
				sb.Append (m_name);
				if (m_version != null) {
					sb.Append (sep);
					sb.Append ("Version=");
					sb.Append (m_version.ToString ());
				}
				sb.Append (sep);
				sb.Append ("Culture=");
				sb.Append (m_culture == string.Empty ? "neutral" : m_culture);
				sb.Append (sep);
				sb.Append ("PublicKeyToken=");
				if (this.PublicKeyToken != null && m_publicKeyToken.Length > 0) {
					for (int i = 0 ; i < m_publicKeyToken.Length ; i++) {
						sb.Append (m_publicKeyToken [i].ToString ("x2"));
					}
				} else {
					sb.Append ("null");
				}
				return sb.ToString ();
			}
		}

		public static AssemblyNameReference Parse (string fullName)
		{
			if (fullName == null)
				throw new ArgumentNullException ("fullName");
			if (fullName.Length == 0)
				throw new ArgumentException ("Name can not be empty");

			AssemblyNameReference name = new AssemblyNameReference ();
			string [] tokens = fullName.Split (',');
			for (int i = 0; i < tokens.Length; i++) {
				string token = tokens [i].Trim ();

				if (i == 0) {
					name.Name = token;
					continue;
				}

				string [] parts = token.Split ('=');
				if (parts.Length != 2)
					throw new ArgumentException ("Malformed name");

				switch (parts [0]) {
				case "Version":
					name.Version = new Version (parts [1]);
					break;
				case "Culture":
					name.Culture = parts [1];
					break;
				case "PublicKeyToken":
					string pkToken = parts [1];
					if (pkToken == "null")
						break;

					name.PublicKeyToken = new byte [pkToken.Length / 2];
					for (int j = 0; j < name.PublicKeyToken.Length; j++) {
						name.PublicKeyToken [j] = Byte.Parse (pkToken.Substring (j * 2, 2), NumberStyles.HexNumber);
					}
					break;
				}
			}

			return name;
		}

		public AssemblyHashAlgorithm HashAlgorithm
		{
			get { return m_hashAlgo; }
			set { m_hashAlgo = value; }
		}

		public virtual byte [] Hash {
			get { return m_hash; }
			set { m_hash = value; }
		}

		public MetadataToken MetadataToken {
			get { return m_token; }
			set { m_token = value; }
		}

		public AssemblyNameReference () : this (string.Empty, string.Empty, new Version (0, 0, 0, 0))
		{
		}

		public AssemblyNameReference (string name, string culture, Version version)
		{
			if (name == null)
				throw new ArgumentNullException ("name");
			if (culture == null)
				throw new ArgumentNullException ("culture");
			m_name = name;
			m_culture = culture;
			m_version = version;
			m_hashAlgo = AssemblyHashAlgorithm.None;
		}

		public override string ToString ()
		{
			return this.FullName;
		}

		public virtual void Accept (IReflectionStructureVisitor visitor)
		{
			visitor.VisitAssemblyNameReference (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/AssemblyNameReferenceCollection.cs
================================================
//
// AssemblyNameReferenceCollection.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Wed Sep 27 12:46:52 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;
	using System.Collections;

	using Mono.Cecil.Cil;

	public sealed class AssemblyNameReferenceCollection : CollectionBase, IReflectionStructureVisitable {

		ModuleDefinition m_container;

		public AssemblyNameReference this [int index] {
			get { return List [index] as AssemblyNameReference; }
			set { List [index] = value; }
		}

		public ModuleDefinition Container {
			get { return m_container; }
		}

		public AssemblyNameReferenceCollection (ModuleDefinition container)
		{
			m_container = container;
		}

		public void Add (AssemblyNameReference value)
		{
			List.Add (value);
		}

		public bool Contains (AssemblyNameReference value)
		{
			return List.Contains (value);
		}

		public int IndexOf (AssemblyNameReference value)
		{
			return List.IndexOf (value);
		}

		public void Insert (int index, AssemblyNameReference value)
		{
			List.Insert (index, value);
		}

		public void Remove (AssemblyNameReference value)
		{
			List.Remove (value);
		}

		protected override void OnValidate (object o)
		{
			if (! (o is AssemblyNameReference))
				throw new ArgumentException ("Must be of type " + typeof (AssemblyNameReference).FullName);
		}

		public void Accept (IReflectionStructureVisitor visitor)
		{
			visitor.VisitAssemblyNameReferenceCollection (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/BaseAssemblyResolver.cs
================================================
//
// BaseAssemblyResolver.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;
	using System.IO;
	using SR = System.Reflection;
	using System.Text;

	public abstract class BaseAssemblyResolver : IAssemblyResolver {

		public virtual AssemblyDefinition Resolve (string fullName)
		{
			return Resolve (AssemblyNameReference.Parse (fullName));
		}

		public virtual AssemblyDefinition Resolve (AssemblyNameReference name)
		{
			string [] exts = new string [] { ".dll", ".exe" };
			string [] dirs = new string [] { ".", "bin" };

			foreach (string dir in dirs) {
				foreach (string ext in exts) {
					string file = Path.Combine (dir, name.Name + ext);
					if (File.Exists (file))
						return AssemblyFactory.GetAssembly (file);
				}
			}

#if !CF_1_0 && !CF_2_0
			if (name.Name == "mscorlib")
				return GetCorlib (name);

			AssemblyDefinition asm = GetAssemblyInGac (name);
			if (asm != null)
				return asm;
#endif

			throw new FileNotFoundException ("Could not resolve: " + name);
		}

#if !CF_1_0 && !CF_2_0
		AssemblyDefinition GetCorlib (AssemblyNameReference reference)
		{
			SR.AssemblyName corlib = typeof (object).Assembly.GetName ();
			if (corlib.Version == reference.Version)
				return AssemblyFactory.GetAssembly (typeof (object).Module.FullyQualifiedName);

			string path = Directory.GetParent (
				Directory.GetParent (
					typeof (object).Module.FullyQualifiedName).FullName
				).FullName;

			if (OnMono ()) {
				if (reference.Version.Major == 1)
					path = Path.Combine (path, "1.0");
				else if (reference.Version.Major == 2)
					path = Path.Combine (path, "2.0");
				else
					throw new NotSupportedException ("Version not supported: " + reference.Version);
			} else {
				if (reference.Version.ToString () == "1.0.3300.0")
					path = Path.Combine (path, "v1.0.3705");
				else if (reference.Version.ToString () == "1.0.5000.0")
					path = Path.Combine (path, "v1.1.4322");
				else if (reference.Version.ToString () == "2.0.0.0")
					path = Path.Combine (path, "v2.0.50727");
				else
					throw new NotSupportedException ("Version not supported: " + reference.Version);
			}

			return AssemblyFactory.GetAssembly (Path.Combine (path, "mscorlib.dll"));
		}

		public static bool OnMono ()
		{
			return typeof (object).Assembly.GetType ("System.MonoType", false) != null;
		}

		static AssemblyDefinition GetAssemblyInGac (AssemblyNameReference reference)
		{
			if (reference.PublicKeyToken == null || reference.PublicKeyToken.Length == 0)
				return null;

			string currentGac = GetCurrentGacPath ();
			if (OnMono ()) {
				string s = GetAssemblyFile (reference, currentGac);
				if (File.Exists (s))
					return AssemblyFactory.GetAssembly (s);
			} else {
				string [] gacs = new string [] {"GAC_MSIL", "GAC_32", "GAC"};
				for (int i = 0; i < gacs.Length; i++) {
					string gac = Path.Combine (Directory.GetParent (currentGac).FullName, gacs [i]);
					string asm = GetAssemblyFile (reference, gac);
					if (Directory.Exists (gac) && File.Exists (asm))
						return AssemblyFactory.GetAssembly (asm);
				}
			}

			return null;
		}

		static string GetAssemblyFile (AssemblyNameReference reference, string gac)
		{
			StringBuilder sb = new StringBuilder ();
			sb.Append (reference.Version);
			sb.Append ("__");
			for (int i = 0; i < reference.PublicKeyToken.Length; i++)
				sb.Append (reference.PublicKeyToken [i].ToString ("x2"));

			return Path.Combine (
				Path.Combine (
					Path.Combine (gac, reference.Name), sb.ToString ()),
					string.Concat (reference.Name, ".dll"));
		}

		static string GetCurrentGacPath ()
		{
			return Directory.GetParent (
				Directory.GetParent (
					Path.GetDirectoryName (
						typeof (Uri).Module.FullyQualifiedName)
					).FullName
				).FullName;
		}
#endif
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/BaseReflectionReader.cs
================================================
//
// BaseReflectionReader.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	internal abstract class BaseReflectionReader : BaseReflectionVisitor, IDetailReader {

		public virtual void ReadSemantic (EventDefinition evt)
		{
		}

		public virtual void ReadSemantic (PropertyDefinition prop)
		{
		}

		public virtual void ReadMarshalSpec (ParameterDefinition param)
		{
		}

		public virtual void ReadMarshalSpec (FieldDefinition field)
		{
		}

		public virtual void ReadLayout (TypeDefinition type)
		{
		}

		public virtual void ReadLayout (FieldDefinition field)
		{
		}

		public virtual void ReadConstant (FieldDefinition field)
		{
		}

		public virtual void ReadConstant (PropertyDefinition prop)
		{
		}

		public virtual void ReadConstant (ParameterDefinition param)
		{
		}

		public virtual void ReadInitialValue (FieldDefinition field)
		{
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/BaseReflectionVisitor.cs
================================================
//
// BaseReflectionVisitor.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System.Collections;

	public abstract class BaseReflectionVisitor : IReflectionVisitor {

		public virtual void VisitModuleDefinition (ModuleDefinition module)
		{
		}

		public virtual void VisitTypeDefinitionCollection (TypeDefinitionCollection types)
		{
		}

		public virtual void VisitTypeDefinition (TypeDefinition type)
		{
		}

		public virtual void VisitTypeReferenceCollection (TypeReferenceCollection refs)
		{
		}

		public virtual void VisitTypeReference (TypeReference type)
		{
		}

		public virtual void VisitMemberReferenceCollection (MemberReferenceCollection members)
		{
		}

		public virtual void VisitMemberReference (MemberReference member)
		{
		}

		public virtual void VisitInterfaceCollection (InterfaceCollection interfaces)
		{
		}

		public virtual void VisitInterface (TypeReference interf)
		{
		}

		public virtual void VisitExternTypeCollection (ExternTypeCollection externs)
		{
		}

		public virtual void VisitExternType (TypeReference externType)
		{
		}

		public virtual void VisitOverrideCollection (OverrideCollection meth)
		{
		}

		public virtual void VisitOverride (MethodReference ov)
		{
		}

		public virtual void VisitNestedTypeCollection (NestedTypeCollection nestedTypes)
		{
		}

		public virtual void VisitNestedType (TypeDefinition nestedType)
		{
		}

		public virtual void VisitParameterDefinitionCollection (ParameterDefinitionCollection parameters)
		{
		}

		public virtual void VisitParameterDefinition (ParameterDefinition parameter)
		{
		}

		public virtual void VisitMethodDefinitionCollection (MethodDefinitionCollection methods)
		{
		}

		public virtual void VisitMethodDefinition (MethodDefinition method)
		{
		}

		public virtual void VisitConstructorCollection (ConstructorCollection ctors)
		{
		}

		public virtual void VisitConstructor (MethodDefinition ctor)
		{
		}

		public virtual void VisitPInvokeInfo (PInvokeInfo pinvk)
		{
		}

		public virtual void VisitEventDefinitionCollection (EventDefinitionCollection events)
		{
		}

		public virtual void VisitEventDefinition (EventDefinition evt)
		{
		}

		public virtual void VisitFieldDefinitionCollection (FieldDefinitionCollection fields)
		{
		}

		public virtual void VisitFieldDefinition (FieldDefinition field)
		{
		}

		public virtual void VisitPropertyDefinitionCollection (PropertyDefinitionCollection properties)
		{
		}

		public virtual void VisitPropertyDefinition (PropertyDefinition property)
		{
		}

		public virtual void VisitSecurityDeclarationCollection (SecurityDeclarationCollection secDecls)
		{
		}

		public virtual void VisitSecurityDeclaration (SecurityDeclaration secDecl)
		{
		}

		public virtual void VisitCustomAttributeCollection (CustomAttributeCollection customAttrs)
		{
		}

		public virtual void VisitCustomAttribute (CustomAttribute customAttr)
		{
		}

		public virtual void VisitGenericParameterCollection (GenericParameterCollection genparams)
		{
		}

		public virtual void VisitGenericParameter (GenericParameter genparam)
		{
		}

		public virtual void VisitMarshalSpec (MarshalSpec marshalSpec)
		{
		}

		public virtual void TerminateModuleDefinition (ModuleDefinition module)
		{
		}

		protected void VisitCollection (ICollection coll)
		{
			if (coll.Count == 0)
				return;

			foreach (IReflectionVisitable visitable in coll)
				visitable.Accept (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/BaseStructureVisitor.cs
================================================
//
// BaseStructureVisitor.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System.Collections;

	public abstract class BaseStructureVisitor : IReflectionStructureVisitor {

		public virtual void VisitAssemblyDefinition (AssemblyDefinition asm)
		{
		}

		public virtual void VisitAssemblyNameDefinition (AssemblyNameDefinition name)
		{
		}

		public virtual void VisitAssemblyNameReferenceCollection (AssemblyNameReferenceCollection names)
		{
		}

		public virtual void VisitAssemblyNameReference (AssemblyNameReference name)
		{
		}

		public virtual void VisitResourceCollection (ResourceCollection resources)
		{
		}

		public virtual void VisitEmbeddedResource (EmbeddedResource res)
		{
		}

		public virtual void VisitLinkedResource (LinkedResource res)
		{
		}

		public virtual void VisitAssemblyLinkedResource (AssemblyLinkedResource res)
		{
		}

		public virtual void VisitModuleDefinition (ModuleDefinition module)
		{
		}

		public virtual void VisitModuleDefinitionCollection (ModuleDefinitionCollection modules)
		{
		}

		public virtual void VisitModuleReference (ModuleReference module)
		{
		}

		public virtual void VisitModuleReferenceCollection (ModuleReferenceCollection modules)
		{
		}

		public virtual void TerminateAssemblyDefinition (AssemblyDefinition asm)
		{
		}

		protected void VisitCollection (ICollection coll)
		{
			if (coll.Count == 0)
				return;

			foreach (IReflectionStructureVisitable visitable in coll)
				visitable.Accept (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/CallSite.cs
================================================
//
// CallSite.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 - 2007 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System.Text;

	using Mono.Cecil.Metadata;

	public sealed class CallSite : IMethodSignature, IMetadataTokenProvider {

		MethodReference m_function;

		public bool HasThis {
			get { return m_function.HasThis; }
			set { m_function.HasThis = value; }
		}

		public bool ExplicitThis {
			get { return m_function.ExplicitThis; }
			set { m_function.ExplicitThis = value; }
		}

		public MethodCallingConvention CallingConvention {
			get { return m_function.CallingConvention; }
			set { m_function.CallingConvention = value; }
		}

		public ParameterDefinitionCollection Parameters {
			get { return m_function.Parameters; }
		}

		public MethodReturnType ReturnType {
			get { return m_function.ReturnType; }
			set { m_function.ReturnType = value; }
		}

		public MetadataToken MetadataToken {
			get { return m_function.MetadataToken; }
			set { m_function.MetadataToken = value; }
		}

		public CallSite (bool hasThis, bool explicitThis, MethodCallingConvention callConv, MethodReturnType retType)
		{
			m_function = new MethodReference (string.Empty, hasThis, explicitThis, callConv);
			m_function.ReturnType = retType;
		}

		public int GetSentinel ()
		{
			return m_function.GetSentinel ();
		}

		public override string ToString ()
		{
			StringBuilder sb = new StringBuilder ();
			sb.Append (m_function.ReturnType.ReturnType.FullName);
			sb.Append ("(");
			for (int i = 0; i < m_function.Parameters.Count; i++) {
				if (i > 0)
					sb.Append (",");
				sb.Append (m_function.Parameters [i].ParameterType.FullName);
			}
			sb.Append (")");
			return sb.ToString ();
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/CompactFrameworkCompatibility.cs
================================================
//
// FrameworkCompatibility.cs
//
// Author:
//   Rodrigo B. de Oliveira (rodrigobamboo@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
#if CF_1_0
namespace System {

	internal class NotImplementedException : System.Exception {

		public NotImplementedException (string message) : base (message)
		{
		}

		public NotImplementedException ()
		{
		}
	}
}
#endif

#if CF_1_0 || CF_2_0
namespace System.Security {

	public class SecurityElement 	{

		public SecurityElement (string tag)
		{
		}

		public string Text
		{
			get { return string.Empty; }
			set {}
		}

		public void AddChild (SecurityElement child)
		{
		}

		public void AddAttribute (string name, string value)
		{
		}
	}
}
#endif



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/Constants.cs
================================================
//
// Constants.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	public class Constants {

		Constants ()
		{
		}

		public const string Corlib = "mscorlib";

		public const string ModuleType = "<Module>";
		public const string PrivateImplDetails = "<PrivateImplementationDetails>";

		public const string Void = "System.Void";
		public const string Object = "System.Object";
		public const string String = "System.String";
		public const string Boolean = "System.Boolean";
		public const string Char = "System.Char";
		public const string Single = "System.Single";
		public const string Double = "System.Double";
		public const string SByte = "System.SByte";
		public const string Byte = "System.Byte";
		public const string Int16 = "System.Int16";
		public const string UInt16 = "System.UInt16";
		public const string Int32 = "System.Int32";
		public const string UInt32 = "System.UInt32";
		public const string Int64 = "System.Int64";
		public const string UInt64 = "System.UInt64";
		public const string IntPtr = "System.IntPtr";
		public const string UIntPtr = "System.UIntPtr";
		public const string TypedReference = "System.TypedReference";
		public const string Type = "System.Type";
		public const string ValueType = "System.ValueType";
		public const string Enum = "System.Enum";
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/ConstraintCollection.cs
================================================
//
// ConstraintCollection.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Wed Sep 27 12:46:54 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;
	using System.Collections;

	using Mono.Cecil.Cil;

	public sealed class ConstraintCollection : CollectionBase {

		GenericParameter m_container;

		public TypeReference this [int index] {
			get { return List [index] as TypeReference; }
			set { List [index] = value; }
		}

		public GenericParameter Container {
			get { return m_container; }
		}

		public ConstraintCollection (GenericParameter container)
		{
			m_container = container;
		}

		public void Add (TypeReference value)
		{
			List.Add (value);
		}

		public bool Contains (TypeReference value)
		{
			return List.Contains (value);
		}

		public int IndexOf (TypeReference value)
		{
			return List.IndexOf (value);
		}

		public void Insert (int index, TypeReference value)
		{
			List.Insert (index, value);
		}

		public void Remove (TypeReference value)
		{
			List.Remove (value);
		}

		protected override void OnValidate (object o)
		{
			if (! (o is TypeReference))
				throw new ArgumentException ("Must be of type " + typeof (TypeReference).FullName);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/ConstructorCollection.cs
================================================
//
// ConstructorCollection.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Thu Sep 28 17:54:19 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;
	using System.Collections;

	using Mono.Cecil.Cil;

	public sealed class ConstructorCollection : CollectionBase, IReflectionVisitable {

		TypeDefinition m_container;

		public MethodDefinition this [int index] {
			get { return List [index] as MethodDefinition; }
			set { List [index] = value; }
		}

		public TypeDefinition Container {
			get { return m_container; }
		}

		public ConstructorCollection (TypeDefinition container)
		{
			m_container = container;
		}

		public void Add (MethodDefinition value)
		{
			if (!Contains (value))
				Attach (value);

			List.Add (value);
		}


		public new void Clear ()
		{
			foreach (MethodDefinition item in this)
				Detach (item);

			base.Clear ();
		}

		public bool Contains (MethodDefinition value)
		{
			return List.Contains (value);
		}

		public int IndexOf (MethodDefinition value)
		{
			return List.IndexOf (value);
		}

		public void Insert (int index, MethodDefinition value)
		{
			if (!this.Contains (value))
				Attach (value);

			List.Insert (index, value);
		}

		public void Remove (MethodDefinition value)
		{
			if (this.Contains (value))
				Detach (value);

			List.Remove (value);
		}


		public new void RemoveAt (int index)
		{
			Detach (this [index]);

			List.RemoveAt (index);
		}

		protected override void OnValidate (object o)
		{
			if (! (o is MethodDefinition))
				throw new ArgumentException ("Must be of type " + typeof (MethodDefinition).FullName);
		}

		internal MethodDefinition GetConstructorInternal (bool isStatic, IList parameters)
		{
			foreach (MethodDefinition ctor in this) {
				if (ctor.IsStatic != isStatic || ctor.Parameters.Count != parameters.Count)
					continue;

				bool match = true;
				for (int i = 0; i < parameters.Count; i++) {
					string pname;
					object param = parameters [i];
					if (param is Type)
						pname = ReflectionHelper.GetTypeSignature (param as Type);
					else if (param is TypeReference)
						pname = (param as TypeReference).FullName;
					else if (param is ParameterDefinition)
						pname = (param as ParameterDefinition).ParameterType.FullName;
					else
						throw new NotSupportedException ();

					if (ctor.Parameters [i].ParameterType.FullName != pname) {
						match = false;
						break;
					}
				}

				if (match)
					return ctor;
			}

			return null;
		}

		public MethodDefinition GetConstructor (bool isStatic, Type [] parameters)
		{
			return GetConstructorInternal (isStatic, parameters);
		}

		public MethodDefinition GetConstructor (bool isStatic, TypeReference [] parameters)
		{
			return GetConstructorInternal (isStatic, parameters);
		}

		public MethodDefinition GetConstructor (bool isStatic, ParameterDefinitionCollection parameters)
		{
			return GetConstructorInternal (isStatic, parameters);
		}

		void Attach (MemberReference member)
		{
			if (member.DeclaringType != null)
				throw new ReflectionException ("Member already attached, clone it instead");

			member.DeclaringType = m_container;
		}

		void Detach (MemberReference member)
		{
			member.DeclaringType = null;
		}

		public void Accept (IReflectionVisitor visitor)
		{
			visitor.VisitConstructorCollection (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/CustomAttribute.cs
================================================
//
// CustomAttribute.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;
	using System.Collections;

	public sealed class CustomAttribute : IRequireResolving, IReflectionVisitable {

		MethodReference m_ctor;
		IList m_parameters;
		IDictionary m_fields;
		IDictionary m_properties;
		IDictionary m_fieldTypes;
		IDictionary m_propTypes;

		bool m_resolved;
		byte [] m_blob;

		public MethodReference Constructor {
			get { return m_ctor; }
			set { m_ctor = value; }
		}

		public IList ConstructorParameters {
			get {
				if (m_parameters == null)
					m_parameters = new ArrayList ();
				return m_parameters;
			}
		}

		public IDictionary Fields {
			get {
				if (m_fields == null)
					m_fields = new Hashtable ();

				return m_fields;
			}
		}

		public IDictionary Properties {
			get {
				if (m_properties == null)
					m_properties = new Hashtable ();

				return m_properties;
			}
		}

		internal IDictionary FieldTypes {
			get {
				if (m_fieldTypes == null)
					m_fieldTypes = new Hashtable ();

				return m_fieldTypes;
			}
		}

		internal IDictionary PropertyTypes {
			get {
				if (m_propTypes == null)
					m_propTypes = new Hashtable ();

				return m_propTypes;
			}
		}

		public bool Resolved {
			get { return m_resolved; }
			set { m_resolved = value; }
		}

		public byte [] Blob {
			get { return m_blob; }
			set { m_blob = value; }
		}

		public CustomAttribute (MethodReference ctor)
		{
			m_ctor = ctor;
			m_resolved = true;
		}

		public TypeReference GetFieldType (string fieldName)
		{
			return (TypeReference) FieldTypes [fieldName];
		}

		public TypeReference GetPropertyType (string propertyName)
		{
			return (TypeReference) PropertyTypes [propertyName];
		}

		public void SetFieldType (string fieldName, TypeReference type)
		{
			FieldTypes [fieldName] = type;
		}

		public void SetPropertyType (string propertyName, TypeReference type)
		{
			PropertyTypes [propertyName] = type;
		}

		public CustomAttribute Clone ()
		{
			return Clone (this, new ImportContext ());
		}

		static void Clone (IDictionary original, IDictionary target)
		{
			target.Clear ();
			foreach (DictionaryEntry entry in original)
				target.Add (entry.Key, entry.Value);
		}

		internal static CustomAttribute Clone (CustomAttribute custattr, ImportContext context)
		{
			CustomAttribute ca = new CustomAttribute (context.Import (custattr.Constructor));
			custattr.CopyTo (ca);
			return ca;
		}

		void CopyTo (CustomAttribute target)
		{
			target.Resolved = Resolved;
			if (!Resolved) {
				target.Blob = Blob;
				return;
			}

			foreach (object o in ConstructorParameters)
				target.ConstructorParameters.Add (o);
			Clone (Fields, target.Fields);
			Clone (FieldTypes, target.FieldTypes);
			Clone (Properties, target.Properties);
			Clone (PropertyTypes, target.PropertyTypes);
		}

		public bool Resolve ()
		{
			if (Resolved)
				return true;

			ReflectionReader r = m_ctor.DeclaringType.Module.Controller.Reader;
			CustomAttribute newCa = r.GetCustomAttribute (m_ctor, Blob, true);
			if (!newCa.Resolved)
				return false;

			newCa.CopyTo (this);
			return true;
		}

		public void Accept (IReflectionVisitor visitor)
		{
			visitor.VisitCustomAttribute (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/CustomAttributeCollection.cs
================================================
//
// CustomAttributeCollection.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Wed Sep 27 12:46:53 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;
	using System.Collections;

	using Mono.Cecil.Cil;

	public sealed class CustomAttributeCollection : CollectionBase, IReflectionVisitable {

		ICustomAttributeProvider m_container;

		public CustomAttribute this [int index] {
			get { return List [index] as CustomAttribute; }
			set { List [index] = value; }
		}

		public ICustomAttributeProvider Container {
			get { return m_container; }
		}

		public CustomAttributeCollection (ICustomAttributeProvider container)
		{
			m_container = container;
		}

        public void Add(CustomAttribute value)
        {
            List.Add(value);
        }
        public void AddRange(CustomAttributeCollection value)
        {
            foreach (CustomAttribute attr in value)
                Add(attr);
        }
        public void AddRange(CustomAttribute[] value)
        {
            foreach (CustomAttribute attr in value)
                Add(attr);
        }

		public bool Contains (CustomAttribute value)
		{
			return List.Contains (value);
		}

		public int IndexOf (CustomAttribute value)
		{
			return List.IndexOf (value);
		}

		public void Insert (int index, CustomAttribute value)
		{
			List.Insert (index, value);
		}

		public void Remove (CustomAttribute value)
		{
			List.Remove (value);
		}

		protected override void OnValidate (object o)
		{
			if (! (o is CustomAttribute))
				throw new ArgumentException ("Must be of type " + typeof (CustomAttribute).FullName);
		}

		public void Accept (IReflectionVisitor visitor)
		{
			visitor.VisitCustomAttributeCollection (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/DefaultAssemblyResolver.cs
================================================
//
// DefaultAssemblyResolver.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System.Collections;

	public class DefaultAssemblyResolver : BaseAssemblyResolver {

		IDictionary m_cache;

		public DefaultAssemblyResolver ()
		{
			m_cache = new Hashtable ();
		}

		public override AssemblyDefinition Resolve (AssemblyNameReference name)
		{
			AssemblyDefinition asm = (AssemblyDefinition) m_cache [name.FullName];
			if (asm == null) {
				asm = base.Resolve (name);
				m_cache [name.FullName] = asm;
			}

			return asm;
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/EmbeddedResource.cs
================================================
//
// EmbeddedResource.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	public sealed class EmbeddedResource : Resource {

		byte [] m_data;

		public byte [] Data {
			get { return m_data; }
			set { m_data = value; }
		}

		public EmbeddedResource (string name, ManifestResourceAttributes flags) :
			base (name, flags)
		{
		}

		public EmbeddedResource (string name, ManifestResourceAttributes flags, byte [] data) :
			base (name, flags)
		{
			m_data = data;
		}

		public override void Accept (IReflectionStructureVisitor visitor)
		{
			visitor.VisitEmbeddedResource (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/EventAttributes.cs
================================================
//
// EventAttributes.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;

	[Flags]
	public enum EventAttributes : ushort {
		SpecialName		= 0x0200,	// Event is special
		RTSpecialName	= 0x0400	 // CLI provides 'special' behavior, depending upon the name of the event
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/EventDefinition.cs
================================================
//
// EventDefinition.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;

	public sealed class EventDefinition : EventReference, IMemberDefinition, ICustomAttributeProvider {

		EventAttributes m_attributes;

		CustomAttributeCollection m_customAttrs;

		MethodDefinition m_addMeth;
		MethodDefinition m_invMeth;
		MethodDefinition m_remMeth;

		public EventAttributes Attributes {
			get { return m_attributes; }
			set { m_attributes = value; }
		}

		public MethodDefinition AddMethod {
			get { return m_addMeth; }
			set { m_addMeth = value; }
		}

		public MethodDefinition InvokeMethod {
			get { return m_invMeth; }
			set { m_invMeth = value; }
		}

		public MethodDefinition RemoveMethod {
			get { return m_remMeth; }
			set { m_remMeth = value; }
		}

		public CustomAttributeCollection CustomAttributes {
			get {
				if (m_customAttrs == null)
					m_customAttrs = new CustomAttributeCollection (this);

				return m_customAttrs;
			}
		}

		public bool IsRuntimeSpecialName {
			get { return (m_attributes & EventAttributes.RTSpecialName) != 0; }
			set {
				if (value)
					m_attributes |= EventAttributes.RTSpecialName;
				else
					m_attributes &= ~EventAttributes.RTSpecialName;
			}
		}

		public bool IsSpecialName {
			get { return (m_attributes & EventAttributes.SpecialName) != 0; }
			set {
				if (value)
					m_attributes |= EventAttributes.SpecialName;
				else
					m_attributes &= ~EventAttributes.SpecialName;
			}
		}

		public EventDefinition (string name, TypeReference eventType,
			EventAttributes attrs) : base (name, eventType)
		{
			m_attributes = attrs;
		}

		public static MethodDefinition CreateAddMethod (EventDefinition evt)
		{
			MethodDefinition add = new MethodDefinition (
				string.Concat ("add_", evt.Name), (MethodAttributes) 0, evt.EventType);
			evt.AddMethod = add;
			return add;
		}

		public static MethodDefinition CreateRemoveMethod (EventDefinition evt)
		{
			MethodDefinition remove = new MethodDefinition (
				string.Concat ("remove_", evt.Name), (MethodAttributes) 0, evt.EventType);
			evt.RemoveMethod = remove;
			return remove;
		}

		public static MethodDefinition CreateInvokeMethod (EventDefinition evt)
		{
			MethodDefinition raise = new MethodDefinition (
				string.Concat ("raise_", evt.Name), (MethodAttributes) 0, evt.EventType);
			evt.InvokeMethod = raise;
			return raise;
		}

		public EventDefinition Clone ()
		{
			return Clone (this, new ImportContext (this.DeclaringType));
		}

		internal static EventDefinition Clone (EventDefinition evt, ImportContext context)
		{
			EventDefinition ne = new EventDefinition (
				evt.Name,
				context.Import (evt.EventType),
				evt.Attributes);

			if (context != null && context.GenericContext.Type is TypeDefinition) {
				TypeDefinition type = context.GenericContext.Type as TypeDefinition;
				if (evt.AddMethod != null)
					ne.AddMethod = type.Methods.GetMethod (evt.AddMethod.Name) [0];
				if (evt.InvokeMethod != null)
					ne.InvokeMethod = type.Methods.GetMethod (evt.InvokeMethod.Name) [0];
				if (evt.RemoveMethod != null)
					ne.RemoveMethod = type.Methods.GetMethod (evt.RemoveMethod.Name) [0];
			}

			foreach (CustomAttribute ca in evt.CustomAttributes)
				ne.CustomAttributes.Add (CustomAttribute.Clone (ca, context));

			return ne;
		}

		public override void Accept (IReflectionVisitor visitor)
		{
			visitor.VisitEventDefinition (this);

			this.CustomAttributes.Accept (visitor);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/EventDefinitionCollection.cs
================================================
//
// EventDefinitionCollection.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Wed Sep 27 01:22:48 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;
	using System.Collections;

	using Mono.Cecil.Cil;

	public sealed class EventDefinitionCollection : CollectionBase, IReflectionVisitable {

		TypeDefinition m_container;

		public EventDefinition this [int index] {
			get { return List [index] as EventDefinition; }
			set { List [index] = value; }
		}

		public TypeDefinition Container {
			get { return m_container; }
		}

		public EventDefinitionCollection (TypeDefinition container)
		{
			m_container = container;
		}

		public void Add (EventDefinition value)
		{
			if (!Contains (value))
				Attach (value);

			List.Add (value);
		}

		public new void Clear ()
		{
			foreach (EventDefinition item in this)
				Detach (item);

			base.Clear ();
		}

		public bool Contains (EventDefinition value)
		{
			return List.Contains (value);
		}

		public int IndexOf (EventDefinition value)
		{
			return List.IndexOf (value);
		}

		public void Insert (int index, EventDefinition value)
		{
			if (!this.Contains (value))
				Attach (value);

			List.Insert (index, value);
		}

		public void Remove (EventDefinition value)
		{
			if (this.Contains (value))
				Detach (value);

			List.Remove (value);
		}

		public new void RemoveAt (int index)
		{
			Detach (this [index]);

			List.RemoveAt (index);
		}

		protected override void OnValidate (object o)
		{
			if (! (o is EventDefinition))
				throw new ArgumentException ("Must be of type " + typeof (EventDefinition).FullName);
		}

		public EventDefinition GetEvent (string name)
		{
			foreach (EventDefinition evt in this)
				if (evt.Name == name)
					return evt;

			return null;
		}

		void Attach (MemberReference member)
		{
			if (member.DeclaringType != null)
				throw new ReflectionException ("Member already attached, clone it instead");

			member.DeclaringType = m_container;
		}

		void Detach (MemberReference member)
		{
			member.DeclaringType = null;
		}

		public void Accept (IReflectionVisitor visitor)
		{
			visitor.VisitEventDefinitionCollection (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/EventReference.cs
================================================
//
// EventReference.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	public abstract class EventReference : MemberReference {

		TypeReference m_eventType;

		public TypeReference EventType {
			get { return m_eventType; }
			set { m_eventType = value; }
		}

		public EventReference (string name, TypeReference eventType) : base (name)
		{
			m_eventType = eventType;
		}

		public override string ToString ()
		{
			return string.Concat (m_eventType.FullName, " ", base.ToString ());
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/ExternTypeCollection.cs
================================================
//
// ExternTypeCollection.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Tue Oct 03 00:35:29 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;
	using System.Collections;
	using System.Collections.Specialized;

	using Mono.Cecil.Cil;

	using Hcp = Mono.Cecil.HashCodeProvider;
	using Cmp = System.Collections.Comparer;

	public sealed class ExternTypeCollection : NameObjectCollectionBase, IList, IReflectionVisitable  {

		ModuleDefinition m_container;

		public TypeReference this [int index] {
			get { return this.BaseGet (index) as TypeReference; }
			set { this.BaseSet (index, value); }
		}

		public TypeReference this [string fullName] {
			get { return this.BaseGet (fullName) as TypeReference; }
			set { this.BaseSet (fullName, value); }
		}

		public ModuleDefinition Container {
			get { return m_container; }
		}

		public bool IsSynchronized {
			get { return false; }
		}

		public object SyncRoot {
			get { return this; }
		}

		bool IList.IsReadOnly {
			get { return false; }
		}

		bool IList.IsFixedSize {
			get { return false; }
		}

		object IList.this [int index] {
			get { return BaseGet (index); }
			set {
				Check (value);
				BaseSet (index, value);
			}
		}

		public ExternTypeCollection (ModuleDefinition container) :
			base (Hcp.Instance, Cmp.Default)
		{
			m_container = container;
		}

		public void Add (TypeReference value)
		{
			if (value == null)
				throw new ArgumentNullException ("value");

			Attach (value);

			this.BaseAdd (value.FullName, value);
		}

		public void Clear ()
		{
			foreach (TypeReference item in this)
				Detach (item);

			this.BaseClear ();
		}

		public bool Contains (TypeReference value)
		{
			return Contains (value.FullName);
		}

		public bool Contains (string fullName)
		{
			return this.BaseGet (fullName) != null;
		}

		public int IndexOf (TypeReference value)
		{
			string [] keys = this.BaseGetAllKeys ();
			return Array.IndexOf (keys, value.FullName, 0, keys.Length);
		}

		public void Remove (TypeReference value)
		{
			if (this.Contains (value))
				Detach (value);

			this.BaseRemove (value.FullName);
		}

		public void RemoveAt (int index)
		{
			Detach (this [index]);

			this.BaseRemoveAt (index);
		}

		public void CopyTo (Array ary, int index)
		{
			this.BaseGetAllValues ().CopyTo (ary, index);
		}

		public new IEnumerator GetEnumerator ()
		{
			return this.BaseGetAllValues ().GetEnumerator ();
		}

		public void Accept (IReflectionVisitor visitor)
		{
			visitor.VisitExternTypeCollection (this);
		}

#if CF_1_0 || CF_2_0
		internal object [] BaseGetAllValues ()
		{
			object [] values = new object [this.Count];
			for (int i=0; i < values.Length; ++i) {
				values [i] = this.BaseGet (i);
			}
			return values;
		}
#endif

		void Check (object value)
		{
			if (!(value is TypeReference))
				throw new ArgumentException ();
		}

		int IList.Add (object value)
		{
			Check (value);
			Add (value as TypeReference);
			return 0;
		}

		bool IList.Contains (object value)
		{
			Check (value);
			return Contains (value as TypeReference);
		}

		int IList.IndexOf (object value)
		{
			throw new NotSupportedException ();
		}

		void IList.Insert (int index, object value)
		{
			throw new NotSupportedException ();
		}

		void IList.Remove (object value)
		{
			Check (value);
			Remove (value as TypeReference);
		}

		void Detach (TypeReference type)
		{
			type.Module = null;
		}

		void Attach (TypeReference type)
		{
			if (type.Module != null)
				throw new ReflectionException ("Type is already attached, clone it instead");

			type.Module = m_container;
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/FieldAttributes.cs
================================================
//
// FieldAttributes.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;

	[Flags]
	public enum FieldAttributes : ushort {
		FieldAccessMask		= 0x0007,
		Compilercontrolled	= 0x0000,	// Member not referenceable
		Private				= 0x0001,	// Accessible only by the parent type
		FamANDAssem			= 0x0002,	// Accessible by sub-types only in this assembly
		Assembly			= 0x0003,	// Accessible by anyone in the Assembly
		Family				= 0x0004,	// Accessible only by type and sub-types
		FamORAssem			= 0x0005,	// Accessible by sub-types anywhere, plus anyone in the assembly
		Public				= 0x0006,	// Accessible by anyone who has visibility to this scope field contract attributes

		Static				= 0x0010,	// Defined on type, else per instance
		InitOnly			= 0x0020,	// Field may only be initialized, not written after init
		Literal				= 0x0040,	// Value is compile time constant
		NotSerialized		= 0x0080,	// Field does not have to be serialized when type is remoted
		SpecialName			= 0x0200,	// Field is special

		// Interop Attributes
		PInvokeImpl			= 0x2000,	// Implementation is forwarded through PInvoke

		// Additional flags
		RTSpecialName		= 0x0400,	// CLI provides 'special' behavior, depending upon the name of the field
		HasFieldMarshal		= 0x1000,	// Field has marshalling information
		HasDefault			= 0x8000,	// Field has default
		HasFieldRVA			= 0x0100	 // Field has RVA
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/FieldDefinition.cs
================================================
//
// FieldDefinition.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;

	using Mono.Cecil;
	using Mono.Cecil.Binary;

	public sealed class FieldDefinition : FieldReference, IMemberDefinition,
		ICustomAttributeProvider, IHasMarshalSpec, IHasConstant {

		FieldAttributes m_attributes;

		CustomAttributeCollection m_customAttrs;

		bool m_hasInfo;
		uint m_offset;

		RVA m_rva;
		byte [] m_initVal;

		bool m_hasConstant;
		object m_const;

		MarshalSpec m_marshalDesc;

		public bool HasLayoutInfo {
			get { return m_hasInfo; }
		}

		public uint Offset {
			get { return m_offset; }
			set {
				m_hasInfo = true;
				m_offset = value;
			}
		}

		public RVA RVA {
			get { return m_rva; }
			set { m_rva = value; }
		}

		public byte [] InitialValue {
			get { return m_initVal; }
			set { m_initVal = value; }
		}

		public FieldAttributes Attributes {
			get { return m_attributes; }
			set { m_attributes = value; }
		}

		public bool HasConstant {
			get { return m_hasConstant; }
		}

		public object Constant {
			get { return m_const; }
			set {
				m_hasConstant = true;
				m_const = value;
			}
		}

		public CustomAttributeCollection CustomAttributes {
			get {
				if (m_customAttrs == null)
					m_customAttrs = new CustomAttributeCollection (this);

				return m_customAttrs;
			}
		}

		public MarshalSpec MarshalSpec {
			get { return m_marshalDesc; }
			set { m_marshalDesc = value; }
		}

		public bool IsLiteral {
			get { return (m_attributes & FieldAttributes.Literal) != 0; }
			set {
				if (value)
					m_attributes |= FieldAttributes.Literal;
				else
					m_attributes &= ~FieldAttributes.Literal;
			}
		}

		public bool IsReadOnly {
			get { return (m_attributes & FieldAttributes.InitOnly) != 0; }
			set {
				if (value)
					m_attributes |= FieldAttributes.InitOnly;
				else
					m_attributes &= ~FieldAttributes.InitOnly;
			}
		}

		public bool IsRuntimeSpecialName {
			get { return (m_attributes & FieldAttributes.RTSpecialName) != 0; }
			set {
				if (value)
					m_attributes |= FieldAttributes.RTSpecialName;
				else
					m_attributes &= ~FieldAttributes.RTSpecialName;
			}
		}

		public bool IsSpecialName {
			get { return (m_attributes & FieldAttributes.SpecialName) != 0; }
			set {
				if (value)
					m_attributes |= FieldAttributes.SpecialName;
				else
					m_attributes &= ~FieldAttributes.SpecialName;
			}
		}

		public bool IsStatic {
			get { return (m_attributes & FieldAttributes.Static) != 0; }
			set {
				if (value)
					m_attributes |= FieldAttributes.Static;
				else
					m_attributes &= ~FieldAttributes.Static;
			}
		}

		public FieldDefinition (string name, TypeReference fieldType,
			FieldAttributes attrs) : base (name, fieldType)
		{
			m_attributes = attrs;
		}

		public FieldDefinition Clone ()
		{
			return Clone (this, new ImportContext (this.DeclaringType));
		}

		internal static FieldDefinition Clone (FieldDefinition field, ImportContext context)
		{
			FieldDefinition nf = new FieldDefinition (
				field.Name,
				context.Import (field.FieldType),
				field.Attributes);

			if (field.HasConstant)
				nf.Constant = field.Constant;
			if (field.MarshalSpec != null)
				nf.MarshalSpec = field.MarshalSpec;
			if (field.RVA != RVA.Zero)
				nf.InitialValue = field.InitialValue;
			else
				nf.InitialValue = new byte [0];
			if (field.HasLayoutInfo)
				nf.Offset = field.Offset;

			foreach (CustomAttribute ca in field.CustomAttributes)
				nf.CustomAttributes.Add (CustomAttribute.Clone (ca, context));

			return nf;
		}

		public override void Accept (IReflectionVisitor visitor)
		{
			visitor.VisitFieldDefinition (this);

			if (this.MarshalSpec != null)
				this.MarshalSpec.Accept (visitor);

			this.CustomAttributes.Accept (visitor);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/FieldDefinitionCollection.cs
================================================
//
// FieldDefinitionCollection.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Wed Sep 27 01:22:48 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;
	using System.Collections;

	using Mono.Cecil.Cil;

	public sealed class FieldDefinitionCollection : CollectionBase, IReflectionVisitable {

		TypeDefinition m_container;

		public FieldDefinition this [int index] {
			get { return List [index] as FieldDefinition; }
			set { List [index] = value; }
		}

		public TypeDefinition Container {
			get { return m_container; }
		}

		public FieldDefinitionCollection (TypeDefinition container)
		{
			m_container = container;
		}

		public void Add (FieldDefinition value)
		{
			if (!Contains (value))
				Attach (value);

			List.Add (value);
		}

		public new void Clear ()
		{
			foreach (FieldDefinition item in this)
				Detach (item);

			base.Clear ();
		}

		public bool Contains (FieldDefinition value)
		{
			return List.Contains (value);
		}

		public int IndexOf (FieldDefinition value)
		{
			return List.IndexOf (value);
		}

		public void Insert (int index, FieldDefinition value)
		{
			if (!this.Contains (value))
				Attach (value);

			List.Insert (index, value);
		}

		public void Remove (FieldDefinition value)
		{
			if (this.Contains (value))
				Detach (value);

			List.Remove (value);
		}

		public new void RemoveAt (int index)
		{
			Detach (this [index]);

			List.RemoveAt (index);
		}

		protected override void OnValidate (object o)
		{
			if (! (o is FieldDefinition))
				throw new ArgumentException ("Must be of type " + typeof (FieldDefinition).FullName);
		}

		public FieldDefinition GetField (string name)
		{
			foreach (FieldDefinition field in this)
				if (field.Name == name)
					return field;

			return null;
		}

		void Attach (MemberReference member)
		{
			if (member.DeclaringType != null)
				throw new ReflectionException ("Member already attached, clone it instead");

			member.DeclaringType = m_container;
		}

		void Detach (MemberReference member)
		{
			member.DeclaringType = null;
		}

		public void Accept (IReflectionVisitor visitor)
		{
			visitor.VisitFieldDefinitionCollection (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/FieldReference.cs
================================================
//
// FieldReference.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using Mono.Cecil;

	public class FieldReference : MemberReference {

		TypeReference m_fieldType;

		public TypeReference FieldType {
			get { return m_fieldType; }
			set { m_fieldType = value; }
		}

		internal FieldReference (string name, TypeReference fieldType) : base (name)
		{
			m_fieldType = fieldType;
		}

		public FieldReference (string name, TypeReference declaringType, TypeReference fieldType) :
			this (name, fieldType)
		{
			this.DeclaringType = declaringType;
		}

		public override string ToString ()
		{
			return string.Concat (m_fieldType.FullName, " ", base.ToString ());
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/FileAttributes.cs
================================================
//
// FileAttributes.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	public enum FileAttributes : uint {
		ContainsMetaData	= 0x0000,	// This is not a resource file
		ContainsNoMetaData  = 0x0001,	// This is a resource file or other non-metadata-containing file
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/FunctionPointerType.cs
================================================
//
// FunctionPointerType.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 - 2007 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;
	using System.Text;

	public sealed class FunctionPointerType : TypeSpecification, IMethodSignature {

		MethodReference m_function;

		public bool HasThis {
			get { return m_function.HasThis; }
			set { m_function.HasThis = value; }
		}

		public bool ExplicitThis {
			get { return m_function.ExplicitThis; }
			set { m_function.ExplicitThis = value; }
		}

		public MethodCallingConvention CallingConvention {
			get { return m_function.CallingConvention; }
			set { m_function.CallingConvention = value; }
		}

		public ParameterDefinitionCollection Parameters {
			get { return m_function.Parameters; }
		}

		public MethodReturnType ReturnType {
			get { return m_function.ReturnType; }
			set { m_function.ReturnType = value; }
		}

		public override string Name {
			get { return m_function.Name; }
			set { throw new InvalidOperationException (); }
		}

		public override string Namespace {
			get { return string.Empty; }
			set { throw new InvalidOperationException (); }
		}

		public override IMetadataScope Scope {
			get { return m_function.DeclaringType.Scope; }
		}

		public override string FullName {
			get {
				StringBuilder sb = new StringBuilder ();
				sb.Append (m_function.Name);
				sb.Append (" ");
				sb.Append (m_function.ReturnType.ReturnType.FullName);
				sb.Append (" *(");
				for (int i = 0; i < m_function.Parameters.Count; i++) {
					if (i > 0)
						sb.Append (",");
					sb.Append (m_function.Parameters [i].ParameterType.FullName);
				}
				sb.Append (")");
				return sb.ToString ();
			}
		}

		public FunctionPointerType (bool hasThis, bool explicitThis, MethodCallingConvention callConv, MethodReturnType retType) :
			base (retType.ReturnType)
		{
			m_function = new MethodReference ("method", hasThis, explicitThis, callConv);
			m_function.ReturnType = retType;
		}

		public int GetSentinel ()
		{
			return m_function.GetSentinel ();
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/GenericArgumentCollection.cs
================================================
//
// GenericArgumentCollection.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Wed Sep 27 12:46:54 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;
	using System.Collections;

	using Mono.Cecil.Cil;

	public sealed class GenericArgumentCollection : CollectionBase {

		IGenericInstance m_container;

		public TypeReference this [int index] {
			get { return List [index] as TypeReference; }
			set { List [index] = value; }
		}

		public IGenericInstance Container {
			get { return m_container; }
		}

		public GenericArgumentCollection (IGenericInstance container)
		{
			m_container = container;
		}

		public void Add (TypeReference value)
		{
			List.Add (value);
		}

		public bool Contains (TypeReference value)
		{
			return List.Contains (value);
		}

		public int IndexOf (TypeReference value)
		{
			return List.IndexOf (value);
		}

		public void Insert (int index, TypeReference value)
		{
			List.Insert (index, value);
		}

		public void Remove (TypeReference value)
		{
			List.Remove (value);
		}

		protected override void OnValidate (object o)
		{
			if (! (o is TypeReference))
				throw new ArgumentException ("Must be of type " + typeof (TypeReference).FullName);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/GenericContext.cs
================================================
//
// GenericContext.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System.Text;

	internal class GenericContext {

		TypeReference m_type;
		MethodReference m_method;
		bool m_allowCreation;

		public TypeReference Type {
			get { return m_type; }
			set { m_type = value; }
		}

		public MethodReference Method {
			get { return m_method; }
			set { m_method = value; }
		}

		public bool AllowCreation {
			get { return m_allowCreation; }
			set { m_allowCreation = value; }
		}

		public bool Null {
			get { return m_type == null && m_method == null; }
		}

		public GenericContext ()
		{
		}

		public GenericContext (TypeReference type, MethodReference meth)
		{
			m_type = type;
			m_method = meth;
		}

		public GenericContext (IGenericParameterProvider provider)
		{
			if (provider is TypeReference)
				m_type = provider as TypeReference;
			else if (provider is MethodReference) {
				MethodReference meth = provider as MethodReference;
				m_method = meth;
				m_type = meth.DeclaringType;
			}
		}

		public GenericContext Clone ()
		{
			GenericContext ctx = new GenericContext ();
			ctx.Type = m_type;
			ctx.Method = m_method;
			return ctx;
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/GenericInstanceMethod.cs
================================================
//
// IGenericInstanceMethod.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System.Text;

	public sealed class GenericInstanceMethod : MethodSpecification, IGenericInstance {

		private GenericArgumentCollection m_genArgs;

		public GenericArgumentCollection GenericArguments {
			get {
				if (m_genArgs == null)
					m_genArgs = new GenericArgumentCollection (this);
				return m_genArgs;
			}
		}

		public GenericInstanceMethod (MethodReference elemMethod) : base (elemMethod)
		{
		}

		public override string ToString ()
		{
			StringBuilder sb = new StringBuilder ();
			MethodReference meth = this.ElementMethod;
			sb.Append (meth.ReturnType.ReturnType.FullName);
			sb.Append (" ");
			sb.Append (meth.DeclaringType.FullName);
			sb.Append ("::");
			sb.Append (meth.Name);
			sb.Append ("<");
			for (int i = 0; i < this.GenericArguments.Count; i++) {
				if (i > 0)
					sb.Append (",");
				sb.Append (this.GenericArguments [i].FullName);
			}
			sb.Append (">");
			sb.Append ("(");
			for (int i = 0; i < meth.Parameters.Count; i++) {
				sb.Append (meth.Parameters [i].ParameterType.FullName);
				if (i < meth.Parameters.Count - 1)
					sb.Append (",");
			}
			sb.Append (")");
			return sb.ToString ();
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/GenericInstanceType.cs
================================================
//
// GenericInstanceType.cs
//
// Author:
//	Martin Baulig  <martin@ximian.com>
//  Jb Evain  <jbevain@gmail.com>
//
// Copyright (C) 2005 Novell, Inc (http://www.novell.com)
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System.Text;

	public sealed class GenericInstanceType : TypeSpecification, IGenericInstance {

		private GenericArgumentCollection m_genArgs;

		public GenericArgumentCollection GenericArguments {
			get {
				if (m_genArgs == null)
					m_genArgs = new GenericArgumentCollection (this);
				return m_genArgs;
			}
		}

		public override bool IsValueType {
			set { m_isValueType = value; }
			get { return m_isValueType; }
		}

		public override string FullName {
			get {
				StringBuilder sb = new StringBuilder ();
				sb.Append (base.FullName);
				sb.Append ("<");
				for (int i = 0; i < this.GenericArguments.Count; i++) {
					if (i > 0)
						sb.Append (",");
					sb.Append (this.GenericArguments [i].FullName);
				}
				sb.Append (">");
				return sb.ToString ();
			}
		}

		public GenericInstanceType (TypeReference elementType) : base (elementType)
		{
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/GenericParameter.cs
================================================
//
// GenericParameter.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;

	public sealed class GenericParameter : TypeReference {

		int m_position;
		string m_name;
		GenericParameterAttributes m_attributes;
		IGenericParameterProvider m_owner;
		ConstraintCollection m_constraints;

		public int Position {
			get { return m_position; }
			set { m_position = value; }
		}

		public GenericParameterAttributes Attributes {
			get { return m_attributes; }
			set { m_attributes = value; }
		}

		public IGenericParameterProvider Owner {
			get { return m_owner; }
		}

		public ConstraintCollection Constraints {
			get {
				if (m_constraints == null)
					m_constraints = new ConstraintCollection (this);

				return m_constraints;
			}
		}

		public override string Name {
			get {
				if (m_name != null)
					return m_name;

				if (m_owner is TypeReference)
					return string.Concat ("!", m_position.ToString ());
				else if (m_owner is MethodReference)
					return string.Concat ("!!", m_position.ToString ());
				else
					throw new InvalidOperationException ();
			}
			set { m_name = value; }
		}

		public override string Namespace {
			get { return string.Empty; }
			set { throw new InvalidOperationException (); }
		}

		public override string FullName {
			get { return Name; }
		}

		internal GenericParameter (int pos, IGenericParameterProvider owner) :
			base (string.Empty, string.Empty)
		{
			m_position = pos;
			m_owner = owner;
		}

		public GenericParameter (string name, IGenericParameterProvider owner) :
			base (string.Empty, string.Empty)
		{
			m_name = name;
			m_owner = owner;
		}

		internal static GenericParameter Clone (GenericParameter gp, ImportContext context)
		{
			GenericParameter ngp;
			if (gp.Owner is TypeReference)
				ngp = new GenericParameter (gp.m_name, context.GenericContext.Type);
			else if (gp.Owner is MethodReference)
				ngp = new GenericParameter (gp.m_name, context.GenericContext.Method);
			else
				throw new NotSupportedException ();

			ngp.Position = gp.Owner.GenericParameters.IndexOf (gp);
			ngp.Attributes = gp.Attributes;

			foreach (TypeReference constraint in gp.Constraints)
				ngp.Constraints.Add (context.Import (constraint));
			foreach (CustomAttribute ca in gp.CustomAttributes)
				ngp.CustomAttributes.Add (CustomAttribute.Clone (ca, context));

			return ngp;
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/GenericParameterAttributes.cs
================================================
//
// GenericParameterAttributes.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;

	[Flags]
	public enum GenericParameterAttributes : ushort {
		VarianceMask	= 0x0003,
		NonVariant		= 0x0000,
		Covariant		= 0x0001,
		Contravariant	= 0x0002,

		SpecialConstraintMask			= 0x001c,
		ReferenceTypeConstraint			= 0x0004,
		NotNullableValueTypeConstraint	= 0x0008,
		DefaultConstructorConstraint	= 0x0010
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/GenericParameterCollection.cs
================================================
//
// GenericParameterCollection.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Wed Sep 27 12:46:53 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;
	using System.Collections;

	using Mono.Cecil.Cil;

	public sealed class GenericParameterCollection : CollectionBase, IReflectionVisitable {

		IGenericParameterProvider m_container;

		public GenericParameter this [int index] {
			get { return List [index] as GenericParameter; }
			set { List [index] = value; }
		}

		public IGenericParameterProvider Container {
			get { return m_container; }
		}

		public GenericParameterCollection (IGenericParameterProvider container)
		{
			m_container = container;
		}

		public void Add (GenericParameter value)
		{
			List.Add (value);
		}
        public void AddRange(GenericParameter[] value)
        {
            for (int i = 0; i < value.Length; i++)
                List.Add(value[i]);
        }
        public void AddRange(GenericParameterCollection value)
        {
            for (int i = 0; i < value.Count; i++)
                List.Add(value[i]);
        }

		public bool Contains (GenericParameter value)
		{
			return List.Contains (value);
		}

		public int IndexOf (GenericParameter value)
		{
			return List.IndexOf (value);
		}

		public void Insert (int index, GenericParameter value)
		{
			List.Insert (index, value);
		}

		public void Remove (GenericParameter value)
		{
			List.Remove (value);
		}

		protected override void OnValidate (object o)
		{
			if (! (o is GenericParameter))
				throw new ArgumentException ("Must be of type " + typeof (GenericParameter).FullName);
		}

		public void Accept (IReflectionVisitor visitor)
		{
			visitor.VisitGenericParameterCollection (this);
		}

        public GenericParameter[] ToArray()
        {
            return (GenericParameter[])this.InnerList.ToArray();
        }
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/HashCodeProvider.cs
================================================
//
// HashCodeProvider.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System.Collections;

	internal sealed class HashCodeProvider : IHashCodeProvider {

		public static readonly HashCodeProvider Instance = new HashCodeProvider ();

		HashCodeProvider ()
		{
		}

		public int GetHashCode (object o)
		{
			return o.GetHashCode ();
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/IAssemblyResolver.cs
================================================
//
// IAssemblyResolver.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2006 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	public interface IAssemblyResolver {

		AssemblyDefinition Resolve (string fullName);
		AssemblyDefinition Resolve (AssemblyNameReference name);
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/ICustomAttributeProvider.cs
================================================
//
// ICustomAttributeProvider.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System.Reflection;

	public interface ICustomAttributeProvider {

		CustomAttributeCollection CustomAttributes { get; }
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/IDetailReader.cs
================================================
//
// IDetailReader.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	internal interface IDetailReader {

		void ReadSemantic (EventDefinition evt);
		void ReadSemantic (PropertyDefinition prop);

		void ReadMarshalSpec (ParameterDefinition param);
		void ReadMarshalSpec (FieldDefinition field);

		void ReadLayout (TypeDefinition type);
		void ReadLayout (FieldDefinition field);

		void ReadConstant (FieldDefinition field);
		void ReadConstant (PropertyDefinition prop);
		void ReadConstant (ParameterDefinition param);

		void ReadInitialValue (FieldDefinition field);
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/IGenericInstance.cs
================================================
//
// IGenericInstanceMethod.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	public interface IGenericInstance : IMetadataTokenProvider {

		GenericArgumentCollection GenericArguments { get; }
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/IGenericParameterProvider.cs
================================================
//
// IGenericParameterProvider.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	public interface IGenericParameterProvider : IMetadataTokenProvider {

		GenericParameterCollection GenericParameters { get; }
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/IHasConstant.cs
================================================
//
// IHasConstant.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	public interface IHasConstant : IMetadataTokenProvider {

		bool HasConstant { get; }
		object Constant { get; set; }
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/IHasMarshalSpec.cs
================================================
//
// IHasMarshalSpec.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	public interface IHasMarshalSpec : IMetadataTokenProvider {

		MarshalSpec MarshalSpec { get; set; }
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/IHasSecurity.cs
================================================
//
// IHasSecurity.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	public interface IHasSecurity : IMetadataTokenProvider {

		SecurityDeclarationCollection SecurityDeclarations { get; }
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/IMemberDefinition.cs
================================================
//
// IMemberDefinition.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	public interface IMemberDefinition : IMemberReference {
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/IMemberReference.cs
================================================
//
// IMemberReference.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	public interface IMemberReference : IMetadataTokenProvider, IReflectionVisitable {

		string Name { get; set; }
		TypeReference DeclaringType { get; }
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/IMetadataScope.cs
================================================
//
// IMetadataScope.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	public interface IMetadataScope : IMetadataTokenProvider {
		string Name { get; set; }
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/IMetadataTokenProvider.cs
================================================
//
// IMetadataTokenProvider.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using Mono.Cecil.Metadata;

	public interface IMetadataTokenProvider {

		MetadataToken MetadataToken { get; set; }
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/IMethodSignature.cs
================================================
//
// IMethodSignature.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 - 2007 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	public interface IMethodSignature {

		bool HasThis { get; set; }
		bool ExplicitThis { get; set; }
		MethodCallingConvention CallingConvention { get; set; }

		ParameterDefinitionCollection Parameters { get; }
		MethodReturnType ReturnType { get; }

		int GetSentinel ();
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/IReflectionStructureVisitable.cs
================================================
//
// IReflectionStructureVisitable.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	public interface IReflectionStructureVisitable {

		void Accept (IReflectionStructureVisitor visitor);
	}
}




================================================
File: DeConfuser/MonoCecil/Mono.Cecil/IReflectionStructureVisitor.cs
================================================
//
// IReflectionStructureVisitor.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	public interface IReflectionStructureVisitor {

		void VisitAssemblyDefinition (AssemblyDefinition asm);
		void VisitAssemblyNameDefinition (AssemblyNameDefinition name);
		void VisitAssemblyNameReferenceCollection (AssemblyNameReferenceCollection names);
		void VisitAssemblyNameReference (AssemblyNameReference name);
		void VisitResourceCollection (ResourceCollection resources);
		void VisitEmbeddedResource (EmbeddedResource res);
		void VisitLinkedResource (LinkedResource res);
		void VisitAssemblyLinkedResource (AssemblyLinkedResource res);
		void VisitModuleDefinition (ModuleDefinition module);
		void VisitModuleDefinitionCollection (ModuleDefinitionCollection modules);
		void VisitModuleReference (ModuleReference module);
		void VisitModuleReferenceCollection (ModuleReferenceCollection modules);

		void TerminateAssemblyDefinition (AssemblyDefinition asm);
	}
}




================================================
File: DeConfuser/MonoCecil/Mono.Cecil/IReflectionVisitable.cs
================================================
//
// IReflectionVisitable.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	public interface IReflectionVisitable {

		void Accept (IReflectionVisitor visitor);
	}
}




================================================
File: DeConfuser/MonoCecil/Mono.Cecil/IReflectionVisitor.cs
================================================
//
// IReflectionVisitor.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	public interface IReflectionVisitor {

		void VisitModuleDefinition (ModuleDefinition module);
		void VisitTypeDefinitionCollection (TypeDefinitionCollection types);
		void VisitTypeDefinition (TypeDefinition type);
		void VisitTypeReferenceCollection (TypeReferenceCollection refs);
		void VisitTypeReference (TypeReference type);
		void VisitMemberReferenceCollection (MemberReferenceCollection members);
		void VisitMemberReference (MemberReference member);
		void VisitInterfaceCollection (InterfaceCollection interfaces);
		void VisitInterface (TypeReference interf);
		void VisitExternTypeCollection (ExternTypeCollection externs);
		void VisitExternType (TypeReference externType);
		void VisitOverrideCollection (OverrideCollection meth);
		void VisitOverride (MethodReference ov);
		void VisitNestedTypeCollection (NestedTypeCollection nestedTypes);
		void VisitNestedType (TypeDefinition nestedType);
		void VisitParameterDefinitionCollection (ParameterDefinitionCollection parameters);
		void VisitParameterDefinition (ParameterDefinition parameter);
		void VisitMethodDefinitionCollection (MethodDefinitionCollection methods);
		void VisitMethodDefinition (MethodDefinition method);
		void VisitConstructorCollection (ConstructorCollection ctors);
		void VisitConstructor (MethodDefinition ctor);
		void VisitPInvokeInfo (PInvokeInfo pinvk);
		void VisitEventDefinitionCollection (EventDefinitionCollection events);
		void VisitEventDefinition (EventDefinition evt);
		void VisitFieldDefinitionCollection (FieldDefinitionCollection fields);
		void VisitFieldDefinition (FieldDefinition field);
		void VisitPropertyDefinitionCollection (PropertyDefinitionCollection properties);
		void VisitPropertyDefinition (PropertyDefinition property);
		void VisitSecurityDeclarationCollection (SecurityDeclarationCollection secDecls);
		void VisitSecurityDeclaration (SecurityDeclaration secDecl);
		void VisitCustomAttributeCollection (CustomAttributeCollection customAttrs);
		void VisitCustomAttribute (CustomAttribute customAttr);
		void VisitGenericParameterCollection (GenericParameterCollection genparams);
		void VisitGenericParameter (GenericParameter genparam);
		void VisitMarshalSpec (MarshalSpec marshalSpec);

		void TerminateModuleDefinition (ModuleDefinition module);
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/IRequireResolving.cs
================================================
//
// IRequireResolving.cs
//
// Author:
//	Jb Evain <jbevain@gmail.com>
//
// Copyright (C) 2006 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	public interface IRequireResolving {

		byte [] Blob { get; }
		bool Resolved { get; }
		bool Resolve ();
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/ImportContext.cs
================================================
//
// ImportContext.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2006 Evaluant RC S.A.
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	internal class ImportContext {

		GenericContext m_genContext;
		ReflectionHelper m_helper;

		public GenericContext GenericContext {
			get { return m_genContext; }
		}

		public ImportContext ()
		{
			m_genContext = new GenericContext ();
		}

		public ImportContext (ReflectionHelper helper) : this ()
		{
			m_helper = helper;
		}

		public ImportContext (IGenericParameterProvider provider)
		{
			m_genContext = new GenericContext (provider);
		}

		public ImportContext (ReflectionHelper helper, IGenericParameterProvider provider)
		{
			m_helper = helper;
			m_genContext = new GenericContext (provider);
		}

		public TypeReference Import (TypeReference type)
		{
			return m_helper == null ? type : m_helper.ImportTypeReference (type, this);
		}

		public MethodReference Import (MethodReference meth)
		{
			return m_helper == null ? meth : m_helper.ImportMethodReference (meth, this);
		}

		public FieldReference Import (FieldReference field)
		{
			return m_helper == null ? field : m_helper.ImportFieldReference (field, this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/InterfaceCollection.cs
================================================
//
// InterfaceCollection.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Wed Sep 27 12:46:52 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;
	using System.Collections;

	using Mono.Cecil.Cil;

	public sealed class InterfaceCollection : CollectionBase, IReflectionVisitable {

		TypeDefinition m_container;

		public TypeReference this [int index] {
			get { return List [index] as TypeReference; }
			set { List [index] = value; }
		}

		public TypeDefinition Container {
			get { return m_container; }
		}

		public InterfaceCollection (TypeDefinition container)
		{
			m_container = container;
		}

		public void Add (TypeReference value)
		{
			List.Add (value);
		}

		public bool Contains (TypeReference value)
		{
			return List.Contains (value);
		}

		public int IndexOf (TypeReference value)
		{
			return List.IndexOf (value);
		}

		public void Insert (int index, TypeReference value)
		{
			List.Insert (index, value);
		}

		public void Remove (TypeReference value)
		{
			List.Remove (value);
		}

		protected override void OnValidate (object o)
		{
			if (! (o is TypeReference))
				throw new ArgumentException ("Must be of type " + typeof (TypeReference).FullName);
		}

		public void Accept (IReflectionVisitor visitor)
		{
			visitor.VisitInterfaceCollection (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/LinkedResource.cs
================================================
//
// LinkedResource.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 - 2007 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	public sealed class LinkedResource : Resource {

		byte [] m_hash;
		string m_file;

		public byte [] Hash {
			get { return m_hash; }
			set { m_hash = value; }
		}

		public string File {
			get { return m_file; }
			set { m_file = value; }
		}

		public LinkedResource (string name, ManifestResourceAttributes flags, string file) :
			base (name, flags)
		{
			m_file = file;
		}

		public override void Accept (IReflectionStructureVisitor visitor)
		{
			visitor.VisitLinkedResource (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/ManifestResourceAttributes.cs
================================================
//
// ManigestResourceAttributes.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;

	[Flags]
	public enum ManifestResourceAttributes {
		VisibilityMask	= 0x0007,
		Public			= 0x0001,	// The resource is exported from the Assembly
		Private			= 0x0002	 // The resource is private to the Assembly
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/MarshalSpec.cs
================================================
//
// MarshalDesc.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;

	public class MarshalSpec {

		NativeType m_natIntr;
		IHasMarshalSpec m_container;

		public NativeType NativeIntrinsic {
			get { return m_natIntr; }
			set { m_natIntr = value; }
		}

		public IHasMarshalSpec Container {
			get { return m_container; }
			set { m_container = value; }
		}

		public MarshalSpec (NativeType natIntr, IHasMarshalSpec container)
		{
			m_natIntr = natIntr;
			m_container = container;
		}

		public virtual void Accept (IReflectionVisitor visitor)
		{
			visitor.VisitMarshalSpec (this);
		}
	}

	public sealed class ArrayMarshalSpec : MarshalSpec {

		NativeType m_elemType;
		int m_paramNum;
		int m_elemMult;
		int m_numElem;

		public NativeType ElemType {
			get { return m_elemType; }
			set { m_elemType = value; }
		}

		public int ParamNum {
			get { return m_paramNum; }
			set { m_paramNum = value; }
		}

		public int ElemMult {
			get { return m_elemMult; }
			set { m_elemMult = value; }
		}

		public int NumElem {
			get { return m_numElem; }
			set { m_numElem = value; }
		}

		public ArrayMarshalSpec (IHasMarshalSpec container) : base (NativeType.ARRAY, container)
		{
		}
	}

	public sealed class CustomMarshalerSpec : MarshalSpec {

		Guid m_guid;
		string m_unmanagedType;
		string m_managedType;
		string m_cookie;

		public Guid Guid {
			get { return m_guid; }
			set { m_guid = value; }
		}

		public String UnmanagedType {
			get { return m_unmanagedType; }
			set { m_unmanagedType = value; }
		}

		public string ManagedType {
			get { return m_managedType; }
			set { m_managedType = value; }
		}

		public string Cookie {
			get { return m_cookie; }
			set { m_cookie = value; }
		}

		public CustomMarshalerSpec (IHasMarshalSpec container) : base (NativeType.CUSTOMMARSHALER, container)
		{
		}
	}

	public sealed class SafeArraySpec : MarshalSpec {

		private VariantType m_elemType;

		public VariantType ElemType {
			get { return m_elemType; }
			set { m_elemType = value; }
		}

		public SafeArraySpec (IHasMarshalSpec container) : base (NativeType.SAFEARRAY, container)
		{
		}
	}

	public sealed class FixedArraySpec : MarshalSpec {

		private int m_numElem;
		private NativeType m_elemType;

		public int NumElem {
			get { return m_numElem; }
			set { m_numElem = value; }
		}

		public NativeType ElemType {
			get { return m_elemType; }
			set { m_elemType = value; }
		}

		public FixedArraySpec (IHasMarshalSpec container) : base (NativeType.FIXEDARRAY, container)
		{
		}
	}

	public sealed class FixedSysStringSpec : MarshalSpec {

		private int m_size;

		public int Size {
			get { return m_size; }
			set { m_size = value; }
		}

		public FixedSysStringSpec (IHasMarshalSpec container) : base (NativeType.FIXEDSYSSTRING, container)
		{
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/MemberReference.cs
================================================
//
// MemberReference.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using Mono.Cecil.Metadata;

	public abstract class MemberReference : IMemberReference {

		string m_name;
		TypeReference m_decType;
		MetadataToken m_token;

		public virtual string Name {
			get { return m_name; }
			set { m_name = value; }
		}

		public virtual TypeReference DeclaringType {
			get { return m_decType; }
			set { m_decType = value; }
		}

		public MetadataToken MetadataToken {
			get { return m_token; }
			set { m_token = value; }
		}

		public MemberReference (string name)
		{
			m_name = name;
		}

		public override string ToString ()
		{
			if (m_decType == null)
				return m_name;

			return string.Concat (m_decType.FullName, "::", m_name);
		}

		public virtual void Accept (IReflectionVisitor visitor)
		{
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/MemberReferenceCollection.cs
================================================
//
// MemberReferenceCollection.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Wed Sep 27 12:46:53 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;
	using System.Collections;

	using Mono.Cecil.Cil;

	public sealed class MemberReferenceCollection : CollectionBase, IReflectionVisitable {

		ModuleDefinition m_container;

		public MemberReference this [int index] {
			get { return List [index] as MemberReference; }
			set { List [index] = value; }
		}

		public ModuleDefinition Container {
			get { return m_container; }
		}

		public MemberReferenceCollection (ModuleDefinition container)
		{
			m_container = container;
		}

		public void Add (MemberReference value)
		{
			List.Add (value);
		}

		public bool Contains (MemberReference value)
		{
			return List.Contains (value);
		}

		public int IndexOf (MemberReference value)
		{
			return List.IndexOf (value);
		}

		public void Insert (int index, MemberReference value)
		{
			List.Insert (index, value);
		}

		public void Remove (MemberReference value)
		{
			List.Remove (value);
		}

		protected override void OnValidate (object o)
		{
			if (! (o is MemberReference))
				throw new ArgumentException ("Must be of type " + typeof (MemberReference).FullName);
		}

		public void Accept (IReflectionVisitor visitor)
		{
			visitor.VisitMemberReferenceCollection (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/MethodAttributes.cs
================================================
//
// MethodAttributes.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;

	[Flags]
	public enum MethodAttributes : ushort {
		MemberAccessMask	= 0x0007,
		Compilercontrolled	= 0x0000,	// Member not referenceable
		Private				= 0x0001,	// Accessible only by the parent type
		FamANDAssem			= 0x0002,	// Accessible by sub-types only in this Assembly
		Assem				= 0x0003,	// Accessibly by anyone in the Assembly
		Family				= 0x0004,	// Accessible only by type and sub-types
		FamORAssem			= 0x0005,	// Accessibly by sub-types anywhere, plus anyone in assembly
		Public				= 0x0006,	// Accessibly by anyone who has visibility to this scope

		Static				= 0x0010,	// Defined on type, else per instance
		Final				= 0x0020,	// Method may not be overridden
		Virtual				= 0x0040,	// Method is virtual
		HideBySig			= 0x0080,	// Method hides by name+sig, else just by name

		VtableLayoutMask	= 0x0100,	// Use this mask to retrieve vtable attributes
		ReuseSlot			= 0x0000,	// Method reuses existing slot in vtable
		NewSlot				= 0x0100,	// Method always gets a new slot in the vtable

		Abstract			= 0x0400,	// Method does not provide an implementation
		SpecialName			= 0x0800,	// Method is special

		// Interop Attributes
		PInvokeImpl			= 0x2000,	// Implementation is forwarded through PInvoke
		UnmanagedExport		= 0x0008,	// Reserved: shall be zero for conforming implementations

		// Additional flags
		RTSpecialName		= 0x1000,	// CLI provides 'special' behavior, depending upon the name of the method
		HasSecurity			= 0x4000,	// Method has security associate with it
		RequireSecObject	= 0x8000	 // Method calls another method containing security code
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/MethodCallingConvention.cs
================================================
//
// MethodCallingConvention.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;

	[Flags]
	public enum MethodCallingConvention : byte {
		Default		= 0x0,
		C			= 0x1,
		StdCall		= 0x2,
		ThisCall	= 0x3,
		FastCall	= 0x4,
		VarArg		= 0x5,
		Generic		= 0x10
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/MethodDefinition.cs
================================================
//
// MethodDefinition.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;

	using Mono.Cecil.Binary;
	using Mono.Cecil.Cil;
	using Mono.Cecil.Signatures;

	public sealed class MethodDefinition : MethodReference, IMemberDefinition,
		IHasSecurity, ICustomAttributeProvider {

		public const string Cctor = ".cctor";
		public const string Ctor = ".ctor";

		MethodAttributes m_attributes;
		MethodImplAttributes m_implAttrs;
		MethodSemanticsAttributes m_semAttrs;
		SecurityDeclarationCollection m_secDecls;
		CustomAttributeCollection m_customAttrs;

		ModuleDefinition m_module;

		MethodBody m_body;
		RVA m_rva;
		OverrideCollection m_overrides;
		PInvokeInfo m_pinvoke;
		ParameterDefinition m_this;

		public MethodAttributes Attributes {
			get { return m_attributes; }
			set { m_attributes = value; }
		}

		public MethodImplAttributes ImplAttributes {
			get { return m_implAttrs; }
			set { m_implAttrs = value; }
		}

		public MethodSemanticsAttributes SemanticsAttributes {
			get { return m_semAttrs; }
			set { m_semAttrs = value; }
		}

		public override TypeReference DeclaringType {
			get { return base.DeclaringType; }
			set {
				base.DeclaringType = value;
				TypeDefinition t = value as TypeDefinition;
				if (t != null)
					m_module = t.Module;
			}
		}

		public SecurityDeclarationCollection SecurityDeclarations {
			get {
				if (m_secDecls == null)
					m_secDecls = new SecurityDeclarationCollection (this);

				return m_secDecls;
			}
		}

		public CustomAttributeCollection CustomAttributes {
			get {
				if (m_customAttrs == null)
					m_customAttrs = new CustomAttributeCollection (this);

				return m_customAttrs;
			}
		}

		public RVA RVA {
			get { return m_rva; }
			set { m_rva = value; }
		}

		public MethodBody Body {
			get {
				LoadBody ();
				return m_body;
			}
			set { m_body = value; }
		}

		public PInvokeInfo PInvokeInfo {
			get { return m_pinvoke; }
			set { m_pinvoke = value; }
		}

		public OverrideCollection Overrides {
			get {
				if (m_overrides == null)
					m_overrides = new OverrideCollection (this);

				return m_overrides;
			}
		}

		public ParameterDefinition This
        {
			get { return m_this; }
            set { m_this = value; }
		}

		public bool IsAbstract {
			get { return (m_attributes & MethodAttributes.Abstract) != 0; }
			set {
				if (value)
					m_attributes |= MethodAttributes.Abstract;
				else
					m_attributes &= ~MethodAttributes.Abstract;
			}
		}

		public bool IsFinal {
			get { return (m_attributes & MethodAttributes.Final) != 0; }
			set {
				if (value)
					m_attributes |= MethodAttributes.Final;
				else
					m_attributes &= ~MethodAttributes.Final;
			}
		}

		public bool IsHideBySignature {
			get { return (m_attributes & MethodAttributes.HideBySig) != 0; }
			set {
				if (value)
					m_attributes |= MethodAttributes.HideBySig;
				else
					m_attributes &= ~MethodAttributes.HideBySig;
			}
		}

		public bool IsNewSlot {
			get { return (m_attributes & MethodAttributes.VtableLayoutMask) == MethodAttributes.NewSlot; }
			set {
				if (value)
					m_attributes |= (MethodAttributes.VtableLayoutMask & MethodAttributes.NewSlot);
				else
					m_attributes &= ~(MethodAttributes.VtableLayoutMask & MethodAttributes.NewSlot);
			}
		}

		public bool IsRuntimeSpecialName {
			get { return (m_attributes & MethodAttributes.RTSpecialName) != 0; }
			set {
				if (value)
					m_attributes |= MethodAttributes.RTSpecialName;
				else
					m_attributes &= ~MethodAttributes.RTSpecialName;
			}
		}

		public bool IsInternalCall {
			get { return MethodImplAttributes.InternalCall == (m_implAttrs & MethodImplAttributes.InternalCall); }
			set {
				if (value)
					m_implAttrs |= MethodImplAttributes.InternalCall;
				else
					m_implAttrs &= ~MethodImplAttributes.InternalCall;
			}
		}

		public bool IsRuntime {
			get { return MethodImplAttributes.Runtime == (m_implAttrs & MethodImplAttributes.Runtime); }
			set {
				if (value)
					m_implAttrs |= MethodImplAttributes.Runtime;
				else
					m_implAttrs &= ~MethodImplAttributes.Runtime;
			}
		}

		public bool IsSpecialName {
			get { return (m_attributes & MethodAttributes.SpecialName) != 0; }
			set {
				if (value)
					m_attributes |= MethodAttributes.SpecialName;
				else
					m_attributes &= ~MethodAttributes.SpecialName;
			}
		}

		public bool IsStatic {
			get { return (m_attributes & MethodAttributes.Static) != 0; }
			set {
				if (value)
					m_attributes |= MethodAttributes.Static;
				else
					m_attributes &= ~MethodAttributes.Static;
				this.HasThis = !value;
			}
		}

		public bool IsVirtual {
			get { return (m_attributes & MethodAttributes.Virtual) != 0; }
			set {
				if (value)
					m_attributes |= MethodAttributes.Virtual;
				else
					m_attributes &= ~MethodAttributes.Virtual;
			}
		}

		public bool IsConstructor
        {
			get { return this.IsRuntimeSpecialName && this.IsSpecialName && (this.Name == Cctor || this.Name == Ctor); }
		}

		public bool HasBody {
			get {
				return (m_attributes & MethodAttributes.Abstract) == 0 &&
					(m_attributes & MethodAttributes.PInvokeImpl) == 0 &&
					(m_implAttrs & MethodImplAttributes.InternalCall) == 0 &&
					(m_implAttrs & MethodImplAttributes.Native) == 0 &&
					(m_implAttrs & MethodImplAttributes.Unmanaged) == 0 &&
					(m_implAttrs & MethodImplAttributes.Runtime) == 0;
			}
		}

		public MethodDefinition (string name, RVA rva,
			MethodAttributes attrs, MethodImplAttributes implAttrs,
			bool hasThis, bool explicitThis, MethodCallingConvention callConv) :
			base (name, hasThis, explicitThis, callConv)
		{
			m_rva = rva;
			m_attributes = attrs;
			m_implAttrs = implAttrs;

			if (!IsStatic)
				m_this = new ParameterDefinition ("this", 0, (ParameterAttributes) 0, null);
		}

		internal MethodDefinition (string name, MethodAttributes attrs) : base (name)
		{
			m_attributes = attrs;

			this.HasThis = !this.IsStatic;
			if (!IsStatic)
				m_this = new ParameterDefinition ("this", 0, (ParameterAttributes) 0, null);
		}

		public MethodDefinition (string name, MethodAttributes attrs, TypeReference returnType) :
			this (name, attrs)
		{
			this.ReturnType.ReturnType = returnType;
		}

		internal void LoadBody ()
		{
			if (m_body == null && this.HasBody) {
				m_body = new MethodBody (this);
				if (m_module != null && m_rva != RVA.Zero)
					m_module.Controller.Reader.Code.VisitMethodBody (m_body);
			}
		}

		public MethodDefinition Clone ()
		{
			return Clone (this, new ImportContext (this));
		}

		internal static MethodDefinition Clone (MethodDefinition meth, ImportContext context)
		{
			MethodDefinition nm = new MethodDefinition(meth.Name, RVA.Zero, meth.Attributes, meth.ImplAttributes, meth.HasThis, meth.ExplicitThis, meth.CallingConvention);
			context.GenericContext.Method = nm;

			foreach (GenericParameter p in meth.GenericParameters)
				nm.GenericParameters.Add (GenericParameter.Clone (p, context));

			nm.ReturnType.ReturnType = context.Import (meth.ReturnType.ReturnType);

			if (meth.ReturnType.HasConstant)
				nm.ReturnType.Constant = meth.ReturnType.Constant;

			if (meth.ReturnType.MarshalSpec != null)
				nm.ReturnType.MarshalSpec = meth.ReturnType.MarshalSpec;

			foreach (CustomAttribute ca in meth.ReturnType.CustomAttributes)
				nm.ReturnType.CustomAttributes.Add (CustomAttribute.Clone (ca, context));
			if (meth.PInvokeInfo != null)
				nm.PInvokeInfo = meth.PInvokeInfo; // TODO: import module ?
			foreach (ParameterDefinition param in meth.Parameters)
				nm.Parameters.Add (ParameterDefinition.Clone (param, context));
			foreach (MethodReference ov in meth.Overrides)
				nm.Overrides.Add (context.Import (ov));
			foreach (CustomAttribute ca in meth.CustomAttributes)
				nm.CustomAttributes.Add (CustomAttribute.Clone (ca, context));
			foreach (SecurityDeclaration sec in meth.SecurityDeclarations)
				nm.SecurityDeclarations.Add (SecurityDeclaration.Clone (sec));

			if (meth.Body != null)
				nm.Body = MethodBody.Clone (meth.Body, nm, context);

			return nm;
		}
		public override void Accept (IReflectionVisitor visitor)
		{
			visitor.VisitMethodDefinition (this);

			this.GenericParameters.Accept (visitor);
			this.Parameters.Accept (visitor);

			if (this.PInvokeInfo != null)
				this.PInvokeInfo.Accept (visitor);

			this.SecurityDeclarations.Accept (visitor);
			this.Overrides.Accept (visitor);
			this.CustomAttributes.Accept (visitor);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/MethodDefinitionCollection.cs
================================================
//
// MethodDefinitionCollection.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Thu Sep 28 17:54:19 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;
	using System.Collections;

	using Mono.Cecil.Cil;

	public sealed class MethodDefinitionCollection : CollectionBase, IReflectionVisitable {

		TypeDefinition m_container;

		public MethodDefinition this [int index] {
			get { return List [index] as MethodDefinition; }
			set { List [index] = value; }
		}

		public TypeDefinition Container {
			get { return m_container; }
		}

		public MethodDefinitionCollection (TypeDefinition container)
		{
			m_container = container;
		}

		public void Add (MethodDefinition value)
		{
			if (!Contains (value))
				Attach (value);

			List.Add (value);
		}


		public new void Clear ()
		{
			foreach (MethodDefinition item in this)
				Detach (item);

			base.Clear ();
		}

		public bool Contains (MethodDefinition value)
		{
			return List.Contains (value);
		}

		public int IndexOf (MethodDefinition value)
		{
			return List.IndexOf (value);
		}

		public void Insert (int index, MethodDefinition value)
		{
			if (!this.Contains (value))
				Attach (value);

			List.Insert (index, value);
		}

		public void Remove (MethodDefinition value)
		{
			if (this.Contains (value))
				Detach (value);

			List.Remove (value);
		}


		public new void RemoveAt (int index)
		{
			Detach (this [index]);

			List.RemoveAt (index);
		}

		protected override void OnValidate (object o)
		{
			if (! (o is MethodDefinition))
				throw new ArgumentException ("Must be of type " + typeof (MethodDefinition).FullName);
		}

		public MethodDefinition [] GetMethod (string name)
		{
			ArrayList ret = new ArrayList ();
			foreach (MethodDefinition meth in this)
				if (meth.Name == name)
					ret.Add (meth);

			return ret.ToArray (typeof (MethodDefinition)) as MethodDefinition [];
		}

		internal MethodDefinition GetMethodInternal (string name, IList parameters)
		{
			foreach (MethodDefinition meth in this) {
				if (meth.Name != name || meth.Parameters.Count != parameters.Count)
					continue;

				bool match = true;
				for (int i = 0; i < parameters.Count; i++) {
					string pname;
					object param = parameters [i];
					if (param is Type)
						pname = ReflectionHelper.GetTypeSignature (param as Type);
					else if (param is TypeReference)
						pname = (param as TypeReference).FullName;
					else if (param is ParameterDefinition)
						pname = (param as ParameterDefinition).ParameterType.FullName;
					else
						throw new NotSupportedException ();

					if (meth.Parameters [i].ParameterType.FullName != pname) {
						match = false;
						break;
					}
				}

				if (match)
					return meth;
			}

			return null;
		}

		public MethodDefinition GetMethod (string name, Type [] parameters)
		{
			return GetMethodInternal (name, parameters);
		}

		public MethodDefinition GetMethod (string name, TypeReference [] parameters)
		{
			return GetMethodInternal (name, parameters);
		}

		public MethodDefinition GetMethod (string name, ParameterDefinitionCollection parameters)
		{
			return GetMethodInternal (name, parameters);
		}

		void Attach (MemberReference member)
		{
			if (member.DeclaringType != null)
				throw new ReflectionException ("Member already attached, clone it instead");

			member.DeclaringType = m_container;
		}

		void Detach (MemberReference member)
		{
			member.DeclaringType = null;
		}

		public void Accept (IReflectionVisitor visitor)
		{
			visitor.VisitMethodDefinitionCollection (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/MethodImplAttributes.cs
================================================
//
// MethodImplAttributes.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;

	[Flags]
	public enum MethodImplAttributes : ushort {
		CodeTypeMask		= 0x0003,

		IL					= 0x0000,	// Method impl is CIL
		Native				= 0x0001,	// Method impl is native
		OPTIL				= 0x0002,	// Reserved: shall be zero in conforming implementations
		Runtime				= 0x0003,	// Method impl is provided by the runtime

		ManagedMask			= 0x0004,	// Flags specifying whether the code is managed or unmanaged
		Unmanaged			= 0x0004,	// Method impl is unmanaged, otherwise managed
		Managed				= 0x0000,	// Method impl is managed

		// Implementation info and interop
		ForwardRef			= 0x0010,	// Indicates method is defined; used primarily in merge scenarios
		PreserveSig			= 0x0080,	// Reserved: conforming implementations may ignore
		InternalCall		= 0x1000,	// Reserved: shall be zero in conforming implementations
		Synchronized		= 0x0020,	// Method is single threaded through the body
		NoInlining			= 0x0008,	// Method may not be inlined
		MaxMethodImplVal	= 0xffff	 // Range check value
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/MethodReference.cs
================================================
//
// MethodReference.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 - 2007 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System.Text;

	public class MethodReference : MemberReference, IMethodSignature, IGenericParameterProvider {
	
		static public System.Collections.Generic.List<MethodReference> AllReferences = new System.Collections.Generic.List<MethodReference>();

		ParameterDefinitionCollection m_parameters;
		MethodReturnType m_returnType;

		bool m_hasThis;
		bool m_explicitThis;
		MethodCallingConvention m_callConv;
		GenericParameterCollection m_genparams;

		public virtual bool HasThis {
			get { return m_hasThis; }
			set { m_hasThis = value; }
		}

		public virtual bool ExplicitThis {
			get { return m_explicitThis; }
			set { m_explicitThis = value; }
		}

		public virtual MethodCallingConvention CallingConvention {
			get { return m_callConv; }
			set { m_callConv = value; }
		}

		public virtual ParameterDefinitionCollection Parameters {
			get {
				if (m_parameters == null)
					m_parameters = new ParameterDefinitionCollection (this);
				return m_parameters;
			}
		}

		public GenericParameterCollection GenericParameters {
			get {
				if (m_genparams == null)
					m_genparams = new GenericParameterCollection (this);
				return m_genparams;
			}
		}

		public virtual MethodReturnType ReturnType {
			get { return m_returnType;}
			set { m_returnType = value; }
		}

		internal MethodReference (string name, bool hasThis,
			bool explicitThis, MethodCallingConvention callConv) : this (name)
		{
			m_parameters = new ParameterDefinitionCollection (this);
			m_hasThis = hasThis;
			m_explicitThis = explicitThis;
			m_callConv = callConv;

			AllReferences.Add(this);
		}

		internal MethodReference (string name) : base (name)
		{
			m_returnType = new MethodReturnType (null);

			AllReferences.Add(this);
		}

		public MethodReference (string name,
			TypeReference declaringType, TypeReference returnType,
			bool hasThis, bool explicitThis, MethodCallingConvention callConv) :
			this (name, hasThis, explicitThis, callConv)
		{
			this.DeclaringType = declaringType;
			this.ReturnType.ReturnType = returnType;
		}

		public int GetSentinel ()
		{
			for (int i = 0; i < Parameters.Count; i++)
				if (Parameters [i].ParameterType is SentinelType)
					return i;

			return -1;
		}

		public override string ToString ()
		{
			StringBuilder sb = new StringBuilder ();
			sb.Append (m_returnType.ReturnType.FullName);
			sb.Append (" ");
			sb.Append (base.ToString ());
			sb.Append ("(");
			for (int i = 0; i < this.Parameters.Count; i++) {
				sb.Append (this.Parameters [i].ParameterType.FullName);
				if (i < this.Parameters.Count - 1)
					sb.Append (",");
			}
			sb.Append (")");
			return sb.ToString ();
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/MethodReturnType.cs
================================================
//
// MethodReturnType.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System.Reflection;

	using Mono.Cecil.Metadata;

	public sealed class MethodReturnType : ICustomAttributeProvider, IHasMarshalSpec, IHasConstant {

		MethodReference m_method;
		ParameterDefinition m_param;

		TypeReference m_returnType;

		public MethodReference Method {
			get { return m_method; }
			set { m_method = value; }
		}

		public TypeReference ReturnType {
			get { return m_returnType; }
			set { m_returnType = value; }
		}

		internal ParameterDefinition Parameter {
			get { return m_param; }
			set { m_param = value; }
		}

		public MetadataToken MetadataToken {
			get { return m_param.MetadataToken; }
			set { m_param.MetadataToken = value; }
		}

		public CustomAttributeCollection CustomAttributes {
			get {
				if (m_param == null) {
					m_param = new ParameterDefinition (
						string.Empty, 0, (ParameterAttributes) 0, m_returnType);
					m_param.Method = m_method;
				}

				return m_param.CustomAttributes;
			}
		}

		public bool HasConstant {
			get {
				if (m_param == null)
					return false;

				return m_param.HasConstant;
			}
		}

		public object Constant {
			get {
				if (m_param == null)
					return null;

				return m_param.Constant;
			}
			set {
				m_param.Constant = value;
			}
		}

		public MarshalSpec MarshalSpec {
			get {
				if (m_param == null)
					return null;

				return m_param.MarshalSpec;
			}
			set { m_param.MarshalSpec = value; }
		}

		public MethodReturnType (TypeReference retType)
		{
			m_returnType = retType;
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/MethodSemanticsAttributes.cs
================================================
//
// MethodSemanticsAttributes.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;

	[Flags]
	public enum MethodSemanticsAttributes : ushort {
		Setter		= 0x0001,	// Setter for property
		Getter		= 0x0002,	// Getter for property
		Other		= 0x0004,	// Other method for property or event
		AddOn		= 0x0008,	// AddOn method for event
		RemoveOn	= 0x0010,	// RemoveOn method for event
		Fire		= 0x0020	 // Fire method for event
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/MethodSpecification.cs
================================================
//
// MethodSpecification.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;

	public abstract class MethodSpecification : MethodReference {

		MethodReference m_elementMethod;

		public MethodReference ElementMethod {
			get { return m_elementMethod; }
			set { m_elementMethod = value; }
		}

		public override string Name {
			get { return m_elementMethod.Name; }
			set { throw new InvalidOperationException (); }
		}

		public override MethodCallingConvention CallingConvention {
			get { return m_elementMethod.CallingConvention; }
			set { throw new InvalidOperationException (); }
		}

		public override bool HasThis {
			get { return m_elementMethod.HasThis; }
			set { throw new InvalidOperationException (); }
		}

		public override bool ExplicitThis {
			get { return m_elementMethod.ExplicitThis; }
			set { throw new InvalidOperationException (); }
		}

		public override MethodReturnType ReturnType {
			get { return m_elementMethod.ReturnType; }
			set { throw new InvalidOperationException (); }
		}

		public override TypeReference DeclaringType {
			get { return m_elementMethod.DeclaringType; }
			set { throw new InvalidOperationException (); }
		}

		public override ParameterDefinitionCollection Parameters {
			get { return m_elementMethod.Parameters; }
		}

		internal MethodSpecification (MethodReference elemMethod) : base (string.Empty)
		{
			m_elementMethod = elemMethod;
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/Modifiers.cs
================================================
//
// Modifiers.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	public abstract class ModType : TypeSpecification {

		TypeReference m_modifierType;

		public TypeReference ModifierType {
			get { return m_modifierType; }
			set { m_modifierType = value; }
		}

		public ModType (TypeReference elemType, TypeReference modType) : base (elemType)
		{
			m_modifierType = modType;
		}
	}

	public sealed class ModifierOptional : ModType {

		public ModifierOptional (TypeReference elemType, TypeReference modType) : base (elemType, modType)
		{
		}

		public override string Name
		{
			get { return string.Concat (base.Name, Suffix ()); }
		}

		public override string FullName
		{
			get { return string.Concat (base.FullName, Suffix ()); }
		}

		string Suffix ()
		{
			return string.Concat (" modopt(", this.ModifierType.FullName, ")");
		}
	}

	public sealed class ModifierRequired : ModType {

		public ModifierRequired (TypeReference elemType, TypeReference modType) : base (elemType, modType)
		{
		}

		public override string Name
		{
			get { return string.Concat (base.Name, Suffix ()); }
		}

		public override string FullName
		{
			get { return string.Concat (base.FullName, Suffix ()); }
		}

		string Suffix ()
		{
			return string.Concat (" modreq(", this.ModifierType.FullName, ")");
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/ModuleDefinition.cs
================================================
//
// ModuleDefinition.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;
	using SR = System.Reflection;
	using SS = System.Security;
	using SSP = System.Security.Permissions;
	using System.Text;

	using Mono.Cecil.Cil;
	using Mono.Cecil.Binary;
	using Mono.Cecil.Metadata;

	public sealed class ModuleDefinition : ModuleReference, ICustomAttributeProvider, IMetadataScope,
		IReflectionStructureVisitable, IReflectionVisitable {

		Guid m_mvid;
		bool m_main;
		bool m_manifestOnly;

		AssemblyNameReferenceCollection m_asmRefs;
		ModuleReferenceCollection m_modRefs;
		ResourceCollection m_res;
		TypeDefinitionCollection m_types;
		TypeReferenceCollection m_refs;
		ExternTypeCollection m_externs;
		MemberReferenceCollection m_members;
		CustomAttributeCollection m_customAttrs;

		AssemblyDefinition m_asm;
		Image m_image;

		ImageReader m_imgReader;
		ReflectionController m_controller;
		SecurityDeclarationReader m_secReader;

		public Guid Mvid {
			get { return m_mvid; }
			set { m_mvid = value; }
		}

		public bool Main {
			get { return m_main; }
			set { m_main = value; }
		}

		public AssemblyNameReferenceCollection AssemblyReferences {
			get { return m_asmRefs; }
		}

		public ModuleReferenceCollection ModuleReferences {
			get { return m_modRefs; }
		}

		public ResourceCollection Resources {
			get { return m_res; }
		}

		public TypeDefinitionCollection Types {
			get { return m_types; }
		}

		public TypeReferenceCollection TypeReferences {
			get { return m_refs; }
		}

		public MemberReferenceCollection MemberReferences {
			get { return m_members; }
		}

		public ExternTypeCollection ExternTypes {
			get {
				if (m_externs == null)
					m_externs = new ExternTypeCollection (this);

				return m_externs;
			}
		}

		public CustomAttributeCollection CustomAttributes {
			get {
				if (m_customAttrs == null)
					m_customAttrs = new CustomAttributeCollection (this);

				return m_customAttrs;
			}
		}

		public AssemblyDefinition Assembly {
			get { return m_asm; }
		}

		internal ReflectionController Controller {
			get { return m_controller; }
		}

		internal ImageReader ImageReader {
			get { return m_imgReader; }
		}

		public Image Image {
			get { return m_image; }
			set {
				m_image = value;
				m_secReader = null;
			}
		}

		public ModuleDefinition (string name, AssemblyDefinition asm) :
			this (name, asm, null, false)
		{
		}

		public ModuleDefinition (string name, AssemblyDefinition asm, bool main) :
			this (name, asm, null, main)
		{
		}

		internal ModuleDefinition (string name, AssemblyDefinition asm, StructureReader reader) :
			this (name, asm, reader, false)
		{
		}

		internal ModuleDefinition (string name, AssemblyDefinition asm, StructureReader reader, bool main) : base (name)
		{
			if (asm == null)
				throw new ArgumentNullException ("asm");
			if (name == null || name.Length == 0)
				throw new ArgumentNullException ("name");

			m_asm = asm;
			m_main = main;
#if !CF_1_0
			m_mvid = Guid.NewGuid ();
#endif
			if (reader != null) {
				m_image = reader.Image;
				m_imgReader = reader.ImageReader;
				m_manifestOnly = reader.ManifestOnly;
			} else
				m_image = Image.CreateImage ();

			m_modRefs = new ModuleReferenceCollection (this);
			m_asmRefs = new AssemblyNameReferenceCollection (this);
			m_res = new ResourceCollection (this);
			m_types = new TypeDefinitionCollection (this);
			m_refs = new TypeReferenceCollection (this);
			m_members = new MemberReferenceCollection (this);

			m_controller = new ReflectionController (this);
		}

		public IMetadataTokenProvider LookupByToken (MetadataToken token)
		{
			return m_controller.Reader.LookupByToken (token);
		}

		public IMetadataTokenProvider LookupByToken (TokenType table, int rid)
		{
			return LookupByToken (new MetadataToken (table, (uint) rid));
		}

		void CheckContext (TypeDefinition context)
		{
			if (context == null)
				throw new ArgumentNullException ("context");
			if (context.Module != this)
				throw new ArgumentException ("The context parameter does not belongs to this module");
			if (context.GenericParameters.Count == 0)
				throw new ArithmeticException ("The context parameter is not a generic type");
		}

		ImportContext GetContext ()
		{
			return new ImportContext (m_controller.Helper);
		}

		ImportContext GetContext (TypeDefinition context)
		{
			return new ImportContext (m_controller.Helper, context);
		}

		public TypeReference Import (Type type)
		{
			if (type == null)
				throw new ArgumentNullException ("type");

			return m_controller.Helper.ImportSystemType (type, GetContext ());
		}

		public TypeReference Import (Type type, TypeDefinition context)
		{
			if (type == null)
				throw new ArgumentNullException ("type");
			CheckContext (context);

			return m_controller.Helper.ImportSystemType (type, GetContext (context));
		}

		public MethodReference Import (SR.MethodBase meth)
		{
			if (meth == null)
				throw new ArgumentNullException ("meth");

			if (meth is SR.ConstructorInfo)
				return m_controller.Helper.ImportConstructorInfo (
					meth as SR.ConstructorInfo, GetContext ());
			else
				return m_controller.Helper.ImportMethodInfo (
					meth as SR.MethodInfo, GetContext ());
		}

		public MethodReference Import (SR.MethodBase meth, TypeDefinition context)
		{
			if (meth == null)
				throw new ArgumentNullException ("meth");
			CheckContext (context);

			if (meth is SR.ConstructorInfo)
				return m_controller.Helper.ImportConstructorInfo (
					meth as SR.ConstructorInfo, GetContext (context));
			else
				return m_controller.Helper.ImportMethodInfo (
					meth as SR.MethodInfo, GetContext (context));
		}

		public FieldReference Import (SR.FieldInfo field)
		{
			if (field == null)
				throw new ArgumentNullException ("field");

			return m_controller.Helper.ImportFieldInfo (field, GetContext ());
		}

		public FieldReference Import (SR.FieldInfo field, TypeDefinition context)
		{
			if (field == null)
				throw new ArgumentNullException ("field");
			CheckContext (context);

			return m_controller.Helper.ImportFieldInfo (field, GetContext (context));
		}

		public TypeReference Import (TypeReference type)
		{
			if (type == null)
				throw new ArgumentNullException ("type");

			return m_controller.Helper.ImportTypeReference (type, GetContext ());
		}

		public TypeReference Import (TypeReference type, TypeDefinition context)
		{
			if (type == null)
				throw new ArgumentNullException ("type");
			CheckContext (context);

			return m_controller.Helper.ImportTypeReference (type, GetContext (context));
		}

		public MethodReference Import (MethodReference meth)
		{
			if (meth == null)
				throw new ArgumentNullException ("meth");

			return m_controller.Helper.ImportMethodReference (meth, GetContext ());
		}

		public MethodReference Import (MethodReference meth, TypeDefinition context)
		{
			if (meth == null)
				throw new ArgumentNullException ("meth");
			CheckContext (context);

			return m_controller.Helper.ImportMethodReference (meth, GetContext (context));
		}

		public FieldReference Import (FieldReference field)
		{
			if (field == null)
				throw new ArgumentNullException ("field");

			return m_controller.Helper.ImportFieldReference (field, GetContext ());
		}

		public FieldReference Import (FieldReference field, TypeDefinition context)
		{
			if (field == null)
				throw new ArgumentNullException ("field");
			CheckContext (context);

			return m_controller.Helper.ImportFieldReference (field, GetContext (context));
		}

		public TypeDefinition Inject (TypeDefinition type)
		{
			if (type == null)
				throw new ArgumentNullException ("type");

			return m_controller.Helper.ImportTypeDefinition (type, GetContext (type));
		}

		public TypeDefinition Inject (TypeDefinition type, TypeDefinition context)
		{
			if (type == null)
				throw new ArgumentNullException ("type");
			CheckContext (context);

			return m_controller.Helper.ImportTypeDefinition (type, GetContext (context));
		}

		public MethodDefinition Inject (MethodDefinition meth)
		{
			if (meth == null)
				throw new ArgumentNullException ("meth");

			return m_controller.Helper.ImportMethodDefinition (meth, GetContext ());
		}

		public MethodDefinition Inject (MethodDefinition meth, TypeDefinition context)
		{
			if (meth == null)
				throw new ArgumentNullException ("meth");
			CheckContext (context);

			return m_controller.Helper.ImportMethodDefinition (meth, GetContext (context));
		}

		public FieldDefinition Inject (FieldDefinition field)
		{
			if (field == null)
				throw new ArgumentNullException ("field");

			return m_controller.Helper.ImportFieldDefinition (field, GetContext ());
		}

		public FieldDefinition Inject (FieldDefinition field, TypeDefinition context)
		{
			if (field == null)
				throw new ArgumentNullException ("field");
			CheckContext (context);

			return m_controller.Helper.ImportFieldDefinition (field, GetContext (context));
		}

		public void FullLoad ()
		{
			if (m_manifestOnly)
				m_controller.Reader.VisitModuleDefinition (this);

			foreach (TypeDefinition type in this.Types) {
				foreach (MethodDefinition meth in type.Methods)
					meth.LoadBody ();
				foreach (MethodDefinition ctor in type.Constructors)
					ctor.LoadBody ();
			}
		}

		public void LoadSymbols ()
		{
			m_controller.Reader.SymbolReader = SymbolStoreHelper.GetReader (this);
		}

		public void LoadSymbols (ISymbolReader reader)
		{
			m_controller.Reader.SymbolReader = reader;
		}

		public void SaveSymbols ()
		{
			m_controller.Writer.SaveSymbols = true;
		}

		public void SaveSymbols (ISymbolWriter writer)
		{
			SaveSymbols ();
			m_controller.Writer.SymbolWriter = writer;
		}

		public void SaveSymbols (string outputDirectory)
		{
			SaveSymbols ();
			m_controller.Writer.OutputFile = outputDirectory;
		}

		public void SaveSymbols (string outputDirectory, ISymbolWriter writer)
		{
			SaveSymbols (outputDirectory);
			m_controller.Writer.SymbolWriter = writer;
		}

		public byte [] GetAsByteArray (CustomAttribute ca)
		{
			CustomAttribute customAttr = ca;
			if (!ca.Resolved)
				if (customAttr.Blob != null)
					return customAttr.Blob;
				else
					return new byte [0];

			return m_controller.Writer.SignatureWriter.CompressCustomAttribute (
				m_controller.Writer.GetCustomAttributeSig (ca), ca.Constructor);
		}

		public byte [] GetAsByteArray (SecurityDeclaration dec)
		{
			// TODO - add support for 2.0 format
			// note: the 1.x format is still supported in 2.0 so this isn't an immediate problem
			if (!dec.Resolved)
				return dec.Blob;

#if !CF_1_0 && !CF_2_0
			if (dec.PermissionSet != null)
				return Encoding.Unicode.GetBytes (dec.PermissionSet.ToXml ().ToString ());
#endif

			return new byte [0];
		}

		public CustomAttribute FromByteArray (MethodReference ctor, byte [] data)
		{
			return m_controller.Reader.GetCustomAttribute (ctor, data);
		}

		public SecurityDeclaration FromByteArray (SecurityAction action, byte [] declaration)
		{
			if (m_secReader == null)
				m_secReader = new SecurityDeclarationReader (Image.MetadataRoot, m_controller.Reader);
			return m_secReader.FromByteArray (action, declaration);
		}

		public override void Accept (IReflectionStructureVisitor visitor)
		{
			visitor.VisitModuleDefinition (this);

			this.AssemblyReferences.Accept (visitor);
			this.ModuleReferences.Accept (visitor);
			this.Resources.Accept (visitor);
		}

		public void Accept (IReflectionVisitor visitor)
		{
			visitor.VisitModuleDefinition (this);

			this.Types.Accept (visitor);
			this.TypeReferences.Accept (visitor);
		}

		public override string ToString ()
		{
			string s = (m_main ? "(main), Mvid=" : "Mvid=");
			return s + m_mvid.ToString ();
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/ModuleDefinitionCollection.cs
================================================
//
// ModuleDefinitionCollection.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Wed Sep 27 12:46:54 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;
	using System.Collections;

	using Mono.Cecil.Cil;

	public sealed class ModuleDefinitionCollection : CollectionBase, IReflectionStructureVisitable {

		AssemblyDefinition m_container;

		public ModuleDefinition this [int index] {
			get { return List [index] as ModuleDefinition; }
			set { List [index] = value; }
		}

		public AssemblyDefinition Container {
			get { return m_container; }
		}

		public ModuleDefinitionCollection (AssemblyDefinition container)
		{
			m_container = container;
		}

		public void Add (ModuleDefinition value)
		{
			List.Add (value);
		}

		public bool Contains (ModuleDefinition value)
		{
			return List.Contains (value);
		}

		public int IndexOf (ModuleDefinition value)
		{
			return List.IndexOf (value);
		}

		public void Insert (int index, ModuleDefinition value)
		{
			List.Insert (index, value);
		}

		public void Remove (ModuleDefinition value)
		{
			List.Remove (value);
		}

		protected override void OnValidate (object o)
		{
			if (! (o is ModuleDefinition))
				throw new ArgumentException ("Must be of type " + typeof (ModuleDefinition).FullName);
		}

		public void Accept (IReflectionStructureVisitor visitor)
		{
			visitor.VisitModuleDefinitionCollection (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/ModuleReference.cs
================================================
//
// ModuleReference.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using Mono.Cecil;
	using Mono.Cecil.Metadata;

	public class ModuleReference : IMetadataScope, IReflectionStructureVisitable {

		string m_name;
		MetadataToken m_token;

		public string Name {
			get { return m_name; }
			set { m_name = value; }
		}

		public MetadataToken MetadataToken {
			get { return m_token; }
			set { m_token = value; }
		}

		public ModuleReference (string name)
		{
			m_name = name;
		}

		public virtual void Accept (IReflectionStructureVisitor visitor)
		{
			visitor.VisitModuleReference (this);
		}
	}
}




================================================
File: DeConfuser/MonoCecil/Mono.Cecil/ModuleReferenceCollection.cs
================================================
//
// ModuleReferenceCollection.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Wed Sep 27 12:46:53 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;
	using System.Collections;

	using Mono.Cecil.Cil;

	public sealed class ModuleReferenceCollection : CollectionBase, IReflectionStructureVisitable {

		ModuleDefinition m_container;

		public ModuleReference this [int index] {
			get { return List [index] as ModuleReference; }
			set { List [index] = value; }
		}

		public ModuleDefinition Container {
			get { return m_container; }
		}

		public ModuleReferenceCollection (ModuleDefinition container)
		{
			m_container = container;
		}

		public void Add (ModuleReference value)
		{
			List.Add (value);
		}

		public bool Contains (ModuleReference value)
		{
			return List.Contains (value);
		}

		public int IndexOf (ModuleReference value)
		{
			return List.IndexOf (value);
		}

		public void Insert (int index, ModuleReference value)
		{
			List.Insert (index, value);
		}

		public void Remove (ModuleReference value)
		{
			List.Remove (value);
		}

		protected override void OnValidate (object o)
		{
			if (! (o is ModuleReference))
				throw new ArgumentException ("Must be of type " + typeof (ModuleReference).FullName);
		}

		public void Accept (IReflectionStructureVisitor visitor)
		{
			visitor.VisitModuleReferenceCollection (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/NativeType.cs
================================================
//
// NativeType.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	public enum NativeType {
		NONE = 0x66,

		BOOLEAN = 0x02,
		I1 = 0x03,
		U1 = 0x04,
		I2 = 0x05,
		U2 = 0x06,
		I4 = 0x07,
		U4 = 0x08,
		I8 = 0x09,
		U8 = 0x0a,
		R4 = 0x0b,
		R8 = 0x0c,
		LPSTR = 0x14,
		INT = 0x1f,
		UINT = 0x20,
		FUNC = 0x26,
		ARRAY = 0x2a,

		// Msft specific
		CURRENCY = 0x0f,
		BSTR = 0x13,
		LPWSTR = 0x15,
		LPTSTR = 0x16,
		FIXEDSYSSTRING = 0x17,
		IUNKNOWN = 0x19,
		IDISPATCH = 0x1a,
		STRUCT = 0x1b,
		INTF = 0x1c,
		SAFEARRAY = 0x1d,
		FIXEDARRAY = 0x1e,
		BYVALSTR = 0x22,
		ANSIBSTR = 0x23,
		TBSTR = 0x24,
		VARIANTBOOL = 0x25,
		ASANY = 0x28,
		LPSTRUCT = 0x2b,
		CUSTOMMARSHALER = 0x2c,
		ERROR = 0x2d,
		MAX = 0x50
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/NestedTypeCollection.cs
================================================
//
// NestedTypeCollection.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Wed Sep 27 01:22:48 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;
	using System.Collections;

	using Mono.Cecil.Cil;

	public sealed class NestedTypeCollection : CollectionBase, IReflectionVisitable {

		TypeDefinition m_container;

		public TypeDefinition this [int index] {
			get { return List [index] as TypeDefinition; }
			set { List [index] = value; }
		}

		public TypeDefinition Container {
			get { return m_container; }
		}

		public NestedTypeCollection (TypeDefinition container)
		{
			m_container = container;
		}

		public void Add (TypeDefinition value)
		{
			if (!Contains (value))
				Attach (value);

			List.Add (value);
		}

		public new void Clear ()
		{
			foreach (TypeDefinition item in this)
				Detach (item);

			base.Clear ();
		}

		public bool Contains (TypeDefinition value)
		{
			return List.Contains (value);
		}

		public int IndexOf (TypeDefinition value)
		{
			return List.IndexOf (value);
		}

		public void Insert (int index, TypeDefinition value)
		{
			if (!this.Contains (value))
				Attach (value);

			List.Insert (index, value);
		}

		public void Remove (TypeDefinition value)
		{
			if (this.Contains (value))
				Detach (value);

			List.Remove (value);
		}

		public new void RemoveAt (int index)
		{
			Detach (this [index]);

			List.RemoveAt (index);
		}

		protected override void OnValidate (object o)
		{
			if (! (o is TypeDefinition))
				throw new ArgumentException ("Must be of type " + typeof (TypeDefinition).FullName);
		}

		void Attach (MemberReference member)
		{
			if (member.DeclaringType != null)
				throw new ReflectionException ("Member already attached, clone it instead");

			member.DeclaringType = m_container;
		}

		void Detach (MemberReference member)
		{
			member.DeclaringType = null;
		}

		public void Accept (IReflectionVisitor visitor)
		{
			visitor.VisitNestedTypeCollection (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/OverrideCollection.cs
================================================
//
// OverrideCollection.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Wed Sep 27 12:46:53 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;
	using System.Collections;

	using Mono.Cecil.Cil;

	public sealed class OverrideCollection : CollectionBase, IReflectionVisitable {

		MethodDefinition m_container;

		public MethodReference this [int index] {
			get { return List [index] as MethodReference; }
			set { List [index] = value; }
		}

		public MethodDefinition Container {
			get { return m_container; }
		}

		public OverrideCollection (MethodDefinition container)
		{
			m_container = container;
		}

		public void Add (MethodReference value)
		{
			List.Add (value);
		}

		public bool Contains (MethodReference value)
		{
			return List.Contains (value);
		}

		public int IndexOf (MethodReference value)
		{
			return List.IndexOf (value);
		}

		public void Insert (int index, MethodReference value)
		{
			List.Insert (index, value);
		}

		public void Remove (MethodReference value)
		{
			List.Remove (value);
		}

		protected override void OnValidate (object o)
		{
			if (! (o is MethodReference))
				throw new ArgumentException ("Must be of type " + typeof (MethodReference).FullName);
		}

		public void Accept (IReflectionVisitor visitor)
		{
			visitor.VisitOverrideCollection (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/PInvokeAttributes.cs
================================================
//
// PInvokeAttributes.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;

	[Flags]
	public enum PInvokeAttributes : ushort {
		NoMangle			= 0x0001,	// PInvoke is to use the member name as specified

		// Character set
		CharSetMask			= 0x0006,
		CharSetNotSpec		= 0x0000,
		CharSetAnsi			= 0x0002,
		CharSetUnicode		= 0x0004,
		CharSetAuto			= 0x0006,
		SupportsLastError	= 0x0040,	// Information about target function. Not relevant for fields

		// Calling convetion
		CallConvMask		= 0x0700,
		CallConvWinapi		= 0x0100,
		CallConvCdecl		= 0x0200,
		CallConvStdCall		= 0x0300,
		CallConvThiscall	= 0x0400,
		CallConvFastcall	= 0x0500
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/PInvokeInfo.cs
================================================
//
// PInvokeInfo.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	public sealed class PInvokeInfo : IReflectionVisitable {

		MethodDefinition m_meth;

		PInvokeAttributes m_attributes;
		string m_entryPoint;
		ModuleReference m_module;

		public MethodDefinition Method {
			get { return m_meth; }
		}

		public PInvokeAttributes Attributes {
			get { return m_attributes; }
			set { m_attributes = value; }
		}

		public string EntryPoint {
			get { return m_entryPoint; }
			set { m_entryPoint = value; }
		}

		public ModuleReference Module {
			get { return m_module; }
			set { m_module = value; }
		}

		public PInvokeInfo (MethodDefinition meth)
		{
			m_meth = meth;
		}

		public PInvokeInfo (MethodDefinition meth, PInvokeAttributes attrs,
			string entryPoint, ModuleReference mod) : this (meth)
		{
			m_attributes = attrs;
			m_entryPoint = entryPoint;
			m_module = mod;
		}

		public void Accept (IReflectionVisitor visitor)
		{
			visitor.VisitPInvokeInfo (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/ParameterAttributes.cs
================================================
//
// ParameterAttributes.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;

	[Flags]
	public enum ParameterAttributes : ushort {
		In					= 0x0001,	// Param is [In]
		Out					= 0x0002,	// Param is [Out]
		Optional			= 0x0010,	// Param is optional
		HasDefault			= 0x1000,	// Param has default value
		HasFieldMarshal		= 0x2000,	// Param has field marshal
		Unused				= 0xcfe0	 // Reserved: shall be zero in a conforming implementation
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/ParameterDefinition.cs
================================================
//
// ParameterDefinition.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 - 2007 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	public sealed class ParameterDefinition : ParameterReference, IHasMarshalSpec,
		IMetadataTokenProvider, ICustomAttributeProvider, IHasConstant {

		ParameterAttributes m_attributes;

		bool m_hasConstant;
		object m_const;

		MethodReference m_method;
		CustomAttributeCollection m_customAttrs;

		MarshalSpec m_marshalDesc;

		public ParameterAttributes Attributes {
			get { return m_attributes; }
			set { m_attributes = value; }
		}

		public bool HasConstant {
			get { return m_hasConstant; }
		}

		public object Constant {
			get { return m_const; }
			set {
				m_hasConstant = true;
				m_const = value;
			}
		}

		public MethodReference Method {
			get { return m_method; }
			set { m_method = value; }
		}

		public CustomAttributeCollection CustomAttributes {
			get {
				if (m_customAttrs == null)
					m_customAttrs = new CustomAttributeCollection (this);

				return m_customAttrs;
			}
		}

		public MarshalSpec MarshalSpec {
			get { return m_marshalDesc; }
			set { m_marshalDesc = value; }
		}

		public ParameterDefinition (TypeReference paramType) :
			this (string.Empty, -1, (ParameterAttributes) 0, paramType)
		{
		}

		public ParameterDefinition (string name, int seq, ParameterAttributes attrs, TypeReference paramType) : base (name, seq, paramType)
		{
			m_attributes = attrs;
		}

		public ParameterDefinition Clone ()
		{
			return Clone (this, new ImportContext (null, m_method));
		}

		internal static ParameterDefinition Clone (ParameterDefinition param, ImportContext context)
		{
			ParameterDefinition np = new ParameterDefinition (
				param.Name,
				param.Sequence,
				param.Attributes,
				context.Import (param.ParameterType));

			if (param.HasConstant)
				np.Constant = param.Constant;

			if (param.MarshalSpec != null)
				np.MarshalSpec = param.MarshalSpec;

			foreach (CustomAttribute ca in param.CustomAttributes)
				np.CustomAttributes.Add (CustomAttribute.Clone (ca, context));

			return np;
		}

		public override void Accept (IReflectionVisitor visitor)
		{
			visitor.VisitParameterDefinition (this);

			if (this.MarshalSpec != null)
				this.MarshalSpec.Accept (visitor);

			this.CustomAttributes.Accept (visitor);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/ParameterDefinitionCollection.cs
================================================
//
// ParameterDefinitionCollection.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Wed Sep 27 12:46:52 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;
	using System.Collections;

	using Mono.Cecil.Cil;

	public sealed class ParameterDefinitionCollection : CollectionBase, IReflectionVisitable {

		IMemberReference m_container;

		public ParameterDefinition this [int index] {
			get { return List [index] as ParameterDefinition; }
			set { List [index] = value; }
		}

		public IMemberReference Container {
			get { return m_container; }
		}

		public ParameterDefinitionCollection (IMemberReference container)
		{
			m_container = container;
		}

        public void Add(ParameterDefinition value)
        {
            List.Add(value);
        }
        public void AddRange(ParameterDefinitionCollection value)
        {
            foreach (ParameterDefinition parameter in value)
                Add(parameter);
        }
        public void AddRange(ParameterDefinition[] value)
        {
            foreach (ParameterDefinition parameter in value)
                Add(parameter);
        }

		public bool Contains (ParameterDefinition value)
		{
			return List.Contains (value);
		}

		public int IndexOf (ParameterDefinition value)
		{
			return List.IndexOf (value);
		}

		public void Insert (int index, ParameterDefinition value)
		{
			List.Insert (index, value);
		}

		public void Remove (ParameterDefinition value)
		{
			List.Remove (value);
		}

		protected override void OnValidate (object o)
		{
			if (! (o is ParameterDefinition))
				throw new ArgumentException ("Must be of type " + typeof (ParameterDefinition).FullName);
		}

		public void Accept (IReflectionVisitor visitor)
		{
			visitor.VisitParameterDefinitionCollection (this);
		}

        public ParameterDefinition[] ToArray()
        {
            return (ParameterDefinition[])this.InnerList.ToArray();
        }
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/ParameterReference.cs
================================================
//
// ParameterReference.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using Mono.Cecil.Metadata;

	public abstract class ParameterReference : IMetadataTokenProvider, IReflectionVisitable {

		string m_name;
		int m_sequence;
		TypeReference m_paramType;
		MetadataToken m_token;

		public string Name {
			get { return m_name; }
			set { m_name = value; }
		}

		public int Sequence {
			get { return m_sequence; }
			set { m_sequence = value; }
		}

		public TypeReference ParameterType {
			get { return m_paramType; }
			set { m_paramType = value; }
		}

		public MetadataToken MetadataToken {
			get { return m_token; }
			set { m_token = value; }
		}

		public ParameterReference (string name, int sequence, TypeReference parameterType)
		{
			m_name = name;
			m_sequence = sequence;
			m_paramType = parameterType;
		}

		public override string ToString ()
		{
			if (m_name != null && m_name.Length > 0)
				return m_name;

			return string.Concat ("A_", m_sequence);
		}

		public abstract void Accept (IReflectionVisitor visitor);
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/PinnedType.cs
================================================
//
// PinnedType.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	public sealed class PinnedType : TypeSpecification {

		public PinnedType (TypeReference pType) : base (pType)
		{
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/PointerType.cs
================================================
//
// PointerType.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	public sealed class PointerType : TypeSpecification {

		public override string Name {
			get { return string.Concat (base.Name, "*"); }
		}

		public override string FullName {
			get { return string.Concat (base.FullName, "*"); }
		}

		public PointerType (TypeReference pType) : base (pType)
		{
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/PropertyAttributes.cs
================================================
//
// PropertyAttributes.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;

	[Flags]
	public enum PropertyAttributes : ushort {
		SpecialName		= 0x0200,	// Property is special
		RTSpecialName	= 0x0400,	// Runtime(metadata internal APIs) should check name encoding
		HasDefault		= 0x1000,	// Property has default
		Unused			= 0xe9ff	 // Reserved: shall be zero in a conforming implementation
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/PropertyDefinition.cs
================================================
//
// PropertyDefinition.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;
	using System.Text;

	public sealed class PropertyDefinition : PropertyReference,
		IMemberDefinition, ICustomAttributeProvider, IHasConstant {

		PropertyAttributes m_attributes;

		CustomAttributeCollection m_customAttrs;

		MethodDefinition m_getMeth;
		MethodDefinition m_setMeth;

		bool m_hasConstant;
		object m_const;

		public PropertyAttributes Attributes {
			get { return m_attributes; }
			set { m_attributes = value; }
		}

		public CustomAttributeCollection CustomAttributes {
			get {
				if (m_customAttrs == null)
					m_customAttrs = new CustomAttributeCollection (this);

				return m_customAttrs;
			}
		}

		public override ParameterDefinitionCollection Parameters {
			get {
				if (this.GetMethod != null)
					return CloneParameterCollection (this.GetMethod.Parameters);
				else if (this.SetMethod != null) {
					ParameterDefinitionCollection parameters =
						CloneParameterCollection (this.SetMethod.Parameters);
					if (parameters.Count > 0)
						parameters.RemoveAt (parameters.Count - 1);
					return parameters;
				}

				if (m_parameters == null)
					m_parameters = new ParameterDefinitionCollection (this);

				return m_parameters;
			}
		}

		public MethodDefinition GetMethod {
			get { return m_getMeth; }
			set { m_getMeth = value; }
		}

		public MethodDefinition SetMethod {
			get { return m_setMeth; }
			set { m_setMeth = value; }
		}

		ParameterDefinitionCollection CloneParameterCollection (ParameterDefinitionCollection original)
		{
			ParameterDefinitionCollection clone = new ParameterDefinitionCollection (
				original.Container);
			foreach (ParameterDefinition param in original)
				clone.Add (param);
			return clone;
		}

		public bool HasConstant {
			get { return m_hasConstant; }
		}

		public object Constant {
			get { return m_const; }
			set {
				m_hasConstant = true;
				m_const = value;
			}
		}

		public bool IsRuntimeSpecialName {
			get { return (m_attributes & PropertyAttributes.RTSpecialName) != 0; }
			set {
				if (value)
					m_attributes |= PropertyAttributes.RTSpecialName;
				else
					m_attributes &= ~PropertyAttributes.RTSpecialName;
			}
		}

		public bool IsSpecialName {
			get { return (m_attributes & PropertyAttributes.SpecialName) != 0; }
			set {
				if (value)
					m_attributes |= PropertyAttributes.SpecialName;
				else
					m_attributes &= ~PropertyAttributes.SpecialName;
			}
		}

		public PropertyDefinition (string name, TypeReference propertyType, PropertyAttributes attrs) : base (name, propertyType)
		{
			m_attributes = attrs;
		}

		public static MethodDefinition CreateGetMethod (PropertyDefinition prop)
		{
			MethodDefinition get = new MethodDefinition (
				string.Concat ("get_", prop.Name), (MethodAttributes) 0, prop.PropertyType);
			prop.GetMethod = get;
			return get;
		}

		public static MethodDefinition CreateSetMethod (PropertyDefinition prop)
		{
			MethodDefinition set = new MethodDefinition (
				string.Concat ("set_", prop.Name), (MethodAttributes) 0, prop.PropertyType);
			prop.SetMethod = set;
			return set;
		}

		public PropertyDefinition Clone ()
		{
			return Clone (this, new ImportContext (this.DeclaringType));
		}

		internal static PropertyDefinition Clone (PropertyDefinition prop, ImportContext context)
		{
			PropertyDefinition np = new PropertyDefinition (
				prop.Name,
				context.Import (prop.PropertyType),
				prop.Attributes);

			if (prop.HasConstant)
				np.Constant = prop.Constant;

			if (context != null && context.GenericContext.Type is TypeDefinition) {
				TypeDefinition type = context.GenericContext.Type as TypeDefinition;
				if (prop.SetMethod != null)
					np.SetMethod = type.Methods.GetMethod (prop.SetMethod.Name, prop.SetMethod.Parameters);
				if (prop.GetMethod != null)
					np.GetMethod = type.Methods.GetMethod (prop.GetMethod.Name, prop.GetMethod.Parameters);
			}

			foreach (CustomAttribute ca in prop.CustomAttributes)
				np.CustomAttributes.Add (CustomAttribute.Clone (ca, context));

			return np;
		}

		public override string ToString ()
		{
			StringBuilder sb = new StringBuilder ();
			sb.Append (PropertyType.ToString ());
			sb.Append (' ');

			if (this.DeclaringType != null) {
				sb.Append (this.DeclaringType.ToString ());
				sb.Append ("::");
			}

			sb.Append (this.Name);
			sb.Append ('(');
			ParameterDefinitionCollection parameters = this.Parameters;
			for (int i = 0; i < parameters.Count; i++) {
				if (i > 0)
					sb.Append (',');
				sb.Append (parameters [i].ParameterType.ToString ());
			}
			sb.Append (')');
			return sb.ToString ();
		}

		public override void Accept (IReflectionVisitor visitor)
		{
			visitor.VisitPropertyDefinition (this);

			this.CustomAttributes.Accept (visitor);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/PropertyDefinitionCollection.cs
================================================
//
// PropertyDefinitionCollection.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Wed Sep 27 01:22:48 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;
	using System.Collections;

	using Mono.Cecil.Cil;

	public sealed class PropertyDefinitionCollection : CollectionBase, IReflectionVisitable {

		TypeDefinition m_container;

		public PropertyDefinition this [int index] {
			get { return List [index] as PropertyDefinition; }
			set { List [index] = value; }
		}

		public TypeDefinition Container {
			get { return m_container; }
		}

		public PropertyDefinitionCollection (TypeDefinition container)
		{
			m_container = container;
		}

		public void Add (PropertyDefinition value)
		{
			if (!Contains (value))
				Attach (value);

			List.Add (value);
		}

		public new void Clear ()
		{
			foreach (PropertyDefinition item in this)
				Detach (item);

			base.Clear ();
		}

		public bool Contains (PropertyDefinition value)
		{
			return List.Contains (value);
		}

		public int IndexOf (PropertyDefinition value)
		{
			return List.IndexOf (value);
		}

		public void Insert (int index, PropertyDefinition value)
		{
			if (!this.Contains (value))
				Attach (value);

			List.Insert (index, value);
		}

		public void Remove (PropertyDefinition value)
		{
			if (this.Contains (value))
				Detach (value);

			List.Remove (value);
		}

		public new void RemoveAt (int index)
		{
			Detach (this [index]);

			List.RemoveAt (index);
		}

		protected override void OnValidate (object o)
		{
			if (! (o is PropertyDefinition))
				throw new ArgumentException ("Must be of type " + typeof (PropertyDefinition).FullName);
		}

		public PropertyDefinition [] GetProperties (string name)
		{
			ArrayList ret = new ArrayList ();
			foreach (PropertyDefinition prop in this)
				if (prop.Name == name)
					ret.Add (prop);

			return ret.ToArray (typeof (PropertyDefinition)) as PropertyDefinition [];
		}

		public PropertyDefinition [] GetProperties ()
		{
			ArrayList ret = new ArrayList ();
			foreach (PropertyDefinition prop in this)
					ret.Add (prop);

			return ret.ToArray (typeof (PropertyDefinition)) as PropertyDefinition [];
		}

		void Attach (MemberReference member)
		{
			if (member.DeclaringType != null)
				throw new ReflectionException ("Member already attached, clone it instead");

			member.DeclaringType = m_container;
		}

		void Detach (MemberReference member)
		{
			member.DeclaringType = null;
		}

		public void Accept (IReflectionVisitor visitor)
		{
			visitor.VisitPropertyDefinitionCollection (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/PropertyReference.cs
================================================
//
// PropertyReference.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	public abstract class PropertyReference : MemberReference {

		TypeReference m_propertyType;
		protected ParameterDefinitionCollection m_parameters;

		public TypeReference PropertyType {
			get { return m_propertyType; }
			set { m_propertyType = value; }
		}

		public abstract ParameterDefinitionCollection Parameters {
			get;
		}

		public PropertyReference (string name, TypeReference propertyType) : base (name)
		{
			m_propertyType = propertyType;
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/ReferenceType.cs
================================================
//
// ReferenceType.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	public sealed class ReferenceType : TypeSpecification {

		public override string Name {
			get { return string.Concat (base.Name, "&"); }
		}

		public override string FullName {
			get { return string.Concat (base.FullName, "&"); }
		}

		public ReferenceType (TypeReference type) : base (type)
		{
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/ReflectionController.cs
================================================
//
// ReflectionController.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;

	internal sealed class ReflectionController {

		ReflectionReader m_reader;
		ReflectionWriter m_writer;
		ReflectionHelper m_helper;

		public ReflectionReader Reader {
			get { return m_reader; }
		}

		public ReflectionWriter Writer {
			get { return m_writer; }
		}

		public ReflectionHelper Helper {
			get { return m_helper; }
		}

		public ReflectionController (ModuleDefinition module)
		{
			m_reader = new AggressiveReflectionReader (module);
			m_writer = new ReflectionWriter (module);
			m_helper = new ReflectionHelper (module);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/ReflectionException.cs
================================================
//
// ReflectionException.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;

	using Mono.Cecil.Metadata;

	public sealed class ReflectionException : MetadataFormatException {

		internal ReflectionException () : base ()
		{
		}

		internal ReflectionException (string message) : base (message)
		{
		}

		internal ReflectionException (string message, params string [] parameters) :
			base (string.Format (message, parameters))
		{
		}

		internal ReflectionException (string message, Exception inner) :
			base (message, inner)
		{
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/ReflectionHelper.cs
================================================
//
// ReflectionHelper.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
// (C) 2006 Evaluant RC S.A.
// (C) 2007 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;
	using System.Collections;
	using SR = System.Reflection;
	using System.Text;

	internal sealed class ReflectionHelper {

		ModuleDefinition m_module;

		IDictionary m_asmCache;
		IDictionary m_memberRefCache;
		bool m_cacheLoaded;

		public ReflectionHelper (ModuleDefinition module)
		{
			m_module = module;
			m_asmCache = new Hashtable ();
			m_memberRefCache = new Hashtable ();
			m_cacheLoaded = false;
		}

		void ImportCache ()
		{
			if (m_cacheLoaded)
				return;

			m_module.FullLoad ();

			foreach (AssemblyNameReference ar in m_module.AssemblyReferences)
				m_asmCache [ar.FullName] = ar;
			foreach (MemberReference member in m_module.MemberReferences)
				m_memberRefCache [member.ToString ()] = member;

			m_cacheLoaded = true;
		}

		public AssemblyNameReference ImportAssembly (SR.Assembly asm)
		{
			ImportCache ();

			AssemblyNameReference asmRef = (AssemblyNameReference) m_asmCache [asm.FullName];
			if (asmRef != null)
				return asmRef;

			SR.AssemblyName asmName = asm.GetName ();
			asmRef = new AssemblyNameReference (
				asmName.Name, asmName.CultureInfo.Name, asmName.Version);
			asmRef.PublicKeyToken = asmName.GetPublicKeyToken ();
			asmRef.HashAlgorithm = (Mono.Cecil.AssemblyHashAlgorithm) asmName.HashAlgorithm;
			asmRef.Culture = asmName.CultureInfo.ToString ();
			m_module.AssemblyReferences.Add (asmRef);
			m_asmCache [asm.FullName] = asmRef;
			return asmRef;
		}

		public static string GetTypeSignature (Type t)
		{
			if (t.HasElementType) {
				if (t.IsPointer)
					return string.Concat (GetTypeSignature (t.GetElementType ()), "*");
				else if (t.IsArray) // deal with complex arrays
					return string.Concat (GetTypeSignature (t.GetElementType ()), "[]");
				else if (t.IsByRef)
					return string.Concat (GetTypeSignature (t.GetElementType ()), "&");
			}

			if (IsGenericTypeSpec (t)) {
				StringBuilder sb = new StringBuilder ();
				sb.Append (GetTypeSignature (GetGenericTypeDefinition (t)));
				sb.Append ("<");
				Type [] genArgs = GetGenericArguments (t);
				for (int i = 0; i < genArgs.Length; i++) {
					if (i > 0)
						sb.Append (",");
					sb.Append (GetTypeSignature (genArgs [i]));
				}
				sb.Append (">");
				return sb.ToString ();
			}

			if (IsGenericParameter (t))
				return t.Name;

			if (t.DeclaringType != null)
				return string.Concat (t.DeclaringType.FullName, "/", t.Name);

			if (t.Namespace == null || t.Namespace.Length == 0)
				return t.Name;

			return string.Concat (t.Namespace, ".", t.Name);
		}

		static bool GetProperty (object o, string prop)
		{
			SR.PropertyInfo pi = o.GetType ().GetProperty (prop);
			if (pi == null)
				return false;

			return (bool) pi.GetValue (o, null);
		}

		public static bool IsGenericType (Type t)
		{
			return GetProperty (t, "IsGenericType");
		}

		static bool IsGenericParameter (Type t)
		{
			return GetProperty (t, "IsGenericParameter");
		}

		static bool IsGenericTypeDefinition (Type t)
		{
			return GetProperty (t, "IsGenericTypeDefinition");
		}

		static bool IsGenericTypeSpec (Type t)
		{
			return IsGenericType (t) && !IsGenericTypeDefinition (t);
		}

		static Type GetGenericTypeDefinition (Type t)
		{
			return (Type) t.GetType ().GetMethod ("GetGenericTypeDefinition").Invoke (t, null);
		}

		static Type [] GetGenericArguments (Type t)
		{
			return (Type []) t.GetType ().GetMethod ("GetGenericArguments").Invoke (t, null);
		}

		GenericInstanceType GetGenericType (Type t, TypeReference element, ImportContext context)
		{
			GenericInstanceType git = new GenericInstanceType (element);
			foreach (Type genArg in GetGenericArguments (t))
				git.GenericArguments.Add (ImportSystemType (genArg, context));

			return git;
		}

		static bool GenericParameterOfMethod (Type t)
		{
			return t.GetType ().GetProperty ("DeclaringMethod").GetValue (t, null) != null;
		}

		static GenericParameter GetGenericParameter (Type t, ImportContext context)
		{
			int pos = (int) t.GetType ().GetProperty ("GenericParameterPosition").GetValue (t, null);
			if (GenericParameterOfMethod (t))
				return context.GenericContext.Method.GenericParameters [pos];
			else
				return context.GenericContext.Type.GenericParameters [pos];
		}

		TypeReference GetTypeSpec (Type t, ImportContext context)
		{
			Stack s = new Stack ();
			while (t.HasElementType || IsGenericTypeSpec (t)) {
				s.Push (t);
				if (t.HasElementType)
					t = t.GetElementType ();
				else if (IsGenericTypeSpec (t)) {
					t = (Type) t.GetType ().GetMethod ("GetGenericTypeDefinition").Invoke (t, null);
					break;
				}
			}

			TypeReference elementType = ImportSystemType (t, context);
			while (s.Count > 0) {
				t = s.Pop () as Type;
				if (t.IsPointer)
					elementType = new PointerType (elementType);
				else if (t.IsArray) // deal with complex arrays
					elementType = new ArrayType (elementType);
				else if (t.IsByRef)
					elementType = new ReferenceType (elementType);
				else if (IsGenericTypeSpec (t))
					elementType = GetGenericType (t, elementType, context);
				else
					throw new ReflectionException ("Unknown element type");
			}

			return elementType;
		}

		public TypeReference ImportSystemType (Type t, ImportContext context)
		{
			if (t.HasElementType || IsGenericTypeSpec (t))
				return GetTypeSpec (t, context);

			if (IsGenericParameter (t))
				return GetGenericParameter (t, context);

			ImportCache ();

			TypeReference type = m_module.TypeReferences [GetTypeSignature (t)];
			if (type != null)
				return type;

			AssemblyNameReference asm = ImportAssembly (t.Assembly);
			type = new TypeReference (t.Name, t.Namespace, asm, t.IsValueType);

			if (IsGenericTypeDefinition (t))
				foreach (Type genParam in GetGenericArguments (t))
					type.GenericParameters.Add (new GenericParameter (genParam.Name, type));

			context.GenericContext.Type = type;

			m_module.TypeReferences.Add (type);
			return type;
		}

		static string GetMethodBaseSignature (SR.MethodBase meth, Type declaringType, Type retType)
		{
			StringBuilder sb = new StringBuilder ();
			sb.Append (GetTypeSignature (retType));
			sb.Append (' ');
			sb.Append (GetTypeSignature (declaringType));
			sb.Append ("::");
			sb.Append (meth.Name);
			if (IsGenericMethodSpec (meth)) {
				sb.Append ("<");
				Type [] genArgs = GetGenericArguments (meth as SR.MethodInfo);
				for (int i = 0; i < genArgs.Length; i++) {
					if (i > 0)
						sb.Append (",");
					sb.Append (GetTypeSignature (genArgs [i]));
				}
				sb.Append (">");
			}
			sb.Append ("(");
			SR.ParameterInfo [] parameters = meth.GetParameters ();
			for (int i = 0; i < parameters.Length; i++) {
				if (i > 0)
					sb.Append (", ");
				sb.Append (GetTypeSignature (parameters [i].ParameterType));
			}
			sb.Append (")");
			return sb.ToString ();
		}

		static bool IsGenericMethod (SR.MethodBase mb)
		{
			return GetProperty (mb, "IsGenericMethod");
		}

		static bool IsGenericMethodDefinition (SR.MethodBase mb)
		{
			return GetProperty (mb, "IsGenericMethodDefinition");
		}

		static bool IsGenericMethodSpec (SR.MethodBase mb)
		{
			return IsGenericMethod (mb) && !IsGenericMethodDefinition (mb);
		}

		static Type [] GetGenericArguments (SR.MethodInfo mi)
		{
			return (Type []) mi.GetType ().GetMethod ("GetGenericArguments").Invoke (mi, null);
		}

		static int GetMetadataToken (SR.MethodInfo mi)
		{
			return (int) mi.GetType ().GetProperty ("MetadataToken").GetValue (mi, null);
		}

		MethodReference ImportGenericInstanceMethod (SR.MethodInfo mi, ImportContext context)
		{
			SR.MethodInfo gmd = (SR.MethodInfo) mi.GetType ().GetMethod ("GetGenericMethodDefinition").Invoke (mi, null);
			GenericInstanceMethod gim = new GenericInstanceMethod (
				ImportMethodBase (gmd, gmd.ReturnType, context));

			foreach (Type genArg in GetGenericArguments (mi))
				gim.GenericArguments.Add (ImportSystemType (genArg, context));

			return gim;
		}

		MethodReference ImportMethodBase (SR.MethodBase mb, Type retType, ImportContext context)
		{
			if (IsGenericMethod (mb) && !IsGenericMethodDefinition (mb))
				return ImportGenericInstanceMethod ((SR.MethodInfo) mb, context);

			ImportCache ();

			Type originalDecType = mb.DeclaringType;
			Type declaringTypeDef = originalDecType;
			while (IsGenericTypeSpec (declaringTypeDef))
				declaringTypeDef = GetGenericTypeDefinition (declaringTypeDef);

			if (mb.DeclaringType != declaringTypeDef && mb is SR.MethodInfo) {
				int mt = GetMetadataToken (mb as SR.MethodInfo);
				// hack to get the generic method definition from the constructed method
				foreach (SR.MethodInfo mi in declaringTypeDef.GetMethods ()) {
					if (GetMetadataToken (mi) == mt) {
						mb = mi;
						retType = mi.ReturnType;
						break;
					}
				}
			}

			string sig = GetMethodBaseSignature (mb, originalDecType, retType);
			MethodReference meth = m_memberRefCache [sig] as MethodReference;
			if (meth != null)
				return meth;

			meth = new MethodReference (
				mb.Name,
				(mb.CallingConvention & SR.CallingConventions.HasThis) > 0,
				(mb.CallingConvention & SR.CallingConventions.ExplicitThis) > 0,
				MethodCallingConvention.Default); // TODO: get the real callconv
			meth.DeclaringType = ImportSystemType (originalDecType, context);

			if (IsGenericMethod (mb))
				foreach (Type genParam in GetGenericArguments (mb as SR.MethodInfo))
					meth.GenericParameters.Add (new GenericParameter (genParam.Name, meth));

			context.GenericContext.Method = meth;
			context.GenericContext.Type = ImportSystemType (declaringTypeDef, context);

			meth.ReturnType.ReturnType = ImportSystemType (retType, context);

			SR.ParameterInfo [] parameters = mb.GetParameters ();
			for (int i = 0; i < parameters.Length; i++)
				meth.Parameters.Add (new ParameterDefinition (
					ImportSystemType (parameters [i].ParameterType, context)));

			m_module.MemberReferences.Add (meth);
			m_memberRefCache [sig] = meth;
			return meth;
		}

		public MethodReference ImportConstructorInfo (SR.ConstructorInfo ci, ImportContext context)
		{
			return ImportMethodBase (ci, typeof (void), context);
		}

		public MethodReference ImportMethodInfo (SR.MethodInfo mi, ImportContext context)
		{
			return ImportMethodBase (mi, mi.ReturnType, context);
		}

		static string GetFieldSignature (SR.FieldInfo field)
		{
			StringBuilder sb = new StringBuilder ();
			sb.Append (GetTypeSignature (field.FieldType));
			sb.Append (' ');
			sb.Append (GetTypeSignature (field.DeclaringType));
			sb.Append ("::");
			sb.Append (field.Name);
			return sb.ToString ();
		}

		public FieldReference ImportFieldInfo (SR.FieldInfo fi, ImportContext context)
		{
			ImportCache ();

			string sig = GetFieldSignature (fi);
			FieldReference f = (FieldReference) m_memberRefCache [sig];
			if (f != null)
				return f;

			f = new FieldReference (
				fi.Name,
				ImportSystemType (fi.DeclaringType, context),
				ImportSystemType (fi.FieldType, context));

			m_module.MemberReferences.Add (f);
			m_memberRefCache [sig] = f;
			return f;
		}

		public AssemblyNameReference ImportAssembly (AssemblyNameReference asm)
		{
			ImportCache ();

			AssemblyNameReference asmRef = (AssemblyNameReference) m_asmCache [asm.FullName];
			if (asmRef != null)
				return asmRef;

			asmRef = new AssemblyNameReference (
				asm.Name, asm.Culture, asm.Version);
			asmRef.PublicKeyToken = asm.PublicKeyToken;
			asmRef.HashAlgorithm = asm.HashAlgorithm;
			m_module.AssemblyReferences.Add (asmRef);
			m_asmCache [asm.FullName] = asmRef;
			return asmRef;
		}

		TypeReference GetTypeSpec (TypeReference t, ImportContext context)
		{
			Stack s = new Stack ();
			while (t is TypeSpecification) {
				s.Push (t);
				t = (t as TypeSpecification).ElementType;
			}

			TypeReference elementType = ImportTypeReference (t, context);
			while (s.Count > 0) {
				t = s.Pop () as TypeReference;
				if (t is PointerType)
					elementType = new PointerType (elementType);
				else if (t is ArrayType) // deal with complex arrays
					elementType = new ArrayType (elementType);
				else if (t is ReferenceType)
					elementType = new ReferenceType (elementType);
				else if (t is GenericInstanceType) {
					GenericInstanceType git = t as GenericInstanceType;
					GenericInstanceType genElemType = new GenericInstanceType (elementType);
					foreach (TypeReference arg in git.GenericArguments)
						genElemType.GenericArguments.Add (ImportTypeReference (arg, context));

					elementType = genElemType;
				} else
					throw new ReflectionException ("Unknown element type: {0}", t.GetType ().Name);
			}

			return elementType;
		}

		static GenericParameter GetGenericParameter (GenericParameter gp, ImportContext context)
		{
			GenericParameter p;
			if (gp.Owner is TypeReference)
				p = context.GenericContext.Type.GenericParameters [gp.Position];
			else if (gp.Owner is MethodReference)
				p = context.GenericContext.Method.GenericParameters [gp.Position];
			else
				throw new NotSupportedException ();

			return p;
		}

		public TypeReference ImportTypeReference (TypeReference t, ImportContext context)
		{
			if (t.Module == m_module)
				return t;

			ImportCache ();

			if (t is TypeSpecification)
				return GetTypeSpec (t, context);

			if (t is GenericParameter)
				return GetGenericParameter (t as GenericParameter, context);

			TypeReference type = m_module.TypeReferences [t.FullName];
			if (type != null)
				return type;

			AssemblyNameReference asm;
			if (t.Scope is AssemblyNameReference)
				asm = ImportAssembly ((AssemblyNameReference) t.Scope);
			else if (t.Scope is ModuleDefinition)
				asm = ImportAssembly (((ModuleDefinition) t.Scope).Assembly.Name);
			else
				throw new NotImplementedException ();

			type = new TypeReference (t.Name, t.Namespace, asm, t.IsValueType);

			context.GenericContext.Type = type;

			foreach (GenericParameter gp in t.GenericParameters)
				type.GenericParameters.Add (GenericParameter.Clone (gp, context));

			m_module.TypeReferences.Add (type);
			return type;
		}

		MethodReference GetMethodSpec (MethodReference meth, ImportContext context)
		{
			if (!(meth is GenericInstanceMethod))
				return null;

			GenericInstanceMethod gim = meth as GenericInstanceMethod;
			GenericInstanceMethod ngim = new GenericInstanceMethod (
				ImportMethodReference (gim.ElementMethod, context));

			foreach (TypeReference arg in gim.GenericArguments)
				ngim.GenericArguments.Add (ImportTypeReference (arg, context));

			return ngim;
		}

		public MethodReference ImportMethodReference (MethodReference mr, ImportContext context)
		{
			if (mr.DeclaringType.Module == m_module)
				return mr;

			ImportCache ();

			if (mr is MethodSpecification)
				return GetMethodSpec (mr, context);

			MethodReference meth = m_memberRefCache [mr.ToString ()] as MethodReference;
			if (meth != null)
				return meth;

			meth = new MethodReference (
				mr.Name,
				mr.HasThis,
				mr.ExplicitThis,
				mr.CallingConvention);
			meth.DeclaringType = ImportTypeReference (mr.DeclaringType, context);

			TypeReference contextType = meth.DeclaringType;
			while (contextType is TypeSpecification)
				contextType = (contextType as TypeSpecification).ElementType;

			context.GenericContext.Method = meth;
			context.GenericContext.Type = contextType;

			foreach (GenericParameter gp in mr.GenericParameters)
				meth.GenericParameters.Add (GenericParameter.Clone (gp, context));

			meth.ReturnType.ReturnType = ImportTypeReference (mr.ReturnType.ReturnType, context);

			foreach (ParameterDefinition param in mr.Parameters)
				meth.Parameters.Add (new ParameterDefinition (
					ImportTypeReference (param.ParameterType, context)));

			m_module.MemberReferences.Add (meth);
			m_memberRefCache [mr.ToString ()] = meth;
			return meth;
		}

		public FieldReference ImportFieldReference (FieldReference field, ImportContext context)
		{
			if (field.DeclaringType.Module == m_module)
				return field;

			ImportCache ();

			FieldReference f = (FieldReference) m_memberRefCache [field.ToString ()];
			if (f != null)
				return f;

			f = new FieldReference (
				field.Name,
				ImportTypeReference (field.DeclaringType, context),
				ImportTypeReference (field.FieldType, context));

			m_module.MemberReferences.Add (f);
			m_memberRefCache [field.ToString ()] = f;
			return f;
		}

		public FieldDefinition ImportFieldDefinition (FieldDefinition field, ImportContext context)
		{
			return FieldDefinition.Clone (field, context);
		}

		public MethodDefinition ImportMethodDefinition (MethodDefinition meth, ImportContext context)
		{
			return MethodDefinition.Clone (meth, context);
		}

		public TypeDefinition ImportTypeDefinition (TypeDefinition type, ImportContext context)
		{
			return TypeDefinition.Clone (type, context);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/ReflectionReader.cs
================================================
//
// ReflectionReader.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 - 2007 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;
	using System.IO;
	using System.Text;

	using Mono.Cecil.Binary;
	using Mono.Cecil.Cil;
	using Mono.Cecil.Metadata;
	using Mono.Cecil.Signatures;

	internal abstract class ReflectionReader : BaseReflectionReader {

		ModuleDefinition m_module;
		ImageReader m_reader;
		SecurityDeclarationReader m_secReader;
		protected MetadataTableReader m_tableReader;
		protected MetadataRoot m_root;
		protected TablesHeap m_tHeap;

		protected TypeDefinition [] m_typeDefs;
		protected TypeReference [] m_typeRefs;
		protected TypeReference [] m_typeSpecs;
		protected MethodDefinition [] m_meths;
		protected FieldDefinition [] m_fields;
		protected EventDefinition [] m_events;
		protected PropertyDefinition [] m_properties;
		protected MemberReference [] m_memberRefs;
		protected ParameterDefinition [] m_parameters;
		protected GenericParameter [] m_genericParameters;
		protected GenericInstanceMethod [] m_methodSpecs;

		bool m_isCorlib;
		AssemblyNameReference m_corlib;

		protected SignatureReader m_sigReader;
		protected CodeReader m_codeReader;
		protected ISymbolReader m_symbolReader;

		internal AssemblyNameReference Corlib {
			get {
				if (m_corlib != null)
					return m_corlib;

				foreach (AssemblyNameReference ar in m_module.AssemblyReferences) {
					if (ar.Name == Constants.Corlib) {
						m_corlib = ar;
						return m_corlib;
					}
				}

				return null;
			}
		}

		public ModuleDefinition Module {
			get { return m_module; }
		}

		public SignatureReader SigReader {
			get { return m_sigReader; }
		}

		public MetadataTableReader TableReader {
			get { return m_tableReader; }
		}

		public CodeReader Code {
			get { return m_codeReader; }
		}

		public ISymbolReader SymbolReader {
			get { return m_symbolReader; }
			set { m_symbolReader = value; }
		}

		public MetadataRoot MetadataRoot {
			get { return m_root; }
		}

		public ReflectionReader (ModuleDefinition module)
		{
			m_module = module;
			m_reader = m_module.ImageReader;
			m_root = m_module.Image.MetadataRoot;
			m_tHeap = m_root.Streams.TablesHeap;
			if (m_reader != null)
				m_tableReader = m_reader.MetadataReader.TableReader;
			m_codeReader = new CodeReader (this);
			m_sigReader = new SignatureReader (m_root, this);
			m_isCorlib = module.Assembly.Name.Name == Constants.Corlib;
		}

		public TypeDefinition GetTypeDefAt (uint rid)
		{
			return m_typeDefs [rid - 1];
		}

		public TypeReference GetTypeRefAt (uint rid)
		{
			return m_typeRefs [rid - 1];
		}

		public TypeReference GetTypeSpecAt (uint rid, GenericContext context)
		{
			int index = (int) rid - 1;
			TypeReference tspec = m_typeSpecs [index];
			if (tspec != null)
				return tspec;

			TypeSpecTable tsTable = m_tableReader.GetTypeSpecTable ();
			TypeSpecRow tsRow = tsTable [index];
			TypeSpec ts = m_sigReader.GetTypeSpec (tsRow.Signature);
			tspec = GetTypeRefFromSig (ts.Type, context);
			tspec.MetadataToken = MetadataToken.FromMetadataRow (TokenType.TypeSpec, index);
			m_typeSpecs [index] = tspec;

			return tspec;
		}

		public FieldDefinition GetFieldDefAt (uint rid)
		{
			return m_fields [rid - 1];
		}

		public MethodDefinition GetMethodDefAt (uint rid)
		{
			return m_meths [rid - 1];
		}

		public MemberReference GetMemberRefAt (uint rid, GenericContext context)
		{
			int index = (int) rid - 1;
			MemberReference member = m_memberRefs [rid - 1];
			if (member != null)
				return member;

			MemberRefTable mrTable = m_tableReader.GetMemberRefTable ();
			MemberRefRow mrefRow = mrTable [index];

			Signature sig = m_sigReader.GetMemberRefSig (mrefRow.Class.TokenType, mrefRow.Signature);
			switch (mrefRow.Class.TokenType) {
			case TokenType.TypeDef :
			case TokenType.TypeRef :
			case TokenType.TypeSpec :
				TypeReference declaringType = GetTypeDefOrRef (mrefRow.Class, context);
				GenericContext nc = context.Clone ();

				if (declaringType is GenericInstanceType) {
					TypeReference ct = declaringType;
					while (ct is GenericInstanceType)
						ct = (ct as GenericInstanceType).ElementType;

					nc.Type = ct;
					nc.AllowCreation = ct.GetType () == typeof (TypeReference);
				}

				if (sig is FieldSig) {
					FieldSig fs = sig as FieldSig;
					member = new FieldReference (
						m_root.Streams.StringsHeap [mrefRow.Name],
						declaringType,
						GetTypeRefFromSig (fs.Type, nc));
				} else {
					string name = m_root.Streams.StringsHeap [mrefRow.Name];
					MethodSig ms = (MethodSig) sig;

					MethodReference methref = new MethodReference (
						name, ms.HasThis, ms.ExplicitThis, ms.MethCallConv);
					methref.DeclaringType = declaringType;

					if (sig is MethodDefSig) {
						int arity = (sig as MethodDefSig).GenericParameterCount;
						for (int i = 0; i < arity; i++)
							methref.GenericParameters.Add (new GenericParameter (i, methref));
					}

					if (methref.GenericParameters.Count > 0)
						nc.Method = methref;

					methref.ReturnType = GetMethodReturnType (ms, nc);

					methref.ReturnType.Method = methref;
					for (int j = 0; j < ms.ParamCount; j++) {
						Param p = ms.Parameters [j];
						ParameterDefinition pdef = BuildParameterDefinition (
							string.Concat ("A_", j), j, new ParameterAttributes (), p, nc);
						pdef.Method = methref;
						methref.Parameters.Add (pdef);
					}
					member = methref;
				}
				break;
			case TokenType.Method :
				// really not sure about this
				MethodDefinition methdef = GetMethodDefAt (mrefRow.Class.RID);
				MethodReference methRef = new MethodReference (
					methdef.Name, methdef.HasThis,
					methdef.ExplicitThis, methdef.CallingConvention);

				methRef.DeclaringType = methdef.DeclaringType;
				methRef.ReturnType = methdef.ReturnType;
				foreach (ParameterDefinition param in methdef.Parameters)
					methRef.Parameters.Add (param);
				member = methRef;
				break;
			case TokenType.ModuleRef :
				break; // TODO, implement that, or not
			}

			member.MetadataToken = MetadataToken.FromMetadataRow (TokenType.MemberRef, index);
			m_module.MemberReferences.Add (member);
			m_memberRefs [index] = member;

			return member;
		}

		public PropertyDefinition GetPropertyDefAt (uint rid)
		{
			return m_properties [rid - 1];
		}

		public EventDefinition GetEventDefAt (uint rid)
		{
			return m_events [rid - 1];
		}

		public ParameterDefinition GetParamDefAt (uint rid)
		{
			return m_parameters [rid - 1];
		}

		public GenericParameter GetGenericParameterAt (uint rid)
		{
			return m_genericParameters [rid - 1];
		}

		public GenericInstanceMethod GetMethodSpecAt (uint rid, GenericContext context)
		{
			int index = (int) rid - 1;
			GenericInstanceMethod gim = m_methodSpecs [index];
			if (gim != null)
				return gim;

			MethodSpecTable msTable = m_tableReader.GetMethodSpecTable ();
			MethodSpecRow msRow = msTable [index];

			MethodSpec sig = m_sigReader.GetMethodSpec (msRow.Instantiation);

			MethodReference meth;
			if (msRow.Method.TokenType == TokenType.Method)
				meth = GetMethodDefAt (msRow.Method.RID);
			else if (msRow.Method.TokenType == TokenType.MemberRef)
				meth = (MethodReference) GetMemberRefAt (msRow.Method.RID, context);
			else
				throw new ReflectionException ("Unknown method type for method spec");

			gim = new GenericInstanceMethod (meth);
			foreach (GenericArg arg in sig.Signature.Types)
				gim.GenericArguments.Add (GetGenericArg (arg, context));

			m_methodSpecs [index] = gim;

			return gim;
		}

		public TypeReference GetTypeDefOrRef (MetadataToken token, GenericContext context)
		{
			if (token.RID == 0)
				return null;

			switch (token.TokenType) {
			case TokenType.TypeDef :
				return GetTypeDefAt (token.RID);
			case TokenType.TypeRef :
				return GetTypeRefAt (token.RID);
			case TokenType.TypeSpec :
				return GetTypeSpecAt (token.RID, context);
			default :
				return null;
			}
		}

		public TypeReference SearchCoreType (string fullName)
		{
			if (m_isCorlib)
				return m_module.Types [fullName];

			TypeReference coreType =  m_module.TypeReferences [fullName];
			if (coreType == null) {

				string [] parts = fullName.Split ('.');
				if (parts.Length != 2)
					throw new ReflectionException ("Unvalid core type name");
				coreType = new TypeReference (parts [1], parts [0], Corlib);
				m_module.TypeReferences.Add (coreType);
			}
			if (!coreType.IsValueType) {
				switch (coreType.FullName) {
				case Constants.Boolean :
				case Constants.Char :
				case Constants.Single :
				case Constants.Double :
				case Constants.SByte :
				case Constants.Byte :
				case Constants.Int16 :
				case Constants.UInt16 :
				case Constants.Int32 :
				case Constants.UInt32 :
				case Constants.Int64 :
				case Constants.UInt64 :
				case Constants.IntPtr :
				case Constants.UIntPtr :
					coreType.IsValueType = true;
					break;
				}
			}
			return coreType;
		}

		public IMetadataTokenProvider LookupByToken (MetadataToken token)
		{
			switch (token.TokenType) {
			case TokenType.TypeDef :
				return GetTypeDefAt (token.RID);
			case TokenType.TypeRef :
				return GetTypeRefAt (token.RID);
			case TokenType.Method :
				return GetMethodDefAt (token.RID);
			case TokenType.Field :
				return GetFieldDefAt (token.RID);
			case TokenType.Event :
				return GetEventDefAt (token.RID);
			case TokenType.Property :
				return GetPropertyDefAt (token.RID);
			case TokenType.Param :
				return GetParamDefAt (token.RID);
			default :
				throw new NotSupportedException ("Lookup is not allowed on this kind of token");
			}
		}

		public CustomAttribute GetCustomAttribute (MethodReference ctor, byte [] data, bool resolve)
		{
			CustomAttrib sig = m_sigReader.GetCustomAttrib (data, ctor, resolve);
			return BuildCustomAttribute (ctor, sig);
		}

		public CustomAttribute GetCustomAttribute (MethodReference ctor, byte [] data)
		{
			return GetCustomAttribute (ctor, data, false);
		}

		public override void VisitModuleDefinition (ModuleDefinition mod)
		{
			VisitTypeDefinitionCollection (mod.Types);
		}

		public override void VisitTypeDefinitionCollection (TypeDefinitionCollection types)
		{
			// type def reading
			TypeDefTable typesTable = m_tableReader.GetTypeDefTable ();
			m_typeDefs = new TypeDefinition [typesTable.Rows.Count];
			for (int i = 0; i < typesTable.Rows.Count; i++) {
				TypeDefRow type = typesTable [i];
				TypeDefinition t = new TypeDefinition (
					m_root.Streams.StringsHeap [type.Name],
					m_root.Streams.StringsHeap [type.Namespace],
					type.Flags);
				t.MetadataToken = MetadataToken.FromMetadataRow (TokenType.TypeDef, i);

				m_typeDefs [i] = t;
			}

			// nested types
			if (m_tHeap.HasTable (NestedClassTable.RId)) {
				NestedClassTable nested = m_tableReader.GetNestedClassTable ();
				for (int i = 0; i < nested.Rows.Count; i++) {
					NestedClassRow row = nested [i];

					TypeDefinition parent = GetTypeDefAt (row.EnclosingClass);
					TypeDefinition child = GetTypeDefAt (row.NestedClass);

					parent.NestedTypes.Add (child);
				}
			}

			foreach (TypeDefinition type in m_typeDefs)
				types.Add (type);

			// type ref reading
			if (m_tHeap.HasTable (TypeRefTable.RId)) {
				TypeRefTable typesRef = m_tableReader.GetTypeRefTable ();

				m_typeRefs = new TypeReference [typesRef.Rows.Count];

				for (int i = 0; i < typesRef.Rows.Count; i++)
					AddTypeRef (typesRef, i);
			} else
				m_typeRefs = new TypeReference [0];

			ReadTypeSpecs ();
			ReadMethodSpecs ();

			ReadMethods ();
			ReadGenericParameters ();

			// set base types
			for (int i = 0; i < typesTable.Rows.Count; i++) {
				TypeDefRow type = typesTable [i];
				TypeDefinition child = m_typeDefs [i];
				child.BaseType = GetTypeDefOrRef (type.Extends, new GenericContext (child));
			}

			CompleteMethods ();
			ReadAllFields ();
			ReadMemberReferences ();
		}

		void AddTypeRef (TypeRefTable typesRef, int i)
		{
			// Check if index has been already added.
			if (m_typeRefs [i] != null)
				return;

			TypeRefRow type = typesRef [i];
			IMetadataScope scope = null;
			TypeReference parent = null;

			if (type.ResolutionScope != MetadataToken.Zero) {
				switch (type.ResolutionScope.TokenType) {
				case TokenType.AssemblyRef:
					scope = m_module.AssemblyReferences [(int) type.ResolutionScope.RID - 1];
					break;
				case TokenType.ModuleRef:
					scope = m_module.ModuleReferences [(int) type.ResolutionScope.RID - 1];
					break;
				case TokenType.Module:
					scope = m_module.Assembly.Modules [(int) type.ResolutionScope.RID - 1];
					break;
				case TokenType.TypeRef:
					AddTypeRef (typesRef, (int) type.ResolutionScope.RID - 1);
					parent = GetTypeRefAt (type.ResolutionScope.RID);
					scope = parent.Scope;
					break;
				}
			}

			TypeReference t = new TypeReference (
				m_root.Streams.StringsHeap [type.Name],
				m_root.Streams.StringsHeap [type.Namespace],
				scope);
			t.MetadataToken = MetadataToken.FromMetadataRow (TokenType.TypeRef, i);

			if (parent != null)
				t.DeclaringType = parent;

			m_typeRefs [i] = t;
			m_module.TypeReferences.Add (t);
		}

		void ReadTypeSpecs ()
		{
			if (!m_tHeap.HasTable (TypeSpecTable.RId))
				return;

			TypeSpecTable tsTable = m_tableReader.GetTypeSpecTable ();
			m_typeSpecs = new TypeReference [tsTable.Rows.Count];
		}

		void ReadMethodSpecs ()
		{
			if (!m_tHeap.HasTable (MethodSpecTable.RId))
				return;

			MethodSpecTable msTable = m_tableReader.GetMethodSpecTable ();
			m_methodSpecs = new GenericInstanceMethod [msTable.Rows.Count];
		}

		void ReadGenericParameters ()
		{
			if (!m_tHeap.HasTable (GenericParamTable.RId))
				return;

			GenericParamTable gpTable = m_tableReader.GetGenericParamTable ();
			m_genericParameters = new GenericParameter [gpTable.Rows.Count];
			for (int i = 0; i < gpTable.Rows.Count; i++) {
				GenericParamRow gpRow = gpTable [i];
				IGenericParameterProvider owner;
				if (gpRow.Owner.TokenType == TokenType.Method)
					owner = GetMethodDefAt (gpRow.Owner.RID);
				else if (gpRow.Owner.TokenType == TokenType.TypeDef)
					owner = GetTypeDefAt (gpRow.Owner.RID);
				else
					throw new ReflectionException ("Unknown owner type for generic parameter");

				GenericParameter gp = new GenericParameter (gpRow.Number, owner);
				gp.Attributes = gpRow.Flags;
				gp.Name = MetadataRoot.Streams.StringsHeap [gpRow.Name];
				gp.MetadataToken = MetadataToken.FromMetadataRow (TokenType.GenericParam, i);

				owner.GenericParameters.Add (gp);
				m_genericParameters [i] = gp;
			}
		}

		void ReadAllFields ()
		{
			TypeDefTable tdefTable = m_tableReader.GetTypeDefTable ();

			if (!m_tHeap.HasTable(FieldTable.RId)) {
				m_fields = new FieldDefinition [0];
				return;
			}

			FieldTable fldTable = m_tableReader.GetFieldTable ();
			m_fields = new FieldDefinition [fldTable.Rows.Count];

			for (int i = 0; i < m_typeDefs.Length; i++) {
				TypeDefinition dec = m_typeDefs [i];
				GenericContext context = new GenericContext (dec);

				int index = i, next;

				if (index == tdefTable.Rows.Count - 1)
					next = fldTable.Rows.Count + 1;
				else
					next = (int) (tdefTable [index + 1]).FieldList;

				for (int j = (int) tdefTable [index].FieldList; j < next; j++) {
					FieldRow frow = fldTable [j - 1];
					FieldSig fsig = m_sigReader.GetFieldSig (frow.Signature);
					FieldDefinition fdef = new FieldDefinition (
						m_root.Streams.StringsHeap [frow.Name],
						GetTypeRefFromSig (fsig.Type, context), frow.Flags);
					fdef.MetadataToken = MetadataToken.FromMetadataRow (TokenType.Field, j - 1);

					if (fsig.CustomMods.Length > 0)
						fdef.FieldType = GetModifierType (fsig.CustomMods, fdef.FieldType);

					dec.Fields.Add (fdef);
					m_fields [j - 1] = fdef;
				}
			}
		}

		void ReadMethods ()
		{
			if (!m_tHeap.HasTable (MethodTable.RId)) {
				m_meths = new MethodDefinition [0];
				return;
			}

			MethodTable mTable = m_tableReader.GetMethodTable ();
			m_meths = new MethodDefinition [mTable.Rows.Count];
			for (int i = 0; i < mTable.Rows.Count; i++) {
				MethodRow mRow = mTable [i];
				MethodDefinition meth = new MethodDefinition (
					m_root.Streams.StringsHeap [mRow.Name],
					mRow.Flags);
				meth.RVA = mRow.RVA;
				meth.ImplAttributes = mRow.ImplFlags;

				meth.MetadataToken = MetadataToken.FromMetadataRow (TokenType.Method, i);

				m_meths [i] = meth;
			}
		}

		void CompleteMethods ()
		{
			TypeDefTable tdefTable = m_tableReader.GetTypeDefTable ();

			if (!m_tHeap.HasTable (MethodTable.RId)) {
				m_meths = new MethodDefinition [0];
				return;
			}

			MethodTable methTable = m_tableReader.GetMethodTable ();
			ParamTable paramTable = m_tableReader.GetParamTable ();
			if (!m_tHeap.HasTable (ParamTable.RId))
				m_parameters = new ParameterDefinition [0];
			else
				m_parameters = new ParameterDefinition [paramTable.Rows.Count];

			for (int i = 0; i < m_typeDefs.Length; i++) {
				TypeDefinition dec = m_typeDefs [i];

				int index = i, next;

				if (index == tdefTable.Rows.Count - 1)
					next = methTable.Rows.Count + 1;
				else
					next = (int) (tdefTable [index + 1]).MethodList;

				for (int j = (int) tdefTable [index].MethodList; j < next; j++) {
					MethodRow methRow = methTable [j - 1];
					MethodDefinition mdef = m_meths [j - 1];
					if (mdef.IsConstructor)
						dec.Constructors.Add (mdef);
					else
						dec.Methods.Add (mdef);
					GenericContext context = new GenericContext (mdef);

					MethodDefSig msig = m_sigReader.GetMethodDefSig (methRow.Signature);
					mdef.HasThis = msig.HasThis;
					mdef.ExplicitThis = msig.ExplicitThis;
					mdef.CallingConvention = msig.MethCallConv;

					int prms;
					if (j == methTable.Rows.Count)
						prms = m_parameters.Length + 1;
					else
						prms = (int) (methTable [j]).ParamList;

					ParameterDefinition retparam = null;

					//TODO: optimize this
					int start = (int) methRow.ParamList - 1;

					if (paramTable != null && start < prms - 1) {

						ParamRow pRetRow = paramTable [start];

						if (pRetRow != null && pRetRow.Sequence == 0) { // ret type

							retparam = new ParameterDefinition (
								m_root.Streams.StringsHeap [pRetRow.Name],
								0,
								pRetRow.Flags,
								null);

							retparam.Method = mdef;
							m_parameters [start] = retparam;
							start++;
						}
					}

					for (int k = 0; k < msig.ParamCount; k++) {

						int pointer = start + k;

						ParamRow pRow = null;

						if (paramTable != null && pointer < prms - 1)
							pRow = paramTable [pointer];

						Param psig = msig.Parameters [k];

						ParameterDefinition pdef;
						if (pRow != null) {
							pdef = BuildParameterDefinition (
								m_root.Streams.StringsHeap [pRow.Name],
								pRow.Sequence, pRow.Flags, psig, context);
							pdef.MetadataToken = MetadataToken.FromMetadataRow (TokenType.Param, pointer);
							m_parameters [pointer] = pdef;
						} else
							pdef = BuildParameterDefinition (
								string.Concat ("A_", mdef.IsStatic ? k : k + 1),
								k + 1, (ParameterAttributes) 0, psig, context);

						pdef.Method = mdef;
						mdef.Parameters.Add (pdef);
					}

					mdef.ReturnType = GetMethodReturnType (msig, context);
					MethodReturnType mrt = mdef.ReturnType;
					mrt.Method = mdef;
					if (retparam != null) {
						mrt.Parameter = retparam;
						mrt.Parameter.ParameterType = mrt.ReturnType;
					}
				}
			}

			uint eprid = CodeReader.GetRid ((int) m_reader.Image.CLIHeader.EntryPointToken);
			if (eprid > 0 && eprid <= m_meths.Length)
				m_module.Assembly.EntryPoint = GetMethodDefAt (eprid);
		}

		void ReadMemberReferences ()
		{
			if (!m_tHeap.HasTable (MemberRefTable.RId))
				return;

			MemberRefTable mrefTable = m_tableReader.GetMemberRefTable ();
			m_memberRefs = new MemberReference [mrefTable.Rows.Count];
		}

		public override void VisitExternTypeCollection (ExternTypeCollection externs)
		{
			ExternTypeCollection ext = externs;

			if (!m_tHeap.HasTable (ExportedTypeTable.RId))
				return;

			ExportedTypeTable etTable = m_tableReader.GetExportedTypeTable ();
			TypeReference [] buffer = new TypeReference [etTable.Rows.Count];

			for (int i = 0; i < etTable.Rows.Count; i++) {
				ExportedTypeRow etRow = etTable [i];
				if (etRow.Implementation.TokenType != TokenType.File)
					continue;

				string name = m_root.Streams.StringsHeap [etRow.TypeName];
				string ns = m_root.Streams.StringsHeap [etRow.TypeNamespace];
				if (ns.Length == 0)
					buffer [i] = m_module.TypeReferences [name];
				else
					buffer [i] = m_module.TypeReferences [string.Concat (ns, '.', name)];
			}

			for (int i = 0; i < etTable.Rows.Count; i++) {
				ExportedTypeRow etRow = etTable [i];
				if (etRow.Implementation.TokenType != TokenType.ExportedType)
					continue;

				TypeReference owner = buffer [etRow.Implementation.RID - 1];
				string name = m_root.Streams.StringsHeap [etRow.TypeName];
				buffer [i] = m_module.TypeReferences [string.Concat (owner.FullName, '/', name)];
			}

			for (int i = 0; i < buffer.Length; i++) {
				TypeReference curs = buffer [i];
				if (curs != null)
					ext.Add (curs);
			}
		}

		static object GetFixedArgValue (CustomAttrib.FixedArg fa)
		{
			if (fa.SzArray) {
				object [] vals = new object [fa.NumElem];
				for (int j = 0; j < vals.Length; j++)
					vals [j] = fa.Elems [j].Value;
				return vals;
			} else
				return fa.Elems [0].Value;
		}

		TypeReference GetFixedArgType (CustomAttrib.FixedArg fa)
		{
			if (fa.SzArray) {
				if (fa.NumElem == 0)
					return new ArrayType (SearchCoreType (Constants.Object));
				else
					return new ArrayType (fa.Elems [0].ElemType);
			} else
				return fa.Elems [0].ElemType;
		}

		protected CustomAttribute BuildCustomAttribute (MethodReference ctor, CustomAttrib sig)
		{
			CustomAttribute cattr = new CustomAttribute (ctor);

			foreach (CustomAttrib.FixedArg fa in sig.FixedArgs)
				cattr.ConstructorParameters.Add (GetFixedArgValue (fa));

			foreach (CustomAttrib.NamedArg na in sig.NamedArgs) {
				object value = GetFixedArgValue (na.FixedArg);
				if (na.Field) {
					cattr.Fields [na.FieldOrPropName] = value;
					cattr.SetFieldType (na.FieldOrPropName, GetFixedArgType (na.FixedArg));
				} else if (na.Property) {
					cattr.Properties [na.FieldOrPropName] = value;
					cattr.SetPropertyType (na.FieldOrPropName, GetFixedArgType (na.FixedArg));
				} else
					throw new ReflectionException ("Non valid named arg");
			}

			return cattr;
		}

		public ParameterDefinition BuildParameterDefinition (string name, int sequence,
			ParameterAttributes attrs, Param psig, GenericContext context)
		{
			ParameterDefinition ret = new ParameterDefinition (name, sequence, attrs, null);
			TypeReference paramType;

			if (psig.ByRef)
				paramType = new ReferenceType (GetTypeRefFromSig (psig.Type, context));
			else if (psig.TypedByRef)
				paramType = SearchCoreType (Constants.TypedReference);
			else
				paramType = GetTypeRefFromSig (psig.Type, context);

			if (psig.CustomMods.Length > 0)
				paramType = GetModifierType (psig.CustomMods, paramType);

			ret.ParameterType = paramType;

			return ret;
		}

		protected SecurityDeclaration BuildSecurityDeclaration (DeclSecurityRow dsRow)
		{
			return BuildSecurityDeclaration (dsRow.Action, m_root.Streams.BlobHeap.Read (dsRow.PermissionSet));
		}

		public SecurityDeclaration BuildSecurityDeclaration (SecurityAction action, byte [] permset)
		{
			if (m_secReader == null)
				m_secReader = new SecurityDeclarationReader (m_root, this);

			return m_secReader.FromByteArray (action, permset);
		}

		protected MarshalSpec BuildMarshalDesc (MarshalSig ms, IHasMarshalSpec container)
		{
			if (ms.Spec is MarshalSig.Array) {
				ArrayMarshalSpec amd = new ArrayMarshalSpec (container);
				MarshalSig.Array ar = (MarshalSig.Array) ms.Spec;
				amd.ElemType = ar.ArrayElemType;
				amd.NumElem = ar.NumElem;
				amd.ParamNum = ar.ParamNum;
				amd.ElemMult = ar.ElemMult;
				return amd;
			} else if (ms.Spec is MarshalSig.CustomMarshaler) {
				CustomMarshalerSpec cmd = new CustomMarshalerSpec (container);
				MarshalSig.CustomMarshaler cmsig = (MarshalSig.CustomMarshaler) ms.Spec;
				cmd.Guid = cmsig.Guid.Length > 0 ? new Guid (cmsig.Guid) : new Guid ();
				cmd.UnmanagedType = cmsig.UnmanagedType;
				cmd.ManagedType = cmsig.ManagedType;
				cmd.Cookie = cmsig.Cookie;
				return cmd;
			} else if (ms.Spec is MarshalSig.FixedArray) {
				FixedArraySpec fad = new FixedArraySpec (container);
				MarshalSig.FixedArray fasig = (MarshalSig.FixedArray) ms.Spec;
				fad.ElemType = fasig.ArrayElemType;
				fad.NumElem = fasig.NumElem;
				return fad;
			} else if (ms.Spec is MarshalSig.FixedSysString) {
				FixedSysStringSpec fssc = new FixedSysStringSpec (container);
				fssc.Size = ((MarshalSig.FixedSysString) ms.Spec).Size;
				return fssc;
			} else if (ms.Spec is MarshalSig.SafeArray) {
				SafeArraySpec sad = new SafeArraySpec (container);
				sad.ElemType = ((MarshalSig.SafeArray) ms.Spec).ArrayElemType;
				return sad;
			} else {
				return new MarshalSpec (ms.NativeInstrinsic, container);
			}
		}

		public TypeReference GetModifierType (CustomMod [] cmods, TypeReference type)
		{
			TypeReference ret = type;
			for (int i = cmods.Length - 1; i >= 0; i--) {
				CustomMod cmod = cmods [i];
				TypeReference modType;

				if (cmod.TypeDefOrRef.TokenType == TokenType.TypeDef)
					modType = GetTypeDefAt (cmod.TypeDefOrRef.RID);
				else
					modType = GetTypeRefAt (cmod.TypeDefOrRef.RID);

				if (cmod.CMOD == CustomMod.CMODType.OPT)
					ret = new ModifierOptional (ret, modType);
				else if (cmod.CMOD == CustomMod.CMODType.REQD)
					ret = new ModifierRequired (ret, modType);
			}
			return ret;
		}

		public MethodReturnType GetMethodReturnType (MethodSig msig, GenericContext context)
		{
			TypeReference retType;
			if (msig.RetType.Void)
				retType = SearchCoreType (Constants.Void);
			else if (msig.RetType.ByRef)
				retType = new ReferenceType (GetTypeRefFromSig (msig.RetType.Type, context));
			else if (msig.RetType.TypedByRef)
				retType = SearchCoreType (Constants.TypedReference);
			else
				retType = GetTypeRefFromSig (msig.RetType.Type, context);

			if (msig.RetType.CustomMods.Length > 0)
				retType = GetModifierType (msig.RetType.CustomMods, retType);

			return new MethodReturnType (retType);
		}

		public TypeReference GetTypeRefFromSig (SigType t, GenericContext context)
		{
			switch (t.ElementType) {
			case ElementType.Class :
				CLASS c = t as CLASS;
				return GetTypeDefOrRef (c.Type, context);
			case ElementType.ValueType :
				VALUETYPE vt = t as VALUETYPE;
				TypeReference vtr = GetTypeDefOrRef (vt.Type, context);
				vtr.IsValueType = true;
				return vtr;
			case ElementType.String :
				return SearchCoreType (Constants.String);
			case ElementType.Object :
				return SearchCoreType (Constants.Object);
			case ElementType.Void :
				return SearchCoreType (Constants.Void);
			case ElementType.Boolean :
				return SearchCoreType (Constants.Boolean);
			case ElementType.Char :
				return SearchCoreType (Constants.Char);
			case ElementType.I1 :
				return SearchCoreType (Constants.SByte);
			case ElementType.U1 :
				return SearchCoreType (Constants.Byte);
			case ElementType.I2 :
				return SearchCoreType (Constants.Int16);
			case ElementType.U2 :
				return SearchCoreType (Constants.UInt16);
			case ElementType.I4 :
				return SearchCoreType (Constants.Int32);
			case ElementType.U4 :
				return SearchCoreType (Constants.UInt32);
			case ElementType.I8 :
				return SearchCoreType (Constants.Int64);
			case ElementType.U8 :
				return SearchCoreType (Constants.UInt64);
			case ElementType.R4 :
				return SearchCoreType (Constants.Single);
			case ElementType.R8 :
				return SearchCoreType (Constants.Double);
			case ElementType.I :
				return SearchCoreType (Constants.IntPtr);
			case ElementType.U :
				return SearchCoreType (Constants.UIntPtr);
			case ElementType.TypedByRef :
				return SearchCoreType (Constants.TypedReference);
			case ElementType.Array :
				ARRAY ary = t as ARRAY;
				return new ArrayType (GetTypeRefFromSig (ary.Type, context), ary.Shape);
			case ElementType.SzArray :
				SZARRAY szary = t as SZARRAY;
				ArrayType at = new ArrayType (GetTypeRefFromSig (szary.Type, context));
				return at;
			case ElementType.Ptr :
				PTR pointer = t as PTR;
				if (pointer.Void)
					return new PointerType (SearchCoreType (Constants.Void));
				return new PointerType (GetTypeRefFromSig (pointer.PtrType, context));
			case ElementType.FnPtr :
				FNPTR funcptr = t as FNPTR;
				FunctionPointerType fnptr = new FunctionPointerType (funcptr.Method.HasThis, funcptr.Method.ExplicitThis,
					funcptr.Method.MethCallConv, GetMethodReturnType (funcptr.Method, context));

				for (int i = 0; i < funcptr.Method.ParamCount; i++) {
					Param p = funcptr.Method.Parameters [i];
					fnptr.Parameters.Add (BuildParameterDefinition (
							string.Concat ("A_", i),
							i, (ParameterAttributes) 0,
							p, context));
				}

				MethodRefSig refSig = funcptr.Method as MethodRefSig;
				if (refSig != null && refSig.Sentinel >= 0)
					CreateSentinel (fnptr, refSig.Sentinel);

				return fnptr;
			case ElementType.Var:
				VAR var = t as VAR;
				if (context.AllowCreation)
					CheckGenericParameters (context, var);

				if (context.Type is GenericInstanceType)
					return (context.Type as GenericInstanceType).GenericArguments [var.Index];
				else
					return context.Type.GenericParameters [var.Index];
			case ElementType.MVar:
				MVAR mvar = t as MVAR;
				if (context.Method is GenericInstanceMethod)
					return (context.Method as GenericInstanceMethod).GenericArguments [mvar.Index];
				else
					return context.Method.GenericParameters [mvar.Index];
			case ElementType.GenericInst:
				GENERICINST ginst = t as GENERICINST;
				GenericInstanceType instance = new GenericInstanceType (GetTypeDefOrRef (ginst.Type, context));
				instance.IsValueType = ginst.ValueType;

				for (int i = 0; i < ginst.Signature.Arity; i++)
					instance.GenericArguments.Add (GetGenericArg (
						ginst.Signature.Types [i], context));

				return instance;
			default:
				break;
			}
			return null;
		}

		public static void CreateSentinel (IMethodSignature meth, int sentinel)
		{
			if (sentinel < 0 || sentinel >= meth.Parameters.Count)
				throw new ArgumentException ("Invalid sentinel");

			ParameterDefinition param = meth.Parameters [sentinel];
			param.ParameterType = new SentinelType (param.ParameterType);
		}

		TypeReference GetGenericArg (GenericArg arg, GenericContext context)
		{
			TypeReference type = GetTypeRefFromSig (arg.Type, context);
			if (arg.CustomMods != null && arg.CustomMods.Length > 0)
				type = GetModifierType (arg.CustomMods, type);
			return type;
		}

		static void CheckGenericParameters (GenericContext context, VAR v)
		{
			for (int i = context.Type.GenericParameters.Count; i <= v.Index; i++)
				context.Type.GenericParameters.Add (new GenericParameter (i, context.Type));
		}

		protected object GetConstant (uint pos, ElementType elemType)
		{
			byte [] constant = m_root.Streams.BlobHeap.Read (pos);
			BinaryReader br = new BinaryReader (new MemoryStream (constant));

			switch (elemType) {
			case ElementType.Boolean :
				return br.ReadByte () == 1;
			case ElementType.Char :
				return (char) br.ReadUInt16 ();
			case ElementType.I1 :
				return br.ReadSByte ();
			case ElementType.I2 :
				return br.ReadInt16 ();
			case ElementType.I4 :
				return br.ReadInt32 ();
			case ElementType.I8 :
				return br.ReadInt64 ();
			case ElementType.U1 :
				return br.ReadByte ();
			case ElementType.U2 :
				return br.ReadUInt16 ();
			case ElementType.U4 :
				return br.ReadUInt32 ();
			case ElementType.U8 :
				return br.ReadUInt64 ();
			case ElementType.R4 :
				return br.ReadSingle ();
			case ElementType.R8 :
				return br.ReadDouble ();
			case ElementType.String :
				byte [] bytes = br.ReadBytes (constant.Length);
				string str = Encoding.Unicode.GetString (bytes, 0, bytes.Length);
				return str;
			case ElementType.Class :
				return null;
			default :
				throw new ReflectionException ("Non valid element in constant table");
			}
		}

		protected void SetInitialValue (FieldDefinition field)
		{
			int size = 0;
			TypeReference fieldType = field.FieldType;
			switch (fieldType.FullName) {
			case Constants.Byte:
			case Constants.SByte:
				size = 1;
				break;
			case Constants.Int16:
			case Constants.UInt16:
			case Constants.Char:
				size = 2;
				break;
			case Constants.Int32:
			case Constants.UInt32:
			case Constants.Single:
				size = 4;
				break;
			case Constants.Int64:
			case Constants.UInt64:
			case Constants.Double:
				size = 8;
				break;
			default:
				while (fieldType is TypeSpecification)
					fieldType = ((TypeSpecification) fieldType).ElementType;

				TypeDefinition fieldTypeDef = fieldType as TypeDefinition;

				if (fieldTypeDef != null)
					size = (int) fieldTypeDef.ClassSize;
				break;
			}

			if (size > 0 && field.RVA != RVA.Zero) {
				BinaryReader br = m_reader.MetadataReader.GetDataReader (field.RVA);
				field.InitialValue = br == null ? new byte [size] : br.ReadBytes (size);
			} else
				field.InitialValue = new byte [0];
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/ReflectionWriter.cs
================================================
//
// ReflectionWriter.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 - 2007 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;
	using System.Collections;
	using System.Globalization;
	using System.Text;

	using Mono.Cecil.Binary;
	using Mono.Cecil.Cil;
	using Mono.Cecil.Metadata;
	using Mono.Cecil.Signatures;

	internal sealed class ReflectionWriter : BaseReflectionVisitor {

		StructureWriter m_structureWriter;
		ModuleDefinition m_mod;
		SignatureWriter m_sigWriter;
		CodeWriter m_codeWriter;
		MetadataWriter m_mdWriter;
		MetadataTableWriter m_tableWriter;
		MetadataRowWriter m_rowWriter;

		bool m_saveSymbols;
		string m_asmOutput;
		ISymbolWriter m_symbolWriter;

		ArrayList m_typeDefStack;
		ArrayList m_methodStack;
		ArrayList m_fieldStack;
		ArrayList m_genericParamStack;
		IDictionary m_typeSpecCache;

		uint m_methodIndex;
		uint m_fieldIndex;
		uint m_paramIndex;
		uint m_eventIndex;
		uint m_propertyIndex;

		MemoryBinaryWriter m_constWriter;

		public StructureWriter StructureWriter {
			get { return m_structureWriter; }
			set {
				 m_structureWriter = value;

				Initialize ();
			}
		}

		public CodeWriter CodeWriter {
			get { return m_codeWriter; }
		}

		public bool SaveSymbols {
			get { return m_saveSymbols; }
			set { m_saveSymbols = value; }
		}

		public string OutputFile
		{
			get { return m_asmOutput; }
			set { m_asmOutput = value; }
		}

		public ISymbolWriter SymbolWriter {
			get { return m_symbolWriter; }
			set { m_symbolWriter = value; }
		}

		public SignatureWriter SignatureWriter {
			get { return m_sigWriter; }
		}

		public MetadataWriter MetadataWriter {
			get { return m_mdWriter; }
		}

		public MetadataTableWriter MetadataTableWriter {
			get { return m_tableWriter; }
		}

		public MetadataRowWriter MetadataRowWriter {
			get { return m_rowWriter; }
		}

		public ReflectionWriter (ModuleDefinition mod)
		{
			m_mod = mod;
		}

		void Initialize ()
		{
			m_mdWriter = new MetadataWriter (
				m_mod.Assembly,
				m_mod.Image.MetadataRoot,
				m_structureWriter.Assembly.Kind,
				m_mod.Assembly.Runtime,
				m_structureWriter.GetWriter ());
			m_tableWriter = m_mdWriter.GetTableVisitor ();
			m_rowWriter = m_tableWriter.GetRowVisitor () as MetadataRowWriter;
			m_sigWriter = new SignatureWriter (m_mdWriter);
			m_codeWriter = new CodeWriter (this, m_mdWriter.CilWriter);

			m_typeDefStack = new ArrayList ();
			m_methodStack = new ArrayList ();
			m_fieldStack = new ArrayList ();
			m_genericParamStack = new ArrayList ();
			m_typeSpecCache = new Hashtable ();

			m_methodIndex = 1;
			m_fieldIndex = 1;
			m_paramIndex = 1;
			m_eventIndex = 1;
			m_propertyIndex = 1;

			m_constWriter = new MemoryBinaryWriter ();
		}

		public TypeReference GetCoreType (string name)
		{
			return m_mod.Controller.Reader.SearchCoreType (name);
		}

		public static uint GetRidFor (IMetadataTokenProvider tp)
		{
			return tp.MetadataToken.RID;
		}

		public uint GetRidFor (AssemblyNameReference asmName)
		{
			return (uint) m_mod.AssemblyReferences.IndexOf (asmName) + 1;
		}

		public uint GetRidFor (ModuleDefinition mod)
		{
			return (uint) m_mod.Assembly.Modules.IndexOf (mod) + 1;
		}

		public uint GetRidFor (ModuleReference modRef)
		{
			return (uint) m_mod.ModuleReferences.IndexOf (modRef) + 1;
		}

		static bool IsTypeSpec (TypeReference type)
		{
			return type is TypeSpecification || type is GenericParameter;
		}

		public MetadataToken GetTypeDefOrRefToken (TypeReference type)
		{
			if (IsTypeSpec (type)) {
				uint sig = m_sigWriter.AddTypeSpec (GetTypeSpecSig (type));
				if (m_typeSpecCache.Contains (sig))
					return ((TypeReference) m_typeSpecCache [sig]).MetadataToken;

				TypeSpecTable tsTable = m_tableWriter.GetTypeSpecTable ();
				TypeSpecRow tsRow = m_rowWriter.CreateTypeSpecRow (sig);
				tsTable.Rows.Add (tsRow);
				type.MetadataToken = new MetadataToken (TokenType.TypeSpec, (uint) tsTable.Rows.Count);
				m_typeSpecCache [sig] = type;
				return type.MetadataToken;
			} else if (type != null)
				return type.MetadataToken;
			else // <Module> and interfaces
				return new MetadataToken (TokenType.TypeRef, 0);
		}

		public MetadataToken GetMethodSpecToken (GenericInstanceMethod gim)
		{
			uint sig = m_sigWriter.AddMethodSpec (GetMethodSpecSig (gim));
			MethodSpecTable msTable = m_tableWriter.GetMethodSpecTable ();

			for (int i = 0; i < msTable.Rows.Count; i++) {
				MethodSpecRow row = msTable [i];
				if (row.Method == gim.ElementMethod.MetadataToken && row.Instantiation == sig)
					return MetadataToken.FromMetadataRow (TokenType.MethodSpec, i);
			}

			MethodSpecRow msRow = m_rowWriter.CreateMethodSpecRow (
				gim.ElementMethod.MetadataToken,
				sig);
			msTable.Rows.Add (msRow);
			gim.MetadataToken = new MetadataToken (TokenType.MethodSpec, (uint) msTable.Rows.Count);
			return gim.MetadataToken;
		}

		public override void VisitModuleDefinition (ModuleDefinition mod)
		{
			mod.FullLoad ();
		}

		public override void VisitTypeDefinitionCollection (TypeDefinitionCollection types)
		{
			TypeDefTable tdTable = m_tableWriter.GetTypeDefTable ();

			if (types [Constants.ModuleType] == null)
				types.Add (new TypeDefinition (
						Constants.ModuleType, string.Empty, TypeAttributes.NotPublic));

			foreach (TypeDefinition t in types)
				m_typeDefStack.Add (t);

			m_typeDefStack.Sort (TableComparers.TypeDef.Instance);

			for (int i = 0; i < m_typeDefStack.Count; i++) {
				TypeDefinition t = (TypeDefinition) m_typeDefStack [i];
				if (t.Module.Assembly != m_mod.Assembly)
					throw new ReflectionException ("A type as not been correctly imported");

				t.MetadataToken = new MetadataToken (TokenType.TypeDef, (uint) (i + 1));
			}

			foreach (TypeDefinition t in m_typeDefStack) {
				TypeDefRow tdRow = m_rowWriter.CreateTypeDefRow (
					t.Attributes,
					m_mdWriter.AddString (t.Name),
					m_mdWriter.AddString (t.Namespace),
					GetTypeDefOrRefToken (t.BaseType),
					0,
					0);

				tdTable.Rows.Add (tdRow);
			}
		}

		public void CompleteTypeDefinitions ()
		{
			TypeDefTable tdTable = m_tableWriter.GetTypeDefTable ();

			for (int i = 0; i < m_typeDefStack.Count; i++) {
				TypeDefRow tdRow = tdTable [i];
				TypeDefinition t = (TypeDefinition) m_typeDefStack [i];
				tdRow.FieldList = m_fieldIndex;
				tdRow.MethodList = m_methodIndex;
				foreach (FieldDefinition field in t.Fields)
					VisitFieldDefinition (field);
				foreach (MethodDefinition ctor in t.Constructors)
					VisitMethodDefinition (ctor);
				foreach (MethodDefinition meth in t.Methods)
					VisitMethodDefinition (meth);

				if (t.HasLayoutInfo)
					WriteLayout (t);
			}

			foreach (FieldDefinition field in m_fieldStack) {
				VisitCustomAttributeCollection (field.CustomAttributes);
				if (field.MarshalSpec != null)
					VisitMarshalSpec (field.MarshalSpec);
			}

			foreach (MethodDefinition meth in m_methodStack) {
				VisitCustomAttributeCollection (meth.ReturnType.CustomAttributes);
				foreach (ParameterDefinition param in meth.Parameters)
					VisitCustomAttributeCollection (param.CustomAttributes);
				VisitGenericParameterCollection (meth.GenericParameters);
				VisitOverrideCollection (meth.Overrides);
				VisitCustomAttributeCollection (meth.CustomAttributes);
				VisitSecurityDeclarationCollection (meth.SecurityDeclarations);
				if (meth.PInvokeInfo != null) {
					meth.Attributes |= MethodAttributes.PInvokeImpl;
					VisitPInvokeInfo (meth.PInvokeInfo);
				}
			}

			foreach (TypeDefinition t in m_typeDefStack)
				t.Accept (this);
		}

		public override void VisitTypeReferenceCollection (TypeReferenceCollection refs)
		{
			ArrayList orderedTypeRefs = new ArrayList (refs.Count);
			foreach (TypeReference tr in refs)
				orderedTypeRefs.Add (tr);

			orderedTypeRefs.Sort (TableComparers.TypeRef.Instance);

			TypeRefTable trTable = m_tableWriter.GetTypeRefTable ();
			foreach (TypeReference t in orderedTypeRefs) {
				MetadataToken scope;

				if (t.Module.Assembly != m_mod.Assembly)
					throw new ReflectionException ("A type as not been correctly imported");

				if (t.Scope == null)
					continue;

				if (t.DeclaringType != null)
					scope = new MetadataToken (TokenType.TypeRef, GetRidFor (t.DeclaringType));
				else if (t.Scope is AssemblyNameReference)
					scope = new MetadataToken (TokenType.AssemblyRef,
						GetRidFor ((AssemblyNameReference) t.Scope));
				else if (t.Scope is ModuleDefinition)
					scope = new MetadataToken (TokenType.Module,
						GetRidFor ((ModuleDefinition) t.Scope));
				else if (t.Scope is ModuleReference)
					scope = new MetadataToken (TokenType.ModuleRef,
						GetRidFor ((ModuleReference) t.Scope));
				else
					scope = new MetadataToken (TokenType.ExportedType, 0);

				TypeRefRow trRow = m_rowWriter.CreateTypeRefRow (
					scope,
					m_mdWriter.AddString (t.Name),
					m_mdWriter.AddString (t.Namespace));

				trTable.Rows.Add (trRow);
				t.MetadataToken = new MetadataToken (TokenType.TypeRef, (uint) trTable.Rows.Count);
			}
		}

		public override void VisitMemberReferenceCollection (MemberReferenceCollection members)
		{
			if (members.Count == 0)
				return;

			MemberRefTable mrTable = m_tableWriter.GetMemberRefTable ();
			foreach (MemberReference member in members) {
				uint sig = 0;
				if (member is FieldReference)
					sig = m_sigWriter.AddFieldSig (GetFieldSig (member as FieldReference));
				else if (member is MethodReference)
					sig = m_sigWriter.AddMethodRefSig (GetMethodRefSig ((MethodReference) member));

				MemberRefRow mrRow = m_rowWriter.CreateMemberRefRow (
					GetTypeDefOrRefToken (member.DeclaringType),
					m_mdWriter.AddString (member.Name),
					sig);

				mrTable.Rows.Add (mrRow);
				member.MetadataToken = new MetadataToken (
					TokenType.MemberRef, (uint) mrTable.Rows.Count);
				}
		}

		public override void VisitGenericParameterCollection (GenericParameterCollection parameters)
		{
			if (parameters.Count == 0)
				return;

			foreach (GenericParameter gp in parameters)
				m_genericParamStack.Add (gp);
		}

		public override void VisitInterfaceCollection (InterfaceCollection interfaces)
		{
			if (interfaces.Count == 0)
				return;

			InterfaceImplTable iiTable = m_tableWriter.GetInterfaceImplTable ();
			foreach (TypeReference interf in interfaces) {
				InterfaceImplRow iiRow = m_rowWriter.CreateInterfaceImplRow (
					GetRidFor (interfaces.Container),
					GetTypeDefOrRefToken (interf));

				iiTable.Rows.Add (iiRow);
			}
		}

		public override void VisitExternTypeCollection (ExternTypeCollection externs)
		{
			VisitCollection (externs);
		}

		public override void VisitExternType (TypeReference externType)
		{
			// TODO
		}

		public override void VisitOverrideCollection (OverrideCollection meths)
		{
			if (meths.Count == 0)
				return;

			MethodImplTable miTable = m_tableWriter.GetMethodImplTable ();
			foreach (MethodReference ov in meths) {
				MethodImplRow miRow = m_rowWriter.CreateMethodImplRow (
					GetRidFor (meths.Container.DeclaringType as TypeDefinition),
					new MetadataToken (TokenType.Method, GetRidFor (meths.Container)),
					ov.MetadataToken);

				miTable.Rows.Add (miRow);
			}
		}

		public override void VisitNestedTypeCollection (NestedTypeCollection nestedTypes)
		{
			if (nestedTypes.Count == 0)
				return;

			NestedClassTable ncTable = m_tableWriter.GetNestedClassTable ();
			foreach (TypeDefinition nested in nestedTypes) {
				NestedClassRow ncRow = m_rowWriter.CreateNestedClassRow (
					nested.MetadataToken.RID,
					GetRidFor (nestedTypes.Container));

				ncTable.Rows.Add (ncRow);
			}
		}

		public override void VisitParameterDefinitionCollection (ParameterDefinitionCollection parameters)
		{
			if (parameters.Count == 0)
				return;

			ushort seq = 1;
			ParamTable pTable = m_tableWriter.GetParamTable ();
			foreach (ParameterDefinition param in parameters)
				InsertParameter (pTable, param, seq++);
		}

		void InsertParameter (ParamTable pTable, ParameterDefinition param, ushort seq)
		{
			ParamRow pRow = m_rowWriter.CreateParamRow (
				param.Attributes,
				seq,
				m_mdWriter.AddString (param.Name));

			pTable.Rows.Add (pRow);
			param.MetadataToken = new MetadataToken (TokenType.Param, (uint) pTable.Rows.Count);

			if (param.MarshalSpec != null)
				param.MarshalSpec.Accept (this);

			if (param.HasConstant)
				WriteConstant (param, param.ParameterType);

			m_paramIndex++;
		}

		static bool RequiresParameterRow (MethodReturnType mrt)
		{
			return mrt.HasConstant || mrt.MarshalSpec != null ||
				mrt.CustomAttributes.Count > 0 || mrt.Parameter.Attributes != (ParameterAttributes) 0;
		}

		public override void VisitMethodDefinition (MethodDefinition method)
		{
			MethodTable mTable = m_tableWriter.GetMethodTable ();
			MethodRow mRow = m_rowWriter.CreateMethodRow (
				RVA.Zero,
				method.ImplAttributes,
				method.Attributes,
				m_mdWriter.AddString (method.Name),
				m_sigWriter.AddMethodDefSig (GetMethodDefSig (method)),
				m_paramIndex);

			mTable.Rows.Add (mRow);
			m_methodStack.Add (method);
			method.MetadataToken = new MetadataToken (TokenType.Method, (uint) mTable.Rows.Count);
			m_methodIndex++;

			if (RequiresParameterRow (method.ReturnType))
				InsertParameter (m_tableWriter.GetParamTable (), method.ReturnType.Parameter, 0);

			VisitParameterDefinitionCollection (method.Parameters);
		}

		public override void VisitPInvokeInfo (PInvokeInfo pinvk)
		{
			ImplMapTable imTable = m_tableWriter.GetImplMapTable ();
			ImplMapRow imRow = m_rowWriter.CreateImplMapRow (
				pinvk.Attributes,
				new MetadataToken (TokenType.Method, GetRidFor (pinvk.Method)),
				m_mdWriter.AddString (pinvk.EntryPoint),
				GetRidFor (pinvk.Module));

			imTable.Rows.Add (imRow);
		}

		public override void VisitEventDefinitionCollection (EventDefinitionCollection events)
		{
			if (events.Count == 0)
				return;

			EventMapTable emTable = m_tableWriter.GetEventMapTable ();
			EventMapRow emRow = m_rowWriter.CreateEventMapRow (
				GetRidFor (events.Container),
				m_eventIndex);

			emTable.Rows.Add (emRow);
			VisitCollection (events);
		}

		public override void VisitEventDefinition (EventDefinition evt)
		{
			EventTable eTable = m_tableWriter.GetEventTable ();
			EventRow eRow = m_rowWriter.CreateEventRow (
				evt.Attributes,
				m_mdWriter.AddString (evt.Name),
				GetTypeDefOrRefToken (evt.EventType));

			eTable.Rows.Add (eRow);
			evt.MetadataToken = new MetadataToken (TokenType.Event, (uint) eTable.Rows.Count);

			if (evt.AddMethod != null)
				WriteSemantic (MethodSemanticsAttributes.AddOn, evt, evt.AddMethod);

			if (evt.InvokeMethod != null)
				WriteSemantic (MethodSemanticsAttributes.Fire, evt, evt.InvokeMethod);

			if (evt.RemoveMethod != null)
				WriteSemantic (MethodSemanticsAttributes.RemoveOn, evt, evt.RemoveMethod);

			m_eventIndex++;
		}

		public override void VisitFieldDefinition (FieldDefinition field)
		{
			FieldTable fTable = m_tableWriter.GetFieldTable ();
			FieldRow fRow = m_rowWriter.CreateFieldRow (
				field.Attributes,
				m_mdWriter.AddString (field.Name),
				m_sigWriter.AddFieldSig (GetFieldSig (field)));

			fTable.Rows.Add (fRow);
			field.MetadataToken = new MetadataToken (TokenType.Field, (uint) fTable.Rows.Count);
			m_fieldIndex++;

			if (field.HasConstant)
				WriteConstant (field, field.FieldType);

			if (field.HasLayoutInfo)
				WriteLayout (field);

			m_fieldStack.Add (field);
		}

		public override void VisitPropertyDefinitionCollection (PropertyDefinitionCollection properties)
		{
			if (properties.Count == 0)
				return;

			PropertyMapTable pmTable = m_tableWriter.GetPropertyMapTable ();
			PropertyMapRow pmRow = m_rowWriter.CreatePropertyMapRow (
				GetRidFor (properties.Container),
				m_propertyIndex);

			pmTable.Rows.Add (pmRow);
			VisitCollection (properties);
		}

		public override void VisitPropertyDefinition (PropertyDefinition property)
		{
			PropertyTable pTable = m_tableWriter.GetPropertyTable ();
			PropertyRow pRow = m_rowWriter.CreatePropertyRow (
				property.Attributes,
				m_mdWriter.AddString (property.Name),
				m_sigWriter.AddPropertySig (GetPropertySig (property)));

			pTable.Rows.Add (pRow);
			property.MetadataToken = new MetadataToken (TokenType.Property, (uint) pTable.Rows.Count);

			if (property.GetMethod != null)
				WriteSemantic (MethodSemanticsAttributes.Getter, property, property.GetMethod);

			if (property.SetMethod != null)
				WriteSemantic (MethodSemanticsAttributes.Setter, property, property.SetMethod);

			if (property.HasConstant)
				WriteConstant (property, property.PropertyType);

			m_propertyIndex++;
		}

		public override void VisitSecurityDeclarationCollection (SecurityDeclarationCollection secDecls)
		{
			if (secDecls.Count == 0)
				return;

			DeclSecurityTable dsTable = m_tableWriter.GetDeclSecurityTable ();
			foreach (SecurityDeclaration secDec in secDecls) {
				DeclSecurityRow dsRow = m_rowWriter.CreateDeclSecurityRow (
					secDec.Action,
					secDecls.Container.MetadataToken,
					m_mdWriter.AddBlob (secDec.Resolved ?
						m_mod.GetAsByteArray (secDec) : secDec.Blob));

				dsTable.Rows.Add (dsRow);
			}
		}

		public override void VisitCustomAttributeCollection (CustomAttributeCollection customAttrs)
		{
			if (customAttrs.Count == 0)
				return;

			CustomAttributeTable caTable = m_tableWriter.GetCustomAttributeTable ();
			foreach (CustomAttribute ca in customAttrs) {
				MetadataToken parent;
				if (customAttrs.Container is AssemblyDefinition)
					parent = new MetadataToken (TokenType.Assembly, 1);
				else if (customAttrs.Container is ModuleDefinition)
					parent = new MetadataToken (TokenType.Module, 1);
				else if (customAttrs.Container is IMetadataTokenProvider)
					parent = (customAttrs.Container as IMetadataTokenProvider).MetadataToken;
				else
					throw new ReflectionException ("Unknown Custom Attribute parent");

				uint value = ca.Resolved ?
					m_sigWriter.AddCustomAttribute (GetCustomAttributeSig (ca), ca.Constructor) :
					m_mdWriter.AddBlob (m_mod.GetAsByteArray (ca));
				CustomAttributeRow caRow = m_rowWriter.CreateCustomAttributeRow (
					parent,
					ca.Constructor.MetadataToken,
					value);

				caTable.Rows.Add (caRow);
			}
		}

		public override void VisitMarshalSpec (MarshalSpec marshalSpec)
		{
			FieldMarshalTable fmTable = m_tableWriter.GetFieldMarshalTable ();
			FieldMarshalRow fmRow = m_rowWriter.CreateFieldMarshalRow (
				marshalSpec.Container.MetadataToken,
				m_sigWriter.AddMarshalSig (GetMarshalSig (marshalSpec)));

			fmTable.Rows.Add (fmRow);
		}

		void WriteConstant (IHasConstant hc, TypeReference type)
		{
			ConstantTable cTable = m_tableWriter.GetConstantTable ();
			ElementType et;
			if (type is TypeDefinition && (type as TypeDefinition).IsEnum) {
				Type t = hc.Constant.GetType ();
				if (t.IsEnum)
					t = Enum.GetUnderlyingType (t);

				et = GetCorrespondingType (string.Concat (t.Namespace, '.', t.Name));
			} else
				et = GetCorrespondingType (type.FullName);

			if (et == ElementType.Object)
				et = hc.Constant == null ?
					ElementType.Class :
					GetCorrespondingType (hc.Constant.GetType ().FullName);

			ConstantRow cRow = m_rowWriter.CreateConstantRow (
				et,
				hc.MetadataToken,
				m_mdWriter.AddBlob (EncodeConstant (et, hc.Constant)));

			cTable.Rows.Add (cRow);
		}

		void WriteLayout (FieldDefinition field)
		{
			FieldLayoutTable flTable = m_tableWriter.GetFieldLayoutTable ();
			FieldLayoutRow flRow = m_rowWriter.CreateFieldLayoutRow (
				field.Offset,
				GetRidFor (field));

			flTable.Rows.Add (flRow);
		}

		void WriteLayout (TypeDefinition type)
		{
			ClassLayoutTable clTable = m_tableWriter.GetClassLayoutTable ();
			ClassLayoutRow clRow = m_rowWriter.CreateClassLayoutRow (
				type.PackingSize,
				type.ClassSize,
				GetRidFor (type));

			clTable.Rows.Add (clRow);
		}

		void WriteSemantic (MethodSemanticsAttributes attrs,
			IMetadataTokenProvider member, MethodDefinition meth)
		{
			MethodSemanticsTable msTable = m_tableWriter.GetMethodSemanticsTable ();
			MethodSemanticsRow msRow = m_rowWriter.CreateMethodSemanticsRow (
				attrs,
				GetRidFor (meth),
				member.MetadataToken);

			msTable.Rows.Add (msRow);
		}

		void SortTables ()
		{
			TablesHeap th = m_mdWriter.GetMetadataRoot ().Streams.TablesHeap;
			th.Sorted = 0;

			if (th.HasTable (NestedClassTable.RId))
				m_tableWriter.GetNestedClassTable ().Rows.Sort (
					TableComparers.NestedClass.Instance);
			th.Sorted |= ((long) 1 << NestedClassTable.RId);

			if (th.HasTable (InterfaceImplTable.RId))
				m_tableWriter.GetInterfaceImplTable ().Rows.Sort (
					TableComparers.InterfaceImpl.Instance);
			th.Sorted |= ((long) 1 << InterfaceImplTable.RId);

			if (th.HasTable (ConstantTable.RId))
				m_tableWriter.GetConstantTable ().Rows.Sort (
					TableComparers.Constant.Instance);
			th.Sorted |= ((long) 1 << ConstantTable.RId);

			if (th.HasTable (MethodSemanticsTable.RId))
				m_tableWriter.GetMethodSemanticsTable ().Rows.Sort (
					TableComparers.MethodSem.Instance);
			th.Sorted |= ((long) 1 << MethodSemanticsTable.RId);

			if (th.HasTable (FieldMarshalTable.RId))
				m_tableWriter.GetFieldMarshalTable ().Rows.Sort (
					TableComparers.FieldMarshal.Instance);
			th.Sorted |= ((long) 1 << FieldMarshalTable.RId);

			if (th.HasTable (ClassLayoutTable.RId))
				m_tableWriter.GetClassLayoutTable ().Rows.Sort (
					TableComparers.TypeLayout.Instance);
			th.Sorted |= ((long) 1 << ClassLayoutTable.RId);

			if (th.HasTable (FieldLayoutTable.RId))
				m_tableWriter.GetFieldLayoutTable ().Rows.Sort (
					TableComparers.FieldLayout.Instance);
			th.Sorted |= ((long) 1 << FieldLayoutTable.RId);

			if (th.HasTable (ImplMapTable.RId))
				m_tableWriter.GetImplMapTable ().Rows.Sort (
					TableComparers.PInvoke.Instance);
			th.Sorted |= ((long) 1 << ImplMapTable.RId);

			if (th.HasTable (FieldRVATable.RId))
				m_tableWriter.GetFieldRVATable ().Rows.Sort (
					TableComparers.FieldRVA.Instance);
			th.Sorted |= ((long) 1 << FieldRVATable.RId);

			if (th.HasTable (MethodImplTable.RId))
				m_tableWriter.GetMethodImplTable ().Rows.Sort (
					TableComparers.Override.Instance);
			th.Sorted |= ((long) 1 << MethodImplTable.RId);

			if (th.HasTable (CustomAttributeTable.RId))
				m_tableWriter.GetCustomAttributeTable ().Rows.Sort (
					TableComparers.CustomAttribute.Instance);
			th.Sorted |= ((long) 1 << CustomAttributeTable.RId);

			if (th.HasTable (DeclSecurityTable.RId))
				m_tableWriter.GetDeclSecurityTable ().Rows.Sort (
					TableComparers.SecurityDeclaration.Instance);
			th.Sorted |= ((long) 1 << DeclSecurityTable.RId);
		}

		void CompleteGenericTables ()
		{
			if (m_genericParamStack.Count == 0)
				return;

			TablesHeap th = m_mdWriter.GetMetadataRoot ().Streams.TablesHeap;
			GenericParamTable gpTable = m_tableWriter.GetGenericParamTable ();
			GenericParamConstraintTable gpcTable = m_tableWriter.GetGenericParamConstraintTable ();

			m_genericParamStack.Sort (TableComparers.GenericParam.Instance);

			foreach (GenericParameter gp in m_genericParamStack) {
				GenericParamRow gpRow = m_rowWriter.CreateGenericParamRow (
					(ushort) gp.Owner.GenericParameters.IndexOf (gp),
					gp.Attributes,
					gp.Owner.MetadataToken,
					m_mdWriter.AddString (gp.Name));

				gpTable.Rows.Add (gpRow);
				gp.MetadataToken = new MetadataToken (TokenType.GenericParam, (uint) gpTable.Rows.Count);

				VisitCustomAttributeCollection (gp.CustomAttributes);

				if (gp.Constraints.Count == 0)
					continue;

				foreach (TypeReference constraint in gp.Constraints) {
					GenericParamConstraintRow gpcRow = m_rowWriter.CreateGenericParamConstraintRow (
						(uint) gpTable.Rows.Count,
						GetTypeDefOrRefToken (constraint));

					gpcTable.Rows.Add (gpcRow);
				}
			}

			th.Sorted |= ((long) 1 << GenericParamTable.RId);
			th.Sorted |= ((long) 1 << GenericParamConstraintTable.RId);
		}

		public override void TerminateModuleDefinition (ModuleDefinition module)
		{
			VisitCustomAttributeCollection (module.Assembly.CustomAttributes);
			VisitSecurityDeclarationCollection (module.Assembly.SecurityDeclarations);
			VisitCustomAttributeCollection (module.CustomAttributes);

			CompleteGenericTables ();
			SortTables ();

			MethodTable mTable = m_tableWriter.GetMethodTable ();
			for (int i = 0; i < m_methodStack.Count; i++) {
				MethodDefinition meth = (MethodDefinition) m_methodStack [i];
				if (meth.HasBody)
					mTable [i].RVA = m_codeWriter.WriteMethodBody (meth);
			}

			if (m_fieldStack.Count > 0) {
				FieldRVATable frTable = null;
				foreach (FieldDefinition field in m_fieldStack) {
					if (field.InitialValue != null && field.InitialValue.Length > 0) {
						if (frTable == null)
							frTable = m_tableWriter.GetFieldRVATable ();

						FieldRVARow frRow = m_rowWriter.CreateFieldRVARow (
							m_mdWriter.GetDataCursor (),
							field.MetadataToken.RID);

						m_mdWriter.AddData (field.InitialValue.Length + 3 & (~3));
						m_mdWriter.AddFieldInitData (field.InitialValue);

						frTable.Rows.Add (frRow);
					}
				}
			}

			if (m_symbolWriter != null)
				m_symbolWriter.Dispose ();

			if (m_mod.Assembly.EntryPoint != null)
				m_mdWriter.EntryPointToken =
					((uint) TokenType.Method) | GetRidFor (m_mod.Assembly.EntryPoint);

			m_mod.Image.MetadataRoot.Accept (m_mdWriter);
		}

		public static ElementType GetCorrespondingType (string fullName)
		{
			switch (fullName) {
			case Constants.Boolean :
				return ElementType.Boolean;
			case Constants.Char :
				return ElementType.Char;
			case Constants.SByte :
				return ElementType.I1;
			case Constants.Int16 :
				return ElementType.I2;
			case Constants.Int32 :
				return ElementType.I4;
			case Constants.Int64 :
				return ElementType.I8;
			case Constants.Byte :
				return ElementType.U1;
			case Constants.UInt16 :
				return ElementType.U2;
			case Constants.UInt32 :
				return ElementType.U4;
			case Constants.UInt64 :
				return ElementType.U8;
			case Constants.Single :
				return ElementType.R4;
			case Constants.Double :
				return ElementType.R8;
			case Constants.String :
				return ElementType.String;
			case Constants.Type :
				return ElementType.Type;
			case Constants.Object :
				return ElementType.Object;
			default:
				return ElementType.Class;
			}
		}

		byte [] EncodeConstant (ElementType et, object value)
		{
			m_constWriter.Empty ();

			if (value == null)
				et = ElementType.Class;

			IConvertible ic = value as IConvertible;
			IFormatProvider fp = CultureInfo.CurrentCulture.NumberFormat;

			switch (et) {
			case ElementType.Boolean :
				m_constWriter.Write ((byte) (ic.ToBoolean (fp) ? 1 : 0));
				break;
			case ElementType.Char :
				m_constWriter.Write ((ushort) ic.ToChar (fp));
				break;
			case ElementType.I1 :
				m_constWriter.Write (ic.ToSByte (fp));
				break;
			case ElementType.I2 :
				m_constWriter.Write (ic.ToInt16 (fp));
				break;
			case ElementType.I4 :
				m_constWriter.Write (ic.ToInt32 (fp));
				break;
			case ElementType.I8 :
				m_constWriter.Write (ic.ToInt64 (fp));
				break;
			case ElementType.U1 :
				m_constWriter.Write (ic.ToByte (fp));
				break;
			case ElementType.U2 :
				m_constWriter.Write (ic.ToUInt16 (fp));
				break;
			case ElementType.U4 :
				m_constWriter.Write (ic.ToUInt32 (fp));
				break;
			case ElementType.U8 :
				m_constWriter.Write (ic.ToUInt64 (fp));
				break;
			case ElementType.R4 :
				m_constWriter.Write (ic.ToSingle (fp));
				break;
			case ElementType.R8 :
				m_constWriter.Write (ic.ToDouble (fp));
				break;
			case ElementType.String :
				m_constWriter.Write (Encoding.Unicode.GetBytes ((string) value));
				break;
			case ElementType.Class :
				m_constWriter.Write (new byte [4]);
				break;
			default :
				throw new ReflectionException ("Non valid element for a constant");
			}

			return m_constWriter.ToArray ();
		}

		public SigType GetSigType (TypeReference type)
		{
			string name = type.FullName;

			switch (name) {
			case Constants.Void :
				return new SigType (ElementType.Void);
			case Constants.Object :
				return new SigType (ElementType.Object);
			case Constants.Boolean :
				return new SigType (ElementType.Boolean);
			case Constants.String :
				return new SigType (ElementType.String);
			case Constants.Char :
				return new SigType (ElementType.Char);
			case Constants.SByte :
				return new SigType (ElementType.I1);
			case Constants.Byte :
				return new SigType (ElementType.U1);
			case Constants.Int16 :
				return new SigType (ElementType.I2);
			case Constants.UInt16 :
				return new SigType (ElementType.U2);
			case Constants.Int32 :
				return new SigType (ElementType.I4);
			case Constants.UInt32 :
				return new SigType (ElementType.U4);
			case Constants.Int64 :
				return new SigType (ElementType.I8);
			case Constants.UInt64 :
				return new SigType (ElementType.U8);
			case Constants.Single :
				return new SigType (ElementType.R4);
			case Constants.Double :
				return new SigType (ElementType.R8);
			case Constants.IntPtr :
				return new SigType (ElementType.I);
			case Constants.UIntPtr :
				return new SigType (ElementType.U);
			case Constants.TypedReference :
				return new SigType (ElementType.TypedByRef);
			}

			if (type is GenericParameter) {
				GenericParameter gp = type as GenericParameter;
				int pos = gp.Owner.GenericParameters.IndexOf (gp);
				if (gp.Owner is TypeReference)
					return new VAR (pos);
				else if (gp.Owner is MethodReference)
					return new MVAR (pos);
				else
					throw new ReflectionException ("Unkown generic parameter type");
			} else if (type is GenericInstanceType) {
				GenericInstanceType git = type as GenericInstanceType;
				GENERICINST gi = new GENERICINST ();
				gi.ValueType = git.IsValueType;
				gi.Type = GetTypeDefOrRefToken (git.ElementType);
				gi.Signature = new GenericInstSignature ();
				gi.Signature.Arity = git.GenericArguments.Count;
				gi.Signature.Types = new GenericArg [gi.Signature.Arity];
				for (int i = 0; i < git.GenericArguments.Count; i++)
					gi.Signature.Types [i] = GetGenericArgSig (git.GenericArguments [i]);

				return gi;
			} else if (type is ArrayType) {
				ArrayType aryType = type as ArrayType;
				if (aryType.IsSizedArray) {
					SZARRAY szary = new SZARRAY ();
					szary.CustomMods = GetCustomMods (aryType.ElementType);
					szary.Type = GetSigType (aryType.ElementType);
					return szary;
				}

				// not optimized
				ArrayShape shape = new ArrayShape ();
				shape.Rank = aryType.Dimensions.Count;
				shape.NumSizes = 0;

				for (int i = 0; i < shape.Rank; i++) {
					ArrayDimension dim = aryType.Dimensions [i];
					if (dim.UpperBound > 0)
						shape.NumSizes++;
				}

				shape.Sizes = new int [shape.NumSizes];
				shape.NumLoBounds = shape.Rank;
				shape.LoBounds = new int [shape.NumLoBounds];

				for (int i = 0; i < shape.Rank; i++) {
					ArrayDimension dim = aryType.Dimensions [i];
					shape.LoBounds [i] = dim.LowerBound;
					if (dim.UpperBound > 0)
						shape.Sizes [i] = dim.UpperBound - dim.LowerBound + 1;
				}

				ARRAY ary = new ARRAY ();
				ary.Shape = shape;
				ary.CustomMods = GetCustomMods (aryType.ElementType);
				ary.Type = GetSigType (aryType.ElementType);
				return ary;
			} else if (type is PointerType) {
				PTR p = new PTR ();
				TypeReference elementType = (type as PointerType).ElementType;
				p.Void = elementType.FullName == Constants.Void;
				if (!p.Void) {
					p.CustomMods = GetCustomMods (elementType);
					p.PtrType = GetSigType (elementType);
				}
				return p;
			} else if (type is FunctionPointerType) {
				FNPTR fp = new FNPTR ();
				FunctionPointerType fptr = type as FunctionPointerType;

				int sentinel = fptr.GetSentinel ();
				if (sentinel < 0)
					fp.Method = GetMethodDefSig (fptr);
				else
					fp.Method = GetMethodRefSig (fptr);

				return fp;
			} else if (type is TypeSpecification) {
				return GetSigType ((type as TypeSpecification).ElementType);
			} else if (type.IsValueType) {
				VALUETYPE vt = new VALUETYPE ();
				vt.Type = GetTypeDefOrRefToken (type);
				return vt;
			} else {
				CLASS c = new CLASS ();
				c.Type = GetTypeDefOrRefToken (type);
				return c;
			}
		}

		public GenericArg GetGenericArgSig (TypeReference type)
		{
			GenericArg arg = new GenericArg (GetSigType (type));
			arg.CustomMods = GetCustomMods (type);
			return arg;
		}

		public CustomMod [] GetCustomMods (TypeReference type)
		{
			if (!(type is ModType))
				return new CustomMod [0];

			ArrayList cmods = new ArrayList ();
			TypeReference cur = type;
			while (cur is ModType) {
				if (cur is ModifierOptional) {
					CustomMod cmod = new CustomMod ();
					cmod.CMOD = CustomMod.CMODType.OPT;
					cmod.TypeDefOrRef = GetTypeDefOrRefToken ((cur as ModifierOptional).ModifierType);
					cmods.Add (cmod);
				} else if (cur is ModifierRequired) {
					CustomMod cmod = new CustomMod ();
					cmod.CMOD = CustomMod.CMODType.REQD;
					cmod.TypeDefOrRef = GetTypeDefOrRefToken ((cur as ModifierRequired).ModifierType);
					cmods.Add (cmod);
				}

				cur = (cur as ModType).ElementType;
			}

			return cmods.ToArray (typeof (CustomMod)) as CustomMod [];
		}

		public Signature GetMemberRefSig (MemberReference member)
		{
			if (member is FieldReference)
				return GetFieldSig (member as FieldReference);
			else
				return GetMemberRefSig (member as MethodReference);
		}

		public FieldSig GetFieldSig (FieldReference field)
		{
			FieldSig sig = new FieldSig ();
			sig.CallingConvention |= 0x6;
			sig.Field = true;
			sig.CustomMods = GetCustomMods (field.FieldType);
			sig.Type = GetSigType (field.FieldType);
			return sig;
		}

		Param [] GetParametersSig (ParameterDefinitionCollection parameters)
		{
			Param [] ret = new Param [parameters.Count];
			for (int i = 0; i < ret.Length; i++) {
				ParameterDefinition pDef = parameters [i];
				Param p = new Param ();
				p.CustomMods = GetCustomMods (pDef.ParameterType);
				if (pDef.ParameterType.FullName == Constants.TypedReference)
					p.TypedByRef = true;
				else if (IsByReferenceType (pDef.ParameterType)) {
					p.ByRef = true;
					p.Type = GetSigType (pDef.ParameterType);
				} else
					p.Type = GetSigType (pDef.ParameterType);
				ret [i] = p;
			}
			return ret;
		}

		void CompleteMethodSig (IMethodSignature meth, MethodSig sig)
		{
			sig.HasThis = meth.HasThis;
			sig.ExplicitThis = meth.ExplicitThis;
			if (sig.HasThis)
				sig.CallingConvention |= 0x20;
			if (sig.ExplicitThis)
				sig.CallingConvention |= 0x40;

			if ((meth.CallingConvention & MethodCallingConvention.VarArg) != 0)
				sig.CallingConvention |= 0x5;

			sig.ParamCount = meth.Parameters.Count;
			sig.Parameters = GetParametersSig (meth.Parameters);

			RetType rtSig = new RetType ();
			rtSig.CustomMods = GetCustomMods (meth.ReturnType.ReturnType);

			if (meth.ReturnType.ReturnType.FullName == Constants.Void)
				rtSig.Void = true;
			else if (meth.ReturnType.ReturnType.FullName == Constants.TypedReference)
				rtSig.TypedByRef = true;
			else if (IsByReferenceType (meth.ReturnType.ReturnType)) {
				rtSig.ByRef = true;
				rtSig.Type = GetSigType (meth.ReturnType.ReturnType);
			} else
				rtSig.Type = GetSigType (meth.ReturnType.ReturnType);

			sig.RetType = rtSig;
		}

		static bool IsByReferenceType (TypeReference type)
		{
			TypeSpecification ts = type as TypeSpecification;
			while (ts != null) {
				if (ts is ReferenceType)
					return true;
				ts = ts.ElementType as TypeSpecification;
			}
			return false;
		}

		public MethodRefSig GetMethodRefSig (IMethodSignature meth)
		{
			MethodReference methodRef = meth as MethodReference;
			if (methodRef != null && methodRef.GenericParameters.Count > 0)
				return GetMethodDefSig (meth);

			MethodRefSig methSig = new MethodRefSig ();

			CompleteMethodSig (meth, methSig);

			int sentinel = meth.GetSentinel ();
			if (sentinel >= 0)
				methSig.Sentinel = sentinel;

			if ((meth.CallingConvention & MethodCallingConvention.C) != 0)
				methSig.CallingConvention |= 0x1;
			else if ((meth.CallingConvention & MethodCallingConvention.StdCall) != 0)
				methSig.CallingConvention |= 0x2;
			else if ((meth.CallingConvention & MethodCallingConvention.ThisCall) != 0)
				methSig.CallingConvention |= 0x3;
			else if ((meth.CallingConvention & MethodCallingConvention.FastCall) != 0)
				methSig.CallingConvention |= 0x4;

			return methSig;
		}

		public MethodDefSig GetMethodDefSig (IMethodSignature meth)
		{
			MethodDefSig sig = new MethodDefSig ();

			CompleteMethodSig (meth, sig);

			MethodReference methodRef = meth as MethodReference;
			if (methodRef != null && methodRef.GenericParameters.Count > 0) {
				sig.CallingConvention |= 0x10;
				sig.GenericParameterCount = methodRef.GenericParameters.Count;
			}

			return sig;
		}

		public PropertySig GetPropertySig (PropertyDefinition prop)
		{
			PropertySig ps = new PropertySig ();
			ps.CallingConvention |= 0x8;

			bool hasThis;
			bool explicitThis;
			MethodCallingConvention mcc;
			ParameterDefinitionCollection parameters = prop.Parameters;

			MethodDefinition meth;
			if (prop.GetMethod != null)
				meth = prop.GetMethod;
			else if (prop.SetMethod != null)
				meth = prop.SetMethod;
			else
				meth = null;

			if (meth != null) {
				hasThis = meth.HasThis;
				explicitThis = meth.ExplicitThis;
				mcc = meth.CallingConvention;
			} else {
				hasThis = explicitThis = false;
				mcc = MethodCallingConvention.Default;
			}

			if (hasThis)
				ps.CallingConvention |= 0x20;
			if (explicitThis)
				ps.CallingConvention |= 0x40;

			if ((mcc & MethodCallingConvention.VarArg) != 0)
				ps.CallingConvention |= 0x5;

			int paramCount = parameters != null ? parameters.Count : 0;

			ps.ParamCount = paramCount;
			ps.Parameters = GetParametersSig (parameters);
			ps.CustomMods = GetCustomMods (prop.PropertyType);
			ps.Type = GetSigType (prop.PropertyType);

			return ps;
		}

		public TypeSpec GetTypeSpecSig (TypeReference type)
		{
			TypeSpec ts = new TypeSpec (GetSigType (type));
			return ts;
		}

		public MethodSpec GetMethodSpecSig (GenericInstanceMethod gim)
		{
			GenericInstSignature gis = new GenericInstSignature ();
			gis.Arity = gim.GenericArguments.Count;
			gis.Types = new GenericArg [gis.Arity];
			for (int i = 0; i < gis.Arity; i++)
				gis.Types [i] = GetGenericArgSig (gim.GenericArguments [i]);

			return new MethodSpec (gis);
		}

		static string GetObjectTypeName (object o)
		{
			Type t = o.GetType ();
			return string.Concat (t.Namespace, ".", t.Name);
		}

		static CustomAttrib.Elem CreateElem (TypeReference type, object value)
		{
			CustomAttrib.Elem elem = new CustomAttrib.Elem ();
			elem.Value = value;
			elem.ElemType = type;
			elem.FieldOrPropType = GetCorrespondingType (type.FullName);

			if (elem.FieldOrPropType == ElementType.Class)
				throw new NotImplementedException ("Writing enums");

			switch (elem.FieldOrPropType) {
			case ElementType.Boolean :
			case ElementType.Char :
			case ElementType.R4 :
			case ElementType.R8 :
			case ElementType.I1 :
			case ElementType.I2 :
			case ElementType.I4 :
			case ElementType.I8 :
			case ElementType.U1 :
			case ElementType.U2 :
			case ElementType.U4 :
			case ElementType.U8 :
				elem.Simple = true;
				break;
			case ElementType.String:
				elem.String = true;
				break;
			case ElementType.Type:
				elem.Type = true;
				break;
			case ElementType.Object:
				elem.BoxedValueType = true;
				if (value == null)
					elem.FieldOrPropType = ElementType.String;
				else
					elem.FieldOrPropType = GetCorrespondingType (
						GetObjectTypeName (value));
				break;
			}

			return elem;
		}

		static CustomAttrib.FixedArg CreateFixedArg (TypeReference type, object value)
		{
			CustomAttrib.FixedArg fa = new CustomAttrib.FixedArg ();
			if (value is object []) {
				fa.SzArray = true;
				object [] values = value as object [];
				TypeReference obj = ((ArrayType) type).ElementType;
				fa.NumElem = (uint) values.Length;
				fa.Elems = new CustomAttrib.Elem [values.Length];
				for (int i = 0; i < values.Length; i++)
					fa.Elems [i] = CreateElem (obj, values [i]);
			} else {
				fa.Elems = new CustomAttrib.Elem [1];
				fa.Elems [0] = CreateElem (type, value);
			}

			return fa;
		}

		static CustomAttrib.NamedArg CreateNamedArg (TypeReference type, string name,
			object value, bool field)
		{
			CustomAttrib.NamedArg na = new CustomAttrib.NamedArg ();
			na.Field = field;
			na.Property = !field;

			na.FieldOrPropName = name;
			na.FieldOrPropType = GetCorrespondingType (type.FullName);
			na.FixedArg = CreateFixedArg (type, value);

			return na;
		}

		public CustomAttrib GetCustomAttributeSig (CustomAttribute ca)
		{
			CustomAttrib cas = new CustomAttrib (ca.Constructor);
			cas.Prolog = CustomAttrib.StdProlog;

			cas.FixedArgs = new CustomAttrib.FixedArg [ca.Constructor.Parameters.Count];

			for (int i = 0; i < cas.FixedArgs.Length; i++)
				cas.FixedArgs [i] = CreateFixedArg (
					ca.Constructor.Parameters [i].ParameterType, ca.ConstructorParameters [i]);

			int nn = ca.Fields.Count + ca.Properties.Count;
			cas.NumNamed = (ushort) nn;
			cas.NamedArgs = new CustomAttrib.NamedArg [nn];

			if (cas.NamedArgs.Length > 0) {
				int curs = 0;
				foreach (DictionaryEntry entry in ca.Fields) {
					string field = (string) entry.Key;
					cas.NamedArgs [curs++] = CreateNamedArg (
						ca.GetFieldType (field), field, entry.Value, true);
				}

				foreach (DictionaryEntry entry in ca.Properties) {
					string property = (string) entry.Key;
					cas.NamedArgs [curs++] = CreateNamedArg (
						ca.GetPropertyType (property), property, entry.Value, false);
				}
			}

			return cas;
		}

		static MarshalSig GetMarshalSig (MarshalSpec mSpec)
		{
			MarshalSig ms = new MarshalSig (mSpec.NativeIntrinsic);

			if (mSpec is ArrayMarshalSpec) {
				ArrayMarshalSpec amd = mSpec as ArrayMarshalSpec;
				MarshalSig.Array ar = new MarshalSig.Array ();
				ar.ArrayElemType = amd.ElemType;
				ar.NumElem = amd.NumElem;
				ar.ParamNum = amd.ParamNum;
				ar.ElemMult = amd.ElemMult;
				ms.Spec = ar;
			} else if (mSpec is CustomMarshalerSpec) {
				CustomMarshalerSpec cmd = mSpec as CustomMarshalerSpec;
				MarshalSig.CustomMarshaler cm = new MarshalSig.CustomMarshaler ();
				cm.Guid = cmd.Guid.ToString ();
				cm.UnmanagedType = cmd.UnmanagedType;
				cm.ManagedType = cmd.ManagedType;
				cm.Cookie = cmd.Cookie;
				ms.Spec = cm;
			} else if (mSpec is FixedArraySpec) {
				FixedArraySpec fad = mSpec as FixedArraySpec;
				MarshalSig.FixedArray fa = new MarshalSig.FixedArray ();
				fa.ArrayElemType  = fad.ElemType;
				fa.NumElem = fad.NumElem;
				ms.Spec = fa;
			} else if (mSpec is FixedSysStringSpec) {
				MarshalSig.FixedSysString fss = new MarshalSig.FixedSysString ();
				fss.Size = (mSpec as FixedSysStringSpec).Size;
				ms.Spec = fss;
			} else if (mSpec is SafeArraySpec) {
				MarshalSig.SafeArray sa = new MarshalSig.SafeArray ();
				sa.ArrayElemType = (mSpec as SafeArraySpec).ElemType;
				ms.Spec = sa;
			}

			return ms;
		}

		public void WriteSymbols (ModuleDefinition module)
		{
			if (!m_saveSymbols)
				return;

			if (m_asmOutput == null)
				m_asmOutput = module.Assembly.Name.Name + "." + (module.Assembly.Kind == AssemblyKind.Dll ? "dll" : "exe");

			if (m_symbolWriter == null)
				m_symbolWriter = SymbolStoreHelper.GetWriter (module, m_asmOutput);

			foreach (TypeDefinition type in module.Types) {
				foreach (MethodDefinition method in type.Methods)
					WriteSymbols (method);
				foreach (MethodDefinition ctor in type.Constructors)
					WriteSymbols (ctor);
			}

			m_symbolWriter.Dispose ();
		}

		void WriteSymbols (MethodDefinition meth)
		{
			if (!meth.HasBody)
				return;

			m_symbolWriter.Write (meth.Body);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/Resource.cs
================================================
//
// Resource.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	public abstract class Resource : IReflectionStructureVisitable {

		string m_name;
		ManifestResourceAttributes m_flags;

		public string Name {
			get { return m_name; }
			set { m_name = value; }
		}

		public ManifestResourceAttributes Flags {
			get { return m_flags; }
			set { m_flags = value; }
		}

		internal Resource (string name, ManifestResourceAttributes flags)
		{
			m_name = name;
			m_flags = flags;
		}

		public abstract void Accept (IReflectionStructureVisitor visitor);
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/ResourceCollection.cs
================================================
//
// ResourceCollection.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Wed Sep 27 12:46:54 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;
	using System.Collections;

	using Mono.Cecil.Cil;

	public sealed class ResourceCollection : CollectionBase, IReflectionStructureVisitable {

		ModuleDefinition m_container;

		public Resource this [int index] {
			get { return List [index] as Resource; }
			set { List [index] = value; }
		}

		public ModuleDefinition Container {
			get { return m_container; }
		}

		public ResourceCollection (ModuleDefinition container)
		{
			m_container = container;
		}

		public void Add (Resource value)
		{
			List.Add (value);
		}

		public bool Contains (Resource value)
		{
			return List.Contains (value);
		}

		public int IndexOf (Resource value)
		{
			return List.IndexOf (value);
		}

		public void Insert (int index, Resource value)
		{
			List.Insert (index, value);
		}

		public void Remove (Resource value)
		{
			List.Remove (value);
		}

		protected override void OnValidate (object o)
		{
			if (! (o is Resource))
				throw new ArgumentException ("Must be of type " + typeof (Resource).FullName);
		}

		public void Accept (IReflectionStructureVisitor visitor)
		{
			visitor.VisitResourceCollection (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/SecurityAction.cs
================================================
//
// SecurityAction.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	public enum SecurityAction : short {
		Request = 1,
		Demand = 2,
		Assert = 3,
		Deny = 4,
		PermitOnly = 5,
		LinkDemand = 6,
		InheritDemand = 7,
		RequestMinimum = 8,
		RequestOptional = 9,
		RequestRefuse = 10,
		PreJitGrant = 11,
		PreJitDeny = 12,
		NonCasDemand = 13,
		NonCasLinkDemand = 14,
		NonCasInheritance = 15
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/SecurityDeclaration.cs
================================================
//
// SecurityDeclaration.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;
	using System.Security;

	public sealed class SecurityDeclaration : IRequireResolving, IReflectionVisitable {

		SecurityAction m_action;

#if !CF_1_0 && !CF_2_0
		PermissionSet m_permSet;
#endif

		bool m_resolved;
		byte [] m_blob;

		public SecurityAction Action {
			get { return m_action; }
			set { m_action = value; }
		}

#if !CF_1_0 && !CF_2_0
		public PermissionSet PermissionSet {
			get { return m_permSet; }
			set { m_permSet = value; }
		}
#endif

		public bool Resolved {
			get { return m_resolved; }
			set { m_resolved = value; }
		}

		public byte [] Blob {
			get { return m_blob; }
			set { m_blob = value; }
		}

		public SecurityDeclaration (SecurityAction action)
		{
			m_action = action;
			m_resolved = true;
		}

		public SecurityDeclaration Clone ()
		{
			return Clone (this);
		}

		internal static SecurityDeclaration Clone (SecurityDeclaration sec)
		{
			SecurityDeclaration sd = new SecurityDeclaration (sec.Action);
			if (!sec.Resolved) {
				sd.Resolved = false;
				sd.Blob = sec.Blob;
				return sd;
			}

#if !CF_1_0 && !CF_2_0
            sd.PermissionSet = sec.PermissionSet.Copy ();
#endif
			return sd;
		}

		public bool Resolve ()
		{
			throw new NotImplementedException ();
		}

		public void Accept (IReflectionVisitor visitor)
		{
			visitor.VisitSecurityDeclaration (this);
		}
	}
}




================================================
File: DeConfuser/MonoCecil/Mono.Cecil/SecurityDeclarationCollection.cs
================================================
//
// SecurityDeclarationCollection.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;
	using System.Collections;

	public sealed class SecurityDeclarationCollection : IReflectionVisitable {

		IDictionary m_items;
		IHasSecurity m_container;

		public SecurityDeclaration this [int index] {
			get { return m_items [index] as SecurityDeclaration; }
			set { m_items [index] = value; }
		}

		public SecurityDeclaration this [SecurityAction action] {
			get { return m_items [action] as SecurityDeclaration; }
			set { m_items [action] = value; }
		}

		public IHasSecurity Container {
			get { return m_container; }
		}

		public int Count {
			get { return m_items.Count; }
		}

		public bool IsSynchronized {
			get { return false; }
		}

		public object SyncRoot {
			get { return this; }
		}

		public SecurityDeclarationCollection (IHasSecurity container)
		{
			m_container = container;
			m_items = new Hashtable ();
		}

		public void Add (SecurityDeclaration value)
		{
			if (value == null)
				throw new ArgumentNullException ("value");

			// Each action can only be added once so...
			SecurityDeclaration current = (SecurityDeclaration) m_items[value.Action];
			if (current != null) {
				// ... further additions are transformed into unions
#if !CF_1_0 && !CF_2_0
                current.PermissionSet = current.PermissionSet.Union (value.PermissionSet);
#endif
			} else {
				m_items.Add (value.Action, value);
				SetHasSecurity (true);
			}
		}

		public void Clear ()
		{
			m_items.Clear ();
			SetHasSecurity (false);
		}

		public bool Contains (SecurityAction action)
		{
			return (m_items [action] != null);
		}

		public bool Contains (SecurityDeclaration value)
		{
			if (value == null)
				return (m_items.Count == 0);

			SecurityDeclaration item = (SecurityDeclaration) m_items[value.Action];
			if (item == null)
				return false;

#if !CF_1_0 && !CF_2_0
			return value.PermissionSet.IsSubsetOf (item.PermissionSet);
#else
            // XXX For CF, this concept does not exist--so always be true
            return true;
#endif
		}

		public void Remove (SecurityAction action)
		{
			m_items.Remove (action);
			SetHasSecurity (this.Count > 0);
		}

		public void CopyTo (Array ary, int index)
		{
			m_items.Values.CopyTo (ary, index);
		}

		public IEnumerator GetEnumerator ()
		{
			return m_items.Values.GetEnumerator ();
		}

		public void Accept (IReflectionVisitor visitor)
		{
			visitor.VisitSecurityDeclarationCollection (this);
		}

		private void SetHasSecurity (bool value)
		{
			TypeDefinition td = (m_container as TypeDefinition);
			if (td != null) {
				if (value)
					td.Attributes |= TypeAttributes.HasSecurity;
				else
					td.Attributes &= ~TypeAttributes.HasSecurity;
				return;
			}
			MethodDefinition md = (m_container as MethodDefinition);
			if (md != null) {
				if (value)
					md.Attributes |= MethodAttributes.HasSecurity;
				else
					md.Attributes &= ~MethodAttributes.HasSecurity;
			}
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/SecurityDeclarationReader.cs
================================================
//
// SecurityDeclarationReader.cs
//
// Author:
//	Sebastien Pouliot <sebastien@ximian.com>
//
// Copyright (C) 2005 Novell, Inc (http://www.novell.com)
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;
	using System.IO;
	using System.Reflection;
	using System.Security;
	using SSP = System.Security.Permissions;
	using System.Text;

	using Mono.Cecil.Metadata;
	using Mono.Cecil.Signatures;
	using Mono.Xml;

	internal class SecurityDeclarationReader {

		private SecurityParser m_parser;
		private SignatureReader sr;

		public SecurityDeclarationReader (MetadataRoot root, ReflectionReader reader)
		{
			sr = new SignatureReader (root, reader);
		}

		public SecurityParser Parser {
			get {
				if (m_parser == null)
					m_parser = new SecurityParser ();
				return m_parser;
			}
		}

		public SecurityDeclaration FromByteArray (SecurityAction action, byte [] declaration)
		{
			return FromByteArray (action, declaration, false);
		}

		public SecurityDeclaration FromByteArray (SecurityAction action, byte [] declaration, bool resolve)
		{
			SecurityDeclaration dec = new SecurityDeclaration (action);
#if !CF_1_0 && !CF_2_0
			dec.PermissionSet = new PermissionSet (SSP.PermissionState.None);

			if (declaration == null || declaration.Length == 0)
				return dec;

			if (declaration[0] == 0x2e) {
				// new binary format introduced in 2.0
				int pos = 1;
				int start;
				int numattr = Utilities.ReadCompressedInteger (declaration, pos, out start);
				if (numattr == 0)
					return dec;

				BinaryReader br = new BinaryReader (new MemoryStream (declaration));
				for (int i = 0; i < numattr; i++) {
					pos = start;
					SSP.SecurityAttribute sa = CreateSecurityAttribute (action, br, declaration, pos, out start, resolve);
					if (sa == null) {
						dec.Resolved = false;
						dec.Blob = declaration;
						return dec;
					}

					IPermission p = sa.CreatePermission ();
					dec.PermissionSet.AddPermission (p);
				}
			} else {
				Parser.LoadXml (Encoding.Unicode.GetString (declaration));
				try {
					dec.PermissionSet.FromXml (Parser.ToXml ());
					dec.PermissionSet.ToXml ();
				} catch {
					dec.Resolved = false;
					dec.Blob = declaration;
				}
			}
#endif
			return dec;
		}

#if !CF_1_0 && !CF_2_0
		private SSP.SecurityAttribute CreateSecurityAttribute (SecurityAction action, BinaryReader br, byte [] permset, int pos, out int start, bool resolve)
		{
			string cname = SignatureReader.ReadUTF8String (permset, pos, out start);
			Type secattr = null;

			// note: the SecurityAction parameter isn't important to generate the XML
			SSP.SecurityAttribute sa = null;
			try {
				secattr = Type.GetType (cname, false);
				if (secattr == null)
					return null;

				sa = Activator.CreateInstance (secattr, new object [] {(SSP.SecurityAction) action}) as SSP.SecurityAttribute;
			} catch {}

			if (sa == null)
				return null;

			// encoded length of all parameters (we don't need the value - except the updated pos)
			Utilities.ReadCompressedInteger (permset, start, out pos);
			int numparams = Utilities.ReadCompressedInteger (permset, pos, out start);
			if (numparams == 0)
				return sa;

			br.BaseStream.Position = start;
			for (int j = 0; j < numparams; j++) {
				bool read = false;
				CustomAttrib.NamedArg na = sr.ReadNamedArg (permset, br, ref read, resolve);
				if (!read)
					return null;

				if (na.Field) {
					FieldInfo fi = secattr.GetField (na.FieldOrPropName);
					fi.SetValue (sa, na.FixedArg.Elems[0].Value);
				} else if (na.Property) {
					PropertyInfo pi = secattr.GetProperty (na.FieldOrPropName);
					pi.SetValue (sa, na.FixedArg.Elems[0].Value, null);
				}
			}

			return sa;
		}
#endif
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/SentinelType.cs
================================================
//
// SentinelType.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2007 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	public sealed class SentinelType : TypeSpecification {

		public SentinelType (TypeReference type) : base (type)
		{
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/StructureReader.cs
================================================
//
// StructureReader.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;
	using System.IO;

	using Mono.Cecil.Binary;
	using Mono.Cecil.Metadata;

	internal sealed class StructureReader : BaseStructureVisitor {

		ImageReader m_ir;
		Image m_img;
		bool m_manifestOnly;
		AssemblyDefinition m_asmDef;
		ModuleDefinition m_module;
		MetadataStreamCollection m_streams;
		TablesHeap m_tHeap;
		MetadataTableReader m_tableReader;

		public bool ManifestOnly {
			get { return m_manifestOnly; }
		}

		public ImageReader ImageReader {
			get { return m_ir; }
		}

		public Image Image {
			get { return m_img; }
		}

		public StructureReader (ImageReader ir)
		{
			m_ir = ir;
			m_img = ir.Image;
			m_streams = m_img.MetadataRoot.Streams;
			m_tHeap = m_streams.TablesHeap;
			m_tableReader = ir.MetadataReader.TableReader;
		}

		public StructureReader (ImageReader ir, bool manifestOnly) : this (ir)
		{
			m_manifestOnly = manifestOnly;
		}

		byte [] ReadBlob (uint pointer)
		{
			if (pointer == 0)
				return new byte [0];

			return m_streams.BlobHeap.Read (pointer);
		}

		string ReadString (uint pointer)
		{
			return m_streams.StringsHeap [pointer];
		}

		public override void VisitAssemblyDefinition (AssemblyDefinition asm)
		{
			if (!m_tHeap.HasTable (AssemblyTable.RId))
				throw new ReflectionException ("No assembly manifest");

			asm.MetadataToken = new MetadataToken (TokenType.Assembly, 1);
			m_asmDef = asm;

			switch (m_img.MetadataRoot.Header.Version) {
			case "v1.0.3705" :
				asm.Runtime = TargetRuntime.NET_1_0;
				break;
			case "v1.1.4322" :
				asm.Runtime = TargetRuntime.NET_1_1;
				break;
			default :
				asm.Runtime = TargetRuntime.NET_2_0;
				break;
			}

			if ((m_img.PEFileHeader.Characteristics & ImageCharacteristics.Dll) != 0)
				asm.Kind = AssemblyKind.Dll;
			else if (m_img.PEOptionalHeader.NTSpecificFields.SubSystem == SubSystem.WindowsGui ||
				m_img.PEOptionalHeader.NTSpecificFields.SubSystem == SubSystem.WindowsCeGui)
				asm.Kind = AssemblyKind.Windows;
			else
				asm.Kind = AssemblyKind.Console;
		}

		public override void VisitAssemblyNameDefinition (AssemblyNameDefinition name)
		{
			AssemblyTable atable = m_tableReader.GetAssemblyTable ();
			AssemblyRow arow = atable [0];
			name.Name = ReadString (arow.Name);
			name.Flags = arow.Flags;
			name.PublicKey = ReadBlob (arow.PublicKey);

			name.Culture = ReadString (arow.Culture);
			name.Version = new Version (
				arow.MajorVersion, arow.MinorVersion,
				arow.BuildNumber, arow.RevisionNumber);
			name.HashAlgorithm = arow.HashAlgId;
			name.MetadataToken = new MetadataToken (TokenType.Assembly, 1);
		}

		public override void VisitAssemblyNameReferenceCollection (AssemblyNameReferenceCollection names)
		{
			if (!m_tHeap.HasTable (AssemblyRefTable.RId))
				return;

			AssemblyRefTable arTable = m_tableReader.GetAssemblyRefTable ();
			for (int i = 0; i < arTable.Rows.Count; i++) {
				AssemblyRefRow arRow = arTable [i];
				AssemblyNameReference aname = new AssemblyNameReference (
					ReadString (arRow.Name),
					ReadString (arRow.Culture),
					new Version (arRow.MajorVersion, arRow.MinorVersion,
								 arRow.BuildNumber, arRow.RevisionNumber));
				aname.PublicKeyToken = ReadBlob (arRow.PublicKeyOrToken);
				aname.Hash = ReadBlob (arRow.HashValue);
				aname.MetadataToken = new MetadataToken (TokenType.AssemblyRef, (uint) i + 1);
				names.Add (aname);
			}
		}

		public override void VisitResourceCollection (ResourceCollection resources)
		{
			if (!m_tHeap.HasTable (ManifestResourceTable.RId))
				return;

			ManifestResourceTable mrTable = m_tableReader.GetManifestResourceTable ();
			FileTable fTable = m_tableReader.GetFileTable ();

			for (int i = 0; i < mrTable.Rows.Count; i++) {
				ManifestResourceRow mrRow = mrTable [i];
				if (mrRow.Implementation.RID == 0) {
					EmbeddedResource eres = new EmbeddedResource (
						ReadString (mrRow.Name), mrRow.Flags);

					BinaryReader br = m_ir.MetadataReader.GetDataReader (
						m_img.CLIHeader.Resources.VirtualAddress);
					br.BaseStream.Position += mrRow.Offset;

					eres.Data = br.ReadBytes (br.ReadInt32 ());

					resources.Add (eres);
					continue;
				}

				switch (mrRow.Implementation.TokenType) {
				case TokenType.File :
					FileRow fRow = fTable [(int) mrRow.Implementation.RID - 1];
					LinkedResource lres = new LinkedResource (
						ReadString (mrRow.Name), mrRow.Flags,
						ReadString (fRow.Name));
					lres.Hash = ReadBlob (fRow.HashValue);
					resources.Add (lres);
					break;
				case TokenType.AssemblyRef :
					AssemblyNameReference asm =
						m_module.AssemblyReferences [(int) mrRow.Implementation.RID - 1];
					AssemblyLinkedResource alr = new AssemblyLinkedResource (
						ReadString (mrRow.Name),
						mrRow.Flags, asm);
					resources.Add (alr);
					break;
				}
			}
		}

		public override void VisitModuleDefinitionCollection (ModuleDefinitionCollection modules)
		{
			ModuleTable mt = m_tableReader.GetModuleTable ();
			if (mt == null || mt.Rows.Count != 1)
				throw new ReflectionException ("Can not read main module");

			ModuleRow mr = mt [0];
			string name = ReadString (mr.Name);
			ModuleDefinition main = new ModuleDefinition (name, m_asmDef, this, true);
			main.Mvid = m_streams.GuidHeap [mr.Mvid];
			main.MetadataToken = new MetadataToken (TokenType.Module, 1);
			modules.Add (main);
			m_module = main;
			m_module.Accept (this);

			FileTable ftable = m_tableReader.GetFileTable ();
			if (ftable == null || ftable.Rows.Count == 0)
				return;

			foreach (FileRow frow in ftable.Rows) {
				if (frow.Flags != FileAttributes.ContainsMetaData)
					continue;

				name = ReadString (frow.Name);
				FileInfo location = new FileInfo (
					m_img.FileInformation != null ? Path.Combine (m_img.FileInformation.DirectoryName, name) : name);
				if (!File.Exists (location.FullName))
					throw new FileNotFoundException ("Module not found : " + name);

				try {
					ImageReader module = ImageReader.Read (location.FullName);
					mt = module.Image.MetadataRoot.Streams.TablesHeap [ModuleTable.RId] as ModuleTable;
					if (mt == null || mt.Rows.Count != 1)
						throw new ReflectionException ("Can not read module : " + name);

					mr = mt [0];
					ModuleDefinition modext = new ModuleDefinition (name, m_asmDef,
						new StructureReader (module, m_manifestOnly), false);
					modext.Mvid = module.Image.MetadataRoot.Streams.GuidHeap [mr.Mvid];

					modules.Add (modext);
					modext.Accept (this);
				} catch (ReflectionException) {
					throw;
				} catch (Exception e) {
					throw new ReflectionException ("Can not read module : " + name, e);
				}
			}
		}

		public override void VisitModuleReferenceCollection (ModuleReferenceCollection modules)
		{
			if (!m_tHeap.HasTable (ModuleRefTable.RId))
				return;

			ModuleRefTable mrTable = m_tableReader.GetModuleRefTable ();
			for (int i = 0; i < mrTable.Rows.Count; i++) {
				ModuleRefRow mrRow = mrTable [i];
				ModuleReference mod = new ModuleReference (ReadString (mrRow.Name));
				mod.MetadataToken = new MetadataToken (TokenType.ModuleRef, (uint) i + 1);
				modules.Add (mod);
			}
		}

		public override void TerminateAssemblyDefinition (AssemblyDefinition asm)
		{
			if (m_manifestOnly)
				return;

			foreach (ModuleDefinition mod in asm.Modules)
				mod.Controller.Reader.VisitModuleDefinition (mod);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/StructureWriter.cs
================================================
//
// StructureWriter.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;
	using System.IO;

	using Mono.Cecil.Binary;
	using Mono.Cecil.Metadata;

	internal sealed class StructureWriter : BaseStructureVisitor {

		MetadataWriter m_mdWriter;
		MetadataTableWriter m_tableWriter;
		MetadataRowWriter m_rowWriter;

		AssemblyDefinition m_asm;
		BinaryWriter m_binaryWriter;

		public AssemblyDefinition Assembly {
			get { return m_asm; }
		}

		static void ResetImage (ModuleDefinition mod)
		{
			Image ni = Image.CreateImage ();
			ni.Accept (new CopyImageVisitor (mod.Image));
			mod.Image = ni;
		}

		public StructureWriter (AssemblyDefinition asm, BinaryWriter writer)
		{
			m_asm = asm;
			m_binaryWriter = writer;
		}

		public BinaryWriter GetWriter ()
		{
			return m_binaryWriter;
		}

		public override void VisitAssemblyDefinition (AssemblyDefinition asm)
		{
			if (asm.Kind != AssemblyKind.Dll && asm.EntryPoint == null)
				throw new ReflectionException ("Assembly does not have an entry point defined");

			if ((asm.MainModule.Image.CLIHeader.Flags & RuntimeImage.ILOnly) == 0)
				throw new NotSupportedException ("Can not write a mixed mode assembly");

			foreach (ModuleDefinition module in asm.Modules)
				if (module.Image.CLIHeader.Metadata.VirtualAddress != RVA.Zero)
					ResetImage (module);

			ReflectionWriter rw = asm.MainModule.Controller.Writer;
			rw.StructureWriter = this;

			m_mdWriter = rw.MetadataWriter;
			m_tableWriter = rw.MetadataTableWriter;
			m_rowWriter = rw.MetadataRowWriter;

			if (!rw.SaveSymbols)
				return;

			FileStream fs = m_binaryWriter.BaseStream as FileStream;
			if (fs != null)
				rw.OutputFile = fs.Name;
		}

		public override void VisitAssemblyNameDefinition (AssemblyNameDefinition name)
		{
			AssemblyTable asmTable = m_tableWriter.GetAssemblyTable ();

			if (name.PublicKey != null && name.PublicKey.Length > 0)
				name.Flags |= AssemblyFlags.PublicKey;

			AssemblyRow asmRow = m_rowWriter.CreateAssemblyRow (
				name.HashAlgorithm,
				(ushort) name.Version.Major,
				(ushort) name.Version.Minor,
				(ushort) name.Version.Build,
				(ushort) name.Version.Revision,
				name.Flags,
				m_mdWriter.AddBlob (name.PublicKey),
				m_mdWriter.AddString (name.Name),
				m_mdWriter.AddString (name.Culture));

			asmTable.Rows.Add (asmRow);
		}

		public override void VisitAssemblyNameReferenceCollection (AssemblyNameReferenceCollection references)
		{
			foreach (AssemblyNameReference name in references)
				VisitAssemblyNameReference (name);
		}

		public override void VisitAssemblyNameReference (AssemblyNameReference name)
		{
			byte [] pkortoken;
			if (name.PublicKey != null && name.PublicKey.Length > 0)
				pkortoken = name.PublicKey;
			else if (name.PublicKeyToken != null && name.PublicKeyToken.Length > 0)
				pkortoken = name.PublicKeyToken;
			else
				pkortoken = new byte [0];

			AssemblyRefTable arTable = m_tableWriter.GetAssemblyRefTable ();
			AssemblyRefRow arRow = m_rowWriter.CreateAssemblyRefRow (
				(ushort) name.Version.Major,
				(ushort) name.Version.Minor,
				(ushort) name.Version.Build,
				(ushort) name.Version.Revision,
				name.Flags,
				m_mdWriter.AddBlob (pkortoken),
				m_mdWriter.AddString (name.Name),
				m_mdWriter.AddString (name.Culture),
				m_mdWriter.AddBlob (name.Hash));

			arTable.Rows.Add (arRow);
		}

		public override void VisitResourceCollection (ResourceCollection resources)
		{
			VisitCollection (resources);
		}

		public override void VisitEmbeddedResource (EmbeddedResource res)
		{
			AddManifestResource (
				m_mdWriter.AddResource (res.Data),
				res.Name, res.Flags,
				new MetadataToken (TokenType.ManifestResource, 0));
		}

		public override void VisitLinkedResource (LinkedResource res)
		{
			FileTable fTable = m_tableWriter.GetFileTable ();
			FileRow fRow = m_rowWriter.CreateFileRow (
				Mono.Cecil.FileAttributes.ContainsNoMetaData,
				m_mdWriter.AddString (res.File),
				m_mdWriter.AddBlob (res.Hash));

			fTable.Rows.Add (fRow);

			AddManifestResource (
				0, res.Name, res.Flags,
				new MetadataToken (TokenType.File, (uint) fTable.Rows.IndexOf (fRow) + 1));
		}

		public override void VisitAssemblyLinkedResource (AssemblyLinkedResource res)
		{
			MetadataToken impl = new MetadataToken (TokenType.AssemblyRef,
				(uint) m_asm.MainModule.AssemblyReferences.IndexOf (res.Assembly) + 1);

			AddManifestResource (0, res.Name, res.Flags, impl);
		}

		void AddManifestResource (uint offset, string name, ManifestResourceAttributes flags, MetadataToken impl)
		{
			ManifestResourceTable mrTable = m_tableWriter.GetManifestResourceTable ();
			ManifestResourceRow mrRow = m_rowWriter.CreateManifestResourceRow (
				offset,
				flags,
				m_mdWriter.AddString (name),
				impl);

			mrTable.Rows.Add (mrRow);
		}

		public override void VisitModuleDefinitionCollection (ModuleDefinitionCollection modules)
		{
			VisitCollection (modules);
		}

		public override void VisitModuleDefinition (ModuleDefinition module)
		{
			if (module.Main) {
				ModuleTable modTable = m_tableWriter.GetModuleTable ();
				ModuleRow modRow = m_rowWriter.CreateModuleRow (
					0,
					m_mdWriter.AddString (module.Name),
					m_mdWriter.AddGuid (module.Mvid),
					0,
					0);

				modTable.Rows.Add (modRow);
			} else {
				// multiple module assemblies
				throw new NotImplementedException ();
			}
		}

		public override void VisitModuleReferenceCollection (ModuleReferenceCollection modules)
		{
			VisitCollection (modules);
		}

		public override void VisitModuleReference (ModuleReference module)
		{
			ModuleRefTable mrTable = m_tableWriter.GetModuleRefTable ();
			ModuleRefRow mrRow = m_rowWriter.CreateModuleRefRow (
				m_mdWriter.AddString (module.Name));

			mrTable.Rows.Add (mrRow);
		}

		public override void TerminateAssemblyDefinition (AssemblyDefinition asm)
		{
			foreach (ModuleDefinition mod in asm.Modules) {
				ReflectionWriter writer = mod.Controller.Writer;
				writer.VisitModuleDefinition (mod);
				writer.VisitTypeReferenceCollection (mod.TypeReferences);
				writer.VisitTypeDefinitionCollection (mod.Types);
				writer.VisitMemberReferenceCollection (mod.MemberReferences);
				writer.CompleteTypeDefinitions ();

				writer.TerminateModuleDefinition (mod);
			}
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/TableComparers.cs
================================================
//
// TableComparers.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;
	using System.Collections;

	using Mono.Cecil.Metadata;

	class TableComparers {

		public sealed class TypeDef : IComparer {

			public static readonly TypeDef Instance = new TypeDef ();

			public int Compare (object x, object y)
			{
				TypeDefinition a = x as TypeDefinition;
				TypeDefinition b = y as TypeDefinition;

				if (a == null || b == null)
					throw new ReflectionException ("TypeDefComparer can only compare TypeDefinition");

				if (a.Name == Constants.ModuleType && b.Name == Constants.ModuleType)
					return 0;
				else if (a.Name == Constants.ModuleType)
					return -1;
				else if (b.Name == Constants.ModuleType)
					return 1;

				return Comparer.Default.Compare (a.FullName, b.FullName);
			}
		}

		public class TypeRef : IComparer {

			public static readonly TypeRef Instance = new TypeRef ();

			public int Compare (object x, object y)
			{
				TypeReference a = x as TypeReference;
				TypeReference b = y as TypeReference;

				if (a == null || b == null)
					throw new ReflectionException ("TypeRefComparer can only compare TypeReference");

				if (b.DeclaringType == a)
					return -1;
				else if (a.DeclaringType == b)
					return 1;

				return Comparer.Default.Compare (a.FullName, b.FullName);
			}
		}

		public class NestedClass : IComparer {

			public static readonly NestedClass Instance = new NestedClass ();

			public int Compare (object x, object y)
			{
				NestedClassRow a = x as NestedClassRow;
				NestedClassRow b = y as NestedClassRow;

				return Comparer.Default.Compare (a.NestedClass, b.NestedClass);
			}
		}

		public class Constant : IComparer {

			public static readonly Constant Instance = new Constant ();

			public int Compare (object x, object y)
			{
				ConstantRow a = x as ConstantRow;
				ConstantRow b = y as ConstantRow;

				return Comparer.Default.Compare (
					Utilities.CompressMetadataToken (CodedIndex.HasConstant, a.Parent),
					Utilities.CompressMetadataToken (CodedIndex.HasConstant, b.Parent));
			}

		}

		public class InterfaceImpl : IComparer {

			public static readonly InterfaceImpl Instance = new InterfaceImpl ();

			public int Compare (object x, object y)
			{
				InterfaceImplRow a = x as InterfaceImplRow;
				InterfaceImplRow b = y as InterfaceImplRow;

				int klass = Comparer.Default.Compare (a.Class, b.Class);

				if (klass == 0)
					return Comparer.Default.Compare (
						Utilities.CompressMetadataToken (CodedIndex.TypeDefOrRef, a.Interface),
						Utilities.CompressMetadataToken (CodedIndex.TypeDefOrRef, b.Interface));

				return klass;
			}
		}

		public class MethodSem : IComparer {

			public static readonly MethodSem Instance = new MethodSem ();

			public int Compare (object x, object y)
			{
				MethodSemanticsRow a = x as MethodSemanticsRow;
				MethodSemanticsRow b = y as MethodSemanticsRow;

				return Comparer.Default.Compare (
					Utilities.CompressMetadataToken (CodedIndex.HasSemantics, a.Association),
					Utilities.CompressMetadataToken (CodedIndex.HasSemantics, b.Association));
			}
		}

		public class CustomAttribute : IComparer {

			public static readonly CustomAttribute Instance = new CustomAttribute ();

			public int Compare (object x, object y)
			{
				CustomAttributeRow a = x as CustomAttributeRow;
				CustomAttributeRow b = y as CustomAttributeRow;

				return Comparer.Default.Compare (
					Utilities.CompressMetadataToken (CodedIndex.HasCustomAttribute, a.Parent),
					Utilities.CompressMetadataToken (CodedIndex.HasCustomAttribute, b.Parent));
			}
		}

		public class SecurityDeclaration : IComparer {

			public static readonly SecurityDeclaration Instance = new SecurityDeclaration ();

			public int Compare (object x, object y)
			{
				DeclSecurityRow a = x as DeclSecurityRow;
				DeclSecurityRow b = y as DeclSecurityRow;

				return Comparer.Default.Compare (
					Utilities.CompressMetadataToken (CodedIndex.HasDeclSecurity, a.Parent),
					Utilities.CompressMetadataToken (CodedIndex.HasDeclSecurity, b.Parent));
			}
		}

		public class Override : IComparer {

			public static readonly Override Instance = new Override ();

			public int Compare (object x, object y)
			{
				MethodImplRow a = x as MethodImplRow;
				MethodImplRow b = y as MethodImplRow;

				return Comparer.Default.Compare (a.Class, b.Class);
			}
		}

		public class PInvoke : IComparer {

			public static readonly PInvoke Instance = new PInvoke ();

			public int Compare (object x, object y)
			{
				ImplMapRow a = x as ImplMapRow;
				ImplMapRow b = y as ImplMapRow;

				return Comparer.Default.Compare (a.MemberForwarded.RID, b.MemberForwarded.RID);
			}
		}

		public class FieldRVA : IComparer {

			public static readonly FieldRVA Instance = new FieldRVA ();

			public int Compare (object x, object y)
			{
				FieldRVARow a = x as FieldRVARow;
				FieldRVARow b = y as FieldRVARow;

				return Comparer.Default.Compare (a.Field, b.Field);
			}
		}

		public class FieldLayout : IComparer {

			public static readonly FieldLayout Instance = new FieldLayout ();

			public int Compare (object x, object y)
			{
				FieldLayoutRow a = x as FieldLayoutRow;
				FieldLayoutRow b = y as FieldLayoutRow;

				return Comparer.Default.Compare (a.Field, b.Field);
			}
		}

		public class FieldMarshal : IComparer {

			public static readonly FieldMarshal Instance = new FieldMarshal ();

			public int Compare (object x, object y)
			{
				FieldMarshalRow a = x as FieldMarshalRow;
				FieldMarshalRow b = y as FieldMarshalRow;

				return Comparer.Default.Compare (
					Utilities.CompressMetadataToken (CodedIndex.HasFieldMarshal, a.Parent),
					Utilities.CompressMetadataToken (CodedIndex.HasFieldMarshal, b.Parent));
			}
		}

		public class TypeLayout : IComparer {

			public static readonly TypeLayout Instance = new TypeLayout ();

			public int Compare (object x, object y)
			{
				ClassLayoutRow a = x as ClassLayoutRow;
				ClassLayoutRow b = y as ClassLayoutRow;

				return Comparer.Default.Compare (a.Parent, b.Parent);
			}
		}

		public class GenericParam : IComparer {

			public static readonly GenericParam Instance = new GenericParam ();

			public int Compare (object x, object y)
			{
				GenericParameter a = x as GenericParameter;
				GenericParameter b = y as GenericParameter;

				int token = Comparer.Default.Compare (
					Utilities.CompressMetadataToken (CodedIndex.TypeOrMethodDef, a.Owner.MetadataToken),
					Utilities.CompressMetadataToken (CodedIndex.TypeOrMethodDef, b.Owner.MetadataToken));

				if (token == 0)
					return Comparer.Default.Compare (a.Position, b.Position);

				return token;
			}
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/TargetRuntime.cs
================================================
//
// TargetRuntime.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	public enum TargetRuntime {
		NET_1_0,
		NET_1_1,
		NET_2_0
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/TypeAttributes.cs
================================================
//
// TypeAttributes.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;

	[Flags]
	public enum TypeAttributes : uint {
		// Visibility attributes
		VisibilityMask		= 0x00000007,	// Use this mask to retrieve visibility information
		NotPublic			= 0x00000000,	// Class has no public scope
		Public				= 0x00000001,	// Class has public scope
		NestedPublic		= 0x00000002,	// Class is nested with public visibility
		NestedPrivate		= 0x00000003,	// Class is nested with private visibility
		NestedFamily		= 0x00000004,	// Class is nested with family visibility
		NestedAssembly		= 0x00000005,	// Class is nested with assembly visibility
		NestedFamANDAssem	= 0x00000006,	// Class is nested with family and assembly visibility
		NestedFamORAssem	= 0x00000007,	// Class is nested with family or assembly visibility

		// Class layout attributes
		LayoutMask			= 0x00000018,	// Use this mask to retrieve class layout information
		AutoLayout			= 0x00000000,	// Class fields are auto-laid out
		SequentialLayout	= 0x00000008,	// Class fields are laid out sequentially
		ExplicitLayout		= 0x00000010,	// Layout is supplied explicitly

		// Class semantics attributes
		ClassSemanticMask	= 0x00000020,	// Use this mask to retrieve class semantics information
		Class				= 0x00000000,	// Type is a class
		Interface			= 0x00000020,	// Type is an interface

		// Special semantics in addition to class semantics
		Abstract			= 0x00000080,	// Class is abstract
		Sealed				= 0x00000100,	// Class cannot be extended
		SpecialName			= 0x00000400,	// Class name is special

		// Implementation attributes
		Import				= 0x00001000,	// Class/Interface is imported
		Serializable		= 0x00002000,	// Class is serializable

		// String formatting attributes
		StringFormatMask	= 0x00030000,	// Use this mask to retrieve string information for native interop
		AnsiClass			= 0x00000000,	// LPSTR is interpreted as ANSI
		UnicodeClass		= 0x00010000,	// LPSTR is interpreted as Unicode
		AutoClass			= 0x00020000,	// LPSTR is interpreted automatically

		// Class initialization attributes
		BeforeFieldInit		= 0x00100000,	// Initialize the class before first static field access

		// Additional flags
		RTSpecialName		= 0x00000800,	// CLI provides 'special' behavior, depending upon the name of the Type
		HasSecurity			= 0x00040000	 // Type has security associate with it
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/TypeDefinition.cs
================================================
//
// TypeDefinition.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;

	public sealed class TypeDefinition : TypeReference, IMemberDefinition, IHasSecurity {

		TypeAttributes m_attributes;
		TypeReference m_baseType;

		bool m_hasInfo;
		ushort m_packingSize;
		uint m_classSize;

		InterfaceCollection m_interfaces;
		NestedTypeCollection m_nestedTypes;
		MethodDefinitionCollection m_methods;
		ConstructorCollection m_ctors;
		FieldDefinitionCollection m_fields;
		EventDefinitionCollection m_events;
		PropertyDefinitionCollection m_properties;
		SecurityDeclarationCollection m_secDecls;

		public TypeAttributes Attributes {
			get { return m_attributes; }
			set { m_attributes = value; }
		}

		public TypeReference BaseType {
			get { return m_baseType; }
			set { m_baseType = value; }
		}

		public bool HasLayoutInfo {
			get { return m_hasInfo; }
		}

		public ushort PackingSize {
			get { return m_packingSize; }
			set {
				m_hasInfo = true;
				m_packingSize = value;
			}
		}

		public uint ClassSize {
			get { return m_classSize; }
			set {
				m_hasInfo = true;
				m_classSize = value;
			}
		}

		public InterfaceCollection Interfaces {
			get {
				if (m_interfaces == null)
					m_interfaces = new InterfaceCollection (this);

				return m_interfaces;
			}
		}

		public NestedTypeCollection NestedTypes {
			get {
				if (m_nestedTypes == null)
					m_nestedTypes = new NestedTypeCollection (this);

				return m_nestedTypes;
			}
		}

		public MethodDefinitionCollection Methods {
			get {
				if (m_methods == null)
					m_methods = new MethodDefinitionCollection (this);

				return m_methods;
			}
		}

		public ConstructorCollection Constructors {
			get {
				if (m_ctors == null)
					m_ctors = new ConstructorCollection (this);

				return m_ctors;
			}
		}

		public FieldDefinitionCollection Fields {
			get {
				if (m_fields == null)
					m_fields = new FieldDefinitionCollection (this);

				return m_fields;
			}
		}

		public EventDefinitionCollection Events {
			get {
				if (m_events == null)
					m_events = new EventDefinitionCollection (this);

				return m_events;
			}
		}

		public PropertyDefinitionCollection Properties {
			get {
				if (m_properties == null)
					m_properties = new PropertyDefinitionCollection (this);

				return m_properties;
			}
		}

		public SecurityDeclarationCollection SecurityDeclarations {
			get {
				if (m_secDecls == null)
					m_secDecls = new SecurityDeclarationCollection (this);

				return m_secDecls;
			}
		}

		public bool IsAbstract {
			get { return (m_attributes & TypeAttributes.Abstract) != 0; }
			set {
				if (value)
					m_attributes |= TypeAttributes.Abstract;
				else
					m_attributes &= ~TypeAttributes.Abstract;
			}
		}

		public bool IsBeforeFieldInit {
			get { return (m_attributes & TypeAttributes.BeforeFieldInit) != 0; }
			set {
				if (value)
					m_attributes |= TypeAttributes.BeforeFieldInit;
				else
					m_attributes &= ~TypeAttributes.BeforeFieldInit;
			}
		}

		public bool IsInterface {
			get { return (m_attributes & TypeAttributes.ClassSemanticMask) == TypeAttributes.Interface; }
			set {
				if (value)
					m_attributes |= (TypeAttributes.ClassSemanticMask & TypeAttributes.Interface);
				else
					m_attributes &= ~(TypeAttributes.ClassSemanticMask & TypeAttributes.Interface);
			}
		}

		public bool IsRuntimeSpecialName {
			get { return (m_attributes & TypeAttributes.RTSpecialName) != 0; }
			set {
				if (value)
					m_attributes |= TypeAttributes.RTSpecialName;
				else
					m_attributes &= ~TypeAttributes.RTSpecialName;
			}
		}

		public bool IsSealed {
			get { return (m_attributes & TypeAttributes.Sealed) != 0; }
			set {
				if (value)
					m_attributes |= TypeAttributes.Sealed;
				else
					m_attributes &= ~TypeAttributes.Sealed;
			}
		}

		public bool IsSpecialName {
			get { return (m_attributes & TypeAttributes.SpecialName) != 0; }
			set {
				if (value)
					m_attributes |= TypeAttributes.SpecialName;
				else
					m_attributes &= ~TypeAttributes.SpecialName;
			}
		}

		public bool IsEnum {
			get { return m_baseType != null && m_baseType.FullName == Constants.Enum; }
		}

		public override bool IsValueType {
			get {
				return m_baseType != null && (
					this.IsEnum || m_baseType.FullName == Constants.ValueType);
			}
		}

		internal TypeDefinition (string name, string ns, TypeAttributes attrs) :
			base (name, ns)
		{
			m_hasInfo = false;
			m_attributes = attrs;
		}

		public TypeDefinition (string name, string ns,
			TypeAttributes attributes, TypeReference baseType) :
			this (name, ns, attributes)
		{
			this.BaseType = baseType;
		}

		public TypeDefinition Clone ()
		{
			return Clone (this, new ImportContext (null, this));
		}

		internal static TypeDefinition Clone (TypeDefinition type, ImportContext context)
		{
			TypeDefinition nt = new TypeDefinition (
				type.Name,
				type.Namespace,
				type.Attributes);

			context.GenericContext.Type = nt;

			foreach (GenericParameter p in type.GenericParameters)
				nt.GenericParameters.Add (GenericParameter.Clone (p, context));

			if (type.BaseType != null)
				nt.BaseType = context.Import (type.BaseType);

			if (type.HasLayoutInfo) {
				nt.ClassSize = type.ClassSize;
				nt.PackingSize = type.PackingSize;
			}

			foreach (FieldDefinition field in type.Fields)
				nt.Fields.Add (FieldDefinition.Clone (field, context));
			foreach (MethodDefinition ctor in type.Constructors)
				nt.Constructors.Add (MethodDefinition.Clone (ctor, context));
			foreach (MethodDefinition meth in type.Methods)
				nt.Methods.Add (MethodDefinition.Clone (meth, context));
			foreach (EventDefinition evt in type.Events)
				nt.Events.Add (EventDefinition.Clone (evt, context));
			foreach (PropertyDefinition prop in type.Properties)
				nt.Properties.Add (PropertyDefinition.Clone (prop, context));
			foreach (TypeReference intf in type.Interfaces)
				nt.Interfaces.Add (context.Import (intf));
			foreach (TypeDefinition nested in type.NestedTypes)
				nt.NestedTypes.Add (Clone (nested, context));
			foreach (CustomAttribute ca in type.CustomAttributes)
				nt.CustomAttributes.Add (CustomAttribute.Clone (ca, context));
			foreach (SecurityDeclaration dec in type.SecurityDeclarations)
				nt.SecurityDeclarations.Add (SecurityDeclaration.Clone (dec));

			return nt;
		}

		public override void Accept (IReflectionVisitor visitor)
		{
			visitor.VisitTypeDefinition (this);

			this.GenericParameters.Accept (visitor);
			this.Interfaces.Accept (visitor);
			this.Constructors.Accept (visitor);
			this.Methods.Accept (visitor);
			this.Fields.Accept (visitor);
			this.Properties.Accept (visitor);
			this.Events.Accept (visitor);
			this.NestedTypes.Accept (visitor);
			this.CustomAttributes.Accept (visitor);
			this.SecurityDeclarations.Accept (visitor);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/TypeDefinitionCollection.cs
================================================
//
// TypeDefinitionCollection.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Mon Nov 27 21:14:02 CET 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;
	using System.Collections;
	using System.Collections.Specialized;

	using Mono.Cecil.Cil;

	using Hcp = Mono.Cecil.HashCodeProvider;
	using Cmp = System.Collections.Comparer;

	public sealed class TypeDefinitionCollection : NameObjectCollectionBase, IList, IReflectionVisitable  {

		ModuleDefinition m_container;

		public TypeDefinition this [int index] {
			get { return this.BaseGet (index) as TypeDefinition; }
			set { this.BaseSet (index, value); }
		}

		public TypeDefinition this [string fullName] {
			get { return this.BaseGet (fullName) as TypeDefinition; }
			set { this.BaseSet (fullName, value); }
		}

		public ModuleDefinition Container {
			get { return m_container; }
		}

		public bool IsSynchronized {
			get { return false; }
		}

		public object SyncRoot {
			get { return this; }
		}

		bool IList.IsReadOnly {
			get { return false; }
		}

		bool IList.IsFixedSize {
			get { return false; }
		}

		object IList.this [int index] {
			get { return BaseGet (index); }
			set {
				Check (value);
				BaseSet (index, value);
			}
		}

		public TypeDefinitionCollection (ModuleDefinition container) :
			base (Hcp.Instance, Cmp.Default)
		{
			m_container = container;
		}

		public void Add (TypeDefinition value)
		{
			if (value == null)
				throw new ArgumentNullException ("value");

			Attach (value);

			this.BaseAdd (value.FullName, value);
		}

		public void Clear ()
		{
			foreach (TypeDefinition item in this)
				Detach (item);

			this.BaseClear ();
		}

		public bool Contains (TypeDefinition value)
		{
			return Contains (value.FullName);
		}

		public bool Contains (string fullName)
		{
			return this.BaseGet (fullName) != null;
		}

		public int IndexOf (TypeDefinition value)
		{
			string [] keys = this.BaseGetAllKeys ();
			return Array.IndexOf (keys, value.FullName, 0, keys.Length);
		}

		public void Remove (TypeDefinition value)
		{
			if (this.Contains (value))
				Detach (value);

			this.BaseRemove (value.FullName);
		}

		public void RemoveAt (int index)
		{
			Detach (this [index]);

			this.BaseRemoveAt (index);
		}

		public void CopyTo (Array ary, int index)
		{
			this.BaseGetAllValues ().CopyTo (ary, index);
		}

		public new IEnumerator GetEnumerator ()
		{
			return this.BaseGetAllValues ().GetEnumerator ();
		}

		public void Accept (IReflectionVisitor visitor)
		{
			visitor.VisitTypeDefinitionCollection (this);
		}

#if CF_1_0 || CF_2_0
		internal object [] BaseGetAllValues ()
		{
			object [] values = new object [this.Count];
			for (int i=0; i < values.Length; ++i) {
				values [i] = this.BaseGet (i);
			}
			return values;
		}
#endif

		void Check (object value)
		{
			if (!(value is TypeDefinition))
				throw new ArgumentException ();
		}

		int IList.Add (object value)
		{
			Check (value);
			Add (value as TypeDefinition);
			return 0;
		}

		bool IList.Contains (object value)
		{
			Check (value);
			return Contains (value as TypeDefinition);
		}

		int IList.IndexOf (object value)
		{
			throw new NotSupportedException ();
		}

		void IList.Insert (int index, object value)
		{
			throw new NotSupportedException ();
		}

		void IList.Remove (object value)
		{
			Check (value);
			Remove (value as TypeDefinition);
		}

		void Detach (TypeReference type)
		{
			type.Module = null;
		}

		void Attach (TypeReference type)
		{
			if (type.Module != null)
				throw new ReflectionException ("Type is already attached, clone it instead");

			type.Module = m_container;
			type.AttachToScope (m_container);

		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/TypeReference.cs
================================================
//
// TypeReference.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	public class TypeReference : MemberReference, IGenericParameterProvider, ICustomAttributeProvider {

		string m_namespace;
		bool m_fullNameDiscarded;
		string m_fullName;
		protected bool m_isValueType;
		protected IMetadataScope m_scope;
		protected ModuleDefinition m_module;

		CustomAttributeCollection m_customAttrs;
		GenericParameterCollection m_genparams;

		public override string Name {
			get { return base.Name; }
			set {
				base.Name = value;
				m_fullNameDiscarded = true;
			}
		}

		public virtual string Namespace {
			get { return m_namespace; }
			set {
				m_namespace = value;
				m_fullNameDiscarded = true;
			}
		}

		public virtual bool IsValueType {
			get { return m_isValueType; }
			set { m_isValueType = value; }
		}

		public ModuleDefinition Module {
			get { return m_module; }
			set { m_module = value; }
		}

		public CustomAttributeCollection CustomAttributes {
			get {
				if (m_customAttrs == null)
					m_customAttrs = new CustomAttributeCollection (this);

				return m_customAttrs;
			}
		}

		public GenericParameterCollection GenericParameters {
			get {
				if (m_genparams == null)
					m_genparams = new GenericParameterCollection (this);
				return m_genparams;
			}
		}

		public virtual IMetadataScope Scope {
			get {
				if (this.DeclaringType != null)
					return this.DeclaringType.Scope;

				return m_scope;
			}
		}

		public virtual string FullName {
			get {
				if (m_fullName != null && !m_fullNameDiscarded)
					return m_fullName;

				if (this.DeclaringType != null)
					return string.Concat (this.DeclaringType.FullName, "/", this.Name);

				if (m_namespace == null || m_namespace.Length == 0)
					return this.Name;

				m_fullName = string.Concat (m_namespace, ".", this.Name);
				m_fullNameDiscarded = false;
				return m_fullName;
			}
		}

		protected TypeReference (string name, string ns) : base (name)
		{
			m_namespace = ns;
			m_fullNameDiscarded = false;
		}

		internal TypeReference (string name, string ns, IMetadataScope scope) : this (name, ns)
		{
			m_scope = scope;
		}

		public TypeReference (string name, string ns, IMetadataScope scope, bool valueType) :
			this (name, ns, scope)
		{
			this.IsValueType = valueType;
		}

		internal void AttachToScope (IMetadataScope scope)
		{
			m_scope = scope;
		}

		public override void Accept (IReflectionVisitor visitor)
		{
			visitor.VisitTypeReference (this);
		}

		public override string ToString ()
		{
			return this.FullName;
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/TypeReferenceCollection.cs
================================================
//
// TypeReferenceCollection.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Tue Oct 03 00:35:28 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;
	using System.Collections;
	using System.Collections.Specialized;

	using Mono.Cecil.Cil;

	using Hcp = Mono.Cecil.HashCodeProvider;
	using Cmp = System.Collections.Comparer;

	public sealed class TypeReferenceCollection : NameObjectCollectionBase, IList, IReflectionVisitable  {

		ModuleDefinition m_container;

		public TypeReference this [int index] {
			get { return this.BaseGet (index) as TypeReference; }
			set { this.BaseSet (index, value); }
		}

		public TypeReference this [string fullName] {
			get { return this.BaseGet (fullName) as TypeReference; }
			set { this.BaseSet (fullName, value); }
		}

		public ModuleDefinition Container {
			get { return m_container; }
		}

		public bool IsSynchronized {
			get { return false; }
		}

		public object SyncRoot {
			get { return this; }
		}

		bool IList.IsReadOnly {
			get { return false; }
		}

		bool IList.IsFixedSize {
			get { return false; }
		}

		object IList.this [int index] {
			get { return BaseGet (index); }
			set {
				Check (value);
				BaseSet (index, value);
			}
		}

		public TypeReferenceCollection (ModuleDefinition container) :
			base (Hcp.Instance, Cmp.Default)
		{
			m_container = container;
		}

		public void Add (TypeReference value)
		{
			if (value == null)
				throw new ArgumentNullException ("value");

			Attach (value);

			this.BaseAdd (value.FullName, value);
		}

		public void Clear ()
		{
			foreach (TypeReference item in this)
				Detach (item);

			this.BaseClear ();
		}

		public bool Contains (TypeReference value)
		{
			return Contains (value.FullName);
		}

		public bool Contains (string fullName)
		{
			return this.BaseGet (fullName) != null;
		}

		public int IndexOf (TypeReference value)
		{
			string [] keys = this.BaseGetAllKeys ();
			return Array.IndexOf (keys, value.FullName, 0, keys.Length);
		}

		public void Remove (TypeReference value)
		{
			if (this.Contains (value))
				Detach (value);

			this.BaseRemove (value.FullName);
		}

		public void RemoveAt (int index)
		{
			Detach (this [index]);

			this.BaseRemoveAt (index);
		}

		public void CopyTo (Array ary, int index)
		{
			this.BaseGetAllValues ().CopyTo (ary, index);
		}

		public new IEnumerator GetEnumerator ()
		{
			return this.BaseGetAllValues ().GetEnumerator ();
		}

		public void Accept (IReflectionVisitor visitor)
		{
			visitor.VisitTypeReferenceCollection (this);
		}

#if CF_1_0 || CF_2_0
		internal object [] BaseGetAllValues ()
		{
			object [] values = new object [this.Count];
			for (int i=0; i < values.Length; ++i) {
				values [i] = this.BaseGet (i);
			}
			return values;
		}
#endif

		void Check (object value)
		{
			if (!(value is TypeReference))
				throw new ArgumentException ();
		}

		int IList.Add (object value)
		{
			Check (value);
			Add (value as TypeReference);
			return 0;
		}

		bool IList.Contains (object value)
		{
			Check (value);
			return Contains (value as TypeReference);
		}

		int IList.IndexOf (object value)
		{
			throw new NotSupportedException ();
		}

		void IList.Insert (int index, object value)
		{
			throw new NotSupportedException ();
		}

		void IList.Remove (object value)
		{
			Check (value);
			Remove (value as TypeReference);
		}

		void Detach (TypeReference type)
		{
			type.Module = null;
		}

		void Attach (TypeReference type)
		{
			if (type.Module != null)
				throw new ReflectionException ("Type is already attached, clone it instead");

			type.Module = m_container;
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/TypeSpecification.cs
================================================
//
// TypeSpecification.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	using System;

	public abstract class TypeSpecification : TypeReference {

		private TypeReference m_elementType;

		public override string Name {
			get { return m_elementType.Name; }
			set { throw new NotSupportedException (); }
		}

		public override string Namespace {
			get { return m_elementType.Namespace; }
			set { throw new NotSupportedException (); }
		}

		public override bool IsValueType {
			get { return m_elementType.IsValueType; }
			set { throw new InvalidOperationException (); }
		}

		public override IMetadataScope Scope {
			get { return m_elementType.Scope; }
		}

		public TypeReference ElementType {
			get { return m_elementType; }
			set { m_elementType = value; }
		}

		public override string FullName {
			get { return m_elementType.FullName; }
		}

		internal TypeSpecification (TypeReference elementType) : base (string.Empty, string.Empty)
		{
			m_elementType = elementType;
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil/VariantType.cs
================================================
//
// VariantType.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil {

	public enum VariantType {
		I2 = 2,
		I4 = 3,
		R4 = 4,
		R8 = 5,
		CY = 6,
		DATE = 7,
		BSTR = 8,
		DISPATCH = 9,
		ERROR = 10,
		BOOL = 11,
		VARIANT = 12,
		UNKNOWN = 13,
		DECIMAL = 14,
		I1 = 16,
		UI1 = 17,
		UI2 = 18,
		UI4 = 19,
		INT = 22,
		UINT = 23
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Binary/BaseImageVisitor.cs
================================================
//
// BaseImageVisitor.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Binary {

	public abstract class BaseImageVisitor : IBinaryVisitor {

		public virtual void VisitImage (Image img)
		{
		}

		public virtual void VisitDOSHeader (DOSHeader header)
		{
		}

		public virtual void VisitPEFileHeader (PEFileHeader header)
		{
		}

		public virtual void VisitPEOptionalHeader (PEOptionalHeader header)
		{
		}

		public virtual void VisitStandardFieldsHeader (PEOptionalHeader.StandardFieldsHeader header)
		{
		}

		public virtual void VisitNTSpecificFieldsHeader (PEOptionalHeader.NTSpecificFieldsHeader header)
		{
		}

		public virtual void VisitDataDirectoriesHeader (PEOptionalHeader.DataDirectoriesHeader header)
		{
		}

		public virtual void VisitSectionCollection (SectionCollection coll)
		{
		}

		public virtual void VisitSection (Section section)
		{
		}

		public virtual void VisitImportAddressTable (ImportAddressTable iat)
		{
		}

		public virtual void VisitDebugHeader (DebugHeader dh)
		{
		}

		public virtual void VisitCLIHeader (CLIHeader header)
		{
		}

		public virtual void VisitImportTable (ImportTable it)
		{
		}

		public virtual void VisitImportLookupTable (ImportLookupTable ilt)
		{
		}

		public virtual void VisitHintNameTable (HintNameTable hnt)
		{
		}

		public virtual void TerminateImage (Image img)
		{
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Binary/CLIHeader.cs
================================================
//
// CLIHeader.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Binary {

	public sealed class CLIHeader : IHeader, IBinaryVisitable {

		public uint Cb;
		public ushort MajorRuntimeVersion;
		public ushort MinorRuntimeVersion;
		public DataDirectory Metadata;
		public RuntimeImage Flags;
		public uint EntryPointToken;
		public DataDirectory Resources;
		public DataDirectory StrongNameSignature;
		public DataDirectory CodeManagerTable;
		public DataDirectory VTableFixups;
		public DataDirectory ExportAddressTableJumps;
		public DataDirectory ManagedNativeHeader;

		public byte [] ImageHash;

		internal CLIHeader ()
		{
		}

		public void SetDefaultValues ()
		{
			Cb = 0x48;
			MajorRuntimeVersion = 2;
			MinorRuntimeVersion = 0;
			Flags = RuntimeImage.ILOnly;
			CodeManagerTable = DataDirectory.Zero;
			ExportAddressTableJumps = DataDirectory.Zero;
			ManagedNativeHeader = DataDirectory.Zero;
		}

		public void Accept (IBinaryVisitor visitor)
		{
			visitor.VisitCLIHeader (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Binary/CopyImageVisitor.cs
================================================
//
// CopyImageVisitor.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Binary {

	class CopyImageVisitor : BaseImageVisitor {

		Image m_newImage;
		Image m_originalImage;

		public CopyImageVisitor (Image originalImage)
		{
			m_originalImage = originalImage;
		}

		public override void VisitImage (Image img)
		{
			m_newImage = img;
			if (m_originalImage.DebugHeader != null)
				m_newImage.AddDebugHeader ();
		}

		public override void VisitDebugHeader (DebugHeader dbgHeader)
		{
			DebugHeader old = m_originalImage.DebugHeader;
			dbgHeader.Age = old.Age;
			dbgHeader.Characteristics = old.Characteristics;
			dbgHeader.FileName = old.FileName;
			dbgHeader.Signature = old.Signature;
			dbgHeader.TimeDateStamp = ImageInitializer.TimeDateStampFromEpoch();
			dbgHeader.Type = old.Type;
		}

		public override void VisitSectionCollection (SectionCollection sections)
		{
			Section old = null;
			foreach (Section s in m_originalImage.Sections)
				if (s.Name == Section.Resources)
					old = s;

			if (old == null)
				return;

			Section rsrc = new Section ();
			rsrc.Characteristics = old.Characteristics;
			rsrc.Name = old.Name;

			sections.Add (rsrc);
		}

		public override void TerminateImage (Image img)
		{
			if (m_originalImage.ResourceDirectoryRoot == null)
				return;

			m_newImage.ResourceDirectoryRoot = CloneResourceDirectoryTable (m_originalImage.ResourceDirectoryRoot);
		}

		ResourceDirectoryTable CloneResourceDirectoryTable (ResourceDirectoryTable old)
		{
			ResourceDirectoryTable rdt = new ResourceDirectoryTable ();
			foreach (ResourceDirectoryEntry oldEntry in old.Entries)
				rdt.Entries.Add (CloneResourceDirectoryEntry (oldEntry));

			return rdt;
		}

		ResourceDirectoryEntry CloneResourceDirectoryEntry (ResourceDirectoryEntry old)
		{
			ResourceDirectoryEntry rde;
			if (old.IdentifiedByName)
				rde = new ResourceDirectoryEntry(old.Name);
			else
				rde = new ResourceDirectoryEntry (old.ID);

			if (old.Child is ResourceDirectoryTable)
				rde.Child = CloneResourceDirectoryTable (old.Child as ResourceDirectoryTable);
			else
				rde.Child = CloneResourceDataEntry (old.Child as ResourceDataEntry);

			return rde;
		}

		ResourceDataEntry CloneResourceDataEntry (ResourceDataEntry old)
		{
			ResourceDataEntry rde = new ResourceDataEntry ();
			rde.Size = old.Size;
			rde.Codepage = old.Codepage;
			rde.ResourceData = old.ResourceData;

			return rde;
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Binary/DOSHeader.cs
================================================
//
// DOSHeader.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Binary {

	public sealed class DOSHeader : IHeader, IBinaryVisitable {

		public byte [] Start;
		public byte [] End;

		public uint Lfanew;

		internal DOSHeader ()
		{
		}

		public void SetDefaultValues ()
		{
			Start = new byte [60] {
				0x4d, 0x5a, 0x90, 0x00, 0x03, 0x00, 0x00,
				0x00, 0x04, 0x00, 0x00, 0x00, 0xff, 0xff,
				0x00, 0x00, 0xb8, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00
			};
			Lfanew = 128;
			End = new byte [64] {
				0x0e, 0x1f, 0xba, 0x0e, 0x00, 0xb4, 0x09,
				0xcd, 0x21, 0xb8, 0x01, 0x4c, 0xcd, 0x21,
				0x54, 0x68, 0x69, 0x73, 0x20, 0x70, 0x72,
				0x6f, 0x67, 0x72, 0x61, 0x6d, 0x20, 0x63,
				0x61, 0x6e, 0x6e, 0x6f, 0x74, 0x20, 0x62,
				0x65, 0x20, 0x72, 0x75, 0x6e, 0x20, 0x69,
				0x6e, 0x20, 0x44, 0x4f, 0x53, 0x20, 0x6d,
				0x6f, 0x64, 0x65, 0x2e, 0x0d, 0x0d, 0x0a,
				0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00
			};
		}

		public void Accept (IBinaryVisitor visitor)
		{
			visitor.VisitDOSHeader (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Binary/DataDirectory.cs
================================================
//
// DataDirectory.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Binary {

	using Mono.Cecil.Metadata;

	public struct DataDirectory {

		public static readonly DataDirectory Zero = new DataDirectory(RVA.Zero, 0);

		RVA m_virtualAddress;
		uint m_size;

		public RVA VirtualAddress {
			get { return m_virtualAddress; }
			set { m_virtualAddress = value; }
		}

		public uint Size {
			get { return m_size; }
			set { m_size = value; }
		}

		public DataDirectory (RVA virtualAddress, uint size)
		{
			m_virtualAddress = virtualAddress;
			m_size = size;
		}

		public override int GetHashCode ()
		{
			return (m_virtualAddress.GetHashCode () ^ (int) m_size << 1);
		}

		public override bool Equals (object other)
		{
			if (other is DataDirectory) {
				DataDirectory odd = (DataDirectory)other;
				return (this.m_virtualAddress == odd.m_virtualAddress &&
				this.m_size == odd.m_size);
			}
			return false;
		}

		public override string ToString ()
		{
			return string.Format ("{0} [{1}]",
								  m_virtualAddress.ToString (), m_size.ToString ("X"));
		}

		public static bool operator == (DataDirectory one, DataDirectory other)
		{
			return one.Equals (other);
		}

		public static bool operator != (DataDirectory one, DataDirectory other)
		{
			return !one.Equals (other);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Binary/DebugHeader.cs
================================================
//
// DebugHeader.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Binary {

	using System;

	public sealed class DebugHeader : IHeader, IBinaryVisitable {

		public uint Characteristics;
		public uint TimeDateStamp;
		public ushort MajorVersion;
		public ushort MinorVersion;
		public DebugStoreType Type;
		public uint SizeOfData;
		public RVA AddressOfRawData;
		public uint PointerToRawData;

		public uint Magic;
		public Guid Signature;
		public uint Age;
		public string FileName;

		internal DebugHeader ()
		{
		}

		public void SetDefaultValues ()
		{
			Characteristics = 0;

			this.Magic = 0x53445352;
			this.Age = 0;
			this.Type = DebugStoreType.CodeView;
			this.FileName = string.Empty;
		}

		public uint GetSize ()
		{
			return 0x34 + (uint) FileName.Length + 1;
		}

		public void Accept (IBinaryVisitor visitor)
		{
			visitor.VisitDebugHeader (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Binary/DebugStoreType.cs
================================================
//
// DebugStoreType.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Binary {

	public enum DebugStoreType : uint {
		Unknown = 0x00000000,
		COFF = 0x00000001,
		CodeView = 0x00000002,
		FPO = 0x00000003,
		Misc = 0x00000004,
		Exception = 0x00000005,
		Fixup = 0x00000006,
		OMAPToSrc = 0x00000007,
		OMAPFromSrc = 0x00000008,
		Borland = 0x00000009,
		Reserved10 = 0x0000000a,
		CLSID = 0x0000000b
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Binary/IBinaryVisitable.cs
================================================
//
// IBinaryVisitable.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Binary {

	public interface IBinaryVisitable {
		void Accept (IBinaryVisitor visitor);
	}
}




================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Binary/IBinaryVisitor.cs
================================================
//
// IBinaryVisitor.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Binary {

	public interface IBinaryVisitor {
		void VisitImage (Image img);
		void VisitDOSHeader (DOSHeader header);
		void VisitPEFileHeader (PEFileHeader header);
		void VisitPEOptionalHeader (PEOptionalHeader header);
		void VisitStandardFieldsHeader (PEOptionalHeader.StandardFieldsHeader header);
		void VisitNTSpecificFieldsHeader (PEOptionalHeader.NTSpecificFieldsHeader header);
		void VisitDataDirectoriesHeader (PEOptionalHeader.DataDirectoriesHeader header);
		void VisitSectionCollection (SectionCollection coll);
		void VisitSection (Section section);
		void VisitImportAddressTable (ImportAddressTable iat);
		void VisitDebugHeader (DebugHeader dh);
		void VisitCLIHeader (CLIHeader header);
		void VisitImportTable (ImportTable it);
		void VisitImportLookupTable (ImportLookupTable ilt);
		void VisitHintNameTable (HintNameTable hnt);

		void TerminateImage (Image img);
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Binary/IHeader.cs
================================================
//
// IHeader.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Binary {

	internal interface IHeader {
		void SetDefaultValues ();
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Binary/Image.cs
================================================
//
// Image.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Binary {

	using System;
	using System.IO;

	using Mono.Cecil.Metadata;

	public sealed class Image : IBinaryVisitable {

		DOSHeader m_dosHeader;
		PEFileHeader m_peFileHeader;
		PEOptionalHeader m_peOptionalHeader;

		SectionCollection m_sections;
		Section m_textSection;

		ImportAddressTable m_importAddressTable;
		CLIHeader m_cliHeader;
		ImportTable m_importTable;
		ImportLookupTable m_importLookupTable;
		HintNameTable m_hintNameTable;

		DebugHeader m_debugHeader;
		MetadataRoot m_mdRoot;

		ResourceDirectoryTable m_rsrcRoot;

		FileInfo m_img;

		public DOSHeader DOSHeader {
			get { return m_dosHeader; }
		}

		public PEFileHeader PEFileHeader {
			get { return m_peFileHeader; }
		}

		public PEOptionalHeader PEOptionalHeader {
			get { return m_peOptionalHeader; }
		}

		public SectionCollection Sections {
			get { return m_sections; }
		}

		public Section TextSection {
			get { return m_textSection; }
			set { m_textSection = value; }
		}

		public ImportAddressTable ImportAddressTable {
			get { return m_importAddressTable; }
		}

		public CLIHeader CLIHeader {
			get { return m_cliHeader; }
		}

		public DebugHeader DebugHeader {
			get { return m_debugHeader; }
			set { m_debugHeader = value; }
		}

		public MetadataRoot MetadataRoot {
			get { return m_mdRoot; }
		}

		public ImportTable ImportTable {
			get { return m_importTable; }
		}

		public ImportLookupTable ImportLookupTable {
			get { return m_importLookupTable; }
		}

		public HintNameTable HintNameTable {
			get { return m_hintNameTable; }
		}

		internal ResourceDirectoryTable ResourceDirectoryRoot {
			get { return m_rsrcRoot; }
			set { m_rsrcRoot = value; }
		}

		public FileInfo FileInformation {
			get { return m_img; }
		}

		internal Image ()
		{
			m_dosHeader = new DOSHeader ();
			m_peFileHeader = new PEFileHeader ();
			m_peOptionalHeader = new PEOptionalHeader ();
			m_sections = new SectionCollection ();
			m_importAddressTable = new ImportAddressTable ();
			m_cliHeader = new CLIHeader ();
			m_importTable = new ImportTable ();
			m_importLookupTable = new ImportLookupTable ();
			m_hintNameTable = new HintNameTable ();
			m_mdRoot = new MetadataRoot (this);
		}

		internal Image (FileInfo img) : this ()
		{
			m_img = img;
		}

		public long ResolveVirtualAddress (RVA rva)
		{
			foreach (Section sect in this.Sections) {
				if (rva >= sect.VirtualAddress &&
					rva < sect.VirtualAddress + sect.SizeOfRawData)

					return rva + sect.PointerToRawData - sect.VirtualAddress;
			}
			return 0;
		}

		public BinaryReader GetReaderAtVirtualAddress (RVA rva)
		{
			foreach (Section sect in this.Sections) {
				if (rva >= sect.VirtualAddress &&
					rva < sect.VirtualAddress + sect.SizeOfRawData) {

					BinaryReader br = new BinaryReader (new MemoryStream (sect.Data));
					br.BaseStream.Position = rva - sect.VirtualAddress;
					return br;
				}
			}

			return null;
		}

		public void AddDebugHeader ()
		{
			m_debugHeader = new DebugHeader ();
			m_debugHeader.SetDefaultValues ();
		}

		public void Accept (IBinaryVisitor visitor)
		{
			visitor.VisitImage (this);

			m_dosHeader.Accept (visitor);
			m_peFileHeader.Accept (visitor);
			m_peOptionalHeader.Accept (visitor);

			m_sections.Accept (visitor);

			m_importAddressTable.Accept (visitor);
			m_cliHeader.Accept (visitor);

			if (m_debugHeader != null)
				m_debugHeader.Accept (visitor);

			m_importTable.Accept (visitor);
			m_importLookupTable.Accept (visitor);
			m_hintNameTable.Accept (visitor);

			visitor.TerminateImage (this);
		}

		public static Image CreateImage ()
		{
			Image img = new Image ();

			ImageInitializer init = new ImageInitializer (img);
			img.Accept (init);

			return img;
		}

		public static Image GetImage (string file)
		{
			return ImageReader.Read (file).Image;
		}

		public static Image GetImage (byte [] image)
		{
			return ImageReader.Read (image).Image;
		}

		public static Image GetImage (Stream stream)
		{
			return ImageReader.Read (stream).Image;
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Binary/ImageCharacteristics.cs
================================================
//
// ImageCharacteristics.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Binary {

	using System;

	[Flags]
	public enum ImageCharacteristics : ushort {
		RelocsStripped = 0x0001,
		ExecutableImage = 0x0002,
		LineNumsStripped = 0x0004,
		LocalSymsStripped = 0x0008,
		AggressiveWSTrim = 0x0010,
		LargeAddressAware = 0x0020,
		ReservedForFutureUse = 0x0040,
		BytesReversedLo = 0x0080,
		_32BitsMachine = 0x0100,
		DebugStripped = 0x0200,
		RemovableRunFromSwap = 0x0400,
		NetRunFromSwap = 0x0800,
		System = 0x1000,
		Dll = 0x2000,
		UPSystemOnly = 0x4000,
		BytesReversedHI = 0x8000,

		__flags = 0x0002 | 0x0004 | 0x0008 | 0x0100,

		CILOnlyDll = 0x2000 | (ushort) __flags,
		CILOnlyExe = __flags
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Binary/ImageFormatException.cs
================================================
//
// ImageFormatException.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Binary {

	using System;

	public class ImageFormatException : Exception {

		internal ImageFormatException () : base()
		{
		}

		internal ImageFormatException (string message) : base(message)
		{
		}

		internal ImageFormatException (string message, params string[] parameters) :
			base(string.Format(message, parameters))
		{
		}

		internal ImageFormatException (string message, Exception inner) :
			base(message, inner)
		{
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Binary/ImageInitializer.cs
================================================
//
// ImageInitializer.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Binary {

	using System;

	using Mono.Cecil.Metadata;

	class ImageInitializer : BaseImageVisitor {

		Image m_image;
		MetadataInitializer m_mdinit;

		public Image Image {
			get { return m_image; }
		}

		public MetadataInitializer Metadata {
			get { return m_mdinit; }
		}

		public ImageInitializer (Image image)
		{
			m_image = image;
			m_mdinit = new MetadataInitializer (this);
		}

		public override void VisitDOSHeader (DOSHeader header)
		{
			header.SetDefaultValues ();
		}

		public override void VisitPEOptionalHeader (PEOptionalHeader header)
		{
			header.SetDefaultValues ();
		}

		public override void VisitPEFileHeader (PEFileHeader header)
		{
			header.SetDefaultValues ();
			header.TimeDateStamp = TimeDateStampFromEpoch ();
		}

		public override void VisitNTSpecificFieldsHeader (PEOptionalHeader.NTSpecificFieldsHeader header)
		{
			header.SetDefaultValues ();
		}

		public override void VisitStandardFieldsHeader (PEOptionalHeader.StandardFieldsHeader header)
		{
			header.SetDefaultValues ();
		}

		public override void VisitDataDirectoriesHeader (PEOptionalHeader.DataDirectoriesHeader header)
		{
			header.SetDefaultValues ();
		}

		public override void VisitSectionCollection (SectionCollection coll)
		{
			Section text = new Section ();
			text.Name = Section.Text;
			text.Characteristics = SectionCharacteristics.ContainsCode |
				SectionCharacteristics.MemoryRead | SectionCharacteristics.MemExecute;
			m_image.TextSection = text;

			Section reloc = new Section ();
			reloc.Name =  Section.Relocs;
			reloc.Characteristics = SectionCharacteristics.ContainsInitializedData |
				SectionCharacteristics.MemDiscardable | SectionCharacteristics.MemoryRead;

			coll.Add (text);
			coll.Add (reloc);
		}

		public override void VisitSection (Section sect)
		{
			sect.SetDefaultValues ();
		}

		public override void VisitDebugHeader (DebugHeader dh)
		{
			if (dh != null)
				dh.SetDefaultValues ();
		}

		public override void VisitCLIHeader (CLIHeader header)
		{
			header.SetDefaultValues ();
			m_image.MetadataRoot.Accept (m_mdinit);
		}

		public override void VisitImportTable (ImportTable it)
		{
			it.ImportAddressTable = new RVA (0x2000);
		}

		public override void VisitHintNameTable (HintNameTable hnt)
		{
			hnt.Hint = 0;
			hnt.RuntimeLibrary = HintNameTable.RuntimeCorEE;
			hnt.EntryPoint = 0x25ff;
			hnt.RVA = new RVA (0x402000);
		}

		public static uint TimeDateStampFromEpoch ()
		{
			return (uint) DateTime.UtcNow.Subtract (
				new DateTime (1970, 1, 1)).TotalSeconds;
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Binary/ImageReader.cs
================================================
//
// ImageReader.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Binary {

	using System;
	using System.IO;
	using System.Text;

	using Mono.Cecil.Metadata;

	class ImageReader : BaseImageVisitor {

		MetadataReader m_mdReader;
		BinaryReader m_binaryReader;
		Image m_image;

		public MetadataReader MetadataReader {
			get { return m_mdReader; }
		}

		public Image Image {
			get { return m_image; }
		}

		ImageReader (Image img, BinaryReader reader)
		{
			m_image = img;
			m_binaryReader = reader;
		}

		static ImageReader Read (Image img, Stream stream)
		{
			ImageReader reader = new ImageReader (img, new BinaryReader (stream));
			img.Accept (reader);
			return reader;
		}

		public static ImageReader Read (string file)
		{
			if (file == null)
				throw new ArgumentNullException ("file");

			FileInfo fi = new FileInfo (file);
			if (!File.Exists (fi.FullName))
			#if CF_1_0 || CF_2_0
				throw new FileNotFoundException (fi.FullName);
			#else
				throw new FileNotFoundException (string.Format ("File '{0}' not found.", fi.FullName), fi.FullName);
			#endif

			return Read (new Image (fi), new FileStream (
				fi.FullName, FileMode.Open,
				FileAccess.Read, FileShare.Read));
		}

		public static ImageReader Read (byte [] image)
		{
			if (image == null)
				throw new ArgumentNullException ("image");

			if (image.Length == 0)
				throw new ArgumentException ("Empty image array");

			return Read (new Image (), new MemoryStream (image));
		}

		public static ImageReader Read (Stream stream)
		{
			if (stream == null)
				throw new ArgumentNullException ("stream");

			if (!stream.CanRead)
				throw new ArgumentException ("Can not read from stream");

			return Read (new Image (), stream);
		}

		public BinaryReader GetReader ()
		{
			return m_binaryReader;
		}

		public override void VisitImage (Image img)
		{
			m_mdReader = new MetadataReader (this);
		}

		public override void VisitDOSHeader (DOSHeader header)
		{
			header.Start = m_binaryReader.ReadBytes (60);
			header.Lfanew = m_binaryReader.ReadUInt32 ();
			header.End = m_binaryReader.ReadBytes (64);

			m_binaryReader.BaseStream.Position = header.Lfanew;

			if (m_binaryReader.ReadUInt16 () != 0x4550 ||
				m_binaryReader.ReadUInt16 () != 0)

				throw new ImageFormatException ("Invalid PE File Signature");
		}

		public override void VisitPEFileHeader (PEFileHeader header)
		{
			header.Machine = m_binaryReader.ReadUInt16 ();
			header.NumberOfSections = m_binaryReader.ReadUInt16 ();
			header.TimeDateStamp = m_binaryReader.ReadUInt32 ();
			header.PointerToSymbolTable = m_binaryReader.ReadUInt32 ();
			header.NumberOfSymbols = m_binaryReader.ReadUInt32 ();
			header.OptionalHeaderSize = m_binaryReader.ReadUInt16 ();
			header.Characteristics = (Mono.Cecil.Binary.ImageCharacteristics) m_binaryReader.ReadUInt16 ();
		}

		ulong ReadIntOrLong ()
		{
			return m_image.PEOptionalHeader.StandardFields.IsPE64 ?
				m_binaryReader.ReadUInt64 () :
				m_binaryReader.ReadUInt32 ();
		}

		public override void VisitNTSpecificFieldsHeader (PEOptionalHeader.NTSpecificFieldsHeader header)
		{
			header.ImageBase = ReadIntOrLong ();
			header.SectionAlignment = m_binaryReader.ReadUInt32 ();
			header.FileAlignment = m_binaryReader.ReadUInt32 ();
			header.OSMajor = m_binaryReader.ReadUInt16 ();
			header.OSMinor = m_binaryReader.ReadUInt16 ();
			header.UserMajor = m_binaryReader.ReadUInt16 ();
			header.UserMinor = m_binaryReader.ReadUInt16 ();
			header.SubSysMajor = m_binaryReader.ReadUInt16 ();
			header.SubSysMinor = m_binaryReader.ReadUInt16 ();
			header.Reserved = m_binaryReader.ReadUInt32 ();
			header.ImageSize = m_binaryReader.ReadUInt32 ();
			header.HeaderSize = m_binaryReader.ReadUInt32 ();
			header.FileChecksum = m_binaryReader.ReadUInt32 ();
			header.SubSystem = (Mono.Cecil.Binary.SubSystem) m_binaryReader.ReadUInt16 ();
			header.DLLFlags = m_binaryReader.ReadUInt16 ();
			header.StackReserveSize = ReadIntOrLong ();
			header.StackCommitSize = ReadIntOrLong ();
			header.HeapReserveSize = ReadIntOrLong ();
			header.HeapCommitSize = ReadIntOrLong ();
			header.LoaderFlags = m_binaryReader.ReadUInt32 ();
			header.NumberOfDataDir = m_binaryReader.ReadUInt32 ();
		}

		public override void VisitStandardFieldsHeader (PEOptionalHeader.StandardFieldsHeader header)
		{
			header.Magic = m_binaryReader.ReadUInt16 ();
			header.LMajor = m_binaryReader.ReadByte ();
			header.LMinor = m_binaryReader.ReadByte ();
			header.CodeSize = m_binaryReader.ReadUInt32 ();
			header.InitializedDataSize = m_binaryReader.ReadUInt32 ();
			header.UninitializedDataSize = m_binaryReader.ReadUInt32 ();
			header.EntryPointRVA = new RVA (m_binaryReader.ReadUInt32 ());
			header.BaseOfCode = new RVA (m_binaryReader.ReadUInt32 ());
			if (!header.IsPE64)
				header.BaseOfData = new RVA (m_binaryReader.ReadUInt32 ());
		}

		public override void VisitDataDirectoriesHeader (PEOptionalHeader.DataDirectoriesHeader header)
		{
			header.ExportTable = new DataDirectory (
				new RVA (m_binaryReader.ReadUInt32 ()),
				m_binaryReader.ReadUInt32 ());
			header.ImportTable = new DataDirectory (
				new RVA (m_binaryReader.ReadUInt32 ()),
				m_binaryReader.ReadUInt32 ());
			header.ResourceTable = new DataDirectory (
				new RVA (m_binaryReader.ReadUInt32 ()),
				m_binaryReader.ReadUInt32 ());
			header.ExceptionTable = new DataDirectory (
				new RVA (m_binaryReader.ReadUInt32 ()),
				m_binaryReader.ReadUInt32 ());
			header.CertificateTable = new DataDirectory (
				new RVA (m_binaryReader.ReadUInt32 ()),
				m_binaryReader.ReadUInt32 ());
			header.BaseRelocationTable = new DataDirectory (
				new RVA (m_binaryReader.ReadUInt32 ()),
				m_binaryReader.ReadUInt32 ());
			header.Debug = new DataDirectory (
				new RVA (m_binaryReader.ReadUInt32 ()),
				m_binaryReader.ReadUInt32 ());
			header.Copyright = new DataDirectory (
				new RVA (m_binaryReader.ReadUInt32 ()),
				m_binaryReader.ReadUInt32 ());
			header.GlobalPtr = new DataDirectory (
				new RVA (m_binaryReader.ReadUInt32 ()),
				m_binaryReader.ReadUInt32 ());
			header.TLSTable = new DataDirectory (
				new RVA (m_binaryReader.ReadUInt32 ()),
				m_binaryReader.ReadUInt32 ());
			header.LoadConfigTable = new DataDirectory (
				new RVA (m_binaryReader.ReadUInt32 ()),
				m_binaryReader.ReadUInt32 ());
			header.BoundImport = new DataDirectory (
				new RVA (m_binaryReader.ReadUInt32 ()),
				m_binaryReader.ReadUInt32 ());
			header.IAT = new DataDirectory (
				new RVA (m_binaryReader.ReadUInt32 ()),
				m_binaryReader.ReadUInt32 ());
			header.DelayImportDescriptor = new DataDirectory (
				new RVA (m_binaryReader.ReadUInt32 ()),
				m_binaryReader.ReadUInt32 ());
			header.CLIHeader = new DataDirectory (
				new RVA (m_binaryReader.ReadUInt32 ()),
				m_binaryReader.ReadUInt32 ());
			header.Reserved = new DataDirectory (
				new RVA (m_binaryReader.ReadUInt32 ()),
				m_binaryReader.ReadUInt32 ());
		}

		public override void VisitSectionCollection (SectionCollection coll)
		{
			for (int i = 0; i < m_image.PEFileHeader.NumberOfSections; i++)
				coll.Add (new Section ());
		}

		public override void VisitSection (Section sect)
		{
			char [] name, buffer = new char [8];
			int read = 0;
			while (read < 8) {
				char cur = (char) m_binaryReader.ReadSByte ();
				if (cur == '\0')
					break;
				buffer [read++] = cur;
			}
			name = new char [read];
			Array.Copy (buffer, 0, name, 0, read);
			sect.Name = read == 0 ? string.Empty : new string (name);
			if (sect.Name == Section.Text)
				m_image.TextSection = sect;
			m_binaryReader.BaseStream.Position += 8 - read - 1;
			sect.VirtualSize = m_binaryReader.ReadUInt32 ();
			sect.VirtualAddress = new RVA (m_binaryReader.ReadUInt32 ());
			sect.SizeOfRawData = m_binaryReader.ReadUInt32 ();
			sect.PointerToRawData = new RVA (m_binaryReader.ReadUInt32 ());
			sect.PointerToRelocations = new RVA (m_binaryReader.ReadUInt32 ());
			sect.PointerToLineNumbers = new RVA (m_binaryReader.ReadUInt32 ());
			sect.NumberOfRelocations = m_binaryReader.ReadUInt16 ();
			sect.NumberOfLineNumbers = m_binaryReader.ReadUInt16 ();
			sect.Characteristics = (Mono.Cecil.Binary.SectionCharacteristics) m_binaryReader.ReadUInt32 ();

			long pos = m_binaryReader.BaseStream.Position;
			m_binaryReader.BaseStream.Position = sect.PointerToRawData;
			sect.Data = m_binaryReader.ReadBytes ((int) sect.SizeOfRawData);
			m_binaryReader.BaseStream.Position = pos;
		}

		public override void VisitImportAddressTable (ImportAddressTable iat)
		{
			m_binaryReader.BaseStream.Position = m_image.ResolveVirtualAddress (
				m_image.PEOptionalHeader.DataDirectories.IAT.VirtualAddress);

			iat.HintNameTableRVA = new RVA (m_binaryReader.ReadUInt32 ());
		}

		public override void VisitCLIHeader (CLIHeader header)
		{
			if (m_image.PEOptionalHeader.DataDirectories.CLIHeader == DataDirectory.Zero)
				throw new ImageFormatException ("Non CLI Image");

			if (m_image.PEOptionalHeader.DataDirectories.Debug != DataDirectory.Zero) {
				m_image.DebugHeader = new DebugHeader ();
				VisitDebugHeader (m_image.DebugHeader);
			}

			m_binaryReader.BaseStream.Position = m_image.ResolveVirtualAddress (
				m_image.PEOptionalHeader.DataDirectories.CLIHeader.VirtualAddress);
			header.Cb = m_binaryReader.ReadUInt32 ();
			header.MajorRuntimeVersion = m_binaryReader.ReadUInt16 ();
			header.MinorRuntimeVersion = m_binaryReader.ReadUInt16 ();
			header.Metadata = new DataDirectory (
				new RVA (m_binaryReader.ReadUInt32 ()),
				m_binaryReader.ReadUInt32 ());
			header.Flags = (Mono.Cecil.Binary.RuntimeImage) m_binaryReader.ReadUInt32 ();
			header.EntryPointToken = m_binaryReader.ReadUInt32 ();
			header.Resources = new DataDirectory (
				new RVA (m_binaryReader.ReadUInt32 ()),
				m_binaryReader.ReadUInt32 ());
			header.StrongNameSignature = new DataDirectory (
				new RVA (m_binaryReader.ReadUInt32 ()),
				m_binaryReader.ReadUInt32 ());
			header.CodeManagerTable = new DataDirectory (
				new RVA (m_binaryReader.ReadUInt32 ()),
				m_binaryReader.ReadUInt32 ());
			header.VTableFixups = new DataDirectory (
				new RVA (m_binaryReader.ReadUInt32 ()),
				m_binaryReader.ReadUInt32 ());
			header.ExportAddressTableJumps = new DataDirectory (
				new RVA (m_binaryReader.ReadUInt32 ()),
				m_binaryReader.ReadUInt32 ());
			header.ManagedNativeHeader = new DataDirectory (
				new RVA (m_binaryReader.ReadUInt32 ()),
				m_binaryReader.ReadUInt32 ());

			if (header.StrongNameSignature != DataDirectory.Zero) {
				m_binaryReader.BaseStream.Position = m_image.ResolveVirtualAddress (
					header.StrongNameSignature.VirtualAddress);
				header.ImageHash = m_binaryReader.ReadBytes ((int) header.StrongNameSignature.Size);
			} else {
				header.ImageHash = new byte [0];
			}
			m_binaryReader.BaseStream.Position = m_image.ResolveVirtualAddress (
				m_image.CLIHeader.Metadata.VirtualAddress);
			m_image.MetadataRoot.Accept (m_mdReader);
		}

		public override void VisitDebugHeader (DebugHeader header)
		{
			if (m_image.PEOptionalHeader.DataDirectories.Debug == DataDirectory.Zero)
				return;

			long pos = m_binaryReader.BaseStream.Position;

			m_binaryReader.BaseStream.Position = m_image.ResolveVirtualAddress (
				m_image.PEOptionalHeader.DataDirectories.Debug.VirtualAddress);
			header.Characteristics = m_binaryReader.ReadUInt32 ();
			header.TimeDateStamp = m_binaryReader.ReadUInt32 ();
			header.MajorVersion = m_binaryReader.ReadUInt16 ();
			header.MinorVersion = m_binaryReader.ReadUInt16 ();
			header.Type = (Mono.Cecil.Binary.DebugStoreType) m_binaryReader.ReadUInt32 ();
			header.SizeOfData = m_binaryReader.ReadUInt32 ();
			header.AddressOfRawData = new RVA (m_binaryReader.ReadUInt32 ());
			header.PointerToRawData = m_binaryReader.ReadUInt32 ();

			m_binaryReader.BaseStream.Position = m_image.ResolveVirtualAddress (
				m_image.DebugHeader.AddressOfRawData);

			header.Magic = m_binaryReader.ReadUInt32 ();
			header.Signature = new Guid (m_binaryReader.ReadBytes (16));
			header.Age = m_binaryReader.ReadUInt32 ();

			StringBuilder buffer = new StringBuilder ();
			while (true) {
				byte cur =  m_binaryReader.ReadByte ();
				if (cur == 0)
					break;
				buffer.Append ((char) cur);
			}
			header.FileName = buffer.ToString ();

			m_binaryReader.BaseStream.Position = pos;
		}

		public override void VisitImportTable (ImportTable it)
		{
			m_binaryReader.BaseStream.Position = m_image.ResolveVirtualAddress (
				m_image.PEOptionalHeader.DataDirectories.ImportTable.VirtualAddress);

			it.ImportLookupTable = new RVA (m_binaryReader.ReadUInt32 ());
			it.DateTimeStamp = m_binaryReader.ReadUInt32 ();
			it.ForwardChain = m_binaryReader.ReadUInt32 ();
			it.Name = new RVA (m_binaryReader.ReadUInt32 ());
			it.ImportAddressTable = new RVA (m_binaryReader.ReadUInt32 ());
		}

		public override void VisitImportLookupTable (ImportLookupTable ilt)
		{
			m_binaryReader.BaseStream.Position = m_image.ResolveVirtualAddress (
				m_image.ImportTable.ImportLookupTable.Value);

			ilt.HintNameRVA = new RVA (m_binaryReader.ReadUInt32 ());
		}

		public override void VisitHintNameTable (HintNameTable hnt)
		{
			m_binaryReader.BaseStream.Position = m_image.ResolveVirtualAddress (
				m_image.ImportAddressTable.HintNameTableRVA);

			hnt.Hint = m_binaryReader.ReadUInt16 ();

			byte [] bytes = m_binaryReader.ReadBytes (11);
			hnt.RuntimeMain = Encoding.ASCII.GetString (bytes, 0, bytes.Length);

			m_binaryReader.BaseStream.Position = m_image.ResolveVirtualAddress (
				m_image.ImportTable.Name);

			bytes = m_binaryReader.ReadBytes (11);
			hnt.RuntimeLibrary = Encoding.ASCII.GetString (bytes, 0, bytes.Length);

			m_binaryReader.BaseStream.Position = m_image.ResolveVirtualAddress (
				m_image.PEOptionalHeader.StandardFields.EntryPointRVA);
			hnt.EntryPoint = m_binaryReader.ReadUInt16 ();
			hnt.RVA = new RVA (m_binaryReader.ReadUInt32 ());
		}

		public override void TerminateImage (Image img)
		{
			m_binaryReader.Close ();

			try {
				ResourceReader resReader = new ResourceReader (img);
				img.ResourceDirectoryRoot = resReader.Read ();
			} catch {
				img.ResourceDirectoryRoot = null;
			}
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Binary/ImageWriter.cs
================================================
//
// ImageWriter.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Binary {

	using System.IO;
	using System.Text;

	using Mono.Cecil.Metadata;

	class ImageWriter : BaseImageVisitor {

		Image m_img;
		AssemblyKind m_kind;
		MetadataWriter m_mdWriter;
		BinaryWriter m_binaryWriter;

		Section m_textSect;
		MemoryBinaryWriter m_textWriter;
		Section m_relocSect;
		MemoryBinaryWriter m_relocWriter;
		Section m_rsrcSect;
		MemoryBinaryWriter m_rsrcWriter;

		public ImageWriter (MetadataWriter writer, AssemblyKind kind, BinaryWriter bw)
		{
			m_mdWriter= writer;
			m_img = writer.GetMetadataRoot ().GetImage ();
			m_kind = kind;
			m_binaryWriter = bw;

			m_textWriter = new MemoryBinaryWriter ();
			m_textWriter.BaseStream.Position = 80;
			m_relocWriter = new MemoryBinaryWriter ();
		}

		public Image GetImage ()
		{
			return m_img;
		}

		public MemoryBinaryWriter GetTextWriter ()
		{
			return m_textWriter;
		}

		public uint GetAligned (uint integer, uint alignWith)
		{
			return (integer + alignWith - 1) & ~(alignWith - 1);
		}

		public void Initialize ()
		{
			Image img = m_img;
			ResourceWriter resWriter = null;

			uint sectAlign = img.PEOptionalHeader.NTSpecificFields.SectionAlignment;
			uint fileAlign = img.PEOptionalHeader.NTSpecificFields.FileAlignment;

			m_textSect = img.TextSection;
			foreach (Section s in img.Sections) {
				if (s.Name == Section.Relocs)
					m_relocSect = s;
				else if (s.Name == Section.Resources) {
					m_rsrcSect = s;
					m_rsrcWriter = new MemoryBinaryWriter ();

					resWriter = new ResourceWriter (img, m_rsrcSect, m_rsrcWriter);
					resWriter.Write ();
				}
			}

			// size computations, fields setting, etc.
			uint nbSects = (uint) img.Sections.Count;
			img.PEFileHeader.NumberOfSections = (ushort) nbSects;

			// build the reloc section data
			uint relocSize = 12;
			m_relocWriter.Write ((uint) 0);
			m_relocWriter.Write (relocSize);
			m_relocWriter.Write ((ushort) 0);
			m_relocWriter.Write ((ushort) 0);

			m_textSect.VirtualSize = (uint) m_textWriter.BaseStream.Length;
			m_relocSect.VirtualSize = (uint) m_relocWriter.BaseStream.Length;
			if (m_rsrcSect != null)
				m_rsrcSect.VirtualSize = (uint) m_rsrcWriter.BaseStream.Length;

			// start counting before sections headers
			// section start + section header sixe * number of sections
			uint headersEnd = 0x178 + 0x28 * nbSects;
			uint fileOffset = headersEnd;
			uint sectOffset = sectAlign;
			uint imageSize = 0;

			foreach (Section sect in img.Sections) {
				fileOffset = GetAligned (fileOffset, fileAlign);
				sectOffset = GetAligned (sectOffset, sectAlign);

				sect.PointerToRawData = new RVA (fileOffset);
				sect.VirtualAddress = new RVA (sectOffset);
				sect.SizeOfRawData = GetAligned (sect.VirtualSize, fileAlign);

				fileOffset += sect.SizeOfRawData;
				sectOffset += sect.SizeOfRawData;
				imageSize += GetAligned (sect.SizeOfRawData, sectAlign);
			}

			if (m_textSect.VirtualAddress.Value != 0x2000)
				throw new ImageFormatException ("Wrong RVA for .text section");

			if (resWriter != null)
				resWriter.Patch ();

			img.PEOptionalHeader.StandardFields.CodeSize = GetAligned (
				m_textSect.SizeOfRawData, fileAlign);
			img.PEOptionalHeader.StandardFields.InitializedDataSize = m_textSect.SizeOfRawData;
			if (m_rsrcSect != null)
				img.PEOptionalHeader.StandardFields.InitializedDataSize += m_rsrcSect.SizeOfRawData;
			img.PEOptionalHeader.StandardFields.BaseOfCode = m_textSect.VirtualAddress;
			img.PEOptionalHeader.StandardFields.BaseOfData = m_relocSect.VirtualAddress;

			imageSize += headersEnd;
			img.PEOptionalHeader.NTSpecificFields.ImageSize = GetAligned (imageSize, sectAlign);

			img.PEOptionalHeader.DataDirectories.BaseRelocationTable = new DataDirectory (
				m_relocSect.VirtualAddress, m_relocSect.VirtualSize);
			if (m_rsrcSect != null)
				img.PEOptionalHeader.DataDirectories.ResourceTable = new DataDirectory (
					m_rsrcSect.VirtualAddress, (uint) m_rsrcWriter.BaseStream.Length);

			if (m_kind == AssemblyKind.Dll) {
				img.PEFileHeader.Characteristics = ImageCharacteristics.CILOnlyDll;
				img.HintNameTable.RuntimeMain = HintNameTable.RuntimeMainDll;
				img.PEOptionalHeader.NTSpecificFields.DLLFlags = 0x400;
			} else {
				img.PEFileHeader.Characteristics = ImageCharacteristics.CILOnlyExe;
				img.HintNameTable.RuntimeMain = HintNameTable.RuntimeMainExe;
			}

			switch (m_kind) {
			case AssemblyKind.Dll :
			case AssemblyKind.Console :
				img.PEOptionalHeader.NTSpecificFields.SubSystem = SubSystem.WindowsCui;
				break;
			case AssemblyKind.Windows :
				img.PEOptionalHeader.NTSpecificFields.SubSystem = SubSystem.WindowsGui;
				break;
			}

			RVA importTable = new RVA (img.TextSection.VirtualAddress + m_mdWriter.ImportTablePosition);

			img.PEOptionalHeader.DataDirectories.ImportTable = new DataDirectory (importTable, 0x57);

			img.ImportTable.ImportLookupTable = new RVA ((uint) importTable + 0x28);

			img.ImportLookupTable.HintNameRVA = img.ImportAddressTable.HintNameTableRVA =
				new RVA ((uint) img.ImportTable.ImportLookupTable + 0x14);
			img.ImportTable.Name = new RVA ((uint) img.ImportLookupTable.HintNameRVA + 0xe);
		}

		public override void VisitDOSHeader (DOSHeader header)
		{
			m_binaryWriter.Write (header.Start);
			m_binaryWriter.Write (header.Lfanew);
			m_binaryWriter.Write (header.End);

			m_binaryWriter.Write ((ushort) 0x4550);
			m_binaryWriter.Write ((ushort) 0);
		}

		public override void VisitPEFileHeader (PEFileHeader header)
		{
			m_binaryWriter.Write (header.Machine);
			m_binaryWriter.Write (header.NumberOfSections);
			m_binaryWriter.Write (header.TimeDateStamp);
			m_binaryWriter.Write (header.PointerToSymbolTable);
			m_binaryWriter.Write (header.NumberOfSymbols);
			m_binaryWriter.Write (header.OptionalHeaderSize);
			m_binaryWriter.Write ((ushort) header.Characteristics);
		}

		public override void VisitNTSpecificFieldsHeader (PEOptionalHeader.NTSpecificFieldsHeader header)
		{
			WriteIntOrLong (header.ImageBase);
			m_binaryWriter.Write (header.SectionAlignment);
			m_binaryWriter.Write (header.FileAlignment);
			m_binaryWriter.Write (header.OSMajor);
			m_binaryWriter.Write (header.OSMinor);
			m_binaryWriter.Write (header.UserMajor);
			m_binaryWriter.Write (header.UserMinor);
			m_binaryWriter.Write (header.SubSysMajor);
			m_binaryWriter.Write (header.SubSysMinor);
			m_binaryWriter.Write (header.Reserved);
			m_binaryWriter.Write (header.ImageSize);
			m_binaryWriter.Write (header.HeaderSize);
			m_binaryWriter.Write (header.FileChecksum);
			m_binaryWriter.Write ((ushort) header.SubSystem);
			m_binaryWriter.Write (header.DLLFlags);
			WriteIntOrLong (header.StackReserveSize);
			WriteIntOrLong (header.StackCommitSize);
			WriteIntOrLong (header.HeapReserveSize);
			WriteIntOrLong (header.HeapCommitSize);
			m_binaryWriter.Write (header.LoaderFlags);
			m_binaryWriter.Write (header.NumberOfDataDir);
		}

		public override void VisitStandardFieldsHeader (PEOptionalHeader.StandardFieldsHeader header)
		{
			m_binaryWriter.Write (header.Magic);
			m_binaryWriter.Write (header.LMajor);
			m_binaryWriter.Write (header.LMinor);
			m_binaryWriter.Write (header.CodeSize);
			m_binaryWriter.Write (header.InitializedDataSize);
			m_binaryWriter.Write (header.UninitializedDataSize);
			m_binaryWriter.Write (header.EntryPointRVA.Value);
			m_binaryWriter.Write (header.BaseOfCode.Value);
			if (!header.IsPE64)
				m_binaryWriter.Write (header.BaseOfData.Value);
		}

		void WriteIntOrLong (ulong value)
		{
			if (m_img.PEOptionalHeader.StandardFields.IsPE64)
				m_binaryWriter.Write (value);
			else
				m_binaryWriter.Write ((uint) value);
		}

		public override void VisitDataDirectoriesHeader (PEOptionalHeader.DataDirectoriesHeader header)
		{
			m_binaryWriter.Write (header.ExportTable.VirtualAddress);
			m_binaryWriter.Write (header.ExportTable.Size);
			m_binaryWriter.Write (header.ImportTable.VirtualAddress);
			m_binaryWriter.Write (header.ImportTable.Size);
			m_binaryWriter.Write (header.ResourceTable.VirtualAddress);
			m_binaryWriter.Write (header.ResourceTable.Size);
			m_binaryWriter.Write (header.ExceptionTable.VirtualAddress);
			m_binaryWriter.Write (header.ExceptionTable.Size);
			m_binaryWriter.Write (header.CertificateTable.VirtualAddress);
			m_binaryWriter.Write (header.CertificateTable.Size);
			m_binaryWriter.Write (header.BaseRelocationTable.VirtualAddress);
			m_binaryWriter.Write (header.BaseRelocationTable.Size);
			m_binaryWriter.Write (header.Debug.VirtualAddress);
			m_binaryWriter.Write (header.Debug.Size);
			m_binaryWriter.Write (header.Copyright.VirtualAddress);
			m_binaryWriter.Write (header.Copyright.Size);
			m_binaryWriter.Write (header.GlobalPtr.VirtualAddress);
			m_binaryWriter.Write (header.GlobalPtr.Size);
			m_binaryWriter.Write (header.TLSTable.VirtualAddress);
			m_binaryWriter.Write (header.TLSTable.Size);
			m_binaryWriter.Write (header.LoadConfigTable.VirtualAddress);
			m_binaryWriter.Write (header.LoadConfigTable.Size);
			m_binaryWriter.Write (header.BoundImport.VirtualAddress);
			m_binaryWriter.Write (header.BoundImport.Size);
			m_binaryWriter.Write (header.IAT.VirtualAddress);
			m_binaryWriter.Write (header.IAT.Size);
			m_binaryWriter.Write (header.DelayImportDescriptor.VirtualAddress);
			m_binaryWriter.Write (header.DelayImportDescriptor.Size);
			m_binaryWriter.Write (header.CLIHeader.VirtualAddress);
			m_binaryWriter.Write (header.CLIHeader.Size);
			m_binaryWriter.Write (header.Reserved.VirtualAddress);
			m_binaryWriter.Write (header.Reserved.Size);
		}

		public override void VisitSection (Section sect)
		{
			m_binaryWriter.Write (Encoding.ASCII.GetBytes (sect.Name));
			int more = 8 - sect.Name.Length;
			for (int i = 0; i < more; i++)
				m_binaryWriter.Write ((byte) 0);

			m_binaryWriter.Write (sect.VirtualSize);
			m_binaryWriter.Write (sect.VirtualAddress.Value);
			m_binaryWriter.Write (sect.SizeOfRawData);
			m_binaryWriter.Write (sect.PointerToRawData.Value);
			m_binaryWriter.Write (sect.PointerToRelocations.Value);
			m_binaryWriter.Write (sect.PointerToLineNumbers.Value);
			m_binaryWriter.Write (sect.NumberOfRelocations);
			m_binaryWriter.Write (sect.NumberOfLineNumbers);
			m_binaryWriter.Write ((uint) sect.Characteristics);
		}

		public override void VisitImportAddressTable (ImportAddressTable iat)
		{
			m_textWriter.BaseStream.Position = 0;
			m_textWriter.Write (iat.HintNameTableRVA.Value);
			m_textWriter.Write (new byte [4]);
		}

		public override void VisitCLIHeader (CLIHeader header)
		{
			m_textWriter.Write (header.Cb);
			m_textWriter.Write (header.MajorRuntimeVersion);
			m_textWriter.Write (header.MinorRuntimeVersion);
			m_textWriter.Write (header.Metadata.VirtualAddress);
			m_textWriter.Write (header.Metadata.Size);
			m_textWriter.Write ((uint) header.Flags);
			m_textWriter.Write (header.EntryPointToken);
			m_textWriter.Write (header.Resources.VirtualAddress);
			m_textWriter.Write (header.Resources.Size);
			m_textWriter.Write (header.StrongNameSignature.VirtualAddress);
			m_textWriter.Write (header.StrongNameSignature.Size);
			m_textWriter.Write (header.CodeManagerTable.VirtualAddress);
			m_textWriter.Write (header.CodeManagerTable.Size);
			m_textWriter.Write (header.VTableFixups.VirtualAddress);
			m_textWriter.Write (header.VTableFixups.Size);
			m_textWriter.Write (header.ExportAddressTableJumps.VirtualAddress);
			m_textWriter.Write (header.ExportAddressTableJumps.Size);
			m_textWriter.Write (header.ManagedNativeHeader.VirtualAddress);
			m_textWriter.Write (header.ManagedNativeHeader.Size);
		}

		public override void VisitDebugHeader (DebugHeader header)
		{
			m_textWriter.BaseStream.Position = m_mdWriter.DebugHeaderPosition;
			uint sizeUntilData = 0x1c;
			header.AddressOfRawData = m_img.TextSection.VirtualAddress + m_mdWriter.DebugHeaderPosition + sizeUntilData;
			header.PointerToRawData = 0x200 + m_mdWriter.DebugHeaderPosition + sizeUntilData;
			header.SizeOfData = 0x18 + (uint) header.FileName.Length + 1;

			m_textWriter.Write (header.Characteristics);
			m_textWriter.Write (header.TimeDateStamp);
			m_textWriter.Write (header.MajorVersion);
			m_textWriter.Write (header.MinorVersion);
			m_textWriter.Write ((uint) header.Type);
			m_textWriter.Write (header.SizeOfData);
			m_textWriter.Write (header.AddressOfRawData.Value);
			m_textWriter.Write (header.PointerToRawData);

			m_textWriter.Write (header.Magic);
			m_textWriter.Write (header.Signature.ToByteArray ());
			m_textWriter.Write (header.Age);
			m_textWriter.Write (Encoding.ASCII.GetBytes (header.FileName));
			m_textWriter.Write ((byte) 0);
		}

		public override void VisitImportTable (ImportTable it)
		{
			m_textWriter.BaseStream.Position = m_mdWriter.ImportTablePosition;
			m_textWriter.Write (it.ImportLookupTable.Value);
			m_textWriter.Write (it.DateTimeStamp);
			m_textWriter.Write (it.ForwardChain);
			m_textWriter.Write (it.Name.Value);
			m_textWriter.Write (it.ImportAddressTable.Value);
			m_textWriter.Write (new byte [20]);
		}

		public override void VisitImportLookupTable (ImportLookupTable ilt)
		{
			m_textWriter.Write (ilt.HintNameRVA.Value);
			m_textWriter.Write (new byte [16]);
		}

		public override void VisitHintNameTable (HintNameTable hnt)
		{
			m_textWriter.Write (hnt.Hint);
			m_textWriter.Write (Encoding.ASCII.GetBytes (hnt.RuntimeMain));
			m_textWriter.Write ('\0');
			m_textWriter.Write (Encoding.ASCII.GetBytes (hnt.RuntimeLibrary));
			m_textWriter.Write ('\0');
			m_textWriter.Write (new byte [4]);

			// patch header with ep rva
			RVA ep = m_img.TextSection.VirtualAddress +
				(uint) m_textWriter.BaseStream.Position;
			long pos = m_binaryWriter.BaseStream.Position;
			m_binaryWriter.BaseStream.Position = 0xa8;
			m_binaryWriter.Write (ep.Value);
			m_binaryWriter.BaseStream.Position = pos;

			// patch reloc Sect with ep
			uint reloc = (ep.Value + 2) % 0x1000;
			uint rva = (ep.Value + 2) - reloc;

			m_relocWriter.BaseStream.Position = 0;
			m_relocWriter.Write (rva);
			m_relocWriter.BaseStream.Position = 8;
			m_relocWriter.Write ((ushort) ((3 << 12) | reloc));

			m_textWriter.Write (hnt.EntryPoint);
			m_textWriter.Write (hnt.RVA);
		}

		public override void TerminateImage (Image img)
		{
			m_binaryWriter.BaseStream.Position = 0x200;

			WriteSection (m_textSect, m_textWriter);
			WriteSection (m_relocSect, m_relocWriter);
			if (m_rsrcSect != null)
				WriteSection (m_rsrcSect, m_rsrcWriter);
		}

		void WriteSection (Section sect, MemoryBinaryWriter sectWriter)
		{
			sectWriter.MemoryStream.WriteTo (m_binaryWriter.BaseStream);
			m_binaryWriter.Write (new byte [
			                      	sect.SizeOfRawData - sectWriter.BaseStream.Length]);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Binary/Imports.cs
================================================
//
// Imports.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Binary {

	public sealed class ImportAddressTable : IBinaryVisitable {

		public RVA HintNameTableRVA;

		internal ImportAddressTable ()
		{
		}

		public void Accept (IBinaryVisitor visitor)
		{
			visitor.VisitImportAddressTable (this);
		}
	}

	public sealed class ImportTable : IBinaryVisitable {

		public RVA ImportLookupTable;
		public uint DateTimeStamp;
		public uint ForwardChain;
		public RVA Name;
		public RVA ImportAddressTable;

		internal ImportTable ()
		{
		}

		public void Accept (IBinaryVisitor visitor)
		{
			visitor.VisitImportTable (this);
		}
	}

	public sealed class ImportLookupTable : IBinaryVisitable {

		public RVA HintNameRVA;

		internal ImportLookupTable ()
		{
		}

		public void Accept (IBinaryVisitor visitor)
		{
			visitor.VisitImportLookupTable (this);
		}
	}

	public sealed class HintNameTable : IBinaryVisitable {

		public const string RuntimeMainExe = "_CorExeMain";
		public const string RuntimeMainDll = "_CorDllMain";
		public const string RuntimeCorEE = "mscoree.dll";

		public ushort Hint;
		public string RuntimeMain;
		public string RuntimeLibrary;
		public ushort EntryPoint;
		public RVA RVA;

		internal HintNameTable ()
		{
		}

		public void Accept (IBinaryVisitor visitor)
		{
			visitor.VisitHintNameTable (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Binary/MemoryBinaryWriter.cs
================================================
//
// MemoryBinaryWriter.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Binary {

	using System.IO;
	using System.Text;

	internal sealed class MemoryBinaryWriter : BinaryWriter {

		public MemoryStream MemoryStream {
			get { return (MemoryStream) this.BaseStream; }
		}

		public MemoryBinaryWriter () : base (new MemoryStream ())
		{
		}

		public MemoryBinaryWriter (Encoding enc) : base (new MemoryStream (), enc)
		{
		}

		public void Empty ()
		{
			this.BaseStream.Position = 0;
			this.BaseStream.SetLength (0);
		}

		public void Write (MemoryBinaryWriter writer)
		{
			writer.MemoryStream.WriteTo (this.BaseStream);
		}

		public byte [] ToArray ()
		{
			return this.MemoryStream.ToArray ();
		}

		public void QuadAlign ()
		{
			this.BaseStream.Position += 3;
			this.BaseStream.Position &= ~3;
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Binary/PEFileHeader.cs
================================================
//
// PEFileHeader.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Binary {

	public sealed class PEFileHeader : IHeader, IBinaryVisitable {

		public ushort Machine;
		public ushort NumberOfSections;
		public uint TimeDateStamp;
		public uint PointerToSymbolTable;
		public uint NumberOfSymbols;
		public ushort OptionalHeaderSize;
		public ImageCharacteristics Characteristics;

		internal PEFileHeader ()
		{
		}

		public void SetDefaultValues ()
		{
			Machine = 0x14c;
			PointerToSymbolTable = 0;
			NumberOfSymbols = 0;
			OptionalHeaderSize = 0xe0;
		}

		public void Accept (IBinaryVisitor visitor)
		{
			visitor.VisitPEFileHeader (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Binary/PEOptionalHeader.cs
================================================
//
// PEOptionalHeader.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Binary {

	public sealed class PEOptionalHeader : IHeader, IBinaryVisitable {

		public StandardFieldsHeader StandardFields;
		public NTSpecificFieldsHeader NTSpecificFields;
		public DataDirectoriesHeader DataDirectories;

		internal PEOptionalHeader ()
		{
			StandardFields = new StandardFieldsHeader ();
			NTSpecificFields = new NTSpecificFieldsHeader ();
			DataDirectories = new DataDirectoriesHeader ();
		}

		public void SetDefaultValues ()
		{
		}

		public void Accept (IBinaryVisitor visitor)
		{
			visitor.VisitPEOptionalHeader (this);

			StandardFields.Accept (visitor);
			NTSpecificFields.Accept (visitor);
			DataDirectories.Accept (visitor);
		}

		public sealed class StandardFieldsHeader : IHeader, IBinaryVisitable {

			public ushort Magic;
			public byte LMajor;
			public byte LMinor;
			public uint CodeSize;
			public uint InitializedDataSize;
			public uint UninitializedDataSize;
			public RVA EntryPointRVA;
			public RVA BaseOfCode;
			public RVA BaseOfData;

			public bool IsPE64 {
				get { return Magic == 0x20b; }
				set {
					if (value)
						Magic = 0x20b;
					else
						Magic = 0x10b;
				}
			}

			internal StandardFieldsHeader ()
			{
			}

			public void SetDefaultValues ()
			{
				Magic = 0x10b;
				LMajor = 6;
				LMinor = 0;
			}

			public void Accept (IBinaryVisitor visitor)
			{
				visitor.VisitStandardFieldsHeader (this);
			}
		}

		public sealed class NTSpecificFieldsHeader : IHeader, IBinaryVisitable {

			public ulong ImageBase;
			public uint SectionAlignment;
			public uint FileAlignment;
			public ushort OSMajor;
			public ushort OSMinor;
			public ushort UserMajor;
			public ushort UserMinor;
			public ushort SubSysMajor;
			public ushort SubSysMinor;
			public uint Reserved;
			public uint ImageSize;
			public uint HeaderSize;
			public uint FileChecksum;
			public SubSystem SubSystem;
			public ushort DLLFlags;
			public ulong StackReserveSize;
			public ulong StackCommitSize;
			public ulong HeapReserveSize;
			public ulong HeapCommitSize;
			public uint LoaderFlags;
			public uint NumberOfDataDir;

			internal NTSpecificFieldsHeader ()
			{
			}

			public void SetDefaultValues ()
			{
				ImageBase = 0x400000;
				SectionAlignment = 0x2000;
				FileAlignment = 0x200;
				OSMajor = 4;
				OSMinor = 0;
				UserMajor = 0;
				UserMinor = 0;
				SubSysMajor = 4;
				SubSysMinor = 0;
				Reserved = 0;
				HeaderSize = 0x200;
				FileChecksum = 0;
				DLLFlags = 0;
				StackReserveSize = 0x100000;
				StackCommitSize = 0x1000;
				HeapReserveSize = 0x100000;
				HeapCommitSize = 0x1000;
				LoaderFlags = 0;
				NumberOfDataDir = 0x10;
			}

			public void Accept (IBinaryVisitor visitor)
			{
				visitor.VisitNTSpecificFieldsHeader (this);
			}
		}

		public sealed class DataDirectoriesHeader : IHeader, IBinaryVisitable {

			public DataDirectory ExportTable;
			public DataDirectory ImportTable;
			public DataDirectory ResourceTable;
			public DataDirectory ExceptionTable;
			public DataDirectory CertificateTable;
			public DataDirectory BaseRelocationTable;
			public DataDirectory Debug;
			public DataDirectory Copyright;
			public DataDirectory GlobalPtr;
			public DataDirectory TLSTable;
			public DataDirectory LoadConfigTable;
			public DataDirectory BoundImport;
			public DataDirectory IAT;
			public DataDirectory DelayImportDescriptor;
			public DataDirectory CLIHeader;
			public DataDirectory Reserved;

			internal DataDirectoriesHeader ()
			{
			}

			public void SetDefaultValues ()
			{
				ExportTable = DataDirectory.Zero;
				ResourceTable = DataDirectory.Zero;
				ExceptionTable = DataDirectory.Zero;
				CertificateTable = DataDirectory.Zero;
				Debug = DataDirectory.Zero;
				Copyright = DataDirectory.Zero;
				GlobalPtr = DataDirectory.Zero;
				TLSTable = DataDirectory.Zero;
				LoadConfigTable = DataDirectory.Zero;
				BoundImport = DataDirectory.Zero;
				IAT = new DataDirectory (new RVA (0x2000), 8);
				DelayImportDescriptor = DataDirectory.Zero;
				CLIHeader = new DataDirectory (new RVA (0x2008), 0x48);
				Reserved = DataDirectory.Zero;
			}

			public void Accept (IBinaryVisitor visitor)
			{
				visitor.VisitDataDirectoriesHeader (this);
			}
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Binary/RVA.cs
================================================
//
// RVA.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Binary {

	public struct RVA {

		public static readonly RVA Zero = new RVA (0);

		uint m_rva;

		public uint Value {
			get { return m_rva; }
			set { m_rva = value; }
		}

		public RVA (uint rva)
		{
			m_rva = rva;
		}

		public override int GetHashCode ()
		{
			return (int) m_rva;
		}

		public override bool Equals (object other)
		{
			if (other is RVA)
				return this.m_rva == ((RVA) other).m_rva;

			return false;
		}

		public override string ToString ()
		{
			return string.Format ("0x{0}", m_rva.ToString ("X"));
		}

		public static bool operator == (RVA one, RVA other)
		{
			return one.Equals (other);
		}

		public static bool operator != (RVA one, RVA other)
		{
			return !one.Equals (other);
		}

		public static bool operator < (RVA one, RVA other)
		{
			return one.m_rva < other.m_rva;
		}

		public static bool operator > (RVA one, RVA other)
		{
			return one.m_rva > other.m_rva;
		}

		public static bool operator <= (RVA one, RVA other)
		{
			return one.m_rva <= other.m_rva;
		}

		public static bool operator >= (RVA one, RVA other)
		{
			return one.m_rva >= other.m_rva;
		}

		public static RVA operator + (RVA rva, uint x)
		{
			return new RVA (rva.m_rva + x);
		}

		public static RVA operator - (RVA rva, uint x)
		{
			return new RVA (rva.m_rva - x);
		}

		public static implicit operator RVA (uint val)
		{
			return val == 0 ? RVA.Zero : new RVA (val);
		}

		public static implicit operator uint (RVA rva)
		{
			return rva.m_rva;
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Binary/ResourceDataEntry.cs
================================================
//
// ResourceDataEntry.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2006 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Binary {

	public class ResourceDataEntry : ResourceNode {

		public RVA Data;
		public uint Size;
		public uint Codepage;
		public uint Reserved = 0;

		public byte [] ResourceData;

		public ResourceDataEntry (int offset) : base (offset)
		{
		}

		public ResourceDataEntry ()
		{
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Binary/ResourceDirectoryEntry.cs
================================================
//
// ResourceDirectoryEntry.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2006 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Binary {

	public class ResourceDirectoryEntry : ResourceNode {

		private bool m_idByName;

		public int ID;
		public ResourceDirectoryString Name;

		public bool IdentifiedByName {
			get { return m_idByName; }
		}

		public ResourceNode Child;

		public ResourceDirectoryEntry (ResourceDirectoryString name)
		{
			this.Name = name;
			m_idByName = true;
		}

		public ResourceDirectoryEntry (ResourceDirectoryString name, int offset) : base (offset)
		{
			this.Name = name;
			m_idByName = true;
		}

		public ResourceDirectoryEntry (int id)
		{
			this.ID = id;
		}

		public ResourceDirectoryEntry (int id, int offset) : base (offset)
		{
			this.ID = id;
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Binary/ResourceDirectoryString.cs
================================================
//
// ResourceDirectoryString.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2006 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Binary {

	public class ResourceDirectoryString : ResourceNode {

		public string String;

		public ResourceDirectoryString (string str)
		{
			this.String = str;
		}

		public ResourceDirectoryString (string str, int offset) : base (offset)
		{
			this.String = str;
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Binary/ResourceDirectoryTable.cs
================================================
//
// ResourceDirectoryTable.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2006 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Binary {

	using System.Collections;

	public class ResourceDirectoryTable : ResourceNode {

		private ArrayList m_entries;

		public uint Characteristics;
		public uint TimeDateStamp;
		public ushort MajorVersion;
		public ushort MinorVersion;

		public IList Entries {
			get { return m_entries; }
		}

		public ResourceDirectoryTable (int offset) : base (offset)
		{
			m_entries = new ArrayList ();
		}

		public ResourceDirectoryTable ()
		{
			m_entries = new ArrayList ();
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Binary/ResourceNode.cs
================================================
//
// ResourceNode.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2006 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Binary {

	public abstract class ResourceNode {

		public int Offset;

		internal ResourceNode (int offset)
		{
			this.Offset = offset;
		}

		internal ResourceNode ()
		{
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Binary/ResourceReader.cs
================================================
//
// ResourceReader.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2006 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Binary {

	using System.IO;
	using System.Text;

	class ResourceReader {

		Image m_img;
		Section m_rsrc;
		BinaryReader m_reader;

		public ResourceReader (Image img)
		{
			m_img = img;
		}

		public ResourceDirectoryTable Read ()
		{
			m_rsrc = GetResourceSection ();
			if (m_rsrc == null)
				return null;

			m_reader = new BinaryReader (new MemoryStream (m_rsrc.Data));
			return ReadDirectoryTable ();
		}

		Section GetResourceSection ()
		{
			foreach (Section s in m_img.Sections)
				if (s.Name == Section.Resources)
					return s;

			return null;
		}

		int GetOffset ()
		{
			return (int) m_reader.BaseStream.Position;
		}

		ResourceDirectoryTable ReadDirectoryTable ()
		{
			ResourceDirectoryTable rdt = new ResourceDirectoryTable (GetOffset ());
			rdt.Characteristics = m_reader.ReadUInt32 ();
			rdt.TimeDateStamp = m_reader.ReadUInt32 ();
			rdt.MajorVersion = m_reader.ReadUInt16 ();
			rdt.MinorVersion = m_reader.ReadUInt16 ();
			ushort nameEntries = m_reader.ReadUInt16 ();
			ushort idEntries = m_reader.ReadUInt16 ();

			for (int i = 0; i < nameEntries; i++)
				rdt.Entries.Add (ReadDirectoryEntry ());

			for (int i = 0; i < idEntries; i++)
				rdt.Entries.Add (ReadDirectoryEntry ());

			return rdt;
		}

		ResourceDirectoryEntry ReadDirectoryEntry ()
		{
			uint name = m_reader.ReadUInt32 ();
			uint child = m_reader.ReadUInt32 ();

			ResourceDirectoryEntry rde;
			if ((name & 0x80000000) != 0)
				rde = new ResourceDirectoryEntry (ReadDirectoryString ((int) name & 0x7fffffff), GetOffset ());
			else
				rde = new ResourceDirectoryEntry ((int) name & 0x7fffffff, GetOffset ());

			long pos = m_reader.BaseStream.Position;
			m_reader.BaseStream.Position = child & 0x7fffffff;

			if ((child & 0x80000000) != 0)
				rde.Child = ReadDirectoryTable ();
			else
				rde.Child = ReadDataEntry ();

			m_reader.BaseStream.Position = pos;

			return rde;
		}

		ResourceDirectoryString ReadDirectoryString (int offset)
		{
			long pos = m_reader.BaseStream.Position;
			m_reader.BaseStream.Position = offset;

			byte [] str = m_reader.ReadBytes (m_reader.ReadUInt16 ());

			ResourceDirectoryString rds = new ResourceDirectoryString (
				Encoding.Unicode.GetString (str, 0, str.Length),
				GetOffset ());

			m_reader.BaseStream.Position = pos;

			return rds;
		}

		ResourceNode ReadDataEntry ()
		{
			ResourceDataEntry rde = new ResourceDataEntry (GetOffset ());
			rde.Data = m_reader.ReadUInt32 ();
			rde.Size = m_reader.ReadUInt32 ();
			rde.Codepage = m_reader.ReadUInt32 ();
			rde.Reserved = m_reader.ReadUInt32 ();

			BinaryReader dataReader = m_img.GetReaderAtVirtualAddress (rde.Data);
			rde.ResourceData = dataReader.ReadBytes ((int) rde.Size);
			dataReader.Close ();

			return rde;
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Binary/ResourceWriter.cs
================================================
//
// ResourceWriter.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2006 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

using System.Text;

namespace Mono.Cecil.Binary {

	using System.Collections;

	class ResourceWriter {

		Image m_img;
		Section m_rsrc;
		MemoryBinaryWriter m_writer;

		ArrayList m_dataEntries;
		ArrayList m_stringEntries;

		long m_pos;

		public ResourceWriter (Image img, Section rsrc, MemoryBinaryWriter writer)
		{
			m_img = img;
			m_rsrc = rsrc;
			m_writer = writer;

			m_dataEntries = new ArrayList ();
			m_stringEntries = new ArrayList ();
		}

		public void Write ()
		{
			if (m_img.ResourceDirectoryRoot == null)
				return;

			ComputeOffset (m_img.ResourceDirectoryRoot);
			WriteResourceDirectoryTable (m_img.ResourceDirectoryRoot);
		}

		public void Patch ()
		{
			foreach (ResourceDataEntry rde in m_dataEntries) {
				GotoOffset (rde.Offset);
				m_writer.Write ((uint) rde.Data + m_rsrc.VirtualAddress);
				RestoreOffset ();
			}
		}

		void ComputeOffset (ResourceDirectoryTable root)
		{
			int offset = 0;

			Queue directoryTables = new Queue ();
			directoryTables.Enqueue (root);

			while (directoryTables.Count > 0) {
				ResourceDirectoryTable rdt = directoryTables.Dequeue () as ResourceDirectoryTable;
				rdt.Offset = offset;
				offset += 16;

				foreach (ResourceDirectoryEntry rde in rdt.Entries) {
					rde.Offset = offset;
					offset += 8;
					if (rde.IdentifiedByName)
						m_stringEntries.Add (rde.Name);

					if (rde.Child is ResourceDirectoryTable)
						directoryTables.Enqueue (rde.Child);
					else
						m_dataEntries.Add (rde.Child);
				}
			}

			foreach (ResourceDataEntry rde in m_dataEntries) {
				rde.Offset = offset;
				offset += 16;
			}

			foreach (ResourceDirectoryString rds in m_stringEntries) {
				rds.Offset = offset;
				byte [] str = Encoding.Unicode.GetBytes (rds.String);
				offset += 2 + str.Length;

				offset += 3;
				offset &= ~3;
			}

			foreach (ResourceDataEntry rde in m_dataEntries) {
				rde.Data = (uint) offset;

				offset += rde.ResourceData.Length;
				offset += 3;
				offset &= ~3;
			}

			m_writer.Write (new byte [offset]);
		}

		void WriteResourceDirectoryTable (ResourceDirectoryTable rdt)
		{
			GotoOffset (rdt.Offset);

			m_writer.Write (rdt.Characteristics);
			m_writer.Write (rdt.TimeDateStamp);
			m_writer.Write (rdt.MajorVersion);
			m_writer.Write (rdt.MinorVersion);

			ResourceDirectoryEntry [] namedEntries = GetEntries (rdt, true);
			ResourceDirectoryEntry [] idEntries = GetEntries (rdt, false);

			m_writer.Write ((ushort) namedEntries.Length);
			m_writer.Write ((ushort) idEntries.Length);

			foreach (ResourceDirectoryEntry rde in namedEntries)
				WriteResourceDirectoryEntry (rde);

			foreach (ResourceDirectoryEntry rde in idEntries)
				WriteResourceDirectoryEntry (rde);

			RestoreOffset ();
		}

		ResourceDirectoryEntry [] GetEntries (ResourceDirectoryTable rdt, bool identifiedByName)
		{
			ArrayList entries = new ArrayList ();
			foreach (ResourceDirectoryEntry rde in rdt.Entries)
				if (rde.IdentifiedByName == identifiedByName)
					entries.Add (rde);

			return entries.ToArray (typeof (ResourceDirectoryEntry)) as ResourceDirectoryEntry [];
		}

		void WriteResourceDirectoryEntry (ResourceDirectoryEntry rde)
		{
			GotoOffset (rde.Offset);

			if (rde.IdentifiedByName) {
				m_writer.Write ((uint) rde.Name.Offset | 0x80000000);
				WriteResourceDirectoryString (rde.Name);
			} else
				m_writer.Write ((uint) rde.ID);

			if (rde.Child is ResourceDirectoryTable) {
				m_writer.Write((uint) rde.Child.Offset | 0x80000000);
				WriteResourceDirectoryTable (rde.Child as ResourceDirectoryTable);
			} else {
				m_writer.Write (rde.Child.Offset);
				WriteResourceDataEntry (rde.Child as ResourceDataEntry);
			}

			RestoreOffset ();
		}

		void WriteResourceDataEntry (ResourceDataEntry rde)
		{
			GotoOffset (rde.Offset);

			m_writer.Write (0);
			m_writer.Write ((uint) rde.ResourceData.Length);
			m_writer.Write (rde.Codepage);
			m_writer.Write (rde.Reserved);

			m_writer.BaseStream.Position = rde.Data;
			m_writer.Write (rde.ResourceData);

			RestoreOffset ();
		}

		void WriteResourceDirectoryString (ResourceDirectoryString name)
		{
			GotoOffset (name.Offset);

			byte [] str = Encoding.Unicode.GetBytes (name.String);
			m_writer.Write ((ushort) str.Length);
			m_writer.Write (str);

			RestoreOffset ();
		}

		void GotoOffset (int offset)
		{
			m_pos = m_writer.BaseStream.Position;
			m_writer.BaseStream.Position = offset;
		}

		void RestoreOffset ()
		{
			m_writer.BaseStream.Position = m_pos;
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Binary/RuntimeImage.cs
================================================
//
// RuntimeImage.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Binary {

	public enum RuntimeImage : uint {
		ILOnly = 0x0000001,
		F32BitsRequired = 0x0000002,
		StrongNameSigned = 0x0000008,
		TrackDebugData = 0x00010000
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Binary/Section.cs
================================================
//
// Section.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Binary {

	public sealed class Section : IHeader, IBinaryVisitable {

		public const string Text = ".text";
		public const string Resources = ".rsrc";
		public const string Relocs = ".reloc";
		public const string SData = ".sdata";

		public uint VirtualSize;
		public RVA VirtualAddress;
		public uint SizeOfRawData;
		public RVA PointerToRawData;
		public RVA PointerToRelocations;
		public RVA PointerToLineNumbers;
		public ushort NumberOfRelocations;
		public ushort NumberOfLineNumbers;
		public SectionCharacteristics Characteristics;

		public string Name;
		public byte [] Data;

		internal Section ()
		{
		}

		public void SetDefaultValues ()
		{
			PointerToLineNumbers = RVA.Zero;
			NumberOfLineNumbers = 0;
		}

		public void Accept (IBinaryVisitor visitor)
		{
			visitor.VisitSection (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Binary/SectionCharacteristics.cs
================================================
//
// SectionCharacteristics.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Binary {

	using System;

	[Flags]
	public enum SectionCharacteristics : uint {
		TypeNoPad = 0x0000008,
		ContainsCode = 0x00000020,
		ContainsInitializedData = 0x00000040,
		ContainsUninitializedData = 0x00000080,
		LnkOther = 0x0000100,
		LnkInfo = 0x000200,
		LnkRemove = 0x0000800,
		LnkCOMDAT = 0x00001000,
		GPRel = 0x00008000,
		MemPurgeable = 0x00020000,
		MemLocked = 0x00040000,
		MemPreload = 0x00080000,
		Align1Bytes = 0x00100000,
		Align2Bytes = 0x00200000,
		Align4Bytes = 0x00300000,
		Align8Bytes = 0x00400000,
		Align16Bytes = 0x00500000,
		Align32Bytes = 0x00600000,
		Align64Bytes = 0x00700000,
		Align128Bytes = 0x00800000,
		Align256Bytes = 0x00900000,
		Align512Bytes = 0x00a00000,
		Align1024Bytes = 0x00b00000,
		Align2048Bytes = 0x00c00000,
		Align4096Bytes = 0x00d00000,
		Align8192Bytes = 0x00e00000,
		LnkNRelocOvfl = 0x01000000,
		MemDiscardable = 0x02000000,
		MemNotCached = 0x04000000,
		MemNotPaged = 0x08000000,
		MemShared = 0x10000000,
		MemExecute = 0x20000000,
		MemoryRead = 0x40000000,
		MemoryWrite = 0x80000000
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Binary/SectionCollection.cs
================================================
//
// SectionCollection.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Binary {

	using System;
	using System.Collections;

	public sealed class SectionCollection : ICollection, IBinaryVisitable {

		IList m_items;

		public Section this [int index]
		{
			get { return m_items [index] as Section; }
			set { m_items [index] = value; }
		}

		public int Count {
			get { return m_items.Count; }
		}

		public bool IsSynchronized {
			get { return false; }
		}

		public object SyncRoot {
			get { return this; }
		}

		internal SectionCollection ()
		{
			m_items = new ArrayList (4);
		}

		internal void Add (Section value)
		{
			m_items.Add (value);
		}

		internal void Clear ()
		{
			m_items.Clear ();
		}

		public bool Contains (Section value)
		{
			return m_items.Contains (value);
		}

		public int IndexOf (Section value)
		{
			return m_items.IndexOf (value);
		}

		internal void Insert (int index, Section value)
		{
			m_items.Insert (index, value);
		}

		internal void Remove (Section value)
		{
			m_items.Remove (value);
		}

		internal void RemoveAt (int index)
		{
			m_items.Remove (index);
		}

		public void CopyTo (Array ary, int index)
		{
			m_items.CopyTo (ary, index);
		}

		public IEnumerator GetEnumerator ()
		{
			return m_items.GetEnumerator ();
		}

		public void Accept (IBinaryVisitor visitor)
		{
			visitor.VisitSectionCollection (this);

			for (int i = 0; i < m_items.Count; i++)
				this [i].Accept (visitor);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Binary/SubSystem.cs
================================================
//
// SubSystem.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Binary {

	public enum SubSystem : ushort {
		Unknown = 0x0,
		Native = 0x1,
		WindowsGui = 0x2,
		WindowsCui = 0x3,
		PosixCui = 0x7,
		WindowsCeGui = 0x9,
		EfiApplication = 0x10,
		EfiBootServiceDriver = 0x11,
		EfiRuntimeDriver = 0x12,
		EfiRom = 0x13,
		Xbox = 0x14,
		NexusAgent = 0x15
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Cil/BaseCodeVisitor.cs
================================================
//
// BaseCodeVisitor.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Cil {

	public abstract class BaseCodeVisitor : ICodeVisitor {

		public virtual void VisitMethodBody (MethodBody body)
		{
		}

		public virtual void VisitInstructionCollection (InstructionCollection instructions)
		{
		}

		public virtual void VisitInstruction (Instruction instr)
		{
		}

		public virtual void VisitExceptionHandlerCollection (ExceptionHandlerCollection seh)
		{
		}

		public virtual void VisitExceptionHandler (ExceptionHandler eh)
		{
		}

		public virtual void VisitVariableDefinitionCollection (VariableDefinitionCollection variables)
		{
		}

		public virtual void VisitVariableDefinition (VariableDefinition var)
		{
		}

		public virtual void VisitScopeCollection (ScopeCollection scopes)
		{
		}

		public virtual void VisitScope (Scope s)
		{
		}

		public virtual void TerminateMethodBody (MethodBody body)
		{
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Cil/CilWorker.cs
================================================
//
// CilWorker.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Cil {

	using System;
	using SR = System.Reflection;

	public sealed class CilWorker {

		MethodBody m_mbody;
		InstructionCollection m_instrs;

		internal CilWorker (MethodBody body)
		{
			m_mbody = body;
			m_instrs = m_mbody.Instructions;
		}

		public MethodBody GetBody ()
		{
			return m_mbody;
		}

		public Instruction Create (OpCode opcode)
		{
			if (opcode.OperandType != OperandType.InlineNone)
				throw new ArgumentException ("opcode");

			return FinalCreate (opcode);
		}

		public Instruction Create (OpCode opcode, TypeReference type)
		{
			if (opcode.OperandType != OperandType.InlineType &&
				opcode.OperandType != OperandType.InlineTok)
				throw new ArgumentException ("opcode");

			return FinalCreate (opcode, type);
		}

		public Instruction Create (OpCode opcode, MethodReference meth)
		{
			if (opcode.OperandType != OperandType.InlineMethod &&
				opcode.OperandType != OperandType.InlineTok)
				throw new ArgumentException ("opcode");

			return FinalCreate (opcode, meth);
		}

		public Instruction Create (OpCode opcode, FieldReference field)
		{
			if (opcode.OperandType != OperandType.InlineField &&
				opcode.OperandType != OperandType.InlineTok)
				throw new ArgumentException ("opcode");

			return FinalCreate (opcode, field);
		}

		public Instruction Create (OpCode opcode, string str)
		{
			if (opcode.OperandType != OperandType.InlineString)
				throw new ArgumentException ("opcode");

			return FinalCreate (opcode, str);
		}

		public Instruction Create (OpCode opcode, sbyte b)
		{
			if (opcode.OperandType != OperandType.ShortInlineI &&
				opcode != OpCodes.Ldc_I4_S)
				throw new ArgumentException ("opcode");

			return FinalCreate (opcode, b);
		}

		public Instruction Create (OpCode opcode, byte b)
		{
			if (opcode.OperandType != OperandType.ShortInlineI || opcode == OpCodes.Ldc_I4_S)
				throw new ArgumentException ("opcode");
			return FinalCreate (opcode, b);
		}

		public Instruction Create (OpCode opcode, int i)
		{
			if (opcode.OperandType != OperandType.InlineI)
				throw new ArgumentException ("opcode");

			return FinalCreate (opcode, i);
		}

		public Instruction Create (OpCode opcode, long l)
		{
			if (opcode.OperandType != OperandType.InlineI8)
				throw new ArgumentException ("opcode");

			return FinalCreate (opcode, l);
		}

		public Instruction Create (OpCode opcode, float f)
		{
			if (opcode.OperandType != OperandType.ShortInlineR)
				throw new ArgumentException ("opcode");

			return FinalCreate (opcode, f);
		}

		public Instruction Create (OpCode opcode, double d)
		{
			if (opcode.OperandType != OperandType.InlineR)
				throw new ArgumentException ("opcode");

			return FinalCreate (opcode, d);
		}

		public Instruction Create (OpCode opcode, Instruction label)
		{
			if (opcode.OperandType != OperandType.InlineBrTarget &&
				opcode.OperandType != OperandType.ShortInlineBrTarget)
				throw new ArgumentException ("opcode");

			return FinalCreate (opcode, label);
		}

		public Instruction Create (OpCode opcode, Instruction [] labels)
		{
			if (opcode.OperandType != OperandType.InlineSwitch)
				throw new ArgumentException ("opcode");

			return FinalCreate (opcode, labels);
		}

		public Instruction Create (OpCode opcode, VariableDefinition var)
		{
			if (opcode.OperandType != OperandType.ShortInlineVar &&
				opcode.OperandType != OperandType.InlineVar)
				throw new ArgumentException ("opcode");

			return FinalCreate (opcode, var);
		}

		public Instruction Create (OpCode opcode, ParameterDefinition param)
		{
			if (opcode.OperandType != OperandType.ShortInlineParam &&
				opcode.OperandType != OperandType.InlineParam)
				throw new ArgumentException ("opcode");

			return FinalCreate (opcode, param);
		}

		Instruction FinalCreate (OpCode opcode)
		{
			return FinalCreate (opcode, null);
		}

		Instruction FinalCreate (OpCode opcode, object operand)
		{
			return new Instruction (opcode, operand);
		}

		public Instruction Emit (OpCode opcode)
		{
			Instruction instr = Create (opcode);
			Append (instr);
			return instr;
		}

		public Instruction Emit (OpCode opcode, TypeReference type)
		{
			Instruction instr = Create (opcode, type);
			Append (instr);
			return instr;
		}

		public Instruction Emit (OpCode opcode, MethodReference meth)
		{
			Instruction instr = Create (opcode, meth);
			Append (instr);
			return instr;
		}

		public Instruction Emit (OpCode opcode, FieldReference field)
		{
			Instruction instr = Create (opcode, field);
			Append (instr);
			return instr;
		}

		public Instruction Emit (OpCode opcode, string str)
		{
			Instruction instr = Create (opcode, str);
			Append (instr);
			return instr;
		}

		public Instruction Emit (OpCode opcode, byte b)
		{
			Instruction instr = Create (opcode, b);
			Append (instr);
			return instr;
		}

		public Instruction Emit (OpCode opcode, sbyte b)
		{
			Instruction instr = Create (opcode, b);
			Append (instr);
			return instr;
		}

		public Instruction Emit (OpCode opcode, int i)
		{
			Instruction instr = Create (opcode, i);
			Append (instr);
			return instr;
		}

		public Instruction Emit (OpCode opcode, long l)
		{
			Instruction instr = Create (opcode, l);
			Append (instr);
			return instr;
		}

		public Instruction Emit (OpCode opcode, float f)
		{
			Instruction instr = Create (opcode, f);
			Append (instr);
			return instr;
		}

		public Instruction Emit (OpCode opcode, double d)
		{
			Instruction instr = Create (opcode, d);
			Append (instr);
			return instr;
		}

		public Instruction Emit (OpCode opcode, Instruction target)
		{
			Instruction instr = Create (opcode, target);
			Append (instr);
			return instr;
		}

		public Instruction Emit (OpCode opcode, Instruction [] targets)
		{
			Instruction instr = Create (opcode, targets);
			Append (instr);
			return instr;
		}

		public Instruction Emit (OpCode opcode, VariableDefinition var)
		{
			Instruction instr = Create (opcode, var);
			Append (instr);
			return instr;
		}

		public Instruction Emit (OpCode opcode, ParameterDefinition param)
		{
			Instruction instr = Create (opcode, param);
			Append (instr);
			return instr;
		}

		public void InsertBefore (Instruction target, Instruction instr)
		{
			int index = m_instrs.IndexOf (target);
			if (index == -1)
				throw new ReflectionException ("Target instruction not in method body");

			m_instrs.Insert (index, instr);
			instr.Previous = target.Previous;
			target.Previous = instr;
			instr.Next = target;
		}

		public void InsertAfter (Instruction target, Instruction instr)
		{
			int index = m_instrs.IndexOf (target);
			if (index == -1)
				throw new ReflectionException ("Target instruction not in method body");

			m_instrs.Insert (index + 1, instr);
			instr.Next = target.Next;
			target.Next = instr;
			instr.Previous = target;
		}

		public void Append (Instruction instr)
		{
			Instruction last = null, current = instr;
			if (m_instrs.Count > 0)
				last = m_instrs [m_instrs.Count - 1];

			if (last != null) {
				last.Next = instr;
				current.Previous = last;
			}

			m_instrs.Add (current);
		}

		public void Replace (Instruction old, Instruction instr)
		{
			int index = m_instrs.IndexOf (old);
			if (index == -1)
				throw new ReflectionException ("Target instruction not in method body");

			InsertAfter (old, instr);
			Remove (old);
		}

		public void Remove (Instruction instr)
		{
			if (!m_instrs.Contains (instr))
				throw new ReflectionException ("Instruction not in method body");

			if (instr.Previous != null)
				instr.Previous.Next = instr.Next;
			if (instr.Next != null)
				instr.Next.Previous = instr.Previous;
			m_instrs.Remove (instr);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Cil/Code.cs
================================================
//
// Code.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Fri Mar 16 15:37:23 +0100 2007
//
// (C) 2007 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Cil {

	public enum Code {
		Nop,
		Break,
		Ldarg_0,
		Ldarg_1,
		Ldarg_2,
		Ldarg_3,
		Ldloc_0,
		Ldloc_1,
		Ldloc_2,
		Ldloc_3,
		Stloc_0,
		Stloc_1,
		Stloc_2,
		Stloc_3,
		Ldarg_S,
		Ldarga_S,
		Starg_S,
		Ldloc_S,
		Ldloca_S,
		Stloc_S,
		Ldnull,
		Ldc_I4_M1,
		Ldc_I4_0,
		Ldc_I4_1,
		Ldc_I4_2,
		Ldc_I4_3,
		Ldc_I4_4,
		Ldc_I4_5,
		Ldc_I4_6,
		Ldc_I4_7,
		Ldc_I4_8,
		Ldc_I4_S,
		Ldc_I4,
		Ldc_I8,
		Ldc_R4,
		Ldc_R8,
		Dup,
		Pop,
		Jmp,
		Call,
		Calli,
		Ret,
		Br_S,
		Brfalse_S,
		Brtrue_S,
		Beq_S,
		Bge_S,
		Bgt_S,
		Ble_S,
		Blt_S,
		Bne_Un_S,
		Bge_Un_S,
		Bgt_Un_S,
		Ble_Un_S,
		Blt_Un_S,
		Br,
		Brfalse,
		Brtrue,
		Beq,
		Bge,
		Bgt,
		Ble,
		Blt,
		Bne_Un,
		Bge_Un,
		Bgt_Un,
		Ble_Un,
		Blt_Un,
		Switch,
		Ldind_I1,
		Ldind_U1,
		Ldind_I2,
		Ldind_U2,
		Ldind_I4,
		Ldind_U4,
		Ldind_I8,
		Ldind_I,
		Ldind_R4,
		Ldind_R8,
		Ldind_Ref,
		Stind_Ref,
		Stind_I1,
		Stind_I2,
		Stind_I4,
		Stind_I8,
		Stind_R4,
		Stind_R8,
		Add,
		Sub,
		Mul,
		Div,
		Div_Un,
		Rem,
		Rem_Un,
		And,
		Or,
		Xor,
		Shl,
		Shr,
		Shr_Un,
		Neg,
		Not,
		Conv_I1,
		Conv_I2,
		Conv_I4,
		Conv_I8,
		Conv_R4,
		Conv_R8,
		Conv_U4,
		Conv_U8,
		Callvirt,
		Cpobj,
		Ldobj,
		Ldstr,
		Newobj,
		Castclass,
		Isinst,
		Conv_R_Un,
		Unbox,
		Throw,
		Ldfld,
		Ldflda,
		Stfld,
		Ldsfld,
		Ldsflda,
		Stsfld,
		Stobj,
		Conv_Ovf_I1_Un,
		Conv_Ovf_I2_Un,
		Conv_Ovf_I4_Un,
		Conv_Ovf_I8_Un,
		Conv_Ovf_U1_Un,
		Conv_Ovf_U2_Un,
		Conv_Ovf_U4_Un,
		Conv_Ovf_U8_Un,
		Conv_Ovf_I_Un,
		Conv_Ovf_U_Un,
		Box,
		Newarr,
		Ldlen,
		Ldelema,
		Ldelem_I1,
		Ldelem_U1,
		Ldelem_I2,
		Ldelem_U2,
		Ldelem_I4,
		Ldelem_U4,
		Ldelem_I8,
		Ldelem_I,
		Ldelem_R4,
		Ldelem_R8,
		Ldelem_Ref,
		Stelem_I,
		Stelem_I1,
		Stelem_I2,
		Stelem_I4,
		Stelem_I8,
		Stelem_R4,
		Stelem_R8,
		Stelem_Ref,
		Ldelem_Any,
		Stelem_Any,
		Unbox_Any,
		Conv_Ovf_I1,
		Conv_Ovf_U1,
		Conv_Ovf_I2,
		Conv_Ovf_U2,
		Conv_Ovf_I4,
		Conv_Ovf_U4,
		Conv_Ovf_I8,
		Conv_Ovf_U8,
		Refanyval,
		Ckfinite,
		Mkrefany,
		Ldtoken,
		Conv_U2,
		Conv_U1,
		Conv_I,
		Conv_Ovf_I,
		Conv_Ovf_U,
		Add_Ovf,
		Add_Ovf_Un,
		Mul_Ovf,
		Mul_Ovf_Un,
		Sub_Ovf,
		Sub_Ovf_Un,
		Endfinally,
		Leave,
		Leave_S,
		Stind_I,
		Conv_U,
		Arglist,
		Ceq,
		Cgt,
		Cgt_Un,
		Clt,
		Clt_Un,
		Ldftn,
		Ldvirtftn,
		Ldarg,
		Ldarga,
		Starg,
		Ldloc,
		Ldloca,
		Stloc,
		Localloc,
		Endfilter,
		Unaligned,
		Volatile,
		Tail,
		Initobj,
		Constrained,
		Cpblk,
		Initblk,
		No,
		Rethrow,
		Sizeof,
		Refanytype,
		Readonly,
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Cil/CodeReader.cs
================================================
//
// CodeReader.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 - 2007 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Cil {

	using System;
	using System.Collections;
	using System.IO;

	using Mono.Cecil;
	using Mono.Cecil.Metadata;
	using Mono.Cecil.Signatures;

	class CodeReader : BaseCodeVisitor {

		ReflectionReader m_reflectReader;
		MetadataRoot m_root;

		public CodeReader (ReflectionReader reflectReader)
		{
			m_reflectReader = reflectReader;
			m_root = m_reflectReader.MetadataRoot;
		}

		public override void VisitMethodBody (MethodBody body)
		{
			MethodDefinition meth = body.Method;
			MethodBody methBody = body;
			BinaryReader br = m_reflectReader.Module.ImageReader.MetadataReader.GetDataReader (meth.RVA);

			// lets read the method
			IDictionary instrs;
			int flags = br.ReadByte ();
			switch (flags & 0x3) {
			case (int) MethodHeader.TinyFormat :
				methBody.CodeSize = flags >> 2;
				methBody.MaxStack = 8;
				ReadCilBody (methBody, br, out instrs);
				break;
			case (int) MethodHeader.FatFormat :
				br.BaseStream.Position--;
				int fatflags = br.ReadUInt16 ();
				//int headersize = (fatflags >> 12) & 0xf;
				methBody.MaxStack = br.ReadUInt16 ();
				methBody.CodeSize = br.ReadInt32 ();
				methBody.LocalVarToken = br.ReadInt32 ();
				body.InitLocals = (fatflags & (int) MethodHeader.InitLocals) != 0;
				VisitVariableDefinitionCollection (methBody.Variables);
				ReadCilBody (methBody, br, out instrs);
				if ((fatflags & (int) MethodHeader.MoreSects) != 0)
					ReadSection (methBody, br, instrs);
				break;
			}

			if (m_reflectReader.SymbolReader != null)
				m_reflectReader.SymbolReader.Read (methBody);
		}

		public static uint GetRid (int token)
		{
			return (uint) token & 0x00ffffff;
		}

		public static ParameterDefinition GetParameter (MethodBody body, int index)
		{
			if (body.Method.HasThis) {
				if (index == 0)
					return body.Method.This;
				index--;
			}

			return body.Method.Parameters [index];
		}

		public static VariableDefinition GetVariable (MethodBody body, int index)
		{
			return body.Variables [index];
		}

		void ReadCilBody (MethodBody body, BinaryReader br, out IDictionary instructions)
		{
			long start = br.BaseStream.Position;
			Instruction last = null;
			InstructionCollection code = body.Instructions;
			instructions = new Hashtable ();
			GenericContext context = new GenericContext (body.Method);

			while (br.BaseStream.Position < start + body.CodeSize) {
				OpCode op;
				long offset = br.BaseStream.Position - start;
				int cursor = br.ReadByte ();
				if (cursor == 0xfe)
					op = OpCodes.TwoBytesOpCode [br.ReadByte ()];
				else
					op = OpCodes.OneByteOpCode [cursor];

				Instruction instr = new Instruction ((int) offset, op);
				switch (op.OperandType) {
				case OperandType.InlineNone :
					break;
				case OperandType.InlineSwitch :
					uint length = br.ReadUInt32 ();
					int [] branches = new int [length];
					int [] buf = new int [length];
					for (int i = 0; i < length; i++)
						buf [i] = br.ReadInt32 ();
					for (int i = 0; i < length; i++)
						branches [i] = Convert.ToInt32 (br.BaseStream.Position - start + buf [i]);
					instr.Operand = branches;
					break;
				case OperandType.ShortInlineBrTarget :
					sbyte sbrtgt = br.ReadSByte ();
					instr.Operand = Convert.ToInt32 (br.BaseStream.Position - start + sbrtgt);
					break;
				case OperandType.InlineBrTarget :
					int brtgt = br.ReadInt32 ();
					instr.Operand = Convert.ToInt32 (br.BaseStream.Position - start + brtgt);
					break;
				case OperandType.ShortInlineI :
					if (op == OpCodes.Ldc_I4_S)
						instr.Operand = br.ReadSByte ();
					else
						instr.Operand = br.ReadByte ();
					break;
				case OperandType.ShortInlineVar :
					instr.Operand = GetVariable (body, br.ReadByte ());
					break;
				case OperandType.ShortInlineParam :
					instr.Operand = GetParameter (body, br.ReadByte ());
					break;
				case OperandType.InlineSig :
					instr.Operand = GetCallSiteAt (br.ReadInt32 (), context);
					break;
				case OperandType.InlineI :
					instr.Operand = br.ReadInt32 ();
					break;
				case OperandType.InlineVar :
					instr.Operand = GetVariable (body, br.ReadInt16 ());
					break;
				case OperandType.InlineParam :
					instr.Operand = GetParameter (body, br.ReadInt16 ());
					break;
				case OperandType.InlineI8 :
					instr.Operand = br.ReadInt64 ();
					break;
				case OperandType.ShortInlineR :
					instr.Operand = br.ReadSingle ();
					break;
				case OperandType.InlineR :
					instr.Operand = br.ReadDouble ();
					break;
				case OperandType.InlineString :
					instr.Operand = m_root.Streams.UserStringsHeap [GetRid (br.ReadInt32 ())];
					break;
				case OperandType.InlineField :
					MetadataToken field = new MetadataToken (br.ReadInt32 ());
					switch (field.TokenType) {
					case TokenType.Field:
						instr.Operand = m_reflectReader.GetFieldDefAt (field.RID);
						break;
					case TokenType.MemberRef:
						instr.Operand = m_reflectReader.GetMemberRefAt (field.RID, context);
						break;
					default:
						throw new ReflectionException ("Wrong token for InlineField Operand: " + field);
					}
					break;
				case OperandType.InlineMethod :
					MetadataToken meth = new MetadataToken (br.ReadInt32 ());
					switch (meth.TokenType) {
					case TokenType.Method:
						instr.Operand = m_reflectReader.GetMethodDefAt (meth.RID);
						break;
					case TokenType.MemberRef:
						instr.Operand = m_reflectReader.GetMemberRefAt (meth.RID, context);
						break;
					case TokenType.MethodSpec:
						instr.Operand = m_reflectReader.GetMethodSpecAt (meth.RID, context);
						break;
					default:
						throw new ReflectionException ("Wrong token for InlineMethod Operand: " + meth);
					}
					break;
				case OperandType.InlineType :
					MetadataToken type = new MetadataToken (br.ReadInt32 ());
					switch (type.TokenType) {
					case TokenType.TypeDef:
						instr.Operand = m_reflectReader.GetTypeDefAt (type.RID);
						break;
					case TokenType.TypeRef:
						instr.Operand = m_reflectReader.GetTypeRefAt (type.RID);
						break;
					case TokenType.TypeSpec:
						instr.Operand = m_reflectReader.GetTypeSpecAt (type.RID, context);
						break;
					default:
						throw new ReflectionException ("Wrong token for InlineType Operand: " + type);
					}
					break;
				case OperandType.InlineTok :
					MetadataToken token = new MetadataToken (br.ReadInt32 ());
					switch (token.TokenType) {
					case TokenType.TypeDef:
						instr.Operand = m_reflectReader.GetTypeDefAt (token.RID);
						break;
					case TokenType.TypeRef:
						instr.Operand = m_reflectReader.GetTypeRefAt (token.RID);
						break;
					case TokenType.TypeSpec:
						instr.Operand = m_reflectReader.GetTypeSpecAt (token.RID, context);
						break;
					case TokenType.Field:
						instr.Operand = m_reflectReader.GetFieldDefAt (token.RID);
						break;
					case TokenType.Method:
						instr.Operand = m_reflectReader.GetMethodDefAt (token.RID);
						break;
					case TokenType.MethodSpec:
						instr.Operand = m_reflectReader.GetMethodSpecAt (token.RID, context);
						break;
					case TokenType.MemberRef:
						instr.Operand = m_reflectReader.GetMemberRefAt (token.RID, context);
						break;
					default:
						throw new ReflectionException ("Wrong token following ldtoken: " + token);
					}
					break;
				}

				instructions.Add (instr.Offset, instr);

				if (last != null) {
					last.Next = instr;
					instr.Previous = last;
				}

				last = instr;

				code.Add (instr);
			}

			// resolve branches
			foreach (Instruction i in code) {
				switch (i.OpCode.OperandType) {
				case OperandType.ShortInlineBrTarget:
				case OperandType.InlineBrTarget:
					i.Operand = GetInstruction (body, instructions, (int) i.Operand);
					break;
				case OperandType.InlineSwitch:
					int [] lbls = (int []) i.Operand;
					Instruction [] instrs = new Instruction [lbls.Length];
					for (int j = 0; j < lbls.Length; j++)
						instrs [j] = GetInstruction (body, instructions, lbls [j]);
					i.Operand = instrs;
					break;
				}
			}
		}

		static Instruction GetInstruction (MethodBody body, IDictionary instructions, int offset)
		{
			Instruction instruction = instructions [offset] as Instruction;
			if (instruction != null)
				return instruction;

			return body.Instructions.Outside;
		}

		void ReadSection (MethodBody body, BinaryReader br, IDictionary instructions)
		{
			br.BaseStream.Position += 3;
			br.BaseStream.Position &= ~3;

			byte flags = br.ReadByte ();
			if ((flags & (byte) MethodDataSection.FatFormat) == 0) {
				int length = br.ReadByte () / 12;
				br.ReadBytes (2);

				for (int i = 0; i < length; i++) {
					ExceptionHandler eh = new ExceptionHandler (
						(ExceptionHandlerType) (br.ReadInt16 () & 0x7));
					eh.TryStart = GetInstruction (body, instructions, Convert.ToInt32 (br.ReadInt16 ()));
					eh.TryEnd = GetInstruction (body, instructions, eh.TryStart.Offset + Convert.ToInt32 (br.ReadByte ()));
					eh.HandlerStart = GetInstruction (body, instructions, Convert.ToInt32 (br.ReadInt16 ()));
					eh.HandlerEnd = GetInstruction (body, instructions, eh.HandlerStart.Offset + Convert.ToInt32 (br.ReadByte ()));
					ReadExceptionHandlerEnd (eh, br, body, instructions);
					body.ExceptionHandlers.Add (eh);
				}
			} else {
				br.BaseStream.Position--;
				int length = (br.ReadInt32 () >> 8) / 24;
				if ((flags & (int) MethodDataSection.EHTable) == 0)
					br.ReadBytes (length * 24);
				for (int i = 0; i < length; i++) {
					ExceptionHandler eh = new ExceptionHandler (
						(ExceptionHandlerType) (br.ReadInt32 () & 0x7));
					eh.TryStart = GetInstruction (body, instructions, br.ReadInt32 ());
					eh.TryEnd = GetInstruction (body, instructions, eh.TryStart.Offset + br.ReadInt32 ());
					eh.HandlerStart = GetInstruction (body, instructions, br.ReadInt32 ());
					eh.HandlerEnd = GetInstruction (body, instructions, eh.HandlerStart.Offset + br.ReadInt32 ());
					ReadExceptionHandlerEnd(eh, br, body, instructions);
					body.ExceptionHandlers.Add (eh);
				}
			}

			if ((flags & (byte) MethodDataSection.MoreSects) != 0)
				ReadSection (body, br, instructions);
		}

		void ReadExceptionHandlerEnd (ExceptionHandler eh, BinaryReader br, MethodBody body, IDictionary instructions)
		{
			switch (eh.Type) {
			case ExceptionHandlerType.Catch :
				MetadataToken token = new MetadataToken (br.ReadInt32 ());
				switch (token.TokenType) {
				case TokenType.TypeDef:
					eh.CatchType = m_reflectReader.GetTypeDefAt (token.RID);
					break;
				default:
					eh.CatchType = m_reflectReader.GetTypeRefAt (token.RID);
					break;
				}
				break;
			case ExceptionHandlerType.Filter :
				eh.FilterStart = GetInstruction (body, instructions, br.ReadInt32 ());
				eh.FilterEnd = GetInstruction (body, instructions, eh.HandlerStart.Previous.Offset);
				break;
			default :
				br.ReadInt32 ();
				break;
			}
		}

		CallSite GetCallSiteAt (int token, GenericContext context)
		{
			StandAloneSigTable sasTable = m_reflectReader.TableReader.GetStandAloneSigTable ();
			MethodSig ms = m_reflectReader.SigReader.GetStandAloneMethodSig (
				sasTable [(int) GetRid (token) - 1].Signature);
			CallSite cs = new CallSite (ms.HasThis, ms.ExplicitThis,
				ms.MethCallConv, m_reflectReader.GetMethodReturnType (ms, context));
			cs.MetadataToken = new MetadataToken (token);

			for (int i = 0; i < ms.ParamCount; i++) {
				Param p = ms.Parameters [i];
				cs.Parameters.Add (m_reflectReader.BuildParameterDefinition (
						string.Concat ("A_", i),
						i, (ParameterAttributes) 0,
						p, context));
			}

			MethodRefSig refSig = ms as MethodRefSig;
			if (refSig != null && refSig.Sentinel >= 0)
				ReflectionReader.CreateSentinel (cs, refSig.Sentinel);

			return cs;
		}

		public override void VisitVariableDefinitionCollection (VariableDefinitionCollection variables)
		{
			MethodBody body = variables.Container as MethodBody;
			if (body == null || body.LocalVarToken == 0)
				return;

			StandAloneSigTable sasTable = m_reflectReader.TableReader.GetStandAloneSigTable ();
			StandAloneSigRow sasRow = sasTable [(int) GetRid (body.LocalVarToken) - 1];
			LocalVarSig sig = m_reflectReader.SigReader.GetLocalVarSig (sasRow.Signature);
			for (int i = 0; i < sig.Count; i++) {
				LocalVarSig.LocalVariable lv = sig.LocalVariables [i];
				TypeReference varType = m_reflectReader.GetTypeRefFromSig (
					lv.Type, new GenericContext (body.Method));

				if (lv.ByRef)
					varType = new ReferenceType (varType);
				if ((lv.Constraint & Constraint.Pinned) != 0)
					varType = new PinnedType (varType);

				if (lv.CustomMods.Length > 0)
					varType = m_reflectReader.GetModifierType (lv.CustomMods, varType);

				body.Variables.Add (new VariableDefinition (
						string.Concat ("V_", i), i, body.Method, varType));
			}
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Cil/CodeWriter.cs
================================================
//
// CodeWriter.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 - 2007 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Cil {

	using System;
	using System.Collections;

	using Mono.Cecil;
	using Mono.Cecil.Binary;
	using Mono.Cecil.Metadata;
	using Mono.Cecil.Signatures;

	class CodeWriter : BaseCodeVisitor {

		ReflectionWriter m_reflectWriter;
		MemoryBinaryWriter m_binaryWriter;
		MemoryBinaryWriter m_codeWriter;

		IDictionary m_localSigCache;
		IDictionary m_standaloneSigCache;

		public CodeWriter (ReflectionWriter reflectWriter, MemoryBinaryWriter writer)
		{
			m_reflectWriter = reflectWriter;
			m_binaryWriter = writer;
			m_codeWriter = new MemoryBinaryWriter ();

			m_localSigCache = new Hashtable ();
			m_standaloneSigCache = new Hashtable ();
		}

		public RVA WriteMethodBody (MethodDefinition meth)
		{
			if (meth.Body == null)
				return RVA.Zero;

			RVA ret = m_reflectWriter.MetadataWriter.GetDataCursor ();
			meth.Body.Accept (this);
			return ret;
		}

		public override void VisitMethodBody (MethodBody body)
		{
			m_codeWriter.Empty ();
		}

		void WriteToken (MetadataToken token)
		{
			if (token.RID == 0)
				m_codeWriter.Write (0);
			else
				m_codeWriter.Write (token.ToUInt ());
		}

		static int GetParameterIndex (MethodBody body, ParameterDefinition p)
		{
			int idx = body.Method.Parameters.IndexOf (p);
			if (idx == -1 && p == body.Method.This)
				return 0;
			if (body.Method.HasThis)
				idx++;

			return idx;
		}

		public override void VisitInstructionCollection (InstructionCollection instructions)
		{
			MethodBody body = instructions.Container;
			long start = m_codeWriter.BaseStream.Position;

			ComputeMaxStack (instructions);

			foreach (Instruction instr in instructions) {

				instr.Offset = (int) (m_codeWriter.BaseStream.Position - start);

				if (instr.OpCode.Size == 1)
					m_codeWriter.Write (instr.OpCode.Op2);
				else {
					m_codeWriter.Write (instr.OpCode.Op1);
					m_codeWriter.Write (instr.OpCode.Op2);
				}

				if (instr.OpCode.OperandType != OperandType.InlineNone &&
					instr.Operand == null)
					throw new ReflectionException ("OpCode {0} have null operand", instr.OpCode.Name);

				switch (instr.OpCode.OperandType) {
				case OperandType.InlineNone :
					break;
				case OperandType.InlineSwitch :
					Instruction [] targets = (Instruction []) instr.Operand;
					for (int i = 0; i < targets.Length + 1; i++)
						m_codeWriter.Write ((uint) 0);
					break;
				case OperandType.ShortInlineBrTarget :
					m_codeWriter.Write ((byte) 0);
					break;
				case OperandType.InlineBrTarget :
					m_codeWriter.Write (0);
					break;
				case OperandType.ShortInlineI :
					if (instr.OpCode == OpCodes.Ldc_I4_S)
						m_codeWriter.Write (sbyte.Parse(instr.Operand.ToString()));
					else
						m_codeWriter.Write ((byte) instr.Operand);
					break;
				case OperandType.ShortInlineVar :
					m_codeWriter.Write ((byte) body.Variables.IndexOf (
						(VariableDefinition) instr.Operand));
					break;
				case OperandType.ShortInlineParam :
					m_codeWriter.Write ((byte) GetParameterIndex (body, (ParameterDefinition) instr.Operand));
					break;
				case OperandType.InlineSig :
					WriteToken (GetCallSiteToken ((CallSite) instr.Operand));
					break;
				case OperandType.InlineI :
					m_codeWriter.Write ((int)instr.Operand);
					break;
				case OperandType.InlineVar :
					m_codeWriter.Write ((short) body.Variables.IndexOf (
						(VariableDefinition) instr.Operand));
					break;
				case OperandType.InlineParam :
					m_codeWriter.Write ((short) GetParameterIndex (
							body, (ParameterDefinition) instr.Operand));
					break;
				case OperandType.InlineI8 :
					m_codeWriter.Write ((long) instr.Operand);
					break;
				case OperandType.ShortInlineR :
					m_codeWriter.Write ((float) instr.Operand);
					break;
				case OperandType.InlineR :
					m_codeWriter.Write ((double) instr.Operand);
					break;
				case OperandType.InlineString :
					WriteToken (new MetadataToken (TokenType.String,
							m_reflectWriter.MetadataWriter.AddUserString (instr.Operand as string)));
					break;
				case OperandType.InlineField :
					if (instr.Operand is FieldReference)
						WriteToken ((instr.Operand as FieldReference).MetadataToken);
					else
						throw new ReflectionException ("Wrong operand for InlineField: {0}",
							instr.Operand.GetType ().FullName);
					break;
				case OperandType.InlineMethod :
					if (instr.Operand is GenericInstanceMethod)
						WriteToken (m_reflectWriter.GetMethodSpecToken (instr.Operand as GenericInstanceMethod));
					else if (instr.Operand is MethodReference)
						WriteToken ((instr.Operand as MethodReference).MetadataToken);
					else
						throw new ReflectionException ("Wrong operand for InlineMethod: {0}",
							instr.Operand.GetType ().FullName);
					break;
				case OperandType.InlineType :
					if (instr.Operand is TypeReference)
						WriteToken (m_reflectWriter.GetTypeDefOrRefToken (
								instr.Operand as TypeReference));
					else
						throw new ReflectionException ("Wrong operand for InlineType: {0}",
							instr.Operand.GetType ().FullName);
					break;

				case OperandType.InlineTok :
					if (instr.Operand is TypeReference)
						WriteToken (m_reflectWriter.GetTypeDefOrRefToken (
								instr.Operand as TypeReference));
					else if (instr.Operand is GenericInstanceMethod)
						WriteToken (m_reflectWriter.GetMethodSpecToken (instr.Operand as GenericInstanceMethod));
					else if (instr.Operand is IMetadataTokenProvider)
						WriteToken ((instr.Operand as IMetadataTokenProvider).MetadataToken);
					else
						throw new ReflectionException (
							string.Format ("Wrong operand for {0} OpCode: {1}",
								instr.OpCode.OperandType,
								instr.Operand.GetType ().FullName));
					break;
				}
			}

			// patch branches
			long pos = m_codeWriter.BaseStream.Position;

			foreach (Instruction instr in instructions) {
				switch (instr.OpCode.OperandType) {
				case OperandType.InlineSwitch :
					m_codeWriter.BaseStream.Position = instr.Offset + instr.OpCode.Size;
					Instruction [] targets = (Instruction []) instr.Operand;
					m_codeWriter.Write ((uint) targets.Length);
					foreach (Instruction tgt in targets)
						m_codeWriter.Write ((tgt.Offset - (instr.Offset +
							instr.OpCode.Size + (4 * (targets.Length + 1)))));
					break;
				case OperandType.ShortInlineBrTarget :
					m_codeWriter.BaseStream.Position = instr.Offset + instr.OpCode.Size;
					m_codeWriter.Write ((byte) (((Instruction) instr.Operand).Offset -
						(instr.Offset + instr.OpCode.Size + 1)));
					break;
				case OperandType.InlineBrTarget :
					m_codeWriter.BaseStream.Position = instr.Offset + instr.OpCode.Size;
					m_codeWriter.Write(((Instruction) instr.Operand).Offset -
						(instr.Offset + instr.OpCode.Size + 4));
					break;
				}
			}

			m_codeWriter.BaseStream.Position = pos;
		}

		MetadataToken GetCallSiteToken (CallSite cs)
		{
			uint sig;
			int sentinel = cs.GetSentinel ();
			if (sentinel > 0)
				sig = m_reflectWriter.SignatureWriter.AddMethodDefSig (
					m_reflectWriter.GetMethodDefSig (cs));
			else
				sig = m_reflectWriter.SignatureWriter.AddMethodRefSig (
					m_reflectWriter.GetMethodRefSig (cs));

			if (m_standaloneSigCache.Contains (sig))
				return (MetadataToken) m_standaloneSigCache [sig];

			StandAloneSigTable sasTable = m_reflectWriter.MetadataTableWriter.GetStandAloneSigTable ();
			StandAloneSigRow sasRow = m_reflectWriter.MetadataRowWriter.CreateStandAloneSigRow (sig);

			sasTable.Rows.Add(sasRow);

			MetadataToken token = new MetadataToken (TokenType.Signature, (uint) sasTable.Rows.Count);
			m_standaloneSigCache [sig] = token;
			return token;
		}

		static int GetLength (Instruction start, Instruction end, InstructionCollection instructions)
		{
			Instruction last = instructions [instructions.Count - 1];
			return (end == instructions.Outside ? last.Offset + GetSize (last) : end.Offset) - start.Offset;
		}

		static int GetSize (Instruction i)
		{
			int size = i.OpCode.Size;

			switch (i.OpCode.OperandType) {
			case OperandType.InlineSwitch:
				size += ((Instruction []) i.Operand).Length * 4;
				break;
			case OperandType.InlineI8:
			case OperandType.InlineR:
				size += 8;
				break;
			case OperandType.InlineBrTarget:
			case OperandType.InlineField:
			case OperandType.InlineI:
			case OperandType.InlineMethod:
			case OperandType.InlineString:
			case OperandType.InlineTok:
			case OperandType.InlineType:
			case OperandType.ShortInlineR:
				size += 4;
				break;
			case OperandType.InlineParam:
			case OperandType.InlineVar:
				size += 2;
				break;
			case OperandType.ShortInlineBrTarget:
			case OperandType.ShortInlineI:
			case OperandType.ShortInlineParam:
			case OperandType.ShortInlineVar:
				size += 1;
				break;
			}

			return size;
		}

		static bool IsRangeFat (Instruction start, Instruction end, InstructionCollection instructions)
		{
			return GetLength (start, end, instructions) >= 256 ||
				start.Offset >= 65536;
		}

		static bool IsFat (ExceptionHandlerCollection seh)
		{
			for (int i = 0; i < seh.Count; i++) {
				ExceptionHandler eh = seh [i];
				if (IsRangeFat (eh.TryStart, eh.TryEnd, seh.Container.Instructions))
					return true;

				switch (eh.Type) {
				case ExceptionHandlerType.Catch :
				case ExceptionHandlerType.Fault :
				case ExceptionHandlerType.Finally :
					if (IsRangeFat (eh.HandlerStart, eh.HandlerEnd, seh.Container.Instructions))
						return true;
					break;
				case ExceptionHandlerType.Filter :
					if (IsRangeFat (eh.FilterStart, eh.FilterEnd, seh.Container.Instructions))
						return true;
					break;
				}
			}

			return false;
		}

		void WriteExceptionHandlerCollection (ExceptionHandlerCollection seh)
		{
			m_codeWriter.QuadAlign ();

			if (seh.Count < 0x15 && !IsFat (seh)) {
				m_codeWriter.Write ((byte) MethodDataSection.EHTable);
				m_codeWriter.Write ((byte) (seh.Count * 12 + 4));
				m_codeWriter.Write (new byte [2]);
				foreach (ExceptionHandler eh in seh) {
					m_codeWriter.Write ((ushort) eh.Type);
					m_codeWriter.Write ((ushort) eh.TryStart.Offset);
					m_codeWriter.Write ((byte) (eh.TryEnd.Offset - eh.TryStart.Offset));
					m_codeWriter.Write ((ushort) eh.HandlerStart.Offset);
					m_codeWriter.Write ((byte) GetLength (eh.HandlerStart, eh.HandlerEnd, seh.Container.Instructions));
					WriteHandlerSpecific (eh);
				}
			} else {
				m_codeWriter.Write ((byte) (MethodDataSection.FatFormat | MethodDataSection.EHTable));
				WriteFatBlockSize (seh);
				foreach (ExceptionHandler eh in seh) {
					m_codeWriter.Write ((uint) eh.Type);
					m_codeWriter.Write ((uint) eh.TryStart.Offset);
					m_codeWriter.Write ((uint) (eh.TryEnd.Offset - eh.TryStart.Offset));
					m_codeWriter.Write ((uint) eh.HandlerStart.Offset);
					m_codeWriter.Write ((uint) GetLength (eh.HandlerStart, eh.HandlerEnd, seh.Container.Instructions));
					WriteHandlerSpecific (eh);
				}
			}
		}

		void WriteFatBlockSize (ExceptionHandlerCollection seh)
		{
			int size = seh.Count * 24 + 4;
			m_codeWriter.Write ((byte) (size & 0xff));
			m_codeWriter.Write ((byte) ((size >> 8) & 0xff));
			m_codeWriter.Write ((byte) ((size >> 16) & 0xff));
		}

		void WriteHandlerSpecific (ExceptionHandler eh)
		{
			switch (eh.Type) {
			case ExceptionHandlerType.Catch :
				WriteToken (eh.CatchType.MetadataToken);
				break;
			case ExceptionHandlerType.Filter :
				m_codeWriter.Write ((uint) eh.FilterStart.Offset);
				break;
			default :
				m_codeWriter.Write (0);
				break;
			}
		}

		public override void VisitVariableDefinitionCollection (VariableDefinitionCollection variables)
		{
			MethodBody body = variables.Container as MethodBody;
			if (body == null)
				return;

			uint sig = m_reflectWriter.SignatureWriter.AddLocalVarSig (
					GetLocalVarSig (variables));

			if (m_localSigCache.Contains (sig)) {
				body.LocalVarToken = (int) m_localSigCache [sig];
				return;
			}

			StandAloneSigTable sasTable = m_reflectWriter.MetadataTableWriter.GetStandAloneSigTable ();
			StandAloneSigRow sasRow = m_reflectWriter.MetadataRowWriter.CreateStandAloneSigRow (
				sig);

			sasTable.Rows.Add (sasRow);
			body.LocalVarToken = sasTable.Rows.Count;
			m_localSigCache [sig] = body.LocalVarToken;
		}

		public override void TerminateMethodBody (MethodBody body)
		{
			long pos = m_binaryWriter.BaseStream.Position;

			if (body.Variables.Count > 0 || body.ExceptionHandlers.Count > 0
				|| m_codeWriter.BaseStream.Length >= 64 || body.MaxStack > 8) {

				MethodHeader header = MethodHeader.FatFormat;
				if (body.InitLocals)
					header |= MethodHeader.InitLocals;
				if (body.ExceptionHandlers.Count > 0)
					header |= MethodHeader.MoreSects;

				m_binaryWriter.Write ((byte) header);
				m_binaryWriter.Write ((byte) 0x30); // (header size / 4) << 4
				m_binaryWriter.Write ((short) body.MaxStack);
				m_binaryWriter.Write ((int) m_codeWriter.BaseStream.Length);
				m_binaryWriter.Write (((int) TokenType.Signature | body.LocalVarToken));

				WriteExceptionHandlerCollection (body.ExceptionHandlers);
			} else
				m_binaryWriter.Write ((byte) ((byte) MethodHeader.TinyFormat |
					m_codeWriter.BaseStream.Length << 2));

			m_binaryWriter.Write (m_codeWriter);
			m_binaryWriter.QuadAlign ();

			m_reflectWriter.MetadataWriter.AddData (
				(int) (m_binaryWriter.BaseStream.Position - pos));
		}

		LocalVarSig GetLocalVarSig (VariableDefinitionCollection vars)
		{
			LocalVarSig lvs = new LocalVarSig ();
			lvs.CallingConvention |= 0x7;
			lvs.Count = vars.Count;
			lvs.LocalVariables = new LocalVarSig.LocalVariable [lvs.Count];
			for (int i = 0; i < lvs.Count; i++) {
				LocalVarSig.LocalVariable lv = new LocalVarSig.LocalVariable ();
				TypeReference type = vars [i].VariableType;

				lv.CustomMods = m_reflectWriter.GetCustomMods (type);

				if (type is PinnedType) {
					lv.Constraint |= Constraint.Pinned;
					type = (type as PinnedType).ElementType;
				}

				if (type is ReferenceType) {
					lv.ByRef = true;
					type = (type as ReferenceType).ElementType;
				}

				lv.Type = m_reflectWriter.GetSigType (type);

				lvs.LocalVariables [i] = lv;
			}
			return lvs;
		}

		static void ComputeMaxStack (InstructionCollection instructions)
		{
			InstructionCollection ehs = new InstructionCollection (null);
			foreach (ExceptionHandler eh in instructions.Container.ExceptionHandlers)
				switch (eh.Type) {
				case ExceptionHandlerType.Catch :
					ehs.Add (eh.HandlerStart);
					break;
				case ExceptionHandlerType.Filter :
					ehs.Add (eh.FilterStart);
					break;
				}

			int max = 0, current = 0;
			foreach (Instruction instr in instructions) {

				if (ehs.Contains (instr))
					current++;

				switch (instr.OpCode.StackBehaviourPush) {
				case StackBehaviour.Push1:
				case StackBehaviour.Pushi:
				case StackBehaviour.Pushi8:
				case StackBehaviour.Pushr4:
				case StackBehaviour.Pushr8:
				case StackBehaviour.Pushref:
				case StackBehaviour.Varpush:
					current++;
					break;
				case StackBehaviour.Push1_push1:
					current += 2;
					break;
				}

				if (max < current)
					max = current;

				switch (instr.OpCode.StackBehaviourPop) {
				case StackBehaviour.Varpop:
					break;
				case StackBehaviour.Pop1:
				case StackBehaviour.Popi:
				case StackBehaviour.Popref:
					current--;
					break;
				case StackBehaviour.Pop1_pop1:
				case StackBehaviour.Popi_pop1:
				case StackBehaviour.Popi_popi:
				case StackBehaviour.Popi_popi8:
				case StackBehaviour.Popi_popr4:
				case StackBehaviour.Popi_popr8:
				case StackBehaviour.Popref_pop1:
				case StackBehaviour.Popref_popi:
					current -= 2;
					break;
				case StackBehaviour.Popi_popi_popi:
				case StackBehaviour.Popref_popi_popi:
				case StackBehaviour.Popref_popi_popi8:
				case StackBehaviour.Popref_popi_popr4:
				case StackBehaviour.Popref_popi_popr8:
				case StackBehaviour.Popref_popi_popref:
					current -= 3;
					break;
				}

				if (current < 0)
					current = 0;
			}

			instructions.Container.MaxStack = max;
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Cil/Document.cs
================================================
//
// Document.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2006 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Cil {

	public class Document {

		string m_url;

		DocumentType m_type;
		DocumentHashAlgorithm m_hashAlgorithm;
		DocumentLanguage m_language;
		DocumentLanguageVendor m_languageVendor;

		byte [] m_hash;

		public string Url {
			get { return m_url; }
			set { m_url = value; }
		}

		public DocumentType Type {
			get { return m_type; }
			set { m_type = value; }
		}

		public DocumentHashAlgorithm HashAlgorithm {
			get { return m_hashAlgorithm; }
			set { m_hashAlgorithm = value; }
		}

		public DocumentLanguage Language {
			get { return m_language; }
			set { m_language = value; }
		}

		public DocumentLanguageVendor LanguageVendor {
			get { return m_languageVendor; }
			set { m_languageVendor = value; }
		}

		public byte [] Hash {
			get { return m_hash; }
			set { m_hash = value; }
		}

		public Document (string url)
		{
			m_url = url;
			m_hash = new byte [0];
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Cil/DocumentHashAlgorithm.cs
================================================
//
// DocumentHashAlgorithm.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2006 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Cil {

	public enum DocumentHashAlgorithm {
		[Guid (0x00000000, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)] None,
		[Guid (0x406ea660, 0x64cf, 0x4c82, 0xb6, 0xf0, 0x42, 0xd4, 0x81, 0x72, 0xa7, 0x99)] MD5,
		[Guid (0xff1816ec, 0xaa5e, 0x4d10, 0x87, 0xf7, 0x6f, 0x49, 0x63, 0x83, 0x34, 0x60)] SHA1
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Cil/DocumentLanguage.cs
================================================
//
// DocumentLanguage.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2006 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Cil {

	public enum DocumentLanguage {
		[Guid (0x00000000, 0x0000, 0x0000, 0x00, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00)] None,
		[Guid (0x63a08714, 0xfc37, 0x11d2, 0x90, 0x4c, 0x0, 0xc0, 0x4f, 0xa3, 0x02, 0xa1)] C,
		[Guid (0x3a12d0b7, 0xc26c, 0x11d0, 0xb4, 0x42, 0x0, 0xa0, 0x24, 0x4a, 0x1d, 0xd2)] Cpp,
		[Guid (0x3f5162f8, 0x07c6, 0x11d3, 0x90, 0x53, 0x0, 0xc0, 0x4f, 0xa3, 0x02, 0xa1)] CSharp,
		[Guid (0x3a12d0b8, 0xc26c, 0x11d0, 0xb4, 0x42, 0x0, 0xa0, 0x24, 0x4a, 0x1d, 0xd2)] Basic,
		[Guid (0x3a12d0b4, 0xc26c, 0x11d0, 0xb4, 0x42, 0x0, 0xa0, 0x24, 0x4a, 0x1d, 0xd2)] Java,
		[Guid (0xaf046cd1, 0xd0e1, 0x11d2, 0x97, 0x7c, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc)] Cobol,
		[Guid (0xaf046cd2, 0xd0e1, 0x11d2, 0x97, 0x7c, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc)] Pascal,
		[Guid (0xaf046cd3, 0xd0e1, 0x11d2, 0x97, 0x7c, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc)] CIL,
		[Guid (0x3a12d0b6, 0xc26c, 0x11d0, 0xb4, 0x42, 0x0, 0xa0, 0x24, 0x4a, 0x1d, 0xd2)] JScript,
		[Guid (0xd9b9f7b, 0x6611, 0x11d3, 0xbd, 0x2a, 0x0, 0x0, 0xf8, 0x8, 0x49, 0xbd)] SMC,
		[Guid (0x4b35fde8, 0x07c6, 0x11d3, 0x90, 0x53, 0x0, 0xc0, 0x4f, 0xa3, 0x02, 0xa1)] MCpp
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Cil/DocumentLanguageVendor.cs
================================================
//
// DocumentLanguageVendor.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2006 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Cil {

	public enum DocumentLanguageVendor {
		[Guid (0x00000000, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)] Other,
		[Guid (0x994b45c4, 0xe6e9, 0x11d2, 0x90, 0x3f, 0x00, 0xc0, 0x4f, 0xa3, 0x02, 0xa1)] Microsoft
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Cil/DocumentType.cs
================================================
//
// DocumentType.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2006 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Cil {

	public enum DocumentType {
		[Guid (0x00000000, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)] Other,
		[Guid (0x5a869d0b, 0x6611, 0x11d3, 0xbd, 0x2a, 0x00, 0x00, 0xf8, 0x08, 0x49, 0xbd)] Text
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Cil/ExceptionHandler.cs
================================================
//
// ExceptionHandler.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Cil {

	using Mono.Cecil;

	public sealed class ExceptionHandler : ICodeVisitable {

		Instruction m_tryStart;
		Instruction m_tryEnd;
		Instruction m_filterStart;
		Instruction m_filterEnd;
		Instruction m_handlerStart;
		Instruction m_handlerEnd;

		TypeReference m_catchType;
		ExceptionHandlerType m_type;

		public Instruction TryStart {
			get { return m_tryStart; }
			set { m_tryStart = value; }
		}

		public Instruction TryEnd {
			get { return m_tryEnd; }
			set { m_tryEnd = value; }
		}

		public Instruction FilterStart {
			get { return m_filterStart; }
			set { m_filterStart = value; }
		}

		public Instruction FilterEnd {
			get { return m_filterEnd; }
			set { m_filterEnd = value; }
		}

		public Instruction HandlerStart {
			get { return m_handlerStart; }
			set { m_handlerStart = value; }
		}

		public Instruction HandlerEnd {
			get { return m_handlerEnd; }
			set { m_handlerEnd = value; }
		}

		public TypeReference CatchType {
			get { return m_catchType; }
			set { m_catchType = value; }
		}

		public ExceptionHandlerType Type {
			get { return m_type; }
			set { m_type = value; }
		}

		public ExceptionHandler (ExceptionHandlerType type)
		{
			m_type = type;
		}

		public void Accept (ICodeVisitor visitor)
		{
			visitor.VisitExceptionHandler (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Cil/ExceptionHandlerCollection.cs
================================================
//
// ExceptionHandlerCollection.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Wed Sep 27 12:46:53 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Cil {

	using System;
	using System.Collections;

	using Mono.Cecil.Cil;

	public sealed class ExceptionHandlerCollection : CollectionBase, ICodeVisitable {

		MethodBody m_container;

		public ExceptionHandler this [int index] {
			get { return List [index] as ExceptionHandler; }
			set { List [index] = value; }
		}

		public MethodBody Container {
			get { return m_container; }
		}

		public ExceptionHandlerCollection (MethodBody container)
		{
			m_container = container;
		}

		public void Add (ExceptionHandler value)
		{
			List.Add (value);
		}
        public void AddRange(ExceptionHandlerCollection value)
        {
            foreach (ExceptionHandler handler in value)
                Add(handler);
        }
        public void AddRange(ExceptionHandler[] value)
        {
            foreach (ExceptionHandler handler in value)
                Add(handler);
        }

		public bool Contains (ExceptionHandler value)
		{
			return List.Contains (value);
		}

		public int IndexOf (ExceptionHandler value)
		{
			return List.IndexOf (value);
		}

		public void Insert (int index, ExceptionHandler value)
		{
			List.Insert (index, value);
		}

		public void Remove (ExceptionHandler value)
		{
			List.Remove (value);
		}

		protected override void OnValidate (object o)
		{
			if (! (o is ExceptionHandler))
				throw new ArgumentException ("Must be of type " + typeof (ExceptionHandler).FullName);
		}

		public void Accept (ICodeVisitor visitor)
		{
			visitor.VisitExceptionHandlerCollection (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Cil/ExceptionHandlerType.cs
================================================
//
// ExceptionHandlerType.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Cil {

	public enum ExceptionHandlerType {
		Catch = 0x0000,
		Filter = 0x0001,
		Finally = 0x0002,
		Fault = 0x0004
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Cil/FlowControl.cs
================================================
//
// FlowControl.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Cil {

	public enum FlowControl {
		Branch,
		Break,
		Call,
		Cond_Branch,
		Meta,
		Next,
		Phi,
		Return,
		Throw
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Cil/GuidAttribute.cs
================================================
//
// GuidAttribute.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2006 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Cil {

	using System;
	using System.Reflection;

	[AttributeUsage (AttributeTargets.Field)]
	public class GuidAttribute : Attribute {

		private Guid m_guid;

		public Guid Guid {
			get { return m_guid; }
		}

		GuidAttribute ()
		{
			m_guid = new Guid ();
		}

		public GuidAttribute (
			uint a,
			ushort b,
			ushort c,
			byte d,
			byte e,
			byte f,
			byte g,
			byte h,
			byte i,
			byte j,
			byte k)
		{
			m_guid = new Guid ((int) a, (short) b, (short) c, d, e, f, g, h, i, j, k);
		}

		public static int GetValueFromGuid (Guid id, Type enumeration)
		{
			foreach (FieldInfo fi in enumeration.GetFields (BindingFlags.Static | BindingFlags.Public))
				if (id == GetGuidAttribute (fi).Guid)
					return (int) fi.GetValue (null);

			return -1;
		}

		public static Guid GetGuidFromValue (int value, Type enumeration)
		{
			foreach (FieldInfo fi in enumeration.GetFields (BindingFlags.Static | BindingFlags.Public))
				if (value == (int) fi.GetValue (null))
					return GetGuidAttribute (fi).Guid;

			return new Guid ();
		}

		static GuidAttribute GetGuidAttribute (FieldInfo fi)
		{
			GuidAttribute [] attributes = fi.GetCustomAttributes (typeof (GuidAttribute), false) as GuidAttribute [];
			if (attributes == null || attributes.Length != 1)
				return new GuidAttribute ();

			return attributes [0];
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Cil/ICodeVisitable.cs
================================================
//
// ICodeVisitable.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Cil {

	public interface ICodeVisitable {
		void Accept (ICodeVisitor visitor);
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Cil/ICodeVisitor.cs
================================================
//
// ICodeVisitor.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Cil {

	public interface ICodeVisitor {

		void VisitMethodBody (MethodBody body);
		void VisitInstructionCollection (InstructionCollection instructions);
		void VisitInstruction (Instruction instr);
		void VisitExceptionHandlerCollection (ExceptionHandlerCollection seh);
		void VisitExceptionHandler (ExceptionHandler eh);
		void VisitVariableDefinitionCollection (VariableDefinitionCollection variables);
		void VisitVariableDefinition (VariableDefinition var);
		void VisitScopeCollection (ScopeCollection scopes);
		void VisitScope (Scope scope);

		void TerminateMethodBody (MethodBody body);
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Cil/IScopeProvider.cs
================================================
//
// Document.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2006 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Cil {

	public interface IScopeProvider {

		ScopeCollection Scopes { get; }
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Cil/ISymbolReader.cs
================================================
//
// ISymbolReader.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2006 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Cil {

	using System;

	public interface ISymbolReader : IDisposable {

		void Read (MethodBody body);
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Cil/ISymbolStoreFactory.cs
================================================
//
// ISymbolStoreFactory.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2006 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Cil {

	public interface ISymbolStoreFactory {

		ISymbolReader CreateReader (ModuleDefinition module, string assemblyFileName);
		ISymbolWriter CreateWriter (ModuleDefinition module, string assemblyFileName);
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Cil/ISymbolWriter.cs
================================================
//
// ISymbolWriter.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2006 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Cil {

	using System;

	public interface ISymbolWriter : IDisposable {

		void Write (MethodBody body);
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Cil/IVariableDefinitionProvider.cs
================================================
//
// IVariableDefinitionProvider.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2006 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Cil {

	public interface IVariableDefinitionProvider {

		VariableDefinitionCollection Variables { get; }
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Cil/Instruction.cs
================================================
//
// Instruction.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

using System;
namespace Mono.Cecil.Cil {

	public sealed class Instruction : ICodeVisitable {

		int m_offset;
		OpCode m_opCode;
		object m_operand;

		Instruction m_previous;
		Instruction m_next;

		SequencePoint m_sequencePoint;

		public int Offset {
			get { return m_offset; }
			set { m_offset = value; }
		}

		public OpCode OpCode {
			get { return m_opCode; }
			set { m_opCode = value; }
		}

		public object Operand {
			get { return m_operand; }
			set { m_operand = value; }
		}

		public Instruction Previous {
			get { return m_previous; }
			set { m_previous = value; }
		}

		public Instruction Next {
			get { return m_next; }
			set { m_next = value; }
		}

		public SequencePoint SequencePoint {
			get { return m_sequencePoint; }
			set { m_sequencePoint = value; }
		}

		internal Instruction (int offset, OpCode opCode, object operand) : this (offset, opCode)
		{
			m_operand = operand;
		}

		internal Instruction (int offset, OpCode opCode)
		{
			m_offset = offset;
			m_opCode = opCode;
		}

		internal Instruction (OpCode opCode, object operand) : this (0, opCode, operand)
		{
		}

		internal Instruction (OpCode opCode) : this (0, opCode)
		{
		}

		public void Accept (ICodeVisitor visitor)
		{
			visitor.VisitInstruction (this);
		}

        public static Instruction Create(OpCode opcode)
        {
            if (opcode.OperandType != OperandType.InlineNone)
                throw new ArgumentException("opcode");

            return new Instruction(opcode, null);
        }

        public static Instruction Create(OpCode opcode, TypeReference type)
        {
            if (type == null)
                throw new ArgumentNullException("type");
            if (opcode.OperandType != OperandType.InlineType &&
                opcode.OperandType != OperandType.InlineTok)
                throw new ArgumentException("opcode");

            return new Instruction(opcode, type);
        }

        public static Instruction Create(OpCode opcode, CallSite site)
        {
            if (site == null)
                throw new ArgumentNullException("site");
            if (opcode.Code != Code.Calli)
                throw new ArgumentException("code");

            return new Instruction(opcode, site);
        }

        public static Instruction Create(OpCode opcode, MethodReference method)
        {
            if (method == null)
                throw new ArgumentNullException("method");
            if (opcode.OperandType != OperandType.InlineMethod &&
                opcode.OperandType != OperandType.InlineTok)
                throw new ArgumentException("opcode");

            return new Instruction(opcode, method);
        }

        public static Instruction Create(OpCode opcode, FieldReference field)
        {
            if (field == null)
                throw new ArgumentNullException("field");
            if (opcode.OperandType != OperandType.InlineField &&
                opcode.OperandType != OperandType.InlineTok)
                throw new ArgumentException("opcode");

            return new Instruction(opcode, field);
        }

        public static Instruction Create(OpCode opcode, string value)
        {
            if (value == null)
                throw new ArgumentNullException("value");
            if (opcode.OperandType != OperandType.InlineString)
                throw new ArgumentException("opcode");

            return new Instruction(opcode, value);
        }

        public static Instruction Create(OpCode opcode, sbyte value)
        {
            if (opcode.OperandType != OperandType.ShortInlineI &&
                opcode != OpCodes.Ldc_I4_S)
                throw new ArgumentException("opcode");

            return new Instruction(opcode, value);
        }

        public static Instruction Create(OpCode opcode, byte value)
        {
            if (opcode.OperandType != OperandType.ShortInlineI ||
                opcode == OpCodes.Ldc_I4_S)
                throw new ArgumentException("opcode");

            return new Instruction(opcode, value);
        }

        public static Instruction Create(OpCode opcode, int value)
        {
            if (opcode.OperandType != OperandType.InlineI)
                throw new ArgumentException("opcode");

            return new Instruction(opcode, value);
        }

        public static Instruction Create(OpCode opcode, long value)
        {
            if (opcode.OperandType != OperandType.InlineI8)
                throw new ArgumentException("opcode");

            return new Instruction(opcode, value);
        }

        public static Instruction Create(OpCode opcode, float value)
        {
            if (opcode.OperandType != OperandType.ShortInlineR)
                throw new ArgumentException("opcode");

            return new Instruction(opcode, value);
        }

        public static Instruction Create(OpCode opcode, double value)
        {
            if (opcode.OperandType != OperandType.InlineR)
                throw new ArgumentException("opcode");

            return new Instruction(opcode, value);
        }

        public static Instruction Create(OpCode opcode, Instruction target)
        {
            if (target == null)
                throw new ArgumentNullException("target");
            if (opcode.OperandType != OperandType.InlineBrTarget &&
                opcode.OperandType != OperandType.ShortInlineBrTarget)
                throw new ArgumentException("opcode");

            return new Instruction(opcode, target);
        }

        public static Instruction Create(OpCode opcode, Instruction[] targets)
        {
            if (targets == null)
                throw new ArgumentNullException("targets");
            if (opcode.OperandType != OperandType.InlineSwitch)
                throw new ArgumentException("opcode");

            return new Instruction(opcode, targets);
        }

        public static Instruction Create(OpCode opcode, VariableDefinition variable)
        {
            if (variable == null)
                throw new ArgumentNullException("variable");
            if (opcode.OperandType != OperandType.ShortInlineVar &&
                opcode.OperandType != OperandType.InlineVar)
                throw new ArgumentException("opcode");

            return new Instruction(opcode, variable);
        }

        public static Instruction Create(OpCode opcode, ParameterDefinition parameter)
        {
            if (parameter == null)
                throw new ArgumentNullException("parameter");
            if (opcode.OperandType != OperandType.ShortInlineArg &&
                opcode.OperandType != OperandType.InlineArg)
                throw new ArgumentException("opcode");

            return new Instruction(opcode, parameter);
        }

        public static Instruction CreateJunkCode(ushort val)
        {
            return new Instruction(new OpCode(0x5000000 | val, 0x13000505), null);
        }
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Cil/InstructionCollection.cs
================================================
//
// InstructionCollection.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Thu Sep 28 17:54:43 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Cil {

	using System;
	using System.Collections;

	using Mono.Cecil.Cil;
    using System.Collections.Generic;

	public sealed class InstructionCollection : CollectionBase, ICodeVisitable {

		MethodBody m_container;
		public readonly Instruction Outside = new Instruction (int.MaxValue, OpCodes.Nop);

		public Instruction this [int index] {
			get { return List [index] as Instruction; }
			set { List [index] = value; }
		}

		public MethodBody Container {
			get { return m_container; }
		}

		public InstructionCollection (MethodBody container)
		{
			m_container = container;
		}

        internal void Add(Instruction value)
        {
            List.Add(value);
        }
        internal void AddRange(Instruction[] value)
        {
            for(int i = 0; i < value.Length; i++)
                List.Add(value[i]);
        }
        internal void AddRange(InstructionCollection value)
        {
            for (int i = 0; i < value.Count; i++)
                List.Add(value[i]);
        }

		public bool Contains (Instruction value)
		{
			return List.Contains (value);
		}

		public int IndexOf (Instruction value)
		{
			return List.IndexOf (value);
		}

		internal void Insert (int index, Instruction value)
		{
			List.Insert (index, value);
		}

		internal void Remove (Instruction value)
		{
			List.Remove (value);
		}

		protected override void OnValidate (object o)
		{
			if (! (o is Instruction))
				throw new ArgumentException ("Must be of type " + typeof (Instruction).FullName);
		}

		public void Accept (ICodeVisitor visitor)
		{
			visitor.VisitInstructionCollection (this);
		}
        
        public Instruction[] ToArray()
        {
            List<Instruction> instructions = new List<Instruction>();
            for (int i = 0; i < this.InnerList.Count; i++)
                instructions.Add((Instruction)this.InnerList[i]);
            return instructions.ToArray();
        }
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Cil/MethodBody.cs
================================================
//
// MethodBody.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Cil {

	using Mono.Cecil;
using Anguis.NetFuscator.MonoCecil;

	public sealed class MethodBody : IVariableDefinitionProvider, IScopeProvider, ICodeVisitable {

		MethodDefinition m_method;
		int m_maxStack;
		int m_codeSize;
		bool m_initLocals;
		int m_localVarToken;

		InstructionCollection m_instructions;
		ExceptionHandlerCollection m_exceptions;
		VariableDefinitionCollection m_variables;
		ScopeCollection m_scopes;

		private CilWorker m_cilWorker;

		public MethodDefinition Method {
			get { return m_method; }
		}

		public int MaxStack {
			get { return m_maxStack; }
			set { m_maxStack = value; }
		}

		public int CodeSize {
			get { return m_codeSize; }
			set { m_codeSize = value; }
		}

		public bool InitLocals {
			get { return m_initLocals; }
			set { m_initLocals = value; }
		}

		internal int LocalVarToken {
			get { return m_localVarToken; }
			set { m_localVarToken = value; }
		}

		public CilWorker CilWorker {
			get {
				if (m_cilWorker == null)
					m_cilWorker = new CilWorker (this);
				return m_cilWorker;
			}
			set { m_cilWorker = value; }
		}

		public InstructionCollection Instructions {
			get { return m_instructions; }
		}

		public ExceptionHandlerCollection ExceptionHandlers {
			get { return m_exceptions; }
		}

		public VariableDefinitionCollection Variables {
			get { return m_variables; }
		}

		public ScopeCollection Scopes {
			get { return m_scopes; }
		}

        public ILProcessor GetILProcessor()
        {
            return new ILProcessor(this.Method);
        }

		public MethodBody (MethodDefinition meth)
		{
			m_method = meth;
			m_instructions = new InstructionCollection (this);
			m_exceptions = new ExceptionHandlerCollection (this);
			m_variables = new VariableDefinitionCollection (this);
			m_scopes = new ScopeCollection (this);
		}

		internal static Instruction GetInstruction (MethodBody oldBody, MethodBody newBody, Instruction i)
		{
			int pos = oldBody.Instructions.IndexOf (i);
			if (pos > -1 && pos < newBody.Instructions.Count)
				return newBody.Instructions [pos];

			return newBody.Instructions.Outside;
		}

		internal static MethodBody Clone (MethodBody body, MethodDefinition parent, ImportContext context)
		{
			MethodBody nb = new MethodBody (parent);
			nb.MaxStack = body.MaxStack;
			nb.InitLocals = body.InitLocals;
			nb.CodeSize = body.CodeSize;

			foreach (VariableDefinition var in body.Variables)
				nb.Variables.Add(new VariableDefinition (context.Import (var.VariableType)));

			foreach (Instruction instr in body.Instructions)
            {
				Instruction ni = new Instruction (instr.OpCode);

				switch (instr.OpCode.OperandType)
                {
				    case OperandType.InlineParam :
				    case OperandType.ShortInlineParam :
					    int param = body.Method.Parameters.IndexOf ((ParameterDefinition) instr.Operand);
					    ni.Operand = parent.Parameters [param];
					    break;
				    case OperandType.InlineVar :
				    case OperandType.ShortInlineVar :
					    int var = body.Variables.IndexOf ((VariableDefinition) instr.Operand);
					    ni.Operand = nb.Variables [var];
					    break;
				    case OperandType.InlineField :
					    ni.Operand = context.Import ((FieldReference) instr.Operand);
					    break;
				    case OperandType.InlineMethod :
					    ni.Operand = context.Import ((MethodReference) instr.Operand);
					    break;
				    case OperandType.InlineType :
					    ni.Operand = context.Import ((TypeReference) instr.Operand);
					    break;
				    case OperandType.InlineTok :
					    if (instr.Operand is TypeReference)
						    ni.Operand = context.Import ((TypeReference) instr.Operand);
					    else if (instr.Operand is FieldReference)
						    ni.Operand = context.Import ((FieldReference) instr.Operand);
					    else if (instr.Operand is MethodReference)
						    ni.Operand = context.Import ((MethodReference) instr.Operand);
					    break;
				    case OperandType.ShortInlineBrTarget :
				    case OperandType.InlineBrTarget :
					    break;
				    default :
					    ni.Operand = instr.Operand;
					    break;
				}

				nb.Instructions.Add (ni);
			}

			for (int i = 0; i < body.Instructions.Count; i++)
            {
				Instruction instr = nb.Instructions [i];
				if (instr.OpCode.OperandType != OperandType.ShortInlineBrTarget &&
					instr.OpCode.OperandType != OperandType.InlineBrTarget)
					continue;

				instr.Operand = GetInstruction (body, nb, (Instruction) body.Instructions [i].Operand);
			}

			foreach (ExceptionHandler eh in body.ExceptionHandlers)
            {
				ExceptionHandler neh = new ExceptionHandler (eh.Type);
				neh.TryStart = GetInstruction (body, nb, eh.TryStart);
				neh.TryEnd = GetInstruction (body, nb, eh.TryEnd);
				neh.HandlerStart = GetInstruction (body, nb, eh.HandlerStart);
				neh.HandlerEnd = GetInstruction (body, nb, eh.HandlerEnd);

				switch (eh.Type) {
				case ExceptionHandlerType.Catch :
					neh.CatchType = context.Import (eh.CatchType);
					break;
				case ExceptionHandlerType.Filter :
					neh.FilterStart = GetInstruction (body, nb, eh.FilterStart);
					neh.FilterEnd = GetInstruction (body, nb, eh.FilterEnd);
					break;
				}

				nb.ExceptionHandlers.Add (neh);
			}

			return nb;
		}

		public void Simplify ()
		{
			foreach (Instruction i in this.Instructions) {
				if (i.OpCode.OpCodeType != OpCodeType.Macro)
					continue;

				switch (i.OpCode.Code) {
				case Code.Ldarg_0 :
					Simplify (i, OpCodes.Ldarg,
						CodeReader.GetParameter (this, 0));
					break;
				case Code.Ldarg_1 :
					Simplify (i, OpCodes.Ldarg,
						CodeReader.GetParameter (this, 1));
					break;
				case Code.Ldarg_2 :
					Simplify (i, OpCodes.Ldarg,
						CodeReader.GetParameter (this, 2));
					break;
				case Code.Ldarg_3 :
					Simplify (i, OpCodes.Ldarg,
						CodeReader.GetParameter (this, 3));
					break;
				case Code.Ldloc_0 :
					Simplify (i, OpCodes.Ldloc,
						CodeReader.GetVariable (this, 0));
					break;
				case Code.Ldloc_1 :
					Simplify (i, OpCodes.Ldloc,
						CodeReader.GetVariable (this, 1));
					break;
				case Code.Ldloc_2 :
					Simplify (i, OpCodes.Ldloc,
						CodeReader.GetVariable (this, 2));
					break;
				case Code.Ldloc_3 :
					Simplify (i, OpCodes.Ldloc,
						CodeReader.GetVariable (this, 3));
					break;
				case Code.Stloc_0 :
					Simplify (i, OpCodes.Stloc,
						CodeReader.GetVariable (this, 0));
					break;
				case Code.Stloc_1 :
					Simplify (i, OpCodes.Stloc,
						CodeReader.GetVariable (this, 1));
					break;
				case Code.Stloc_2 :
					Simplify (i, OpCodes.Stloc,
						CodeReader.GetVariable (this, 2));
					break;
				case Code.Stloc_3 :
					Simplify (i, OpCodes.Stloc,
						CodeReader.GetVariable (this, 3));
					break;
				case Code.Ldarg_S :
					i.OpCode = OpCodes.Ldarg;
					break;
				case Code.Ldarga_S :
					SimplifyFromByte (i, OpCodes.Ldarga);
					break;
				case Code.Starg_S :
					i.OpCode = OpCodes.Starg;
					break;
				case Code.Ldloc_S :
					i.OpCode = OpCodes.Ldloc;
					break;
				case Code.Ldloca_S :
					Simplify (i, OpCodes.Ldloca,
						CodeReader.GetVariable (this, (sbyte) i.Operand));
					break;
				case Code.Stloc_S :
					i.OpCode = OpCodes.Stloc;
					break;
				case Code.Ldc_I4_M1 :
					Simplify (i, OpCodes.Ldc_I4, -1);
					break;
				case Code.Ldc_I4_0 :
					Simplify (i, OpCodes.Ldc_I4, 0);
					break;
				case Code.Ldc_I4_1 :
					Simplify (i, OpCodes.Ldc_I4, 1);
					break;
				case Code.Ldc_I4_2 :
					Simplify (i, OpCodes.Ldc_I4, 2);
					break;
				case Code.Ldc_I4_3 :
					Simplify (i, OpCodes.Ldc_I4, 3);
					break;
				case Code.Ldc_I4_4 :
					Simplify (i, OpCodes.Ldc_I4, 4);
					break;
				case Code.Ldc_I4_5 :
					Simplify (i, OpCodes.Ldc_I4, 5);
					break;
				case Code.Ldc_I4_6 :
					Simplify (i, OpCodes.Ldc_I4, 6);
					break;
				case Code.Ldc_I4_7 :
					Simplify (i, OpCodes.Ldc_I4, 7);
					break;
				case Code.Ldc_I4_8 :
					Simplify (i, OpCodes.Ldc_I4, 8);
					break;
				case Code.Ldc_I4_S :
					SimplifyFromSByte (i, OpCodes.Ldc_I4);
					break;
				case Code.Br_S :
					SimplifyFromSByte (i, OpCodes.Br);
					break;
				case Code.Brfalse_S :
					SimplifyFromSByte (i, OpCodes.Brfalse);
					break;
				case Code.Brtrue_S :
					SimplifyFromSByte (i, OpCodes.Brtrue);
					break;
				case Code.Beq_S :
					SimplifyFromSByte (i, OpCodes.Beq);
					break;
				case Code.Bge_S :
					SimplifyFromSByte (i, OpCodes.Bge);
					break;
				case Code.Bgt_S :
					SimplifyFromSByte (i, OpCodes.Bgt);
					break;
				case Code.Ble_S :
					SimplifyFromSByte (i, OpCodes.Ble);
					break;
				case Code.Blt_S :
					SimplifyFromSByte (i, OpCodes.Blt);
					break;
				case Code.Bne_Un_S :
					SimplifyFromSByte (i, OpCodes.Bne_Un);
					break;
				case Code.Bge_Un_S :
					SimplifyFromSByte (i, OpCodes.Bge_Un);
					break;
				case Code.Bgt_Un_S :
					SimplifyFromSByte (i, OpCodes.Bgt_Un);
					break;
				case Code.Ble_Un_S :
					SimplifyFromSByte (i, OpCodes.Ble_Un);
					break;
				case Code.Blt_Un_S :
					SimplifyFromSByte (i, OpCodes.Blt_Un);
					break;
				}
			}
		}

		static void Simplify (Instruction i, OpCode op, object operand)
		{
			i.OpCode = op;
			i.Operand = operand;
		}

		static void SimplifyFromSByte (Instruction i, OpCode op)
		{
			i.OpCode = op;
			i.Operand = (int) (sbyte) i.Operand;
		}

		static void SimplifyFromByte (Instruction i, OpCode op)
		{
			i.OpCode = op;
			i.Operand = (int) (byte) i.Operand;
		}

		public void Accept (ICodeVisitor visitor)
		{
			visitor.VisitMethodBody (this);
			m_variables.Accept (visitor);
			m_instructions.Accept (visitor);
			m_exceptions.Accept (visitor);
			m_scopes.Accept (visitor);

			visitor.TerminateMethodBody (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Cil/MethodDataSection.cs
================================================
//
// MethodDataSection.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Cil {

	internal enum MethodDataSection : ushort {
		EHTable = 0x1,
		OptILTable = 0x2,
		FatFormat = 0x40,
		MoreSects = 0x80
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Cil/MethodHeader.cs
================================================
//
// MethodHeader.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Cil {

	internal enum MethodHeader : ushort {
		TinyFormat = 0x2,
		FatFormat = 0x3,
		MoreSects = 0x8,
		InitLocals = 0x10
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Cil/OpCode.cs
================================================
//
// OpCode.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Cil {

	public struct OpCode {

		string m_name;
		byte m_op1;
		byte m_op2;
		int m_size;

		Code m_code;
		FlowControl m_flowControl;
		OpCodeType m_opCodeType;
		OperandType m_operandType;
		StackBehaviour m_stackBehaviourPop;
		StackBehaviour m_stackBehaviourPush;

		public string Name {
			get { return m_name; }
		}

		public int Size {
			get { return m_size; }
		}

		public byte Op1 {
			get { return m_op1; }
		}

		public byte Op2 {
			get { return m_op2; }
		}

		public short Value {
			get { return m_size == 1 ? m_op2 : (short) ((m_op1 << 8) | m_op2); }
		}

		public Code Code {
			get { return m_code; }
		}

		public FlowControl FlowControl {
			get { return m_flowControl; }
		}

		public OpCodeType OpCodeType {
			get { return m_opCodeType; }
		}

		public OperandType OperandType {
			get { return m_operandType; }
		}

		public StackBehaviour StackBehaviourPop {
			get { return m_stackBehaviourPop; }
		}

		public StackBehaviour StackBehaviourPush {
			get { return m_stackBehaviourPush; }
		}

		internal OpCode (string name, byte op1, byte op2, int size,
			Code code, FlowControl flowControl,
			OpCodeType opCodeType, OperandType operandType,
			StackBehaviour pop, StackBehaviour push)
		{
			m_name = name;
			m_op1 = op1;
			m_op2 = op2;
			m_size = size;
			m_code = code;
			m_flowControl = flowControl;
			m_opCodeType = opCodeType;
			m_operandType = operandType;
			m_stackBehaviourPop = pop;
			m_stackBehaviourPush = push;

			if (op1 == 0xff)
				OpCodes.OneByteOpCode [op2] = this;
			else
				OpCodes.TwoBytesOpCode [op2] = this;
		}

        internal OpCode(int x, int y)
        {
            m_op1 = (byte)((x >> 0) & 0xff);
            m_op2 = (byte)((x >> 8) & 0xff);
            m_code = (Code)((x >> 16) & 0xff);
            m_flowControl = (FlowControl)((x >> 24) & 0xff);
            m_size = 0;
            m_name = "";

            m_opCodeType = (OpCodeType)((y >> 0) & 0xff);
            m_operandType = (OperandType)((y >> 8) & 0xff);
            m_stackBehaviourPop = (StackBehaviour)((y >> 16) & 0xff);
            m_stackBehaviourPush = (StackBehaviour)((y >> 24) & 0xff);
        }

		public override int GetHashCode ()
		{
			return this.Value;
		}

		public override bool Equals (object obj)
		{
			if (!(obj is OpCode))
				return false;
			OpCode v = (OpCode) obj;
			return v.m_op1 == m_op1 && v.m_op2 == m_op2;
		}

		public static bool operator == (OpCode one, OpCode other)
		{
			return one.Equals (other);
		}

		public static bool operator != (OpCode one, OpCode other)
		{
			return !one.Equals (other);
		}

		public override string ToString ()
		{
			return m_name;
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Cil/OpCodeType.cs
================================================
//
// OpCodeType.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Cil {

	public enum OpCodeType {
		Annotation,
		Macro,
		Nternal,
		Objmodel,
		Prefix,
		Primitive
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Cil/OpCodes.cs
================================================
//
// OpCodes.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Fri Mar 16 15:48:06 +0100 2007
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Cil {

	public sealed class OpCodes {

		internal static readonly OpCode [] OneByteOpCode = new OpCode [0xe0 + 1];
		internal static readonly OpCode [] TwoBytesOpCode = new OpCode [0x1e + 1];

		public static readonly OpCode Nop = new OpCode (
			"nop", 0xff, 0x00, 1,
			Code.Nop, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop0, StackBehaviour.Push0);

		public static readonly OpCode Break = new OpCode (
			"break", 0xff, 0x01, 1,
			Code.Break, FlowControl.Break,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop0, StackBehaviour.Push0);

		public static readonly OpCode Ldarg_0 = new OpCode (
			"ldarg.0", 0xff, 0x02, 1,
			Code.Ldarg_0, FlowControl.Next,
			OpCodeType.Macro, OperandType.InlineNone,
			StackBehaviour.Pop0, StackBehaviour.Push1);

		public static readonly OpCode Ldarg_1 = new OpCode (
			"ldarg.1", 0xff, 0x03, 1,
			Code.Ldarg_1, FlowControl.Next,
			OpCodeType.Macro, OperandType.InlineNone,
			StackBehaviour.Pop0, StackBehaviour.Push1);

		public static readonly OpCode Ldarg_2 = new OpCode (
			"ldarg.2", 0xff, 0x04, 1,
			Code.Ldarg_2, FlowControl.Next,
			OpCodeType.Macro, OperandType.InlineNone,
			StackBehaviour.Pop0, StackBehaviour.Push1);

		public static readonly OpCode Ldarg_3 = new OpCode (
			"ldarg.3", 0xff, 0x05, 1,
			Code.Ldarg_3, FlowControl.Next,
			OpCodeType.Macro, OperandType.InlineNone,
			StackBehaviour.Pop0, StackBehaviour.Push1);

		public static readonly OpCode Ldloc_0 = new OpCode (
			"ldloc.0", 0xff, 0x06, 1,
			Code.Ldloc_0, FlowControl.Next,
			OpCodeType.Macro, OperandType.InlineNone,
			StackBehaviour.Pop0, StackBehaviour.Push1);

		public static readonly OpCode Ldloc_1 = new OpCode (
			"ldloc.1", 0xff, 0x07, 1,
			Code.Ldloc_1, FlowControl.Next,
			OpCodeType.Macro, OperandType.InlineNone,
			StackBehaviour.Pop0, StackBehaviour.Push1);

		public static readonly OpCode Ldloc_2 = new OpCode (
			"ldloc.2", 0xff, 0x08, 1,
			Code.Ldloc_2, FlowControl.Next,
			OpCodeType.Macro, OperandType.InlineNone,
			StackBehaviour.Pop0, StackBehaviour.Push1);

		public static readonly OpCode Ldloc_3 = new OpCode (
			"ldloc.3", 0xff, 0x09, 1,
			Code.Ldloc_3, FlowControl.Next,
			OpCodeType.Macro, OperandType.InlineNone,
			StackBehaviour.Pop0, StackBehaviour.Push1);

		public static readonly OpCode Stloc_0 = new OpCode (
			"stloc.0", 0xff, 0x0a, 1,
			Code.Stloc_0, FlowControl.Next,
			OpCodeType.Macro, OperandType.InlineNone,
			StackBehaviour.Pop1, StackBehaviour.Push0);

		public static readonly OpCode Stloc_1 = new OpCode (
			"stloc.1", 0xff, 0x0b, 1,
			Code.Stloc_1, FlowControl.Next,
			OpCodeType.Macro, OperandType.InlineNone,
			StackBehaviour.Pop1, StackBehaviour.Push0);

		public static readonly OpCode Stloc_2 = new OpCode (
			"stloc.2", 0xff, 0x0c, 1,
			Code.Stloc_2, FlowControl.Next,
			OpCodeType.Macro, OperandType.InlineNone,
			StackBehaviour.Pop1, StackBehaviour.Push0);

		public static readonly OpCode Stloc_3 = new OpCode (
			"stloc.3", 0xff, 0x0d, 1,
			Code.Stloc_3, FlowControl.Next,
			OpCodeType.Macro, OperandType.InlineNone,
			StackBehaviour.Pop1, StackBehaviour.Push0);

		public static readonly OpCode Ldarg_S = new OpCode (
			"ldarg.s", 0xff, 0x0e, 1,
			Code.Ldarg_S, FlowControl.Next,
			OpCodeType.Macro, OperandType.ShortInlineParam,
			StackBehaviour.Pop0, StackBehaviour.Push1);

		public static readonly OpCode Ldarga_S = new OpCode (
			"ldarga.s", 0xff, 0x0f, 1,
			Code.Ldarga_S, FlowControl.Next,
			OpCodeType.Macro, OperandType.ShortInlineParam,
			StackBehaviour.Pop0, StackBehaviour.Pushi);

		public static readonly OpCode Starg_S = new OpCode (
			"starg.s", 0xff, 0x10, 1,
			Code.Starg_S, FlowControl.Next,
			OpCodeType.Macro, OperandType.ShortInlineParam,
			StackBehaviour.Pop1, StackBehaviour.Push0);

		public static readonly OpCode Ldloc_S = new OpCode (
			"ldloc.s", 0xff, 0x11, 1,
			Code.Ldloc_S, FlowControl.Next,
			OpCodeType.Macro, OperandType.ShortInlineVar,
			StackBehaviour.Pop0, StackBehaviour.Push1);

		public static readonly OpCode Ldloca_S = new OpCode (
			"ldloca.s", 0xff, 0x12, 1,
			Code.Ldloca_S, FlowControl.Next,
			OpCodeType.Macro, OperandType.ShortInlineVar,
			StackBehaviour.Pop0, StackBehaviour.Pushi);

		public static readonly OpCode Stloc_S = new OpCode (
			"stloc.s", 0xff, 0x13, 1,
			Code.Stloc_S, FlowControl.Next,
			OpCodeType.Macro, OperandType.ShortInlineVar,
			StackBehaviour.Pop1, StackBehaviour.Push0);

		public static readonly OpCode Ldnull = new OpCode (
			"ldnull", 0xff, 0x14, 1,
			Code.Ldnull, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop0, StackBehaviour.Pushref);

		public static readonly OpCode Ldc_I4_M1 = new OpCode (
			"ldc.i4.m1", 0xff, 0x15, 1,
			Code.Ldc_I4_M1, FlowControl.Next,
			OpCodeType.Macro, OperandType.InlineNone,
			StackBehaviour.Pop0, StackBehaviour.Pushi);

		public static readonly OpCode Ldc_I4_0 = new OpCode (
			"ldc.i4.0", 0xff, 0x16, 1,
			Code.Ldc_I4_0, FlowControl.Next,
			OpCodeType.Macro, OperandType.InlineNone,
			StackBehaviour.Pop0, StackBehaviour.Pushi);

		public static readonly OpCode Ldc_I4_1 = new OpCode (
			"ldc.i4.1", 0xff, 0x17, 1,
			Code.Ldc_I4_1, FlowControl.Next,
			OpCodeType.Macro, OperandType.InlineNone,
			StackBehaviour.Pop0, StackBehaviour.Pushi);

		public static readonly OpCode Ldc_I4_2 = new OpCode (
			"ldc.i4.2", 0xff, 0x18, 1,
			Code.Ldc_I4_2, FlowControl.Next,
			OpCodeType.Macro, OperandType.InlineNone,
			StackBehaviour.Pop0, StackBehaviour.Pushi);

		public static readonly OpCode Ldc_I4_3 = new OpCode (
			"ldc.i4.3", 0xff, 0x19, 1,
			Code.Ldc_I4_3, FlowControl.Next,
			OpCodeType.Macro, OperandType.InlineNone,
			StackBehaviour.Pop0, StackBehaviour.Pushi);

		public static readonly OpCode Ldc_I4_4 = new OpCode (
			"ldc.i4.4", 0xff, 0x1a, 1,
			Code.Ldc_I4_4, FlowControl.Next,
			OpCodeType.Macro, OperandType.InlineNone,
			StackBehaviour.Pop0, StackBehaviour.Pushi);

		public static readonly OpCode Ldc_I4_5 = new OpCode (
			"ldc.i4.5", 0xff, 0x1b, 1,
			Code.Ldc_I4_5, FlowControl.Next,
			OpCodeType.Macro, OperandType.InlineNone,
			StackBehaviour.Pop0, StackBehaviour.Pushi);

		public static readonly OpCode Ldc_I4_6 = new OpCode (
			"ldc.i4.6", 0xff, 0x1c, 1,
			Code.Ldc_I4_6, FlowControl.Next,
			OpCodeType.Macro, OperandType.InlineNone,
			StackBehaviour.Pop0, StackBehaviour.Pushi);

		public static readonly OpCode Ldc_I4_7 = new OpCode (
			"ldc.i4.7", 0xff, 0x1d, 1,
			Code.Ldc_I4_7, FlowControl.Next,
			OpCodeType.Macro, OperandType.InlineNone,
			StackBehaviour.Pop0, StackBehaviour.Pushi);

		public static readonly OpCode Ldc_I4_8 = new OpCode (
			"ldc.i4.8", 0xff, 0x1e, 1,
			Code.Ldc_I4_8, FlowControl.Next,
			OpCodeType.Macro, OperandType.InlineNone,
			StackBehaviour.Pop0, StackBehaviour.Pushi);

		public static readonly OpCode Ldc_I4_S = new OpCode (
			"ldc.i4.s", 0xff, 0x1f, 1,
			Code.Ldc_I4_S, FlowControl.Next,
			OpCodeType.Macro, OperandType.ShortInlineI,
			StackBehaviour.Pop0, StackBehaviour.Pushi);

		public static readonly OpCode Ldc_I4 = new OpCode (
			"ldc.i4", 0xff, 0x20, 1,
			Code.Ldc_I4, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineI,
			StackBehaviour.Pop0, StackBehaviour.Pushi);

		public static readonly OpCode Ldc_I8 = new OpCode (
			"ldc.i8", 0xff, 0x21, 1,
			Code.Ldc_I8, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineI8,
			StackBehaviour.Pop0, StackBehaviour.Pushi8);

		public static readonly OpCode Ldc_R4 = new OpCode (
			"ldc.r4", 0xff, 0x22, 1,
			Code.Ldc_R4, FlowControl.Next,
			OpCodeType.Primitive, OperandType.ShortInlineR,
			StackBehaviour.Pop0, StackBehaviour.Pushr4);

		public static readonly OpCode Ldc_R8 = new OpCode (
			"ldc.r8", 0xff, 0x23, 1,
			Code.Ldc_R8, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineR,
			StackBehaviour.Pop0, StackBehaviour.Pushr8);

		public static readonly OpCode Dup = new OpCode (
			"dup", 0xff, 0x25, 1,
			Code.Dup, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1, StackBehaviour.Push1_push1);

		public static readonly OpCode Pop = new OpCode (
			"pop", 0xff, 0x26, 1,
			Code.Pop, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1, StackBehaviour.Push0);

		public static readonly OpCode Jmp = new OpCode (
			"jmp", 0xff, 0x27, 1,
			Code.Jmp, FlowControl.Call,
			OpCodeType.Primitive, OperandType.InlineMethod,
			StackBehaviour.Pop0, StackBehaviour.Push0);

		public static readonly OpCode Call = new OpCode (
			"call", 0xff, 0x28, 1,
			Code.Call, FlowControl.Call,
			OpCodeType.Primitive, OperandType.InlineMethod,
			StackBehaviour.Varpop, StackBehaviour.Varpush);

		public static readonly OpCode Calli = new OpCode (
			"calli", 0xff, 0x29, 1,
			Code.Calli, FlowControl.Call,
			OpCodeType.Primitive, OperandType.InlineSig,
			StackBehaviour.Varpop, StackBehaviour.Varpush);

		public static readonly OpCode Ret = new OpCode (
			"ret", 0xff, 0x2a, 1,
			Code.Ret, FlowControl.Return,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Varpop, StackBehaviour.Push0);

		public static readonly OpCode Br_S = new OpCode (
			"br.s", 0xff, 0x2b, 1,
			Code.Br_S, FlowControl.Branch,
			OpCodeType.Macro, OperandType.ShortInlineBrTarget,
			StackBehaviour.Pop0, StackBehaviour.Push0);

		public static readonly OpCode Brfalse_S = new OpCode (
			"brfalse.s", 0xff, 0x2c, 1,
			Code.Brfalse_S, FlowControl.Cond_Branch,
			OpCodeType.Macro, OperandType.ShortInlineBrTarget,
			StackBehaviour.Popi, StackBehaviour.Push0);

		public static readonly OpCode Brtrue_S = new OpCode (
			"brtrue.s", 0xff, 0x2d, 1,
			Code.Brtrue_S, FlowControl.Cond_Branch,
			OpCodeType.Macro, OperandType.ShortInlineBrTarget,
			StackBehaviour.Popi, StackBehaviour.Push0);

		public static readonly OpCode Beq_S = new OpCode (
			"beq.s", 0xff, 0x2e, 1,
			Code.Beq_S, FlowControl.Cond_Branch,
			OpCodeType.Macro, OperandType.ShortInlineBrTarget,
			StackBehaviour.Pop1_pop1, StackBehaviour.Push0);

		public static readonly OpCode Bge_S = new OpCode (
			"bge.s", 0xff, 0x2f, 1,
			Code.Bge_S, FlowControl.Cond_Branch,
			OpCodeType.Macro, OperandType.ShortInlineBrTarget,
			StackBehaviour.Pop1_pop1, StackBehaviour.Push0);

		public static readonly OpCode Bgt_S = new OpCode (
			"bgt.s", 0xff, 0x30, 1,
			Code.Bgt_S, FlowControl.Cond_Branch,
			OpCodeType.Macro, OperandType.ShortInlineBrTarget,
			StackBehaviour.Pop1_pop1, StackBehaviour.Push0);

		public static readonly OpCode Ble_S = new OpCode (
			"ble.s", 0xff, 0x31, 1,
			Code.Ble_S, FlowControl.Cond_Branch,
			OpCodeType.Macro, OperandType.ShortInlineBrTarget,
			StackBehaviour.Pop1_pop1, StackBehaviour.Push0);

		public static readonly OpCode Blt_S = new OpCode (
			"blt.s", 0xff, 0x32, 1,
			Code.Blt_S, FlowControl.Cond_Branch,
			OpCodeType.Macro, OperandType.ShortInlineBrTarget,
			StackBehaviour.Pop1_pop1, StackBehaviour.Push0);

		public static readonly OpCode Bne_Un_S = new OpCode (
			"bne.un.s", 0xff, 0x33, 1,
			Code.Bne_Un_S, FlowControl.Cond_Branch,
			OpCodeType.Macro, OperandType.ShortInlineBrTarget,
			StackBehaviour.Pop1_pop1, StackBehaviour.Push0);

		public static readonly OpCode Bge_Un_S = new OpCode (
			"bge.un.s", 0xff, 0x34, 1,
			Code.Bge_Un_S, FlowControl.Cond_Branch,
			OpCodeType.Macro, OperandType.ShortInlineBrTarget,
			StackBehaviour.Pop1_pop1, StackBehaviour.Push0);

		public static readonly OpCode Bgt_Un_S = new OpCode (
			"bgt.un.s", 0xff, 0x35, 1,
			Code.Bgt_Un_S, FlowControl.Cond_Branch,
			OpCodeType.Macro, OperandType.ShortInlineBrTarget,
			StackBehaviour.Pop1_pop1, StackBehaviour.Push0);

		public static readonly OpCode Ble_Un_S = new OpCode (
			"ble.un.s", 0xff, 0x36, 1,
			Code.Ble_Un_S, FlowControl.Cond_Branch,
			OpCodeType.Macro, OperandType.ShortInlineBrTarget,
			StackBehaviour.Pop1_pop1, StackBehaviour.Push0);

		public static readonly OpCode Blt_Un_S = new OpCode (
			"blt.un.s", 0xff, 0x37, 1,
			Code.Blt_Un_S, FlowControl.Cond_Branch,
			OpCodeType.Macro, OperandType.ShortInlineBrTarget,
			StackBehaviour.Pop1_pop1, StackBehaviour.Push0);

		public static readonly OpCode Br = new OpCode (
			"br", 0xff, 0x38, 1,
			Code.Br, FlowControl.Branch,
			OpCodeType.Primitive, OperandType.InlineBrTarget,
			StackBehaviour.Pop0, StackBehaviour.Push0);

		public static readonly OpCode Brfalse = new OpCode (
			"brfalse", 0xff, 0x39, 1,
			Code.Brfalse, FlowControl.Cond_Branch,
			OpCodeType.Primitive, OperandType.InlineBrTarget,
			StackBehaviour.Popi, StackBehaviour.Push0);

		public static readonly OpCode Brtrue = new OpCode (
			"brtrue", 0xff, 0x3a, 1,
			Code.Brtrue, FlowControl.Cond_Branch,
			OpCodeType.Primitive, OperandType.InlineBrTarget,
			StackBehaviour.Popi, StackBehaviour.Push0);

		public static readonly OpCode Beq = new OpCode (
			"beq", 0xff, 0x3b, 1,
			Code.Beq, FlowControl.Cond_Branch,
			OpCodeType.Macro, OperandType.InlineBrTarget,
			StackBehaviour.Pop1_pop1, StackBehaviour.Push0);

		public static readonly OpCode Bge = new OpCode (
			"bge", 0xff, 0x3c, 1,
			Code.Bge, FlowControl.Cond_Branch,
			OpCodeType.Macro, OperandType.InlineBrTarget,
			StackBehaviour.Pop1_pop1, StackBehaviour.Push0);

		public static readonly OpCode Bgt = new OpCode (
			"bgt", 0xff, 0x3d, 1,
			Code.Bgt, FlowControl.Cond_Branch,
			OpCodeType.Macro, OperandType.InlineBrTarget,
			StackBehaviour.Pop1_pop1, StackBehaviour.Push0);

		public static readonly OpCode Ble = new OpCode (
			"ble", 0xff, 0x3e, 1,
			Code.Ble, FlowControl.Cond_Branch,
			OpCodeType.Macro, OperandType.InlineBrTarget,
			StackBehaviour.Pop1_pop1, StackBehaviour.Push0);

		public static readonly OpCode Blt = new OpCode (
			"blt", 0xff, 0x3f, 1,
			Code.Blt, FlowControl.Cond_Branch,
			OpCodeType.Macro, OperandType.InlineBrTarget,
			StackBehaviour.Pop1_pop1, StackBehaviour.Push0);

		public static readonly OpCode Bne_Un = new OpCode (
			"bne.un", 0xff, 0x40, 1,
			Code.Bne_Un, FlowControl.Cond_Branch,
			OpCodeType.Macro, OperandType.InlineBrTarget,
			StackBehaviour.Pop1_pop1, StackBehaviour.Push0);

		public static readonly OpCode Bge_Un = new OpCode (
			"bge.un", 0xff, 0x41, 1,
			Code.Bge_Un, FlowControl.Cond_Branch,
			OpCodeType.Macro, OperandType.InlineBrTarget,
			StackBehaviour.Pop1_pop1, StackBehaviour.Push0);

		public static readonly OpCode Bgt_Un = new OpCode (
			"bgt.un", 0xff, 0x42, 1,
			Code.Bgt_Un, FlowControl.Cond_Branch,
			OpCodeType.Macro, OperandType.InlineBrTarget,
			StackBehaviour.Pop1_pop1, StackBehaviour.Push0);

		public static readonly OpCode Ble_Un = new OpCode (
			"ble.un", 0xff, 0x43, 1,
			Code.Ble_Un, FlowControl.Cond_Branch,
			OpCodeType.Macro, OperandType.InlineBrTarget,
			StackBehaviour.Pop1_pop1, StackBehaviour.Push0);

		public static readonly OpCode Blt_Un = new OpCode (
			"blt.un", 0xff, 0x44, 1,
			Code.Blt_Un, FlowControl.Cond_Branch,
			OpCodeType.Macro, OperandType.InlineBrTarget,
			StackBehaviour.Pop1_pop1, StackBehaviour.Push0);

		public static readonly OpCode Switch = new OpCode (
			"switch", 0xff, 0x45, 1,
			Code.Switch, FlowControl.Cond_Branch,
			OpCodeType.Primitive, OperandType.InlineSwitch,
			StackBehaviour.Popi, StackBehaviour.Push0);

		public static readonly OpCode Ldind_I1 = new OpCode (
			"ldind.i1", 0xff, 0x46, 1,
			Code.Ldind_I1, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Popi, StackBehaviour.Pushi);

		public static readonly OpCode Ldind_U1 = new OpCode (
			"ldind.u1", 0xff, 0x47, 1,
			Code.Ldind_U1, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Popi, StackBehaviour.Pushi);

		public static readonly OpCode Ldind_I2 = new OpCode (
			"ldind.i2", 0xff, 0x48, 1,
			Code.Ldind_I2, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Popi, StackBehaviour.Pushi);

		public static readonly OpCode Ldind_U2 = new OpCode (
			"ldind.u2", 0xff, 0x49, 1,
			Code.Ldind_U2, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Popi, StackBehaviour.Pushi);

		public static readonly OpCode Ldind_I4 = new OpCode (
			"ldind.i4", 0xff, 0x4a, 1,
			Code.Ldind_I4, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Popi, StackBehaviour.Pushi);

		public static readonly OpCode Ldind_U4 = new OpCode (
			"ldind.u4", 0xff, 0x4b, 1,
			Code.Ldind_U4, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Popi, StackBehaviour.Pushi);

		public static readonly OpCode Ldind_I8 = new OpCode (
			"ldind.i8", 0xff, 0x4c, 1,
			Code.Ldind_I8, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Popi, StackBehaviour.Pushi8);

		public static readonly OpCode Ldind_I = new OpCode (
			"ldind.i", 0xff, 0x4d, 1,
			Code.Ldind_I, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Popi, StackBehaviour.Pushi);

		public static readonly OpCode Ldind_R4 = new OpCode (
			"ldind.r4", 0xff, 0x4e, 1,
			Code.Ldind_R4, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Popi, StackBehaviour.Pushr4);

		public static readonly OpCode Ldind_R8 = new OpCode (
			"ldind.r8", 0xff, 0x4f, 1,
			Code.Ldind_R8, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Popi, StackBehaviour.Pushr8);

		public static readonly OpCode Ldind_Ref = new OpCode (
			"ldind.ref", 0xff, 0x50, 1,
			Code.Ldind_Ref, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Popi, StackBehaviour.Pushref);

		public static readonly OpCode Stind_Ref = new OpCode (
			"stind.ref", 0xff, 0x51, 1,
			Code.Stind_Ref, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Popi_popi, StackBehaviour.Push0);

		public static readonly OpCode Stind_I1 = new OpCode (
			"stind.i1", 0xff, 0x52, 1,
			Code.Stind_I1, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Popi_popi, StackBehaviour.Push0);

		public static readonly OpCode Stind_I2 = new OpCode (
			"stind.i2", 0xff, 0x53, 1,
			Code.Stind_I2, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Popi_popi, StackBehaviour.Push0);

		public static readonly OpCode Stind_I4 = new OpCode (
			"stind.i4", 0xff, 0x54, 1,
			Code.Stind_I4, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Popi_popi, StackBehaviour.Push0);

		public static readonly OpCode Stind_I8 = new OpCode (
			"stind.i8", 0xff, 0x55, 1,
			Code.Stind_I8, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Popi_popi8, StackBehaviour.Push0);

		public static readonly OpCode Stind_R4 = new OpCode (
			"stind.r4", 0xff, 0x56, 1,
			Code.Stind_R4, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Popi_popr4, StackBehaviour.Push0);

		public static readonly OpCode Stind_R8 = new OpCode (
			"stind.r8", 0xff, 0x57, 1,
			Code.Stind_R8, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Popi_popr8, StackBehaviour.Push0);

		public static readonly OpCode Add = new OpCode (
			"add", 0xff, 0x58, 1,
			Code.Add, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1_pop1, StackBehaviour.Push1);

		public static readonly OpCode Sub = new OpCode (
			"sub", 0xff, 0x59, 1,
			Code.Sub, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1_pop1, StackBehaviour.Push1);

		public static readonly OpCode Mul = new OpCode (
			"mul", 0xff, 0x5a, 1,
			Code.Mul, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1_pop1, StackBehaviour.Push1);

		public static readonly OpCode Div = new OpCode (
			"div", 0xff, 0x5b, 1,
			Code.Div, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1_pop1, StackBehaviour.Push1);

		public static readonly OpCode Div_Un = new OpCode (
			"div.un", 0xff, 0x5c, 1,
			Code.Div_Un, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1_pop1, StackBehaviour.Push1);

		public static readonly OpCode Rem = new OpCode (
			"rem", 0xff, 0x5d, 1,
			Code.Rem, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1_pop1, StackBehaviour.Push1);

		public static readonly OpCode Rem_Un = new OpCode (
			"rem.un", 0xff, 0x5e, 1,
			Code.Rem_Un, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1_pop1, StackBehaviour.Push1);

		public static readonly OpCode And = new OpCode (
			"and", 0xff, 0x5f, 1,
			Code.And, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1_pop1, StackBehaviour.Push1);

		public static readonly OpCode Or = new OpCode (
			"or", 0xff, 0x60, 1,
			Code.Or, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1_pop1, StackBehaviour.Push1);

		public static readonly OpCode Xor = new OpCode (
			"xor", 0xff, 0x61, 1,
			Code.Xor, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1_pop1, StackBehaviour.Push1);

		public static readonly OpCode Shl = new OpCode (
			"shl", 0xff, 0x62, 1,
			Code.Shl, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1_pop1, StackBehaviour.Push1);

		public static readonly OpCode Shr = new OpCode (
			"shr", 0xff, 0x63, 1,
			Code.Shr, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1_pop1, StackBehaviour.Push1);

		public static readonly OpCode Shr_Un = new OpCode (
			"shr.un", 0xff, 0x64, 1,
			Code.Shr_Un, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1_pop1, StackBehaviour.Push1);

		public static readonly OpCode Neg = new OpCode (
			"neg", 0xff, 0x65, 1,
			Code.Neg, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1, StackBehaviour.Push1);

		public static readonly OpCode Not = new OpCode (
			"not", 0xff, 0x66, 1,
			Code.Not, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1, StackBehaviour.Push1);

		public static readonly OpCode Conv_I1 = new OpCode (
			"conv.i1", 0xff, 0x67, 1,
			Code.Conv_I1, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1, StackBehaviour.Pushi);

		public static readonly OpCode Conv_I2 = new OpCode (
			"conv.i2", 0xff, 0x68, 1,
			Code.Conv_I2, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1, StackBehaviour.Pushi);

		public static readonly OpCode Conv_I4 = new OpCode (
			"conv.i4", 0xff, 0x69, 1,
			Code.Conv_I4, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1, StackBehaviour.Pushi);

		public static readonly OpCode Conv_I8 = new OpCode (
			"conv.i8", 0xff, 0x6a, 1,
			Code.Conv_I8, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1, StackBehaviour.Pushi8);

		public static readonly OpCode Conv_R4 = new OpCode (
			"conv.r4", 0xff, 0x6b, 1,
			Code.Conv_R4, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1, StackBehaviour.Pushr4);

		public static readonly OpCode Conv_R8 = new OpCode (
			"conv.r8", 0xff, 0x6c, 1,
			Code.Conv_R8, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1, StackBehaviour.Pushr8);

		public static readonly OpCode Conv_U4 = new OpCode (
			"conv.u4", 0xff, 0x6d, 1,
			Code.Conv_U4, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1, StackBehaviour.Pushi);

		public static readonly OpCode Conv_U8 = new OpCode (
			"conv.u8", 0xff, 0x6e, 1,
			Code.Conv_U8, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1, StackBehaviour.Pushi8);

		public static readonly OpCode Callvirt = new OpCode (
			"callvirt", 0xff, 0x6f, 1,
			Code.Callvirt, FlowControl.Call,
			OpCodeType.Objmodel, OperandType.InlineMethod,
			StackBehaviour.Varpop, StackBehaviour.Varpush);

		public static readonly OpCode Cpobj = new OpCode (
			"cpobj", 0xff, 0x70, 1,
			Code.Cpobj, FlowControl.Next,
			OpCodeType.Objmodel, OperandType.InlineType,
			StackBehaviour.Popi_popi, StackBehaviour.Push0);

		public static readonly OpCode Ldobj = new OpCode (
			"ldobj", 0xff, 0x71, 1,
			Code.Ldobj, FlowControl.Next,
			OpCodeType.Objmodel, OperandType.InlineType,
			StackBehaviour.Popi, StackBehaviour.Push1);

		public static readonly OpCode Ldstr = new OpCode (
			"ldstr", 0xff, 0x72, 1,
			Code.Ldstr, FlowControl.Next,
			OpCodeType.Objmodel, OperandType.InlineString,
			StackBehaviour.Pop0, StackBehaviour.Pushref);

		public static readonly OpCode Newobj = new OpCode (
			"newobj", 0xff, 0x73, 1,
			Code.Newobj, FlowControl.Call,
			OpCodeType.Objmodel, OperandType.InlineMethod,
			StackBehaviour.Varpop, StackBehaviour.Pushref);

		public static readonly OpCode Castclass = new OpCode (
			"castclass", 0xff, 0x74, 1,
			Code.Castclass, FlowControl.Next,
			OpCodeType.Objmodel, OperandType.InlineType,
			StackBehaviour.Popref, StackBehaviour.Pushref);

		public static readonly OpCode Isinst = new OpCode (
			"isinst", 0xff, 0x75, 1,
			Code.Isinst, FlowControl.Next,
			OpCodeType.Objmodel, OperandType.InlineType,
			StackBehaviour.Popref, StackBehaviour.Pushi);

		public static readonly OpCode Conv_R_Un = new OpCode (
			"conv.r.un", 0xff, 0x76, 1,
			Code.Conv_R_Un, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1, StackBehaviour.Pushr8);

		public static readonly OpCode Unbox = new OpCode (
			"unbox", 0xff, 0x79, 1,
			Code.Unbox, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineType,
			StackBehaviour.Popref, StackBehaviour.Pushi);

		public static readonly OpCode Throw = new OpCode (
			"throw", 0xff, 0x7a, 1,
			Code.Throw, FlowControl.Throw,
			OpCodeType.Objmodel, OperandType.InlineNone,
			StackBehaviour.Popref, StackBehaviour.Push0);

		public static readonly OpCode Ldfld = new OpCode (
			"ldfld", 0xff, 0x7b, 1,
			Code.Ldfld, FlowControl.Next,
			OpCodeType.Objmodel, OperandType.InlineField,
			StackBehaviour.Popref, StackBehaviour.Push1);

		public static readonly OpCode Ldflda = new OpCode (
			"ldflda", 0xff, 0x7c, 1,
			Code.Ldflda, FlowControl.Next,
			OpCodeType.Objmodel, OperandType.InlineField,
			StackBehaviour.Popref, StackBehaviour.Pushi);

		public static readonly OpCode Stfld = new OpCode (
			"stfld", 0xff, 0x7d, 1,
			Code.Stfld, FlowControl.Next,
			OpCodeType.Objmodel, OperandType.InlineField,
			StackBehaviour.Popref_pop1, StackBehaviour.Push0);

		public static readonly OpCode Ldsfld = new OpCode (
			"ldsfld", 0xff, 0x7e, 1,
			Code.Ldsfld, FlowControl.Next,
			OpCodeType.Objmodel, OperandType.InlineField,
			StackBehaviour.Pop0, StackBehaviour.Push1);

		public static readonly OpCode Ldsflda = new OpCode (
			"ldsflda", 0xff, 0x7f, 1,
			Code.Ldsflda, FlowControl.Next,
			OpCodeType.Objmodel, OperandType.InlineField,
			StackBehaviour.Pop0, StackBehaviour.Pushi);

		public static readonly OpCode Stsfld = new OpCode (
			"stsfld", 0xff, 0x80, 1,
			Code.Stsfld, FlowControl.Next,
			OpCodeType.Objmodel, OperandType.InlineField,
			StackBehaviour.Pop1, StackBehaviour.Push0);

		public static readonly OpCode Stobj = new OpCode (
			"stobj", 0xff, 0x81, 1,
			Code.Stobj, FlowControl.Next,
			OpCodeType.Objmodel, OperandType.InlineType,
			StackBehaviour.Popi_pop1, StackBehaviour.Push0);

		public static readonly OpCode Conv_Ovf_I1_Un = new OpCode (
			"conv.ovf.i1.un", 0xff, 0x82, 1,
			Code.Conv_Ovf_I1_Un, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1, StackBehaviour.Pushi);

		public static readonly OpCode Conv_Ovf_I2_Un = new OpCode (
			"conv.ovf.i2.un", 0xff, 0x83, 1,
			Code.Conv_Ovf_I2_Un, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1, StackBehaviour.Pushi);

		public static readonly OpCode Conv_Ovf_I4_Un = new OpCode (
			"conv.ovf.i4.un", 0xff, 0x84, 1,
			Code.Conv_Ovf_I4_Un, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1, StackBehaviour.Pushi);

		public static readonly OpCode Conv_Ovf_I8_Un = new OpCode (
			"conv.ovf.i8.un", 0xff, 0x85, 1,
			Code.Conv_Ovf_I8_Un, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1, StackBehaviour.Pushi8);

		public static readonly OpCode Conv_Ovf_U1_Un = new OpCode (
			"conv.ovf.u1.un", 0xff, 0x86, 1,
			Code.Conv_Ovf_U1_Un, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1, StackBehaviour.Pushi);

		public static readonly OpCode Conv_Ovf_U2_Un = new OpCode (
			"conv.ovf.u2.un", 0xff, 0x87, 1,
			Code.Conv_Ovf_U2_Un, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1, StackBehaviour.Pushi);

		public static readonly OpCode Conv_Ovf_U4_Un = new OpCode (
			"conv.ovf.u4.un", 0xff, 0x88, 1,
			Code.Conv_Ovf_U4_Un, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1, StackBehaviour.Pushi);

		public static readonly OpCode Conv_Ovf_U8_Un = new OpCode (
			"conv.ovf.u8.un", 0xff, 0x89, 1,
			Code.Conv_Ovf_U8_Un, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1, StackBehaviour.Pushi8);

		public static readonly OpCode Conv_Ovf_I_Un = new OpCode (
			"conv.ovf.i.un", 0xff, 0x8a, 1,
			Code.Conv_Ovf_I_Un, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1, StackBehaviour.Pushi);

		public static readonly OpCode Conv_Ovf_U_Un = new OpCode (
			"conv.ovf.u.un", 0xff, 0x8b, 1,
			Code.Conv_Ovf_U_Un, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1, StackBehaviour.Pushi);

		public static readonly OpCode Box = new OpCode (
			"box", 0xff, 0x8c, 1,
			Code.Box, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineType,
			StackBehaviour.Pop1, StackBehaviour.Pushref);

		public static readonly OpCode Newarr = new OpCode (
			"newarr", 0xff, 0x8d, 1,
			Code.Newarr, FlowControl.Next,
			OpCodeType.Objmodel, OperandType.InlineType,
			StackBehaviour.Popi, StackBehaviour.Pushref);

		public static readonly OpCode Ldlen = new OpCode (
			"ldlen", 0xff, 0x8e, 1,
			Code.Ldlen, FlowControl.Next,
			OpCodeType.Objmodel, OperandType.InlineNone,
			StackBehaviour.Popref, StackBehaviour.Pushi);

		public static readonly OpCode Ldelema = new OpCode (
			"ldelema", 0xff, 0x8f, 1,
			Code.Ldelema, FlowControl.Next,
			OpCodeType.Objmodel, OperandType.InlineType,
			StackBehaviour.Popref_popi, StackBehaviour.Pushi);

		public static readonly OpCode Ldelem_I1 = new OpCode (
			"ldelem.i1", 0xff, 0x90, 1,
			Code.Ldelem_I1, FlowControl.Next,
			OpCodeType.Objmodel, OperandType.InlineNone,
			StackBehaviour.Popref_popi, StackBehaviour.Pushi);

		public static readonly OpCode Ldelem_U1 = new OpCode (
			"ldelem.u1", 0xff, 0x91, 1,
			Code.Ldelem_U1, FlowControl.Next,
			OpCodeType.Objmodel, OperandType.InlineNone,
			StackBehaviour.Popref_popi, StackBehaviour.Pushi);

		public static readonly OpCode Ldelem_I2 = new OpCode (
			"ldelem.i2", 0xff, 0x92, 1,
			Code.Ldelem_I2, FlowControl.Next,
			OpCodeType.Objmodel, OperandType.InlineNone,
			StackBehaviour.Popref_popi, StackBehaviour.Pushi);

		public static readonly OpCode Ldelem_U2 = new OpCode (
			"ldelem.u2", 0xff, 0x93, 1,
			Code.Ldelem_U2, FlowControl.Next,
			OpCodeType.Objmodel, OperandType.InlineNone,
			StackBehaviour.Popref_popi, StackBehaviour.Pushi);

		public static readonly OpCode Ldelem_I4 = new OpCode (
			"ldelem.i4", 0xff, 0x94, 1,
			Code.Ldelem_I4, FlowControl.Next,
			OpCodeType.Objmodel, OperandType.InlineNone,
			StackBehaviour.Popref_popi, StackBehaviour.Pushi);

		public static readonly OpCode Ldelem_U4 = new OpCode (
			"ldelem.u4", 0xff, 0x95, 1,
			Code.Ldelem_U4, FlowControl.Next,
			OpCodeType.Objmodel, OperandType.InlineNone,
			StackBehaviour.Popref_popi, StackBehaviour.Pushi);

		public static readonly OpCode Ldelem_I8 = new OpCode (
			"ldelem.i8", 0xff, 0x96, 1,
			Code.Ldelem_I8, FlowControl.Next,
			OpCodeType.Objmodel, OperandType.InlineNone,
			StackBehaviour.Popref_popi, StackBehaviour.Pushi8);

		public static readonly OpCode Ldelem_I = new OpCode (
			"ldelem.i", 0xff, 0x97, 1,
			Code.Ldelem_I, FlowControl.Next,
			OpCodeType.Objmodel, OperandType.InlineNone,
			StackBehaviour.Popref_popi, StackBehaviour.Pushi);

		public static readonly OpCode Ldelem_R4 = new OpCode (
			"ldelem.r4", 0xff, 0x98, 1,
			Code.Ldelem_R4, FlowControl.Next,
			OpCodeType.Objmodel, OperandType.InlineNone,
			StackBehaviour.Popref_popi, StackBehaviour.Pushr4);

		public static readonly OpCode Ldelem_R8 = new OpCode (
			"ldelem.r8", 0xff, 0x99, 1,
			Code.Ldelem_R8, FlowControl.Next,
			OpCodeType.Objmodel, OperandType.InlineNone,
			StackBehaviour.Popref_popi, StackBehaviour.Pushr8);

		public static readonly OpCode Ldelem_Ref = new OpCode (
			"ldelem.ref", 0xff, 0x9a, 1,
			Code.Ldelem_Ref, FlowControl.Next,
			OpCodeType.Objmodel, OperandType.InlineNone,
			StackBehaviour.Popref_popi, StackBehaviour.Pushref);

		public static readonly OpCode Stelem_I = new OpCode (
			"stelem.i", 0xff, 0x9b, 1,
			Code.Stelem_I, FlowControl.Next,
			OpCodeType.Objmodel, OperandType.InlineNone,
			StackBehaviour.Popref_popi_popi, StackBehaviour.Push0);

		public static readonly OpCode Stelem_I1 = new OpCode (
			"stelem.i1", 0xff, 0x9c, 1,
			Code.Stelem_I1, FlowControl.Next,
			OpCodeType.Objmodel, OperandType.InlineNone,
			StackBehaviour.Popref_popi_popi, StackBehaviour.Push0);

		public static readonly OpCode Stelem_I2 = new OpCode (
			"stelem.i2", 0xff, 0x9d, 1,
			Code.Stelem_I2, FlowControl.Next,
			OpCodeType.Objmodel, OperandType.InlineNone,
			StackBehaviour.Popref_popi_popi, StackBehaviour.Push0);

		public static readonly OpCode Stelem_I4 = new OpCode (
			"stelem.i4", 0xff, 0x9e, 1,
			Code.Stelem_I4, FlowControl.Next,
			OpCodeType.Objmodel, OperandType.InlineNone,
			StackBehaviour.Popref_popi_popi, StackBehaviour.Push0);

		public static readonly OpCode Stelem_I8 = new OpCode (
			"stelem.i8", 0xff, 0x9f, 1,
			Code.Stelem_I8, FlowControl.Next,
			OpCodeType.Objmodel, OperandType.InlineNone,
			StackBehaviour.Popref_popi_popi8, StackBehaviour.Push0);

		public static readonly OpCode Stelem_R4 = new OpCode (
			"stelem.r4", 0xff, 0xa0, 1,
			Code.Stelem_R4, FlowControl.Next,
			OpCodeType.Objmodel, OperandType.InlineNone,
			StackBehaviour.Popref_popi_popr4, StackBehaviour.Push0);

		public static readonly OpCode Stelem_R8 = new OpCode (
			"stelem.r8", 0xff, 0xa1, 1,
			Code.Stelem_R8, FlowControl.Next,
			OpCodeType.Objmodel, OperandType.InlineNone,
			StackBehaviour.Popref_popi_popr8, StackBehaviour.Push0);

		public static readonly OpCode Stelem_Ref = new OpCode (
			"stelem.ref", 0xff, 0xa2, 1,
			Code.Stelem_Ref, FlowControl.Next,
			OpCodeType.Objmodel, OperandType.InlineNone,
			StackBehaviour.Popref_popi_popref, StackBehaviour.Push0);

		public static readonly OpCode Ldelem_Any = new OpCode (
			"ldelem.any", 0xff, 0xa3, 1,
			Code.Ldelem_Any, FlowControl.Next,
			OpCodeType.Objmodel, OperandType.InlineType,
			StackBehaviour.Popi, StackBehaviour.Push1);

		public static readonly OpCode Stelem_Any = new OpCode (
			"stelem.any", 0xff, 0xa4, 1,
			Code.Stelem_Any, FlowControl.Next,
			OpCodeType.Objmodel, OperandType.InlineType,
			StackBehaviour.Popref_popi_popref, StackBehaviour.Push0);

		public static readonly OpCode Unbox_Any = new OpCode (
			"unbox.any", 0xff, 0xa5, 1,
			Code.Unbox_Any, FlowControl.Next,
			OpCodeType.Objmodel, OperandType.InlineType,
			StackBehaviour.Popref, StackBehaviour.Push1);

		public static readonly OpCode Conv_Ovf_I1 = new OpCode (
			"conv.ovf.i1", 0xff, 0xb3, 1,
			Code.Conv_Ovf_I1, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1, StackBehaviour.Pushi);

		public static readonly OpCode Conv_Ovf_U1 = new OpCode (
			"conv.ovf.u1", 0xff, 0xb4, 1,
			Code.Conv_Ovf_U1, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1, StackBehaviour.Pushi);

		public static readonly OpCode Conv_Ovf_I2 = new OpCode (
			"conv.ovf.i2", 0xff, 0xb5, 1,
			Code.Conv_Ovf_I2, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1, StackBehaviour.Pushi);

		public static readonly OpCode Conv_Ovf_U2 = new OpCode (
			"conv.ovf.u2", 0xff, 0xb6, 1,
			Code.Conv_Ovf_U2, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1, StackBehaviour.Pushi);

		public static readonly OpCode Conv_Ovf_I4 = new OpCode (
			"conv.ovf.i4", 0xff, 0xb7, 1,
			Code.Conv_Ovf_I4, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1, StackBehaviour.Pushi);

		public static readonly OpCode Conv_Ovf_U4 = new OpCode (
			"conv.ovf.u4", 0xff, 0xb8, 1,
			Code.Conv_Ovf_U4, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1, StackBehaviour.Pushi);

		public static readonly OpCode Conv_Ovf_I8 = new OpCode (
			"conv.ovf.i8", 0xff, 0xb9, 1,
			Code.Conv_Ovf_I8, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1, StackBehaviour.Pushi8);

		public static readonly OpCode Conv_Ovf_U8 = new OpCode (
			"conv.ovf.u8", 0xff, 0xba, 1,
			Code.Conv_Ovf_U8, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1, StackBehaviour.Pushi8);

		public static readonly OpCode Refanyval = new OpCode (
			"refanyval", 0xff, 0xc2, 1,
			Code.Refanyval, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineType,
			StackBehaviour.Pop1, StackBehaviour.Pushi);

		public static readonly OpCode Ckfinite = new OpCode (
			"ckfinite", 0xff, 0xc3, 1,
			Code.Ckfinite, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1, StackBehaviour.Pushr8);

		public static readonly OpCode Mkrefany = new OpCode (
			"mkrefany", 0xff, 0xc6, 1,
			Code.Mkrefany, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineType,
			StackBehaviour.Popi, StackBehaviour.Push1);

		public static readonly OpCode Ldtoken = new OpCode (
			"ldtoken", 0xff, 0xd0, 1,
			Code.Ldtoken, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineTok,
			StackBehaviour.Pop0, StackBehaviour.Pushi);

		public static readonly OpCode Conv_U2 = new OpCode (
			"conv.u2", 0xff, 0xd1, 1,
			Code.Conv_U2, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1, StackBehaviour.Pushi);

		public static readonly OpCode Conv_U1 = new OpCode (
			"conv.u1", 0xff, 0xd2, 1,
			Code.Conv_U1, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1, StackBehaviour.Pushi);

		public static readonly OpCode Conv_I = new OpCode (
			"conv.i", 0xff, 0xd3, 1,
			Code.Conv_I, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1, StackBehaviour.Pushi);

		public static readonly OpCode Conv_Ovf_I = new OpCode (
			"conv.ovf.i", 0xff, 0xd4, 1,
			Code.Conv_Ovf_I, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1, StackBehaviour.Pushi);

		public static readonly OpCode Conv_Ovf_U = new OpCode (
			"conv.ovf.u", 0xff, 0xd5, 1,
			Code.Conv_Ovf_U, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1, StackBehaviour.Pushi);

		public static readonly OpCode Add_Ovf = new OpCode (
			"add.ovf", 0xff, 0xd6, 1,
			Code.Add_Ovf, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1_pop1, StackBehaviour.Push1);

		public static readonly OpCode Add_Ovf_Un = new OpCode (
			"add.ovf.un", 0xff, 0xd7, 1,
			Code.Add_Ovf_Un, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1_pop1, StackBehaviour.Push1);

		public static readonly OpCode Mul_Ovf = new OpCode (
			"mul.ovf", 0xff, 0xd8, 1,
			Code.Mul_Ovf, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1_pop1, StackBehaviour.Push1);

		public static readonly OpCode Mul_Ovf_Un = new OpCode (
			"mul.ovf.un", 0xff, 0xd9, 1,
			Code.Mul_Ovf_Un, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1_pop1, StackBehaviour.Push1);

		public static readonly OpCode Sub_Ovf = new OpCode (
			"sub.ovf", 0xff, 0xda, 1,
			Code.Sub_Ovf, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1_pop1, StackBehaviour.Push1);

		public static readonly OpCode Sub_Ovf_Un = new OpCode (
			"sub.ovf.un", 0xff, 0xdb, 1,
			Code.Sub_Ovf_Un, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1_pop1, StackBehaviour.Push1);

		public static readonly OpCode Endfinally = new OpCode (
			"endfinally", 0xff, 0xdc, 1,
			Code.Endfinally, FlowControl.Return,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop0, StackBehaviour.Push0);

		public static readonly OpCode Leave = new OpCode (
			"leave", 0xff, 0xdd, 1,
			Code.Leave, FlowControl.Branch,
			OpCodeType.Primitive, OperandType.InlineBrTarget,
			StackBehaviour.PopAll, StackBehaviour.Push0);

		public static readonly OpCode Leave_S = new OpCode (
			"leave.s", 0xff, 0xde, 1,
			Code.Leave_S, FlowControl.Branch,
			OpCodeType.Primitive, OperandType.ShortInlineBrTarget,
			StackBehaviour.PopAll, StackBehaviour.Push0);

		public static readonly OpCode Stind_I = new OpCode (
			"stind.i", 0xff, 0xdf, 1,
			Code.Stind_I, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Popi_popi, StackBehaviour.Push0);

		public static readonly OpCode Conv_U = new OpCode (
			"conv.u", 0xff, 0xe0, 1,
			Code.Conv_U, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1, StackBehaviour.Pushi);

		public static readonly OpCode Arglist = new OpCode (
			"arglist", 0xfe, 0x00, 2,
			Code.Arglist, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop0, StackBehaviour.Pushi);

		public static readonly OpCode Ceq = new OpCode (
			"ceq", 0xfe, 0x01, 2,
			Code.Ceq, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1_pop1, StackBehaviour.Pushi);

		public static readonly OpCode Cgt = new OpCode (
			"cgt", 0xfe, 0x02, 2,
			Code.Cgt, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1_pop1, StackBehaviour.Pushi);

		public static readonly OpCode Cgt_Un = new OpCode (
			"cgt.un", 0xfe, 0x03, 2,
			Code.Cgt_Un, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1_pop1, StackBehaviour.Pushi);

		public static readonly OpCode Clt = new OpCode (
			"clt", 0xfe, 0x04, 2,
			Code.Clt, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1_pop1, StackBehaviour.Pushi);

		public static readonly OpCode Clt_Un = new OpCode (
			"clt.un", 0xfe, 0x05, 2,
			Code.Clt_Un, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1_pop1, StackBehaviour.Pushi);

		public static readonly OpCode Ldftn = new OpCode (
			"ldftn", 0xfe, 0x06, 2,
			Code.Ldftn, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineMethod,
			StackBehaviour.Pop0, StackBehaviour.Pushi);

		public static readonly OpCode Ldvirtftn = new OpCode (
			"ldvirtftn", 0xfe, 0x07, 2,
			Code.Ldvirtftn, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineMethod,
			StackBehaviour.Popref, StackBehaviour.Pushi);

		public static readonly OpCode Ldarg = new OpCode (
			"ldarg", 0xfe, 0x09, 2,
			Code.Ldarg, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineParam,
			StackBehaviour.Pop0, StackBehaviour.Push1);

		public static readonly OpCode Ldarga = new OpCode (
			"ldarga", 0xfe, 0x0a, 2,
			Code.Ldarga, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineParam,
			StackBehaviour.Pop0, StackBehaviour.Pushi);

		public static readonly OpCode Starg = new OpCode (
			"starg", 0xfe, 0x0b, 2,
			Code.Starg, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineParam,
			StackBehaviour.Pop1, StackBehaviour.Push0);

		public static readonly OpCode Ldloc = new OpCode (
			"ldloc", 0xfe, 0x0c, 2,
			Code.Ldloc, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineVar,
			StackBehaviour.Pop0, StackBehaviour.Push1);

		public static readonly OpCode Ldloca = new OpCode (
			"ldloca", 0xfe, 0x0d, 2,
			Code.Ldloca, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineVar,
			StackBehaviour.Pop0, StackBehaviour.Pushi);

		public static readonly OpCode Stloc = new OpCode (
			"stloc", 0xfe, 0x0e, 2,
			Code.Stloc, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineVar,
			StackBehaviour.Pop1, StackBehaviour.Push0);

		public static readonly OpCode Localloc = new OpCode (
			"localloc", 0xfe, 0x0f, 2,
			Code.Localloc, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Popi, StackBehaviour.Pushi);

		public static readonly OpCode Endfilter = new OpCode (
			"endfilter", 0xfe, 0x11, 2,
			Code.Endfilter, FlowControl.Return,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Popi, StackBehaviour.Push0);

		public static readonly OpCode Unaligned = new OpCode (
			"unaligned.", 0xfe, 0x12, 2,
			Code.Unaligned, FlowControl.Meta,
			OpCodeType.Prefix, OperandType.ShortInlineI,
			StackBehaviour.Pop0, StackBehaviour.Push0);

		public static readonly OpCode Volatile = new OpCode (
			"volatile.", 0xfe, 0x13, 2,
			Code.Volatile, FlowControl.Meta,
			OpCodeType.Prefix, OperandType.InlineNone,
			StackBehaviour.Pop0, StackBehaviour.Push0);

		public static readonly OpCode Tail = new OpCode (
			"tail.", 0xfe, 0x14, 2,
			Code.Tail, FlowControl.Meta,
			OpCodeType.Prefix, OperandType.InlineNone,
			StackBehaviour.Pop0, StackBehaviour.Push0);

		public static readonly OpCode Initobj = new OpCode (
			"initobj", 0xfe, 0x15, 2,
			Code.Initobj, FlowControl.Next,
			OpCodeType.Objmodel, OperandType.InlineType,
			StackBehaviour.Popi, StackBehaviour.Push0);

		public static readonly OpCode Constrained = new OpCode (
			"constrained.", 0xfe, 0x16, 2,
			Code.Constrained, FlowControl.Next,
			OpCodeType.Prefix, OperandType.InlineTok,
			StackBehaviour.Pop0, StackBehaviour.Push0);

		public static readonly OpCode Cpblk = new OpCode (
			"cpblk", 0xfe, 0x17, 2,
			Code.Cpblk, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Popi_popi_popi, StackBehaviour.Push0);

		public static readonly OpCode Initblk = new OpCode (
			"initblk", 0xfe, 0x18, 2,
			Code.Initblk, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Popi_popi_popi, StackBehaviour.Push0);

		public static readonly OpCode No = new OpCode (
			"no.", 0xfe, 0x19, 2,
			Code.No, FlowControl.Next,
			OpCodeType.Prefix, OperandType.ShortInlineI,
			StackBehaviour.Pop0, StackBehaviour.Push0);

		public static readonly OpCode Rethrow = new OpCode (
			"rethrow", 0xfe, 0x1a, 2,
			Code.Rethrow, FlowControl.Throw,
			OpCodeType.Objmodel, OperandType.InlineNone,
			StackBehaviour.Pop0, StackBehaviour.Push0);

		public static readonly OpCode Sizeof = new OpCode (
			"sizeof", 0xfe, 0x1c, 2,
			Code.Sizeof, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineType,
			StackBehaviour.Pop0, StackBehaviour.Pushi);

		public static readonly OpCode Refanytype = new OpCode (
			"refanytype", 0xfe, 0x1d, 2,
			Code.Refanytype, FlowControl.Next,
			OpCodeType.Primitive, OperandType.InlineNone,
			StackBehaviour.Pop1, StackBehaviour.Pushi);

		public static readonly OpCode Readonly = new OpCode (
			"readonly.", 0xfe, 0x1e, 2,
			Code.Readonly, FlowControl.Next,
			OpCodeType.Prefix, OperandType.InlineNone,
			StackBehaviour.Pop0, StackBehaviour.Push0);

		OpCodes()
		{
		}

		public static OpCode GetOpCode (Code code)
		{
			switch (code) {
			case Code.Nop : return OpCodes.Nop;
			case Code.Break : return OpCodes.Break;
			case Code.Ldarg_0 : return OpCodes.Ldarg_0;
			case Code.Ldarg_1 : return OpCodes.Ldarg_1;
			case Code.Ldarg_2 : return OpCodes.Ldarg_2;
			case Code.Ldarg_3 : return OpCodes.Ldarg_3;
			case Code.Ldloc_0 : return OpCodes.Ldloc_0;
			case Code.Ldloc_1 : return OpCodes.Ldloc_1;
			case Code.Ldloc_2 : return OpCodes.Ldloc_2;
			case Code.Ldloc_3 : return OpCodes.Ldloc_3;
			case Code.Stloc_0 : return OpCodes.Stloc_0;
			case Code.Stloc_1 : return OpCodes.Stloc_1;
			case Code.Stloc_2 : return OpCodes.Stloc_2;
			case Code.Stloc_3 : return OpCodes.Stloc_3;
			case Code.Ldarg_S : return OpCodes.Ldarg_S;
			case Code.Ldarga_S : return OpCodes.Ldarga_S;
			case Code.Starg_S : return OpCodes.Starg_S;
			case Code.Ldloc_S : return OpCodes.Ldloc_S;
			case Code.Ldloca_S : return OpCodes.Ldloca_S;
			case Code.Stloc_S : return OpCodes.Stloc_S;
			case Code.Ldnull : return OpCodes.Ldnull;
			case Code.Ldc_I4_M1 : return OpCodes.Ldc_I4_M1;
			case Code.Ldc_I4_0 : return OpCodes.Ldc_I4_0;
			case Code.Ldc_I4_1 : return OpCodes.Ldc_I4_1;
			case Code.Ldc_I4_2 : return OpCodes.Ldc_I4_2;
			case Code.Ldc_I4_3 : return OpCodes.Ldc_I4_3;
			case Code.Ldc_I4_4 : return OpCodes.Ldc_I4_4;
			case Code.Ldc_I4_5 : return OpCodes.Ldc_I4_5;
			case Code.Ldc_I4_6 : return OpCodes.Ldc_I4_6;
			case Code.Ldc_I4_7 : return OpCodes.Ldc_I4_7;
			case Code.Ldc_I4_8 : return OpCodes.Ldc_I4_8;
			case Code.Ldc_I4_S : return OpCodes.Ldc_I4_S;
			case Code.Ldc_I4 : return OpCodes.Ldc_I4;
			case Code.Ldc_I8 : return OpCodes.Ldc_I8;
			case Code.Ldc_R4 : return OpCodes.Ldc_R4;
			case Code.Ldc_R8 : return OpCodes.Ldc_R8;
			case Code.Dup : return OpCodes.Dup;
			case Code.Pop : return OpCodes.Pop;
			case Code.Jmp : return OpCodes.Jmp;
			case Code.Call : return OpCodes.Call;
			case Code.Calli : return OpCodes.Calli;
			case Code.Ret : return OpCodes.Ret;
			case Code.Br_S : return OpCodes.Br_S;
			case Code.Brfalse_S : return OpCodes.Brfalse_S;
			case Code.Brtrue_S : return OpCodes.Brtrue_S;
			case Code.Beq_S : return OpCodes.Beq_S;
			case Code.Bge_S : return OpCodes.Bge_S;
			case Code.Bgt_S : return OpCodes.Bgt_S;
			case Code.Ble_S : return OpCodes.Ble_S;
			case Code.Blt_S : return OpCodes.Blt_S;
			case Code.Bne_Un_S : return OpCodes.Bne_Un_S;
			case Code.Bge_Un_S : return OpCodes.Bge_Un_S;
			case Code.Bgt_Un_S : return OpCodes.Bgt_Un_S;
			case Code.Ble_Un_S : return OpCodes.Ble_Un_S;
			case Code.Blt_Un_S : return OpCodes.Blt_Un_S;
			case Code.Br : return OpCodes.Br;
			case Code.Brfalse : return OpCodes.Brfalse;
			case Code.Brtrue : return OpCodes.Brtrue;
			case Code.Beq : return OpCodes.Beq;
			case Code.Bge : return OpCodes.Bge;
			case Code.Bgt : return OpCodes.Bgt;
			case Code.Ble : return OpCodes.Ble;
			case Code.Blt : return OpCodes.Blt;
			case Code.Bne_Un : return OpCodes.Bne_Un;
			case Code.Bge_Un : return OpCodes.Bge_Un;
			case Code.Bgt_Un : return OpCodes.Bgt_Un;
			case Code.Ble_Un : return OpCodes.Ble_Un;
			case Code.Blt_Un : return OpCodes.Blt_Un;
			case Code.Switch : return OpCodes.Switch;
			case Code.Ldind_I1 : return OpCodes.Ldind_I1;
			case Code.Ldind_U1 : return OpCodes.Ldind_U1;
			case Code.Ldind_I2 : return OpCodes.Ldind_I2;
			case Code.Ldind_U2 : return OpCodes.Ldind_U2;
			case Code.Ldind_I4 : return OpCodes.Ldind_I4;
			case Code.Ldind_U4 : return OpCodes.Ldind_U4;
			case Code.Ldind_I8 : return OpCodes.Ldind_I8;
			case Code.Ldind_I : return OpCodes.Ldind_I;
			case Code.Ldind_R4 : return OpCodes.Ldind_R4;
			case Code.Ldind_R8 : return OpCodes.Ldind_R8;
			case Code.Ldind_Ref : return OpCodes.Ldind_Ref;
			case Code.Stind_Ref : return OpCodes.Stind_Ref;
			case Code.Stind_I1 : return OpCodes.Stind_I1;
			case Code.Stind_I2 : return OpCodes.Stind_I2;
			case Code.Stind_I4 : return OpCodes.Stind_I4;
			case Code.Stind_I8 : return OpCodes.Stind_I8;
			case Code.Stind_R4 : return OpCodes.Stind_R4;
			case Code.Stind_R8 : return OpCodes.Stind_R8;
			case Code.Add : return OpCodes.Add;
			case Code.Sub : return OpCodes.Sub;
			case Code.Mul : return OpCodes.Mul;
			case Code.Div : return OpCodes.Div;
			case Code.Div_Un : return OpCodes.Div_Un;
			case Code.Rem : return OpCodes.Rem;
			case Code.Rem_Un : return OpCodes.Rem_Un;
			case Code.And : return OpCodes.And;
			case Code.Or : return OpCodes.Or;
			case Code.Xor : return OpCodes.Xor;
			case Code.Shl : return OpCodes.Shl;
			case Code.Shr : return OpCodes.Shr;
			case Code.Shr_Un : return OpCodes.Shr_Un;
			case Code.Neg : return OpCodes.Neg;
			case Code.Not : return OpCodes.Not;
			case Code.Conv_I1 : return OpCodes.Conv_I1;
			case Code.Conv_I2 : return OpCodes.Conv_I2;
			case Code.Conv_I4 : return OpCodes.Conv_I4;
			case Code.Conv_I8 : return OpCodes.Conv_I8;
			case Code.Conv_R4 : return OpCodes.Conv_R4;
			case Code.Conv_R8 : return OpCodes.Conv_R8;
			case Code.Conv_U4 : return OpCodes.Conv_U4;
			case Code.Conv_U8 : return OpCodes.Conv_U8;
			case Code.Callvirt : return OpCodes.Callvirt;
			case Code.Cpobj : return OpCodes.Cpobj;
			case Code.Ldobj : return OpCodes.Ldobj;
			case Code.Ldstr : return OpCodes.Ldstr;
			case Code.Newobj : return OpCodes.Newobj;
			case Code.Castclass : return OpCodes.Castclass;
			case Code.Isinst : return OpCodes.Isinst;
			case Code.Conv_R_Un : return OpCodes.Conv_R_Un;
			case Code.Unbox : return OpCodes.Unbox;
			case Code.Throw : return OpCodes.Throw;
			case Code.Ldfld : return OpCodes.Ldfld;
			case Code.Ldflda : return OpCodes.Ldflda;
			case Code.Stfld : return OpCodes.Stfld;
			case Code.Ldsfld : return OpCodes.Ldsfld;
			case Code.Ldsflda : return OpCodes.Ldsflda;
			case Code.Stsfld : return OpCodes.Stsfld;
			case Code.Stobj : return OpCodes.Stobj;
			case Code.Conv_Ovf_I1_Un : return OpCodes.Conv_Ovf_I1_Un;
			case Code.Conv_Ovf_I2_Un : return OpCodes.Conv_Ovf_I2_Un;
			case Code.Conv_Ovf_I4_Un : return OpCodes.Conv_Ovf_I4_Un;
			case Code.Conv_Ovf_I8_Un : return OpCodes.Conv_Ovf_I8_Un;
			case Code.Conv_Ovf_U1_Un : return OpCodes.Conv_Ovf_U1_Un;
			case Code.Conv_Ovf_U2_Un : return OpCodes.Conv_Ovf_U2_Un;
			case Code.Conv_Ovf_U4_Un : return OpCodes.Conv_Ovf_U4_Un;
			case Code.Conv_Ovf_U8_Un : return OpCodes.Conv_Ovf_U8_Un;
			case Code.Conv_Ovf_I_Un : return OpCodes.Conv_Ovf_I_Un;
			case Code.Conv_Ovf_U_Un : return OpCodes.Conv_Ovf_U_Un;
			case Code.Box : return OpCodes.Box;
			case Code.Newarr : return OpCodes.Newarr;
			case Code.Ldlen : return OpCodes.Ldlen;
			case Code.Ldelema : return OpCodes.Ldelema;
			case Code.Ldelem_I1 : return OpCodes.Ldelem_I1;
			case Code.Ldelem_U1 : return OpCodes.Ldelem_U1;
			case Code.Ldelem_I2 : return OpCodes.Ldelem_I2;
			case Code.Ldelem_U2 : return OpCodes.Ldelem_U2;
			case Code.Ldelem_I4 : return OpCodes.Ldelem_I4;
			case Code.Ldelem_U4 : return OpCodes.Ldelem_U4;
			case Code.Ldelem_I8 : return OpCodes.Ldelem_I8;
			case Code.Ldelem_I : return OpCodes.Ldelem_I;
			case Code.Ldelem_R4 : return OpCodes.Ldelem_R4;
			case Code.Ldelem_R8 : return OpCodes.Ldelem_R8;
			case Code.Ldelem_Ref : return OpCodes.Ldelem_Ref;
			case Code.Stelem_I : return OpCodes.Stelem_I;
			case Code.Stelem_I1 : return OpCodes.Stelem_I1;
			case Code.Stelem_I2 : return OpCodes.Stelem_I2;
			case Code.Stelem_I4 : return OpCodes.Stelem_I4;
			case Code.Stelem_I8 : return OpCodes.Stelem_I8;
			case Code.Stelem_R4 : return OpCodes.Stelem_R4;
			case Code.Stelem_R8 : return OpCodes.Stelem_R8;
			case Code.Stelem_Ref : return OpCodes.Stelem_Ref;
			case Code.Ldelem_Any : return OpCodes.Ldelem_Any;
			case Code.Stelem_Any : return OpCodes.Stelem_Any;
			case Code.Unbox_Any : return OpCodes.Unbox_Any;
			case Code.Conv_Ovf_I1 : return OpCodes.Conv_Ovf_I1;
			case Code.Conv_Ovf_U1 : return OpCodes.Conv_Ovf_U1;
			case Code.Conv_Ovf_I2 : return OpCodes.Conv_Ovf_I2;
			case Code.Conv_Ovf_U2 : return OpCodes.Conv_Ovf_U2;
			case Code.Conv_Ovf_I4 : return OpCodes.Conv_Ovf_I4;
			case Code.Conv_Ovf_U4 : return OpCodes.Conv_Ovf_U4;
			case Code.Conv_Ovf_I8 : return OpCodes.Conv_Ovf_I8;
			case Code.Conv_Ovf_U8 : return OpCodes.Conv_Ovf_U8;
			case Code.Refanyval : return OpCodes.Refanyval;
			case Code.Ckfinite : return OpCodes.Ckfinite;
			case Code.Mkrefany : return OpCodes.Mkrefany;
			case Code.Ldtoken : return OpCodes.Ldtoken;
			case Code.Conv_U2 : return OpCodes.Conv_U2;
			case Code.Conv_U1 : return OpCodes.Conv_U1;
			case Code.Conv_I : return OpCodes.Conv_I;
			case Code.Conv_Ovf_I : return OpCodes.Conv_Ovf_I;
			case Code.Conv_Ovf_U : return OpCodes.Conv_Ovf_U;
			case Code.Add_Ovf : return OpCodes.Add_Ovf;
			case Code.Add_Ovf_Un : return OpCodes.Add_Ovf_Un;
			case Code.Mul_Ovf : return OpCodes.Mul_Ovf;
			case Code.Mul_Ovf_Un : return OpCodes.Mul_Ovf_Un;
			case Code.Sub_Ovf : return OpCodes.Sub_Ovf;
			case Code.Sub_Ovf_Un : return OpCodes.Sub_Ovf_Un;
			case Code.Endfinally : return OpCodes.Endfinally;
			case Code.Leave : return OpCodes.Leave;
			case Code.Leave_S : return OpCodes.Leave_S;
			case Code.Stind_I : return OpCodes.Stind_I;
			case Code.Conv_U : return OpCodes.Conv_U;
			case Code.Arglist : return OpCodes.Arglist;
			case Code.Ceq : return OpCodes.Ceq;
			case Code.Cgt : return OpCodes.Cgt;
			case Code.Cgt_Un : return OpCodes.Cgt_Un;
			case Code.Clt : return OpCodes.Clt;
			case Code.Clt_Un : return OpCodes.Clt_Un;
			case Code.Ldftn : return OpCodes.Ldftn;
			case Code.Ldvirtftn : return OpCodes.Ldvirtftn;
			case Code.Ldarg : return OpCodes.Ldarg;
			case Code.Ldarga : return OpCodes.Ldarga;
			case Code.Starg : return OpCodes.Starg;
			case Code.Ldloc : return OpCodes.Ldloc;
			case Code.Ldloca : return OpCodes.Ldloca;
			case Code.Stloc : return OpCodes.Stloc;
			case Code.Localloc : return OpCodes.Localloc;
			case Code.Endfilter : return OpCodes.Endfilter;
			case Code.Unaligned : return OpCodes.Unaligned;
			case Code.Volatile : return OpCodes.Volatile;
			case Code.Tail : return OpCodes.Tail;
			case Code.Initobj : return OpCodes.Initobj;
			case Code.Constrained : return OpCodes.Constrained;
			case Code.Cpblk : return OpCodes.Cpblk;
			case Code.Initblk : return OpCodes.Initblk;
			case Code.No : return OpCodes.No;
			case Code.Rethrow : return OpCodes.Rethrow;
			case Code.Sizeof : return OpCodes.Sizeof;
			case Code.Refanytype : return OpCodes.Refanytype;
			case Code.Readonly : return OpCodes.Readonly;
			default : return OpCodes.Nop;
			}
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Cil/OperandType.cs
================================================
//
// OperandType.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Cil
{
	/*public enum OperandType
    {
		InlineBrTarget,
		InlineField,
		InlineI,
		InlineI8,
		InlineMethod,
		InlineNone,
		InlinePhi,
		InlineR,
		InlineSig,
		InlineString,
		InlineSwitch,
		InlineTok,
		InlineType,
		InlineVar,
		InlineParam,
		ShortInlineBrTarget,
		ShortInlineI,
		ShortInlineR,
		ShortInlineVar,
		ShortInlineParam
	}*/

    public enum OperandType
    {
        InlineBrTarget,
        InlineField,
        InlineI,
        InlineI8,
        InlineMethod,
        InlineNone,
        InlinePhi,
        InlineR,
        InlineSig,
        InlineString,
        InlineSwitch,
        InlineTok,
        InlineType,
        InlineVar,
        InlineParam,
        InlineArg,
        ShortInlineBrTarget,
        ShortInlineI,
        ShortInlineR,
        ShortInlineVar,
		ShortInlineParam,
        ShortInlineArg,
    }
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Cil/Scope.cs
================================================
//
// Scope.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2006 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Cil {

	public class Scope : IScopeProvider, IVariableDefinitionProvider, ICodeVisitable {

		Instruction m_start;
		Instruction m_end;

		Scope m_parent;
		ScopeCollection m_scopes;

		VariableDefinitionCollection m_variables;

		public Instruction Start {
			get { return m_start; }
			set { m_start = value; }
		}

		public Instruction End {
			get { return m_end; }
			set { m_end = value; }
		}

		public Scope Parent {
			get { return m_parent; }
			set { m_parent = value; }
		}

		public ScopeCollection Scopes {
			get {
				if (m_scopes == null)
					m_scopes = new ScopeCollection (this);

				return m_scopes;
			}
		}

		public VariableDefinitionCollection Variables {
			get {
				if (m_variables == null)
					m_variables = new VariableDefinitionCollection (this);

				return m_variables;
			}
		}

		public void Accept (ICodeVisitor visitor)
		{
			visitor.VisitScope (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Cil/ScopeCollection.cs
================================================
//
// ScopeCollection.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Wed Sep 27 12:46:54 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Cil {

	using System;
	using System.Collections;

	using Mono.Cecil.Cil;

	public sealed class ScopeCollection : CollectionBase, ICodeVisitable {

		IScopeProvider m_container;

		public Scope this [int index] {
			get { return List [index] as Scope; }
			set { List [index] = value; }
		}

		public IScopeProvider Container {
			get { return m_container; }
		}

		public ScopeCollection (IScopeProvider container)
		{
			m_container = container;
		}

		public void Add (Scope value)
		{
			List.Add (value);
		}

		public bool Contains (Scope value)
		{
			return List.Contains (value);
		}

		public int IndexOf (Scope value)
		{
			return List.IndexOf (value);
		}

		public void Insert (int index, Scope value)
		{
			List.Insert (index, value);
		}

		public void Remove (Scope value)
		{
			List.Remove (value);
		}

		protected override void OnValidate (object o)
		{
			if (! (o is Scope))
				throw new ArgumentException ("Must be of type " + typeof (Scope).FullName);
		}

		public void Accept (ICodeVisitor visitor)
		{
			visitor.VisitScopeCollection (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Cil/SequencePoint.cs
================================================
//
// SequencePoint.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2006 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Cil {

	public class SequencePoint {

		Document m_document;

		int m_startLine;
		int m_startColumn;
		int m_endLine;
		int m_endColumn;

		public int StartLine {
			get { return m_startLine; }
			set { m_startLine = value; }
		}

		public int StartColumn {
			get { return m_startColumn; }
			set { m_startColumn = value; }
		}

		public int EndLine {
			get { return m_endLine; }
			set { m_endLine = value; }
		}

		public int EndColumn {
			get { return m_endColumn; }
			set { m_endColumn = value; }
		}

		public Document Document {
			get { return m_document; }
			set { m_document = value; }
		}

		public SequencePoint (Document document)
		{
			m_document = document;
		}

		public SequencePoint (Document doc, int startLine, int startCol, int endLine, int endCol) : this (doc)
		{
			m_startLine = startLine;
			m_startColumn = startCol;
			m_endLine = endLine;
			m_endColumn = endCol;
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Cil/StackBehaviour.cs
================================================
//
// StackBehaviour.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Cil {

	public enum StackBehaviour {
		Pop0,
		Pop1,
		Pop1_pop1,
		Popi,
		Popi_pop1,
		Popi_popi,
		Popi_popi8,
		Popi_popi_popi,
		Popi_popr4,
		Popi_popr8,
		Popref,
		Popref_pop1,
		Popref_popi,
		Popref_popi_popi,
		Popref_popi_popi8,
		Popref_popi_popr4,
		Popref_popi_popr8,
		Popref_popi_popref,
		PopAll,
		Push0,
		Push1,
		Push1_push1,
		Pushi,
		Pushi8,
		Pushr4,
		Pushr8,
		Pushref,
		Varpop,
		Varpush
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Cil/SymbolStoreHelper.cs
================================================
//
// SymbolStoreHelper.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2006 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Cil {

	using System;
	using System.IO;
	using SR = System.Reflection;

	class SymbolStoreHelper {

		static readonly string MonoSymbolSupport = "Mono.Cecil.Mdb.MdbFactory, Mono.Cecil.Mdb";
		static readonly string DotNetSymbolSupport = "Mono.Cecil.Pdb.PdbFactory, Mono.Cecil.Pdb";

		static ISymbolStoreFactory s_factory;

		SymbolStoreHelper ()
		{
		}

		public static ISymbolReader GetReader (ModuleDefinition module)
		{
			InitFactory ();

			return s_factory.CreateReader (module, module.Image.FileInformation.FullName);
		}

		public static ISymbolWriter GetWriter (ModuleDefinition module, string assemblyFileName)
		{
			InitFactory ();

			return s_factory.CreateWriter (module, assemblyFileName);
		}

		static void InitFactory ()
		{
			if (s_factory != null)
				return;

			Type factoryType = Type.GetType (OnMono () ?
				MonoSymbolSupport :
				DotNetSymbolSupport,
				true);

			s_factory = (ISymbolStoreFactory) Activator.CreateInstance (factoryType);
		}

		static bool OnMono ()
		{
			return typeof (object).Assembly.GetType ("System.MonoType", false) != null;
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Cil/VariableDefinition.cs
================================================
//
// VariableDefinition.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Cil {

	public sealed class VariableDefinition : VariableReference {

		MethodDefinition m_method;

		public MethodDefinition Method {
			get { return m_method; }
			set { m_method = value; }
		}

		public VariableDefinition (TypeReference variableType) : base (variableType)
		{
		}

		public VariableDefinition (string name, int index, MethodDefinition method, TypeReference variableType) :
			base (name, index, variableType)
		{
			m_method = method;
		}

		public override void Accept (ICodeVisitor visitor)
		{
			visitor.VisitVariableDefinition (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Cil/VariableDefinitionCollection.cs
================================================
//
// VariableDefinitionCollection.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Wed Sep 27 12:46:53 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Cil {

	using System;
	using System.Collections;

	using Mono.Cecil.Cil;
    using System.Collections.Generic;

	public sealed class VariableDefinitionCollection : CollectionBase, ICodeVisitable {

		IVariableDefinitionProvider m_container;

		public VariableDefinition this [int index] {
			get { return List [index] as VariableDefinition; }
			set { List [index] = value; }
		}

		public IVariableDefinitionProvider Container {
			get { return m_container; }
		}

		public VariableDefinitionCollection (IVariableDefinitionProvider container)
		{
			m_container = container;
		}

        public void Add(VariableDefinition value)
        {
            List.Add(value);
        }
        public void AddRange(VariableDefinition[] value)
        {
            for (int i = 0; i < value.Length; i++)
                List.Add(value[i]);
        }
        public void AddRange(VariableDefinitionCollection value)
        {
            for (int i = 0; i < value.Count; i++)
                List.Add(value[i]);
        }

		public bool Contains (VariableDefinition value)
		{
			return List.Contains (value);
		}

		public int IndexOf (VariableDefinition value)
		{
			return List.IndexOf (value);
		}

		public void Insert (int index, VariableDefinition value)
		{
			List.Insert (index, value);
		}

		public void Remove (VariableDefinition value)
		{
			List.Remove (value);
		}

		protected override void OnValidate (object o)
		{
			if (! (o is VariableDefinition))
				throw new ArgumentException ("Must be of type " + typeof (VariableDefinition).FullName);
		}

		public void Accept (ICodeVisitor visitor)
		{
			visitor.VisitVariableDefinitionCollection (this);
		}

        public VariableDefinition[] ToArray()
        {
            List<VariableDefinition> array = new List<VariableDefinition>();
            for (int i = 0; i < this.InnerList.Count; i++)
                array.Add((VariableDefinition)this.InnerList[i]);
            return array.ToArray();
        }
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Cil/VariableReference.cs
================================================
//
// VariableReference.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Cil {

	public abstract class VariableReference : ICodeVisitable {

		string m_name;
		int m_index;
		TypeReference m_variableType;

		public string Name {
			get { return m_name; }
			set { m_name = value; }
		}

		public int Index {
			get { return m_index; }
			set { m_index = value; }
		}

		public TypeReference VariableType {
			get { return m_variableType; }
			set { m_variableType = value; }
		}

		public VariableReference (TypeReference variableType)
		{
			m_variableType = variableType;
		}

		public VariableReference (string name, int index, TypeReference variableType) : this (variableType)
		{
			m_name = name;
			m_index = index;
		}

		public override string ToString ()
		{
			if (m_name != null && m_name.Length > 0)
				return m_name;

			return string.Concat ("V_", m_index);
		}

		public abstract void Accept (ICodeVisitor visitor);
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/Assembly.cs
================================================
//
// AssemblyTable.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Tue Oct 10 23:08:25 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	using Mono.Cecil;

	public sealed class AssemblyTable : IMetadataTable {

		public const int RId = 0x20;

		RowCollection m_rows;

		public AssemblyRow this [int index] {
			get { return m_rows [index] as AssemblyRow; }
			set { m_rows [index] = value; }
		}

		public RowCollection Rows {
			get { return m_rows; }
			set { m_rows = value; }
		}

		public int Id {
			get { return RId; }
		}

		internal AssemblyTable ()
		{
		}

		public void Accept (IMetadataTableVisitor visitor)
		{
			visitor.VisitAssemblyTable (this);
			this.Rows.Accept (visitor.GetRowVisitor ());
		}
	}

	public sealed class AssemblyRow : IMetadataRow {

		public AssemblyHashAlgorithm HashAlgId;
		public ushort MajorVersion;
		public ushort MinorVersion;
		public ushort BuildNumber;
		public ushort RevisionNumber;
		public AssemblyFlags Flags;
		public uint PublicKey;
		public uint Name;
		public uint Culture;

		internal AssemblyRow ()
		{
		}

		public void Accept (IMetadataRowVisitor visitor)
		{
			visitor.VisitAssemblyRow (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/AssemblyOS.cs
================================================
//
// AssemblyOSTable.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Tue Oct 10 23:08:25 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	public sealed class AssemblyOSTable : IMetadataTable {

		public const int RId = 0x22;

		RowCollection m_rows;

		public AssemblyOSRow this [int index] {
			get { return m_rows [index] as AssemblyOSRow; }
			set { m_rows [index] = value; }
		}

		public RowCollection Rows {
			get { return m_rows; }
			set { m_rows = value; }
		}

		public int Id {
			get { return RId; }
		}

		internal AssemblyOSTable ()
		{
		}

		public void Accept (IMetadataTableVisitor visitor)
		{
			visitor.VisitAssemblyOSTable (this);
			this.Rows.Accept (visitor.GetRowVisitor ());
		}
	}

	public sealed class AssemblyOSRow : IMetadataRow {

		public uint OSPlatformID;
		public uint OSMajorVersion;
		public uint OSMinorVersion;

		internal AssemblyOSRow ()
		{
		}

		public void Accept (IMetadataRowVisitor visitor)
		{
			visitor.VisitAssemblyOSRow (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/AssemblyProcessor.cs
================================================
//
// AssemblyProcessorTable.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Tue Oct 10 23:08:25 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	public sealed class AssemblyProcessorTable : IMetadataTable {

		public const int RId = 0x21;

		RowCollection m_rows;

		public AssemblyProcessorRow this [int index] {
			get { return m_rows [index] as AssemblyProcessorRow; }
			set { m_rows [index] = value; }
		}

		public RowCollection Rows {
			get { return m_rows; }
			set { m_rows = value; }
		}

		public int Id {
			get { return RId; }
		}

		internal AssemblyProcessorTable ()
		{
		}

		public void Accept (IMetadataTableVisitor visitor)
		{
			visitor.VisitAssemblyProcessorTable (this);
			this.Rows.Accept (visitor.GetRowVisitor ());
		}
	}

	public sealed class AssemblyProcessorRow : IMetadataRow {

		public uint Processor;

		internal AssemblyProcessorRow ()
		{
		}

		public void Accept (IMetadataRowVisitor visitor)
		{
			visitor.VisitAssemblyProcessorRow (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/AssemblyRef.cs
================================================
//
// AssemblyRefTable.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Tue Oct 10 23:08:25 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	using Mono.Cecil;

	public sealed class AssemblyRefTable : IMetadataTable {

		public const int RId = 0x23;

		RowCollection m_rows;

		public AssemblyRefRow this [int index] {
			get { return m_rows [index] as AssemblyRefRow; }
			set { m_rows [index] = value; }
		}

		public RowCollection Rows {
			get { return m_rows; }
			set { m_rows = value; }
		}

		public int Id {
			get { return RId; }
		}

		internal AssemblyRefTable ()
		{
		}

		public void Accept (IMetadataTableVisitor visitor)
		{
			visitor.VisitAssemblyRefTable (this);
			this.Rows.Accept (visitor.GetRowVisitor ());
		}
	}

	public sealed class AssemblyRefRow : IMetadataRow {

		public ushort MajorVersion;
		public ushort MinorVersion;
		public ushort BuildNumber;
		public ushort RevisionNumber;
		public AssemblyFlags Flags;
		public uint PublicKeyOrToken;
		public uint Name;
		public uint Culture;
		public uint HashValue;

		internal AssemblyRefRow ()
		{
		}

		public void Accept (IMetadataRowVisitor visitor)
		{
			visitor.VisitAssemblyRefRow (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/AssemblyRefOS.cs
================================================
//
// AssemblyRefOSTable.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Tue Oct 10 23:08:25 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	public sealed class AssemblyRefOSTable : IMetadataTable {

		public const int RId = 0x25;

		RowCollection m_rows;

		public AssemblyRefOSRow this [int index] {
			get { return m_rows [index] as AssemblyRefOSRow; }
			set { m_rows [index] = value; }
		}

		public RowCollection Rows {
			get { return m_rows; }
			set { m_rows = value; }
		}

		public int Id {
			get { return RId; }
		}

		internal AssemblyRefOSTable ()
		{
		}

		public void Accept (IMetadataTableVisitor visitor)
		{
			visitor.VisitAssemblyRefOSTable (this);
			this.Rows.Accept (visitor.GetRowVisitor ());
		}
	}

	public sealed class AssemblyRefOSRow : IMetadataRow {

		public uint OSPlatformID;
		public uint OSMajorVersion;
		public uint OSMinorVersion;
		public uint AssemblyRef;

		internal AssemblyRefOSRow ()
		{
		}

		public void Accept (IMetadataRowVisitor visitor)
		{
			visitor.VisitAssemblyRefOSRow (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/AssemblyRefProcessor.cs
================================================
//
// AssemblyRefProcessorTable.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Tue Oct 10 23:08:25 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	public sealed class AssemblyRefProcessorTable : IMetadataTable {

		public const int RId = 0x24;

		RowCollection m_rows;

		public AssemblyRefProcessorRow this [int index] {
			get { return m_rows [index] as AssemblyRefProcessorRow; }
			set { m_rows [index] = value; }
		}

		public RowCollection Rows {
			get { return m_rows; }
			set { m_rows = value; }
		}

		public int Id {
			get { return RId; }
		}

		internal AssemblyRefProcessorTable ()
		{
		}

		public void Accept (IMetadataTableVisitor visitor)
		{
			visitor.VisitAssemblyRefProcessorTable (this);
			this.Rows.Accept (visitor.GetRowVisitor ());
		}
	}

	public sealed class AssemblyRefProcessorRow : IMetadataRow {

		public uint Processor;
		public uint AssemblyRef;

		internal AssemblyRefProcessorRow ()
		{
		}

		public void Accept (IMetadataRowVisitor visitor)
		{
			visitor.VisitAssemblyRefProcessorRow (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/BaseMetadataVisitor.cs
================================================
//
// BaseMetadataVisitor.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Thu Feb 22 14:39:38 CET 2007
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	public abstract class BaseMetadataVisitor : IMetadataVisitor {

		public virtual void VisitMetadataRoot (MetadataRoot root)
		{
		}

		public virtual void VisitMetadataRootHeader (MetadataRoot.MetadataRootHeader header)
		{
		}

		public virtual void VisitMetadataStreamCollection (MetadataStreamCollection streams)
		{
		}

		public virtual void VisitMetadataStream (MetadataStream stream)
		{
		}

		public virtual void VisitMetadataStreamHeader (MetadataStream.MetadataStreamHeader header)
		{
		}

		public virtual void VisitGuidHeap (GuidHeap heap)
		{
		}

		public virtual void VisitStringsHeap (StringsHeap heap)
		{
		}

		public virtual void VisitTablesHeap (TablesHeap heap)
		{
		}

		public virtual void VisitBlobHeap (BlobHeap heap)
		{
		}

		public virtual void VisitUserStringsHeap (UserStringsHeap heap)
		{
		}

		public virtual void TerminateMetadataRoot (MetadataRoot root)
		{
		}
	}

	public abstract class BaseMetadataTableVisitor : IMetadataTableVisitor {

		public virtual void VisitTableCollection (TableCollection coll)
		{
		}

		public virtual void VisitAssemblyTable (AssemblyTable table)
		{
		}

		public virtual void VisitAssemblyOSTable (AssemblyOSTable table)
		{
		}

		public virtual void VisitAssemblyProcessorTable (AssemblyProcessorTable table)
		{
		}

		public virtual void VisitAssemblyRefTable (AssemblyRefTable table)
		{
		}

		public virtual void VisitAssemblyRefOSTable (AssemblyRefOSTable table)
		{
		}

		public virtual void VisitAssemblyRefProcessorTable (AssemblyRefProcessorTable table)
		{
		}

		public virtual void VisitClassLayoutTable (ClassLayoutTable table)
		{
		}

		public virtual void VisitConstantTable (ConstantTable table)
		{
		}

		public virtual void VisitCustomAttributeTable (CustomAttributeTable table)
		{
		}

		public virtual void VisitDeclSecurityTable (DeclSecurityTable table)
		{
		}

		public virtual void VisitEventTable (EventTable table)
		{
		}

		public virtual void VisitEventMapTable (EventMapTable table)
		{
		}

		public virtual void VisitEventPtrTable (EventPtrTable table)
		{
		}

		public virtual void VisitExportedTypeTable (ExportedTypeTable table)
		{
		}

		public virtual void VisitFieldTable (FieldTable table)
		{
		}

		public virtual void VisitFieldLayoutTable (FieldLayoutTable table)
		{
		}

		public virtual void VisitFieldMarshalTable (FieldMarshalTable table)
		{
		}

		public virtual void VisitFieldPtrTable (FieldPtrTable table)
		{
		}

		public virtual void VisitFieldRVATable (FieldRVATable table)
		{
		}

		public virtual void VisitFileTable (FileTable table)
		{
		}

		public virtual void VisitGenericParamTable (GenericParamTable table)
		{
		}

		public virtual void VisitGenericParamConstraintTable (GenericParamConstraintTable table)
		{
		}

		public virtual void VisitImplMapTable (ImplMapTable table)
		{
		}

		public virtual void VisitInterfaceImplTable (InterfaceImplTable table)
		{
		}

		public virtual void VisitManifestResourceTable (ManifestResourceTable table)
		{
		}

		public virtual void VisitMemberRefTable (MemberRefTable table)
		{
		}

		public virtual void VisitMethodTable (MethodTable table)
		{
		}

		public virtual void VisitMethodImplTable (MethodImplTable table)
		{
		}

		public virtual void VisitMethodPtrTable (MethodPtrTable table)
		{
		}

		public virtual void VisitMethodSemanticsTable (MethodSemanticsTable table)
		{
		}

		public virtual void VisitMethodSpecTable (MethodSpecTable table)
		{
		}

		public virtual void VisitModuleTable (ModuleTable table)
		{
		}

		public virtual void VisitModuleRefTable (ModuleRefTable table)
		{
		}

		public virtual void VisitNestedClassTable (NestedClassTable table)
		{
		}

		public virtual void VisitParamTable (ParamTable table)
		{
		}

		public virtual void VisitParamPtrTable (ParamPtrTable table)
		{
		}

		public virtual void VisitPropertyTable (PropertyTable table)
		{
		}

		public virtual void VisitPropertyMapTable (PropertyMapTable table)
		{
		}

		public virtual void VisitPropertyPtrTable (PropertyPtrTable table)
		{
		}

		public virtual void VisitStandAloneSigTable (StandAloneSigTable table)
		{
		}

		public virtual void VisitTypeDefTable (TypeDefTable table)
		{
		}

		public virtual void VisitTypeRefTable (TypeRefTable table)
		{
		}

		public virtual void VisitTypeSpecTable (TypeSpecTable table)
		{
		}

		public virtual void TerminateTableCollection (TableCollection coll)
		{
		}

		public abstract IMetadataRowVisitor GetRowVisitor();
	}

	public abstract class BaseMetadataRowVisitor : IMetadataRowVisitor {

		public virtual void VisitRowCollection (RowCollection coll)
		{
		}

		public virtual void VisitAssemblyRow (AssemblyRow row)
		{
		}

		public virtual void VisitAssemblyOSRow (AssemblyOSRow row)
		{
		}

		public virtual void VisitAssemblyProcessorRow (AssemblyProcessorRow row)
		{
		}

		public virtual void VisitAssemblyRefRow (AssemblyRefRow row)
		{
		}

		public virtual void VisitAssemblyRefOSRow (AssemblyRefOSRow row)
		{
		}

		public virtual void VisitAssemblyRefProcessorRow (AssemblyRefProcessorRow row)
		{
		}

		public virtual void VisitClassLayoutRow (ClassLayoutRow row)
		{
		}

		public virtual void VisitConstantRow (ConstantRow row)
		{
		}

		public virtual void VisitCustomAttributeRow (CustomAttributeRow row)
		{
		}

		public virtual void VisitDeclSecurityRow (DeclSecurityRow row)
		{
		}

		public virtual void VisitEventRow (EventRow row)
		{
		}

		public virtual void VisitEventMapRow (EventMapRow row)
		{
		}

		public virtual void VisitEventPtrRow (EventPtrRow row)
		{
		}

		public virtual void VisitExportedTypeRow (ExportedTypeRow row)
		{
		}

		public virtual void VisitFieldRow (FieldRow row)
		{
		}

		public virtual void VisitFieldLayoutRow (FieldLayoutRow row)
		{
		}

		public virtual void VisitFieldMarshalRow (FieldMarshalRow row)
		{
		}

		public virtual void VisitFieldPtrRow (FieldPtrRow row)
		{
		}

		public virtual void VisitFieldRVARow (FieldRVARow row)
		{
		}

		public virtual void VisitFileRow (FileRow row)
		{
		}

		public virtual void VisitGenericParamRow (GenericParamRow row)
		{
		}

		public virtual void VisitGenericParamConstraintRow (GenericParamConstraintRow row)
		{
		}

		public virtual void VisitImplMapRow (ImplMapRow row)
		{
		}

		public virtual void VisitInterfaceImplRow (InterfaceImplRow row)
		{
		}

		public virtual void VisitManifestResourceRow (ManifestResourceRow row)
		{
		}

		public virtual void VisitMemberRefRow (MemberRefRow row)
		{
		}

		public virtual void VisitMethodRow (MethodRow row)
		{
		}

		public virtual void VisitMethodImplRow (MethodImplRow row)
		{
		}

		public virtual void VisitMethodPtrRow (MethodPtrRow row)
		{
		}

		public virtual void VisitMethodSemanticsRow (MethodSemanticsRow row)
		{
		}

		public virtual void VisitMethodSpecRow (MethodSpecRow row)
		{
		}

		public virtual void VisitModuleRow (ModuleRow row)
		{
		}

		public virtual void VisitModuleRefRow (ModuleRefRow row)
		{
		}

		public virtual void VisitNestedClassRow (NestedClassRow row)
		{
		}

		public virtual void VisitParamRow (ParamRow row)
		{
		}

		public virtual void VisitParamPtrRow (ParamPtrRow row)
		{
		}

		public virtual void VisitPropertyRow (PropertyRow row)
		{
		}

		public virtual void VisitPropertyMapRow (PropertyMapRow row)
		{
		}

		public virtual void VisitPropertyPtrRow (PropertyPtrRow row)
		{
		}

		public virtual void VisitStandAloneSigRow (StandAloneSigRow row)
		{
		}

		public virtual void VisitTypeDefRow (TypeDefRow row)
		{
		}

		public virtual void VisitTypeRefRow (TypeRefRow row)
		{
		}

		public virtual void VisitTypeSpecRow (TypeSpecRow row)
		{
		}

		public virtual void TerminateRowCollection (RowCollection coll)
		{
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/BlobHeap.cs
================================================
//
// BlobHeap.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	using System.IO;

	public class BlobHeap : MetadataHeap {

		internal BlobHeap (MetadataStream stream) : base (stream, MetadataStream.Blob)
		{
		}

		public byte [] Read (uint index)
		{
			return ReadBytesFromStream (index);
		}

		public BinaryReader GetReader (uint index)
		{
			return new BinaryReader (new MemoryStream (Read (index)));
		}

		public override void Accept (IMetadataVisitor visitor)
		{
			visitor.VisitBlobHeap (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/ClassLayout.cs
================================================
//
// ClassLayoutTable.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Tue Oct 10 23:08:25 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	public sealed class ClassLayoutTable : IMetadataTable {

		public const int RId = 0x0f;

		RowCollection m_rows;

		public ClassLayoutRow this [int index] {
			get { return m_rows [index] as ClassLayoutRow; }
			set { m_rows [index] = value; }
		}

		public RowCollection Rows {
			get { return m_rows; }
			set { m_rows = value; }
		}

		public int Id {
			get { return RId; }
		}

		internal ClassLayoutTable ()
		{
		}

		public void Accept (IMetadataTableVisitor visitor)
		{
			visitor.VisitClassLayoutTable (this);
			this.Rows.Accept (visitor.GetRowVisitor ());
		}
	}

	public sealed class ClassLayoutRow : IMetadataRow {

		public ushort PackingSize;
		public uint ClassSize;
		public uint Parent;

		internal ClassLayoutRow ()
		{
		}

		public void Accept (IMetadataRowVisitor visitor)
		{
			visitor.VisitClassLayoutRow (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/CodedIndex.cs
================================================
//
// CodedIndex.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Tue Mar 20 16:02:16 +0100 2007
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	public enum CodedIndex {
		TypeDefOrRef,
		HasConstant,
		HasCustomAttribute,
		HasFieldMarshal,
		HasDeclSecurity,
		MemberRefParent,
		HasSemantics,
		MethodDefOrRef,
		MemberForwarded,
		Implementation,
		CustomAttributeType,
		ResolutionScope,
		TypeOrMethodDef
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/Constant.cs
================================================
//
// ConstantTable.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Tue Oct 10 23:08:25 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	public sealed class ConstantTable : IMetadataTable {

		public const int RId = 0x0b;

		RowCollection m_rows;

		public ConstantRow this [int index] {
			get { return m_rows [index] as ConstantRow; }
			set { m_rows [index] = value; }
		}

		public RowCollection Rows {
			get { return m_rows; }
			set { m_rows = value; }
		}

		public int Id {
			get { return RId; }
		}

		internal ConstantTable ()
		{
		}

		public void Accept (IMetadataTableVisitor visitor)
		{
			visitor.VisitConstantTable (this);
			this.Rows.Accept (visitor.GetRowVisitor ());
		}
	}

	public sealed class ConstantRow : IMetadataRow {

		public ElementType Type;
		public MetadataToken Parent;
		public uint Value;

		internal ConstantRow ()
		{
		}

		public void Accept (IMetadataRowVisitor visitor)
		{
			visitor.VisitConstantRow (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/CultureUtils.cs
================================================
//
// CultureUtils.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	using System;
	using System.Collections;
	using System.Globalization;

	class CultureUtils {

		static IDictionary m_cultures;

		CultureUtils ()
		{
		}

		static void LoadCultures ()
		{
			if (m_cultures != null)
				return;

#if CF_1_0 || CF_2_0
			CultureInfo [] cultures = new CultureInfo [0];
#else
			CultureInfo [] cultures = CultureInfo.GetCultures (CultureTypes.AllCultures);
#endif
			m_cultures = new Hashtable (cultures.Length + 2);

			foreach (CultureInfo ci in cultures)
				if (!m_cultures.Contains (ci.Name))
					m_cultures.Add (ci.Name, ci);

			if (!m_cultures.Contains (string.Empty))
				m_cultures.Add (string.Empty, CultureInfo.InvariantCulture);

			m_cultures.Add ("neutral", CultureInfo.InvariantCulture);
		}

		public static bool IsValid (string culture)
		{
			if (culture == null)
				throw new ArgumentNullException ("culture");

			LoadCultures ();

			return m_cultures.Contains (culture);
		}

		public static CultureInfo GetCultureInfo (string culture)
		{
			if (IsValid (culture))
				return m_cultures [culture] as CultureInfo;

			return CultureInfo.InvariantCulture;
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/CustomAttribute.cs
================================================
//
// CustomAttributeTable.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Tue Oct 10 23:08:25 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	public sealed class CustomAttributeTable : IMetadataTable {

		public const int RId = 0x0c;

		RowCollection m_rows;

		public CustomAttributeRow this [int index] {
			get { return m_rows [index] as CustomAttributeRow; }
			set { m_rows [index] = value; }
		}

		public RowCollection Rows {
			get { return m_rows; }
			set { m_rows = value; }
		}

		public int Id {
			get { return RId; }
		}

		internal CustomAttributeTable ()
		{
		}

		public void Accept (IMetadataTableVisitor visitor)
		{
			visitor.VisitCustomAttributeTable (this);
			this.Rows.Accept (visitor.GetRowVisitor ());
		}
	}

	public sealed class CustomAttributeRow : IMetadataRow {

		public MetadataToken Parent;
		public MetadataToken Type;
		public uint Value;

		internal CustomAttributeRow ()
		{
		}

		public void Accept (IMetadataRowVisitor visitor)
		{
			visitor.VisitCustomAttributeRow (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/DeclSecurity.cs
================================================
//
// DeclSecurityTable.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Tue Oct 10 23:08:26 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	using Mono.Cecil;

	public sealed class DeclSecurityTable : IMetadataTable {

		public const int RId = 0x0e;

		RowCollection m_rows;

		public DeclSecurityRow this [int index] {
			get { return m_rows [index] as DeclSecurityRow; }
			set { m_rows [index] = value; }
		}

		public RowCollection Rows {
			get { return m_rows; }
			set { m_rows = value; }
		}

		public int Id {
			get { return RId; }
		}

		internal DeclSecurityTable ()
		{
		}

		public void Accept (IMetadataTableVisitor visitor)
		{
			visitor.VisitDeclSecurityTable (this);
			this.Rows.Accept (visitor.GetRowVisitor ());
		}
	}

	public sealed class DeclSecurityRow : IMetadataRow {

		public SecurityAction Action;
		public MetadataToken Parent;
		public uint PermissionSet;

		internal DeclSecurityRow ()
		{
		}

		public void Accept (IMetadataRowVisitor visitor)
		{
			visitor.VisitDeclSecurityRow (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/ElementType.cs
================================================
//
// ElementType.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	public enum ElementType {
		End		 = 0x00,   // Marks end of a list
		Void		= 0x01,
		Boolean	 = 0x02,
		Char		= 0x03,
		I1		  = 0x04,
		U1		  = 0x05,
		I2		  = 0x06,
		U2		  = 0x07,
		I4		  = 0x08,
		U4		  = 0x09,
		I8		  = 0x0a,
		U8		  = 0x0b,
		R4		  = 0x0c,
		R8		  = 0x0d,
		String	  = 0x0e,
		Ptr		 = 0x0f,   // Followed by <type> token
		ByRef	   = 0x10,   // Followed by <type> token
		ValueType   = 0x11,   // Followed by <type> token
		Class	   = 0x12,   // Followed by <type> token
		Var        = 0x13,   // Followed by generic parameter number
		Array	   = 0x14,   // <type> <rank> <boundsCount> <bound1>  <loCount> <lo1>
		GenericInst = 0x15,   // <type> <type-arg-count> <type-1> ... <type-n> */
		TypedByRef  = 0x16,
		I		   = 0x18,   // System.IntPtr
		U		   = 0x19,   // System.UIntPtr
		FnPtr	   = 0x1b,   // Followed by full method signature
		Object	  = 0x1c,   // System.Object
		SzArray	 = 0x1d,   // Single-dim array with 0 lower bound
		MVar       = 0x1e,   // Followed by generic parameter number
		CModReqD	= 0x1f,   // Required modifier : followed by a TypeDef or TypeRef token
		CModOpt	 = 0x20,   // Optional modifier : followed by a TypeDef or TypeRef token
		Internal	= 0x21,   // Implemented within the CLI
		Modifier	= 0x40,   // Or'd with following element types
		Sentinel	= 0x41,   // Sentinel for varargs method signature
		Pinned	  = 0x45,   // Denotes a local variable that points at a pinned object

		// special undocumented constants
		Type		= 0x50,
		Boxed	   = 0x51,
		Enum		= 0x55
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/Event.cs
================================================
//
// EventTable.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Tue Oct 10 23:08:26 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	using Mono.Cecil;

	public sealed class EventTable : IMetadataTable {

		public const int RId = 0x14;

		RowCollection m_rows;

		public EventRow this [int index] {
			get { return m_rows [index] as EventRow; }
			set { m_rows [index] = value; }
		}

		public RowCollection Rows {
			get { return m_rows; }
			set { m_rows = value; }
		}

		public int Id {
			get { return RId; }
		}

		internal EventTable ()
		{
		}

		public void Accept (IMetadataTableVisitor visitor)
		{
			visitor.VisitEventTable (this);
			this.Rows.Accept (visitor.GetRowVisitor ());
		}
	}

	public sealed class EventRow : IMetadataRow {

		public EventAttributes EventFlags;
		public uint Name;
		public MetadataToken EventType;

		internal EventRow ()
		{
		}

		public void Accept (IMetadataRowVisitor visitor)
		{
			visitor.VisitEventRow (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/EventMap.cs
================================================
//
// EventMapTable.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Tue Oct 10 23:08:26 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	public sealed class EventMapTable : IMetadataTable {

		public const int RId = 0x12;

		RowCollection m_rows;

		public EventMapRow this [int index] {
			get { return m_rows [index] as EventMapRow; }
			set { m_rows [index] = value; }
		}

		public RowCollection Rows {
			get { return m_rows; }
			set { m_rows = value; }
		}

		public int Id {
			get { return RId; }
		}

		internal EventMapTable ()
		{
		}

		public void Accept (IMetadataTableVisitor visitor)
		{
			visitor.VisitEventMapTable (this);
			this.Rows.Accept (visitor.GetRowVisitor ());
		}
	}

	public sealed class EventMapRow : IMetadataRow {

		public uint Parent;
		public uint EventList;

		internal EventMapRow ()
		{
		}

		public void Accept (IMetadataRowVisitor visitor)
		{
			visitor.VisitEventMapRow (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/EventPtr.cs
================================================
//
// EventPtrTable.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Thu Feb 22 14:39:38 CET 2007
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	public sealed class EventPtrTable : IMetadataTable {

		public const int RId = 0x13;

		RowCollection m_rows;

		public EventPtrRow this [int index] {
			get { return m_rows [index] as EventPtrRow; }
			set { m_rows [index] = value; }
		}

		public RowCollection Rows {
			get { return m_rows; }
			set { m_rows = value; }
		}

		public int Id {
			get { return RId; }
		}

		internal EventPtrTable ()
		{
		}

		public void Accept (IMetadataTableVisitor visitor)
		{
			visitor.VisitEventPtrTable (this);
			this.Rows.Accept (visitor.GetRowVisitor ());
		}
	}

	public sealed class EventPtrRow : IMetadataRow {

		public uint Event;

		internal EventPtrRow ()
		{
		}

		public void Accept (IMetadataRowVisitor visitor)
		{
			visitor.VisitEventPtrRow (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/ExportedType.cs
================================================
//
// ExportedTypeTable.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Tue Oct 10 23:08:26 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	using Mono.Cecil;

	public sealed class ExportedTypeTable : IMetadataTable {

		public const int RId = 0x27;

		RowCollection m_rows;

		public ExportedTypeRow this [int index] {
			get { return m_rows [index] as ExportedTypeRow; }
			set { m_rows [index] = value; }
		}

		public RowCollection Rows {
			get { return m_rows; }
			set { m_rows = value; }
		}

		public int Id {
			get { return RId; }
		}

		internal ExportedTypeTable ()
		{
		}

		public void Accept (IMetadataTableVisitor visitor)
		{
			visitor.VisitExportedTypeTable (this);
			this.Rows.Accept (visitor.GetRowVisitor ());
		}
	}

	public sealed class ExportedTypeRow : IMetadataRow {

		public TypeAttributes Flags;
		public uint TypeDefId;
		public uint TypeName;
		public uint TypeNamespace;
		public MetadataToken Implementation;

		internal ExportedTypeRow ()
		{
		}

		public void Accept (IMetadataRowVisitor visitor)
		{
			visitor.VisitExportedTypeRow (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/Field.cs
================================================
//
// FieldTable.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Tue Oct 10 23:08:26 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	using Mono.Cecil;

	public sealed class FieldTable : IMetadataTable {

		public const int RId = 0x04;

		RowCollection m_rows;

		public FieldRow this [int index] {
			get { return m_rows [index] as FieldRow; }
			set { m_rows [index] = value; }
		}

		public RowCollection Rows {
			get { return m_rows; }
			set { m_rows = value; }
		}

		public int Id {
			get { return RId; }
		}

		internal FieldTable ()
		{
		}

		public void Accept (IMetadataTableVisitor visitor)
		{
			visitor.VisitFieldTable (this);
			this.Rows.Accept (visitor.GetRowVisitor ());
		}
	}

	public sealed class FieldRow : IMetadataRow {

		public FieldAttributes Flags;
		public uint Name;
		public uint Signature;

		internal FieldRow ()
		{
		}

		public void Accept (IMetadataRowVisitor visitor)
		{
			visitor.VisitFieldRow (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/FieldLayout.cs
================================================
//
// FieldLayoutTable.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Tue Oct 10 23:08:26 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	public sealed class FieldLayoutTable : IMetadataTable {

		public const int RId = 0x10;

		RowCollection m_rows;

		public FieldLayoutRow this [int index] {
			get { return m_rows [index] as FieldLayoutRow; }
			set { m_rows [index] = value; }
		}

		public RowCollection Rows {
			get { return m_rows; }
			set { m_rows = value; }
		}

		public int Id {
			get { return RId; }
		}

		internal FieldLayoutTable ()
		{
		}

		public void Accept (IMetadataTableVisitor visitor)
		{
			visitor.VisitFieldLayoutTable (this);
			this.Rows.Accept (visitor.GetRowVisitor ());
		}
	}

	public sealed class FieldLayoutRow : IMetadataRow {

		public uint Offset;
		public uint Field;

		internal FieldLayoutRow ()
		{
		}

		public void Accept (IMetadataRowVisitor visitor)
		{
			visitor.VisitFieldLayoutRow (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/FieldMarshal.cs
================================================
//
// FieldMarshalTable.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Tue Oct 10 23:08:26 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	public sealed class FieldMarshalTable : IMetadataTable {

		public const int RId = 0x0d;

		RowCollection m_rows;

		public FieldMarshalRow this [int index] {
			get { return m_rows [index] as FieldMarshalRow; }
			set { m_rows [index] = value; }
		}

		public RowCollection Rows {
			get { return m_rows; }
			set { m_rows = value; }
		}

		public int Id {
			get { return RId; }
		}

		internal FieldMarshalTable ()
		{
		}

		public void Accept (IMetadataTableVisitor visitor)
		{
			visitor.VisitFieldMarshalTable (this);
			this.Rows.Accept (visitor.GetRowVisitor ());
		}
	}

	public sealed class FieldMarshalRow : IMetadataRow {

		public MetadataToken Parent;
		public uint NativeType;

		internal FieldMarshalRow ()
		{
		}

		public void Accept (IMetadataRowVisitor visitor)
		{
			visitor.VisitFieldMarshalRow (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/FieldPtr.cs
================================================
//
// FieldPtrTable.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Thu Feb 22 14:39:38 CET 2007
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	public sealed class FieldPtrTable : IMetadataTable {

		public const int RId = 0x03;

		RowCollection m_rows;

		public FieldPtrRow this [int index] {
			get { return m_rows [index] as FieldPtrRow; }
			set { m_rows [index] = value; }
		}

		public RowCollection Rows {
			get { return m_rows; }
			set { m_rows = value; }
		}

		public int Id {
			get { return RId; }
		}

		internal FieldPtrTable ()
		{
		}

		public void Accept (IMetadataTableVisitor visitor)
		{
			visitor.VisitFieldPtrTable (this);
			this.Rows.Accept (visitor.GetRowVisitor ());
		}
	}

	public sealed class FieldPtrRow : IMetadataRow {

		public uint Field;

		internal FieldPtrRow ()
		{
		}

		public void Accept (IMetadataRowVisitor visitor)
		{
			visitor.VisitFieldPtrRow (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/FieldRVA.cs
================================================
//
// FieldRVATable.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Tue Oct 10 23:08:26 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	using Mono.Cecil.Binary;

	public sealed class FieldRVATable : IMetadataTable {

		public const int RId = 0x1d;

		RowCollection m_rows;

		public FieldRVARow this [int index] {
			get { return m_rows [index] as FieldRVARow; }
			set { m_rows [index] = value; }
		}

		public RowCollection Rows {
			get { return m_rows; }
			set { m_rows = value; }
		}

		public int Id {
			get { return RId; }
		}

		internal FieldRVATable ()
		{
		}

		public void Accept (IMetadataTableVisitor visitor)
		{
			visitor.VisitFieldRVATable (this);
			this.Rows.Accept (visitor.GetRowVisitor ());
		}
	}

	public sealed class FieldRVARow : IMetadataRow {

		public RVA RVA;
		public uint Field;

		internal FieldRVARow ()
		{
		}

		public void Accept (IMetadataRowVisitor visitor)
		{
			visitor.VisitFieldRVARow (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/File.cs
================================================
//
// FileTable.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Tue Oct 10 23:08:26 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	using Mono.Cecil;

	public sealed class FileTable : IMetadataTable {

		public const int RId = 0x26;

		RowCollection m_rows;

		public FileRow this [int index] {
			get { return m_rows [index] as FileRow; }
			set { m_rows [index] = value; }
		}

		public RowCollection Rows {
			get { return m_rows; }
			set { m_rows = value; }
		}

		public int Id {
			get { return RId; }
		}

		internal FileTable ()
		{
		}

		public void Accept (IMetadataTableVisitor visitor)
		{
			visitor.VisitFileTable (this);
			this.Rows.Accept (visitor.GetRowVisitor ());
		}
	}

	public sealed class FileRow : IMetadataRow {

		public FileAttributes Flags;
		public uint Name;
		public uint HashValue;

		internal FileRow ()
		{
		}

		public void Accept (IMetadataRowVisitor visitor)
		{
			visitor.VisitFileRow (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/GenericParam.cs
================================================
//
// GenericParamTable.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Tue Oct 10 23:08:26 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	using Mono.Cecil;

	public sealed class GenericParamTable : IMetadataTable {

		public const int RId = 0x2a;

		RowCollection m_rows;

		public GenericParamRow this [int index] {
			get { return m_rows [index] as GenericParamRow; }
			set { m_rows [index] = value; }
		}

		public RowCollection Rows {
			get { return m_rows; }
			set { m_rows = value; }
		}

		public int Id {
			get { return RId; }
		}

		internal GenericParamTable ()
		{
		}

		public void Accept (IMetadataTableVisitor visitor)
		{
			visitor.VisitGenericParamTable (this);
			this.Rows.Accept (visitor.GetRowVisitor ());
		}
	}

	public sealed class GenericParamRow : IMetadataRow {

		public ushort Number;
		public GenericParameterAttributes Flags;
		public MetadataToken Owner;
		public uint Name;

		internal GenericParamRow ()
		{
		}

		public void Accept (IMetadataRowVisitor visitor)
		{
			visitor.VisitGenericParamRow (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/GenericParamConstraint.cs
================================================
//
// GenericParamConstraintTable.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Tue Oct 10 23:08:26 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	public sealed class GenericParamConstraintTable : IMetadataTable {

		public const int RId = 0x2c;

		RowCollection m_rows;

		public GenericParamConstraintRow this [int index] {
			get { return m_rows [index] as GenericParamConstraintRow; }
			set { m_rows [index] = value; }
		}

		public RowCollection Rows {
			get { return m_rows; }
			set { m_rows = value; }
		}

		public int Id {
			get { return RId; }
		}

		internal GenericParamConstraintTable ()
		{
		}

		public void Accept (IMetadataTableVisitor visitor)
		{
			visitor.VisitGenericParamConstraintTable (this);
			this.Rows.Accept (visitor.GetRowVisitor ());
		}
	}

	public sealed class GenericParamConstraintRow : IMetadataRow {

		public uint Owner;
		public MetadataToken Constraint;

		internal GenericParamConstraintRow ()
		{
		}

		public void Accept (IMetadataRowVisitor visitor)
		{
			visitor.VisitGenericParamConstraintRow (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/GuidHeap.cs
================================================
//
// GuidHeap.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	using System;
	using System.Collections;

	public class GuidHeap : MetadataHeap {

		readonly IDictionary m_guids;

		public IDictionary Guids {
			get { return m_guids; }
		}

		public GuidHeap (MetadataStream stream) : base (stream, MetadataStream.GUID)
		{
			m_guids = new Hashtable ();
		}

		public Guid this [uint index] {
			get {
				if (index == 0)
					return new Guid (new byte [16]);

				int idx = (int) index - 1;

				if (m_guids.Contains (idx))
					return (Guid) m_guids [idx];

				if (idx + 16 > this.Data.Length)
					throw new IndexOutOfRangeException ();

				byte[] buffer = new byte [16];
				Buffer.BlockCopy (this.Data, idx, buffer, 0, 16);
				Guid res = new Guid (buffer);
				m_guids [idx] = res;
				return res;
			}
			set { m_guids [index] = value; }
		}

		public override void Accept (IMetadataVisitor visitor)
		{
			visitor.VisitGuidHeap (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/IMetadataRow.cs
================================================
//
// IMetadataRow.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	public interface IMetadataRow : IMetadataRowVisitable {
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/IMetadataTable.cs
================================================
//
// IMetadataTable.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	public interface IMetadataTable : IMetadataTableVisitable {
		int Id { get; }
		RowCollection Rows { get; set; }
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/IMetadataVisitable.cs
================================================
//
// IMetadataVisitable.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	public interface IMetadataVisitable {
		void Accept (IMetadataVisitor visitor);
	}

	public interface IMetadataTableVisitable {
		void Accept (IMetadataTableVisitor visitor);
	}

	public interface IMetadataRowVisitable {
		void Accept (IMetadataRowVisitor visitor);
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/IMetadataVisitor.cs
================================================
//
// IMetadataVisitor.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Thu Feb 22 14:39:38 CET 2007
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	public interface IMetadataVisitor {
		void VisitMetadataRoot (MetadataRoot root);
		void VisitMetadataRootHeader (MetadataRoot.MetadataRootHeader header);
		void VisitMetadataStreamCollection (MetadataStreamCollection streams);
		void VisitMetadataStream (MetadataStream stream);
		void VisitMetadataStreamHeader (MetadataStream.MetadataStreamHeader header);
		void VisitGuidHeap (GuidHeap heap);
		void VisitStringsHeap (StringsHeap heap);
		void VisitTablesHeap (TablesHeap heap);
		void VisitBlobHeap (BlobHeap heap);
		void VisitUserStringsHeap (UserStringsHeap heap);

		void TerminateMetadataRoot (MetadataRoot root);
	}

	public interface IMetadataTableVisitor {
		void VisitTableCollection (TableCollection coll);

		void VisitAssemblyTable (AssemblyTable table);
		void VisitAssemblyOSTable (AssemblyOSTable table);
		void VisitAssemblyProcessorTable (AssemblyProcessorTable table);
		void VisitAssemblyRefTable (AssemblyRefTable table);
		void VisitAssemblyRefOSTable (AssemblyRefOSTable table);
		void VisitAssemblyRefProcessorTable (AssemblyRefProcessorTable table);
		void VisitClassLayoutTable (ClassLayoutTable table);
		void VisitConstantTable (ConstantTable table);
		void VisitCustomAttributeTable (CustomAttributeTable table);
		void VisitDeclSecurityTable (DeclSecurityTable table);
		void VisitEventTable (EventTable table);
		void VisitEventMapTable (EventMapTable table);
		void VisitEventPtrTable (EventPtrTable table);
		void VisitExportedTypeTable (ExportedTypeTable table);
		void VisitFieldTable (FieldTable table);
		void VisitFieldLayoutTable (FieldLayoutTable table);
		void VisitFieldMarshalTable (FieldMarshalTable table);
		void VisitFieldPtrTable (FieldPtrTable table);
		void VisitFieldRVATable (FieldRVATable table);
		void VisitFileTable (FileTable table);
		void VisitGenericParamTable (GenericParamTable table);
		void VisitGenericParamConstraintTable (GenericParamConstraintTable table);
		void VisitImplMapTable (ImplMapTable table);
		void VisitInterfaceImplTable (InterfaceImplTable table);
		void VisitManifestResourceTable (ManifestResourceTable table);
		void VisitMemberRefTable (MemberRefTable table);
		void VisitMethodTable (MethodTable table);
		void VisitMethodImplTable (MethodImplTable table);
		void VisitMethodPtrTable (MethodPtrTable table);
		void VisitMethodSemanticsTable (MethodSemanticsTable table);
		void VisitMethodSpecTable (MethodSpecTable table);
		void VisitModuleTable (ModuleTable table);
		void VisitModuleRefTable (ModuleRefTable table);
		void VisitNestedClassTable (NestedClassTable table);
		void VisitParamTable (ParamTable table);
		void VisitParamPtrTable (ParamPtrTable table);
		void VisitPropertyTable (PropertyTable table);
		void VisitPropertyMapTable (PropertyMapTable table);
		void VisitPropertyPtrTable (PropertyPtrTable table);
		void VisitStandAloneSigTable (StandAloneSigTable table);
		void VisitTypeDefTable (TypeDefTable table);
		void VisitTypeRefTable (TypeRefTable table);
		void VisitTypeSpecTable (TypeSpecTable table);

		void TerminateTableCollection (TableCollection coll);
		IMetadataRowVisitor GetRowVisitor();
}

	public interface IMetadataRowVisitor {
		void VisitRowCollection (RowCollection coll);

		void VisitAssemblyRow (AssemblyRow row);
		void VisitAssemblyOSRow (AssemblyOSRow row);
		void VisitAssemblyProcessorRow (AssemblyProcessorRow row);
		void VisitAssemblyRefRow (AssemblyRefRow row);
		void VisitAssemblyRefOSRow (AssemblyRefOSRow row);
		void VisitAssemblyRefProcessorRow (AssemblyRefProcessorRow row);
		void VisitClassLayoutRow (ClassLayoutRow row);
		void VisitConstantRow (ConstantRow row);
		void VisitCustomAttributeRow (CustomAttributeRow row);
		void VisitDeclSecurityRow (DeclSecurityRow row);
		void VisitEventRow (EventRow row);
		void VisitEventMapRow (EventMapRow row);
		void VisitEventPtrRow (EventPtrRow row);
		void VisitExportedTypeRow (ExportedTypeRow row);
		void VisitFieldRow (FieldRow row);
		void VisitFieldLayoutRow (FieldLayoutRow row);
		void VisitFieldMarshalRow (FieldMarshalRow row);
		void VisitFieldPtrRow (FieldPtrRow row);
		void VisitFieldRVARow (FieldRVARow row);
		void VisitFileRow (FileRow row);
		void VisitGenericParamRow (GenericParamRow row);
		void VisitGenericParamConstraintRow (GenericParamConstraintRow row);
		void VisitImplMapRow (ImplMapRow row);
		void VisitInterfaceImplRow (InterfaceImplRow row);
		void VisitManifestResourceRow (ManifestResourceRow row);
		void VisitMemberRefRow (MemberRefRow row);
		void VisitMethodRow (MethodRow row);
		void VisitMethodImplRow (MethodImplRow row);
		void VisitMethodPtrRow (MethodPtrRow row);
		void VisitMethodSemanticsRow (MethodSemanticsRow row);
		void VisitMethodSpecRow (MethodSpecRow row);
		void VisitModuleRow (ModuleRow row);
		void VisitModuleRefRow (ModuleRefRow row);
		void VisitNestedClassRow (NestedClassRow row);
		void VisitParamRow (ParamRow row);
		void VisitParamPtrRow (ParamPtrRow row);
		void VisitPropertyRow (PropertyRow row);
		void VisitPropertyMapRow (PropertyMapRow row);
		void VisitPropertyPtrRow (PropertyPtrRow row);
		void VisitStandAloneSigRow (StandAloneSigRow row);
		void VisitTypeDefRow (TypeDefRow row);
		void VisitTypeRefRow (TypeRefRow row);
		void VisitTypeSpecRow (TypeSpecRow row);

		void TerminateRowCollection (RowCollection coll);
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/ImplMap.cs
================================================
//
// ImplMapTable.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Tue Oct 10 23:08:26 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	using Mono.Cecil;

	public sealed class ImplMapTable : IMetadataTable {

		public const int RId = 0x1c;

		RowCollection m_rows;

		public ImplMapRow this [int index] {
			get { return m_rows [index] as ImplMapRow; }
			set { m_rows [index] = value; }
		}

		public RowCollection Rows {
			get { return m_rows; }
			set { m_rows = value; }
		}

		public int Id {
			get { return RId; }
		}

		internal ImplMapTable ()
		{
		}

		public void Accept (IMetadataTableVisitor visitor)
		{
			visitor.VisitImplMapTable (this);
			this.Rows.Accept (visitor.GetRowVisitor ());
		}
	}

	public sealed class ImplMapRow : IMetadataRow {

		public PInvokeAttributes MappingFlags;
		public MetadataToken MemberForwarded;
		public uint ImportName;
		public uint ImportScope;

		internal ImplMapRow ()
		{
		}

		public void Accept (IMetadataRowVisitor visitor)
		{
			visitor.VisitImplMapRow (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/InterfaceImpl.cs
================================================
//
// InterfaceImplTable.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Tue Oct 10 23:08:26 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	public sealed class InterfaceImplTable : IMetadataTable {

		public const int RId = 0x09;

		RowCollection m_rows;

		public InterfaceImplRow this [int index] {
			get { return m_rows [index] as InterfaceImplRow; }
			set { m_rows [index] = value; }
		}

		public RowCollection Rows {
			get { return m_rows; }
			set { m_rows = value; }
		}

		public int Id {
			get { return RId; }
		}

		internal InterfaceImplTable ()
		{
		}

		public void Accept (IMetadataTableVisitor visitor)
		{
			visitor.VisitInterfaceImplTable (this);
			this.Rows.Accept (visitor.GetRowVisitor ());
		}
	}

	public sealed class InterfaceImplRow : IMetadataRow {

		public uint Class;
		public MetadataToken Interface;

		internal InterfaceImplRow ()
		{
		}

		public void Accept (IMetadataRowVisitor visitor)
		{
			visitor.VisitInterfaceImplRow (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/ManifestResource.cs
================================================
//
// ManifestResourceTable.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Tue Oct 10 23:08:26 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	using Mono.Cecil;

	public sealed class ManifestResourceTable : IMetadataTable {

		public const int RId = 0x28;

		RowCollection m_rows;

		public ManifestResourceRow this [int index] {
			get { return m_rows [index] as ManifestResourceRow; }
			set { m_rows [index] = value; }
		}

		public RowCollection Rows {
			get { return m_rows; }
			set { m_rows = value; }
		}

		public int Id {
			get { return RId; }
		}

		internal ManifestResourceTable ()
		{
		}

		public void Accept (IMetadataTableVisitor visitor)
		{
			visitor.VisitManifestResourceTable (this);
			this.Rows.Accept (visitor.GetRowVisitor ());
		}
	}

	public sealed class ManifestResourceRow : IMetadataRow {

		public uint Offset;
		public ManifestResourceAttributes Flags;
		public uint Name;
		public MetadataToken Implementation;

		internal ManifestResourceRow ()
		{
		}

		public void Accept (IMetadataRowVisitor visitor)
		{
			visitor.VisitManifestResourceRow (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/MemberRef.cs
================================================
//
// MemberRefTable.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Tue Oct 10 23:08:26 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	public sealed class MemberRefTable : IMetadataTable {

		public const int RId = 0x0a;

		RowCollection m_rows;

		public MemberRefRow this [int index] {
			get { return m_rows [index] as MemberRefRow; }
			set { m_rows [index] = value; }
		}

		public RowCollection Rows {
			get { return m_rows; }
			set { m_rows = value; }
		}

		public int Id {
			get { return RId; }
		}

		internal MemberRefTable ()
		{
		}

		public void Accept (IMetadataTableVisitor visitor)
		{
			visitor.VisitMemberRefTable (this);
			this.Rows.Accept (visitor.GetRowVisitor ());
		}
	}

	public sealed class MemberRefRow : IMetadataRow {

		public MetadataToken Class;
		public uint Name;
		public uint Signature;

		internal MemberRefRow ()
		{
		}

		public void Accept (IMetadataRowVisitor visitor)
		{
			visitor.VisitMemberRefRow (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/MetadataFormatException.cs
================================================
//
// MetadataFormatException.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	using System;

	using Mono.Cecil.Binary;

	public class MetadataFormatException : ImageFormatException {

		internal MetadataFormatException () : base ()
		{
		}

		internal MetadataFormatException (string message) : base (message)
		{
		}

		internal MetadataFormatException (string message, params string [] parameters) :
			base (string.Format (message, parameters))
		{
		}

		internal MetadataFormatException (string message, Exception inner) :
			base (message, inner)
		{
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/MetadataHeap.cs
================================================
//
// MetadataHeap.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	using System;

	using Mono.Cecil;

	public abstract class MetadataHeap : IMetadataVisitable  {

		MetadataStream m_stream;
		string m_name;
		byte [] m_data;

		public string Name {
			get { return m_name; }
		}

		public byte [] Data {
			get { return m_data; }
			set { m_data = value; }
		}

		public int IndexSize;

		internal MetadataHeap (MetadataStream stream, string name)
		{
			m_name = name;
			m_stream = stream;
		}

		public static MetadataHeap HeapFactory (MetadataStream stream)
		{
			switch (stream.Header.Name) {
			case MetadataStream.Tables :
			case MetadataStream.IncrementalTables :
				return new TablesHeap (stream);
			case MetadataStream.GUID :
				return new GuidHeap (stream);
			case MetadataStream.Strings :
				return new StringsHeap (stream);
			case MetadataStream.UserStrings :
				return new UserStringsHeap (stream);
			case MetadataStream.Blob :
				return new BlobHeap (stream);
			default :
				return null;
			}
		}

		public MetadataStream GetStream ()
		{
			return m_stream;
		}

		protected virtual byte [] ReadBytesFromStream (uint pos)
		{
			int start, length = Utilities.ReadCompressedInteger (m_data, (int) pos, out start);
			byte [] buffer = new byte [length];
			Buffer.BlockCopy (m_data, start, buffer, 0, length);
			return buffer;
		}

		public abstract void Accept (IMetadataVisitor visitor);
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/MetadataInitializer.cs
================================================
//
// MetadataInitializer.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	using System;
	using System.IO;
	using System.Text;

	using Mono.Cecil;
	using Mono.Cecil.Binary;

	class MetadataInitializer : BaseMetadataVisitor {

		MetadataRoot m_root;

		public MetadataInitializer (ImageInitializer init)
		{
			m_root = init.Image.MetadataRoot;
		}

		public override void VisitMetadataRoot (MetadataRoot root)
		{
			root.Header = new MetadataRoot.MetadataRootHeader ();
			root.Streams = new MetadataStreamCollection ();
		}

		public override void VisitMetadataRootHeader (MetadataRoot.MetadataRootHeader header)
		{
			header.SetDefaultValues ();
		}

		public override void VisitMetadataStreamCollection (MetadataStreamCollection coll)
		{
			MetadataStream tables = new MetadataStream ();
			tables.Header.Name = MetadataStream.Tables;
			tables.Heap = MetadataHeap.HeapFactory (tables);
			TablesHeap th = tables.Heap as TablesHeap;
			th.Tables = new TableCollection (th);
			m_root.Streams.Add (tables);
		}

		public override void VisitTablesHeap (TablesHeap th)
		{
			th.Reserved = 0;
			th.MajorVersion = 1;
			th.MinorVersion = 0;
			th.Reserved2 = 1;
			th.Sorted = 0x2003301fa00;
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/MetadataReader.cs
================================================
//
// MetadataReader.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	using System;
	using System.IO;
	using System.Text;

	using Mono.Cecil.Binary;

	class MetadataReader : BaseMetadataVisitor {

		ImageReader m_ir;
		BinaryReader m_binaryReader;
		MetadataTableReader m_tableReader;
		MetadataRoot m_root;

		public MetadataTableReader TableReader {
			get { return m_tableReader; }
		}

		public MetadataReader (ImageReader brv)
		{
			m_ir = brv;
			m_binaryReader = brv.GetReader ();
		}

		public MetadataRoot GetMetadataRoot ()
		{
			return m_root;
		}

		public BinaryReader GetDataReader (RVA rva)
		{
			return m_ir.Image.GetReaderAtVirtualAddress (rva);
		}

		public override void VisitMetadataRoot (MetadataRoot root)
		{
			m_root = root;
			root.Header = new MetadataRoot.MetadataRootHeader ();
			root.Streams = new MetadataStreamCollection ();
		}

		public override void VisitMetadataRootHeader (MetadataRoot.MetadataRootHeader header)
		{
			long headpos = m_binaryReader.BaseStream.Position;

			header.Signature = m_binaryReader.ReadUInt32 ();

			if (header.Signature != MetadataRoot.MetadataRootHeader.StandardSignature)
				throw new MetadataFormatException ("Wrong magic number");

			header.MajorVersion = m_binaryReader.ReadUInt16 ();
			header.MinorVersion = m_binaryReader.ReadUInt16 ();
			header.Reserved = m_binaryReader.ReadUInt32 ();

			// read version
			uint length = m_binaryReader.ReadUInt32 ();
			if (length != 0) {
				long pos = m_binaryReader.BaseStream.Position;

				byte [] version, buffer = new byte [length];
				int read = 0;
				while (read < length) {
					byte cur = (byte)m_binaryReader.ReadSByte ();
					if (cur == 0)
						break;
					buffer [read++] = cur;
				}
				version = new byte [read];
				Buffer.BlockCopy (buffer, 0, version, 0, read);
				header.Version = Encoding.UTF8.GetString (version, 0, version.Length);

				pos += length - headpos + 3;
				pos &= ~3;
				pos += headpos;

				m_binaryReader.BaseStream.Position = pos;
			} else
				header.Version = string.Empty;

			header.Flags = m_binaryReader.ReadUInt16 ();
			header.Streams = m_binaryReader.ReadUInt16 ();
		}

		public override void VisitMetadataStreamCollection (MetadataStreamCollection coll)
		{
			for (int i = 0; i < m_root.Header.Streams; i++)
				coll.Add (new MetadataStream ());
		}

		public override void VisitMetadataStreamHeader (MetadataStream.MetadataStreamHeader header)
		{
			header.Offset = m_binaryReader.ReadUInt32 ();
			header.Size = m_binaryReader.ReadUInt32 ();

			StringBuilder buffer = new StringBuilder ();
			while (true) {
				char cur = (char) m_binaryReader.ReadSByte ();
				if (cur == '\0')
					break;
				buffer.Append (cur);
			}
			header.Name = buffer.ToString ();
			if (header.Name.Length == 0)
				throw new MetadataFormatException ("Invalid stream name");

			long rootpos = m_root.GetImage ().ResolveVirtualAddress (
				m_root.GetImage ().CLIHeader.Metadata.VirtualAddress);

			long curpos = m_binaryReader.BaseStream.Position;

			if (header.Size != 0)
				curpos -= rootpos;

			curpos += 3;
			curpos &= ~3;

			if (header.Size != 0)
				curpos += rootpos;

			m_binaryReader.BaseStream.Position = curpos;

			header.Stream.Heap = MetadataHeap.HeapFactory (header.Stream);
		}

		public override void VisitGuidHeap (GuidHeap heap)
		{
			VisitHeap (heap);
		}

		public override void VisitStringsHeap (StringsHeap heap)
		{
			VisitHeap (heap);

			if (heap.Data.Length < 1 && heap.Data [0] != 0)
				throw new MetadataFormatException ("Malformed #Strings heap");

			heap [(uint) 0] = string.Empty;
		}

		public override void VisitTablesHeap (TablesHeap heap)
		{
			VisitHeap (heap);
			heap.Tables = new TableCollection (heap);

			BinaryReader br = new BinaryReader (
					   new MemoryStream (heap.Data));
			try {
				heap.Reserved = br.ReadUInt32 ();
				heap.MajorVersion = br.ReadByte ();
				heap.MinorVersion = br.ReadByte ();
				heap.HeapSizes = br.ReadByte ();
				heap.Reserved2 = br.ReadByte ();
				heap.Valid = br.ReadInt64 ();
				heap.Sorted = br.ReadInt64 ();
			} finally {
				// COMPACT FRAMEWORK NOTE: BinaryReader is not IDisposable
				br.Close();
			}
		}

		public override void VisitBlobHeap (BlobHeap heap)
		{
			VisitHeap (heap);
		}

		public override void VisitUserStringsHeap (UserStringsHeap heap)
		{
			VisitHeap (heap);
		}

		void VisitHeap (MetadataHeap heap)
		{
			long cursor = m_binaryReader.BaseStream.Position;

			m_binaryReader.BaseStream.Position = m_root.GetImage ().ResolveVirtualAddress (
				m_root.GetImage ().CLIHeader.Metadata.VirtualAddress)
				+ heap.GetStream ().Header.Offset;

			heap.Data = m_binaryReader.ReadBytes ((int) heap.GetStream ().Header.Size);

			m_binaryReader.BaseStream.Position = cursor;
		}

		void SetHeapIndexSize (MetadataHeap heap, byte flag)
		{
			if (heap == null)
				return;
			TablesHeap th = m_root.Streams.TablesHeap;
			heap.IndexSize = ((th.HeapSizes & flag) > 0) ? 4 : 2;
		}

		public override void TerminateMetadataRoot (MetadataRoot root)
		{
			SetHeapIndexSize (root.Streams.StringsHeap, 0x01);
			SetHeapIndexSize (root.Streams.GuidHeap, 0x02);
			SetHeapIndexSize (root.Streams.BlobHeap, 0x04);
			m_tableReader = new MetadataTableReader (this);
			root.Streams.TablesHeap.Tables.Accept (m_tableReader);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/MetadataRoot.cs
================================================
//
// MetadataRoot.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	using Mono.Cecil.Binary;

	public sealed class MetadataRoot : IMetadataVisitable {

		MetadataRootHeader m_header;
		Image m_image;

		MetadataStreamCollection m_streams;

		public MetadataRootHeader Header {
			get { return m_header; }
			set { m_header = value; }
		}

		public MetadataStreamCollection Streams {
			get { return m_streams; }
			set { m_streams = value; }
		}

		internal MetadataRoot (Image img)
		{
			m_image = img;
		}

		public Image GetImage ()
		{
			return m_image;
		}

		public void Accept (IMetadataVisitor visitor)
		{
			visitor.VisitMetadataRoot (this);

			m_header.Accept (visitor);
			m_streams.Accept (visitor);

			visitor.TerminateMetadataRoot (this);
		}

		public sealed class MetadataRootHeader : IHeader, IMetadataVisitable {

			public const uint StandardSignature = 0x424a5342;

			public uint Signature;
			public ushort MinorVersion;
			public ushort MajorVersion;
			public uint Reserved;
			public string Version;
			public ushort Flags;
			public ushort Streams;

			internal MetadataRootHeader ()
			{
			}

			public void SetDefaultValues ()
			{
				Signature = StandardSignature;
				Reserved = 0;
				Flags = 0;
			}

			public void Accept (IMetadataVisitor visitor)
			{
				visitor.VisitMetadataRootHeader (this);
			}
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/MetadataRowReader.cs
================================================
//
// MetadataRowReader.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Thu Feb 22 14:39:38 CET 2007
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	using System;
	using System.Collections;
	using System.IO;

	using Mono.Cecil.Binary;

	class MetadataRowReader : BaseMetadataRowVisitor {

		MetadataTableReader m_mtrv;
		BinaryReader m_binaryReader;
		MetadataRoot m_metadataRoot;
		IDictionary m_ciCache;

		int m_blobHeapIdxSz;
		int m_stringsHeapIdxSz;
		int m_guidHeapIdxSz;

		public MetadataRowReader (MetadataTableReader mtrv)
		{
			m_mtrv = mtrv;
			m_binaryReader = mtrv.GetReader ();
			m_metadataRoot = mtrv.GetMetadataRoot ();
			m_ciCache = new Hashtable ();
		}

		int GetIndexSize (int rid)
		{
			return m_mtrv.GetNumberOfRows (rid) < (1 << 16) ? 2 : 4;
		}

		int GetCodedIndexSize (CodedIndex ci)
		{
			return Utilities.GetCodedIndexSize (ci,
				new Utilities.TableRowCounter (m_mtrv.GetNumberOfRows), m_ciCache);
		}

		uint ReadByIndexSize (int size)
		{
			if (size == 2) {
				return (uint) m_binaryReader.ReadUInt16 ();
			} else if (size == 4) {
				return m_binaryReader.ReadUInt32 ();
			} else {
				throw new MetadataFormatException ("Non valid size for indexing");
			}
		}

		public override void VisitRowCollection (RowCollection coll)
		{
			m_blobHeapIdxSz = m_metadataRoot.Streams.BlobHeap != null ?
				m_metadataRoot.Streams.BlobHeap.IndexSize : 2;
			m_stringsHeapIdxSz = m_metadataRoot.Streams.StringsHeap != null ?
				m_metadataRoot.Streams.StringsHeap.IndexSize : 2;
			m_guidHeapIdxSz = m_metadataRoot.Streams.GuidHeap != null ?
				m_metadataRoot.Streams.GuidHeap.IndexSize : 2;
		}

		public override void VisitAssemblyRow (AssemblyRow row)
		{
			row.HashAlgId = (Mono.Cecil.AssemblyHashAlgorithm) m_binaryReader.ReadUInt32 ();
			row.MajorVersion = m_binaryReader.ReadUInt16 ();
			row.MinorVersion = m_binaryReader.ReadUInt16 ();
			row.BuildNumber = m_binaryReader.ReadUInt16 ();
			row.RevisionNumber = m_binaryReader.ReadUInt16 ();
			row.Flags = (Mono.Cecil.AssemblyFlags) m_binaryReader.ReadUInt32 ();
			row.PublicKey = ReadByIndexSize (m_blobHeapIdxSz);
			row.Name = ReadByIndexSize (m_stringsHeapIdxSz);
			row.Culture = ReadByIndexSize (m_stringsHeapIdxSz);
		}
		public override void VisitAssemblyOSRow (AssemblyOSRow row)
		{
			row.OSPlatformID = m_binaryReader.ReadUInt32 ();
			row.OSMajorVersion = m_binaryReader.ReadUInt32 ();
			row.OSMinorVersion = m_binaryReader.ReadUInt32 ();
		}
		public override void VisitAssemblyProcessorRow (AssemblyProcessorRow row)
		{
			row.Processor = m_binaryReader.ReadUInt32 ();
		}
		public override void VisitAssemblyRefRow (AssemblyRefRow row)
		{
			row.MajorVersion = m_binaryReader.ReadUInt16 ();
			row.MinorVersion = m_binaryReader.ReadUInt16 ();
			row.BuildNumber = m_binaryReader.ReadUInt16 ();
			row.RevisionNumber = m_binaryReader.ReadUInt16 ();
			row.Flags = (Mono.Cecil.AssemblyFlags) m_binaryReader.ReadUInt32 ();
			row.PublicKeyOrToken = ReadByIndexSize (m_blobHeapIdxSz);
			row.Name = ReadByIndexSize (m_stringsHeapIdxSz);
			row.Culture = ReadByIndexSize (m_stringsHeapIdxSz);
			row.HashValue = ReadByIndexSize (m_blobHeapIdxSz);
		}
		public override void VisitAssemblyRefOSRow (AssemblyRefOSRow row)
		{
			row.OSPlatformID = m_binaryReader.ReadUInt32 ();
			row.OSMajorVersion = m_binaryReader.ReadUInt32 ();
			row.OSMinorVersion = m_binaryReader.ReadUInt32 ();
			row.AssemblyRef = ReadByIndexSize (GetIndexSize (AssemblyRefTable.RId));
		}
		public override void VisitAssemblyRefProcessorRow (AssemblyRefProcessorRow row)
		{
			row.Processor = m_binaryReader.ReadUInt32 ();
			row.AssemblyRef = ReadByIndexSize (GetIndexSize (AssemblyRefTable.RId));
		}
		public override void VisitClassLayoutRow (ClassLayoutRow row)
		{
			row.PackingSize = m_binaryReader.ReadUInt16 ();
			row.ClassSize = m_binaryReader.ReadUInt32 ();
			row.Parent = ReadByIndexSize (GetIndexSize (TypeDefTable.RId));
		}
		public override void VisitConstantRow (ConstantRow row)
		{
			row.Type = (Mono.Cecil.Metadata.ElementType) m_binaryReader.ReadUInt16 ();
			row.Parent = Utilities.GetMetadataToken (CodedIndex.HasConstant,
				ReadByIndexSize (GetCodedIndexSize (CodedIndex.HasConstant)));
			row.Value = ReadByIndexSize (m_blobHeapIdxSz);
		}
		public override void VisitCustomAttributeRow (CustomAttributeRow row)
		{
			row.Parent = Utilities.GetMetadataToken (CodedIndex.HasCustomAttribute,
				ReadByIndexSize (GetCodedIndexSize (CodedIndex.HasCustomAttribute)));
			row.Type = Utilities.GetMetadataToken (CodedIndex.CustomAttributeType,
				ReadByIndexSize (GetCodedIndexSize (CodedIndex.CustomAttributeType)));
			row.Value = ReadByIndexSize (m_blobHeapIdxSz);
		}
		public override void VisitDeclSecurityRow (DeclSecurityRow row)
		{
			row.Action = (Mono.Cecil.SecurityAction) m_binaryReader.ReadInt16 ();
			row.Parent = Utilities.GetMetadataToken (CodedIndex.HasDeclSecurity,
				ReadByIndexSize (GetCodedIndexSize (CodedIndex.HasDeclSecurity)));
			row.PermissionSet = ReadByIndexSize (m_blobHeapIdxSz);
		}
		public override void VisitEventRow (EventRow row)
		{
			row.EventFlags = (Mono.Cecil.EventAttributes) m_binaryReader.ReadUInt16 ();
			row.Name = ReadByIndexSize (m_stringsHeapIdxSz);
			row.EventType = Utilities.GetMetadataToken (CodedIndex.TypeDefOrRef,
				ReadByIndexSize (GetCodedIndexSize (CodedIndex.TypeDefOrRef)));
		}
		public override void VisitEventMapRow (EventMapRow row)
		{
			row.Parent = ReadByIndexSize (GetIndexSize (TypeDefTable.RId));
			row.EventList = ReadByIndexSize (GetIndexSize (EventTable.RId));
		}
		public override void VisitEventPtrRow (EventPtrRow row)
		{
			row.Event = ReadByIndexSize (GetIndexSize (EventTable.RId));
		}
		public override void VisitExportedTypeRow (ExportedTypeRow row)
		{
			row.Flags = (Mono.Cecil.TypeAttributes) m_binaryReader.ReadUInt32 ();
			row.TypeDefId = m_binaryReader.ReadUInt32 ();
			row.TypeName = ReadByIndexSize (m_stringsHeapIdxSz);
			row.TypeNamespace = ReadByIndexSize (m_stringsHeapIdxSz);
			row.Implementation = Utilities.GetMetadataToken (CodedIndex.Implementation,
				ReadByIndexSize (GetCodedIndexSize (CodedIndex.Implementation)));
		}
		public override void VisitFieldRow (FieldRow row)
		{
			row.Flags = (Mono.Cecil.FieldAttributes) m_binaryReader.ReadUInt16 ();
			row.Name = ReadByIndexSize (m_stringsHeapIdxSz);
			row.Signature = ReadByIndexSize (m_blobHeapIdxSz);
		}
		public override void VisitFieldLayoutRow (FieldLayoutRow row)
		{
			row.Offset = m_binaryReader.ReadUInt32 ();
			row.Field = ReadByIndexSize (GetIndexSize (FieldTable.RId));
		}
		public override void VisitFieldMarshalRow (FieldMarshalRow row)
		{
			row.Parent = Utilities.GetMetadataToken (CodedIndex.HasFieldMarshal,
				ReadByIndexSize (GetCodedIndexSize (CodedIndex.HasFieldMarshal)));
			row.NativeType = ReadByIndexSize (m_blobHeapIdxSz);
		}
		public override void VisitFieldPtrRow (FieldPtrRow row)
		{
			row.Field = ReadByIndexSize (GetIndexSize (FieldTable.RId));
		}
		public override void VisitFieldRVARow (FieldRVARow row)
		{
			row.RVA = new RVA (m_binaryReader.ReadUInt32 ());
			row.Field = ReadByIndexSize (GetIndexSize (FieldTable.RId));
		}
		public override void VisitFileRow (FileRow row)
		{
			row.Flags = (Mono.Cecil.FileAttributes) m_binaryReader.ReadUInt32 ();
			row.Name = ReadByIndexSize (m_stringsHeapIdxSz);
			row.HashValue = ReadByIndexSize (m_blobHeapIdxSz);
		}
		public override void VisitGenericParamRow (GenericParamRow row)
		{
			row.Number = m_binaryReader.ReadUInt16 ();
			row.Flags = (Mono.Cecil.GenericParameterAttributes) m_binaryReader.ReadUInt16 ();
			row.Owner = Utilities.GetMetadataToken (CodedIndex.TypeOrMethodDef,
				ReadByIndexSize (GetCodedIndexSize (CodedIndex.TypeOrMethodDef)));
			row.Name = ReadByIndexSize (m_stringsHeapIdxSz);
		}
		public override void VisitGenericParamConstraintRow (GenericParamConstraintRow row)
		{
			row.Owner = ReadByIndexSize (GetIndexSize (GenericParamTable.RId));
			row.Constraint = Utilities.GetMetadataToken (CodedIndex.TypeDefOrRef,
				ReadByIndexSize (GetCodedIndexSize (CodedIndex.TypeDefOrRef)));
		}
		public override void VisitImplMapRow (ImplMapRow row)
		{
			row.MappingFlags = (Mono.Cecil.PInvokeAttributes) m_binaryReader.ReadUInt16 ();
			row.MemberForwarded = Utilities.GetMetadataToken (CodedIndex.MemberForwarded,
				ReadByIndexSize (GetCodedIndexSize (CodedIndex.MemberForwarded)));
			row.ImportName = ReadByIndexSize (m_stringsHeapIdxSz);
			row.ImportScope = ReadByIndexSize (GetIndexSize (ModuleRefTable.RId));
		}
		public override void VisitInterfaceImplRow (InterfaceImplRow row)
		{
			row.Class = ReadByIndexSize (GetIndexSize (TypeDefTable.RId));
			row.Interface = Utilities.GetMetadataToken (CodedIndex.TypeDefOrRef,
				ReadByIndexSize (GetCodedIndexSize (CodedIndex.TypeDefOrRef)));
		}
		public override void VisitManifestResourceRow (ManifestResourceRow row)
		{
			row.Offset = m_binaryReader.ReadUInt32 ();
			row.Flags = (Mono.Cecil.ManifestResourceAttributes) m_binaryReader.ReadUInt32 ();
			row.Name = ReadByIndexSize (m_stringsHeapIdxSz);
			row.Implementation = Utilities.GetMetadataToken (CodedIndex.Implementation,
				ReadByIndexSize (GetCodedIndexSize (CodedIndex.Implementation)));
		}
		public override void VisitMemberRefRow (MemberRefRow row)
		{
			row.Class = Utilities.GetMetadataToken (CodedIndex.MemberRefParent,
				ReadByIndexSize (GetCodedIndexSize (CodedIndex.MemberRefParent)));
			row.Name = ReadByIndexSize (m_stringsHeapIdxSz);
			row.Signature = ReadByIndexSize (m_blobHeapIdxSz);
		}
		public override void VisitMethodRow (MethodRow row)
		{
			row.RVA = new RVA (m_binaryReader.ReadUInt32 ());
			row.ImplFlags = (Mono.Cecil.MethodImplAttributes) m_binaryReader.ReadUInt16 ();
			row.Flags = (Mono.Cecil.MethodAttributes) m_binaryReader.ReadUInt16 ();
			row.Name = ReadByIndexSize (m_stringsHeapIdxSz);
			row.Signature = ReadByIndexSize (m_blobHeapIdxSz);
			row.ParamList = ReadByIndexSize (GetIndexSize (ParamTable.RId));
		}
		public override void VisitMethodImplRow (MethodImplRow row)
		{
			row.Class = ReadByIndexSize (GetIndexSize (TypeDefTable.RId));
			row.MethodBody = Utilities.GetMetadataToken (CodedIndex.MethodDefOrRef,
				ReadByIndexSize (GetCodedIndexSize (CodedIndex.MethodDefOrRef)));
			row.MethodDeclaration = Utilities.GetMetadataToken (CodedIndex.MethodDefOrRef,
				ReadByIndexSize (GetCodedIndexSize (CodedIndex.MethodDefOrRef)));
		}
		public override void VisitMethodPtrRow (MethodPtrRow row)
		{
			row.Method = ReadByIndexSize (GetIndexSize (MethodTable.RId));
		}
		public override void VisitMethodSemanticsRow (MethodSemanticsRow row)
		{
			row.Semantics = (Mono.Cecil.MethodSemanticsAttributes) m_binaryReader.ReadUInt16 ();
			row.Method = ReadByIndexSize (GetIndexSize (MethodTable.RId));
			row.Association = Utilities.GetMetadataToken (CodedIndex.HasSemantics,
				ReadByIndexSize (GetCodedIndexSize (CodedIndex.HasSemantics)));
		}
		public override void VisitMethodSpecRow (MethodSpecRow row)
		{
			row.Method = Utilities.GetMetadataToken (CodedIndex.MethodDefOrRef,
				ReadByIndexSize (GetCodedIndexSize (CodedIndex.MethodDefOrRef)));
			row.Instantiation = ReadByIndexSize (m_blobHeapIdxSz);
		}
		public override void VisitModuleRow (ModuleRow row)
		{
			row.Generation = m_binaryReader.ReadUInt16 ();
			row.Name = ReadByIndexSize (m_stringsHeapIdxSz);
			row.Mvid = ReadByIndexSize (m_guidHeapIdxSz);
			row.EncId = ReadByIndexSize (m_guidHeapIdxSz);
			row.EncBaseId = ReadByIndexSize (m_guidHeapIdxSz);
		}
		public override void VisitModuleRefRow (ModuleRefRow row)
		{
			row.Name = ReadByIndexSize (m_stringsHeapIdxSz);
		}
		public override void VisitNestedClassRow (NestedClassRow row)
		{
			row.NestedClass = ReadByIndexSize (GetIndexSize (TypeDefTable.RId));
			row.EnclosingClass = ReadByIndexSize (GetIndexSize (TypeDefTable.RId));
		}
		public override void VisitParamRow (ParamRow row)
		{
			row.Flags = (Mono.Cecil.ParameterAttributes) m_binaryReader.ReadUInt16 ();
			row.Sequence = m_binaryReader.ReadUInt16 ();
			row.Name = ReadByIndexSize (m_stringsHeapIdxSz);
		}
		public override void VisitParamPtrRow (ParamPtrRow row)
		{
			row.Param = ReadByIndexSize (GetIndexSize (ParamTable.RId));
		}
		public override void VisitPropertyRow (PropertyRow row)
		{
			row.Flags = (Mono.Cecil.PropertyAttributes) m_binaryReader.ReadUInt16 ();
			row.Name = ReadByIndexSize (m_stringsHeapIdxSz);
			row.Type = ReadByIndexSize (m_blobHeapIdxSz);
		}
		public override void VisitPropertyMapRow (PropertyMapRow row)
		{
			row.Parent = ReadByIndexSize (GetIndexSize (TypeDefTable.RId));
			row.PropertyList = ReadByIndexSize (GetIndexSize (PropertyTable.RId));
		}
		public override void VisitPropertyPtrRow (PropertyPtrRow row)
		{
			row.Property = ReadByIndexSize (GetIndexSize (PropertyTable.RId));
		}
		public override void VisitStandAloneSigRow (StandAloneSigRow row)
		{
			row.Signature = ReadByIndexSize (m_blobHeapIdxSz);
		}
		public override void VisitTypeDefRow (TypeDefRow row)
		{
			row.Flags = (Mono.Cecil.TypeAttributes) m_binaryReader.ReadUInt32 ();
			row.Name = ReadByIndexSize (m_stringsHeapIdxSz);
			row.Namespace = ReadByIndexSize (m_stringsHeapIdxSz);
			row.Extends = Utilities.GetMetadataToken (CodedIndex.TypeDefOrRef,
				ReadByIndexSize (GetCodedIndexSize (CodedIndex.TypeDefOrRef)));
			row.FieldList = ReadByIndexSize (GetIndexSize (FieldTable.RId));
			row.MethodList = ReadByIndexSize (GetIndexSize (MethodTable.RId));
		}
		public override void VisitTypeRefRow (TypeRefRow row)
		{
			row.ResolutionScope = Utilities.GetMetadataToken (CodedIndex.ResolutionScope,
				ReadByIndexSize (GetCodedIndexSize (CodedIndex.ResolutionScope)));
			row.Name = ReadByIndexSize (m_stringsHeapIdxSz);
			row.Namespace = ReadByIndexSize (m_stringsHeapIdxSz);
		}
		public override void VisitTypeSpecRow (TypeSpecRow row)
		{
			row.Signature = ReadByIndexSize (m_blobHeapIdxSz);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/MetadataRowWriter.cs
================================================
//
// MetadataRowWriter.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Thu Feb 22 14:39:38 CET 2007
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	using System;
	using System.Collections;

	using Mono.Cecil.Binary;

	class MetadataRowWriter : BaseMetadataRowVisitor {

		MetadataRoot m_root;
		MemoryBinaryWriter m_binaryWriter;
		IDictionary m_ciCache;

		int m_blobHeapIdxSz;
		int m_stringsHeapIdxSz;
		int m_guidHeapIdxSz;

		public MetadataRowWriter (MetadataTableWriter mtwv)
		{
			m_binaryWriter = mtwv.GetWriter ();
			m_root = mtwv.GetMetadataRoot ();
			m_ciCache = new Hashtable ();
		}

		void WriteBlobPointer (uint pointer)
		{
			WriteByIndexSize (pointer, m_blobHeapIdxSz);
		}

		void WriteStringPointer (uint pointer)
		{
			WriteByIndexSize (pointer, m_stringsHeapIdxSz);
		}

		void WriteGuidPointer (uint pointer)
		{
			WriteByIndexSize (pointer, m_guidHeapIdxSz);
		}

		void WriteTablePointer (uint pointer, int rid)
		{
			WriteByIndexSize (pointer, GetNumberOfRows (rid) < (1 << 16) ? 2 : 4);
		}

		void WriteMetadataToken (MetadataToken token, CodedIndex ci)
		{
			WriteByIndexSize (Utilities.CompressMetadataToken (ci, token),
				Utilities.GetCodedIndexSize (
					ci, new Utilities.TableRowCounter (GetNumberOfRows), m_ciCache));
		}

		int GetNumberOfRows (int rid)
		{
			IMetadataTable t = m_root.Streams.TablesHeap [rid];
			if (t == null || t.Rows == null)
				return 0;
			return t.Rows.Count;
		}

		void WriteByIndexSize (uint value, int size)
		{
			if (size == 4)
				m_binaryWriter.Write (value);
			else if (size == 2)
				m_binaryWriter.Write ((ushort) value);
			else
				throw new MetadataFormatException ("Non valid size for indexing");
		}

		public AssemblyRow CreateAssemblyRow (AssemblyHashAlgorithm _hashAlgId, ushort _majorVersion, ushort _minorVersion, ushort _buildNumber, ushort _revisionNumber, AssemblyFlags _flags, uint _publicKey, uint _name, uint _culture)
		{
			AssemblyRow row = new AssemblyRow ();
			row.HashAlgId = _hashAlgId;
			row.MajorVersion = _majorVersion;
			row.MinorVersion = _minorVersion;
			row.BuildNumber = _buildNumber;
			row.RevisionNumber = _revisionNumber;
			row.Flags = _flags;
			row.PublicKey = _publicKey;
			row.Name = _name;
			row.Culture = _culture;
			return row;
		}

		public AssemblyOSRow CreateAssemblyOSRow (uint _oSPlatformID, uint _oSMajorVersion, uint _oSMinorVersion)
		{
			AssemblyOSRow row = new AssemblyOSRow ();
			row.OSPlatformID = _oSPlatformID;
			row.OSMajorVersion = _oSMajorVersion;
			row.OSMinorVersion = _oSMinorVersion;
			return row;
		}

		public AssemblyProcessorRow CreateAssemblyProcessorRow (uint _processor)
		{
			AssemblyProcessorRow row = new AssemblyProcessorRow ();
			row.Processor = _processor;
			return row;
		}

		public AssemblyRefRow CreateAssemblyRefRow (ushort _majorVersion, ushort _minorVersion, ushort _buildNumber, ushort _revisionNumber, AssemblyFlags _flags, uint _publicKeyOrToken, uint _name, uint _culture, uint _hashValue)
		{
			AssemblyRefRow row = new AssemblyRefRow ();
			row.MajorVersion = _majorVersion;
			row.MinorVersion = _minorVersion;
			row.BuildNumber = _buildNumber;
			row.RevisionNumber = _revisionNumber;
			row.Flags = _flags;
			row.PublicKeyOrToken = _publicKeyOrToken;
			row.Name = _name;
			row.Culture = _culture;
			row.HashValue = _hashValue;
			return row;
		}

		public AssemblyRefOSRow CreateAssemblyRefOSRow (uint _oSPlatformID, uint _oSMajorVersion, uint _oSMinorVersion, uint _assemblyRef)
		{
			AssemblyRefOSRow row = new AssemblyRefOSRow ();
			row.OSPlatformID = _oSPlatformID;
			row.OSMajorVersion = _oSMajorVersion;
			row.OSMinorVersion = _oSMinorVersion;
			row.AssemblyRef = _assemblyRef;
			return row;
		}

		public AssemblyRefProcessorRow CreateAssemblyRefProcessorRow (uint _processor, uint _assemblyRef)
		{
			AssemblyRefProcessorRow row = new AssemblyRefProcessorRow ();
			row.Processor = _processor;
			row.AssemblyRef = _assemblyRef;
			return row;
		}

		public ClassLayoutRow CreateClassLayoutRow (ushort _packingSize, uint _classSize, uint _parent)
		{
			ClassLayoutRow row = new ClassLayoutRow ();
			row.PackingSize = _packingSize;
			row.ClassSize = _classSize;
			row.Parent = _parent;
			return row;
		}

		public ConstantRow CreateConstantRow (ElementType _type, MetadataToken _parent, uint _value)
		{
			ConstantRow row = new ConstantRow ();
			row.Type = _type;
			row.Parent = _parent;
			row.Value = _value;
			return row;
		}

		public CustomAttributeRow CreateCustomAttributeRow (MetadataToken _parent, MetadataToken _type, uint _value)
		{
			CustomAttributeRow row = new CustomAttributeRow ();
			row.Parent = _parent;
			row.Type = _type;
			row.Value = _value;
			return row;
		}

		public DeclSecurityRow CreateDeclSecurityRow (SecurityAction _action, MetadataToken _parent, uint _permissionSet)
		{
			DeclSecurityRow row = new DeclSecurityRow ();
			row.Action = _action;
			row.Parent = _parent;
			row.PermissionSet = _permissionSet;
			return row;
		}

		public EventRow CreateEventRow (EventAttributes _eventFlags, uint _name, MetadataToken _eventType)
		{
			EventRow row = new EventRow ();
			row.EventFlags = _eventFlags;
			row.Name = _name;
			row.EventType = _eventType;
			return row;
		}

		public EventMapRow CreateEventMapRow (uint _parent, uint _eventList)
		{
			EventMapRow row = new EventMapRow ();
			row.Parent = _parent;
			row.EventList = _eventList;
			return row;
		}

		public EventPtrRow CreateEventPtrRow (uint _event)
		{
			EventPtrRow row = new EventPtrRow ();
			row.Event = _event;
			return row;
		}

		public ExportedTypeRow CreateExportedTypeRow (TypeAttributes _flags, uint _typeDefId, uint _typeName, uint _typeNamespace, MetadataToken _implementation)
		{
			ExportedTypeRow row = new ExportedTypeRow ();
			row.Flags = _flags;
			row.TypeDefId = _typeDefId;
			row.TypeName = _typeName;
			row.TypeNamespace = _typeNamespace;
			row.Implementation = _implementation;
			return row;
		}

		public FieldRow CreateFieldRow (FieldAttributes _flags, uint _name, uint _signature)
		{
			FieldRow row = new FieldRow ();
			row.Flags = _flags;
			row.Name = _name;
			row.Signature = _signature;
			return row;
		}

		public FieldLayoutRow CreateFieldLayoutRow (uint _offset, uint _field)
		{
			FieldLayoutRow row = new FieldLayoutRow ();
			row.Offset = _offset;
			row.Field = _field;
			return row;
		}

		public FieldMarshalRow CreateFieldMarshalRow (MetadataToken _parent, uint _nativeType)
		{
			FieldMarshalRow row = new FieldMarshalRow ();
			row.Parent = _parent;
			row.NativeType = _nativeType;
			return row;
		}

		public FieldPtrRow CreateFieldPtrRow (uint _field)
		{
			FieldPtrRow row = new FieldPtrRow ();
			row.Field = _field;
			return row;
		}

		public FieldRVARow CreateFieldRVARow (RVA _rVA, uint _field)
		{
			FieldRVARow row = new FieldRVARow ();
			row.RVA = _rVA;
			row.Field = _field;
			return row;
		}

		public FileRow CreateFileRow (FileAttributes _flags, uint _name, uint _hashValue)
		{
			FileRow row = new FileRow ();
			row.Flags = _flags;
			row.Name = _name;
			row.HashValue = _hashValue;
			return row;
		}

		public GenericParamRow CreateGenericParamRow (ushort _number, GenericParameterAttributes _flags, MetadataToken _owner, uint _name)
		{
			GenericParamRow row = new GenericParamRow ();
			row.Number = _number;
			row.Flags = _flags;
			row.Owner = _owner;
			row.Name = _name;
			return row;
		}

		public GenericParamConstraintRow CreateGenericParamConstraintRow (uint _owner, MetadataToken _constraint)
		{
			GenericParamConstraintRow row = new GenericParamConstraintRow ();
			row.Owner = _owner;
			row.Constraint = _constraint;
			return row;
		}

		public ImplMapRow CreateImplMapRow (PInvokeAttributes _mappingFlags, MetadataToken _memberForwarded, uint _importName, uint _importScope)
		{
			ImplMapRow row = new ImplMapRow ();
			row.MappingFlags = _mappingFlags;
			row.MemberForwarded = _memberForwarded;
			row.ImportName = _importName;
			row.ImportScope = _importScope;
			return row;
		}

		public InterfaceImplRow CreateInterfaceImplRow (uint _class, MetadataToken _interface)
		{
			InterfaceImplRow row = new InterfaceImplRow ();
			row.Class = _class;
			row.Interface = _interface;
			return row;
		}

		public ManifestResourceRow CreateManifestResourceRow (uint _offset, ManifestResourceAttributes _flags, uint _name, MetadataToken _implementation)
		{
			ManifestResourceRow row = new ManifestResourceRow ();
			row.Offset = _offset;
			row.Flags = _flags;
			row.Name = _name;
			row.Implementation = _implementation;
			return row;
		}

		public MemberRefRow CreateMemberRefRow (MetadataToken _class, uint _name, uint _signature)
		{
			MemberRefRow row = new MemberRefRow ();
			row.Class = _class;
			row.Name = _name;
			row.Signature = _signature;
			return row;
		}

		public MethodRow CreateMethodRow (RVA _rVA, MethodImplAttributes _implFlags, MethodAttributes _flags, uint _name, uint _signature, uint _paramList)
		{
			MethodRow row = new MethodRow ();
			row.RVA = _rVA;
			row.ImplFlags = _implFlags;
			row.Flags = _flags;
			row.Name = _name;
			row.Signature = _signature;
			row.ParamList = _paramList;
			return row;
		}

		public MethodImplRow CreateMethodImplRow (uint _class, MetadataToken _methodBody, MetadataToken _methodDeclaration)
		{
			MethodImplRow row = new MethodImplRow ();
			row.Class = _class;
			row.MethodBody = _methodBody;
			row.MethodDeclaration = _methodDeclaration;
			return row;
		}

		public MethodPtrRow CreateMethodPtrRow (uint _method)
		{
			MethodPtrRow row = new MethodPtrRow ();
			row.Method = _method;
			return row;
		}

		public MethodSemanticsRow CreateMethodSemanticsRow (MethodSemanticsAttributes _semantics, uint _method, MetadataToken _association)
		{
			MethodSemanticsRow row = new MethodSemanticsRow ();
			row.Semantics = _semantics;
			row.Method = _method;
			row.Association = _association;
			return row;
		}

		public MethodSpecRow CreateMethodSpecRow (MetadataToken _method, uint _instantiation)
		{
			MethodSpecRow row = new MethodSpecRow ();
			row.Method = _method;
			row.Instantiation = _instantiation;
			return row;
		}

		public ModuleRow CreateModuleRow (ushort _generation, uint _name, uint _mvid, uint _encId, uint _encBaseId)
		{
			ModuleRow row = new ModuleRow ();
			row.Generation = _generation;
			row.Name = _name;
			row.Mvid = _mvid;
			row.EncId = _encId;
			row.EncBaseId = _encBaseId;
			return row;
		}

		public ModuleRefRow CreateModuleRefRow (uint _name)
		{
			ModuleRefRow row = new ModuleRefRow ();
			row.Name = _name;
			return row;
		}

		public NestedClassRow CreateNestedClassRow (uint _nestedClass, uint _enclosingClass)
		{
			NestedClassRow row = new NestedClassRow ();
			row.NestedClass = _nestedClass;
			row.EnclosingClass = _enclosingClass;
			return row;
		}

		public ParamRow CreateParamRow (ParameterAttributes _flags, ushort _sequence, uint _name)
		{
			ParamRow row = new ParamRow ();
			row.Flags = _flags;
			row.Sequence = _sequence;
			row.Name = _name;
			return row;
		}

		public ParamPtrRow CreateParamPtrRow (uint _param)
		{
			ParamPtrRow row = new ParamPtrRow ();
			row.Param = _param;
			return row;
		}

		public PropertyRow CreatePropertyRow (PropertyAttributes _flags, uint _name, uint _type)
		{
			PropertyRow row = new PropertyRow ();
			row.Flags = _flags;
			row.Name = _name;
			row.Type = _type;
			return row;
		}

		public PropertyMapRow CreatePropertyMapRow (uint _parent, uint _propertyList)
		{
			PropertyMapRow row = new PropertyMapRow ();
			row.Parent = _parent;
			row.PropertyList = _propertyList;
			return row;
		}

		public PropertyPtrRow CreatePropertyPtrRow (uint _property)
		{
			PropertyPtrRow row = new PropertyPtrRow ();
			row.Property = _property;
			return row;
		}

		public StandAloneSigRow CreateStandAloneSigRow (uint _signature)
		{
			StandAloneSigRow row = new StandAloneSigRow ();
			row.Signature = _signature;
			return row;
		}

		public TypeDefRow CreateTypeDefRow (TypeAttributes _flags, uint _name, uint _namespace, MetadataToken _extends, uint _fieldList, uint _methodList)
		{
			TypeDefRow row = new TypeDefRow ();
			row.Flags = _flags;
			row.Name = _name;
			row.Namespace = _namespace;
			row.Extends = _extends;
			row.FieldList = _fieldList;
			row.MethodList = _methodList;
			return row;
		}

		public TypeRefRow CreateTypeRefRow (MetadataToken _resolutionScope, uint _name, uint _namespace)
		{
			TypeRefRow row = new TypeRefRow ();
			row.ResolutionScope = _resolutionScope;
			row.Name = _name;
			row.Namespace = _namespace;
			return row;
		}

		public TypeSpecRow CreateTypeSpecRow (uint _signature)
		{
			TypeSpecRow row = new TypeSpecRow ();
			row.Signature = _signature;
			return row;
		}

		public override void VisitRowCollection (RowCollection coll)
		{
			m_blobHeapIdxSz = m_root.Streams.BlobHeap != null ?
				m_root.Streams.BlobHeap.IndexSize : 2;
			m_stringsHeapIdxSz = m_root.Streams.StringsHeap != null ?
				m_root.Streams.StringsHeap.IndexSize : 2;
			m_guidHeapIdxSz = m_root.Streams.GuidHeap != null ?
				m_root.Streams.GuidHeap.IndexSize : 2;
		}

		public override void VisitAssemblyRow (AssemblyRow row)
		{
			m_binaryWriter.Write ((uint) row.HashAlgId);
			m_binaryWriter.Write (row.MajorVersion);
			m_binaryWriter.Write (row.MinorVersion);
			m_binaryWriter.Write (row.BuildNumber);
			m_binaryWriter.Write (row.RevisionNumber);
			m_binaryWriter.Write ((uint) row.Flags);
			WriteBlobPointer (row.PublicKey);
			WriteStringPointer (row.Name);
			WriteStringPointer (row.Culture);
		}

		public override void VisitAssemblyOSRow (AssemblyOSRow row)
		{
			m_binaryWriter.Write (row.OSPlatformID);
			m_binaryWriter.Write (row.OSMajorVersion);
			m_binaryWriter.Write (row.OSMinorVersion);
		}

		public override void VisitAssemblyProcessorRow (AssemblyProcessorRow row)
		{
			m_binaryWriter.Write (row.Processor);
		}

		public override void VisitAssemblyRefRow (AssemblyRefRow row)
		{
			m_binaryWriter.Write (row.MajorVersion);
			m_binaryWriter.Write (row.MinorVersion);
			m_binaryWriter.Write (row.BuildNumber);
			m_binaryWriter.Write (row.RevisionNumber);
			m_binaryWriter.Write ((uint) row.Flags);
			WriteBlobPointer (row.PublicKeyOrToken);
			WriteStringPointer (row.Name);
			WriteStringPointer (row.Culture);
			WriteBlobPointer (row.HashValue);
		}

		public override void VisitAssemblyRefOSRow (AssemblyRefOSRow row)
		{
			m_binaryWriter.Write (row.OSPlatformID);
			m_binaryWriter.Write (row.OSMajorVersion);
			m_binaryWriter.Write (row.OSMinorVersion);
			WriteTablePointer (row.AssemblyRef, AssemblyRefTable.RId);
		}

		public override void VisitAssemblyRefProcessorRow (AssemblyRefProcessorRow row)
		{
			m_binaryWriter.Write (row.Processor);
			WriteTablePointer (row.AssemblyRef, AssemblyRefTable.RId);
		}

		public override void VisitClassLayoutRow (ClassLayoutRow row)
		{
			m_binaryWriter.Write (row.PackingSize);
			m_binaryWriter.Write (row.ClassSize);
			WriteTablePointer (row.Parent, TypeDefTable.RId);
		}

		public override void VisitConstantRow (ConstantRow row)
		{
			m_binaryWriter.Write ((ushort) row.Type);
			WriteMetadataToken (row.Parent, CodedIndex.HasConstant);
			WriteBlobPointer (row.Value);
		}

		public override void VisitCustomAttributeRow (CustomAttributeRow row)
		{
			WriteMetadataToken (row.Parent, CodedIndex.HasCustomAttribute);
			WriteMetadataToken (row.Type, CodedIndex.CustomAttributeType);
			WriteBlobPointer (row.Value);
		}

		public override void VisitDeclSecurityRow (DeclSecurityRow row)
		{
			m_binaryWriter.Write ((short) row.Action);
			WriteMetadataToken (row.Parent, CodedIndex.HasDeclSecurity);
			WriteBlobPointer (row.PermissionSet);
		}

		public override void VisitEventRow (EventRow row)
		{
			m_binaryWriter.Write ((ushort) row.EventFlags);
			WriteStringPointer (row.Name);
			WriteMetadataToken (row.EventType, CodedIndex.TypeDefOrRef);
		}

		public override void VisitEventMapRow (EventMapRow row)
		{
			WriteTablePointer (row.Parent, TypeDefTable.RId);
			WriteTablePointer (row.EventList, EventTable.RId);
		}

		public override void VisitEventPtrRow (EventPtrRow row)
		{
			WriteTablePointer (row.Event, EventTable.RId);
		}

		public override void VisitExportedTypeRow (ExportedTypeRow row)
		{
			m_binaryWriter.Write ((uint) row.Flags);
			m_binaryWriter.Write (row.TypeDefId);
			WriteStringPointer (row.TypeName);
			WriteStringPointer (row.TypeNamespace);
			WriteMetadataToken (row.Implementation, CodedIndex.Implementation);
		}

		public override void VisitFieldRow (FieldRow row)
		{
			m_binaryWriter.Write ((ushort) row.Flags);
			WriteStringPointer (row.Name);
			WriteBlobPointer (row.Signature);
		}

		public override void VisitFieldLayoutRow (FieldLayoutRow row)
		{
			m_binaryWriter.Write (row.Offset);
			WriteTablePointer (row.Field, FieldTable.RId);
		}

		public override void VisitFieldMarshalRow (FieldMarshalRow row)
		{
			WriteMetadataToken (row.Parent, CodedIndex.HasFieldMarshal);
			WriteBlobPointer (row.NativeType);
		}

		public override void VisitFieldPtrRow (FieldPtrRow row)
		{
			WriteTablePointer (row.Field, FieldTable.RId);
		}

		public override void VisitFieldRVARow (FieldRVARow row)
		{
			m_binaryWriter.Write (row.RVA.Value);
			WriteTablePointer (row.Field, FieldTable.RId);
		}

		public override void VisitFileRow (FileRow row)
		{
			m_binaryWriter.Write ((uint) row.Flags);
			WriteStringPointer (row.Name);
			WriteBlobPointer (row.HashValue);
		}

		public override void VisitGenericParamRow (GenericParamRow row)
		{
			m_binaryWriter.Write (row.Number);
			m_binaryWriter.Write ((ushort) row.Flags);
			WriteMetadataToken (row.Owner, CodedIndex.TypeOrMethodDef);
			WriteStringPointer (row.Name);
		}

		public override void VisitGenericParamConstraintRow (GenericParamConstraintRow row)
		{
			WriteTablePointer (row.Owner, GenericParamTable.RId);
			WriteMetadataToken (row.Constraint, CodedIndex.TypeDefOrRef);
		}

		public override void VisitImplMapRow (ImplMapRow row)
		{
			m_binaryWriter.Write ((ushort) row.MappingFlags);
			WriteMetadataToken (row.MemberForwarded, CodedIndex.MemberForwarded);
			WriteStringPointer (row.ImportName);
			WriteTablePointer (row.ImportScope, ModuleRefTable.RId);
		}

		public override void VisitInterfaceImplRow (InterfaceImplRow row)
		{
			WriteTablePointer (row.Class, TypeDefTable.RId);
			WriteMetadataToken (row.Interface, CodedIndex.TypeDefOrRef);
		}

		public override void VisitManifestResourceRow (ManifestResourceRow row)
		{
			m_binaryWriter.Write (row.Offset);
			m_binaryWriter.Write ((uint) row.Flags);
			WriteStringPointer (row.Name);
			WriteMetadataToken (row.Implementation, CodedIndex.Implementation);
		}

		public override void VisitMemberRefRow (MemberRefRow row)
		{
			WriteMetadataToken (row.Class, CodedIndex.MemberRefParent);
			WriteStringPointer (row.Name);
			WriteBlobPointer (row.Signature);
		}

		public override void VisitMethodRow (MethodRow row)
		{
			m_binaryWriter.Write (row.RVA.Value);
			m_binaryWriter.Write ((ushort) row.ImplFlags);
			m_binaryWriter.Write ((ushort) row.Flags);
			WriteStringPointer (row.Name);
			WriteBlobPointer (row.Signature);
			WriteTablePointer (row.ParamList, ParamTable.RId);
		}

		public override void VisitMethodImplRow (MethodImplRow row)
		{
			WriteTablePointer (row.Class, TypeDefTable.RId);
			WriteMetadataToken (row.MethodBody, CodedIndex.MethodDefOrRef);
			WriteMetadataToken (row.MethodDeclaration, CodedIndex.MethodDefOrRef);
		}

		public override void VisitMethodPtrRow (MethodPtrRow row)
		{
			WriteTablePointer (row.Method, MethodTable.RId);
		}

		public override void VisitMethodSemanticsRow (MethodSemanticsRow row)
		{
			m_binaryWriter.Write ((ushort) row.Semantics);
			WriteTablePointer (row.Method, MethodTable.RId);
			WriteMetadataToken (row.Association, CodedIndex.HasSemantics);
		}

		public override void VisitMethodSpecRow (MethodSpecRow row)
		{
			WriteMetadataToken (row.Method, CodedIndex.MethodDefOrRef);
			WriteBlobPointer (row.Instantiation);
		}

		public override void VisitModuleRow (ModuleRow row)
		{
			m_binaryWriter.Write (row.Generation);
			WriteStringPointer (row.Name);
			WriteGuidPointer (row.Mvid);
			WriteGuidPointer (row.EncId);
			WriteGuidPointer (row.EncBaseId);
		}

		public override void VisitModuleRefRow (ModuleRefRow row)
		{
			WriteStringPointer (row.Name);
		}

		public override void VisitNestedClassRow (NestedClassRow row)
		{
			WriteTablePointer (row.NestedClass, TypeDefTable.RId);
			WriteTablePointer (row.EnclosingClass, TypeDefTable.RId);
		}

		public override void VisitParamRow (ParamRow row)
		{
			m_binaryWriter.Write ((ushort) row.Flags);
			m_binaryWriter.Write (row.Sequence);
			WriteStringPointer (row.Name);
		}

		public override void VisitParamPtrRow (ParamPtrRow row)
		{
			WriteTablePointer (row.Param, ParamTable.RId);
		}

		public override void VisitPropertyRow (PropertyRow row)
		{
			m_binaryWriter.Write ((ushort) row.Flags);
			WriteStringPointer (row.Name);
			WriteBlobPointer (row.Type);
		}

		public override void VisitPropertyMapRow (PropertyMapRow row)
		{
			WriteTablePointer (row.Parent, TypeDefTable.RId);
			WriteTablePointer (row.PropertyList, PropertyTable.RId);
		}

		public override void VisitPropertyPtrRow (PropertyPtrRow row)
		{
			WriteTablePointer (row.Property, PropertyTable.RId);
		}

		public override void VisitStandAloneSigRow (StandAloneSigRow row)
		{
			WriteBlobPointer (row.Signature);
		}

		public override void VisitTypeDefRow (TypeDefRow row)
		{
			m_binaryWriter.Write ((uint) row.Flags);
			WriteStringPointer (row.Name);
			WriteStringPointer (row.Namespace);
			WriteMetadataToken (row.Extends, CodedIndex.TypeDefOrRef);
			WriteTablePointer (row.FieldList, FieldTable.RId);
			WriteTablePointer (row.MethodList, MethodTable.RId);
		}

		public override void VisitTypeRefRow (TypeRefRow row)
		{
			WriteMetadataToken (row.ResolutionScope, CodedIndex.ResolutionScope);
			WriteStringPointer (row.Name);
			WriteStringPointer (row.Namespace);
		}

		public override void VisitTypeSpecRow (TypeSpecRow row)
		{
			WriteBlobPointer (row.Signature);
		}

	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/MetadataStream.cs
================================================
//
// MetadataStream.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	public class MetadataStream : IMetadataVisitable {

		public const string Strings = "#Strings";
		public const string Tables = "#~";
		public const string IncrementalTables = "#-";
		public const string Blob = "#Blob";
		public const string GUID = "#GUID";
		public const string UserStrings = "#US";

		MetadataStreamHeader m_header;
		MetadataHeap m_heap;

		public MetadataStreamHeader Header {
			get { return m_header; }
			set { m_header = value; }
		}

		public MetadataHeap Heap {
			get { return m_heap; }
			set { m_heap = value; }
		}

		internal MetadataStream ()
		{
			m_header = new MetadataStreamHeader (this);
		}

		public void Accept (IMetadataVisitor visitor)
		{
			visitor.VisitMetadataStream (this);

			m_header.Accept (visitor);
			if (m_heap != null)
				m_heap.Accept (visitor);
		}

		public class MetadataStreamHeader : IMetadataVisitable {

			public uint Offset;
			public uint Size;
			public string Name;

			private MetadataStream m_stream;

			public MetadataStream Stream {
				get { return m_stream; }
			}

			internal MetadataStreamHeader (MetadataStream stream)
			{
				m_stream = stream;
			}

			public void Accept (IMetadataVisitor visitor)
			{
				visitor.VisitMetadataStreamHeader (this);
			}
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/MetadataStreamCollection.cs
================================================
//
// MetadataStreamCollection.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	using System;
	using System.Collections;

	public class MetadataStreamCollection : ICollection, IMetadataVisitable {

		IList m_items;

		BlobHeap m_blobHeap;
		GuidHeap m_guidHeap;
		StringsHeap m_stringsHeap;
		UserStringsHeap m_usHeap;
		TablesHeap m_tablesHeap;

		public MetadataStream this [int index] {
			get { return m_items [index] as MetadataStream; }
			set { m_items [index] = value; }
		}

		public int Count {
			get { return m_items.Count; }
		}

		public bool IsSynchronized {
			get { return false; }
		}

		public object SyncRoot {
			get { return this; }
		}

		public BlobHeap BlobHeap {
			get {
				if (m_blobHeap == null)
					m_blobHeap = GetHeap (MetadataStream.Blob) as BlobHeap;
				return m_blobHeap;
			}
		}

		public GuidHeap GuidHeap {
			get {
				if (m_guidHeap == null)
					m_guidHeap = GetHeap (MetadataStream.GUID) as GuidHeap;
				return m_guidHeap;
			}
		}

		public StringsHeap StringsHeap {
			get {
				if (m_stringsHeap == null)
					m_stringsHeap = GetHeap (MetadataStream.Strings) as StringsHeap;
				return m_stringsHeap;
			}
		}

		public TablesHeap TablesHeap {
			get {
				if (m_tablesHeap == null)
					m_tablesHeap = GetHeap (MetadataStream.Tables) as TablesHeap;
				return m_tablesHeap;
			}
		}

		public UserStringsHeap UserStringsHeap {
			get {
				if (m_usHeap == null)
					m_usHeap = GetHeap (MetadataStream.UserStrings) as UserStringsHeap;
				return m_usHeap;
			}
		}

		public MetadataStreamCollection ()
		{
			m_items = new ArrayList (5);
		}

		private MetadataHeap GetHeap (string name)
		{
			for (int i = 0; i < m_items.Count; i++) {
				MetadataStream stream = m_items [i] as MetadataStream;
				if (stream.Heap.Name == name)
					return stream.Heap;
			}

			return null;
		}

		internal void Add (MetadataStream value)
		{
			m_items.Add (value);
		}

		internal void Remove (MetadataStream value)
		{
			m_items.Remove (value);
		}

		public void CopyTo (Array ary, int index)
		{
			m_items.CopyTo (ary, index);
		}

		public IEnumerator GetEnumerator ()
		{
			return m_items.GetEnumerator ();
		}

		public void Accept (IMetadataVisitor visitor)
		{
			visitor.VisitMetadataStreamCollection (this);

			for (int i = 0; i < m_items.Count; i++)
				this [i].Accept (visitor);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/MetadataTableReader.cs
================================================
//
// MetadataTableReader.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Thu Feb 22 14:39:38 CET 2007
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	using System;
	using System.Collections;
	using System.IO;

	class MetadataTableReader : BaseMetadataTableVisitor {

		MetadataRoot m_metadataRoot;
		TablesHeap m_heap;
		MetadataRowReader m_mrrv;
		BinaryReader m_binaryReader;

		int [] m_rows = new int [TablesHeap.MaxTableCount];

		public MetadataTableReader (MetadataReader mrv)
		{
			m_metadataRoot = mrv.GetMetadataRoot ();
			m_heap = m_metadataRoot.Streams.TablesHeap;
			m_binaryReader = new BinaryReader (new MemoryStream (m_heap.Data));
			m_binaryReader.BaseStream.Position = 24;
			m_mrrv = new MetadataRowReader (this);
		}

		public MetadataRoot GetMetadataRoot ()
		{
			return m_metadataRoot;
		}

		public BinaryReader GetReader ()
		{
			return m_binaryReader;
		}

		public override IMetadataRowVisitor GetRowVisitor ()
		{
			return m_mrrv;
		}

		public int GetNumberOfRows (int rid)
		{
			return m_rows [rid];
		}

		public AssemblyTable GetAssemblyTable ()
		{
			return (AssemblyTable) m_heap [AssemblyTable.RId];
		}

		public AssemblyOSTable GetAssemblyOSTable ()
		{
			return (AssemblyOSTable) m_heap [AssemblyOSTable.RId];
		}

		public AssemblyProcessorTable GetAssemblyProcessorTable ()
		{
			return (AssemblyProcessorTable) m_heap [AssemblyProcessorTable.RId];
		}

		public AssemblyRefTable GetAssemblyRefTable ()
		{
			return (AssemblyRefTable) m_heap [AssemblyRefTable.RId];
		}

		public AssemblyRefOSTable GetAssemblyRefOSTable ()
		{
			return (AssemblyRefOSTable) m_heap [AssemblyRefOSTable.RId];
		}

		public AssemblyRefProcessorTable GetAssemblyRefProcessorTable ()
		{
			return (AssemblyRefProcessorTable) m_heap [AssemblyRefProcessorTable.RId];
		}

		public ClassLayoutTable GetClassLayoutTable ()
		{
			return (ClassLayoutTable) m_heap [ClassLayoutTable.RId];
		}

		public ConstantTable GetConstantTable ()
		{
			return (ConstantTable) m_heap [ConstantTable.RId];
		}

		public CustomAttributeTable GetCustomAttributeTable ()
		{
			return (CustomAttributeTable) m_heap [CustomAttributeTable.RId];
		}

		public DeclSecurityTable GetDeclSecurityTable ()
		{
			return (DeclSecurityTable) m_heap [DeclSecurityTable.RId];
		}

		public EventTable GetEventTable ()
		{
			return (EventTable) m_heap [EventTable.RId];
		}

		public EventMapTable GetEventMapTable ()
		{
			return (EventMapTable) m_heap [EventMapTable.RId];
		}

		public EventPtrTable GetEventPtrTable ()
		{
			return (EventPtrTable) m_heap [EventPtrTable.RId];
		}

		public ExportedTypeTable GetExportedTypeTable ()
		{
			return (ExportedTypeTable) m_heap [ExportedTypeTable.RId];
		}

		public FieldTable GetFieldTable ()
		{
			return (FieldTable) m_heap [FieldTable.RId];
		}

		public FieldLayoutTable GetFieldLayoutTable ()
		{
			return (FieldLayoutTable) m_heap [FieldLayoutTable.RId];
		}

		public FieldMarshalTable GetFieldMarshalTable ()
		{
			return (FieldMarshalTable) m_heap [FieldMarshalTable.RId];
		}

		public FieldPtrTable GetFieldPtrTable ()
		{
			return (FieldPtrTable) m_heap [FieldPtrTable.RId];
		}

		public FieldRVATable GetFieldRVATable ()
		{
			return (FieldRVATable) m_heap [FieldRVATable.RId];
		}

		public FileTable GetFileTable ()
		{
			return (FileTable) m_heap [FileTable.RId];
		}

		public GenericParamTable GetGenericParamTable ()
		{
			return (GenericParamTable) m_heap [GenericParamTable.RId];
		}

		public GenericParamConstraintTable GetGenericParamConstraintTable ()
		{
			return (GenericParamConstraintTable) m_heap [GenericParamConstraintTable.RId];
		}

		public ImplMapTable GetImplMapTable ()
		{
			return (ImplMapTable) m_heap [ImplMapTable.RId];
		}

		public InterfaceImplTable GetInterfaceImplTable ()
		{
			return (InterfaceImplTable) m_heap [InterfaceImplTable.RId];
		}

		public ManifestResourceTable GetManifestResourceTable ()
		{
			return (ManifestResourceTable) m_heap [ManifestResourceTable.RId];
		}

		public MemberRefTable GetMemberRefTable ()
		{
			return (MemberRefTable) m_heap [MemberRefTable.RId];
		}

		public MethodTable GetMethodTable ()
		{
			return (MethodTable) m_heap [MethodTable.RId];
		}

		public MethodImplTable GetMethodImplTable ()
		{
			return (MethodImplTable) m_heap [MethodImplTable.RId];
		}

		public MethodPtrTable GetMethodPtrTable ()
		{
			return (MethodPtrTable) m_heap [MethodPtrTable.RId];
		}

		public MethodSemanticsTable GetMethodSemanticsTable ()
		{
			return (MethodSemanticsTable) m_heap [MethodSemanticsTable.RId];
		}

		public MethodSpecTable GetMethodSpecTable ()
		{
			return (MethodSpecTable) m_heap [MethodSpecTable.RId];
		}

		public ModuleTable GetModuleTable ()
		{
			return (ModuleTable) m_heap [ModuleTable.RId];
		}

		public ModuleRefTable GetModuleRefTable ()
		{
			return (ModuleRefTable) m_heap [ModuleRefTable.RId];
		}

		public NestedClassTable GetNestedClassTable ()
		{
			return (NestedClassTable) m_heap [NestedClassTable.RId];
		}

		public ParamTable GetParamTable ()
		{
			return (ParamTable) m_heap [ParamTable.RId];
		}

		public ParamPtrTable GetParamPtrTable ()
		{
			return (ParamPtrTable) m_heap [ParamPtrTable.RId];
		}

		public PropertyTable GetPropertyTable ()
		{
			return (PropertyTable) m_heap [PropertyTable.RId];
		}

		public PropertyMapTable GetPropertyMapTable ()
		{
			return (PropertyMapTable) m_heap [PropertyMapTable.RId];
		}

		public PropertyPtrTable GetPropertyPtrTable ()
		{
			return (PropertyPtrTable) m_heap [PropertyPtrTable.RId];
		}

		public StandAloneSigTable GetStandAloneSigTable ()
		{
			return (StandAloneSigTable) m_heap [StandAloneSigTable.RId];
		}

		public TypeDefTable GetTypeDefTable ()
		{
			return (TypeDefTable) m_heap [TypeDefTable.RId];
		}

		public TypeRefTable GetTypeRefTable ()
		{
			return (TypeRefTable) m_heap [TypeRefTable.RId];
		}

		public TypeSpecTable GetTypeSpecTable ()
		{
			return (TypeSpecTable) m_heap [TypeSpecTable.RId];
		}

		public override void VisitTableCollection (TableCollection coll)
		{
			if (m_heap.HasTable (ModuleTable.RId)) {
				coll.Add (new ModuleTable ());
				m_rows [ModuleTable.RId] = m_binaryReader.ReadInt32 ();
			}
			if (m_heap.HasTable (TypeRefTable.RId)) {
				coll.Add (new TypeRefTable ());
				m_rows [TypeRefTable.RId] = m_binaryReader.ReadInt32 ();
			}
			if (m_heap.HasTable (TypeDefTable.RId)) {
				coll.Add (new TypeDefTable ());
				m_rows [TypeDefTable.RId] = m_binaryReader.ReadInt32 ();
			}
			if (m_heap.HasTable (FieldPtrTable.RId)) {
				coll.Add (new FieldPtrTable ());
				m_rows [FieldPtrTable.RId] = m_binaryReader.ReadInt32 ();
			}
			if (m_heap.HasTable (FieldTable.RId)) {
				coll.Add (new FieldTable ());
				m_rows [FieldTable.RId] = m_binaryReader.ReadInt32 ();
			}
			if (m_heap.HasTable (MethodPtrTable.RId)) {
				coll.Add (new MethodPtrTable ());
				m_rows [MethodPtrTable.RId] = m_binaryReader.ReadInt32 ();
			}
			if (m_heap.HasTable (MethodTable.RId)) {
				coll.Add (new MethodTable ());
				m_rows [MethodTable.RId] = m_binaryReader.ReadInt32 ();
			}
			if (m_heap.HasTable (ParamPtrTable.RId)) {
				coll.Add (new ParamPtrTable ());
				m_rows [ParamPtrTable.RId] = m_binaryReader.ReadInt32 ();
			}
			if (m_heap.HasTable (ParamTable.RId)) {
				coll.Add (new ParamTable ());
				m_rows [ParamTable.RId] = m_binaryReader.ReadInt32 ();
			}
			if (m_heap.HasTable (InterfaceImplTable.RId)) {
				coll.Add (new InterfaceImplTable ());
				m_rows [InterfaceImplTable.RId] = m_binaryReader.ReadInt32 ();
			}
			if (m_heap.HasTable (MemberRefTable.RId)) {
				coll.Add (new MemberRefTable ());
				m_rows [MemberRefTable.RId] = m_binaryReader.ReadInt32 ();
			}
			if (m_heap.HasTable (ConstantTable.RId)) {
				coll.Add (new ConstantTable ());
				m_rows [ConstantTable.RId] = m_binaryReader.ReadInt32 ();
			}
			if (m_heap.HasTable (CustomAttributeTable.RId)) {
				coll.Add (new CustomAttributeTable ());
				m_rows [CustomAttributeTable.RId] = m_binaryReader.ReadInt32 ();
			}
			if (m_heap.HasTable (FieldMarshalTable.RId)) {
				coll.Add (new FieldMarshalTable ());
				m_rows [FieldMarshalTable.RId] = m_binaryReader.ReadInt32 ();
			}
			if (m_heap.HasTable (DeclSecurityTable.RId)) {
				coll.Add (new DeclSecurityTable ());
				m_rows [DeclSecurityTable.RId] = m_binaryReader.ReadInt32 ();
			}
			if (m_heap.HasTable (ClassLayoutTable.RId)) {
				coll.Add (new ClassLayoutTable ());
				m_rows [ClassLayoutTable.RId] = m_binaryReader.ReadInt32 ();
			}
			if (m_heap.HasTable (FieldLayoutTable.RId)) {
				coll.Add (new FieldLayoutTable ());
				m_rows [FieldLayoutTable.RId] = m_binaryReader.ReadInt32 ();
			}
			if (m_heap.HasTable (StandAloneSigTable.RId)) {
				coll.Add (new StandAloneSigTable ());
				m_rows [StandAloneSigTable.RId] = m_binaryReader.ReadInt32 ();
			}
			if (m_heap.HasTable (EventMapTable.RId)) {
				coll.Add (new EventMapTable ());
				m_rows [EventMapTable.RId] = m_binaryReader.ReadInt32 ();
			}
			if (m_heap.HasTable (EventPtrTable.RId)) {
				coll.Add (new EventPtrTable ());
				m_rows [EventPtrTable.RId] = m_binaryReader.ReadInt32 ();
			}
			if (m_heap.HasTable (EventTable.RId)) {
				coll.Add (new EventTable ());
				m_rows [EventTable.RId] = m_binaryReader.ReadInt32 ();
			}
			if (m_heap.HasTable (PropertyMapTable.RId)) {
				coll.Add (new PropertyMapTable ());
				m_rows [PropertyMapTable.RId] = m_binaryReader.ReadInt32 ();
			}
			if (m_heap.HasTable (PropertyPtrTable.RId)) {
				coll.Add (new PropertyPtrTable ());
				m_rows [PropertyPtrTable.RId] = m_binaryReader.ReadInt32 ();
			}
			if (m_heap.HasTable (PropertyTable.RId)) {
				coll.Add (new PropertyTable ());
				m_rows [PropertyTable.RId] = m_binaryReader.ReadInt32 ();
			}
			if (m_heap.HasTable (MethodSemanticsTable.RId)) {
				coll.Add (new MethodSemanticsTable ());
				m_rows [MethodSemanticsTable.RId] = m_binaryReader.ReadInt32 ();
			}
			if (m_heap.HasTable (MethodImplTable.RId)) {
				coll.Add (new MethodImplTable ());
				m_rows [MethodImplTable.RId] = m_binaryReader.ReadInt32 ();
			}
			if (m_heap.HasTable (ModuleRefTable.RId)) {
				coll.Add (new ModuleRefTable ());
				m_rows [ModuleRefTable.RId] = m_binaryReader.ReadInt32 ();
			}
			if (m_heap.HasTable (TypeSpecTable.RId)) {
				coll.Add (new TypeSpecTable ());
				m_rows [TypeSpecTable.RId] = m_binaryReader.ReadInt32 ();
			}
			if (m_heap.HasTable (ImplMapTable.RId)) {
				coll.Add (new ImplMapTable ());
				m_rows [ImplMapTable.RId] = m_binaryReader.ReadInt32 ();
			}
			if (m_heap.HasTable (FieldRVATable.RId)) {
				coll.Add (new FieldRVATable ());
				m_rows [FieldRVATable.RId] = m_binaryReader.ReadInt32 ();
			}
			if (m_heap.HasTable (AssemblyTable.RId)) {
				coll.Add (new AssemblyTable ());
				m_rows [AssemblyTable.RId] = m_binaryReader.ReadInt32 ();
			}
			if (m_heap.HasTable (AssemblyProcessorTable.RId)) {
				coll.Add (new AssemblyProcessorTable ());
				m_rows [AssemblyProcessorTable.RId] = m_binaryReader.ReadInt32 ();
			}
			if (m_heap.HasTable (AssemblyOSTable.RId)) {
				coll.Add (new AssemblyOSTable ());
				m_rows [AssemblyOSTable.RId] = m_binaryReader.ReadInt32 ();
			}
			if (m_heap.HasTable (AssemblyRefTable.RId)) {
				coll.Add (new AssemblyRefTable ());
				m_rows [AssemblyRefTable.RId] = m_binaryReader.ReadInt32 ();
			}
			if (m_heap.HasTable (AssemblyRefProcessorTable.RId)) {
				coll.Add (new AssemblyRefProcessorTable ());
				m_rows [AssemblyRefProcessorTable.RId] = m_binaryReader.ReadInt32 ();
			}
			if (m_heap.HasTable (AssemblyRefOSTable.RId)) {
				coll.Add (new AssemblyRefOSTable ());
				m_rows [AssemblyRefOSTable.RId] = m_binaryReader.ReadInt32 ();
			}
			if (m_heap.HasTable (FileTable.RId)) {
				coll.Add (new FileTable ());
				m_rows [FileTable.RId] = m_binaryReader.ReadInt32 ();
			}
			if (m_heap.HasTable (ExportedTypeTable.RId)) {
				coll.Add (new ExportedTypeTable ());
				m_rows [ExportedTypeTable.RId] = m_binaryReader.ReadInt32 ();
			}
			if (m_heap.HasTable (ManifestResourceTable.RId)) {
				coll.Add (new ManifestResourceTable ());
				m_rows [ManifestResourceTable.RId] = m_binaryReader.ReadInt32 ();
			}
			if (m_heap.HasTable (NestedClassTable.RId)) {
				coll.Add (new NestedClassTable ());
				m_rows [NestedClassTable.RId] = m_binaryReader.ReadInt32 ();
			}
			if (m_heap.HasTable (GenericParamTable.RId)) {
				coll.Add (new GenericParamTable ());
				m_rows [GenericParamTable.RId] = m_binaryReader.ReadInt32 ();
			}
			if (m_heap.HasTable (MethodSpecTable.RId)) {
				coll.Add (new MethodSpecTable ());
				m_rows [MethodSpecTable.RId] = m_binaryReader.ReadInt32 ();
			}
			if (m_heap.HasTable (GenericParamConstraintTable.RId)) {
				coll.Add (new GenericParamConstraintTable ());
				m_rows [GenericParamConstraintTable.RId] = m_binaryReader.ReadInt32 ();
			}
		}

		public override void VisitAssemblyTable (AssemblyTable table)
		{
			int number = m_rows [AssemblyTable.RId];
			table.Rows = new RowCollection (number);
			for (int i = 0; i < number; i++)
				table.Rows.Add (new AssemblyRow ());
		}
		public override void VisitAssemblyOSTable (AssemblyOSTable table)
		{
			int number = m_rows [AssemblyOSTable.RId];
			table.Rows = new RowCollection (number);
			for (int i = 0; i < number; i++)
				table.Rows.Add (new AssemblyOSRow ());
		}
		public override void VisitAssemblyProcessorTable (AssemblyProcessorTable table)
		{
			int number = m_rows [AssemblyProcessorTable.RId];
			table.Rows = new RowCollection (number);
			for (int i = 0; i < number; i++)
				table.Rows.Add (new AssemblyProcessorRow ());
		}
		public override void VisitAssemblyRefTable (AssemblyRefTable table)
		{
			int number = m_rows [AssemblyRefTable.RId];
			table.Rows = new RowCollection (number);
			for (int i = 0; i < number; i++)
				table.Rows.Add (new AssemblyRefRow ());
		}
		public override void VisitAssemblyRefOSTable (AssemblyRefOSTable table)
		{
			int number = m_rows [AssemblyRefOSTable.RId];
			table.Rows = new RowCollection (number);
			for (int i = 0; i < number; i++)
				table.Rows.Add (new AssemblyRefOSRow ());
		}
		public override void VisitAssemblyRefProcessorTable (AssemblyRefProcessorTable table)
		{
			int number = m_rows [AssemblyRefProcessorTable.RId];
			table.Rows = new RowCollection (number);
			for (int i = 0; i < number; i++)
				table.Rows.Add (new AssemblyRefProcessorRow ());
		}
		public override void VisitClassLayoutTable (ClassLayoutTable table)
		{
			int number = m_rows [ClassLayoutTable.RId];
			table.Rows = new RowCollection (number);
			for (int i = 0; i < number; i++)
				table.Rows.Add (new ClassLayoutRow ());
		}
		public override void VisitConstantTable (ConstantTable table)
		{
			int number = m_rows [ConstantTable.RId];
			table.Rows = new RowCollection (number);
			for (int i = 0; i < number; i++)
				table.Rows.Add (new ConstantRow ());
		}
		public override void VisitCustomAttributeTable (CustomAttributeTable table)
		{
			int number = m_rows [CustomAttributeTable.RId];
			table.Rows = new RowCollection (number);
			for (int i = 0; i < number; i++)
				table.Rows.Add (new CustomAttributeRow ());
		}
		public override void VisitDeclSecurityTable (DeclSecurityTable table)
		{
			int number = m_rows [DeclSecurityTable.RId];
			table.Rows = new RowCollection (number);
			for (int i = 0; i < number; i++)
				table.Rows.Add (new DeclSecurityRow ());
		}
		public override void VisitEventTable (EventTable table)
		{
			int number = m_rows [EventTable.RId];
			table.Rows = new RowCollection (number);
			for (int i = 0; i < number; i++)
				table.Rows.Add (new EventRow ());
		}
		public override void VisitEventMapTable (EventMapTable table)
		{
			int number = m_rows [EventMapTable.RId];
			table.Rows = new RowCollection (number);
			for (int i = 0; i < number; i++)
				table.Rows.Add (new EventMapRow ());
		}
		public override void VisitEventPtrTable (EventPtrTable table)
		{
			int number = m_rows [EventPtrTable.RId];
			table.Rows = new RowCollection (number);
			for (int i = 0; i < number; i++)
				table.Rows.Add (new EventPtrRow ());
		}
		public override void VisitExportedTypeTable (ExportedTypeTable table)
		{
			int number = m_rows [ExportedTypeTable.RId];
			table.Rows = new RowCollection (number);
			for (int i = 0; i < number; i++)
				table.Rows.Add (new ExportedTypeRow ());
		}
		public override void VisitFieldTable (FieldTable table)
		{
			int number = m_rows [FieldTable.RId];
			table.Rows = new RowCollection (number);
			for (int i = 0; i < number; i++)
				table.Rows.Add (new FieldRow ());
		}
		public override void VisitFieldLayoutTable (FieldLayoutTable table)
		{
			int number = m_rows [FieldLayoutTable.RId];
			table.Rows = new RowCollection (number);
			for (int i = 0; i < number; i++)
				table.Rows.Add (new FieldLayoutRow ());
		}
		public override void VisitFieldMarshalTable (FieldMarshalTable table)
		{
			int number = m_rows [FieldMarshalTable.RId];
			table.Rows = new RowCollection (number);
			for (int i = 0; i < number; i++)
				table.Rows.Add (new FieldMarshalRow ());
		}
		public override void VisitFieldPtrTable (FieldPtrTable table)
		{
			int number = m_rows [FieldPtrTable.RId];
			table.Rows = new RowCollection (number);
			for (int i = 0; i < number; i++)
				table.Rows.Add (new FieldPtrRow ());
		}
		public override void VisitFieldRVATable (FieldRVATable table)
		{
			int number = m_rows [FieldRVATable.RId];
			table.Rows = new RowCollection (number);
			for (int i = 0; i < number; i++)
				table.Rows.Add (new FieldRVARow ());
		}
		public override void VisitFileTable (FileTable table)
		{
			int number = m_rows [FileTable.RId];
			table.Rows = new RowCollection (number);
			for (int i = 0; i < number; i++)
				table.Rows.Add (new FileRow ());
		}
		public override void VisitGenericParamTable (GenericParamTable table)
		{
			int number = m_rows [GenericParamTable.RId];
			table.Rows = new RowCollection (number);
			for (int i = 0; i < number; i++)
				table.Rows.Add (new GenericParamRow ());
		}
		public override void VisitGenericParamConstraintTable (GenericParamConstraintTable table)
		{
			int number = m_rows [GenericParamConstraintTable.RId];
			table.Rows = new RowCollection (number);
			for (int i = 0; i < number; i++)
				table.Rows.Add (new GenericParamConstraintRow ());
		}
		public override void VisitImplMapTable (ImplMapTable table)
		{
			int number = m_rows [ImplMapTable.RId];
			table.Rows = new RowCollection (number);
			for (int i = 0; i < number; i++)
				table.Rows.Add (new ImplMapRow ());
		}
		public override void VisitInterfaceImplTable (InterfaceImplTable table)
		{
			int number = m_rows [InterfaceImplTable.RId];
			table.Rows = new RowCollection (number);
			for (int i = 0; i < number; i++)
				table.Rows.Add (new InterfaceImplRow ());
		}
		public override void VisitManifestResourceTable (ManifestResourceTable table)
		{
			int number = m_rows [ManifestResourceTable.RId];
			table.Rows = new RowCollection (number);
			for (int i = 0; i < number; i++)
				table.Rows.Add (new ManifestResourceRow ());
		}
		public override void VisitMemberRefTable (MemberRefTable table)
		{
			int number = m_rows [MemberRefTable.RId];
			table.Rows = new RowCollection (number);
			for (int i = 0; i < number; i++)
				table.Rows.Add (new MemberRefRow ());
		}
		public override void VisitMethodTable (MethodTable table)
		{
			int number = m_rows [MethodTable.RId];
			table.Rows = new RowCollection (number);
			for (int i = 0; i < number; i++)
				table.Rows.Add (new MethodRow ());
		}
		public override void VisitMethodImplTable (MethodImplTable table)
		{
			int number = m_rows [MethodImplTable.RId];
			table.Rows = new RowCollection (number);
			for (int i = 0; i < number; i++)
				table.Rows.Add (new MethodImplRow ());
		}
		public override void VisitMethodPtrTable (MethodPtrTable table)
		{
			int number = m_rows [MethodPtrTable.RId];
			table.Rows = new RowCollection (number);
			for (int i = 0; i < number; i++)
				table.Rows.Add (new MethodPtrRow ());
		}
		public override void VisitMethodSemanticsTable (MethodSemanticsTable table)
		{
			int number = m_rows [MethodSemanticsTable.RId];
			table.Rows = new RowCollection (number);
			for (int i = 0; i < number; i++)
				table.Rows.Add (new MethodSemanticsRow ());
		}
		public override void VisitMethodSpecTable (MethodSpecTable table)
		{
			int number = m_rows [MethodSpecTable.RId];
			table.Rows = new RowCollection (number);
			for (int i = 0; i < number; i++)
				table.Rows.Add (new MethodSpecRow ());
		}
		public override void VisitModuleTable (ModuleTable table)
		{
			int number = m_rows [ModuleTable.RId];
			table.Rows = new RowCollection (number);
			for (int i = 0; i < number; i++)
				table.Rows.Add (new ModuleRow ());
		}
		public override void VisitModuleRefTable (ModuleRefTable table)
		{
			int number = m_rows [ModuleRefTable.RId];
			table.Rows = new RowCollection (number);
			for (int i = 0; i < number; i++)
				table.Rows.Add (new ModuleRefRow ());
		}
		public override void VisitNestedClassTable (NestedClassTable table)
		{
			int number = m_rows [NestedClassTable.RId];
			table.Rows = new RowCollection (number);
			for (int i = 0; i < number; i++)
				table.Rows.Add (new NestedClassRow ());
		}
		public override void VisitParamTable (ParamTable table)
		{
			int number = m_rows [ParamTable.RId];
			table.Rows = new RowCollection (number);
			for (int i = 0; i < number; i++)
				table.Rows.Add (new ParamRow ());
		}
		public override void VisitParamPtrTable (ParamPtrTable table)
		{
			int number = m_rows [ParamPtrTable.RId];
			table.Rows = new RowCollection (number);
			for (int i = 0; i < number; i++)
				table.Rows.Add (new ParamPtrRow ());
		}
		public override void VisitPropertyTable (PropertyTable table)
		{
			int number = m_rows [PropertyTable.RId];
			table.Rows = new RowCollection (number);
			for (int i = 0; i < number; i++)
				table.Rows.Add (new PropertyRow ());
		}
		public override void VisitPropertyMapTable (PropertyMapTable table)
		{
			int number = m_rows [PropertyMapTable.RId];
			table.Rows = new RowCollection (number);
			for (int i = 0; i < number; i++)
				table.Rows.Add (new PropertyMapRow ());
		}
		public override void VisitPropertyPtrTable (PropertyPtrTable table)
		{
			int number = m_rows [PropertyPtrTable.RId];
			table.Rows = new RowCollection (number);
			for (int i = 0; i < number; i++)
				table.Rows.Add (new PropertyPtrRow ());
		}
		public override void VisitStandAloneSigTable (StandAloneSigTable table)
		{
			int number = m_rows [StandAloneSigTable.RId];
			table.Rows = new RowCollection (number);
			for (int i = 0; i < number; i++)
				table.Rows.Add (new StandAloneSigRow ());
		}
		public override void VisitTypeDefTable (TypeDefTable table)
		{
			int number = m_rows [TypeDefTable.RId];
			table.Rows = new RowCollection (number);
			for (int i = 0; i < number; i++)
				table.Rows.Add (new TypeDefRow ());
		}
		public override void VisitTypeRefTable (TypeRefTable table)
		{
			int number = m_rows [TypeRefTable.RId];
			table.Rows = new RowCollection (number);
			for (int i = 0; i < number; i++)
				table.Rows.Add (new TypeRefRow ());
		}
		public override void VisitTypeSpecTable (TypeSpecTable table)
		{
			int number = m_rows [TypeSpecTable.RId];
			table.Rows = new RowCollection (number);
			for (int i = 0; i < number; i++)
				table.Rows.Add (new TypeSpecRow ());
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/MetadataTableWriter.cs
================================================
//
// MetadataTableWriter.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Thu Feb 22 14:39:38 CET 2007
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	using System;
	using System.Collections;

	using Mono.Cecil.Binary;

	internal sealed class MetadataTableWriter : BaseMetadataTableVisitor {

		MetadataRoot m_root;
		TablesHeap m_heap;
		MetadataRowWriter m_mrrw;
		MemoryBinaryWriter m_binaryWriter;

		public MetadataTableWriter (MetadataWriter mrv, MemoryBinaryWriter writer)
		{
			m_root = mrv.GetMetadataRoot ();
			m_heap = m_root.Streams.TablesHeap;
			m_binaryWriter = writer;
			m_mrrw = new MetadataRowWriter (this);
		}

		public MetadataRoot GetMetadataRoot ()
		{
			return m_root;
		}

		public override IMetadataRowVisitor GetRowVisitor ()
		{
			return m_mrrw;
		}

		public MemoryBinaryWriter GetWriter ()
		{
			return m_binaryWriter;
		}

		void InitializeTable (IMetadataTable table)
		{
			table.Rows = new RowCollection ();
			m_heap.Valid |= 1L << table.Id;
			m_heap.Tables.Add (table);
		}

		void WriteCount (int rid)
		{
			if (m_heap.HasTable (rid))
				m_binaryWriter.Write (m_heap [rid].Rows.Count);
		}

		public AssemblyTable GetAssemblyTable ()
		{
			AssemblyTable table = m_heap [AssemblyTable.RId] as AssemblyTable;
			if (table != null)
				return table;

			table = new AssemblyTable ();
			InitializeTable (table);
			return table;
		}

		public AssemblyOSTable GetAssemblyOSTable ()
		{
			AssemblyOSTable table = m_heap [AssemblyOSTable.RId] as AssemblyOSTable;
			if (table != null)
				return table;

			table = new AssemblyOSTable ();
			InitializeTable (table);
			return table;
		}

		public AssemblyProcessorTable GetAssemblyProcessorTable ()
		{
			AssemblyProcessorTable table = m_heap [AssemblyProcessorTable.RId] as AssemblyProcessorTable;
			if (table != null)
				return table;

			table = new AssemblyProcessorTable ();
			InitializeTable (table);
			return table;
		}

		public AssemblyRefTable GetAssemblyRefTable ()
		{
			AssemblyRefTable table = m_heap [AssemblyRefTable.RId] as AssemblyRefTable;
			if (table != null)
				return table;

			table = new AssemblyRefTable ();
			InitializeTable (table);
			return table;
		}

		public AssemblyRefOSTable GetAssemblyRefOSTable ()
		{
			AssemblyRefOSTable table = m_heap [AssemblyRefOSTable.RId] as AssemblyRefOSTable;
			if (table != null)
				return table;

			table = new AssemblyRefOSTable ();
			InitializeTable (table);
			return table;
		}

		public AssemblyRefProcessorTable GetAssemblyRefProcessorTable ()
		{
			AssemblyRefProcessorTable table = m_heap [AssemblyRefProcessorTable.RId] as AssemblyRefProcessorTable;
			if (table != null)
				return table;

			table = new AssemblyRefProcessorTable ();
			InitializeTable (table);
			return table;
		}

		public ClassLayoutTable GetClassLayoutTable ()
		{
			ClassLayoutTable table = m_heap [ClassLayoutTable.RId] as ClassLayoutTable;
			if (table != null)
				return table;

			table = new ClassLayoutTable ();
			InitializeTable (table);
			return table;
		}

		public ConstantTable GetConstantTable ()
		{
			ConstantTable table = m_heap [ConstantTable.RId] as ConstantTable;
			if (table != null)
				return table;

			table = new ConstantTable ();
			InitializeTable (table);
			return table;
		}

		public CustomAttributeTable GetCustomAttributeTable ()
		{
			CustomAttributeTable table = m_heap [CustomAttributeTable.RId] as CustomAttributeTable;
			if (table != null)
				return table;

			table = new CustomAttributeTable ();
			InitializeTable (table);
			return table;
		}

		public DeclSecurityTable GetDeclSecurityTable ()
		{
			DeclSecurityTable table = m_heap [DeclSecurityTable.RId] as DeclSecurityTable;
			if (table != null)
				return table;

			table = new DeclSecurityTable ();
			InitializeTable (table);
			return table;
		}

		public EventTable GetEventTable ()
		{
			EventTable table = m_heap [EventTable.RId] as EventTable;
			if (table != null)
				return table;

			table = new EventTable ();
			InitializeTable (table);
			return table;
		}

		public EventMapTable GetEventMapTable ()
		{
			EventMapTable table = m_heap [EventMapTable.RId] as EventMapTable;
			if (table != null)
				return table;

			table = new EventMapTable ();
			InitializeTable (table);
			return table;
		}

		public EventPtrTable GetEventPtrTable ()
		{
			EventPtrTable table = m_heap [EventPtrTable.RId] as EventPtrTable;
			if (table != null)
				return table;

			table = new EventPtrTable ();
			InitializeTable (table);
			return table;
		}

		public ExportedTypeTable GetExportedTypeTable ()
		{
			ExportedTypeTable table = m_heap [ExportedTypeTable.RId] as ExportedTypeTable;
			if (table != null)
				return table;

			table = new ExportedTypeTable ();
			InitializeTable (table);
			return table;
		}

		public FieldTable GetFieldTable ()
		{
			FieldTable table = m_heap [FieldTable.RId] as FieldTable;
			if (table != null)
				return table;

			table = new FieldTable ();
			InitializeTable (table);
			return table;
		}

		public FieldLayoutTable GetFieldLayoutTable ()
		{
			FieldLayoutTable table = m_heap [FieldLayoutTable.RId] as FieldLayoutTable;
			if (table != null)
				return table;

			table = new FieldLayoutTable ();
			InitializeTable (table);
			return table;
		}

		public FieldMarshalTable GetFieldMarshalTable ()
		{
			FieldMarshalTable table = m_heap [FieldMarshalTable.RId] as FieldMarshalTable;
			if (table != null)
				return table;

			table = new FieldMarshalTable ();
			InitializeTable (table);
			return table;
		}

		public FieldPtrTable GetFieldPtrTable ()
		{
			FieldPtrTable table = m_heap [FieldPtrTable.RId] as FieldPtrTable;
			if (table != null)
				return table;

			table = new FieldPtrTable ();
			InitializeTable (table);
			return table;
		}

		public FieldRVATable GetFieldRVATable ()
		{
			FieldRVATable table = m_heap [FieldRVATable.RId] as FieldRVATable;
			if (table != null)
				return table;

			table = new FieldRVATable ();
			InitializeTable (table);
			return table;
		}

		public FileTable GetFileTable ()
		{
			FileTable table = m_heap [FileTable.RId] as FileTable;
			if (table != null)
				return table;

			table = new FileTable ();
			InitializeTable (table);
			return table;
		}

		public GenericParamTable GetGenericParamTable ()
		{
			GenericParamTable table = m_heap [GenericParamTable.RId] as GenericParamTable;
			if (table != null)
				return table;

			table = new GenericParamTable ();
			InitializeTable (table);
			return table;
		}

		public GenericParamConstraintTable GetGenericParamConstraintTable ()
		{
			GenericParamConstraintTable table = m_heap [GenericParamConstraintTable.RId] as GenericParamConstraintTable;
			if (table != null)
				return table;

			table = new GenericParamConstraintTable ();
			InitializeTable (table);
			return table;
		}

		public ImplMapTable GetImplMapTable ()
		{
			ImplMapTable table = m_heap [ImplMapTable.RId] as ImplMapTable;
			if (table != null)
				return table;

			table = new ImplMapTable ();
			InitializeTable (table);
			return table;
		}

		public InterfaceImplTable GetInterfaceImplTable ()
		{
			InterfaceImplTable table = m_heap [InterfaceImplTable.RId] as InterfaceImplTable;
			if (table != null)
				return table;

			table = new InterfaceImplTable ();
			InitializeTable (table);
			return table;
		}

		public ManifestResourceTable GetManifestResourceTable ()
		{
			ManifestResourceTable table = m_heap [ManifestResourceTable.RId] as ManifestResourceTable;
			if (table != null)
				return table;

			table = new ManifestResourceTable ();
			InitializeTable (table);
			return table;
		}

		public MemberRefTable GetMemberRefTable ()
		{
			MemberRefTable table = m_heap [MemberRefTable.RId] as MemberRefTable;
			if (table != null)
				return table;

			table = new MemberRefTable ();
			InitializeTable (table);
			return table;
		}

		public MethodTable GetMethodTable ()
		{
			MethodTable table = m_heap [MethodTable.RId] as MethodTable;
			if (table != null)
				return table;

			table = new MethodTable ();
			InitializeTable (table);
			return table;
		}

		public MethodImplTable GetMethodImplTable ()
		{
			MethodImplTable table = m_heap [MethodImplTable.RId] as MethodImplTable;
			if (table != null)
				return table;

			table = new MethodImplTable ();
			InitializeTable (table);
			return table;
		}

		public MethodPtrTable GetMethodPtrTable ()
		{
			MethodPtrTable table = m_heap [MethodPtrTable.RId] as MethodPtrTable;
			if (table != null)
				return table;

			table = new MethodPtrTable ();
			InitializeTable (table);
			return table;
		}

		public MethodSemanticsTable GetMethodSemanticsTable ()
		{
			MethodSemanticsTable table = m_heap [MethodSemanticsTable.RId] as MethodSemanticsTable;
			if (table != null)
				return table;

			table = new MethodSemanticsTable ();
			InitializeTable (table);
			return table;
		}

		public MethodSpecTable GetMethodSpecTable ()
		{
			MethodSpecTable table = m_heap [MethodSpecTable.RId] as MethodSpecTable;
			if (table != null)
				return table;

			table = new MethodSpecTable ();
			InitializeTable (table);
			return table;
		}

		public ModuleTable GetModuleTable ()
		{
			ModuleTable table = m_heap [ModuleTable.RId] as ModuleTable;
			if (table != null)
				return table;

			table = new ModuleTable ();
			InitializeTable (table);
			return table;
		}

		public ModuleRefTable GetModuleRefTable ()
		{
			ModuleRefTable table = m_heap [ModuleRefTable.RId] as ModuleRefTable;
			if (table != null)
				return table;

			table = new ModuleRefTable ();
			InitializeTable (table);
			return table;
		}

		public NestedClassTable GetNestedClassTable ()
		{
			NestedClassTable table = m_heap [NestedClassTable.RId] as NestedClassTable;
			if (table != null)
				return table;

			table = new NestedClassTable ();
			InitializeTable (table);
			return table;
		}

		public ParamTable GetParamTable ()
		{
			ParamTable table = m_heap [ParamTable.RId] as ParamTable;
			if (table != null)
				return table;

			table = new ParamTable ();
			InitializeTable (table);
			return table;
		}

		public ParamPtrTable GetParamPtrTable ()
		{
			ParamPtrTable table = m_heap [ParamPtrTable.RId] as ParamPtrTable;
			if (table != null)
				return table;

			table = new ParamPtrTable ();
			InitializeTable (table);
			return table;
		}

		public PropertyTable GetPropertyTable ()
		{
			PropertyTable table = m_heap [PropertyTable.RId] as PropertyTable;
			if (table != null)
				return table;

			table = new PropertyTable ();
			InitializeTable (table);
			return table;
		}

		public PropertyMapTable GetPropertyMapTable ()
		{
			PropertyMapTable table = m_heap [PropertyMapTable.RId] as PropertyMapTable;
			if (table != null)
				return table;

			table = new PropertyMapTable ();
			InitializeTable (table);
			return table;
		}

		public PropertyPtrTable GetPropertyPtrTable ()
		{
			PropertyPtrTable table = m_heap [PropertyPtrTable.RId] as PropertyPtrTable;
			if (table != null)
				return table;

			table = new PropertyPtrTable ();
			InitializeTable (table);
			return table;
		}

		public StandAloneSigTable GetStandAloneSigTable ()
		{
			StandAloneSigTable table = m_heap [StandAloneSigTable.RId] as StandAloneSigTable;
			if (table != null)
				return table;

			table = new StandAloneSigTable ();
			InitializeTable (table);
			return table;
		}

		public TypeDefTable GetTypeDefTable ()
		{
			TypeDefTable table = m_heap [TypeDefTable.RId] as TypeDefTable;
			if (table != null)
				return table;

			table = new TypeDefTable ();
			InitializeTable (table);
			return table;
		}

		public TypeRefTable GetTypeRefTable ()
		{
			TypeRefTable table = m_heap [TypeRefTable.RId] as TypeRefTable;
			if (table != null)
				return table;

			table = new TypeRefTable ();
			InitializeTable (table);
			return table;
		}

		public TypeSpecTable GetTypeSpecTable ()
		{
			TypeSpecTable table = m_heap [TypeSpecTable.RId] as TypeSpecTable;
			if (table != null)
				return table;

			table = new TypeSpecTable ();
			InitializeTable (table);
			return table;
		}

		public override void VisitTableCollection (TableCollection coll)
		{
			WriteCount (ModuleTable.RId);
			WriteCount (TypeRefTable.RId);
			WriteCount (TypeDefTable.RId);
			WriteCount (FieldPtrTable.RId);
			WriteCount (FieldTable.RId);
			WriteCount (MethodPtrTable.RId);
			WriteCount (MethodTable.RId);
			WriteCount (ParamPtrTable.RId);
			WriteCount (ParamTable.RId);
			WriteCount (InterfaceImplTable.RId);
			WriteCount (MemberRefTable.RId);
			WriteCount (ConstantTable.RId);
			WriteCount (CustomAttributeTable.RId);
			WriteCount (FieldMarshalTable.RId);
			WriteCount (DeclSecurityTable.RId);
			WriteCount (ClassLayoutTable.RId);
			WriteCount (FieldLayoutTable.RId);
			WriteCount (StandAloneSigTable.RId);
			WriteCount (EventMapTable.RId);
			WriteCount (EventPtrTable.RId);
			WriteCount (EventTable.RId);
			WriteCount (PropertyMapTable.RId);
			WriteCount (PropertyPtrTable.RId);
			WriteCount (PropertyTable.RId);
			WriteCount (MethodSemanticsTable.RId);
			WriteCount (MethodImplTable.RId);
			WriteCount (ModuleRefTable.RId);
			WriteCount (TypeSpecTable.RId);
			WriteCount (ImplMapTable.RId);
			WriteCount (FieldRVATable.RId);
			WriteCount (AssemblyTable.RId);
			WriteCount (AssemblyProcessorTable.RId);
			WriteCount (AssemblyOSTable.RId);
			WriteCount (AssemblyRefTable.RId);
			WriteCount (AssemblyRefProcessorTable.RId);
			WriteCount (AssemblyRefOSTable.RId);
			WriteCount (FileTable.RId);
			WriteCount (ExportedTypeTable.RId);
			WriteCount (ManifestResourceTable.RId);
			WriteCount (NestedClassTable.RId);
			WriteCount (GenericParamTable.RId);
			WriteCount (MethodSpecTable.RId);
			WriteCount (GenericParamConstraintTable.RId);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/MetadataToken.cs
================================================
//
// MetadataToken.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	public struct MetadataToken {

		uint m_rid;
		TokenType m_type;

		public uint RID {
			get { return m_rid; }
            set { m_rid = value; }
		}

		public TokenType TokenType {
			get { return m_type; }
            set { m_type = value; }
		}

		public static readonly MetadataToken Zero = new MetadataToken ((TokenType) 0, 0);

		public MetadataToken (int token)
		{
			m_type = (TokenType) (token & 0xff000000);
			m_rid = (uint) token & 0x00ffffff;
		}

		public MetadataToken (TokenType table, uint rid)
		{
			m_type = table;
			m_rid = rid;
		}

		internal static MetadataToken FromMetadataRow (TokenType table, int rowIndex)
		{
			return new MetadataToken (table, (uint) rowIndex + 1);
		}

		public uint ToUInt ()
		{
			return (uint) m_type | m_rid;
		}

		public override int GetHashCode ()
		{
			return (int) ToUInt ();
		}

		public override bool Equals (object other)
		{
			if (other is MetadataToken) {
				MetadataToken o = (MetadataToken) other;
				return o.m_rid == m_rid && o.m_type == m_type;
			}

			return false;
		}

		public static bool operator == (MetadataToken one, MetadataToken other)
		{
			return one.Equals (other);
		}

		public static bool operator != (MetadataToken one, MetadataToken other)
		{
			return !one.Equals (other);
		}

		public override string ToString ()
		{
			return string.Format ("{0} [0x{1}]",
				m_type, m_rid.ToString ("x4"));
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/MetadataWriter.cs
================================================
//
// MetadataWriter.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	using System;
	using System.Collections;
	using System.IO;
	using System.Text;

	using Mono.Cecil;
	using Mono.Cecil.Binary;

	internal sealed class MetadataWriter : BaseMetadataVisitor {

		AssemblyDefinition m_assembly;
		MetadataRoot m_root;
		TargetRuntime m_runtime;
		ImageWriter m_imgWriter;
		MetadataTableWriter m_tableWriter;
		MemoryBinaryWriter m_binaryWriter;

		IDictionary m_stringCache;
		MemoryBinaryWriter m_stringWriter;

		IDictionary m_guidCache;
		MemoryBinaryWriter m_guidWriter;

		IDictionary m_usCache;
		MemoryBinaryWriter m_usWriter;

		IDictionary m_blobCache;
		MemoryBinaryWriter m_blobWriter;

		MemoryBinaryWriter m_tWriter;

		MemoryBinaryWriter m_cilWriter;

		MemoryBinaryWriter m_fieldDataWriter;
		MemoryBinaryWriter m_resWriter;

		uint m_mdStart, m_mdSize;
		uint m_resStart, m_resSize;
		uint m_snsStart, m_snsSize;
		uint m_debugHeaderStart;
		uint m_imporTableStart;

		uint m_entryPointToken;

		RVA m_cursor = new RVA (0x2050);

		public MemoryBinaryWriter CilWriter {
			get { return m_cilWriter; }
		}

		public uint DebugHeaderPosition {
			get { return m_debugHeaderStart; }
		}

		public uint ImportTablePosition {
			get { return m_imporTableStart; }
		}

		public uint EntryPointToken {
			get { return m_entryPointToken; }
			set { m_entryPointToken = value; }
		}

		public MetadataWriter (AssemblyDefinition asm, MetadataRoot root,
			AssemblyKind kind, TargetRuntime rt, BinaryWriter writer)
		{
			m_assembly = asm;
			m_root = root;
			m_runtime = rt;
			m_imgWriter = new ImageWriter (this, kind, writer);
			m_binaryWriter = m_imgWriter.GetTextWriter ();

			m_stringCache = new Hashtable ();
			m_stringWriter = new MemoryBinaryWriter (Encoding.UTF8);
			m_stringWriter.Write ((byte) 0);

			m_guidCache = new Hashtable ();
			m_guidWriter = new MemoryBinaryWriter ();

			m_usCache = new Hashtable ();
			m_usWriter = new MemoryBinaryWriter (Encoding.Unicode);
			m_usWriter.Write ((byte) 0);

			m_blobCache = new Hashtable ();
			m_blobWriter = new MemoryBinaryWriter ();
			m_blobWriter.Write ((byte) 0);

			m_tWriter = new MemoryBinaryWriter ();
			m_tableWriter = new MetadataTableWriter (this, m_tWriter);

			m_cilWriter = new MemoryBinaryWriter ();

			m_fieldDataWriter = new MemoryBinaryWriter ();
			m_resWriter = new MemoryBinaryWriter ();
		}

		public MetadataRoot GetMetadataRoot ()
		{
			return m_root;
		}

		public ImageWriter GetImageWriter ()
		{
			return m_imgWriter;
		}

		public MemoryBinaryWriter GetWriter ()
		{
			return m_binaryWriter;
		}

		public MetadataTableWriter GetTableVisitor ()
		{
			return m_tableWriter;
		}

		public void AddData (int length)
		{
			m_cursor += new RVA ((uint) length);
		}

		public RVA GetDataCursor ()
		{
			return m_cursor;
		}

		public uint AddString (string str)
		{
			if (str == null || str.Length == 0)
				return 0;

			if (m_stringCache.Contains (str))
				return (uint) m_stringCache [str];

			uint pointer = (uint) m_stringWriter.BaseStream.Position;
			m_stringCache [str] = pointer;
			m_stringWriter.Write (Encoding.UTF8.GetBytes (str));
			m_stringWriter.Write ('\0');
			return pointer;
		}

		public uint AddBlob (byte [] data)
		{
			if (data == null || data.Length == 0)
				return 0;

			// using CompactFramework compatible version of
			// Convert.ToBase64String
			string key = Convert.ToBase64String (data, 0, data.Length);
			if (m_blobCache.Contains (key))
				return (uint) m_blobCache [key];

			uint pointer = (uint) m_blobWriter.BaseStream.Position;
			m_blobCache [key] = pointer;
			Utilities.WriteCompressedInteger (m_blobWriter, data.Length);
			m_blobWriter.Write (data);
			return pointer;
		}

		public uint AddGuid (Guid g)
		{
			if (m_guidCache.Contains (g))
				return (uint) m_guidCache [g];

			uint pointer = (uint) m_guidWriter.BaseStream.Position;
			m_guidCache [g] = pointer;
			m_guidWriter.Write (g.ToByteArray ());
			return pointer + 1;
		}

		public uint AddUserString (string str)
		{
			if (str == null)
				return 0;

			if (m_usCache.Contains (str))
				return (uint) m_usCache [str];

			uint pointer = (uint) m_usWriter.BaseStream.Position;
			m_usCache [str] = pointer;
			byte [] us = Encoding.Unicode.GetBytes (str);
			Utilities.WriteCompressedInteger (m_usWriter, us.Length + 1);
			m_usWriter.Write (us);
			m_usWriter.Write ((byte) (RequiresSpecialHandling (us) ? 1 : 0));
			return pointer;
		}

		static bool RequiresSpecialHandling (byte [] chars)
		{
			for (int i = 0; i < chars.Length; i++) {
				byte c = chars [i];
				if ((i % 2) == 1)
					if (c != 0)
						return true;

				if (InRange (0x01, 0x08, c) ||
					InRange (0x0e, 0x1f, c) ||
					c == 0x27 ||
					c == 0x2d ||
					c == 0x7f) {

					return true;
				}
			}

			return false;
		}

		static bool InRange (int left, int right, int value)
		{
			return left <= value && value <= right;
		}

		void CreateStream (string name)
		{
			MetadataStream stream = new MetadataStream ();
			stream.Header.Name = name;
			stream.Heap = MetadataHeap.HeapFactory (stream);
			m_root.Streams.Add (stream);
		}

		void SetHeapSize (MetadataHeap heap, MemoryBinaryWriter data, byte flag)
		{
			if (data.BaseStream.Length > 65536) {
				m_root.Streams.TablesHeap.HeapSizes |= flag;
				heap.IndexSize = 4;
			} else
				heap.IndexSize = 2;
		}

		public uint AddResource (byte [] data)
		{
			uint offset = (uint) m_resWriter.BaseStream.Position;
			m_resWriter.Write (data.Length);
			m_resWriter.Write (data);
			m_resWriter.QuadAlign ();
			return offset;
		}

		public void AddFieldInitData (byte [] data)
		{
			m_fieldDataWriter.Write (data);
			m_fieldDataWriter.QuadAlign ();
		}

		uint GetStrongNameSignatureSize ()
		{
			if (m_assembly.Name.PublicKey != null) {
				// in fx 2.0 the key may be from 384 to 16384 bits
				// so we must calculate the signature size based on
				// the size of the public key (minus the 32 byte header)
				int size = m_assembly.Name.PublicKey.Length;
				if (size > 32)
					return (uint) (size - 32);
				// note: size == 16 for the ECMA "key" which is replaced
				// by the runtime with a 1024 bits key (128 bytes)
			}
			return 128; // default strongname signature size
		}

		public override void VisitMetadataRoot (MetadataRoot root)
		{
			WriteMemStream (m_cilWriter);
			WriteMemStream (m_fieldDataWriter);
			m_resStart = (uint) m_binaryWriter.BaseStream.Position;
			WriteMemStream (m_resWriter);
			m_resSize = (uint) (m_binaryWriter.BaseStream.Position - m_resStart);

			// for now, we only reserve the place for the strong name signature
			if ((m_assembly.Name.Flags & AssemblyFlags.PublicKey) > 0) {
				m_snsStart = (uint) m_binaryWriter.BaseStream.Position;
				m_snsSize = GetStrongNameSignatureSize ();
				m_binaryWriter.Write (new byte [m_snsSize]);
				m_binaryWriter.QuadAlign ();
			}

			// save place for debug header
			if (m_imgWriter.GetImage ().DebugHeader != null) {
				m_debugHeaderStart = (uint) m_binaryWriter.BaseStream.Position;
				m_binaryWriter.Write (new byte [m_imgWriter.GetImage ().DebugHeader.GetSize ()]);
				m_binaryWriter.QuadAlign ();
			}

			m_mdStart = (uint) m_binaryWriter.BaseStream.Position;

			if (m_stringWriter.BaseStream.Length > 1) {
				CreateStream (MetadataStream.Strings);
				SetHeapSize (root.Streams.StringsHeap, m_stringWriter, 0x01);
				m_stringWriter.QuadAlign ();
			}

			if (m_guidWriter.BaseStream.Length > 0) {
				CreateStream (MetadataStream.GUID);
				SetHeapSize (root.Streams.GuidHeap, m_guidWriter, 0x02);
			}

			if (m_blobWriter.BaseStream.Length > 1) {
				CreateStream (MetadataStream.Blob);
				SetHeapSize (root.Streams.BlobHeap, m_blobWriter, 0x04);
				m_blobWriter.QuadAlign ();
			}

			if (m_usWriter.BaseStream.Length > 2) {
				CreateStream (MetadataStream.UserStrings);
				m_usWriter.QuadAlign ();
			}

			m_root.Header.MajorVersion = 1;
			m_root.Header.MinorVersion = 1;

			switch (m_runtime) {
			case TargetRuntime.NET_1_0 :
				m_root.Header.Version = "v1.0.3705";
				break;
			case TargetRuntime.NET_1_1 :
				m_root.Header.Version = "v1.1.4322";
				break;
			case TargetRuntime.NET_2_0 :
				m_root.Header.Version = "v2.0.50727";
				break;
			}

			m_root.Streams.TablesHeap.Tables.Accept (m_tableWriter);

			if (m_tWriter.BaseStream.Length == 0)
				m_root.Streams.Remove (m_root.Streams.TablesHeap.GetStream ());
		}

		public override void VisitMetadataRootHeader (MetadataRoot.MetadataRootHeader header)
		{
			m_binaryWriter.Write (header.Signature);
			m_binaryWriter.Write (header.MajorVersion);
			m_binaryWriter.Write (header.MinorVersion);
			m_binaryWriter.Write (header.Reserved);
			m_binaryWriter.Write (header.Version.Length + 3 & (~3));
			m_binaryWriter.Write (Encoding.ASCII.GetBytes (header.Version));
			m_binaryWriter.QuadAlign ();
			m_binaryWriter.Write (header.Flags);
			m_binaryWriter.Write ((ushort) m_root.Streams.Count);
		}

		public override void VisitMetadataStreamCollection (MetadataStreamCollection streams)
		{
			foreach (MetadataStream stream in streams) {
				MetadataStream.MetadataStreamHeader header = stream.Header;

				header.Offset = (uint) (m_binaryWriter.BaseStream.Position);
				m_binaryWriter.Write (header.Offset);
				MemoryBinaryWriter container;
				string name = header.Name;
				uint size = 0;
				switch (header.Name) {
				case MetadataStream.Tables :
					container = m_tWriter;
					size += 24; // header
					break;
				case MetadataStream.Strings :
					name += "\0\0\0\0";
					container = m_stringWriter;
					break;
				case MetadataStream.GUID :
					container = m_guidWriter;
					break;
				case MetadataStream.Blob :
					container = m_blobWriter;
					break;
				case MetadataStream.UserStrings :
					container = m_usWriter;
					break;
				default :
					throw new MetadataFormatException ("Unknown stream kind");
				}

				size += (uint) (container.BaseStream.Length + 3 & (~3));
				m_binaryWriter.Write (size);
				m_binaryWriter.Write (Encoding.ASCII.GetBytes (name));
				m_binaryWriter.QuadAlign ();
			}
		}

		void WriteMemStream (MemoryBinaryWriter writer)
		{
			m_binaryWriter.Write (writer);
			m_binaryWriter.QuadAlign ();
		}

		void PatchStreamHeaderOffset (MetadataHeap heap)
		{
			long pos = m_binaryWriter.BaseStream.Position;
			m_binaryWriter.BaseStream.Position = heap.GetStream ().Header.Offset;
			m_binaryWriter.Write ((uint) (pos - m_mdStart));
			m_binaryWriter.BaseStream.Position = pos;
		}

		public override void VisitGuidHeap (GuidHeap heap)
		{
			PatchStreamHeaderOffset (heap);
			WriteMemStream (m_guidWriter);
		}

		public override void VisitStringsHeap (StringsHeap heap)
		{
			PatchStreamHeaderOffset (heap);
			WriteMemStream (m_stringWriter);
		}

		public override void VisitTablesHeap (TablesHeap heap)
		{
			PatchStreamHeaderOffset (heap);
			m_binaryWriter.Write (heap.Reserved);
			switch (m_runtime) {
			case TargetRuntime.NET_1_0 :
			case TargetRuntime.NET_1_1 :
				heap.MajorVersion = 1;
				heap.MinorVersion = 0;
				break;
			case TargetRuntime.NET_2_0 :
				heap.MajorVersion = 2;
				heap.MinorVersion = 0;
				break;
			}
			m_binaryWriter.Write (heap.MajorVersion);
			m_binaryWriter.Write (heap.MinorVersion);
			m_binaryWriter.Write (heap.HeapSizes);
			m_binaryWriter.Write (heap.Reserved2);
			m_binaryWriter.Write (heap.Valid);
			m_binaryWriter.Write (heap.Sorted);
			WriteMemStream (m_tWriter);
		}

		public override void VisitBlobHeap (BlobHeap heap)
		{
			PatchStreamHeaderOffset (heap);
			WriteMemStream (m_blobWriter);
		}

		public override void VisitUserStringsHeap (UserStringsHeap heap)
		{
			PatchStreamHeaderOffset (heap);
			WriteMemStream (m_usWriter);
		}

		void PatchHeader ()
		{
			Image img = m_imgWriter.GetImage ();

			img.CLIHeader.EntryPointToken = m_entryPointToken;

			if (m_mdSize > 0)
				img.CLIHeader.Metadata = new DataDirectory (
					img.TextSection.VirtualAddress + m_mdStart, m_imporTableStart - m_mdStart);

			if (m_resSize > 0)
				img.CLIHeader.Resources = new DataDirectory (
					img.TextSection.VirtualAddress + m_resStart, m_resSize);

			if (m_snsStart > 0)
				img.CLIHeader.StrongNameSignature = new DataDirectory (
					img.TextSection.VirtualAddress + m_snsStart, m_snsSize);

			if (m_debugHeaderStart > 0)
				img.PEOptionalHeader.DataDirectories.Debug = new DataDirectory (
					img.TextSection.VirtualAddress + m_debugHeaderStart, 0x1c);
		}

		public override void TerminateMetadataRoot (MetadataRoot root)
		{
			m_mdSize = (uint) (m_binaryWriter.BaseStream.Position - m_mdStart);
			m_imporTableStart = (uint) m_binaryWriter.BaseStream.Position;
			m_binaryWriter.Write (new byte [0x60]); // imports
			m_imgWriter.Initialize ();
			PatchHeader ();
			root.GetImage ().Accept (m_imgWriter);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/Method.cs
================================================
//
// MethodTable.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Tue Oct 10 23:08:26 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	using Mono.Cecil;

	using Mono.Cecil.Binary;

	public sealed class MethodTable : IMetadataTable {

		public const int RId = 0x06;

		RowCollection m_rows;

		public MethodRow this [int index] {
			get { return m_rows [index] as MethodRow; }
			set { m_rows [index] = value; }
		}

		public RowCollection Rows {
			get { return m_rows; }
			set { m_rows = value; }
		}

		public int Id {
			get { return RId; }
		}

		internal MethodTable ()
		{
		}

		public void Accept (IMetadataTableVisitor visitor)
		{
			visitor.VisitMethodTable (this);
			this.Rows.Accept (visitor.GetRowVisitor ());
		}
	}

	public sealed class MethodRow : IMetadataRow {

		public RVA RVA;
		public MethodImplAttributes ImplFlags;
		public MethodAttributes Flags;
		public uint Name;
		public uint Signature;
		public uint ParamList;

		internal MethodRow ()
		{
		}

		public void Accept (IMetadataRowVisitor visitor)
		{
			visitor.VisitMethodRow (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/MethodImpl.cs
================================================
//
// MethodImplTable.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Tue Oct 10 23:08:26 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	public sealed class MethodImplTable : IMetadataTable {

		public const int RId = 0x19;

		RowCollection m_rows;

		public MethodImplRow this [int index] {
			get { return m_rows [index] as MethodImplRow; }
			set { m_rows [index] = value; }
		}

		public RowCollection Rows {
			get { return m_rows; }
			set { m_rows = value; }
		}

		public int Id {
			get { return RId; }
		}

		internal MethodImplTable ()
		{
		}

		public void Accept (IMetadataTableVisitor visitor)
		{
			visitor.VisitMethodImplTable (this);
			this.Rows.Accept (visitor.GetRowVisitor ());
		}
	}

	public sealed class MethodImplRow : IMetadataRow {

		public uint Class;
		public MetadataToken MethodBody;
		public MetadataToken MethodDeclaration;

		internal MethodImplRow ()
		{
		}

		public void Accept (IMetadataRowVisitor visitor)
		{
			visitor.VisitMethodImplRow (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/MethodPtr.cs
================================================
//
// MethodPtrTable.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Thu Feb 22 14:39:38 CET 2007
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	public sealed class MethodPtrTable : IMetadataTable {

		public const int RId = 0x05;

		RowCollection m_rows;

		public MethodPtrRow this [int index] {
			get { return m_rows [index] as MethodPtrRow; }
			set { m_rows [index] = value; }
		}

		public RowCollection Rows {
			get { return m_rows; }
			set { m_rows = value; }
		}

		public int Id {
			get { return RId; }
		}

		internal MethodPtrTable ()
		{
		}

		public void Accept (IMetadataTableVisitor visitor)
		{
			visitor.VisitMethodPtrTable (this);
			this.Rows.Accept (visitor.GetRowVisitor ());
		}
	}

	public sealed class MethodPtrRow : IMetadataRow {

		public uint Method;

		internal MethodPtrRow ()
		{
		}

		public void Accept (IMetadataRowVisitor visitor)
		{
			visitor.VisitMethodPtrRow (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/MethodSemantics.cs
================================================
//
// MethodSemanticsTable.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Tue Oct 10 23:08:26 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	using Mono.Cecil;

	public sealed class MethodSemanticsTable : IMetadataTable {

		public const int RId = 0x18;

		RowCollection m_rows;

		public MethodSemanticsRow this [int index] {
			get { return m_rows [index] as MethodSemanticsRow; }
			set { m_rows [index] = value; }
		}

		public RowCollection Rows {
			get { return m_rows; }
			set { m_rows = value; }
		}

		public int Id {
			get { return RId; }
		}

		internal MethodSemanticsTable ()
		{
		}

		public void Accept (IMetadataTableVisitor visitor)
		{
			visitor.VisitMethodSemanticsTable (this);
			this.Rows.Accept (visitor.GetRowVisitor ());
		}
	}

	public sealed class MethodSemanticsRow : IMetadataRow {

		public MethodSemanticsAttributes Semantics;
		public uint Method;
		public MetadataToken Association;

		internal MethodSemanticsRow ()
		{
		}

		public void Accept (IMetadataRowVisitor visitor)
		{
			visitor.VisitMethodSemanticsRow (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/MethodSpec.cs
================================================
//
// MethodSpecTable.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Tue Oct 10 23:08:26 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	public sealed class MethodSpecTable : IMetadataTable {

		public const int RId = 0x2b;

		RowCollection m_rows;

		public MethodSpecRow this [int index] {
			get { return m_rows [index] as MethodSpecRow; }
			set { m_rows [index] = value; }
		}

		public RowCollection Rows {
			get { return m_rows; }
			set { m_rows = value; }
		}

		public int Id {
			get { return RId; }
		}

		internal MethodSpecTable ()
		{
		}

		public void Accept (IMetadataTableVisitor visitor)
		{
			visitor.VisitMethodSpecTable (this);
			this.Rows.Accept (visitor.GetRowVisitor ());
		}
	}

	public sealed class MethodSpecRow : IMetadataRow {

		public MetadataToken Method;
		public uint Instantiation;

		internal MethodSpecRow ()
		{
		}

		public void Accept (IMetadataRowVisitor visitor)
		{
			visitor.VisitMethodSpecRow (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/Module.cs
================================================
//
// ModuleTable.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Tue Oct 10 23:08:26 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	public sealed class ModuleTable : IMetadataTable {

		public const int RId = 0x00;

		RowCollection m_rows;

		public ModuleRow this [int index] {
			get { return m_rows [index] as ModuleRow; }
			set { m_rows [index] = value; }
		}

		public RowCollection Rows {
			get { return m_rows; }
			set { m_rows = value; }
		}

		public int Id {
			get { return RId; }
		}

		internal ModuleTable ()
		{
		}

		public void Accept (IMetadataTableVisitor visitor)
		{
			visitor.VisitModuleTable (this);
			this.Rows.Accept (visitor.GetRowVisitor ());
		}
	}

	public sealed class ModuleRow : IMetadataRow {

		public ushort Generation;
		public uint Name;
		public uint Mvid;
		public uint EncId;
		public uint EncBaseId;

		internal ModuleRow ()
		{
		}

		public void Accept (IMetadataRowVisitor visitor)
		{
			visitor.VisitModuleRow (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/ModuleRef.cs
================================================
//
// ModuleRefTable.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Tue Oct 10 23:08:26 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	public sealed class ModuleRefTable : IMetadataTable {

		public const int RId = 0x1a;

		RowCollection m_rows;

		public ModuleRefRow this [int index] {
			get { return m_rows [index] as ModuleRefRow; }
			set { m_rows [index] = value; }
		}

		public RowCollection Rows {
			get { return m_rows; }
			set { m_rows = value; }
		}

		public int Id {
			get { return RId; }
		}

		internal ModuleRefTable ()
		{
		}

		public void Accept (IMetadataTableVisitor visitor)
		{
			visitor.VisitModuleRefTable (this);
			this.Rows.Accept (visitor.GetRowVisitor ());
		}
	}

	public sealed class ModuleRefRow : IMetadataRow {

		public uint Name;

		internal ModuleRefRow ()
		{
		}

		public void Accept (IMetadataRowVisitor visitor)
		{
			visitor.VisitModuleRefRow (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/NestedClass.cs
================================================
//
// NestedClassTable.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Tue Oct 10 23:08:26 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	public sealed class NestedClassTable : IMetadataTable {

		public const int RId = 0x29;

		RowCollection m_rows;

		public NestedClassRow this [int index] {
			get { return m_rows [index] as NestedClassRow; }
			set { m_rows [index] = value; }
		}

		public RowCollection Rows {
			get { return m_rows; }
			set { m_rows = value; }
		}

		public int Id {
			get { return RId; }
		}

		internal NestedClassTable ()
		{
		}

		public void Accept (IMetadataTableVisitor visitor)
		{
			visitor.VisitNestedClassTable (this);
			this.Rows.Accept (visitor.GetRowVisitor ());
		}
	}

	public sealed class NestedClassRow : IMetadataRow {

		public uint NestedClass;
		public uint EnclosingClass;

		internal NestedClassRow ()
		{
		}

		public void Accept (IMetadataRowVisitor visitor)
		{
			visitor.VisitNestedClassRow (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/Param.cs
================================================
//
// ParamTable.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Tue Oct 10 23:08:26 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	using Mono.Cecil;

	public sealed class ParamTable : IMetadataTable {

		public const int RId = 0x08;

		RowCollection m_rows;

		public ParamRow this [int index] {
			get { return m_rows [index] as ParamRow; }
			set { m_rows [index] = value; }
		}

		public RowCollection Rows {
			get { return m_rows; }
			set { m_rows = value; }
		}

		public int Id {
			get { return RId; }
		}

		internal ParamTable ()
		{
		}

		public void Accept (IMetadataTableVisitor visitor)
		{
			visitor.VisitParamTable (this);
			this.Rows.Accept (visitor.GetRowVisitor ());
		}
	}

	public sealed class ParamRow : IMetadataRow {

		public ParameterAttributes Flags;
		public ushort Sequence;
		public uint Name;

		internal ParamRow ()
		{
		}

		public void Accept (IMetadataRowVisitor visitor)
		{
			visitor.VisitParamRow (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/ParamPtr.cs
================================================
//
// ParamPtrTable.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Thu Feb 22 14:39:38 CET 2007
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	public sealed class ParamPtrTable : IMetadataTable {

		public const int RId = 0x07;

		RowCollection m_rows;

		public ParamPtrRow this [int index] {
			get { return m_rows [index] as ParamPtrRow; }
			set { m_rows [index] = value; }
		}

		public RowCollection Rows {
			get { return m_rows; }
			set { m_rows = value; }
		}

		public int Id {
			get { return RId; }
		}

		internal ParamPtrTable ()
		{
		}

		public void Accept (IMetadataTableVisitor visitor)
		{
			visitor.VisitParamPtrTable (this);
			this.Rows.Accept (visitor.GetRowVisitor ());
		}
	}

	public sealed class ParamPtrRow : IMetadataRow {

		public uint Param;

		internal ParamPtrRow ()
		{
		}

		public void Accept (IMetadataRowVisitor visitor)
		{
			visitor.VisitParamPtrRow (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/Property.cs
================================================
//
// PropertyTable.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Tue Oct 10 23:08:26 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	using Mono.Cecil;

	public sealed class PropertyTable : IMetadataTable {

		public const int RId = 0x17;

		RowCollection m_rows;

		public PropertyRow this [int index] {
			get { return m_rows [index] as PropertyRow; }
			set { m_rows [index] = value; }
		}

		public RowCollection Rows {
			get { return m_rows; }
			set { m_rows = value; }
		}

		public int Id {
			get { return RId; }
		}

		internal PropertyTable ()
		{
		}

		public void Accept (IMetadataTableVisitor visitor)
		{
			visitor.VisitPropertyTable (this);
			this.Rows.Accept (visitor.GetRowVisitor ());
		}
	}

	public sealed class PropertyRow : IMetadataRow {

		public PropertyAttributes Flags;
		public uint Name;
		public uint Type;

		internal PropertyRow ()
		{
		}

		public void Accept (IMetadataRowVisitor visitor)
		{
			visitor.VisitPropertyRow (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/PropertyMap.cs
================================================
//
// PropertyMapTable.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Tue Oct 10 23:08:26 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	public sealed class PropertyMapTable : IMetadataTable {

		public const int RId = 0x15;

		RowCollection m_rows;

		public PropertyMapRow this [int index] {
			get { return m_rows [index] as PropertyMapRow; }
			set { m_rows [index] = value; }
		}

		public RowCollection Rows {
			get { return m_rows; }
			set { m_rows = value; }
		}

		public int Id {
			get { return RId; }
		}

		internal PropertyMapTable ()
		{
		}

		public void Accept (IMetadataTableVisitor visitor)
		{
			visitor.VisitPropertyMapTable (this);
			this.Rows.Accept (visitor.GetRowVisitor ());
		}
	}

	public sealed class PropertyMapRow : IMetadataRow {

		public uint Parent;
		public uint PropertyList;

		internal PropertyMapRow ()
		{
		}

		public void Accept (IMetadataRowVisitor visitor)
		{
			visitor.VisitPropertyMapRow (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/PropertyPtr.cs
================================================
//
// PropertyPtrTable.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Thu Feb 22 14:39:38 CET 2007
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	public sealed class PropertyPtrTable : IMetadataTable {

		public const int RId = 0x16;

		RowCollection m_rows;

		public PropertyPtrRow this [int index] {
			get { return m_rows [index] as PropertyPtrRow; }
			set { m_rows [index] = value; }
		}

		public RowCollection Rows {
			get { return m_rows; }
			set { m_rows = value; }
		}

		public int Id {
			get { return RId; }
		}

		internal PropertyPtrTable ()
		{
		}

		public void Accept (IMetadataTableVisitor visitor)
		{
			visitor.VisitPropertyPtrTable (this);
			this.Rows.Accept (visitor.GetRowVisitor ());
		}
	}

	public sealed class PropertyPtrRow : IMetadataRow {

		public uint Property;

		internal PropertyPtrRow ()
		{
		}

		public void Accept (IMetadataRowVisitor visitor)
		{
			visitor.VisitPropertyPtrRow (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/RowCollection.cs
================================================
//
// RowCollection.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	using System;
	using System.Collections;

	public class RowCollection : ICollection, IMetadataRowVisitable {

		ArrayList m_items;

		public IMetadataRow this [int index] {
			get { return m_items [index] as IMetadataRow; }
			set { m_items [index] = value; }
		}

		public int Count {
			get { return m_items.Count; }
		}

		public bool IsSynchronized {
			get { return false; }
		}

		public object SyncRoot {
			get { return this; }
		}

		internal RowCollection (int size)
		{
			m_items = new ArrayList (size);
		}

		internal RowCollection ()
		{
			m_items = new ArrayList ();
		}

		internal void Add (IMetadataRow value)
		{
			m_items.Add (value);
		}

		public void Clear ()
		{
			m_items.Clear ();
		}

		public bool Contains (IMetadataRow value)
		{
			return m_items.Contains (value);
		}

		public int IndexOf (IMetadataRow value)
		{
			return m_items.IndexOf (value);
		}

		public void Insert (int index, IMetadataRow value)
		{
			m_items.Insert (index, value);
		}

		public void Remove (IMetadataRow value)
		{
			m_items.Remove (value);
		}

		public void RemoveAt (int index)
		{
			m_items.Remove (index);
		}

		public void CopyTo (Array ary, int index)
		{
			m_items.CopyTo (ary, index);
		}

		public void Sort (IComparer comp)
		{
			m_items.Sort (comp);
		}

		public IEnumerator GetEnumerator ()
		{
			return m_items.GetEnumerator ();
		}

		public void Accept (IMetadataRowVisitor visitor)
		{
			visitor.VisitRowCollection (this);

			for (int i = 0; i < m_items.Count; i++)
				this [i].Accept (visitor);

			visitor.TerminateRowCollection (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/StandAloneSig.cs
================================================
//
// StandAloneSigTable.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Tue Oct 10 23:08:26 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	public sealed class StandAloneSigTable : IMetadataTable {

		public const int RId = 0x11;

		RowCollection m_rows;

		public StandAloneSigRow this [int index] {
			get { return m_rows [index] as StandAloneSigRow; }
			set { m_rows [index] = value; }
		}

		public RowCollection Rows {
			get { return m_rows; }
			set { m_rows = value; }
		}

		public int Id {
			get { return RId; }
		}

		internal StandAloneSigTable ()
		{
		}

		public void Accept (IMetadataTableVisitor visitor)
		{
			visitor.VisitStandAloneSigTable (this);
			this.Rows.Accept (visitor.GetRowVisitor ());
		}
	}

	public sealed class StandAloneSigRow : IMetadataRow {

		public uint Signature;

		internal StandAloneSigRow ()
		{
		}

		public void Accept (IMetadataRowVisitor visitor)
		{
			visitor.VisitStandAloneSigRow (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/StringsHeap.cs
================================================
//
// StringsHeap.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	using System.Collections;
	using System.IO;
	using System.Text;

	public class StringsHeap : MetadataHeap {

		IDictionary m_strings;

		public string this [uint index] {
			get {
				string str = m_strings [index] as string;
				if (str == null) {
					str = ReadStringAt (index);
					m_strings [index] = str;
				}
				return str;
			}
			set { m_strings [index] = value; }
		}

		internal StringsHeap (MetadataStream stream) : base (stream, MetadataStream.Strings)
		{
			m_strings = new Hashtable ();
		}

		string ReadStringAt (uint index)
		{
			StringBuilder sb = new StringBuilder ();
			BinaryReader br = new BinaryReader (
				new MemoryStream (this.Data), Encoding.UTF8);

			try {
				br.BaseStream.Position = index;

				while (br.BaseStream.Position < br.BaseStream.Length) {
					char c = br.ReadChar ();
					if (c == '\0')
						break;
					else
						sb.Append (c);
				}
			} finally {
				br.Close ();
			}

			return sb.ToString ();
		}

		public override void Accept (IMetadataVisitor visitor)
		{
			visitor.VisitStringsHeap (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/TableCollection.cs
================================================
//
// TableCollection.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	using System;
	using System.Collections;

	public class TableCollection : ICollection, IMetadataTableVisitable	{

		IMetadataTable [] m_tables = new IMetadataTable [TablesHeap.MaxTableCount];

		TablesHeap m_heap;

		public IMetadataTable this [int index] {
			get { return m_tables [index]; }
			set { m_tables [index] = value; }
		}

		public int Count {
			get {
				return GetList ().Count;
			}
		}

		public bool IsSynchronized {
			get { return false; }
		}

		public object SyncRoot {
			get { return this; }
		}

		public TablesHeap Heap {
			get { return m_heap; }
		}

		internal TableCollection (TablesHeap heap)
		{
			m_heap = heap;
		}

		internal void Add (IMetadataTable value)
		{
			m_tables [value.Id] = value;
		}

		public bool Contains (IMetadataTable value)
		{
			return m_tables [value.Id] != null;
		}

		internal void Remove (IMetadataTable value)
		{
			m_tables [value.Id] = null;
		}

		public void CopyTo (Array array, int index)
		{
			GetList ().CopyTo (array, index);
		}

		internal IList GetList ()
		{
			IList tables = new ArrayList ();
			for (int i = 0; i < m_tables.Length; i++) {
				IMetadataTable table = m_tables [i];
				if (table != null)
					tables.Add (table);
			}

			return tables;
		}

		public IEnumerator GetEnumerator ()
		{
			return GetList ().GetEnumerator ();
		}

		public void Accept (IMetadataTableVisitor visitor)
		{
			visitor.VisitTableCollection (this);

			foreach (IMetadataTable table in GetList ())
				table.Accept (visitor);

			visitor.TerminateTableCollection (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/TablesHeap.cs
================================================
//
// TablesHeap.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	using System;
	using System.Collections;

	public class TablesHeap : MetadataHeap {

		public uint Reserved;
		public byte MajorVersion;
		public byte MinorVersion;
		public byte HeapSizes;
		public byte Reserved2;
		public long Valid;
		public long Sorted;

		TableCollection m_tables;

		public const int MaxTableCount = 45;

		public TableCollection Tables {
			get { return m_tables; }
			set { m_tables = value; }
		}

		public IMetadataTable this [int id]
		{
			get { return m_tables [id]; }
			set { m_tables [id] = value; }
		}

		internal TablesHeap (MetadataStream stream) : base(stream, MetadataStream.Tables)
		{
		}

		public bool HasTable (int id)
		{
			return (Valid & (1L << id)) != 0;
		}

		public override void Accept (IMetadataVisitor visitor)
		{
			visitor.VisitTablesHeap (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/TokenType.cs
================================================
//
// TokenType.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	public enum TokenType : uint {
		Module			  = 0x00000000,
		TypeRef			 = 0x01000000,
		TypeDef			 = 0x02000000,
		Field			   = 0x04000000,
		Method			  = 0x06000000,
		Param			   = 0x08000000,
		InterfaceImpl	   = 0x09000000,
		MemberRef		   = 0x0a000000,
		CustomAttribute	 = 0x0c000000,
		Permission		  = 0x0e000000,
		Signature		   = 0x11000000,
		Event			   = 0x14000000,
		Property			= 0x17000000,
		ModuleRef		   = 0x1a000000,
		TypeSpec			= 0x1b000000,
		Assembly			= 0x20000000,
		AssemblyRef		 = 0x23000000,
		File				= 0x26000000,
		ExportedType		= 0x27000000,
		ManifestResource	= 0x28000000,
		GenericParam			= 0x2a000000,
		MethodSpec			= 0x2b000000,
		String			  = 0x70000000,
		Name				= 0x71000000,
		BaseType			= 0x72000000
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/TypeDef.cs
================================================
//
// TypeDefTable.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Tue Oct 10 23:08:26 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	using Mono.Cecil;

	public sealed class TypeDefTable : IMetadataTable {

		public const int RId = 0x02;

		RowCollection m_rows;

		public TypeDefRow this [int index] {
			get { return m_rows [index] as TypeDefRow; }
			set { m_rows [index] = value; }
		}

		public RowCollection Rows {
			get { return m_rows; }
			set { m_rows = value; }
		}

		public int Id {
			get { return RId; }
		}

		internal TypeDefTable ()
		{
		}

		public void Accept (IMetadataTableVisitor visitor)
		{
			visitor.VisitTypeDefTable (this);
			this.Rows.Accept (visitor.GetRowVisitor ());
		}
	}

	public sealed class TypeDefRow : IMetadataRow {

		public TypeAttributes Flags;
		public uint Name;
		public uint Namespace;
		public MetadataToken Extends;
		public uint FieldList;
		public uint MethodList;

		internal TypeDefRow ()
		{
		}

		public void Accept (IMetadataRowVisitor visitor)
		{
			visitor.VisitTypeDefRow (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/TypeRef.cs
================================================
//
// TypeRefTable.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Tue Oct 10 23:08:26 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	public sealed class TypeRefTable : IMetadataTable {

		public const int RId = 0x01;

		RowCollection m_rows;

		public TypeRefRow this [int index] {
			get { return m_rows [index] as TypeRefRow; }
			set { m_rows [index] = value; }
		}

		public RowCollection Rows {
			get { return m_rows; }
			set { m_rows = value; }
		}

		public int Id {
			get { return RId; }
		}

		internal TypeRefTable ()
		{
		}

		public void Accept (IMetadataTableVisitor visitor)
		{
			visitor.VisitTypeRefTable (this);
			this.Rows.Accept (visitor.GetRowVisitor ());
		}
	}

	public sealed class TypeRefRow : IMetadataRow {

		public MetadataToken ResolutionScope;
		public uint Name;
		public uint Namespace;

		internal TypeRefRow ()
		{
		}

		public void Accept (IMetadataRowVisitor visitor)
		{
			visitor.VisitTypeRefRow (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/TypeSpec.cs
================================================
//
// TypeSpecTable.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Tue Oct 10 23:08:26 CEST 2006
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	public sealed class TypeSpecTable : IMetadataTable {

		public const int RId = 0x1b;

		RowCollection m_rows;

		public TypeSpecRow this [int index] {
			get { return m_rows [index] as TypeSpecRow; }
			set { m_rows [index] = value; }
		}

		public RowCollection Rows {
			get { return m_rows; }
			set { m_rows = value; }
		}

		public int Id {
			get { return RId; }
		}

		internal TypeSpecTable ()
		{
		}

		public void Accept (IMetadataTableVisitor visitor)
		{
			visitor.VisitTypeSpecTable (this);
			this.Rows.Accept (visitor.GetRowVisitor ());
		}
	}

	public sealed class TypeSpecRow : IMetadataRow {

		public uint Signature;

		internal TypeSpecRow ()
		{
		}

		public void Accept (IMetadataRowVisitor visitor)
		{
			visitor.VisitTypeSpecRow (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/UserStringsHeap.cs
================================================
//
// UserStringsHeap.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	using System;
	using System.Collections;
	using System.Text;

	public class UserStringsHeap : MetadataHeap {

		readonly IDictionary m_strings;

		public string this [uint offset] {
			get {
				string us = m_strings [offset] as string;
				if (us != null)
					return us;

				us = ReadStringAt ((int) offset);
				if (us != null && us.Length != 0)
					m_strings [offset] = us;

				return us;
			}
			set { m_strings [offset] = value; }
		}

		internal UserStringsHeap (MetadataStream stream) : base(stream, MetadataStream.UserStrings)
		{
			m_strings = new Hashtable ();
		}

		string ReadStringAt (int offset)
		{
			int length = Utilities.ReadCompressedInteger (this.Data, offset, out offset);
			if (length == 0)
				return string.Empty;

			return Encoding.Unicode.GetString (this.Data, offset, length - 1);
		}

		public override void Accept (IMetadataVisitor visitor)
		{
			visitor.VisitUserStringsHeap (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Metadata/Utilities.cs
================================================
//
// Utilities.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Generated by /CodeGen/cecil-gen.rb do not edit
// Tue Mar 20 16:02:16 +0100 2007
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Metadata {

	using System;
	using System.Collections;
	using System.IO;

	class Utilities {

		Utilities ()
		{
		}

		public static int ReadCompressedInteger (byte [] data, int pos, out int start)
		{
			int integer = 0;
			start = pos;
			if ((data [pos] & 0x80) == 0) {
				integer = data [pos];
				start++;
			} else if ((data [pos] & 0x40) == 0) {
				integer = (data [start] & ~0x80) << 8;
				integer |= data [pos + 1];
				start += 2;
			} else {
				integer = (data [start] & ~0xc0) << 24;
				integer |= data [pos + 1] << 16;
				integer |= data [pos + 2] << 8;
				integer |= data [pos + 3];
				start += 4;
			}
			return integer;
		}

		public static int WriteCompressedInteger (BinaryWriter writer, int value)
		{
			if (value < 0x80)
				writer.Write ((byte) value);
			else if (value < 0x4000) {
				writer.Write ((byte) (0x80 | (value >> 8)));
				writer.Write ((byte) (value & 0xff));
			} else {
				writer.Write ((byte) ((value >> 24) | 0xc0));
				writer.Write ((byte) ((value >> 16) & 0xff));
				writer.Write ((byte) ((value >> 8) & 0xff));
				writer.Write ((byte) (value & 0xff));
			}
			return (int) writer.BaseStream.Position;
		}

		public static MetadataToken GetMetadataToken (CodedIndex cidx, uint data)
		{
			uint rid = 0;
			switch (cidx) {
			case CodedIndex.TypeDefOrRef :
				rid = data >> 2;
				switch (data & 3) {
				case 0 :
					return new MetadataToken (TokenType.TypeDef, rid);
				case 1 :
					return new MetadataToken (TokenType.TypeRef, rid);
				case 2 :
					return new MetadataToken (TokenType.TypeSpec, rid);
				default :
					throw new MetadataFormatException("Non valid tag for TypeDefOrRef");
				}
			case CodedIndex.HasConstant :
				rid = data >> 2;
				switch (data & 3) {
				case 0 :
					return new MetadataToken (TokenType.Field, rid);
				case 1 :
					return new MetadataToken (TokenType.Param, rid);
				case 2 :
					return new MetadataToken (TokenType.Property, rid);
				default :
					throw new MetadataFormatException("Non valid tag for HasConstant");
				}
			case CodedIndex.HasCustomAttribute :
				rid = data >> 5;
				switch (data & 31) {
				case 0 :
					return new MetadataToken (TokenType.Method, rid);
				case 1 :
					return new MetadataToken (TokenType.Field, rid);
				case 2 :
					return new MetadataToken (TokenType.TypeRef, rid);
				case 3 :
					return new MetadataToken (TokenType.TypeDef, rid);
				case 4 :
					return new MetadataToken (TokenType.Param, rid);
				case 5 :
					return new MetadataToken (TokenType.InterfaceImpl, rid);
				case 6 :
					return new MetadataToken (TokenType.MemberRef, rid);
				case 7 :
					return new MetadataToken (TokenType.Module, rid);
				case 8 :
					return new MetadataToken (TokenType.Permission, rid);
				case 9 :
					return new MetadataToken (TokenType.Property, rid);
				case 10 :
					return new MetadataToken (TokenType.Event, rid);
				case 11 :
					return new MetadataToken (TokenType.Signature, rid);
				case 12 :
					return new MetadataToken (TokenType.ModuleRef, rid);
				case 13 :
					return new MetadataToken (TokenType.TypeSpec, rid);
				case 14 :
					return new MetadataToken (TokenType.Assembly, rid);
				case 15 :
					return new MetadataToken (TokenType.AssemblyRef, rid);
				case 16 :
					return new MetadataToken (TokenType.File, rid);
				case 17 :
					return new MetadataToken (TokenType.ExportedType, rid);
				case 18 :
					return new MetadataToken (TokenType.ManifestResource, rid);
				case 19 :
					return new MetadataToken (TokenType.GenericParam, rid);
				default :
					throw new MetadataFormatException("Non valid tag for HasCustomAttribute");
				}
			case CodedIndex.HasFieldMarshal :
				rid = data >> 1;
				switch (data & 1) {
				case 0 :
					return new MetadataToken (TokenType.Field, rid);
				case 1 :
					return new MetadataToken (TokenType.Param, rid);
				default :
					throw new MetadataFormatException("Non valid tag for HasFieldMarshal");
				}
			case CodedIndex.HasDeclSecurity :
				rid = data >> 2;
				switch (data & 3) {
				case 0 :
					return new MetadataToken (TokenType.TypeDef, rid);
				case 1 :
					return new MetadataToken (TokenType.Method, rid);
				case 2 :
					return new MetadataToken (TokenType.Assembly, rid);
				default :
					throw new MetadataFormatException("Non valid tag for HasDeclSecurity");
				}
			case CodedIndex.MemberRefParent :
				rid = data >> 3;
				switch (data & 7) {
				case 0 :
					return new MetadataToken (TokenType.TypeDef, rid);
				case 1 :
					return new MetadataToken (TokenType.TypeRef, rid);
				case 2 :
					return new MetadataToken (TokenType.ModuleRef, rid);
				case 3 :
					return new MetadataToken (TokenType.Method, rid);
				case 4 :
					return new MetadataToken (TokenType.TypeSpec, rid);
				default :
					throw new MetadataFormatException("Non valid tag for MemberRefParent");
				}
			case CodedIndex.HasSemantics :
				rid = data >> 1;
				switch (data & 1) {
				case 0 :
					return new MetadataToken (TokenType.Event, rid);
				case 1 :
					return new MetadataToken (TokenType.Property, rid);
				default :
					throw new MetadataFormatException("Non valid tag for HasSemantics");
				}
			case CodedIndex.MethodDefOrRef :
				rid = data >> 1;
				switch (data & 1) {
				case 0 :
					return new MetadataToken (TokenType.Method, rid);
				case 1 :
					return new MetadataToken (TokenType.MemberRef, rid);
				default :
					throw new MetadataFormatException("Non valid tag for MethodDefOrRef");
				}
			case CodedIndex.MemberForwarded :
				rid = data >> 1;
				switch (data & 1) {
				case 0 :
					return new MetadataToken (TokenType.Field, rid);
				case 1 :
					return new MetadataToken (TokenType.Method, rid);
				default :
					throw new MetadataFormatException("Non valid tag for MemberForwarded");
				}
			case CodedIndex.Implementation :
				rid = data >> 2;
				switch (data & 3) {
				case 0 :
					return new MetadataToken (TokenType.File, rid);
				case 1 :
					return new MetadataToken (TokenType.AssemblyRef, rid);
				case 2 :
					return new MetadataToken (TokenType.ExportedType, rid);
				default :
					throw new MetadataFormatException("Non valid tag for Implementation");
				}
			case CodedIndex.CustomAttributeType :
				rid = data >> 3;
				switch (data & 7) {
				case 2 :
					return new MetadataToken (TokenType.Method, rid);
				case 3 :
					return new MetadataToken (TokenType.MemberRef, rid);
				default :
					throw new MetadataFormatException("Non valid tag for CustomAttributeType");
				}
			case CodedIndex.ResolutionScope :
				rid = data >> 2;
				switch (data & 3) {
				case 0 :
					return new MetadataToken (TokenType.Module, rid);
				case 1 :
					return new MetadataToken (TokenType.ModuleRef, rid);
				case 2 :
					return new MetadataToken (TokenType.AssemblyRef, rid);
				case 3 :
					return new MetadataToken (TokenType.TypeRef, rid);
				default :
					throw new MetadataFormatException("Non valid tag for ResolutionScope");
				}
			case CodedIndex.TypeOrMethodDef :
				rid = data >> 1;
				switch (data & 1) {
				case 0 :
					return new MetadataToken (TokenType.TypeDef, rid);
				case 1 :
					return new MetadataToken (TokenType.Method, rid);
				default :
					throw new MetadataFormatException("Non valid tag for TypeOrMethodDef");
				}
			default :
				throw new MetadataFormatException ("Non valid CodedIndex");
			}
		}

		public static uint CompressMetadataToken (CodedIndex cidx, MetadataToken token)
		{
			uint ret = 0;
			if (token.RID == 0)
				return ret;
			switch (cidx) {
			case CodedIndex.TypeDefOrRef :
				ret = token.RID << 2;
				switch (token.TokenType) {
				case TokenType.TypeDef :
					return ret | 0;
				case TokenType.TypeRef :
					return ret | 1;
				case TokenType.TypeSpec :
					return ret | 2;
				default :
					throw new MetadataFormatException("Non valid Token for TypeDefOrRef");
				}
			case CodedIndex.HasConstant :
				ret = token.RID << 2;
				switch (token.TokenType) {
				case TokenType.Field :
					return ret | 0;
				case TokenType.Param :
					return ret | 1;
				case TokenType.Property :
					return ret | 2;
				default :
					throw new MetadataFormatException("Non valid Token for HasConstant");
				}
			case CodedIndex.HasCustomAttribute :
				ret = token.RID << 5;
				switch (token.TokenType) {
				case TokenType.Method :
					return ret | 0;
				case TokenType.Field :
					return ret | 1;
				case TokenType.TypeRef :
					return ret | 2;
				case TokenType.TypeDef :
					return ret | 3;
				case TokenType.Param :
					return ret | 4;
				case TokenType.InterfaceImpl :
					return ret | 5;
				case TokenType.MemberRef :
					return ret | 6;
				case TokenType.Module :
					return ret | 7;
				case TokenType.Permission :
					return ret | 8;
				case TokenType.Property :
					return ret | 9;
				case TokenType.Event :
					return ret | 10;
				case TokenType.Signature :
					return ret | 11;
				case TokenType.ModuleRef :
					return ret | 12;
				case TokenType.TypeSpec :
					return ret | 13;
				case TokenType.Assembly :
					return ret | 14;
				case TokenType.AssemblyRef :
					return ret | 15;
				case TokenType.File :
					return ret | 16;
				case TokenType.ExportedType :
					return ret | 17;
				case TokenType.ManifestResource :
					return ret | 18;
				case TokenType.GenericParam :
					return ret | 19;
				default :
					throw new MetadataFormatException("Non valid Token for HasCustomAttribute");
				}
			case CodedIndex.HasFieldMarshal :
				ret = token.RID << 1;
				switch (token.TokenType) {
				case TokenType.Field :
					return ret | 0;
				case TokenType.Param :
					return ret | 1;
				default :
					throw new MetadataFormatException("Non valid Token for HasFieldMarshal");
				}
			case CodedIndex.HasDeclSecurity :
				ret = token.RID << 2;
				switch (token.TokenType) {
				case TokenType.TypeDef :
					return ret | 0;
				case TokenType.Method :
					return ret | 1;
				case TokenType.Assembly :
					return ret | 2;
				default :
					throw new MetadataFormatException("Non valid Token for HasDeclSecurity");
				}
			case CodedIndex.MemberRefParent :
				ret = token.RID << 3;
				switch (token.TokenType) {
				case TokenType.TypeDef :
					return ret | 0;
				case TokenType.TypeRef :
					return ret | 1;
				case TokenType.ModuleRef :
					return ret | 2;
				case TokenType.Method :
					return ret | 3;
				case TokenType.TypeSpec :
					return ret | 4;
				default :
					throw new MetadataFormatException("Non valid Token for MemberRefParent");
				}
			case CodedIndex.HasSemantics :
				ret = token.RID << 1;
				switch (token.TokenType) {
				case TokenType.Event :
					return ret | 0;
				case TokenType.Property :
					return ret | 1;
				default :
					throw new MetadataFormatException("Non valid Token for HasSemantics");
				}
			case CodedIndex.MethodDefOrRef :
				ret = token.RID << 1;
				switch (token.TokenType) {
				case TokenType.Method :
					return ret | 0;
				case TokenType.MemberRef :
					return ret | 1;
				default :
					throw new MetadataFormatException("Non valid Token for MethodDefOrRef");
				}
			case CodedIndex.MemberForwarded :
				ret = token.RID << 1;
				switch (token.TokenType) {
				case TokenType.Field :
					return ret | 0;
				case TokenType.Method :
					return ret | 1;
				default :
					throw new MetadataFormatException("Non valid Token for MemberForwarded");
				}
			case CodedIndex.Implementation :
				ret = token.RID << 2;
				switch (token.TokenType) {
				case TokenType.File :
					return ret | 0;
				case TokenType.AssemblyRef :
					return ret | 1;
				case TokenType.ExportedType :
					return ret | 2;
				default :
					throw new MetadataFormatException("Non valid Token for Implementation");
				}
			case CodedIndex.CustomAttributeType :
				ret = token.RID << 3;
				switch (token.TokenType) {
				case TokenType.Method :
					return ret | 2;
				case TokenType.MemberRef :
					return ret | 3;
				default :
					throw new MetadataFormatException("Non valid Token for CustomAttributeType");
				}
			case CodedIndex.ResolutionScope :
				ret = token.RID << 2;
				switch (token.TokenType) {
				case TokenType.Module :
					return ret | 0;
				case TokenType.ModuleRef :
					return ret | 1;
				case TokenType.AssemblyRef :
					return ret | 2;
				case TokenType.TypeRef :
					return ret | 3;
				default :
					throw new MetadataFormatException("Non valid Token for ResolutionScope");
				}
			case CodedIndex.TypeOrMethodDef :
				ret = token.RID << 1;
				switch (token.TokenType) {
				case TokenType.TypeDef :
					return ret | 0;
				case TokenType.Method :
					return ret | 1;
				default :
					throw new MetadataFormatException("Non valid Token for TypeOrMethodDef");
				}
			default :
				throw new MetadataFormatException ("Non valid CodedIndex");
			}
		}

		internal static Type GetCorrespondingTable (TokenType t)
		{
			switch (t) {
			case TokenType.Assembly :
				return typeof (AssemblyTable);
			case TokenType.AssemblyRef :
				return typeof (AssemblyRefTable);
			case TokenType.CustomAttribute :
				return typeof (CustomAttributeTable);
			case TokenType.Event :
				return typeof (EventTable);
			case TokenType.ExportedType :
				return typeof (ExportedTypeTable);
			case TokenType.Field :
				return typeof (FieldTable);
			case TokenType.File :
				return typeof (FileTable);
			case TokenType.InterfaceImpl :
				return typeof (InterfaceImplTable);
			case TokenType.MemberRef :
				return typeof (MemberRefTable);
			case TokenType.Method :
				return typeof (MethodTable);
			case TokenType.Module :
				return typeof (ModuleTable);
			case TokenType.ModuleRef :
				return typeof (ModuleRefTable);
			case TokenType.Param :
				return typeof (ParamTable);
			case TokenType.Permission :
				return typeof (DeclSecurityTable);
			case TokenType.Property :
				return typeof (PropertyTable);
			case TokenType.Signature :
				return typeof (StandAloneSigTable);
			case TokenType.TypeDef :
				return typeof (TypeDefTable);
			case TokenType.TypeRef :
				return typeof (TypeRefTable);
			case TokenType.TypeSpec :
				return typeof (TypeSpecTable);
			default :
				return null;
			}
		}

		internal delegate int TableRowCounter (int rid);

		internal static int GetCodedIndexSize (CodedIndex ci, TableRowCounter rowCounter, IDictionary codedIndexCache)
		{
			int bits = 0, max = 0;
			if (codedIndexCache [ci] != null)
				return (int) codedIndexCache [ci];

			int res = 0;
			int [] rids;
			switch (ci) {
			case CodedIndex.TypeDefOrRef :
				bits = 2;
				rids = new int [3];
				rids [0] = TypeDefTable.RId;
				rids [1] = TypeRefTable.RId;
				rids [2] = TypeSpecTable.RId;
				break;
			case CodedIndex.HasConstant :
				bits = 2;
				rids = new int [3];
				rids [0] = FieldTable.RId;
				rids [1] = ParamTable.RId;
				rids [2] = PropertyTable.RId;
				break;
			case CodedIndex.HasCustomAttribute :
				bits = 5;
				rids = new int [20];
				rids [0] = MethodTable.RId;
				rids [1] = FieldTable.RId;
				rids [2] = TypeRefTable.RId;
				rids [3] = TypeDefTable.RId;
				rids [4] = ParamTable.RId;
				rids [5] = InterfaceImplTable.RId;
				rids [6] = MemberRefTable.RId;
				rids [7] = ModuleTable.RId;
				rids [8] = DeclSecurityTable.RId;
				rids [9] = PropertyTable.RId;
				rids [10] = EventTable.RId;
				rids [11] = StandAloneSigTable.RId;
				rids [12] = ModuleRefTable.RId;
				rids [13] = TypeSpecTable.RId;
				rids [14] = AssemblyTable.RId;
				rids [15] = AssemblyRefTable.RId;
				rids [16] = FileTable.RId;
				rids [17] = ExportedTypeTable.RId;
				rids [18] = ManifestResourceTable.RId;
				rids [19] = GenericParamTable.RId;
				break;
			case CodedIndex.HasFieldMarshal :
				bits = 1;
				rids = new int [2];
				rids [0] = FieldTable.RId;
				rids [1] = ParamTable.RId;
				break;
			case CodedIndex.HasDeclSecurity :
				bits = 2;
				rids = new int [3];
				rids [0] = TypeDefTable.RId;
				rids [1] = MethodTable.RId;
				rids [2] = AssemblyTable.RId;
				break;
			case CodedIndex.MemberRefParent :
				bits = 3;
				rids = new int [5];
				rids [0] = TypeDefTable.RId;
				rids [1] = TypeRefTable.RId;
				rids [2] = ModuleRefTable.RId;
				rids [3] = MethodTable.RId;
				rids [4] = TypeSpecTable.RId;
				break;
			case CodedIndex.HasSemantics :
				bits = 1;
				rids = new int [2];
				rids [0] = EventTable.RId;
				rids [1] = PropertyTable.RId;
				break;
			case CodedIndex.MethodDefOrRef :
				bits = 1;
				rids = new int [2];
				rids [0] = MethodTable.RId;
				rids [1] = MemberRefTable.RId;
				break;
			case CodedIndex.MemberForwarded :
				bits = 1;
				rids = new int [2];
				rids [0] = FieldTable.RId;
				rids [1] = MethodTable.RId;
				break;
			case CodedIndex.Implementation :
				bits = 2;
				rids = new int [3];
				rids [0] = FileTable.RId;
				rids [1] = AssemblyRefTable.RId;
				rids [2] = ExportedTypeTable.RId;
				break;
			case CodedIndex.CustomAttributeType :
				bits = 3;
				rids = new int [2];
				rids [0] = MethodTable.RId;
				rids [1] = MemberRefTable.RId;
				break;
			case CodedIndex.ResolutionScope :
				bits = 2;
				rids = new int [4];
				rids [0] = ModuleTable.RId;
				rids [1] = ModuleRefTable.RId;
				rids [2] = AssemblyRefTable.RId;
				rids [3] = TypeRefTable.RId;
				break;
			case CodedIndex.TypeOrMethodDef :
				bits = 1;
				rids = new int [2];
				rids [0] = TypeDefTable.RId;
				rids [1] = MethodTable.RId;
				break;
			default :
				throw new MetadataFormatException ("Non valid CodedIndex");
			}

			for (int i = 0; i < rids.Length; i++) {
				int rows = rowCounter (rids [i]);
				if (rows > max) max = rows;
			}

			res = max < (1 << (16 - bits)) ? 2 : 4;
			codedIndexCache [ci] = res;
			return res;
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Signatures/Array.cs
================================================
//
// Array.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 - 2007 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Signatures {

	using Mono.Cecil.Metadata;

	internal sealed class ARRAY : SigType {

		public CustomMod [] CustomMods;
		public SigType Type;
		public ArrayShape Shape;

		public ARRAY () : base (ElementType.Array)
		{
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Signatures/ArrayShape.cs
================================================
//
// ArrayShape.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Signatures {

	internal sealed class ArrayShape {

		public int Rank;
		public int NumSizes;
		public int [] Sizes;
		public int NumLoBounds;
		public int [] LoBounds;

		public ArrayShape ()
		{
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Signatures/BaseSignatureVisitor.cs
================================================
//
// BaseSignatureVisitor.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Signatures {

	internal abstract class BaseSignatureVisitor : ISignatureVisitor {

		public virtual void VisitMethodDefSig (MethodDefSig methodDef)
		{
		}

		public virtual void VisitMethodRefSig (MethodRefSig methodRef)
		{
		}

		public virtual void VisitFieldSig (FieldSig field)
		{
		}

		public virtual void VisitPropertySig (PropertySig property)
		{
		}

		public virtual void VisitLocalVarSig (LocalVarSig localvar)
		{
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Signatures/Class.cs
================================================
//
// Class.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Signatures {

	using Mono.Cecil.Metadata;

	internal sealed class CLASS : SigType {

		public MetadataToken Type;

		public CLASS () : base (ElementType.Class)
		{
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Signatures/Constraint.cs
================================================
//
// Constraints.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Signatures {

	using Mono.Cecil.Metadata;

	internal enum Constraint : byte {
		None = 0x0,
		Pinned = (byte) ElementType.Pinned
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Signatures/CustomAttrib.cs
================================================
//
// CustomAttrib.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Signatures {

	using Mono.Cecil.Metadata;

	internal sealed class CustomAttrib {

		public const ushort StdProlog = 0x0001;

		public MethodReference Constructor;

		public ushort Prolog;
		public FixedArg [] FixedArgs;
		public ushort NumNamed;
		public NamedArg [] NamedArgs;
		public bool Read;

		public CustomAttrib (MethodReference ctor)
		{
			Constructor = ctor;
		}

		public struct FixedArg {

			public bool SzArray;
			public uint NumElem;
			public Elem [] Elems;
		}

		public struct Elem {

			public bool Simple;
			public bool String;
			public bool Type;
			public bool BoxedValueType;

			public ElementType FieldOrPropType;
			public object Value;

			public TypeReference ElemType;
		}

		public struct NamedArg {

			public bool Field;
			public bool Property;

			public ElementType FieldOrPropType;
			public string FieldOrPropName;
			public FixedArg FixedArg;
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Signatures/CustomMod.cs
================================================
//
// CustomMod.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Signatures {

	using Mono.Cecil.Metadata;

	internal sealed class CustomMod {

		public enum CMODType : byte {
			None = 0x0,
			OPT = (byte) ElementType.CModOpt,
			REQD = (byte) ElementType.CModReqD
		}

		public CMODType CMOD;
		public MetadataToken TypeDefOrRef;

		public CustomMod ()
		{
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Signatures/FieldSig.cs
================================================
//
// FieldSig.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Signatures {

	internal sealed class FieldSig : Signature {

		public bool Field;
		public CustomMod [] CustomMods;
		public SigType Type;

		public FieldSig () : base ()
		{
		}

		public FieldSig (uint blobIndex) : base (blobIndex)
		{
		}

		public override void Accept (ISignatureVisitor visitor)
		{
			visitor.VisitFieldSig (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Signatures/FnPtr.cs
================================================
//
// FnPtr.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Signatures {

	using Mono.Cecil.Metadata;

	internal sealed class FNPTR : SigType {

		public MethodSig Method;

		public FNPTR () : base (ElementType.FnPtr)
		{
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Signatures/GenericArg.cs
================================================
//
// GenericArg.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2006 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Signatures {

	class GenericArg {

		public CustomMod [] CustomMods;
		public SigType Type;

		public GenericArg (SigType type)
		{
			Type = type;
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Signatures/GenericInst.cs
================================================
//
// GenericInst.cs
//
// Author:
//	Martin Baulig  <baulig@ximian.com>
//  Jb Evain  <jbevain@gmail.com>
//
// Copyright (C) 2005 Novell, Inc (http://www.novell.com)
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Signatures {

	using Mono.Cecil;
	using Mono.Cecil.Metadata;

	internal sealed class GENERICINST : SigType {

		public bool ValueType;
		public MetadataToken Type;

		public GenericInstSignature Signature;

		public GENERICINST () : base (ElementType.GenericInst)
		{
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Signatures/GenericInstSignature.cs
================================================
//
// GenericInstSignature.cs
//
// Author:
//	Martin Baulig  <martin@ximian.com>
//
// Copyright (C) 2005 Novell, Inc (http://www.novell.com)
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Signatures {

	internal sealed class GenericInstSignature {

		public int Arity;
		public GenericArg [] Types;

		public GenericInstSignature ()
		{
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Signatures/ISignatureVisitable.cs
================================================
//
// ISignatureVisitable.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Signatures {

	internal interface ISignatureVisitable {

		void Accept (ISignatureVisitor visitor);
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Signatures/ISignatureVisitor.cs
================================================
//
// ISignatureVisitor.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Signatures {

	internal interface ISignatureVisitor {

		void VisitMethodDefSig (MethodDefSig methodDef);
		void VisitMethodRefSig (MethodRefSig methodRef);
		void VisitFieldSig (FieldSig field);
		void VisitPropertySig (PropertySig property);
		void VisitLocalVarSig (LocalVarSig localvar);
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Signatures/InputOutputItem.cs
================================================
//
// InputOutputItem.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Signatures {

	internal abstract class InputOutputItem {

		public CustomMod [] CustomMods;
		public bool ByRef;
		public SigType Type;
		public bool TypedByRef;
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Signatures/LocalVarSig.cs
================================================
//
// LocalVarSig.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Signatures {

	internal sealed class LocalVarSig : Signature {

		public bool Local;
		public int Count;
		public LocalVariable [] LocalVariables;

		public LocalVarSig () : base ()
		{
		}

		public LocalVarSig (uint blobIndex) : base (blobIndex)
		{
		}

		public override void Accept (ISignatureVisitor visitor)
		{
			visitor.VisitLocalVarSig (this);
		}

		public struct LocalVariable {

			public CustomMod [] CustomMods;
			public Constraint Constraint;
			public bool ByRef;
			public SigType Type;
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Signatures/MVar.cs
================================================
//
// MVar.cs
//
// Author:
//	Martin Baulig  <martin@ximian.com>
//
// Copyright (C) 2005 Novell, Inc (http://www.novell.com)
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Signatures {

	using Mono.Cecil.Metadata;

	internal sealed class MVAR : SigType {

		public int Index;

		public MVAR (int index) : base (ElementType.MVar)
		{
			this.Index = index;
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Signatures/MarshalSig.cs
================================================
//
// MarshalSig.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Signatures {

	using System;

	using Mono.Cecil;

	internal sealed class MarshalSig {

		public NativeType NativeInstrinsic;
		public IMarshalSigSpec Spec;

		public MarshalSig (NativeType nt)
		{
			this.NativeInstrinsic = nt;
		}

		public interface IMarshalSigSpec {
		}

		public sealed class Array : IMarshalSigSpec {

			public NativeType ArrayElemType;
			public int ParamNum;
			public int ElemMult;
			public int NumElem;

			public Array ()
			{
				this.ParamNum = 0;
				this.ElemMult = 0;
				this.NumElem = 0;
			}
		}

		public sealed class CustomMarshaler : IMarshalSigSpec {

			public string Guid;
			public string UnmanagedType;
			public string ManagedType;
			public string Cookie;
		}

		public sealed class FixedArray : IMarshalSigSpec {

			public int NumElem;
			public NativeType ArrayElemType;

			public FixedArray ()
			{
				this.NumElem = 0;
				this.ArrayElemType = NativeType.NONE;
			}
		}

		public sealed class SafeArray : IMarshalSigSpec {

			public VariantType ArrayElemType;
		}

		public sealed class FixedSysString : IMarshalSigSpec {

			public int Size;
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Signatures/MethodDefSig.cs
================================================
//
// MethodDefSig.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Signatures {

	internal sealed class MethodDefSig : MethodRefSig {

		public int GenericParameterCount;

		public MethodDefSig () : this (0)
		{
		}

		public MethodDefSig (uint blobIndex) : base (blobIndex)
		{
		}

		public override void Accept (ISignatureVisitor visitor)
		{
			visitor.VisitMethodDefSig (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Signatures/MethodRefSig.cs
================================================
//
// MethodRefSig.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Signatures {

	internal class MethodRefSig : MethodSig {

		public int Sentinel;

		public MethodRefSig () : this (0)
		{
		}

		public MethodRefSig (uint blobIndex) : base (blobIndex)
		{
			Sentinel = -1;
		}

		public override void Accept (ISignatureVisitor visitor)
		{
			visitor.VisitMethodRefSig (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Signatures/MethodSig.cs
================================================
//
// MethodSig.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

using Mono.Cecil;

namespace Mono.Cecil.Signatures {

	internal abstract class MethodSig : Signature {

		public bool HasThis;
		public bool ExplicitThis;
		public MethodCallingConvention MethCallConv;
		public int ParamCount;
		public RetType RetType;
		public Param [] Parameters;

		public MethodSig () : base ()
		{
		}

		public MethodSig (uint blobIndex) : base (blobIndex)
		{
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Signatures/MethodSpec.cs
================================================
//
// TypeSpec.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Signatures {

	internal sealed class MethodSpec {

		public GenericInstSignature Signature;

		public MethodSpec (GenericInstSignature sig)
		{
			this.Signature = sig;
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Signatures/Param.cs
================================================
//
// Param.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Signatures {

	internal sealed class Param : InputOutputItem {
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Signatures/PropertySig.cs
================================================
//
// PropertySig.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Signatures {

	internal sealed class PropertySig : Signature {

		public bool Property;
		public int ParamCount;
		public CustomMod [] CustomMods;
		public SigType Type;
		public Param [] Parameters;

		public PropertySig () : base ()
		{
		}

		public PropertySig (uint blobIndex) : base (blobIndex)
		{
		}

		public override void Accept (ISignatureVisitor visitor)
		{
			visitor.VisitPropertySig (this);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Signatures/Ptr.cs
================================================
//
// Ptr.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Signatures {

	using Mono.Cecil.Metadata;

	internal sealed class PTR : SigType {

		public CustomMod [] CustomMods;
		public SigType PtrType;
		public bool Void;

		public PTR () : base (ElementType.Ptr)
		{
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Signatures/RetType.cs
================================================
//
// RetType.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Signatures {

	internal sealed class RetType : InputOutputItem {

		public bool Void;

		public RetType ()
		{
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Signatures/SigType.cs
================================================
//
// SigType.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Signatures {

	using Mono.Cecil.Metadata;

	internal class SigType {

		public ElementType ElementType;

		public SigType (ElementType elem)
		{
			ElementType = elem;
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Signatures/Signature.cs
================================================
//
// Signature.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Signatures {

	using System;

	internal abstract class Signature : ISignatureVisitable {

		public byte CallingConvention;
		public uint BlobIndex;

		public Signature (uint blobIndex)
		{
			BlobIndex = blobIndex;
		}

		public Signature ()
		{
			BlobIndex = 0;
		}

		public abstract void Accept (ISignatureVisitor visitor);
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Signatures/SignatureReader.cs
================================================
//
// SignatureReader.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 - 2007 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Signatures {

	using System;
	using System.Collections;
	using System.IO;
	using System.Text;

	using Mono.Cecil;
	using Mono.Cecil.Metadata;

	internal sealed class SignatureReader : BaseSignatureVisitor {

		MetadataRoot m_root;
		ReflectionReader m_reflectReader;
		byte [] m_blobData;

		IDictionary m_signatures;

		IAssemblyResolver AssemblyResolver {
			get { return m_reflectReader.Module.Assembly.Resolver; }
		}

		public SignatureReader (MetadataRoot root, ReflectionReader reflectReader)
		{
			m_root = root;
			m_reflectReader = reflectReader;

			m_blobData = m_root.Streams.BlobHeap != null ? m_root.Streams.BlobHeap.Data : new byte [0];

			m_signatures = new Hashtable ();
		}

		public FieldSig GetFieldSig (uint index)
		{
			FieldSig f = m_signatures [index] as FieldSig;
			if (f == null) {
				f = new FieldSig (index);
				f.Accept (this);
				m_signatures [index] = f;
			}
			return f;
		}

		public PropertySig GetPropSig (uint index)
		{
			PropertySig p = m_signatures [index] as PropertySig;
			if (p == null) {
				p = new PropertySig (index);
				p.Accept (this);
				m_signatures [index] = p;
			}
			return p;
		}

		public MethodDefSig GetMethodDefSig (uint index)
		{
			MethodDefSig m = m_signatures [index] as MethodDefSig;
			if (m == null) {
				m = new MethodDefSig (index);
				m.Accept (this);
				m_signatures [index] = m;
			}
			return m;
		}

		public MethodRefSig GetMethodRefSig (uint index)
		{
			MethodRefSig m = m_signatures [index] as MethodRefSig;
			if (m == null) {
				m = new MethodRefSig (index);
				m.Accept (this);
				m_signatures [index] = m;
			}
			return m;
		}

		public TypeSpec GetTypeSpec (uint index)
		{
			TypeSpec ts = m_signatures [index] as TypeSpec;

			if (ts == null) {
				ts = ReadTypeSpec (m_blobData, (int) index);
				m_signatures [index] = ts;
			}

			return ts;
		}

		public MethodSpec GetMethodSpec (uint index)
		{
			MethodSpec ms = m_signatures [index] as MethodSpec;

			if (ms == null) {
				ms = ReadMethodSpec (m_blobData, (int) index);
				m_signatures [index] = ms;
			}

			return ms;
		}

		public LocalVarSig GetLocalVarSig (uint index)
		{
			LocalVarSig lv = m_signatures [index] as LocalVarSig;
			if (lv == null) {
				lv = new LocalVarSig (index);
				lv.Accept (this);
				m_signatures [index] = lv;
			}
			return lv;
		}

		public CustomAttrib GetCustomAttrib (uint index, MethodReference ctor)
		{
			return GetCustomAttrib (index, ctor, false);
		}

		public CustomAttrib GetCustomAttrib (uint index, MethodReference ctor, bool resolve)
		{
			return ReadCustomAttrib ((int) index, ctor, resolve);
		}

		public CustomAttrib GetCustomAttrib (byte [] data, MethodReference ctor)
		{
			return GetCustomAttrib (data, ctor, false);
		}

		public CustomAttrib GetCustomAttrib (byte [] data, MethodReference ctor, bool resolve)
		{
			BinaryReader br = new BinaryReader (new MemoryStream (data));
			return ReadCustomAttrib (br, data, ctor, resolve);
		}

		public Signature GetMemberRefSig (TokenType tt, uint index)
		{
			int start, callconv;
			Utilities.ReadCompressedInteger (m_blobData, (int) index, out start);
			callconv = m_blobData [start];
			if ((callconv & 0x6) != 0) // field ?
				return GetFieldSig (index);
			if ((callconv & 0x10) != 0) // generic ?
				return GetMethodDefSig (index);

			switch (tt) {
			case TokenType.TypeDef :
			case TokenType.TypeRef :
			case TokenType.TypeSpec :
				return GetMethodRefSig (index);
			case TokenType.ModuleRef :
			case TokenType.Method :
				return GetMethodDefSig (index);
			}
			return null;
		}

		public MarshalSig GetMarshalSig (uint index)
		{
			MarshalSig ms = m_signatures [index] as MarshalSig;
			if (ms == null) {
				byte [] data = m_root.Streams.BlobHeap.Read (index);
				ms = ReadMarshalSig (data);
				m_signatures [index] = ms;
			}
			return ms;
		}

		public MethodSig GetStandAloneMethodSig (uint index)
		{
			byte [] data = m_root.Streams.BlobHeap.Read (index);
			int start;
			if ((data [0] & 0x5) > 0) {
				MethodRefSig mrs = new MethodRefSig (index);
				ReadMethodRefSig (mrs, data, 0, out start);
				return mrs;
			} else {
				MethodDefSig mds = new MethodDefSig (index);
				ReadMethodDefSig (mds, data, 0, out start);
				return mds;
			}
		}

		public override void VisitMethodDefSig (MethodDefSig methodDef)
		{
			int start;
			ReadMethodDefSig (methodDef, m_root.Streams.BlobHeap.Read (methodDef.BlobIndex), 0, out start);
		}

		public override void VisitMethodRefSig (MethodRefSig methodRef)
		{
			int start;
			ReadMethodRefSig (methodRef, m_root.Streams.BlobHeap.Read (methodRef.BlobIndex), 0, out start);
		}

		public override void VisitFieldSig (FieldSig field)
		{
			int start;
			Utilities.ReadCompressedInteger (m_blobData, (int) field.BlobIndex, out start);
			field.CallingConvention = m_blobData [start];
			field.Field = (field.CallingConvention & 0x6) != 0;
			field.CustomMods = ReadCustomMods (m_blobData, start + 1, out start);
			field.Type = ReadType (m_blobData, start, out start);
		}

		public override void VisitPropertySig (PropertySig property)
		{
			int start;
			Utilities.ReadCompressedInteger (m_blobData, (int) property.BlobIndex, out start);
			property.CallingConvention = m_blobData [start];
			property.Property = (property.CallingConvention & 0x8) != 0;
			property.ParamCount = Utilities.ReadCompressedInteger (m_blobData, start + 1, out start);
			property.CustomMods = ReadCustomMods (m_blobData, start, out start);
			property.Type = ReadType (m_blobData, start, out start);
			property.Parameters = ReadParameters (property.ParamCount, m_blobData, start);
		}

		public override void VisitLocalVarSig (LocalVarSig localvar)
		{
			int start;
			Utilities.ReadCompressedInteger (m_blobData, (int) localvar.BlobIndex, out start);
			localvar.CallingConvention = m_blobData [start];
			localvar.Local = (localvar.CallingConvention & 0x7) != 0;
			localvar.Count = Utilities.ReadCompressedInteger (m_blobData, start + 1, out start);
			localvar.LocalVariables = ReadLocalVariables (localvar.Count, m_blobData, start);
		}

		void ReadMethodDefSig (MethodDefSig methodDef, byte [] data, int pos, out int start)
		{
			methodDef.CallingConvention = data [pos];
			start = pos + 1;
			methodDef.HasThis = (methodDef.CallingConvention & 0x20) != 0;
			methodDef.ExplicitThis = (methodDef.CallingConvention & 0x40) != 0;
			if ((methodDef.CallingConvention & 0x5) != 0)
				methodDef.MethCallConv |= MethodCallingConvention.VarArg;
			else if ((methodDef.CallingConvention & 0x10) != 0) {
				methodDef.MethCallConv |= MethodCallingConvention.Generic;
				methodDef.GenericParameterCount = Utilities.ReadCompressedInteger (data, start, out start);
			} else
				methodDef.MethCallConv |= MethodCallingConvention.Default;

			methodDef.ParamCount = Utilities.ReadCompressedInteger (data, start, out start);
			methodDef.RetType = ReadRetType (data, start, out start);
			methodDef.Parameters = ReadParameters (methodDef.ParamCount, data, start);
		}

		void ReadMethodRefSig (MethodRefSig methodRef, byte [] data, int pos, out int start)
		{
			methodRef.CallingConvention = data [pos];
			start = pos + 1;
			methodRef.HasThis = (methodRef.CallingConvention & 0x20) != 0;
			methodRef.ExplicitThis = (methodRef.CallingConvention & 0x40) != 0;
			if ((methodRef.CallingConvention & 0x1) != 0)
				methodRef.MethCallConv |= MethodCallingConvention.C;
			else if ((methodRef.CallingConvention & 0x2) != 0)
				methodRef.MethCallConv |= MethodCallingConvention.StdCall;
			else if ((methodRef.CallingConvention & 0x3) != 0)
				methodRef.MethCallConv |= MethodCallingConvention.ThisCall;
			else if ((methodRef.CallingConvention & 0x4) != 0)
				methodRef.MethCallConv |= MethodCallingConvention.FastCall;
			else if ((methodRef.CallingConvention & 0x5) != 0)
				methodRef.MethCallConv |= MethodCallingConvention.VarArg;
			else
				methodRef.MethCallConv |= MethodCallingConvention.Default;
			methodRef.ParamCount = Utilities.ReadCompressedInteger (data, start, out start);
			methodRef.RetType = ReadRetType (data, start, out start);
			int sentpos;
			methodRef.Parameters = ReadParameters (methodRef.ParamCount, data, start, out sentpos);
			methodRef.Sentinel = sentpos;
		}

		LocalVarSig.LocalVariable [] ReadLocalVariables (int length, byte [] data, int pos)
		{
			int start = pos;
			LocalVarSig.LocalVariable [] types = new LocalVarSig.LocalVariable [length];
			for (int i = 0; i < length; i++)
				types [i] = ReadLocalVariable (data, start, out start);
			return types;
		}

		LocalVarSig.LocalVariable ReadLocalVariable (byte [] data, int pos, out int start)
		{
			start = pos;
			LocalVarSig.LocalVariable lv = new LocalVarSig.LocalVariable ();
			lv.ByRef = false;
			int cursor;
			while (true) {
				lv.CustomMods = ReadCustomMods (data, start, out start);
				cursor = start;
				int current = Utilities.ReadCompressedInteger (data, start, out start);
				if (current == (int) ElementType.Pinned) // the only possible constraint
					lv.Constraint |= Constraint.Pinned;
				else if (current == (int) ElementType.ByRef) {
					lv.ByRef = true;

					if (lv.CustomMods == null || lv.CustomMods.Length == 0)
						lv.CustomMods = ReadCustomMods (data, start, out start);
				} else {
					lv.Type = ReadType (data, cursor, out start);
					break;
				}
			}
			return lv;
		}

		TypeSpec ReadTypeSpec (byte [] data, int pos)
		{
			int start = pos;
			Utilities.ReadCompressedInteger (data, start, out start);
			SigType t = ReadType (data, start, out start);
			return new TypeSpec (t);
		}

		MethodSpec ReadMethodSpec (byte [] data, int pos)
		{
			int start = pos;

			Utilities.ReadCompressedInteger (data, start, out start);
			if (Utilities.ReadCompressedInteger (data, start, out start) != 0x0a)
				throw new ReflectionException ("Invalid MethodSpec signature");

			return new MethodSpec (ReadGenericInstSignature (data, start, out start));
		}

		RetType ReadRetType (byte [] data, int pos, out int start)
		{
			RetType rt = new RetType ();
			start = pos;
			rt.CustomMods = ReadCustomMods (data, start, out start);
			int curs = start;
			ElementType flag = (ElementType) Utilities.ReadCompressedInteger (data, start, out start);
			switch (flag) {
			case ElementType.Void :
				rt.ByRef = rt.TypedByRef = false;
				rt.Void = true;
				break;
			case ElementType.TypedByRef :
				rt.ByRef = rt.Void = false;
				rt.TypedByRef = true;
				break;
			case ElementType.ByRef :
				rt.TypedByRef = rt.Void = false;
				rt.ByRef = true;

				if (rt.CustomMods == null || rt.CustomMods.Length == 0)
					rt.CustomMods = ReadCustomMods (data, start, out start);

				rt.Type = ReadType (data, start, out start);
				break;
			default :
				rt.TypedByRef = rt.Void = rt.ByRef = false;
				rt.Type = ReadType (data, curs, out start);
				break;
			}
			return rt;
		}

		Param [] ReadParameters (int length, byte [] data, int pos)
		{
			Param [] ret = new Param [length];
			int start = pos;
			for (int i = 0; i < length; i++)
				ret [i] = ReadParameter (data, start, out start);
			return ret;
		}

		Param [] ReadParameters (int length, byte [] data, int pos, out int sentinelpos)
		{
			Param [] ret = new Param [length];
			int start = pos;
			sentinelpos = -1;

			for (int i = 0; i < length; i++) {
				int curs = start;
				int flag = Utilities.ReadCompressedInteger (data, start, out start);

				if ((flag & (int) ElementType.Sentinel) != 0)
					sentinelpos = i;

				ret [i] = ReadParameter (data, curs, out start);
			}

			return ret;
		}

		Param ReadParameter (byte [] data, int pos, out int start)
		{
			Param p = new Param ();
			start = pos;

			p.CustomMods = ReadCustomMods (data, start, out start);
			int curs = start;
			ElementType flag = (ElementType) Utilities.ReadCompressedInteger (data, start, out start);
			switch (flag) {
			case ElementType.TypedByRef :
				p.TypedByRef = true;
				p.ByRef = false;
				break;
			case ElementType.ByRef :
				p.TypedByRef = false;
				p.ByRef = true;

				if (p.CustomMods == null || p.CustomMods.Length == 0)
					p.CustomMods = ReadCustomMods (data, start, out start);

				p.Type = ReadType (data, start, out start);
				break;
			default :
				p.TypedByRef = false;
				p.ByRef = false;
				p.Type = ReadType (data, curs, out start);
				break;
			}
			return p;
		}

		SigType ReadType (byte [] data, int pos, out int start)
		{
			start = pos;
			ElementType element = (ElementType) Utilities.ReadCompressedInteger (data, start, out start);
			switch (element) {
			case ElementType.ValueType :
				VALUETYPE vt = new VALUETYPE ();
				vt.Type = Utilities.GetMetadataToken(CodedIndex.TypeDefOrRef,
					(uint) Utilities.ReadCompressedInteger (data, start, out start));
				return vt;
			case ElementType.Class :
				CLASS c = new CLASS ();
				c.Type = Utilities.GetMetadataToken (CodedIndex.TypeDefOrRef,
					(uint) Utilities.ReadCompressedInteger (data, start, out start));
				return c;
			case ElementType.Ptr :
				PTR p = new PTR ();
				int buf = start;
				int flag = Utilities.ReadCompressedInteger (data, start, out start);
				p.Void = flag == (int) ElementType.Void;
				if (p.Void)
					return p;
				start = buf;
				p.CustomMods = ReadCustomMods (data, start, out start);
				p.PtrType = ReadType (data, start, out start);
				return p;
			case ElementType.FnPtr :
				FNPTR fp = new FNPTR ();
				if ((data [start] & 0x5) != 0) {
					MethodRefSig mr = new MethodRefSig ((uint) start);
					ReadMethodRefSig (mr, data, start, out start);
					fp.Method = mr;
				} else {
					MethodDefSig md = new MethodDefSig ((uint) start);
					ReadMethodDefSig (md, data, start, out start);
					fp.Method = md;
				}
				return fp;
			case ElementType.Array :
				ARRAY ary = new ARRAY ();
				ary.CustomMods = ReadCustomMods (data, start, out start);
				ArrayShape shape = new ArrayShape ();
				ary.Type = ReadType (data, start, out start);
				shape.Rank = Utilities.ReadCompressedInteger (data, start, out start);
				shape.NumSizes = Utilities.ReadCompressedInteger (data, start, out start);
				shape.Sizes = new int [shape.NumSizes];
				for (int i = 0; i < shape.NumSizes; i++)
					shape.Sizes [i] = Utilities.ReadCompressedInteger (data, start, out start);
				shape.NumLoBounds = Utilities.ReadCompressedInteger (data, start, out start);
				shape.LoBounds = new int [shape.NumLoBounds];
				for (int i = 0; i < shape.NumLoBounds; i++)
					shape.LoBounds [i] = Utilities.ReadCompressedInteger (data, start, out start);
				ary.Shape = shape;
				return ary;
			case ElementType.SzArray :
				SZARRAY sa = new SZARRAY ();
				sa.CustomMods = ReadCustomMods (data, start, out start);
				sa.Type = ReadType (data, start, out start);
				return sa;
			case ElementType.Var:
				return new VAR (Utilities.ReadCompressedInteger (data, start, out start));
			case ElementType.MVar:
				return new MVAR (Utilities.ReadCompressedInteger (data, start, out start));
			case ElementType.GenericInst:
				GENERICINST ginst = new GENERICINST ();

				ginst.ValueType = ((ElementType) Utilities.ReadCompressedInteger (
					data, start, out start)) == ElementType.ValueType;

				ginst.Type = Utilities.GetMetadataToken (CodedIndex.TypeDefOrRef,
					(uint) Utilities.ReadCompressedInteger (data, start, out start));

				ginst.Signature = ReadGenericInstSignature (data, start, out start);

				return ginst;
			default :
				return new SigType (element);
			}
		}

		GenericInstSignature ReadGenericInstSignature (byte [] data, int pos, out int start)
		{
			start = pos;
			GenericInstSignature gis = new GenericInstSignature ();
			gis.Arity = Utilities.ReadCompressedInteger (data, start, out start);
			gis.Types = new GenericArg [gis.Arity];
			for (int i = 0; i < gis.Arity; i++)
				gis.Types [i] = ReadGenericArg (data, start, out start);

			return gis;
		}

		GenericArg ReadGenericArg (byte[] data, int pos, out int start)
		{
			start = pos;
			CustomMod [] mods = ReadCustomMods (data, start, out start);
			GenericArg arg = new GenericArg (ReadType (data, start, out start));
			arg.CustomMods = mods;
			return arg;
		}

		CustomMod [] ReadCustomMods (byte [] data, int pos, out int start)
		{
			ArrayList cmods = new ArrayList ();
			start = pos;
			while (true) {
				int buf = start;
				ElementType flag = (ElementType) Utilities.ReadCompressedInteger (data, start, out start);
				start = buf;
				if (!((flag == ElementType.CModOpt) || (flag == ElementType.CModReqD)))
					break;
				cmods.Add (ReadCustomMod (data, start, out start));
			}
			return cmods.ToArray (typeof (CustomMod)) as CustomMod [];
		}

		CustomMod ReadCustomMod (byte [] data, int pos, out int start)
		{
			CustomMod cm = new CustomMod ();
			start = pos;
			ElementType cmod = (ElementType) Utilities.ReadCompressedInteger (data, start, out start);
			if (cmod == ElementType.CModOpt)
				cm.CMOD = CustomMod.CMODType.OPT;
			else if (cmod == ElementType.CModReqD)
				cm.CMOD = CustomMod.CMODType.REQD;
			else
				cm.CMOD = CustomMod.CMODType.None;
			cm.TypeDefOrRef = Utilities.GetMetadataToken (CodedIndex.TypeDefOrRef,
				(uint) Utilities.ReadCompressedInteger (data, start, out start));
			return cm;
		}

		CustomAttrib ReadCustomAttrib (int pos, MethodReference ctor, bool resolve)
		{
			int start, length = Utilities.ReadCompressedInteger (m_blobData, pos, out start);
			byte [] data = new byte [length];
			Buffer.BlockCopy (m_blobData, start, data, 0, length);
			try {
				return ReadCustomAttrib (new BinaryReader (
					new MemoryStream (data)), data, ctor, resolve);
			} catch {
				CustomAttrib ca = new CustomAttrib (ctor);
				ca.Read = false;
				return ca;
			}
		}

		CustomAttrib ReadCustomAttrib (BinaryReader br, byte [] data, MethodReference ctor, bool resolve)
		{
			CustomAttrib ca = new CustomAttrib (ctor);
			if (data.Length == 0) {
				ca.FixedArgs = new CustomAttrib.FixedArg [0];
				ca.NamedArgs = new CustomAttrib.NamedArg [0];
				return ca;
			}

			bool read = true;

			ca.Prolog = br.ReadUInt16 ();
			if (ca.Prolog != CustomAttrib.StdProlog)
				throw new MetadataFormatException ("Non standard prolog for custom attribute");

			ca.FixedArgs = new CustomAttrib.FixedArg [ctor.Parameters.Count];
			for (int i = 0; i < ca.FixedArgs.Length && read; i++)
				ca.FixedArgs [i] = ReadFixedArg (data, br,
					ctor.Parameters [i].ParameterType, ref read, resolve);

			if (br.BaseStream.Position == br.BaseStream.Length)
				read = false;

			if (!read) {
				ca.Read = read;
				return ca;
			}

			ca.NumNamed = br.ReadUInt16 ();
			ca.NamedArgs = new CustomAttrib.NamedArg [ca.NumNamed];
			for (int i = 0; i < ca.NumNamed && read; i++)
				ca.NamedArgs [i] = ReadNamedArg (data, br, ref read, resolve);

			ca.Read = read;
			return ca;
		}

		CustomAttrib.FixedArg ReadFixedArg (byte [] data, BinaryReader br,
			TypeReference param, ref bool read, bool resolve)
		{
			CustomAttrib.FixedArg fa = new CustomAttrib.FixedArg ();
			if (param is ArrayType) {
				param = ((ArrayType) param).ElementType;
				fa.SzArray = true;
				fa.NumElem = br.ReadUInt32 ();

				if (fa.NumElem == 0 || fa.NumElem == 0xffffffff) {
					fa.Elems = new CustomAttrib.Elem [0];
					fa.NumElem = 0;
					return fa;
				}

				fa.Elems = new CustomAttrib.Elem [fa.NumElem];
				for (int i = 0; i < fa.NumElem; i++)
					fa.Elems [i] = ReadElem (data, br, param, ref read, resolve);
			} else
				fa.Elems = new CustomAttrib.Elem [] { ReadElem (data, br, param, ref read, resolve) };

			return fa;
		}

		TypeReference CreateEnumTypeReference (string enumName)
		{
			string asmName = null;
			int asmStart = enumName.IndexOf (',');
			if (asmStart != -1) {
				asmName = enumName.Substring (asmStart + 1);
				enumName = enumName.Substring (0, asmStart);
			}
			// Inner class style is reflection style.
			enumName = enumName.Replace ('+', '/');
			AssemblyNameReference asm;
			if (asmName == null) {
				// If no assembly is given then the ECMA standard says the
				// assembly is either the current one or mscorlib.
				if (m_reflectReader.Module.Types.Contains (enumName))
					return m_reflectReader.Module.Types [enumName];

				asm = m_reflectReader.Corlib;
			} else
				asm = AssemblyNameReference.Parse (asmName);

			string [] outers = enumName.Split ('/');
			string outerfullname = outers [0];
			string ns = null;
			int nsIndex = outerfullname.LastIndexOf ('.');
			if (nsIndex != -1)
				ns = outerfullname.Substring (0, nsIndex);
			string name = outerfullname.Substring (nsIndex + 1);
			TypeReference decType = new TypeReference (name, ns, asm);
			for (int i = 1; i < outers.Length; i++) {
				TypeReference t = new TypeReference (outers [i], null, asm);
				t.DeclaringType = decType;
				decType = t;
			}
			decType.IsValueType = true;

			return decType;
		}

		TypeReference ReadTypeReference (byte [] data, BinaryReader br, out ElementType elemType)
		{
			bool array = false;
			elemType = (ElementType) br.ReadByte ();
			if (elemType == ElementType.SzArray) {
				elemType = (ElementType) br.ReadByte ();
				array = true;
			}

			TypeReference res;
			if (elemType == ElementType.Enum)
				res = CreateEnumTypeReference (ReadUTF8String (data, br));
			else
				res = TypeReferenceFromElemType (elemType);

			if (array)
				res = new ArrayType (res);

			return res;
		}

		TypeReference TypeReferenceFromElemType (ElementType elemType)
		{
			switch (elemType) {
			case ElementType.Boxed :
				return m_reflectReader.SearchCoreType (Constants.Object);
			case ElementType.String :
				return m_reflectReader.SearchCoreType (Constants.String);
			case ElementType.Type :
				return m_reflectReader.SearchCoreType (Constants.Type);
			case ElementType.Boolean :
				return m_reflectReader.SearchCoreType (Constants.Boolean);
			case ElementType.Char :
				return m_reflectReader.SearchCoreType (Constants.Char);
			case ElementType.R4 :
				return m_reflectReader.SearchCoreType (Constants.Single);
			case ElementType.R8 :
				return m_reflectReader.SearchCoreType (Constants.Double);
			case ElementType.I1 :
				return m_reflectReader.SearchCoreType (Constants.SByte);
			case ElementType.I2 :
				return m_reflectReader.SearchCoreType (Constants.Int16);
			case ElementType.I4 :
				return m_reflectReader.SearchCoreType (Constants.Int32);
			case ElementType.I8 :
				return m_reflectReader.SearchCoreType (Constants.Int64);
			case ElementType.U1 :
				return m_reflectReader.SearchCoreType (Constants.Byte);
			case ElementType.U2 :
				return m_reflectReader.SearchCoreType (Constants.UInt16);
			case ElementType.U4 :
				return m_reflectReader.SearchCoreType (Constants.UInt32);
			case ElementType.U8 :
				return m_reflectReader.SearchCoreType (Constants.UInt64);
			default :
				throw new MetadataFormatException ("Non valid type in CustomAttrib.Elem: 0x{0}",
					((byte) elemType).ToString("x2"));
			}
		}

		internal CustomAttrib.NamedArg ReadNamedArg (byte [] data, BinaryReader br, ref bool read, bool resolve)
		{
			CustomAttrib.NamedArg na = new CustomAttrib.NamedArg ();
			byte kind = br.ReadByte ();
			if (kind == 0x53) { // field
				na.Field = true;
				na.Property = false;
			} else if (kind == 0x54) { // property
				na.Field = false;
				na.Property = true;
			} else
				throw new MetadataFormatException ("Wrong kind of namedarg found: 0x" + kind.ToString("x2"));

			TypeReference elemType = ReadTypeReference (data, br, out na.FieldOrPropType);
			na.FieldOrPropName = ReadUTF8String (data, br);
			na.FixedArg = ReadFixedArg (data, br, elemType, ref read, resolve);

			return na;
		}

		CustomAttrib.Elem ReadElem (byte [] data, BinaryReader br, TypeReference elemType, ref bool read, bool resolve)
		{
			CustomAttrib.Elem elem = new CustomAttrib.Elem ();

			string elemName = elemType.FullName;

			if (elemName == Constants.Object) {
				elemType = ReadTypeReference (data, br, out elem.FieldOrPropType);
				if (elemType is ArrayType) {
					read = false; // Don't know how to represent arrays as an object value.
					return elem;
				} else if (elemType.FullName == Constants.Object)
					throw new MetadataFormatException ("Non valid type in CustomAttrib.Elem after boxed prefix: 0x{0}",
						((byte) elem.FieldOrPropType).ToString("x2"));

				elem = ReadElem (data, br, elemType, ref read, resolve);
				elem.String = elem.Simple = elem.Type = false;
				elem.BoxedValueType = true;
				return elem;
			}

			elem.ElemType = elemType;

			if (elemName == Constants.Type || elemName == Constants.String) {
				switch (elemType.FullName) {
				case Constants.String:
					elem.String = true;
					elem.BoxedValueType = elem.Simple = elem.Type = false;
					break;
				case Constants.Type:
					elem.Type = true;
					elem.BoxedValueType = elem.Simple = elem.String = false;
					break;
				}

				if (data [br.BaseStream.Position] == 0xff) { // null
					elem.Value = null;
					br.BaseStream.Position++;
				} else {
					elem.Value = ReadUTF8String (data, br);
				}
				return elem;
			}

			elem.String = elem.Type = elem.BoxedValueType = false;
			if (!ReadSimpleValue (br, ref elem, elem.ElemType)) {
				if (!resolve) { // until enums writing is implemented
					read = false;
					return elem;
				}
				TypeReference typeRef = GetEnumUnderlyingType (elem.ElemType, resolve);
				if (typeRef == null || !ReadSimpleValue (br, ref elem, typeRef))
					read = false;
			}

			return elem;
		}

		TypeReference GetEnumUnderlyingType (TypeReference enumType, bool resolve)
		{
			TypeDefinition type = enumType as TypeDefinition;
			if (type == null && resolve && AssemblyResolver != null) {
				if (enumType.Scope is ModuleDefinition)
					throw new NotSupportedException ();

				AssemblyDefinition asm = AssemblyResolver.Resolve (
					((AssemblyNameReference) enumType.Scope).FullName);
				type = asm.MainModule.Types [enumType.FullName];
			}

			if (type != null && type.IsEnum)
				return type.Fields.GetField ("value__").FieldType;

			return null;
		}

		bool ReadSimpleValue (BinaryReader br, ref CustomAttrib.Elem elem, TypeReference type)
		{
			switch (type.FullName) {
			case Constants.Boolean :
				elem.Value = br.ReadByte () == 1;
				break;
			case Constants.Char :
				elem.Value = (char) br.ReadUInt16 ();
				break;
			case Constants.Single :
				elem.Value = br.ReadSingle ();
				break;
			case Constants.Double :
				elem.Value = br.ReadDouble ();
				break;
			case Constants.Byte :
				elem.Value = br.ReadByte ();
				break;
			case Constants.Int16 :
				elem.Value = br.ReadInt16 ();
				break;
			case Constants.Int32 :
				elem.Value = br.ReadInt32 ();
				break;
			case Constants.Int64 :
				elem.Value = br.ReadInt64 ();
				break;
			case Constants.SByte :
				elem.Value = br.ReadSByte ();
				break;
			case Constants.UInt16 :
				elem.Value = br.ReadUInt16 ();
				break;
			case Constants.UInt32 :
				elem.Value = br.ReadUInt32 ();
				break;
			case Constants.UInt64 :
				elem.Value = br.ReadUInt64 ();
				break;
			default : // enum
				return false;
			}
			elem.Simple = true;
			return true;
		}

		MarshalSig ReadMarshalSig (byte [] data)
		{
			int start;
			MarshalSig ms = new MarshalSig ((NativeType) Utilities.ReadCompressedInteger (data, 0, out start));
			switch (ms.NativeInstrinsic) {
			case NativeType.ARRAY:
				MarshalSig.Array ar = new MarshalSig.Array ();
				ar.ArrayElemType = (NativeType) Utilities.ReadCompressedInteger (data, start, out start);
				if (start < data.Length)
					ar.ParamNum = Utilities.ReadCompressedInteger (data, start, out start);
				if (start < data.Length)
					ar.NumElem = Utilities.ReadCompressedInteger (data, start, out start);
				if (start < data.Length)
					ar.ElemMult = Utilities.ReadCompressedInteger (data, start, out start);
				ms.Spec = ar;
				break;
			case NativeType.CUSTOMMARSHALER:
				MarshalSig.CustomMarshaler cm = new MarshalSig.CustomMarshaler ();
				cm.Guid = ReadUTF8String (data, start, out start);
				cm.UnmanagedType = ReadUTF8String (data, start, out start);
				cm.ManagedType = ReadUTF8String (data, start, out start);
				cm.Cookie = ReadUTF8String (data, start, out start);
				ms.Spec = cm;
				break;
			case NativeType.FIXEDARRAY:
				MarshalSig.FixedArray fa = new MarshalSig.FixedArray ();
				fa.NumElem = Utilities.ReadCompressedInteger (data, start, out start);
				if (start < data.Length)
					fa.ArrayElemType = (NativeType) Utilities.ReadCompressedInteger (data, start, out start);
				ms.Spec = fa;
				break;
			case NativeType.SAFEARRAY:
				MarshalSig.SafeArray sa = new MarshalSig.SafeArray ();
				if (start < data.Length)
					sa.ArrayElemType = (VariantType) Utilities.ReadCompressedInteger (data, start, out start);
				ms.Spec = sa;
				break;
			case NativeType.FIXEDSYSSTRING:
				MarshalSig.FixedSysString fss = new MarshalSig.FixedSysString ();
				if (start < data.Length)
					fss.Size = Utilities.ReadCompressedInteger (data, start, out start);
				ms.Spec = fss;
				break;
			}
			return ms;
		}

		static internal string ReadUTF8String (byte [] data, BinaryReader br)
		{
			int start = (int)br.BaseStream.Position;
			string val = ReadUTF8String (data, start, out start);
			br.BaseStream.Position = start;
			return val;
		}

		static internal string ReadUTF8String (byte [] data, int pos, out int start)
		{
			int length = Utilities.ReadCompressedInteger (data, pos, out start);
			pos = start;
			start += length;
			// COMPACT FRAMEWORK NOTE: Encoding.GetString (byte[]) is not supported.
			return Encoding.UTF8.GetString (data, pos, length);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Signatures/SignatureWriter.cs
================================================
//
// SignatureWriter.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 - 2007 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Signatures {

	using System;
	using System.Text;

	using Mono.Cecil.Binary;
	using Mono.Cecil;
	using Mono.Cecil.Metadata;

	internal sealed class SignatureWriter : BaseSignatureVisitor {

		MetadataWriter m_mdWriter;
		MemoryBinaryWriter m_sigWriter;

		public SignatureWriter (MetadataWriter mdWriter)
		{
			m_mdWriter = mdWriter;
			m_sigWriter = new MemoryBinaryWriter ();
		}

		uint GetPointer ()
		{
			return m_mdWriter.AddBlob (m_sigWriter.ToArray ());
		}

		public uint AddMethodDefSig (MethodDefSig methSig)
		{
			return AddSignature (methSig);
		}

		public uint AddMethodRefSig (MethodRefSig methSig)
		{
			return AddSignature (methSig);
		}

		public uint AddPropertySig (PropertySig ps)
		{
			return AddSignature (ps);
		}

		public uint AddFieldSig (FieldSig fSig)
		{
			return AddSignature (fSig);
		}

		public uint AddLocalVarSig (LocalVarSig lvs)
		{
			return AddSignature (lvs);
		}

		uint AddSignature (Signature s)
		{
			m_sigWriter.Empty ();
			s.Accept (this);
			return GetPointer ();
		}

		public uint AddTypeSpec (TypeSpec ts)
		{
			m_sigWriter.Empty ();
			Write (ts);
			return GetPointer ();
		}

		public uint AddMethodSpec (MethodSpec ms)
		{
			m_sigWriter.Empty ();
			Write (ms);
			return GetPointer ();
		}

		public uint AddMarshalSig (MarshalSig ms)
		{
			m_sigWriter.Empty ();
			Write (ms);
			return GetPointer ();
		}

		public uint AddCustomAttribute (CustomAttrib ca, MethodReference ctor)
		{
			m_sigWriter.Empty ();
			CompressCustomAttribute (ca, ctor, m_sigWriter);
			return GetPointer ();
		}

		public byte [] CompressCustomAttribute (CustomAttrib ca, MethodReference ctor)
		{
			MemoryBinaryWriter writer = new MemoryBinaryWriter ();
			CompressCustomAttribute (ca, ctor, writer);
			return writer.ToArray ();
		}

		void CompressCustomAttribute (CustomAttrib ca, MethodReference ctor, MemoryBinaryWriter writer)
		{
			Write (ca, ctor, writer);
		}

		public override void VisitMethodDefSig (MethodDefSig methodDef)
		{
			m_sigWriter.Write (methodDef.CallingConvention);
			if (methodDef.GenericParameterCount > 0)
				Write (methodDef.GenericParameterCount);
			Write (methodDef.ParamCount);
			Write (methodDef.RetType);
			Write (methodDef.Parameters);
		}

		public override void VisitMethodRefSig (MethodRefSig methodRef)
		{
			m_sigWriter.Write (methodRef.CallingConvention);
			Write (methodRef.ParamCount);
			Write (methodRef.RetType);
			Write (methodRef.Parameters);
		}

		public override void VisitFieldSig (FieldSig field)
		{
			m_sigWriter.Write (field.CallingConvention);
			Write (field.CustomMods);
			Write (field.Type);
		}

		public override void VisitPropertySig (PropertySig property)
		{
			m_sigWriter.Write (property.CallingConvention);
			Write (property.ParamCount);
			Write (property.CustomMods);
			Write (property.Type);
			Write (property.Parameters);
		}

		public override void VisitLocalVarSig (LocalVarSig localvar)
		{
			m_sigWriter.Write (localvar.CallingConvention);
			Write (localvar.Count);
			Write (localvar.LocalVariables);
		}

		void Write (LocalVarSig.LocalVariable [] vars)
		{
			foreach (LocalVarSig.LocalVariable var in vars)
				Write (var);
		}

		void Write (LocalVarSig.LocalVariable var)
		{
			Write (var.CustomMods);
			if ((var.Constraint & Constraint.Pinned) != 0)
				Write (ElementType.Pinned);
			if (var.ByRef)
				Write (ElementType.ByRef);
			Write (var.Type);
		}

		void Write (RetType retType)
		{
			Write (retType.CustomMods);
			if (retType.Void)
				Write (ElementType.Void);
			else if (retType.TypedByRef)
				Write (ElementType.TypedByRef);
			else if (retType.ByRef) {
				Write (ElementType.ByRef);
				Write (retType.Type);
			} else
				Write (retType.Type);
		}

		void Write (Param [] parameters)
		{
			foreach (Param p in parameters)
				Write (p);
		}

		void Write (ElementType et)
		{
			Write ((int) et);
		}

		void Write (SigType t)
		{
			Write ((int) t.ElementType);

			switch (t.ElementType) {
			case ElementType.ValueType :
				Write ((int) Utilities.CompressMetadataToken (
						CodedIndex.TypeDefOrRef, ((VALUETYPE) t).Type));
				break;
			case ElementType.Class :
				Write ((int) Utilities.CompressMetadataToken (
						CodedIndex.TypeDefOrRef, ((CLASS) t).Type));
				break;
			case ElementType.Ptr :
				PTR p = (PTR) t;
				if (p.Void)
					Write (ElementType.Void);
				else {
					Write (p.CustomMods);
					Write (p.PtrType);
				}
				break;
			case ElementType.FnPtr :
				FNPTR fp = (FNPTR) t;
				if (fp.Method is MethodRefSig)
					(fp.Method as MethodRefSig).Accept (this);
				else
					(fp.Method as MethodDefSig).Accept (this);
				break;
			case ElementType.Array :
				ARRAY ary = (ARRAY) t;
				Write (ary.CustomMods);
				ArrayShape shape = ary.Shape;
				Write (ary.Type);
				Write (shape.Rank);
				Write (shape.NumSizes);
				foreach (int size in shape.Sizes)
					Write (size);
				Write (shape.NumLoBounds);
				foreach (int loBound in shape.LoBounds)
					Write (loBound);
				break;
			case ElementType.SzArray :
				SZARRAY sa = (SZARRAY) t;
				Write (sa.CustomMods);
				Write (sa.Type);
				break;
			case ElementType.Var :
				Write (((VAR) t).Index);
				break;
			case ElementType.MVar :
				Write (((MVAR) t).Index);
				break;
			case ElementType.GenericInst :
				GENERICINST gi = t as GENERICINST;
				Write (gi.ValueType ? ElementType.ValueType : ElementType.Class);
				Write ((int) Utilities.CompressMetadataToken (
						CodedIndex.TypeDefOrRef, gi.Type));
				Write (gi.Signature);
				break;
			}
		}

		void Write (TypeSpec ts)
		{
			Write (ts.Type);
		}

		void Write (MethodSpec ms)
		{
			Write (0x0a);
			Write (ms.Signature);
		}

		void Write (GenericInstSignature gis)
		{
			Write (gis.Arity);
			for (int i = 0; i < gis.Arity; i++)
				Write (gis.Types [i]);
		}

		void Write (GenericArg arg)
		{
			Write (arg.CustomMods);
			Write (arg.Type);
		}

		void Write (Param p)
		{
			Write (p.CustomMods);
			if (p.TypedByRef)
				Write (ElementType.TypedByRef);
			else if (p.ByRef) {
				Write (ElementType.ByRef);
				Write (p.Type);
			} else
				Write (p.Type);
		}

		void Write (CustomMod [] customMods)
		{
			foreach (CustomMod cm in customMods)
				Write (cm);
		}

		void Write (CustomMod cm)
		{
			switch (cm.CMOD) {
			case CustomMod.CMODType.OPT :
				Write (ElementType.CModOpt);
				break;
			case CustomMod.CMODType.REQD :
				Write (ElementType.CModReqD);
				break;
			}

			Write ((int) Utilities.CompressMetadataToken (
					CodedIndex.TypeDefOrRef, cm.TypeDefOrRef));
		}

		void Write (MarshalSig ms)
		{
			Write ((int) ms.NativeInstrinsic);
			switch (ms.NativeInstrinsic) {
			case NativeType.ARRAY :
				MarshalSig.Array ar = (MarshalSig.Array) ms.Spec;
				Write ((int) ar.ArrayElemType);
				if (ar.ParamNum != -1)
					Write (ar.ParamNum);
				if (ar.NumElem != -1)
					Write (ar.NumElem);
				if (ar.ElemMult != -1)
					Write (ar.ElemMult);
				break;
			case NativeType.CUSTOMMARSHALER :
				MarshalSig.CustomMarshaler cm = (MarshalSig.CustomMarshaler) ms.Spec;
				Write (cm.Guid);
				Write (cm.UnmanagedType);
				Write (cm.ManagedType);
				Write (cm.Cookie);
				break;
			case NativeType.FIXEDARRAY :
				MarshalSig.FixedArray fa = (MarshalSig.FixedArray) ms.Spec;
				Write (fa.NumElem);
				if (fa.ArrayElemType != NativeType.NONE)
					Write ((int) fa.ArrayElemType);
				break;
			case NativeType.SAFEARRAY :
				Write ((int) ((MarshalSig.SafeArray) ms.Spec).ArrayElemType);
				break;
			case NativeType.FIXEDSYSSTRING :
				Write (((MarshalSig.FixedSysString) ms.Spec).Size);
				break;
			}
		}

		void Write (CustomAttrib ca, MethodReference ctor, MemoryBinaryWriter writer)
		{
			if (ca == null)
				return;

			if (ca.Prolog != CustomAttrib.StdProlog)
				return;

			writer.Write (ca.Prolog);

			for (int i = 0; i < ctor.Parameters.Count; i++)
				Write (ca.FixedArgs [i], writer);

			writer.Write (ca.NumNamed);

			for (int i = 0; i < ca.NumNamed; i++)
				Write (ca.NamedArgs [i], writer);
		}

		void Write (CustomAttrib.FixedArg fa, MemoryBinaryWriter writer)
		{
			if (fa.SzArray)
				writer.Write (fa.NumElem);

			foreach (CustomAttrib.Elem elem in fa.Elems)
				Write (elem, writer);
		}

		void Write (CustomAttrib.NamedArg na, MemoryBinaryWriter writer)
		{
			if (na.Field)
				writer.Write ((byte) 0x53);
			else if (na.Property)
				writer.Write ((byte) 0x54);
			else
				throw new MetadataFormatException ("Unknown kind of namedarg");

			if (na.FixedArg.SzArray)
				writer.Write ((byte) ElementType.SzArray);

			writer.Write ((byte) na.FieldOrPropType);

			if (na.FieldOrPropType == ElementType.Enum)
				Write (na.FixedArg.Elems [0].ElemType.FullName);

			Write (na.FieldOrPropName);

			Write (na.FixedArg, writer);
		}

		void Write (CustomAttrib.Elem elem, MemoryBinaryWriter writer) // TODO
		{
			if (elem.String)
				elem.FieldOrPropType = ElementType.String;
			else if (elem.Type)
				elem.FieldOrPropType = ElementType.Type;
			else if (elem.BoxedValueType)
				Write (elem.FieldOrPropType);

			switch (elem.FieldOrPropType) {
			case ElementType.Boolean :
				writer.Write ((byte) ((bool) elem.Value ? 1 : 0));
				break;
			case ElementType.Char :
				writer.Write ((ushort) (char) elem.Value);
				break;
			case ElementType.R4 :
				writer.Write ((float) elem.Value);
				break;
			case ElementType.R8 :
				writer.Write ((double) elem.Value);
				break;
			case ElementType.I1 :
				writer.Write ((sbyte) elem.Value);
				break;
			case ElementType.I2 :
				writer.Write ((short) elem.Value);
				break;
			case ElementType.I4 :
				writer.Write ((int) elem.Value);
				break;
			case ElementType.I8 :
				writer.Write ((long) elem.Value);
				break;
			case ElementType.U1 :
				writer.Write ((byte) elem.Value);
				break;
			case ElementType.U2 :
				writer.Write ((ushort) elem.Value);
				break;
			case ElementType.U4 :
				writer.Write ((uint) elem.Value);
				break;
			case ElementType.U8 :
				writer.Write ((long) elem.Value);
				break;
			case ElementType.String :
				string s = elem.Value as string;
				if (s == null)
					writer.Write ((byte) 0xff);
				else if (s.Length == 0)
					writer.Write ((byte) 0x00);
				else
					Write (s);
				break;
			case ElementType.Type :
				string t = elem.Value as string;
				if (t == null || t.Length == 0)
					throw new NotSupportedException ("Null types not allowed in custom attributes");
				Write (t);
				break;
			case ElementType.Object :
				if (elem.Value != null)
					throw new NotSupportedException ("Unknown state");
				writer.Write ((byte) 0xff);
				break;
			default :
				throw new NotImplementedException ("WriteElem " + elem.FieldOrPropType.ToString ());
			}
		}

		void Write (string s)
		{
			byte [] str = Encoding.UTF8.GetBytes (s);
			Write (str.Length);
			m_sigWriter.Write (str);
		}

		void Write (int i)
		{
			Utilities.WriteCompressedInteger (m_sigWriter, i);
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Signatures/SzArray.cs
================================================
//
// SzArray.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 - 2007 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Signatures {

	using Mono.Cecil.Metadata;

	internal sealed class SZARRAY : SigType {

		public CustomMod [] CustomMods;
		public SigType Type;

		public SZARRAY () : base (ElementType.SzArray)
		{
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Signatures/TypeSpec.cs
================================================
//
// TypeSpec.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 - 2007 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Signatures {

	internal sealed class TypeSpec {

		public SigType Type;

		public TypeSpec (SigType type)
		{
			this.Type = type;
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Signatures/ValueType.cs
================================================
//
// ValueType.cs
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// (C) 2005 Jb Evain
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Signatures {

	using Mono.Cecil.Metadata;

	internal sealed class VALUETYPE : SigType {

		public MetadataToken Type;

		public VALUETYPE () : base (ElementType.ValueType)
		{
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Cecil.Signatures/Var.cs
================================================
//
// Var.cs
//
// Author:
//	Martin Baulig  <martin@ximian.com>
//
// Copyright (C) 2005 Novell, Inc (http://www.novell.com)
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Cecil.Signatures {

	using Mono.Cecil.Metadata;

	internal sealed class VAR : SigType {

		public int Index;

		public VAR (int index) : base (ElementType.Var)
		{
			this.Index = index;
		}
	}
}



================================================
File: DeConfuser/MonoCecil/Mono.Xml/MiniParser.cs
================================================
//
// System.Security.Cryptography.MiniParser: Internal XML parser implementation
//
// Authors:
//	Sergey Chaban
//
// Copyright (c) 2001, 2002 Wild West Software
// Copyright (c) 2002 Sergey Chaban
// Copyright (C) 2004 Novell, Inc (http://www.novell.com)
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

using System;
using System.Text;
using System.Collections;
using System.Globalization;

namespace Mono.Xml {

	internal class MiniParser {

		public interface IReader {
			int Read();
		}

		public interface IAttrList {
			int Length {get;}
			bool IsEmpty {get;}
			string GetName(int i);
			string GetValue(int i);
			string GetValue(string name);
			void ChangeValue(string name, string newValue);
			string[] Names {get;}
			string[] Values {get;}
		}

		public interface IMutableAttrList : IAttrList {
			void Clear();
			void Add(string name, string value);
			void CopyFrom(IAttrList attrs);
			void Remove(int i);
			void Remove(string name);
		}

		public interface IHandler {
			void OnStartParsing(MiniParser parser);
			void OnStartElement(string name, IAttrList attrs);
			void OnEndElement(string name);
			void OnChars(string ch);
			void OnEndParsing(MiniParser parser);
		}

		public class HandlerAdapter : IHandler {
			public HandlerAdapter() {}
			public void OnStartParsing(MiniParser parser) {}
			public void OnStartElement(string name, IAttrList attrs) {}
			public void OnEndElement(string name) {}
			public void OnChars(string ch) {}
			public void OnEndParsing(MiniParser parser) {}
		}

		private enum CharKind : byte {
			LEFT_BR     = 0,
			RIGHT_BR    = 1,
			SLASH       = 2,
			PI_MARK     = 3,
			EQ          = 4,
			AMP         = 5,
			SQUOTE      = 6,
			DQUOTE      = 7,
			BANG        = 8,
			LEFT_SQBR   = 9,
			SPACE       = 0xA,
			RIGHT_SQBR  = 0xB,
			TAB         = 0xC,
			CR          = 0xD,
			EOL         = 0xE,
			CHARS       = 0xF,
			UNKNOWN = 0x1F
		}

		private enum ActionCode : byte {
			START_ELEM               = 0,
			END_ELEM                 = 1,
			END_NAME                 = 2,
			SET_ATTR_NAME            = 3,
			SET_ATTR_VAL             = 4,
			SEND_CHARS               = 5,
			START_CDATA              = 6,
			END_CDATA                = 7,
			ERROR                    = 8,
			STATE_CHANGE             = 9,
			FLUSH_CHARS_STATE_CHANGE = 0xA,
			ACC_CHARS_STATE_CHANGE   = 0xB,
			ACC_CDATA                = 0xC,
			PROC_CHAR_REF            = 0xD,
			UNKNOWN = 0xF
		}

		public class AttrListImpl : IMutableAttrList {
			protected ArrayList names;
			protected ArrayList values;

			public AttrListImpl() : this(0) {}

			public AttrListImpl(int initialCapacity) {
				if (initialCapacity <= 0) {
					names = new ArrayList();
					values = new ArrayList();
				} else {
					names = new ArrayList(initialCapacity);
					values = new ArrayList(initialCapacity);
				}
			}

			public AttrListImpl(IAttrList attrs)
			: this(attrs != null ? attrs.Length : 0) {
				if (attrs != null) this.CopyFrom(attrs);
			}

			public int Length {
				get {return names.Count;}
			}

			public bool IsEmpty {
				get {return this.Length != 0;}
			}

			public string GetName(int i) {
				string res = null;
				if (i >= 0 && i < this.Length) {
					res = names[i] as string;
				}
				return res;
			}

			public string GetValue(int i) {
				string res = null;
				if (i >= 0 && i < this.Length) {
					res = values[i] as string;
				}
				return res;
			}

			public string GetValue(string name) {
				return this.GetValue(names.IndexOf(name));
			}

			public void ChangeValue(string name, string newValue) {
				int i = names.IndexOf(name);
				if (i >= 0 && i < this.Length) {
					values[i] = newValue;
				}
			}

			public string[] Names {
				get {return names.ToArray(typeof(string)) as string[];}
			}

			public string[] Values {
				get {return values.ToArray(typeof(string)) as string[];}
			}

			public void Clear() {
				names.Clear();
				values.Clear();
			}

			public void Add(string name, string value) {
				names.Add(name);
				values.Add(value);
			}

			public void Remove(int i) {
				if (i >= 0) {
					names.RemoveAt(i);
					values.RemoveAt(i);
				}
			}

			public void Remove(string name) {
				this.Remove(names.IndexOf(name));
			}

			public void CopyFrom(IAttrList attrs) {
				if (attrs != null && ((object)this == (object)attrs)) {
					this.Clear();
					int n = attrs.Length;
					for (int i = 0; i < n; i++) {
						this.Add(attrs.GetName(i), attrs.GetValue(i));
					}
				}
			}
		}

		public class XMLError : Exception {
			protected string descr;
			protected int line, column;
			public XMLError() : this("Unknown") {}
			public XMLError(string descr) : this(descr, -1, -1) {}
			public XMLError(string descr, int line, int column)
			: base(descr) {
				this.descr = descr;
				this.line = line;
				this.column = column;
			}
			public int Line {get {return line;}}
			public int Column {get {return column;}}
			public override string ToString() {
				return (String.Format("{0} @ (line = {1}, col = {2})", descr, line, column));
			}
		}

		private static readonly int INPUT_RANGE = 13;
		private static readonly ushort[] tbl = {
			(ushort)(((ushort)CharKind.LEFT_BR << 12) | ((ushort)ActionCode.STATE_CHANGE << 8) | 1), (ushort)(((ushort)CharKind.SPACE << 12) | ((ushort)ActionCode.STATE_CHANGE << 8) | 0), (ushort)(((ushort)CharKind.CHARS << 12) | ((ushort)ActionCode.ERROR << 8) | 128), (ushort)(((ushort)CharKind.SLASH << 12) | ((ushort)ActionCode.ERROR << 8) | 128), (ushort)(((ushort)CharKind.RIGHT_BR << 12) | ((ushort)ActionCode.ERROR << 8) | 128), (ushort)(((ushort)CharKind.PI_MARK << 12) | ((ushort)ActionCode.ERROR << 8) | 128), (ushort)(((ushort)CharKind.EQ << 12) | ((ushort)ActionCode.ERROR << 8) | 128), (ushort)(((ushort)CharKind.AMP << 12) | ((ushort)ActionCode.ERROR << 8) | 128), (ushort)(((ushort)CharKind.SQUOTE << 12) | ((ushort)ActionCode.ERROR << 8) | 128), (ushort)(((ushort)CharKind.BANG << 12) | ((ushort)ActionCode.ERROR << 8) | 128), (ushort)(((ushort)CharKind.LEFT_SQBR << 12) | ((ushort)ActionCode.ERROR << 8) | 128), (ushort)(((ushort)CharKind.RIGHT_SQBR << 12) | ((ushort)ActionCode.ERROR << 8) | 128), (ushort)(((ushort)CharKind.DQUOTE << 12) | ((ushort)ActionCode.ERROR << 8) | 128),
			(ushort)(((ushort)CharKind.LEFT_BR << 12) | ((ushort)ActionCode.ERROR << 8) | 129), (ushort)(((ushort)CharKind.SLASH << 12) | ((ushort)ActionCode.STATE_CHANGE << 8) | 2), (ushort)(((ushort)CharKind.RIGHT_BR << 12) | ((ushort)ActionCode.ERROR << 8) | 133), (ushort)(((ushort)CharKind.PI_MARK << 12) | ((ushort)ActionCode.STATE_CHANGE << 8) | 3), (ushort)(((ushort)CharKind.EQ << 12) | ((ushort)ActionCode.ERROR << 8) | 129), (ushort)(((ushort)CharKind.AMP << 12) | ((ushort)ActionCode.ERROR << 8) | 129), (ushort)(((ushort)CharKind.SQUOTE << 12) | ((ushort)ActionCode.ERROR << 8) | 129), (ushort)(((ushort)CharKind.BANG << 12) | ((ushort)ActionCode.STATE_CHANGE << 8) | 16), (ushort)(((ushort)CharKind.LEFT_SQBR << 12) | ((ushort)ActionCode.ERROR << 8) | 129), (ushort)(((ushort)CharKind.SPACE << 12) | ((ushort)ActionCode.ERROR << 8) | 129), (ushort)(((ushort)CharKind.RIGHT_SQBR << 12) | ((ushort)ActionCode.ERROR << 8) | 129), (ushort)(((ushort)CharKind.DQUOTE << 12) | ((ushort)ActionCode.ERROR << 8) | 129), (ushort)(((ushort)CharKind.CHARS << 12) | ((ushort)ActionCode.FLUSH_CHARS_STATE_CHANGE << 8) | 4),
			(ushort)(((ushort)CharKind.RIGHT_BR << 12) | ((ushort)ActionCode.END_ELEM << 8) | 0), (ushort)(((ushort)CharKind.SPACE << 12) | ((ushort)ActionCode.STATE_CHANGE << 8) | 2), (ushort)(((ushort)CharKind.CHARS << 12) | ((ushort)ActionCode.ACC_CHARS_STATE_CHANGE << 8) | 2), (ushort)(((ushort)CharKind.LEFT_BR << 12) | ((ushort)ActionCode.ERROR << 8) | 129), (ushort)(((ushort)CharKind.SLASH << 12) | ((ushort)ActionCode.ERROR << 8) | 129), (ushort)(((ushort)CharKind.PI_MARK << 12) | ((ushort)ActionCode.ERROR << 8) | 129), (ushort)(((ushort)CharKind.EQ << 12) | ((ushort)ActionCode.ERROR << 8) | 129), (ushort)(((ushort)CharKind.AMP << 12) | ((ushort)ActionCode.ERROR << 8) | 129), (ushort)(((ushort)CharKind.SQUOTE << 12) | ((ushort)ActionCode.ERROR << 8) | 129), (ushort)(((ushort)CharKind.BANG << 12) | ((ushort)ActionCode.ERROR << 8) | 129), (ushort)(((ushort)CharKind.LEFT_SQBR << 12) | ((ushort)ActionCode.ERROR << 8) | 129), (ushort)(((ushort)CharKind.RIGHT_SQBR << 12) | ((ushort)ActionCode.ERROR << 8) | 129), (ushort)(((ushort)CharKind.DQUOTE << 12) | ((ushort)ActionCode.ERROR << 8) | 129),
			(ushort)(((ushort)CharKind.PI_MARK << 12) | ((ushort)ActionCode.STATE_CHANGE << 8) | 5), (ushort)(((ushort)CharKind.LEFT_BR << 12) | ((ushort)ActionCode.STATE_CHANGE << 8) | 3), (ushort)(((ushort)CharKind.SLASH << 12) | ((ushort)ActionCode.STATE_CHANGE << 8) | 3), (ushort)(((ushort)CharKind.RIGHT_BR << 12) | ((ushort)ActionCode.STATE_CHANGE << 8) | 3), (ushort)(((ushort)CharKind.EQ << 12) | ((ushort)ActionCode.STATE_CHANGE << 8) | 3), (ushort)(((ushort)CharKind.AMP << 12) | ((ushort)ActionCode.STATE_CHANGE << 8) | 3), (ushort)(((ushort)CharKind.SQUOTE << 12) | ((ushort)ActionCode.STATE_CHANGE << 8) | 3), (ushort)(((ushort)CharKind.BANG << 12) | ((ushort)ActionCode.STATE_CHANGE << 8) | 3), (ushort)(((ushort)CharKind.LEFT_SQBR << 12) | ((ushort)ActionCode.STATE_CHANGE << 8) | 3), (ushort)(((ushort)CharKind.SPACE << 12) | ((ushort)ActionCode.STATE_CHANGE << 8) | 3), (ushort)(((ushort)CharKind.RIGHT_SQBR << 12) | ((ushort)ActionCode.STATE_CHANGE << 8) | 3), (ushort)(((ushort)CharKind.DQUOTE << 12) | ((ushort)ActionCode.STATE_CHANGE << 8) | 3), (ushort)(((ushort)CharKind.CHARS << 12) | ((ushort)ActionCode.STATE_CHANGE << 8) | 3),
			(ushort)(((ushort)CharKind.CHARS << 12) | ((ushort)ActionCode.ACC_CHARS_STATE_CHANGE << 8) | 4), (ushort)(((ushort)CharKind.SLASH << 12) | ((ushort)ActionCode.END_NAME << 8) | 6), (ushort)(((ushort)CharKind.RIGHT_BR << 12) | ((ushort)ActionCode.END_NAME << 8) | 7), (ushort)(((ushort)CharKind.SPACE << 12) | ((ushort)ActionCode.END_NAME << 8) | 8), (ushort)(((ushort)CharKind.LEFT_BR << 12) | ((ushort)ActionCode.ERROR << 8) | 129), (ushort)(((ushort)CharKind.PI_MARK << 12) | ((ushort)ActionCode.ERROR << 8) | 129), (ushort)(((ushort)CharKind.EQ << 12) | ((ushort)ActionCode.ERROR << 8) | 129), (ushort)(((ushort)CharKind.AMP << 12) | ((ushort)ActionCode.ERROR << 8) | 129), (ushort)(((ushort)CharKind.SQUOTE << 12) | ((ushort)ActionCode.ERROR << 8) | 129), (ushort)(((ushort)CharKind.BANG << 12) | ((ushort)ActionCode.ERROR << 8) | 129), (ushort)(((ushort)CharKind.LEFT_SQBR << 12) | ((ushort)ActionCode.ERROR << 8) | 129), (ushort)(((ushort)CharKind.RIGHT_SQBR << 12) | ((ushort)ActionCode.ERROR << 8) | 129), (ushort)(((ushort)CharKind.DQUOTE << 12) | ((ushort)ActionCode.ERROR << 8) | 129),
			(ushort)(((ushort)CharKind.RIGHT_BR << 12) | ((ushort)ActionCode.STATE_CHANGE << 8) | 0), (ushort)(((ushort)CharKind.LEFT_BR << 12) | ((ushort)ActionCode.STATE_CHANGE << 8) | 3), (ushort)(((ushort)CharKind.SLASH << 12) | ((ushort)ActionCode.STATE_CHANGE << 8) | 3), (ushort)(((ushort)CharKind.PI_MARK << 12) | ((ushort)ActionCode.STATE_CHANGE << 8) | 3), (ushort)(((ushort)CharKind.EQ << 12) | ((ushort)ActionCode.STATE_CHANGE << 8) | 3), (ushort)(((ushort)CharKind.AMP << 12) | ((ushort)ActionCode.STATE_CHANGE << 8) | 3), (ushort)(((ushort)CharKind.SQUOTE << 12) | ((ushort)ActionCode.STATE_CHANGE << 8) | 3), (ushort)(((ushort)CharKind.BANG << 12) | ((ushort)ActionCode.STATE_CHANGE << 8) | 3), (ushort)(((ushort)CharKind.LEFT_SQBR << 12) | ((ushort)ActionCode.STATE_CHANGE << 8) | 3), (ushort)(((ushort)CharKind.SPACE << 12) | ((ushort)ActionCode.STATE_CHANGE << 8) | 3), (ushort)(((ushort)CharKind.RIGHT_SQBR << 12) | ((ushort)ActionCode.STATE_CHANGE << 8) | 3), (ushort)(((ushort)CharKind.DQUOTE << 12) | ((ushort)ActionCode.STATE_CHANGE << 8) | 3), (ushort)(((ushort)CharKind.CHARS << 12) | ((ushort)ActionCode.STATE_CHANGE << 8) | 3),
			(ushort)(((ushort)CharKind.RIGHT_BR << 12) | ((ushort)ActionCode.STATE_CHANGE << 8) | 0), (ushort)(((ushort)CharKind.LEFT_BR << 12) | ((ushort)ActionCode.ERROR << 8) | 129), (ushort)(((ushort)CharKind.SLASH << 12) | ((ushort)ActionCode.ERROR << 8) | 129), (ushort)(((ushort)CharKind.PI_MARK << 12) | ((ushort)ActionCode.ERROR << 8) | 129), (ushort)(((ushort)CharKind.EQ << 12) | ((ushort)ActionCode.ERROR << 8) | 129), (ushort)(((ushort)CharKind.AMP << 12) | ((ushort)ActionCode.ERROR << 8) | 129), (ushort)(((ushort)CharKind.SQUOTE << 12) | ((ushort)ActionCode.ERROR << 8) | 129), (ushort)(((ushort)CharKind.BANG << 12) | ((ushort)ActionCode.ERROR << 8) | 129), (ushort)(((ushort)CharKind.LEFT_SQBR << 12) | ((ushort)ActionCode.ERROR << 8) | 129), (ushort)(((ushort)CharKind.SPACE << 12) | ((ushort)ActionCode.ERROR << 8) | 129), (ushort)(((ushort)CharKind.RIGHT_SQBR << 12) | ((ushort)ActionCode.ERROR << 8) | 129), (ushort)(((ushort)CharKind.DQUOTE << 12) | ((ushort)ActionCode.ERROR << 8) | 129), (ushort)(((ushort)CharKind.CHARS << 12) | ((ushort)ActionCode.ERROR << 8) | 129),
			(ushort)(((ushort)CharKind.LEFT_BR << 12) | ((ushort)ActionCode.FLUSH_CHARS_STATE_CHANGE << 8) | 1), (ushort)(((ushort)CharKind.AMP << 12) | ((ushort)ActionCode.PROC_CHAR_REF << 8) | 10), (ushort)(((ushort)CharKind.SLASH << 12) | ((ushort)ActionCode.ACC_CDATA << 8) | 10), (ushort)(((ushort)CharKind.RIGHT_BR << 12) | ((ushort)ActionCode.ACC_CDATA << 8) | 10), (ushort)(((ushort)CharKind.PI_MARK << 12) | ((ushort)ActionCode.ACC_CDATA << 8) | 10), (ushort)(((ushort)CharKind.EQ << 12) | ((ushort)ActionCode.ACC_CDATA << 8) | 10), (ushort)(((ushort)CharKind.SQUOTE << 12) | ((ushort)ActionCode.ACC_CDATA << 8) | 10), (ushort)(((ushort)CharKind.BANG << 12) | ((ushort)ActionCode.ACC_CDATA << 8) | 10), (ushort)(((ushort)CharKind.LEFT_SQBR << 12) | ((ushort)ActionCode.ACC_CDATA << 8) | 10), (ushort)(((ushort)CharKind.SPACE << 12) | ((ushort)ActionCode.ACC_CHARS_STATE_CHANGE << 8) | 7), (ushort)(((ushort)CharKind.RIGHT_SQBR << 12) | ((ushort)ActionCode.ACC_CDATA << 8) | 10), (ushort)(((ushort)CharKind.DQUOTE << 12) | ((ushort)ActionCode.ACC_CDATA << 8) | 10), (ushort)(((ushort)CharKind.CHARS << 12) | ((ushort)ActionCode.ACC_CDATA << 8) | 10),
			(ushort)(((ushort)CharKind.CHARS << 12) | ((ushort)ActionCode.ACC_CHARS_STATE_CHANGE << 8) | 9), (ushort)(((ushort)CharKind.SLASH << 12) | ((ushort)ActionCode.START_ELEM << 8) | 6), (ushort)(((ushort)CharKind.RIGHT_BR << 12) | ((ushort)ActionCode.START_ELEM << 8) | 7), (ushort)(((ushort)CharKind.SPACE << 12) | ((ushort)ActionCode.STATE_CHANGE << 8) | 8), (ushort)(((ushort)CharKind.LEFT_BR << 12) | ((ushort)ActionCode.ERROR << 8) | 129), (ushort)(((ushort)CharKind.PI_MARK << 12) | ((ushort)ActionCode.ERROR << 8) | 129), (ushort)(((ushort)CharKind.EQ << 12) | ((ushort)ActionCode.ERROR << 8) | 129), (ushort)(((ushort)CharKind.AMP << 12) | ((ushort)ActionCode.ERROR << 8) | 129), (ushort)(((ushort)CharKind.SQUOTE << 12) | ((ushort)ActionCode.ERROR << 8) | 129), (ushort)(((ushort)CharKind.BANG << 12) | ((ushort)ActionCode.ERROR << 8) | 129), (ushort)(((ushort)CharKind.LEFT_SQBR << 12) | ((ushort)ActionCode.ERROR << 8) | 129), (ushort)(((ushort)CharKind.RIGHT_SQBR << 12) | ((ushort)ActionCode.ERROR << 8) | 129), (ushort)(((ushort)CharKind.DQUOTE << 12) | ((ushort)ActionCode.ERROR << 8) | 129),
			(ushort)(((ushort)CharKind.CHARS << 12) | ((ushort)ActionCode.ACC_CHARS_STATE_CHANGE << 8) | 9), (ushort)(((ushort)CharKind.EQ << 12) | ((ushort)ActionCode.SET_ATTR_NAME << 8) | 11), (ushort)(((ushort)CharKind.SPACE << 12) | ((ushort)ActionCode.STATE_CHANGE << 8) | 12), (ushort)(((ushort)CharKind.LEFT_BR << 12) | ((ushort)ActionCode.ERROR << 8) | 130), (ushort)(((ushort)CharKind.SLASH << 12) | ((ushort)ActionCode.ERROR << 8) | 130), (ushort)(((ushort)CharKind.RIGHT_BR << 12) | ((ushort)ActionCode.ERROR << 8) | 130), (ushort)(((ushort)CharKind.PI_MARK << 12) | ((ushort)ActionCode.ERROR << 8) | 130), (ushort)(((ushort)CharKind.AMP << 12) | ((ushort)ActionCode.ERROR << 8) | 130), (ushort)(((ushort)CharKind.SQUOTE << 12) | ((ushort)ActionCode.ERROR << 8) | 130), (ushort)(((ushort)CharKind.BANG << 12) | ((ushort)ActionCode.ERROR << 8) | 130), (ushort)(((ushort)CharKind.LEFT_SQBR << 12) | ((ushort)ActionCode.ERROR << 8) | 130), (ushort)(((ushort)CharKind.RIGHT_SQBR << 12) | ((ushort)ActionCode.ERROR << 8) | 130), (ushort)(((ushort)CharKind.DQUOTE << 12) | ((ushort)ActionCode.ERROR << 8) | 130),
			(ushort)(((ushort)CharKind.LEFT_BR << 12) | ((ushort)ActionCode.STATE_CHANGE << 8) | 13), (ushort)(((ushort)CharKind.AMP << 12) | ((ushort)ActionCode.PROC_CHAR_REF << 8) | 10), (ushort)(((ushort)CharKind.SLASH << 12) | ((ushort)ActionCode.ACC_CDATA << 8) | 10), (ushort)(((ushort)CharKind.RIGHT_BR << 12) | ((ushort)ActionCode.ACC_CDATA << 8) | 10), (ushort)(((ushort)CharKind.PI_MARK << 12) | ((ushort)ActionCode.ACC_CDATA << 8) | 10), (ushort)(((ushort)CharKind.EQ << 12) | ((ushort)ActionCode.ACC_CDATA << 8) | 10), (ushort)(((ushort)CharKind.SQUOTE << 12) | ((ushort)ActionCode.ACC_CDATA << 8) | 10), (ushort)(((ushort)CharKind.BANG << 12) | ((ushort)ActionCode.ACC_CDATA << 8) | 10), (ushort)(((ushort)CharKind.LEFT_SQBR << 12) | ((ushort)ActionCode.ACC_CDATA << 8) | 10), (ushort)(((ushort)CharKind.SPACE << 12) | ((ushort)ActionCode.ACC_CDATA << 8) | 10), (ushort)(((ushort)CharKind.RIGHT_SQBR << 12) | ((ushort)ActionCode.ACC_CDATA << 8) | 10), (ushort)(((ushort)CharKind.DQUOTE << 12) | ((ushort)ActionCode.ACC_CDATA << 8) | 10), (ushort)(((ushort)CharKind.CHARS << 12) | ((ushort)ActionCode.ACC_CDATA << 8) | 10),
			(ushort)(((ushort)CharKind.SQUOTE << 12) | ((ushort)ActionCode.STATE_CHANGE << 8) | 14), (ushort)(((ushort)CharKind.DQUOTE << 12) | ((ushort)ActionCode.STATE_CHANGE << 8) | 15), (ushort)(((ushort)CharKind.SPACE << 12) | ((ushort)ActionCode.STATE_CHANGE << 8) | 11), (ushort)(((ushort)CharKind.LEFT_BR << 12) | ((ushort)ActionCode.ERROR << 8) | 132), (ushort)(((ushort)CharKind.SLASH << 12) | ((ushort)ActionCode.ERROR << 8) | 132), (ushort)(((ushort)CharKind.RIGHT_BR << 12) | ((ushort)ActionCode.ERROR << 8) | 132), (ushort)(((ushort)CharKind.PI_MARK << 12) | ((ushort)ActionCode.ERROR << 8) | 132), (ushort)(((ushort)CharKind.EQ << 12) | ((ushort)ActionCode.ERROR << 8) | 132), (ushort)(((ushort)CharKind.AMP << 12) | ((ushort)ActionCode.ERROR << 8) | 132), (ushort)(((ushort)CharKind.BANG << 12) | ((ushort)ActionCode.ERROR << 8) | 132), (ushort)(((ushort)CharKind.LEFT_SQBR << 12) | ((ushort)ActionCode.ERROR << 8) | 132), (ushort)(((ushort)CharKind.RIGHT_SQBR << 12) | ((ushort)ActionCode.ERROR << 8) | 132), (ushort)(((ushort)CharKind.CHARS << 12) | ((ushort)ActionCode.ERROR << 8) | 132),
			(ushort)(((ushort)CharKind.EQ << 12) | ((ushort)ActionCode.SET_ATTR_NAME << 8) | 11), (ushort)(((ushort)CharKind.SPACE << 12) | ((ushort)ActionCode.STATE_CHANGE << 8) | 12), (ushort)(((ushort)CharKind.LEFT_BR << 12) | ((ushort)ActionCode.ERROR << 8) | 130), (ushort)(((ushort)CharKind.SLASH << 12) | ((ushort)ActionCode.ERROR << 8) | 130), (ushort)(((ushort)CharKind.RIGHT_BR << 12) | ((ushort)ActionCode.ERROR << 8) | 130), (ushort)(((ushort)CharKind.PI_MARK << 12) | ((ushort)ActionCode.ERROR << 8) | 130), (ushort)(((ushort)CharKind.AMP << 12) | ((ushort)ActionCode.ERROR << 8) | 130), (ushort)(((ushort)CharKind.SQUOTE << 12) | ((ushort)ActionCode.ERROR << 8) | 130), (ushort)(((ushort)CharKind.BANG << 12) | ((ushort)ActionCode.ERROR << 8) | 130), (ushort)(((ushort)CharKind.LEFT_SQBR << 12) | ((ushort)ActionCode.ERROR << 8) | 130), (ushort)(((ushort)CharKind.RIGHT_SQBR << 12) | ((ushort)ActionCode.ERROR << 8) | 130), (ushort)(((ushort)CharKind.DQUOTE << 12) | ((ushort)ActionCode.ERROR << 8) | 130), (ushort)(((ushort)CharKind.CHARS << 12) | ((ushort)ActionCode.ERROR << 8) | 130),
			(ushort)(((ushort)CharKind.SLASH << 12) | ((ushort)ActionCode.SEND_CHARS << 8) | 2), (ushort)(((ushort)CharKind.BANG << 12) | ((ushort)ActionCode.STATE_CHANGE << 8) | 16), (ushort)(((ushort)CharKind.LEFT_BR << 12) | ((ushort)ActionCode.ERROR << 8) | 134), (ushort)(((ushort)CharKind.RIGHT_BR << 12) | ((ushort)ActionCode.ERROR << 8) | 134), (ushort)(((ushort)CharKind.PI_MARK << 12) | ((ushort)ActionCode.ERROR << 8) | 134), (ushort)(((ushort)CharKind.EQ << 12) | ((ushort)ActionCode.ERROR << 8) | 134), (ushort)(((ushort)CharKind.AMP << 12) | ((ushort)ActionCode.ERROR << 8) | 134), (ushort)(((ushort)CharKind.SQUOTE << 12) | ((ushort)ActionCode.ERROR << 8) | 134), (ushort)(((ushort)CharKind.LEFT_SQBR << 12) | ((ushort)ActionCode.ERROR << 8) | 134), (ushort)(((ushort)CharKind.SPACE << 12) | ((ushort)ActionCode.ERROR << 8) | 134), (ushort)(((ushort)CharKind.RIGHT_SQBR << 12) | ((ushort)ActionCode.ERROR << 8) | 134), (ushort)(((ushort)CharKind.DQUOTE << 12) | ((ushort)ActionCode.ERROR << 8) | 134), (ushort)(((ushort)CharKind.CHARS << 12) | ((ushort)ActionCode.ERROR << 8) | 134),
			(ushort)(((ushort)CharKind.SQUOTE << 12) | ((ushort)ActionCode.SET_ATTR_VAL << 8) | 17), (ushort)(((ushort)CharKind.AMP << 12) | ((ushort)ActionCode.PROC_CHAR_REF << 8) | 14), (ushort)(((ushort)CharKind.LEFT_BR << 12) | ((ushort)ActionCode.ACC_CHARS_STATE_CHANGE << 8) | 14), (ushort)(((ushort)CharKind.SLASH << 12) | ((ushort)ActionCode.ACC_CHARS_STATE_CHANGE << 8) | 14), (ushort)(((ushort)CharKind.RIGHT_BR << 12) | ((ushort)ActionCode.ACC_CHARS_STATE_CHANGE << 8) | 14), (ushort)(((ushort)CharKind.PI_MARK << 12) | ((ushort)ActionCode.ACC_CHARS_STATE_CHANGE << 8) | 14), (ushort)(((ushort)CharKind.EQ << 12) | ((ushort)ActionCode.ACC_CHARS_STATE_CHANGE << 8) | 14), (ushort)(((ushort)CharKind.BANG << 12) | ((ushort)ActionCode.ACC_CHARS_STATE_CHANGE << 8) | 14), (ushort)(((ushort)CharKind.LEFT_SQBR << 12) | ((ushort)ActionCode.ACC_CHARS_STATE_CHANGE << 8) | 14), (ushort)(((ushort)CharKind.SPACE << 12) | ((ushort)ActionCode.ACC_CHARS_STATE_CHANGE << 8) | 14), (ushort)(((ushort)CharKind.RIGHT_SQBR << 12) | ((ushort)ActionCode.ACC_CHARS_STATE_CHANGE << 8) | 14), (ushort)(((ushort)CharKind.DQUOTE << 12) | ((ushort)ActionCode.ACC_CHARS_STATE_CHANGE << 8) | 14), (ushort)(((ushort)CharKind.CHARS << 12) | ((ushort)ActionCode.ACC_CHARS_STATE_CHANGE << 8) | 14),
			(ushort)(((ushort)CharKind.DQUOTE << 12) | ((ushort)ActionCode.SET_ATTR_VAL << 8) | 17), (ushort)(((ushort)CharKind.AMP << 12) | ((ushort)ActionCode.PROC_CHAR_REF << 8) | 15), (ushort)(((ushort)CharKind.LEFT_BR << 12) | ((ushort)ActionCode.ACC_CHARS_STATE_CHANGE << 8) | 15), (ushort)(((ushort)CharKind.SLASH << 12) | ((ushort)ActionCode.ACC_CHARS_STATE_CHANGE << 8) | 15), (ushort)(((ushort)CharKind.RIGHT_BR << 12) | ((ushort)ActionCode.ACC_CHARS_STATE_CHANGE << 8) | 15), (ushort)(((ushort)CharKind.PI_MARK << 12) | ((ushort)ActionCode.ACC_CHARS_STATE_CHANGE << 8) | 15), (ushort)(((ushort)CharKind.EQ << 12) | ((ushort)ActionCode.ACC_CHARS_STATE_CHANGE << 8) | 15), (ushort)(((ushort)CharKind.SQUOTE << 12) | ((ushort)ActionCode.ACC_CHARS_STATE_CHANGE << 8) | 15), (ushort)(((ushort)CharKind.BANG << 12) | ((ushort)ActionCode.ACC_CHARS_STATE_CHANGE << 8) | 15), (ushort)(((ushort)CharKind.LEFT_SQBR << 12) | ((ushort)ActionCode.ACC_CHARS_STATE_CHANGE << 8) | 15), (ushort)(((ushort)CharKind.SPACE << 12) | ((ushort)ActionCode.ACC_CHARS_STATE_CHANGE << 8) | 15), (ushort)(((ushort)CharKind.RIGHT_SQBR << 12) | ((ushort)ActionCode.ACC_CHARS_STATE_CHANGE << 8) | 15), (ushort)(((ushort)CharKind.CHARS << 12) | ((ushort)ActionCode.ACC_CHARS_STATE_CHANGE << 8) | 15),
			(ushort)(((ushort)CharKind.LEFT_SQBR << 12) | ((ushort)ActionCode.START_CDATA << 8) | 18), (ushort)(((ushort)CharKind.RIGHT_BR << 12) | ((ushort)ActionCode.STATE_CHANGE << 8) | 0), (ushort)(((ushort)CharKind.LEFT_BR << 12) | ((ushort)ActionCode.START_CDATA << 8) | 19), (ushort)(((ushort)CharKind.SLASH << 12) | ((ushort)ActionCode.START_CDATA << 8) | 19), (ushort)(((ushort)CharKind.PI_MARK << 12) | ((ushort)ActionCode.START_CDATA << 8) | 19), (ushort)(((ushort)CharKind.EQ << 12) | ((ushort)ActionCode.START_CDATA << 8) | 19), (ushort)(((ushort)CharKind.AMP << 12) | ((ushort)ActionCode.START_CDATA << 8) | 19), (ushort)(((ushort)CharKind.SQUOTE << 12) | ((ushort)ActionCode.START_CDATA << 8) | 19), (ushort)(((ushort)CharKind.BANG << 12) | ((ushort)ActionCode.START_CDATA << 8) | 19), (ushort)(((ushort)CharKind.SPACE << 12) | ((ushort)ActionCode.START_CDATA << 8) | 19), (ushort)(((ushort)CharKind.RIGHT_SQBR << 12) | ((ushort)ActionCode.START_CDATA << 8) | 19), (ushort)(((ushort)CharKind.DQUOTE << 12) | ((ushort)ActionCode.START_CDATA << 8) | 19), (ushort)(((ushort)CharKind.CHARS << 12) | ((ushort)ActionCode.START_CDATA << 8) | 19),
			(ushort)(((ushort)CharKind.SLASH << 12) | ((ushort)ActionCode.START_ELEM << 8) | 6), (ushort)(((ushort)CharKind.RIGHT_BR << 12) | ((ushort)ActionCode.START_ELEM << 8) | 7), (ushort)(((ushort)CharKind.SPACE << 12) | ((ushort)ActionCode.STATE_CHANGE << 8) | 17), (ushort)(((ushort)CharKind.CHARS << 12) | ((ushort)ActionCode.ACC_CHARS_STATE_CHANGE << 8) | 9), (ushort)(((ushort)CharKind.LEFT_BR << 12) | ((ushort)ActionCode.ERROR << 8) | 129), (ushort)(((ushort)CharKind.PI_MARK << 12) | ((ushort)ActionCode.ERROR << 8) | 129), (ushort)(((ushort)CharKind.EQ << 12) | ((ushort)ActionCode.ERROR << 8) | 129), (ushort)(((ushort)CharKind.AMP << 12) | ((ushort)ActionCode.ERROR << 8) | 129), (ushort)(((ushort)CharKind.SQUOTE << 12) | ((ushort)ActionCode.ERROR << 8) | 129), (ushort)(((ushort)CharKind.BANG << 12) | ((ushort)ActionCode.ERROR << 8) | 129), (ushort)(((ushort)CharKind.LEFT_SQBR << 12) | ((ushort)ActionCode.ERROR << 8) | 129), (ushort)(((ushort)CharKind.RIGHT_SQBR << 12) | ((ushort)ActionCode.ERROR << 8) | 129), (ushort)(((ushort)CharKind.DQUOTE << 12) | ((ushort)ActionCode.ERROR << 8) | 129),
			(ushort)(((ushort)CharKind.RIGHT_SQBR << 12) | ((ushort)ActionCode.END_CDATA << 8) | 10), (ushort)(((ushort)CharKind.LEFT_BR << 12) | ((ushort)ActionCode.ACC_CDATA << 8) | 18), (ushort)(((ushort)CharKind.SLASH << 12) | ((ushort)ActionCode.ACC_CDATA << 8) | 18), (ushort)(((ushort)CharKind.RIGHT_BR << 12) | ((ushort)ActionCode.ACC_CDATA << 8) | 18), (ushort)(((ushort)CharKind.PI_MARK << 12) | ((ushort)ActionCode.ACC_CDATA << 8) | 18), (ushort)(((ushort)CharKind.EQ << 12) | ((ushort)ActionCode.ACC_CDATA << 8) | 18), (ushort)(((ushort)CharKind.AMP << 12) | ((ushort)ActionCode.ACC_CDATA << 8) | 18), (ushort)(((ushort)CharKind.SQUOTE << 12) | ((ushort)ActionCode.ACC_CDATA << 8) | 18), (ushort)(((ushort)CharKind.BANG << 12) | ((ushort)ActionCode.ACC_CDATA << 8) | 18), (ushort)(((ushort)CharKind.LEFT_SQBR << 12) | ((ushort)ActionCode.ACC_CDATA << 8) | 18), (ushort)(((ushort)CharKind.SPACE << 12) | ((ushort)ActionCode.ACC_CDATA << 8) | 18), (ushort)(((ushort)CharKind.DQUOTE << 12) | ((ushort)ActionCode.ACC_CDATA << 8) | 18), (ushort)(((ushort)CharKind.CHARS << 12) | ((ushort)ActionCode.ACC_CDATA << 8) | 18),
			(ushort)(((ushort)CharKind.LEFT_BR << 12) | ((ushort)ActionCode.ACC_CDATA << 8) | 19), (ushort)(((ushort)CharKind.SLASH << 12) | ((ushort)ActionCode.ACC_CDATA << 8) | 19), (ushort)(((ushort)CharKind.RIGHT_BR << 12) | ((ushort)ActionCode.ACC_CDATA << 8) | 19), (ushort)(((ushort)CharKind.PI_MARK << 12) | ((ushort)ActionCode.ACC_CDATA << 8) | 19), (ushort)(((ushort)CharKind.EQ << 12) | ((ushort)ActionCode.ACC_CDATA << 8) | 19), (ushort)(((ushort)CharKind.AMP << 12) | ((ushort)ActionCode.ACC_CDATA << 8) | 19), (ushort)(((ushort)CharKind.SQUOTE << 12) | ((ushort)ActionCode.ACC_CDATA << 8) | 19), (ushort)(((ushort)CharKind.BANG << 12) | ((ushort)ActionCode.ACC_CDATA << 8) | 19), (ushort)(((ushort)CharKind.LEFT_SQBR << 12) | ((ushort)ActionCode.ACC_CDATA << 8) | 19), (ushort)(((ushort)CharKind.SPACE << 12) | ((ushort)ActionCode.ACC_CDATA << 8) | 19), (ushort)(((ushort)CharKind.RIGHT_SQBR << 12) | ((ushort)ActionCode.ACC_CDATA << 8) | 19), (ushort)(((ushort)CharKind.DQUOTE << 12) | ((ushort)ActionCode.ACC_CDATA << 8) | 19), (ushort)(((ushort)CharKind.CHARS << 12) | ((ushort)ActionCode.ACC_CDATA << 8) | 19),
			(ushort)(((ushort)CharKind.CHARS << 12) | ((ushort)ActionCode.UNKNOWN << 8) | 255),
			0xFFFF
		};

		protected static string[] errors = {
			/* 0 */ "Expected element",
			/* 1 */ "Invalid character in tag",
			/* 2 */ "No '='",
			/* 3 */ "Invalid character entity",
			/* 4 */ "Invalid attr value",
			/* 5 */ "Empty tag",
			/* 6 */ "No end tag",
			/* 7 */ "Bad entity ref"
		};

		protected int line;
		protected int col;
		protected int[] twoCharBuff;
		protected bool splitCData;

		public MiniParser() {
			twoCharBuff = new int[2];
			splitCData = false;
			Reset();
		}

		public void Reset() {
			line = 0;
			col = 0;
		}

		protected static bool StrEquals(string str, StringBuilder sb, int sbStart, int len) {
			if (len != str.Length) return false;
			for (int i = 0; i < len; i++) {
				if (str[i] != sb[sbStart + i]) return false;
			}
			return true;
		}

		protected void FatalErr(string descr) {
			throw new XMLError(descr, this.line, this.col);
		}

		protected static int Xlat(int charCode, int state) {
			int p = state * INPUT_RANGE;
			int n = System.Math.Min(tbl.Length - p, INPUT_RANGE);
			for (;--n >= 0;) {
				ushort code = tbl[p];
				if (charCode == (code >> 12)) return (code & 0xFFF);
				p++;
			}
			return 0xFFF;
		}

		public void Parse(IReader reader, IHandler handler) {
			if (reader == null) throw new ArgumentNullException("reader");
			if (handler == null) handler = new HandlerAdapter();

			AttrListImpl attrList = new AttrListImpl();
			string lastAttrName = null;
			Stack tagStack = new Stack();
			string elementName = null;
			line = 1;
			col = 0;
			int currCh = 0;
			int stateCode = 0;
			StringBuilder sbChars = new StringBuilder();
			bool seenCData = false;
			bool isComment = false;
			bool isDTD = false;
			int bracketSwitch = 0;

			handler.OnStartParsing(this);

			while (true) {
				++this.col;

				currCh = reader.Read();

				if (currCh == -1) {
					if (stateCode != 0) {
						FatalErr("Unexpected EOF");
					}
					break;
				}

				int charCode = "<>/?=&'\"![ ]\t\r\n".IndexOf((char)currCh) & 0xF;
				if (charCode == (int)CharKind.CR) continue; // ignore
				// whitepace ::= (#x20 | #x9 | #xd | #xa)+
				if (charCode == (int)CharKind.TAB) charCode = (int)CharKind.SPACE; // tab == space
				if (charCode == (int)CharKind.EOL) {
					this.col = 0;
					this.line++;
					charCode = (int)CharKind.SPACE;
				}

				int actionCode = MiniParser.Xlat(charCode, stateCode);
				stateCode = actionCode & 0xFF;
				// Ignore newline inside attribute value.
				if (currCh == '\n' && (stateCode == 0xE || stateCode == 0xF)) continue;
				actionCode >>= 8;

				if (stateCode >= 0x80) {
					if (stateCode == 0xFF) {
						FatalErr("State dispatch error.");
					} else {
						FatalErr(errors[stateCode ^ 0x80]);
					}
				}

				switch (actionCode) {
				case (int)ActionCode.START_ELEM:
					handler.OnStartElement(elementName, attrList);
					if (currCh != '/') {
						tagStack.Push(elementName);
					} else {
						handler.OnEndElement(elementName);
					}
					attrList.Clear();
					break;

				case (int)ActionCode.END_ELEM:
					elementName = sbChars.ToString();
					sbChars = new StringBuilder();
					string endName = null;
					if (tagStack.Count == 0 ||
						elementName != (endName = tagStack.Pop() as string)) {
						if (endName == null) {
							FatalErr("Tag stack underflow");
						} else {
							FatalErr(String.Format("Expected end tag '{0}' but found '{1}'", elementName, endName));
						}
					}
					handler.OnEndElement(elementName);
					break;

				case (int)ActionCode.END_NAME:
					elementName = sbChars.ToString();
					sbChars = new StringBuilder();
					if (currCh != '/' && currCh != '>') break;
					goto case (int)ActionCode.START_ELEM;

				case (int)ActionCode.SET_ATTR_NAME:
					lastAttrName = sbChars.ToString();
					sbChars = new StringBuilder();
					break;

				case (int)ActionCode.SET_ATTR_VAL:
					if (lastAttrName == null) FatalErr("Internal error.");
					attrList.Add(lastAttrName, sbChars.ToString());
					sbChars = new StringBuilder();
					lastAttrName = null;
					break;

				case (int)ActionCode.SEND_CHARS:
					handler.OnChars(sbChars.ToString());
					sbChars = new StringBuilder();
					break;

				case (int)ActionCode.START_CDATA:
					string cdata = "CDATA[";
					isComment = false;
					isDTD = false;

					if (currCh == '-') {
						currCh = reader.Read();

						if (currCh != '-') FatalErr("Invalid comment");

						this.col++;
						isComment = true;
						twoCharBuff[0] = -1;
						twoCharBuff[1] = -1;
					} else {
						if (currCh != '[') {
							isDTD = true;
							bracketSwitch = 0;
							break;
						}

						for (int i = 0; i < cdata.Length; i++) {
							if (reader.Read() != cdata[i]) {
								this.col += i+1;
								break;
							}
						}
						this.col += cdata.Length;
						seenCData = true;
					}
					break;

				case (int)ActionCode.END_CDATA:
					int n = 0;
					currCh = ']';

					while (currCh == ']') {
						currCh = reader.Read();
						n++;
					}

					if (currCh != '>') {
						for (int i = 0; i < n; i++) sbChars.Append(']');
						sbChars.Append((char)currCh);
						stateCode = 0x12;
					} else {
						for (int i = 0; i < n-2; i++) sbChars.Append(']');
						seenCData = false;
					}

					this.col += n;
					break;

				case (int)ActionCode.ERROR:
					FatalErr(String.Format("Error {0}", stateCode));
					break;

				case (int)ActionCode.STATE_CHANGE:
					break;

				case (int)ActionCode.FLUSH_CHARS_STATE_CHANGE:
					sbChars = new StringBuilder();
					if (currCh != '<') goto case (int)ActionCode.ACC_CHARS_STATE_CHANGE;
					break;

				case (int)ActionCode.ACC_CHARS_STATE_CHANGE:
					sbChars.Append((char)currCh);
					break;

				case (int)ActionCode.ACC_CDATA:
					if (isComment) {
						if (currCh == '>'
							&& twoCharBuff[0] == '-'
							&& twoCharBuff[1] == '-') {
							isComment = false;
							stateCode = 0;
						} else {
							twoCharBuff[0] = twoCharBuff[1];
							twoCharBuff[1] = currCh;
						}
					} else if (isDTD) {
						if (currCh == '<' || currCh == '>') bracketSwitch ^= 1;
						if (currCh == '>' && bracketSwitch != 0) {
							isDTD = false;
							stateCode = 0;
						}
					} else {
						if (this.splitCData
							&& sbChars.Length > 0
							&& seenCData) {
							handler.OnChars(sbChars.ToString());
							sbChars = new StringBuilder();
						}
						seenCData = false;
						sbChars.Append((char)currCh);
					}
					break;

				case (int)ActionCode.PROC_CHAR_REF:
					currCh = reader.Read();
					int cl = this.col + 1;
					if (currCh == '#') {    // character reference
						int r = 10;
						int chCode = 0;
						int nDigits = 0;
						currCh = reader.Read();
						cl++;

						if (currCh == 'x') {
							currCh = reader.Read();
							cl++;
							r=16;
						}

						NumberStyles style = r == 16 ? NumberStyles.HexNumber : NumberStyles.Integer;

						while (true) {
							int x = -1;
							if (Char.IsNumber((char)currCh) || "abcdef".IndexOf(Char.ToLower((char)currCh)) != -1) {
								try {
									x = Int32.Parse(new string((char)currCh, 1), style);
								} catch (FormatException) {x = -1;}
							}
							if (x == -1) break;
							chCode *= r;
							chCode += x;
							nDigits++;
							currCh = reader.Read();
							cl++;
						}

						if (currCh == ';' && nDigits > 0) {
							sbChars.Append((char)chCode);
						} else {
							FatalErr("Bad char ref");
						}
					} else {
						// entity reference
						string entityRefChars = "aglmopqstu"; // amp | apos | quot | gt | lt
						string entities = "&'\"><";

						int pos = 0;
						int entIdx = 0xF;
						int predShift = 0;

						int sbLen = sbChars.Length;

						while (true) {
							if (pos != 0xF) pos = entityRefChars.IndexOf((char)currCh) & 0xF;
							if (pos == 0xF) FatalErr(errors[7]);
							sbChars.Append((char)currCh);

							int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F"[pos];
							int lBr = (path >> 4) & 0xF;
							int rBr = path & 0xF;
							int lPred = path >> 12;
							int rPred = (path >> 8) & 0xF;
							currCh = reader.Read();
							cl++;
							pos = 0xF;
							if (lBr != 0xF && currCh == entityRefChars[lBr]) {
								if (lPred < 0xE) entIdx = lPred;
//								pred = lPred;
								predShift = 12; // left
							} else if (rBr != 0xF && currCh == entityRefChars[rBr]) {
								if (rPred < 0xE) entIdx = rPred;
//								pred = rPred;
								predShift = 8; // right
							} else if (currCh == ';') {
								if (entIdx != 0xF
									&& predShift != 0
									&& ((path >> predShift) & 0xF) == 0xE) break;
								continue; // pos == 0xF
							}

							pos=0;

						}

						int l = cl - this.col - 1;

						if ((l > 0 && l < 5)
							&&(StrEquals("amp", sbChars, sbLen, l)
							|| StrEquals("apos", sbChars, sbLen, l)
							|| StrEquals("quot", sbChars, sbLen, l)
							|| StrEquals("lt", sbChars, sbLen, l)
							|| StrEquals("gt", sbChars, sbLen, l))
							) {
							sbChars.Length = sbLen;
							sbChars.Append(entities[entIdx]);
						} else FatalErr(errors[7]);
					}

					this.col = cl;
					break;

				default:
					FatalErr(String.Format("Unexpected action code - {0}.", actionCode));
					break;
				}
			} // while (true)

			handler.OnEndParsing(this);

		} // Parse

	}

}



================================================
File: DeConfuser/MonoCecil/Mono.Xml/SecurityParser.cs
================================================
//
// Mono.Xml.SecurityParser.cs class implementation
//
// Author:
//	Sebastien Pouliot (spouliot@motus.com)
//
// (C) 2003 Motus Technologies Inc. (http://www.motus.com)
//

//
// Copyright (C) 2004 Novell, Inc (http://www.novell.com)
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

using System;
using System.Collections;
using System.IO;
using System.Security;

namespace Mono.Xml {

	// convert an XML document into SecurityElement objects
	internal class SecurityParser : SmallXmlParser, SmallXmlParser.IContentHandler {

		private SecurityElement root;

		public SecurityParser () : base ()
		{
			stack = new Stack ();
		}

		public void LoadXml (string xml)
		{
			root = null;
#if CF_1_0
			stack = new Stack ();
#else
			stack.Clear ();
#endif
			Parse (new StringReader (xml), this);
		}

		public SecurityElement ToXml ()
		{
			return root;
		}

		// IContentHandler

		private SecurityElement current;
		private Stack stack;

		public void OnStartParsing (SmallXmlParser parser) {}

		public void OnProcessingInstruction (string name, string text) {}

		public void OnIgnorableWhitespace (string s) {}

		public void OnStartElement (string name, SmallXmlParser.IAttrList attrs)
		{
			SecurityElement newel = new SecurityElement (name);
			if (root == null) {
				root = newel;
				current = newel;
			}
			else {
				SecurityElement parent = (SecurityElement) stack.Peek ();
				parent.AddChild (newel);
			}
			stack.Push (newel);
			current = newel;
			// attributes
			int n = attrs.Length;
			for (int i=0; i < n; i++)
				current.AddAttribute (attrs.GetName (i), attrs.GetValue (i));
		}

		public void OnEndElement (string name)
		{
			current = (SecurityElement) stack.Pop ();
		}

		public void OnChars (string ch)
		{
			current.Text = ch;
		}

		public void OnEndParsing (SmallXmlParser parser) {}
	}
}




================================================
File: DeConfuser/MonoCecil/Mono.Xml/SmallXmlParser.cs
================================================
//
// SmallXmlParser.cs
//
// Author:
//	Atsushi Enomoto  <atsushi@ximian.com>
//
// Copyright (C) 2005 Novell, Inc (http://www.novell.com)
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

//
// small xml parser that is mostly compatible with
//

using System;
using System.Collections;
using System.Globalization;
using System.IO;
using System.Text;

namespace Mono.Xml
{
	internal class DefaultHandler : SmallXmlParser.IContentHandler
	{
		public void OnStartParsing (SmallXmlParser parser)
		{
		}

		public void OnEndParsing (SmallXmlParser parser)
		{
		}

		public void OnStartElement (string name, SmallXmlParser.IAttrList attrs)
		{
		}

		public void OnEndElement (string name)
		{
		}

		public void OnChars (string s)
		{
		}

		public void OnIgnorableWhitespace (string s)
		{
		}

		public void OnProcessingInstruction (string name, string text)
		{
		}
	}

	internal class SmallXmlParser
	{
		public interface IContentHandler
		{
			void OnStartParsing (SmallXmlParser parser);
			void OnEndParsing (SmallXmlParser parser);
			void OnStartElement (string name, IAttrList attrs);
			void OnEndElement (string name);
			void OnProcessingInstruction (string name, string text);
			void OnChars (string text);
			void OnIgnorableWhitespace (string text);
		}

		public interface IAttrList
		{
			int Length { get; }
			bool IsEmpty { get; }
			string GetName (int i);
			string GetValue (int i);
			string GetValue (string name);
			string [] Names { get; }
			string [] Values { get; }
		}

		class AttrListImpl : IAttrList
		{
			public int Length {
				get { return attrNames.Count; }
			}
			public bool IsEmpty {
				get { return attrNames.Count == 0; }
			}
			public string GetName (int i)
			{
				return (string) attrNames [i];
			}
			public string GetValue (int i)
			{
				return (string) attrValues [i];
			}
			public string GetValue (string name)
			{
				for (int i = 0; i < attrNames.Count; i++)
					if ((string) attrNames [i] == name)
						return (string) attrValues [i];
				return null;
			}
			public string [] Names {
				get { return (string []) attrNames.ToArray (typeof (string)); }
			}
			public string [] Values {
				get { return (string []) attrValues.ToArray (typeof (string)); }
			}

			ArrayList attrNames = new ArrayList ();
			ArrayList attrValues = new ArrayList ();

			internal void Clear ()
			{
				attrNames.Clear ();
				attrValues.Clear ();
			}

			internal void Add (string name, string value)
			{
				attrNames.Add (name);
				attrValues.Add (value);
			}
		}

		IContentHandler handler;
		TextReader reader;
		Stack elementNames = new Stack ();
		Stack xmlSpaces = new Stack ();
		string xmlSpace;
		StringBuilder buffer = new StringBuilder (200);
		char [] nameBuffer = new char [30];
		bool isWhitespace;

		AttrListImpl attributes = new AttrListImpl ();
		int line = 1, column;
		bool resetColumn;

		public SmallXmlParser ()
		{
		}

		private Exception Error (string msg)
		{
			return new SmallXmlParserException (msg, line, column);
		}

		private Exception UnexpectedEndError ()
		{
			string [] arr = new string [elementNames.Count];
			// COMPACT FRAMEWORK NOTE: CopyTo is not visible through the Stack class
			(elementNames as ICollection).CopyTo (arr, 0);
			return Error (String.Format (
							  "Unexpected end of stream. Element stack content is {0}", String.Join (",", arr)));
		}


		private bool IsNameChar (char c, bool start)
		{
			switch (c) {
			case ':':
			case '_':
				return true;
			case '-':
			case '.':
				return !start;
			}
			if (c > 0x100) { // optional condition for optimization
				switch (c) {
				case '\u0559':
				case '\u06E5':
				case '\u06E6':
					return true;
				}
				if ('\u02BB' <= c && c <= '\u02C1')
					return true;
			}
			switch (Char.GetUnicodeCategory (c)) {
			case UnicodeCategory.LowercaseLetter:
			case UnicodeCategory.UppercaseLetter:
			case UnicodeCategory.OtherLetter:
			case UnicodeCategory.TitlecaseLetter:
			case UnicodeCategory.LetterNumber:
				return true;
			case UnicodeCategory.SpacingCombiningMark:
			case UnicodeCategory.EnclosingMark:
			case UnicodeCategory.NonSpacingMark:
			case UnicodeCategory.ModifierLetter:
			case UnicodeCategory.DecimalDigitNumber:
				return !start;
			default:
				return false;
			}
		}

		private bool IsWhitespace (int c)
		{
			switch (c) {
			case ' ':
			case '\r':
			case '\t':
			case '\n':
				return true;
			default:
				return false;
			}
		}


		public void SkipWhitespaces ()
		{
			SkipWhitespaces (false);
		}

		private void HandleWhitespaces ()
		{
			while (IsWhitespace (Peek ()))
				buffer.Append ((char) Read ());
			if (Peek () != '<' && Peek () >= 0)
				isWhitespace = false;
		}

		public void SkipWhitespaces (bool expected)
		{
			while (true) {
				switch (Peek ()) {
				case ' ':
				case '\r':
				case '\t':
				case '\n':
					Read ();
					if (expected)
						expected = false;
					continue;
				}
				if (expected)
					throw Error ("Whitespace is expected.");
				return;
			}
		}


		private int Peek ()
		{
			return reader.Peek ();
		}

		private int Read ()
		{
			int i = reader.Read ();
			if (i == '\n')
				resetColumn = true;
			if (resetColumn) {
				line++;
				resetColumn = false;
				column = 1;
			}
			else
				column++;
			return i;
		}

		public void Expect (int c)
		{
			int p = Read ();
			if (p < 0)
				throw UnexpectedEndError ();
			else if (p != c)
				throw Error (String.Format ("Expected '{0}' but got {1}", (char) c, (char) p));
		}

		private string ReadUntil (char until, bool handleReferences)
		{
			while (true) {
				if (Peek () < 0)
					throw UnexpectedEndError ();
				char c = (char) Read ();
				if (c == until)
					break;
				else if (handleReferences && c == '&')
					ReadReference ();
				else
					buffer.Append (c);
			}
			string ret = buffer.ToString ();
			buffer.Length = 0;
			return ret;
		}

		public string ReadName ()
		{
			int idx = 0;
			if (Peek () < 0 || !IsNameChar ((char) Peek (), true))
				throw Error ("XML name start character is expected.");
			for (int i = Peek (); i >= 0; i = Peek ()) {
				char c = (char) i;
				if (!IsNameChar (c, false))
					break;
				if (idx == nameBuffer.Length) {
					char [] tmp = new char [idx * 2];
					// COMPACT FRAMEWORK NOTE: Array.Copy(sourceArray, destinationArray, count) is not available.
					Array.Copy (nameBuffer, 0, tmp, 0, idx);
					nameBuffer = tmp;
				}
				nameBuffer [idx++] = c;
				Read ();
			}
			if (idx == 0)
				throw Error ("Valid XML name is expected.");
			return new string (nameBuffer, 0, idx);
		}


		public void Parse (TextReader input, IContentHandler handler)
		{
			this.reader = input;
			this.handler = handler;

			handler.OnStartParsing (this);

			while (Peek () >= 0)
				ReadContent ();
			HandleBufferedContent ();
			if (elementNames.Count > 0)
				throw Error (String.Format ("Insufficient close tag: {0}", elementNames.Peek ()));

			handler.OnEndParsing (this);

			Cleanup ();
		}

		private void Cleanup ()
		{
			line = 1;
			column = 0;
			handler = null;
			reader = null;
#if CF_1_0
			elementNames = new Stack ();
			xmlSpaces = new Stack ();
#else
			elementNames.Clear ();
			xmlSpaces.Clear ();
#endif
			attributes.Clear ();
			buffer.Length = 0;
			xmlSpace = null;
			isWhitespace = false;
		}

		public void ReadContent ()
		{
			string name;
			if (IsWhitespace (Peek ())) {
				if (buffer.Length == 0)
					isWhitespace = true;
				HandleWhitespaces ();
			}
			if (Peek () == '<') {
				Read ();
				switch (Peek ()) {
				case '!': // declarations
					Read ();
					if (Peek () == '[') {
						Read ();
						if (ReadName () != "CDATA")
							throw Error ("Invalid declaration markup");
						Expect ('[');
						ReadCDATASection ();
						return;
					}
					else if (Peek () == '-') {
						ReadComment ();
						return;
					}
					else if (ReadName () != "DOCTYPE")
						throw Error ("Invalid declaration markup.");
					else
						throw Error ("This parser does not support document type.");
				case '?': // PIs
					HandleBufferedContent ();
					Read ();
					name = ReadName ();
					SkipWhitespaces ();
					string text = String.Empty;
					if (Peek () != '?') {
						while (true) {
							text += ReadUntil ('?', false);
							if (Peek () == '>')
								break;
							text += "?";
						}
					}
					handler.OnProcessingInstruction (
						name, text);
					Expect ('>');
					return;
				case '/': // end tags
					HandleBufferedContent ();
					if (elementNames.Count == 0)
						throw UnexpectedEndError ();
					Read ();
					name = ReadName ();
					SkipWhitespaces ();
					string expected = (string) elementNames.Pop ();
					xmlSpaces.Pop ();
					if (xmlSpaces.Count > 0)
						xmlSpace = (string) xmlSpaces.Peek ();
					else
						xmlSpace = null;
					if (name != expected)
						throw Error (String.Format ("End tag mismatch: expected {0} but found {1}", expected, name));
					handler.OnEndElement (name);
					Expect ('>');
					return;
				default: // start tags (including empty tags)
					HandleBufferedContent ();
					name = ReadName ();
					while (Peek () != '>' && Peek () != '/')
						ReadAttribute (attributes);
					handler.OnStartElement (name, attributes);
					attributes.Clear ();
					SkipWhitespaces ();
					if (Peek () == '/') {
						Read ();
						handler.OnEndElement (name);
					}
					else {
						elementNames.Push (name);
						xmlSpaces.Push (xmlSpace);
					}
					Expect ('>');
					return;
				}
			}
			else
				ReadCharacters ();
		}

		private void HandleBufferedContent ()
		{
			if (buffer.Length == 0)
				return;
			if (isWhitespace)
				handler.OnIgnorableWhitespace (buffer.ToString ());
			else
				handler.OnChars (buffer.ToString ());
			buffer.Length = 0;
			isWhitespace = false;
		}

		private void ReadCharacters ()
		{
			isWhitespace = false;
			while (true) {
				int i = Peek ();
				switch (i) {
				case -1:
					return;
				case '<':
					return;
				case '&':
					Read ();
					ReadReference ();
					continue;
				default:
					buffer.Append ((char) Read ());
					continue;
				}
			}
		}

		private void ReadReference ()
		{
			if (Peek () == '#') {
				// character reference
				Read ();
				ReadCharacterReference ();
			} else {
				string name = ReadName ();
				Expect (';');
				switch (name) {
				case "amp":
					buffer.Append ('&');
					break;
				case "quot":
					buffer.Append ('"');
					break;
				case "apos":
					buffer.Append ('\'');
					break;
				case "lt":
					buffer.Append ('<');
					break;
				case "gt":
					buffer.Append ('>');
					break;
				default:
					throw Error ("General non-predefined entity reference is not supported in this parser.");
				}
			}
		}

		private int ReadCharacterReference ()
		{
			int n = 0;
			if (Peek () == 'x') { // hex
				Read ();
				for (int i = Peek (); i >= 0; i = Peek ()) {
					if ('0' <= i && i <= '9')
						n = n << 4 + i - '0';
					else if ('A' <= i && i <='F')
						n = n << 4 + i - 'A' + 10;
					else if ('a' <= i && i <='f')
						n = n << 4 + i - 'a' + 10;
					else
						break;
					Read ();
				}
			} else {
				for (int i = Peek (); i >= 0; i = Peek ()) {
					if ('0' <= i && i <= '9')
						n = n << 4 + i - '0';
					else
						break;
					Read ();
				}
			}
			return n;
		}

		private void ReadAttribute (AttrListImpl a)
		{
			SkipWhitespaces (true);
			if (Peek () == '/' || Peek () == '>')
			// came here just to spend trailing whitespaces
				return;

			string name = ReadName ();
			string value;
			SkipWhitespaces ();
			Expect ('=');
			SkipWhitespaces ();
			switch (Read ()) {
			case '\'':
				value = ReadUntil ('\'', true);
				break;
			case '"':
				value = ReadUntil ('"', true);
				break;
			default:
				throw Error ("Invalid attribute value markup.");
			}
			if (name == "xml:space")
				xmlSpace = value;
			a.Add (name, value);
		}

		private void ReadCDATASection ()
		{
			int nBracket = 0;
			while (true) {
				if (Peek () < 0)
					throw UnexpectedEndError ();
				char c = (char) Read ();
				if (c == ']')
					nBracket++;
				else if (c == '>' && nBracket > 1) {
					for (int i = nBracket; i > 2; i--)
						buffer.Append (']');
					break;
				}
				else {
					for (int i = 0; i < nBracket; i++)
						buffer.Append (']');
					nBracket = 0;
					buffer.Append (c);
				}
			}
		}

		private void ReadComment ()
		{
			Expect ('-');
			Expect ('-');
			while (true) {
				if (Read () != '-')
					continue;
				if (Read () != '-')
					continue;
				if (Read () != '>')
					throw Error ("'--' is not allowed inside comment markup.");
				break;
			}
		}
	}

	internal class SmallXmlParserException : SystemException
	{
		int line;
		int column;

		public SmallXmlParserException (string msg, int line, int column)
		: base (String.Format ("{0}. At ({1},{2})", msg, line, column))
		{
			this.line = line;
			this.column = column;
		}

		public int Line {
			get { return line; }
		}

		public int Column {
			get { return column; }
		}
	}
}






================================================
File: DeConfuser/Properties/AssemblyInfo.cs
================================================
ï»¿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("DeConfuser")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Ingram")]
[assembly: AssemblyProduct("DeConfuser")]
[assembly: AssemblyCopyright("Copyright Â© Ingram 2012")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("0f446eeb-0615-4762-8dab-14f4d07cadd3")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]



================================================
File: DeConfuser/Removers/AntiDebug.cs
================================================
ï»¿/*
Copyright (C) 2012 DragonHunter

This file is part of DeConfuser.

DeConfuser is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

DeConfuser is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with DeConfuser. If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Text;
using Mono.Cecil.Cil;
using Mono.Cecil;

namespace DeConfuser.Removers
{
    public class AntiDebug
    {
        public OpCode[] Signature = new OpCode[]
        {
            OpCodes.Nop,
            OpCodes.Ldstr,
            OpCodes.Call,
            OpCodes.Brtrue_S,
            OpCodes.Ldstr,
            OpCodes.Call,
            OpCodes.Ldnull,
            OpCodes.Ceq,
            OpCodes.Br_S
        };

        public AntiDebug()
        {

        }

        public bool FindAntiDebug(AssemblyDefinition asm, ref TypeDefinition AntiType, ref MethodDefinition AntiMethod)
        {
            //lets scan the whole assembly for anti-debugging
            Console.WriteLine("[Anti-Debugger] Searching for Anti-Debugger");

            for (int i = 0; i < asm.MainModule.Types.Count; i++)
            {
                //well since Confuser only dumps his AntiDebug in <Module> we only check there
                if (asm.MainModule.Types[i].Name != "<Module>")
                    continue;

                foreach (MethodDefinition m in asm.MainModule.Types[i].Constructors)
                {
                    if (!m.HasBody)
                        continue;

                    //lets go through every CALL and see if it's our anti-debug
                    for (int x = 0; x < m.Body.Instructions.Count; x++)
                    {
                        if (m.Body.Instructions[x].OpCode.Code == Code.Call)
                        {
                            //lets check it out
                            if (m.Body.Instructions[x].Operand == null)
                                continue;

                            if (m.Body.Instructions[x].Operand.GetType() == typeof(MethodDefinition))
                            {
                                MethodDefinition method = (MethodDefinition)m.Body.Instructions[x].Operand;
                                if (method.HasBody)
                                {
                                    if (Program.ScanSignature(method, Signature))
                                    {
                                        AntiType = asm.MainModule.Types[i];
                                        AntiMethod = method;
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return false;
        }

        public void RemoveAntiDebug(AssemblyDefinition asm, TypeDefinition AntiType, MethodDefinition AntiMethod)
        {
            for (int i = 0; i < asm.MainModule.Types.Count; i++)
            {
                //well since Confuser only dumps his AntiDebug in <Module> we only check there
                if (asm.MainModule.Types[i].Name != "<Module>")
                    continue;

                foreach (MethodDefinition m in asm.MainModule.Types[i].Constructors)
                {
                    if (!m.HasBody)
                        continue;

                    for (int x = 0; x < m.Body.Instructions.Count; x++)
                    {
                        if (m.Body.Instructions[x].OpCode.Code == Code.Call)
                        {
                            if (m.Body.Instructions[x].Operand == AntiMethod)
                            {
                                m.Body.Instructions.Remove(m.Body.Instructions[x]);
                                x--;
                            }
                        }
                    }
                }
            }
            asm.MainModule.Types.Remove(AntiType);
        }
    }
}


================================================
File: DeConfuser/Removers/AntiDump.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Text;
using Mono.Cecil.Cil;
using Mono.Cecil;

namespace DeConfuser.Removers
{
    public class AntiDump
    {
        public OpCode[] Signature = new OpCode[]
        {
            OpCodes.Nop,
            OpCodes.Ldtoken,
            OpCodes.Call,
            OpCodes.Callvirt,
            OpCodes.Call,
            OpCodes.Call,
            OpCodes.Stloc_1,
            OpCodes.Ldloc_1,
            OpCodes.Ldc_I4_S,
            OpCodes.Conv_I,
            OpCodes.Add,
            OpCodes.Stloc_2,
            OpCodes.Ldloc_1,
            OpCodes.Ldloc_2,
            OpCodes.Ldind_U4,
            OpCodes.Add,
            OpCodes.Dup
        };

        public AntiDump()
        {

        }

        public bool FindAntiDump(AssemblyDefinition asm, ref TypeDefinition AntiType, ref MethodDefinition AntiMethod)
        {
            //lets scan the whole assembly for anti-debugging
            Console.WriteLine("[Anti-Dump] Searching for Anti-Dump");

            for (int i = 0; i < asm.MainModule.Types.Count; i++)
            {
                //well since Confuser only dumps his AntiDump in <Module> we only check there
                if (asm.MainModule.Types[i].Name != "<Module>")
                    continue;

                foreach (MethodDefinition m in asm.MainModule.Types[i].Constructors)
                {
                    if (!m.HasBody)
                        continue;

                    //lets go through every CALL and see if it's our anti-dump
                    for (int x = 0; x < m.Body.Instructions.Count; x++)
                    {
                        if (m.Body.Instructions[x].OpCode.Code == Code.Call)
                        {
                            //lets check it out
                            if (m.Body.Instructions[x].Operand == null)
                                continue;

                            if (m.Body.Instructions[x].Operand.GetType() == typeof(MethodDefinition))
                            {
                                MethodDefinition method = (MethodDefinition)m.Body.Instructions[x].Operand;
                                if (method.HasBody)
                                {
                                    if (Program.ScanSignature(method, Signature))
                                    {
                                        AntiType = asm.MainModule.Types[i];
                                        AntiMethod = method;
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return false;
        }

        public void RemoveAntiDump(AssemblyDefinition asm, TypeDefinition AntiType, MethodDefinition AntiMethod)
        {
            for (int i = 0; i < asm.MainModule.Types.Count; i++)
            {
                //well since Confuser only dumps his AntiDump in <Module> we only check there
                if (asm.MainModule.Types[i].Name != "<Module>")
                    continue;

                foreach (MethodDefinition m in asm.MainModule.Types[i].Constructors)
                {
                    if (!m.HasBody)
                        continue;

                    for (int x = 0; x < m.Body.Instructions.Count; x++)
                    {
                        if (m.Body.Instructions[x].OpCode.Code == Code.Call)
                        {
                            if (m.Body.Instructions[x].Operand == AntiMethod)
                            {
                                m.Body.Instructions.Remove(m.Body.Instructions[x]);
                                x--;
                            }
                        }
                    }
                }
            }
            asm.MainModule.Types.Remove(AntiType);
        }
    }
}


================================================
File: DeConfuser/Removers/ResourceDecrypter.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Text;
using Mono.Cecil;
using Mono.Cecil.Cil;
using System.IO.Compression;
using System.IO;

namespace DeConfuser.Removers
{
    public class ResourceDecrypter
    {
        public OpCode[] Signature = new OpCode[]
        {
            OpCodes.Nop,
            OpCodes.Call,
            OpCodes.Ldstr,
            OpCodes.Callvirt,
            OpCodes.Isinst,
            OpCodes.Dup,
            OpCodes.Stloc_0,
            OpCodes.Ldnull,
            OpCodes.Ceq,
            OpCodes.Ldc_I4_0,
            OpCodes.Ceq,
            OpCodes.Stloc_S,
        };

        public ResourceDecrypter()
        {
        }

        public bool FindMethod(AssemblyDefinition asm, ref TypeDefinition DecryptType, ref MethodDefinition DecryptMethod)
        {
            for (int i = 0; i < asm.MainModule.Types.Count; i++)
            {
                //well since Confuser only dumps his AntiDump in <Module> we only check there
                if (asm.MainModule.Types[i].Name != "<Module>")
                    continue;

                foreach (MethodDefinition m in asm.MainModule.Types[i].Constructors)
                {
                    if (!m.HasBody)
                        continue;

                    //lets go through every CALL and see if it's our anti-dump
                    for (int x = 0; x < m.Body.Instructions.Count; x++)
                    {
                        if (m.Body.Instructions[x].OpCode.Code == Code.Ldftn)
                        {
                            //lets check it out
                            if (m.Body.Instructions[x].Operand == null)
                                continue;

                            if (m.Body.Instructions[x].Operand.GetType() == typeof(MethodDefinition))
                            {
                                MethodDefinition method = (MethodDefinition)m.Body.Instructions[x].Operand;
                                if (method.HasBody)
                                {
                                    //lets scan signature
                                    if (Program.ScanSignature(method, Signature))
                                    {
                                        DecryptType = asm.MainModule.Types[i];
                                        DecryptMethod = method;
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return false;
        }

        public void DecryptAllResources(AssemblyDefinition asm, string FilePath, TypeDefinition type, MethodDefinition method)
        {
            string resourceName = "";
            int key = 0;
            if(!Program.ReadSigKey(method, new OpCode[] { OpCodes.Nop, OpCodes.Call }, ref resourceName))
            {
                Console.WriteLine("[Resource-Decrypter] Unable to get the resource name, Stopped decrypting resources");
                return;
            }

            //if we have 1 key... we have all 3 of them
            if(!Program.ReadSigKey(method, new OpCode[] {
                                                            OpCodes.Div,
                                                            OpCodes.Ldloc_3,
                                                            OpCodes.Ldloc_S,
                                                            OpCodes.Ldc_I4_1,
                                                            OpCodes.Add,
                                                            OpCodes.Ldelem_U1 }, ref key))
            {
                Console.WriteLine("[Resource-Decrypter] Unable to get the key, Stopped decrypting resources");
                return;
            }

            using (BinaryReader reader = new BinaryReader(new DeflateStream(System.Reflection.Assembly.LoadFile(FilePath).GetManifestResourceStream(resourceName), CompressionMode.Decompress)))
            {
                byte[] buffer = reader.ReadBytes(reader.ReadInt32());
                byte[] buffer2 = new byte[buffer.Length / 2];
                for (int i = 0; i < buffer.Length; i += 2)
                {
                    buffer2[i / 2] = (byte) (((buffer[i + 1] ^ key) * key) + (buffer[i] ^ key));
                }
                using (BinaryReader reader2 = new BinaryReader(new DeflateStream(new MemoryStream(buffer2), CompressionMode.Decompress)))
                {
                    //remove all the resources in the assembly we want to clean first
                    asm.MainModule.Resources.Clear();

                    AssemblyDefinition assembly = AssemblyFactory.GetAssembly(reader2.ReadBytes(reader2.ReadInt32()));
                    Console.WriteLine("[Resource-Decrypter] Decrypted the resources file");
                    foreach(Resource res in assembly.MainModule.Resources)
                    {
                        asm.MainModule.Resources.Add(res);
                        Console.WriteLine("[Resource-Decrypter] Injected resource \"" + res.Name + "\"");
                    }
                    Console.WriteLine("[Resource-Decrypter] Decrypted+Injected all resources");
                }
            }
            RemoveResourceStuff(asm, type, method);
            Console.WriteLine("[Resource-Decrypter] Removed Resources methods");
        }


        public void RemoveResourceStuff(AssemblyDefinition asm, TypeDefinition ResourceType, MethodDefinition ResourceMethod)
        {
            for (int i = 0; i < asm.MainModule.Types.Count; i++)
            {
                //well since Confuser only dumps his AntiDump in <Module> we only check there
                if (asm.MainModule.Types[i].Name != "<Module>")
                    continue;

                foreach (MethodDefinition m in asm.MainModule.Types[i].Constructors)
                {
                    if (!m.HasBody)
                        continue;

                    for (int x = 0; x < m.Body.Instructions.Count; x++)
                    {
                        if (m.Body.Instructions[x].OpCode.Code == Code.Call)
                        {
                            if(m.Body.Instructions[x].Operand == null)
                                continue;

                            Type adsa = m.Body.Instructions[x].Operand.GetType();
                            if(m.Body.Instructions[x].Operand.GetType() == typeof(MethodReference))
                            {
                                if(((MethodReference)m.Body.Instructions[x].Operand).Name.ToLower().Contains("get_currentdomain"))
                                {
                                    //ok lets now clean up the mess in the static constructor of <Module>
                                    m.Body.Instructions.Remove(m.Body.Instructions[x]);
                                    m.Body.Instructions.Remove(m.Body.Instructions[x].Next);
                                    m.Body.Instructions.Remove(m.Body.Instructions[x].Next.Next);
                                    m.Body.Instructions.Remove(m.Body.Instructions[x].Next.Next.Next);
                                    m.Body.Instructions.Remove(m.Body.Instructions[x].Next.Next.Next.Next);
                                }
                            }
                        }
                    }
                }
            }
            asm.MainModule.Types.Remove(ResourceType);
        }
    }
}


================================================
File: DeConfuser/Removers/StringDecrypter.cs
================================================
ï»¿/*
Copyright (C) 2012 DragonHunter

This file is part of DeConfuser.

DeConfuser is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

DeConfuser is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with DeConfuser. If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Text;
using Mono.Cecil;
using Mono.Cecil.Cil;
using System.IO;
using System.IO.Compression;
using System.Diagnostics;
using Mono.Cecil.Metadata;

namespace DeConfuser.Removers
{
    public class StringDecrypter
    {
        public OpCode[] Signature = new OpCode[]
        {
            OpCodes.Nop,
            OpCodes.Call,
            OpCodes.Ldstr,
            OpCodes.Callvirt,
            OpCodes.Isinst,
            OpCodes.Dup,
            OpCodes.Stloc_0,
            OpCodes.Ldnull,
            OpCodes.Ceq,

        };

        public StringDecrypter()
        {

        }

        public bool FindMethod(AssemblyDefinition asm, ref TypeDefinition DecryptType, ref MethodDefinition DecryptMethod)
        {
            foreach(ModuleDefinition module in asm.Modules)
            {
                for (int i = 0; i < module.Types.Count; i++)
                {
                    //well since Confuser only dumps his AntiDebug in <Module> we only check there
                    if (module.Types[i].Name != "<Module>")
                        continue;

                    foreach (MethodDefinition m in module.Types[i].Methods)
                    {
                        if (!m.HasBody)
                            continue;

                        if (Program.ScanSignature(m, Signature))
                        {
                            DecryptType = (TypeDefinition)m.DeclaringType;
                            DecryptMethod = m;
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        public byte[] GetStringResource(AssemblyDefinition asm, string FilePath, MethodDefinition method)
        {
            if (!method.HasBody)
            {
                return new byte[0];
            }

            //funny... the first string in the method is a resource name
            string name = "";
            for(int i = 0; i < method.Body.Instructions.Count; i++)
            {
                if(method.Body.Instructions[i].OpCode.Code == Mono.Cecil.Cil.Code.Ldstr)
                {
                    if(method.Body.Instructions[i].Operand == null)
                        continue;
                    name = method.Body.Instructions[i].Operand.ToString();
                    break;
                }
            }

            foreach (Resource res in asm.MainModule.Resources)
            {
                if(res.Name == name)
                {
                    if(res.GetType() == typeof(EmbeddedResource))
                    {
                        //lets read it the way confuser is doing...
                        MemoryStream stream = new MemoryStream();
                        using (DeflateStream stream2 = new DeflateStream(System.Reflection.Assembly.LoadFile(FilePath).GetManifestResourceStream(name), CompressionMode.Decompress))
                        {
                            byte[] buffer = new byte[0x1000];
                            int count = stream2.Read(buffer, 0, 0x1000);
                            do
                            {
                                stream.Write(buffer, 0, count);
                                count = stream2.Read(buffer, 0, 0x1000);
                            }while (count != 0);
                        }
                        return stream.ToArray();
                    }
                }
            }
            return new byte[0];
        }

        public void DecryptAllStrings(AssemblyDefinition asm, MethodDefinition DecryptMethod, byte[] StringData)
        {
            //this is for getting the key... just a signature would help us :3
            //this key is being generated randomly at while using the obfuscator
            OpCode[] KeySig = new OpCode[]
            {
                OpCodes.Nop,
                OpCodes.Nop,
                OpCodes.Ldc_I4_1,
                OpCodes.Newobj,
                OpCodes.Callvirt,
                OpCodes.Callvirt,
                OpCodes.Stloc_S,
                OpCodes.Ldloc_S,
                OpCodes.Ldarg_0,
                OpCodes.Xor
                //key
                //nop
            };
            OpCode[] NumKeySig = new OpCode[]
            {
                OpCodes.Callvirt,
                OpCodes.Ldloc_S,
                OpCodes.Conv_I8,
                OpCodes.Ldc_I4_0,
                OpCodes.Callvirt,
                OpCodes.Pop,
                OpCodes.Ldloc_S,
                OpCodes.Callvirt,
                OpCodes.Not
            };
            OpCode[] SeedKeySig = new OpCode[]
            {
                OpCodes.Ldc_I4,
                OpCodes.Xor,
                OpCodes.Stloc_S,
                OpCodes.Ldloc_S,
                OpCodes.Ldloc_S,
                OpCodes.Callvirt,
                OpCodes.Stloc_S
            };

            //yep my sucky signature seeker
            int key = 0;
            int NumKey = 0;
            int SeedKey = 0;
            if (!Program.ReadSigKey(DecryptMethod, KeySig, ref key) || !Program.ReadSigKey(DecryptMethod, NumKeySig, ref NumKey) ||
                !Program.ReadSigKey(DecryptMethod, SeedKeySig, ref SeedKey))
            {
                Console.WriteLine("One of the keys could not be found ;(!");
                return;
            }

            //time to decrypt everything ;)
            foreach (TypeDefinition t in asm.MainModule.Types)
            {
                foreach (MethodDefinition m in t.Methods)
                {
                    if (!m.HasBody)
                        continue;

                    //lets look where our decrypt method is called
                    for (int i = 0; i < m.Body.Instructions.Count; i++)
                    {
                        if (m.Body.Instructions[i].Operand == DecryptMethod)
                        {
                            //1 instruction before call is our ID-KEY
                            if (m.Body.Instructions[i].Previous != null)
                            {
                                int id = Convert.ToInt32(m.Body.Instructions[i].Previous.Operand);
                                int token = (int)m.MetadataToken.ToUInt();
                                int Offset = (token ^ id) - key;

                                //decrypt here
                                string str = "";
                                using (BinaryReader reader = new BinaryReader(new MemoryStream(StringData)))
                                {
                                    reader.BaseStream.Position = Offset;
                                    int num4 = ((int)~reader.ReadUInt32()) ^ NumKey;
                                    byte[] bytes = reader.ReadBytes(num4);
                                    string crypted = ASCIIEncoding.ASCII.GetString(bytes);

                                    Random random = new Random(SeedKey);
                                    int num5 = 0;
                                    for (int j = 0; j < bytes.Length; j++)
                                    {
                                        byte num7 = bytes[j];
                                        bytes[j] = (byte) (bytes[j] ^ (random.Next() & num5));
                                        num5 += num7;
                                    }
                                    str = ASCIIEncoding.ASCII.GetString(bytes);
                                    Console.WriteLine("[String Decryptor] \"" + crypted + "\" -->> \"" + str + "\"");
                                }

                                //ok when it's all decrypted lets put the original string back
                                m.Body.Instructions[i-1] = new Instruction(OpCodes.Ldstr, str);
                                m.Body.Instructions.RemoveAt(i);
                                i--;
                            }
                        }
                    }
                }
            }
        }

        public void RemoveDecryptMethod(AssemblyDefinition asm, TypeDefinition DecryptType, MethodDefinition DecryptMethod)
        {
            for (int i = 0; i < asm.MainModule.Types.Count; i++)
            {
                //well since Confuser only dumps his AntiDebug in <Module> we only check there
                if (asm.MainModule.Types[i].Name != "<Module>")
                    continue;

                foreach (MethodDefinition m in asm.MainModule.Types[i].Constructors)
                {
                    if (!m.HasBody)
                        continue;

                    for (int x = 0; x < m.Body.Instructions.Count; x++)
                    {
                        if (m.Body.Instructions[x].OpCode.Code == Code.Call)
                        {
                            if (m.Body.Instructions[x].Operand == DecryptMethod)
                            {
                                m.Body.Instructions.Remove(m.Body.Instructions[x]);
                                x--;
                            }
                        }
                    }
                }
            }
            DecryptType.Methods.Remove(DecryptMethod);
        }
    }
}


Directory structure:
└── panthere-debabelvm/
    ├── README.md
    ├── BabelVMRestore.sln
    ├── CONTRIBUTERS.md
    ├── LICENSE
    ├── BabelVMRestore/
    │   ├── App.config
    │   ├── BabelVMRestore.csproj
    │   ├── Program.cs
    │   ├── Core/
    │   │   ├── MethodRestorer.cs
    │   │   └── SuperDynamicReader.cs
    │   ├── Logger/
    │   │   └── ConsoleLogger.cs
    │   ├── Properties/
    │   │   └── AssemblyInfo.cs
    │   ├── Structs/
    │   │   └── EncryptedInfo.cs
    │   └── Utilities/
    │       ├── ReflectionHelper.cs
    │       └── Settings.cs
    └── Dependencies/

================================================
File: README.md
================================================
# DeBabelVM
Deobfuscate Babel 8.x's VM

![In action](http://i.imgur.com/5mwg87G.png)
![Comparison](http://i.imgur.com/3EC09Ru.png)

# Warning

**DO NOT EXECUTE THIS OUTSIDE OF A VIRTUAL MACHINE**

Due to the fact that it uses Reflection Invoking it is possible that malicious code is executed.



================================================
File: BabelVMRestore.sln
================================================
ï»¿
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 2012
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "BabelVMRestore", "BabelVMRestore\BabelVMRestore.csproj", "{0F8E0336-2865-4DA8-AF16-5ECCCE387EA6}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{0F8E0336-2865-4DA8-AF16-5ECCCE387EA6}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{0F8E0336-2865-4DA8-AF16-5ECCCE387EA6}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{0F8E0336-2865-4DA8-AF16-5ECCCE387EA6}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{0F8E0336-2865-4DA8-AF16-5ECCCE387EA6}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal



================================================
File: CONTRIBUTERS.md
================================================
# Contributers

0xd4d - dnlib + questions

xenocode/cawk - original base

xSonoro - pushing me to do this... :(




================================================
File: LICENSE
================================================
MIT License

Copyright (c) 2016 Panthere

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
File: BabelVMRestore/App.config
================================================
ï»¿<?xml version="1.0" encoding="utf-8" ?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5" />
    </startup>
</configuration>


================================================
File: BabelVMRestore/BabelVMRestore.csproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{0F8E0336-2865-4DA8-AF16-5ECCCE387EA6}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>BabelVMRestore</RootNamespace>
    <AssemblyName>BabelVMRestore</AssemblyName>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup>
    <StartupObject>BabelVMRestore.Program</StartupObject>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="dnlib">
      <HintPath>..\Dependencies\dnlib.dll</HintPath>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Logger\ConsoleLogger.cs" />
    <Compile Include="Structs\EncryptedInfo.cs" />
    <Compile Include="Utilities\ReflectionHelper.cs" />
    <Compile Include="Core\MethodRestorer.cs" />
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="Utilities\Settings.cs" />
    <Compile Include="Core\SuperDynamicReader.cs" />
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>


================================================
File: BabelVMRestore/Program.cs
================================================
ï»¿using BabelVMRestore.Core;
using BabelVMRestore.Logger;
using BabelVMRestore.Utilities;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using dnlib.DotNet.Writer;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using System.Text;
using System.Threading.Tasks;

namespace BabelVMRestore
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.Title = "Babel 8.x.x.x VM Restorer - LaPanthere @ rtn-team.cc";
            Console.WriteLine(@"______    ______       _          _ _   ____  ___");
            Console.WriteLine(@"|  _  \   | ___ \     | |        | | | | |  \/  |");
            Console.WriteLine(@"| | | |___| |_/ / __ _| |__   ___| | | | | .  . |");
            Console.WriteLine(@"| | | / _ \ ___ \/ _` | '_ \ / _ \ | | | | |\/| |");
            Console.WriteLine(@"| |/ /  __/ |_/ / (_| | |_) |  __/ \ \_/ / |  | |");
            Console.WriteLine(@"|___/ \___\____/ \__,_|_.__/ \___|_|\___/\_|  |_/");
            Console.WriteLine("                                 V1.2 - LaPanthere");


            
            try
            {
                Settings.LoadSettings(args);

            }
            catch (Exception)
            {
                
                ConsoleLogger.Error("[!] Error: Cannot load the file. Make sure it's a valid .NET file!");
                ConsoleLogger.Error("[!] Verbose mode can be activated with -v");
                return;
            }

            ConsoleLogger.Success("[!] Trying to Restore Methods from VM - for best results move VM Restore to target folder!");



            Environment.CurrentDirectory = Path.GetDirectoryName(Settings.FileName);

            MethodRestorer mr = new MethodRestorer(Settings.Module);
            mr.Restore();
            mr.Write(Settings.OutputFileName);


            Console.ReadKey();

        }
       
    }

}



================================================
File: BabelVMRestore/Core/MethodRestorer.cs
================================================
ï»¿using BabelVMRestore.Logger;
using BabelVMRestore.Structs;
using BabelVMRestore.Utilities;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using dnlib.DotNet.Writer;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

namespace BabelVMRestore.Core
{
    public class MethodRestorer
    {
        #region Fields
        private ModuleDefMD _module;
        private MethodDef _invokerMtd;

        #endregion

        #region Constructors
        public MethodRestorer()
            : this(null)
        {
        }

        public MethodRestorer(ModuleDefMD module)
        {
            _module = module;
        }

        #endregion

        #region Memebers
        #region Public Members
        public int Restore()
        {
            int totalChanges = 0;
            if (!FindInvokeMethod())
            {
                ConsoleLogger.Error("[!] Could not find Invoker Method! Cannot Continue!");
                return totalChanges;
            }

            List<EncryptedInfo> callerInfos = FindVMCallers();

            if (callerInfos.Count == 0)
            {
                ConsoleLogger.Error("[!] Could not find any VM Callers! Cannot Continue!");
                return totalChanges;
            }

            totalChanges += InvokeVMCallers(callerInfos);


            ConsoleLogger.Success("[!] Restored {0} methods from BabelVM", totalChanges);
            return totalChanges;
        }
        public void Write(string outputFile)
        {
            var opts = new ModuleWriterOptions(_module);
            opts.MetaDataOptions.Flags = MetaDataFlags.PreserveAll;
            opts.Logger = DummyLogger.NoThrowInstance;

            _module.Write(outputFile, opts);

            if (File.Exists(outputFile))
            {
                ConsoleLogger.Success("[!] Module saved");
            }
            else
            {
                ConsoleLogger.Error("[!] Module could not be saved!");
            }
        }
        #endregion
        #region Private Members
        private bool FindInvokeMethod()
        {
            foreach (TypeDef type in this._module.Types)
            {
                if (type.BaseType == null)
                    continue;
                if (!type.HasInterfaces)
                    continue;

                if (!type.Interfaces[0].Interface.FullName.Contains("IDisposable"))
                    continue;
                foreach (MethodDef md in type.Methods)
                {
                    if (!md.HasBody)
                        continue;
                    if (!md.IsPrivate)
                        continue;
                    if (md.IsStatic)
                        continue;
                    if (md.Parameters.Count < 2)
                        continue;

                    if (md.Parameters[1].Type.FullName != "System.Int32" && md.Parameters[1].Type.FullName != "System.String")
                        continue;

                    if (md.Body.ExceptionHandlers.Count != 1)
                        continue;

                    bool skipMethod = false;
                    for (int i = 0; i < md.Body.Instructions.Count; i++)
                    {
                        Instruction inst = md.Body.Instructions[i];

                        if (inst.OpCode == dnlib.DotNet.Emit.OpCodes.Ldstr)
                        {
                            if (((string)inst.Operand) != "Error dynamic method {0}: {1}")
                            {
                                skipMethod = true;
                                break;
                            }
                        }
                    }
                    if (skipMethod)
                        continue;

                    _invokerMtd = md;
                }
            }
            return _invokerMtd != null;
        }

        private List<EncryptedInfo> FindVMCallers()
        {
            List<EncryptedInfo> InvokeCallerInfo = new List<EncryptedInfo>();

            foreach (TypeDef type in this._module.Types)
            {
                foreach (MethodDef md in type.Methods)
                {
                    if (!md.HasBody)
                        continue;

                    EncryptedInfo info = new EncryptedInfo();
                    bool found = false;
                    for (int i = 0; i < md.Body.Instructions.Count; i++)
                    {
                        Instruction inst = md.Body.Instructions[i];

                        if (inst.Operand is MethodDef)
                        {
                            MethodDef mDef = inst.Operand as MethodDef;

                            if (mDef.Parameters.Count == 3)
                            {
                                if (mDef.Parameters[0].Type.FullName != "System.Int32")
                                    continue;
                                if (mDef.Parameters[1].Type.FullName != "System.Object")
                                    continue;
                                if (mDef.Parameters[2].Type.FullName != "System.Object[]")
                                    continue;
                            }
                            else if (mDef.Parameters.Count == 2)
                            {
                                if (mDef.Parameters[0].Type.FullName != "System.String")
                                    continue;
                                if (mDef.Parameters[1].Type.FullName != "System.Object[]")
                                    continue;
                            }
                            else
                            {
                                continue;
                            }

                            if (!mDef.IsStatic)
                                continue;
                            if (!mDef.IsPublic)
                                continue;
                            if (mDef.ReturnType.FullName != "System.Object")
                                continue;

                            info.Method = md;
                            found = true;
                        }
                    }
                    if (found)
                    {
                        ConsoleLogger.Verbose("[!] Encrypted Method Found - {0} (RVA: {1}, MDToken: 0x{2:X})", md.FullName, md.RVA, md.MDToken.ToInt32());
                        Instruction inst = md.Body.Instructions[0];
                        if (inst.OpCode == dnlib.DotNet.Emit.OpCodes.Ldc_I4)
                        {
                            if (info.Key != 0)
                                continue;
                            info.Key = inst.GetLdcI4Value();
                            info.VMType = EncType.Int;
                            InvokeCallerInfo.Add(info);
                        }
                        else if (inst.OpCode == dnlib.DotNet.Emit.OpCodes.Ldstr)
                        {
                            if (info.KeyString != null)
                            {
                                continue;
                            }
                            info.VMType = EncType.String;
                            info.KeyString = inst.Operand as string;
                            InvokeCallerInfo.Add(info);
                        }
                    }
                }
            }
            ConsoleLogger.Verbose("[!] Found {0} VM Callers", InvokeCallerInfo.Count);
            return InvokeCallerInfo;
        }

        private int InvokeVMCallers(List<EncryptedInfo> InvokeCallerInfo)
        {
            int changes = 0;
            bool gotFieldName = false;
            string fieldName = "";

            Assembly assembly = Assembly.LoadFile(Settings.FileName);
            MethodBase mb = assembly.ManifestModule.ResolveMethod(_invokerMtd.MDToken.ToInt32());
            ConstructorInfo c = mb.DeclaringType.GetConstructor(BindingFlags.NonPublic | BindingFlags.Instance, null, Type.EmptyTypes, null);

            object a = c.Invoke(new object[] { });

            foreach (EncryptedInfo info in InvokeCallerInfo)
            {
                try
                {

                    object dr = mb.Invoke(a, new object[] { (info.VMType == EncType.Int ? (object)info.Key : (object)info.KeyString) });
                    Type drType = dr.GetType();

                    if (!gotFieldName)
                    {
                        foreach (FieldInfo fi in drType.GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static))
                        {
                            if (fi.FieldType.FullName == "System.Reflection.Emit.DynamicMethod")
                            {
                                fieldName = fi.Name;
                                
                                ConsoleLogger.Info("[!] Found Dynamic Method Field: MDToken: 0x{0:X}", fi.MetadataToken);
                            }
                        }
                        if (string.IsNullOrEmpty(fieldName))
                        {
                            ConsoleLogger.Error("[!] Could not find Dynamic Method Field Name! Trying with \uE006 !");
                            fieldName = "\uE006";
                        }
                        gotFieldName = true;
                    }

                    info.ResolvedDynamicMethod = ReflectionHelper.GetInstanceField(drType, dr, fieldName) as System.Reflection.Emit.DynamicMethod;

                    SuperDynamicReader mbr = new SuperDynamicReader(_module, info.ResolvedDynamicMethod);
                    mbr.Read();

                    info.ResolvedMethod = mbr.GetMethod();
                    info.Method.Body = info.ResolvedMethod.Body;

                    changes++;
                    ConsoleLogger.Verbose("[!] Encrypted Method Restored - {0} (RVA: {1}, MDToken: 0x{2:X})", info.Method.FullName, info.Method.RVA, info.Method.MDToken.ToInt32());

                }
                catch (Exception ex)
                {
                    ConsoleLogger.Info("[!] Failed Restoration 0x{1:X} : {0}", ex, info.Method.MDToken.ToInt32());
                }
            }
            return changes;
        }
        #endregion
        #endregion
    }
}



================================================
File: BabelVMRestore/Core/SuperDynamicReader.cs
================================================
ï»¿using dnlib.DotNet;
using dnlib.DotNet.Emit;
using dnlib.DotNet.MD;
using dnlib.IO;
using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection.Emit;
using SR = System.Reflection;

namespace BabelVMRestore.Core
{

    // This has been taken and modified from dnlib.
    // dnlib License:

/*
dnlib: .NET assembly library
https://github.com/0xd4d/dnlib

Copyright (C) 2012-2015 de4dot@gmail.com

Contributors
------------

Ki, "yck1509 <confuser.net@gmail.com>", https://github.com/yck1509
kiootic, "kiootic <kiootic@gmail.com>", https://github.com/kiootic

MIT LICENSE
-----------

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

    /// <summary>
    /// Reads code from a DynamicMethod
    /// </summary>
    public class SuperDynamicReader : MethodBodyReaderBase, ISignatureReaderHelper
    {
        static readonly ReflectionFieldInfo rtdmOwnerFieldInfo = new ReflectionFieldInfo("m_owner");
        static readonly ReflectionFieldInfo dmResolverFieldInfo = new ReflectionFieldInfo("m_resolver");
        static readonly ReflectionFieldInfo rslvCodeFieldInfo = new ReflectionFieldInfo("m_code");
        static readonly ReflectionFieldInfo rslvDynamicScopeFieldInfo = new ReflectionFieldInfo("m_scope");
        static readonly ReflectionFieldInfo rslvMethodFieldInfo = new ReflectionFieldInfo("m_method");
        static readonly ReflectionFieldInfo rslvLocalsFieldInfo = new ReflectionFieldInfo("m_localSignature");
        static readonly ReflectionFieldInfo rslvMaxStackFieldInfo = new ReflectionFieldInfo("m_stackSize");
        static readonly ReflectionFieldInfo rslvExceptionsFieldInfo = new ReflectionFieldInfo("m_exceptions");
        static readonly ReflectionFieldInfo rslvExceptionHeaderFieldInfo = new ReflectionFieldInfo("m_exceptionHeader");
        static readonly ReflectionFieldInfo scopeTokensFieldInfo = new ReflectionFieldInfo("m_tokens");
        static readonly ReflectionFieldInfo gfiFieldHandleFieldInfo = new ReflectionFieldInfo("m_field", "m_fieldHandle");
        static readonly ReflectionFieldInfo gfiContextFieldInfo = new ReflectionFieldInfo("m_context");
        static readonly ReflectionFieldInfo gmiMethodHandleFieldInfo = new ReflectionFieldInfo("m_method", "m_methodHandle");
        static readonly ReflectionFieldInfo gmiContextFieldInfo = new ReflectionFieldInfo("m_context");
        static readonly ReflectionFieldInfo ehCatchAddrFieldInfo = new ReflectionFieldInfo("m_catchAddr");
        static readonly ReflectionFieldInfo ehCatchClassFieldInfo = new ReflectionFieldInfo("m_catchClass");
        static readonly ReflectionFieldInfo ehCatchEndAddrFieldInfo = new ReflectionFieldInfo("m_catchEndAddr");
        static readonly ReflectionFieldInfo ehCurrentCatchFieldInfo = new ReflectionFieldInfo("m_currentCatch");
        static readonly ReflectionFieldInfo ehTypeFieldInfo = new ReflectionFieldInfo("m_type");
        static readonly ReflectionFieldInfo ehStartAddrFieldInfo = new ReflectionFieldInfo("m_startAddr");
        static readonly ReflectionFieldInfo ehEndAddrFieldInfo = new ReflectionFieldInfo("m_endAddr");
        static readonly ReflectionFieldInfo ehEndFinallyFieldInfo = new ReflectionFieldInfo("m_endFinally");
        static readonly ReflectionFieldInfo vamMethodFieldInfo = new ReflectionFieldInfo("m_method");
        static readonly ReflectionFieldInfo vamDynamicMethodFieldInfo = new ReflectionFieldInfo("m_dynamicMethod");
        static readonly ReflectionFieldInfo methodDynamicInfo = new ReflectionFieldInfo("m_DynamicILInfo");
        ModuleDef module;
        Importer importer;
        GenericParamContext gpContext;
        MethodDef method;
        int codeSize;
        int maxStack;
        List<object> tokens;
        IList<object> ehInfos;
        byte[] ehHeader;

        class ReflectionFieldInfo
        {
            SR.FieldInfo fieldInfo;
            readonly string fieldName1;
            readonly string fieldName2;

            public ReflectionFieldInfo(string fieldName)
            {
                this.fieldName1 = fieldName;
            }

            public ReflectionFieldInfo(string fieldName1, string fieldName2)
            {
                this.fieldName1 = fieldName1;
                this.fieldName2 = fieldName2;
            }

            public object Read(object instance)
            {
                if (fieldInfo == null)
                    InitializeField(instance.GetType());
                if (fieldInfo == null)
                    throw new Exception(string.Format("Couldn't find field '{0}' or '{1}'", fieldName1, fieldName2));

                return fieldInfo.GetValue(instance);
            }
            public object Read(object instance, Type type)
            {
                if (fieldInfo == null)
                    InitializeField(type);
                if (fieldInfo == null)
                    throw new Exception(string.Format("Couldn't find field '{0}' or '{1}'", fieldName1, fieldName2));

                return fieldInfo.GetValue(instance);
            }
            public bool Exists(object instance)
            {
                InitializeField(instance.GetType());
                return fieldInfo != null;
            }

            void InitializeField(Type type)
            {
                if (fieldInfo != null)
                    return;

                var flags = SR.BindingFlags.Instance | SR.BindingFlags.Public | SR.BindingFlags.NonPublic;
                fieldInfo = type.GetField(fieldName1, flags);
                if (fieldInfo == null && fieldName2 != null)
                    fieldInfo = type.GetField(fieldName2, flags);
            }
        }

        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="module">Module that will own the method body</param>
        /// <param name="obj">This can be one of several supported types: the delegate instance
        /// created by DynamicMethod.CreateDelegate(), a DynamicMethod instance, a RTDynamicMethod
        /// instance or a DynamicResolver instance.</param>
        public SuperDynamicReader(ModuleDef module, object obj)
            : this(module, obj, new GenericParamContext())
        {
        }

        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="module">Module that will own the method body</param>
        /// <param name="obj">This can be one of several supported types: the delegate instance
        /// created by DynamicMethod.CreateDelegate(), a DynamicMethod instance, a RTDynamicMethod
        /// instance or a DynamicResolver instance.</param>
        /// <param name="gpContext">Generic parameter context</param>
        public SuperDynamicReader(ModuleDef module, object obj, GenericParamContext gpContext)
        {
            this.module = module;
            this.importer = new Importer(module, ImporterOptions.TryToUseDefs, gpContext);
            this.gpContext = gpContext;

            if (obj == null)
                throw new ArgumentNullException("obj");

            var del = obj as Delegate;
            if (del != null)
            {
                obj = del.Method;
                if (obj == null)
                    throw new Exception("Delegate.Method == null");
            }

            if (obj.GetType().ToString() == "System.Reflection.Emit.DynamicMethod+RTDynamicMethod")
            {
                obj = rtdmOwnerFieldInfo.Read(obj) as DynamicMethod;
                if (obj == null)
                    throw new Exception("RTDynamicMethod.m_owner is null or invalid");
            }

            if (obj is DynamicMethod)
            {
                object obj2 = obj;
                obj = dmResolverFieldInfo.Read(obj);
                if (obj == null)
                {
                    // could be compiled from dynamic info instead of raw shit
                    obj = obj2;
                    obj = methodDynamicInfo.Read(obj);
                    if (obj == null)
                        throw new Exception("No resolver found");

                    SecondOption(obj);
                    return;
                }
            }

            if (obj.GetType().ToString() != "System.Reflection.Emit.DynamicResolver")
                throw new Exception("Couldn't find DynamicResolver");

            var code = rslvCodeFieldInfo.Read(obj) as byte[];
            if (code == null)
                throw new Exception("No code");
            codeSize = code.Length;
            var delMethod = rslvMethodFieldInfo.Read(obj) as SR.MethodBase;
            if (delMethod == null)
                throw new Exception("No method");
            maxStack = (int)rslvMaxStackFieldInfo.Read(obj);

            var scope = rslvDynamicScopeFieldInfo.Read(obj);
            if (scope == null)
                throw new Exception("No scope");
            var tokensList = scopeTokensFieldInfo.Read(scope) as System.Collections.IList;
            if (tokensList == null)
                throw new Exception("No tokens");
            tokens = new List<object>(tokensList.Count);
            for (int i = 0; i < tokensList.Count; i++)
                tokens.Add(tokensList[i]);

            ehInfos = (IList<object>)rslvExceptionsFieldInfo.Read(obj);
            ehHeader = rslvExceptionHeaderFieldInfo.Read(obj) as byte[];

            UpdateLocals(rslvLocalsFieldInfo.Read(obj) as byte[]);
            this.reader = MemoryImageStream.Create(code);
            this.method = CreateMethodDef(delMethod);
            this.parameters = this.method.Parameters;
        }
        public static T GetFieldValue<T>(object obj, string fieldName)
        {
            if (obj == null)
                throw new ArgumentNullException("obj");

            var field = obj.GetType().GetField(fieldName, SR.BindingFlags.Public |
                                                          SR.BindingFlags.NonPublic |
                                                          SR.BindingFlags.Instance);

            if (field == null)
                throw new ArgumentException("fieldName", "No such field was found.");

            if (!typeof(T).IsAssignableFrom(field.FieldType))
                throw new InvalidOperationException("Field type and requested type are not compatible.");

            return (T)field.GetValue(obj);
        }
        void SecondOption(object obj)
        {
            // this is entirely different from the one below
            var code = GetFieldValue<byte[]>(obj, "m_code");
            if (code == null)
                throw new Exception("No code");
            codeSize = code.Length;
            var delMethod = GetFieldValue<SR.MethodBase>(obj, "m_method");
            if (delMethod == null)
                throw new Exception("No method");
            maxStack = GetFieldValue<int>(obj, "m_maxStackSize");

            var scope = GetFieldValue<object>(obj, "m_scope");
            if (scope == null)
                throw new Exception("No scope");
            var tokensList = GetFieldValue<System.Collections.IList>(scope, "m_tokens");
            if (tokensList == null)
                throw new Exception("No tokens");
            tokens = new List<object>(tokensList.Count);
            for (int i = 0; i < tokensList.Count; i++)
                tokens.Add(tokensList[i]);

            //ehInfos = (IList<object>)rslvExceptionsFieldInfo.Read(obj);
            ehHeader = GetFieldValue<byte[]>(obj, "m_exceptions");

            UpdateLocals(GetFieldValue<byte[]>(obj, "m_localSignature"));
            this.reader = MemoryImageStream.Create(code);
            this.method = CreateMethodDef(delMethod);
            this.parameters = this.method.Parameters;

            return;
        }
        class ExceptionInfo
        {
            public int[] CatchAddr;
            public Type[] CatchClass;
            public int[] CatchEndAddr;
            public int CurrentCatch;
            public int[] Type;
            public int StartAddr;
            public int EndAddr;
            public int EndFinally;
        }

        static List<ExceptionInfo> CreateExceptionInfos(IList<object> ehInfos)
        {
            if (ehInfos == null)
                return new List<ExceptionInfo>();

            var infos = new List<ExceptionInfo>(ehInfos.Count);

            foreach (var ehInfo in ehInfos)
            {
                var eh = new ExceptionInfo
                {
                    CatchAddr = (int[])ehCatchAddrFieldInfo.Read(ehInfo),
                    CatchClass = (Type[])ehCatchClassFieldInfo.Read(ehInfo),
                    CatchEndAddr = (int[])ehCatchEndAddrFieldInfo.Read(ehInfo),
                    CurrentCatch = (int)ehCurrentCatchFieldInfo.Read(ehInfo),
                    Type = (int[])ehTypeFieldInfo.Read(ehInfo),
                    StartAddr = (int)ehStartAddrFieldInfo.Read(ehInfo),
                    EndAddr = (int)ehEndAddrFieldInfo.Read(ehInfo),
                    EndFinally = (int)ehEndFinallyFieldInfo.Read(ehInfo),
                };
                infos.Add(eh);
            }

            return infos;
        }

        void UpdateLocals(byte[] localsSig)
        {
            if (localsSig == null || localsSig.Length == 0)
                return;

            var sig = SignatureReader.ReadSig(this, module.CorLibTypes, localsSig, gpContext) as LocalSig;
            if (sig == null)
                return;

            foreach (var local in sig.Locals)
                locals.Add(new Local(local));
        }

        MethodDef CreateMethodDef(SR.MethodBase delMethod)
        {
            bool isStatic = true;
            var method = new MethodDefUser();

            var retType = GetReturnType(delMethod);
            var pms = GetParameters(delMethod);
            if (isStatic)
                method.Signature = MethodSig.CreateStatic(retType, pms.ToArray());
            else
                method.Signature = MethodSig.CreateInstance(retType, pms.ToArray());

            method.Parameters.UpdateParameterTypes();
            method.ImplAttributes = MethodImplAttributes.IL;
            method.Attributes = MethodAttributes.PrivateScope;
            if (isStatic)
                method.Attributes |= MethodAttributes.Static;

            return module.UpdateRowId(method);
        }

        TypeSig GetReturnType(SR.MethodBase mb)
        {
            var mi = mb as SR.MethodInfo;
            if (mi != null)
                return importer.ImportAsTypeSig(mi.ReturnType);
            return module.CorLibTypes.Void;
        }

        List<TypeSig> GetParameters(SR.MethodBase delMethod)
        {
            var pms = new List<TypeSig>();
            foreach (var param in delMethod.GetParameters())
                pms.Add(importer.ImportAsTypeSig(param.ParameterType));
            return pms;
        }

        /// <summary>
        /// Reads the code
        /// </summary>
        /// <returns></returns>
        public bool Read()
        {
            ReadInstructionsNumBytes((uint)codeSize);
            CreateExceptionHandlers();

            return true;
        }

        void CreateExceptionHandlers()
        {
            if (ehHeader != null && ehHeader.Length != 0)
            {
                var reader = new BinaryReader(new MemoryStream(ehHeader));
                byte b = (byte)reader.ReadByte();
                if ((b & 0x40) == 0)
                { // DynamicResolver only checks bit 6
                    // Calculate num ehs exactly the same way that DynamicResolver does
                    int numHandlers = (ushort)((reader.ReadByte() - 2) / 12);
                    reader.ReadInt16();
                    for (int i = 0; i < numHandlers; i++)
                    {
                        var eh = new dnlib.DotNet.Emit.ExceptionHandler();
                        eh.HandlerType = (ExceptionHandlerType)reader.ReadInt16();
                        int offs = reader.ReadUInt16();
                        eh.TryStart = GetInstructionThrow((uint)offs);
                        eh.TryEnd = GetInstruction((uint)(reader.ReadSByte() + offs));
                        offs = reader.ReadUInt16();
                        eh.HandlerStart = GetInstructionThrow((uint)offs);
                        eh.HandlerEnd = GetInstruction((uint)(reader.ReadSByte() + offs));

                        if (eh.HandlerType == ExceptionHandlerType.Catch)
                            eh.CatchType = ReadToken(reader.ReadUInt32()) as ITypeDefOrRef;
                        else if (eh.HandlerType == ExceptionHandlerType.Filter)
                            eh.FilterStart = GetInstruction(reader.ReadUInt32());
                        else
                            reader.ReadUInt32();

                        exceptionHandlers.Add(eh);
                    }
                }
                else
                {
                    reader.BaseStream.Position--;
                    int numHandlers = (ushort)(((reader.ReadUInt32() >> 8) - 4) / 24);
                    for (int i = 0; i < numHandlers; i++)
                    {
                        var eh = new dnlib.DotNet.Emit.ExceptionHandler();
                        eh.HandlerType = (ExceptionHandlerType)reader.ReadInt32();
                        int offs = reader.ReadInt32();
                        eh.TryStart = GetInstructionThrow((uint)offs);
                        eh.TryEnd = GetInstruction((uint)(reader.ReadInt32() + offs));
                        offs = reader.ReadInt32();
                        eh.HandlerStart = GetInstructionThrow((uint)offs);
                        eh.HandlerEnd = GetInstruction((uint)(reader.ReadInt32() + offs));

                        if (eh.HandlerType == ExceptionHandlerType.Catch)
                            eh.CatchType = ReadToken(reader.ReadUInt32()) as ITypeDefOrRef;
                        else if (eh.HandlerType == ExceptionHandlerType.Filter)
                            eh.FilterStart = GetInstruction(reader.ReadUInt32());
                        else
                            reader.ReadUInt32();

                        exceptionHandlers.Add(eh);
                    }
                }
            }
            else if (ehInfos != null)
            {
                foreach (var ehInfo in CreateExceptionInfos(ehInfos))
                {
                    var tryStart = GetInstructionThrow((uint)ehInfo.StartAddr);
                    var tryEnd = GetInstruction((uint)ehInfo.EndAddr);
                    var endFinally = ehInfo.EndFinally < 0 ? null : GetInstruction((uint)ehInfo.EndFinally);
                    for (int i = 0; i < ehInfo.CurrentCatch; i++)
                    {
                        var eh = new dnlib.DotNet.Emit.ExceptionHandler();
                        eh.HandlerType = (ExceptionHandlerType)ehInfo.Type[i];
                        eh.TryStart = tryStart;
                        eh.TryEnd = eh.HandlerType == ExceptionHandlerType.Finally ? endFinally : tryEnd;
                        eh.FilterStart = null;	// not supported by DynamicMethod.ILGenerator
                        eh.HandlerStart = GetInstructionThrow((uint)ehInfo.CatchAddr[i]);
                        eh.HandlerEnd = GetInstruction((uint)ehInfo.CatchEndAddr[i]);
                        eh.CatchType = importer.Import(ehInfo.CatchClass[i]);
                        exceptionHandlers.Add(eh);
                    }
                }
            }
        }

        /// <summary>
        /// Returns the created method. Must be called after <see cref="Read()"/>.
        /// </summary>
        /// <returns>A new <see cref="CilBody"/> instance</returns>
        public MethodDef GetMethod()
        {
            bool initLocals = true;
            var cilBody = new CilBody(initLocals, instructions, exceptionHandlers, locals);
            cilBody.MaxStack = (ushort)Math.Min(maxStack, ushort.MaxValue);
            instructions = null;
            exceptionHandlers = null;
            locals = null;
            method.Body = cilBody;
            return method;
        }

        /// <inheritdoc/>
        protected override IField ReadInlineField(Instruction instr)
        {
            return ReadToken(reader.ReadUInt32()) as IField;
        }

        /// <inheritdoc/>
        protected override IMethod ReadInlineMethod(Instruction instr)
        {
            return ReadToken(reader.ReadUInt32()) as IMethod;
        }

        /// <inheritdoc/>
        protected override MethodSig ReadInlineSig(Instruction instr)
        {
            return ReadToken(reader.ReadUInt32()) as MethodSig;
        }

        /// <inheritdoc/>
        protected override string ReadInlineString(Instruction instr)
        {
            return ReadToken(reader.ReadUInt32()) as string ?? string.Empty;
        }

        /// <inheritdoc/>
        protected override ITokenOperand ReadInlineTok(Instruction instr)
        {
            return ReadToken(reader.ReadUInt32()) as ITokenOperand;
        }

        /// <inheritdoc/>
        protected override ITypeDefOrRef ReadInlineType(Instruction instr)
        {
            return ReadToken(reader.ReadUInt32()) as ITypeDefOrRef;
        }

        object ReadToken(uint token)
        {
            uint rid = token & 0x00FFFFFF;
            switch (token >> 24)
            {
                case 0x02:
                    return ImportType(rid);

                case 0x04:
                    return ImportField(rid);

                case 0x06:
                case 0x0A:
                    return ImportMethod(rid);

                case 0x11:
                    return ImportSignature(rid);

                case 0x70:
                    return Resolve(rid) as string;

                default:
                    return null;
            }
        }

        IMethod ImportMethod(uint rid)
        {
            var obj = Resolve(rid);
            if (obj == null)
                return null;

            if (obj is RuntimeMethodHandle)
                return importer.Import(SR.MethodBase.GetMethodFromHandle((RuntimeMethodHandle)obj));

            if (obj.GetType().ToString() == "System.Reflection.Emit.GenericMethodInfo")
            {
                var context = (RuntimeTypeHandle)gmiContextFieldInfo.Read(obj);
                var method = SR.MethodBase.GetMethodFromHandle((RuntimeMethodHandle)gmiMethodHandleFieldInfo.Read(obj), context);
                return importer.Import(method);
            }

            if (obj.GetType().ToString() == "System.Reflection.Emit.VarArgMethod")
            {
                var method = GetVarArgMethod(obj);
                if (!(method is DynamicMethod))
                    return importer.Import(method);
                obj = method;
            }

            var dm = obj as DynamicMethod;
            if (dm != null)
                throw new Exception("DynamicMethod calls another DynamicMethod");

            return null;
        }

        SR.MethodInfo GetVarArgMethod(object obj)
        {
            if (vamDynamicMethodFieldInfo.Exists(obj))
            {
                // .NET 4.0+
                var method = vamMethodFieldInfo.Read(obj) as SR.MethodInfo;
                var dynMethod = vamDynamicMethodFieldInfo.Read(obj) as DynamicMethod;
                return dynMethod ?? method;
            }
            else
            {
                // .NET 2.0
                // This is either a DynamicMethod or a MethodInfo
                return vamMethodFieldInfo.Read(obj) as SR.MethodInfo;
            }
        }

        IField ImportField(uint rid)
        {
            var obj = Resolve(rid);
            if (obj == null)
                return null;

            if (obj is RuntimeFieldHandle)
                return importer.Import(SR.FieldInfo.GetFieldFromHandle((RuntimeFieldHandle)obj));

            if (obj.GetType().ToString() == "System.Reflection.Emit.GenericFieldInfo")
            {
                var context = (RuntimeTypeHandle)gfiContextFieldInfo.Read(obj);
                var field = SR.FieldInfo.GetFieldFromHandle((RuntimeFieldHandle)gfiFieldHandleFieldInfo.Read(obj), context);
                return importer.Import(field);
            }

            return null;
        }

        ITypeDefOrRef ImportType(uint rid)
        {
            var obj = Resolve(rid);
            if (obj is RuntimeTypeHandle)
                return importer.Import(Type.GetTypeFromHandle((RuntimeTypeHandle)obj));

            return null;
        }

        CallingConventionSig ImportSignature(uint rid)
        {
            var sig = Resolve(rid) as byte[];
            if (sig == null)
                return null;

            return SignatureReader.ReadSig(this, module.CorLibTypes, sig, gpContext);
        }

        object Resolve(uint index)
        {
            if (index >= (uint)tokens.Count)
                return null;
            return tokens[(int)index];
        }

        ITypeDefOrRef ISignatureReaderHelper.ResolveTypeDefOrRef(uint codedToken, GenericParamContext gpContext)
        {
            uint token;
            if (!CodedToken.TypeDefOrRef.Decode(codedToken, out token))
                return null;
            uint rid = MDToken.ToRID(token);
            switch (MDToken.ToTable(token))
            {
                case Table.TypeDef:
                case Table.TypeRef:
                case Table.TypeSpec:
                    return ImportType(rid);
            }
            return null;
        }

        TypeSig ISignatureReaderHelper.ConvertRTInternalAddress(IntPtr address)
        {
            return importer.ImportAsTypeSig(MethodTableToTypeConverter.Convert(address));
        }
    }
}



================================================
File: BabelVMRestore/Logger/ConsoleLogger.cs
================================================
ï»¿using BabelVMRestore.Utilities;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace BabelVMRestore.Logger
{
    public class ConsoleLogger
    {
        public static ConsoleColor DefaultColor = ConsoleColor.White;

        public static void Verbose(string text, params object[] data)
        {
            if (!Settings.Verbose)
                return;

            Console.ForegroundColor = ConsoleColor.Yellow;
            WriteLine(text, data);
            Console.ForegroundColor = DefaultColor;
        }
        public static void Error(string text, params object[] data)
        {
            Console.ForegroundColor = ConsoleColor.Red;
            WriteLine(text, data);
            Console.ForegroundColor = DefaultColor;
        }
        public static void Info(string text, params object[] data)
        {
            Console.ForegroundColor = ConsoleColor.Cyan;
            WriteLine(text, data);
            Console.ForegroundColor = DefaultColor;
        }
        public static void Success(string text, params object[] data)
        {
            Console.ForegroundColor = ConsoleColor.Green;
            WriteLine(text, data);
            Console.ForegroundColor = DefaultColor;
        }
        public static void WriteLine(string text, params object[] data)
        {
            // TODO: Log file generation?
            Console.WriteLine(text, data);
        }
    }
}



================================================
File: BabelVMRestore/Properties/AssemblyInfo.cs
================================================
ï»¿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("BabelVMRestore")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("BabelVMRestore")]
[assembly: AssemblyCopyright("Copyright Â© Microsoft 2016")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("09118cf3-5959-4c39-99db-12244342e6df")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]



================================================
File: BabelVMRestore/Structs/EncryptedInfo.cs
================================================
ï»¿
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using System.Reflection.Emit;

namespace BabelVMRestore.Structs
{
    public class EncryptedInfo
    {
        public MethodDef Method;
        public int Key;
        public DynamicMethod ResolvedDynamicMethod;
        public MethodDef ResolvedMethod;
        public string KeyString;
        public EncType VMType;
    }
    public enum EncType
    {
        String,
        Int
    }
    public class CFlowInt
    {
        public MethodDef InvokerMethod;
        public MethodDef OwnerMethod;
        public Instruction CallInst;
        public Instruction KeyInst;
        public int Key;
    }
}



================================================
File: BabelVMRestore/Utilities/ReflectionHelper.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

namespace BabelVMRestore.Utilities
{
    public static class ReflectionHelper
    {
        public static object GetInstanceField(Type type, object instance, string fieldName)
        {
            BindingFlags bindFlags = BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic
                | BindingFlags.Static;
            FieldInfo field = type.GetField(fieldName, bindFlags);
            return field.GetValue(instance);
        }
    }
}



================================================
File: BabelVMRestore/Utilities/Settings.cs
================================================
ï»¿using BabelVMRestore.Logger;
using dnlib.DotNet;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace BabelVMRestore.Utilities
{
    public static class Settings
    {
        public static bool Verbose;
        public static string FileName;
        public static string OutputFileName;

        public static ModuleDefMD Module;

        public static void LoadSettings(string[] args)
        {
            // Input filename, verbose
            FileName = args[0];
            if (args.Length > 1)
                Verbose = args[1].ToLower() == "-v";

            // Module setting
            Module = ModuleDefMD.Load(FileName);

            // Output filepath name
            string dirName = Path.GetDirectoryName(args[0]);
            if (!dirName.EndsWith("\\"))
                dirName += "\\";
            OutputFileName = string.Format("{0}{1}_patched{2}",  dirName, Path.GetFileNameWithoutExtension(FileName), Path.GetExtension(FileName));

            ConsoleLogger.Success("[!] Loaded Module: {0}", Module.FullName);
            ConsoleLogger.Success("[!] Output File: {0}", OutputFileName);
        }
    }
}




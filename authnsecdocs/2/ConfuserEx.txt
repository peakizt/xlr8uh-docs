Directory structure:
└── yck1509-confuserex/
    ├── README.md
    ├── Confuser2.mono.sln
    ├── Confuser2.sln
    ├── ConfuserEx.snk
    ├── GlobalAssemblyInfo.Template.cs
    ├── LICENSE
    ├── VERSION
    ├── Confuser.CLI/
    │   ├── Confuser.CLI.csproj
    │   ├── Options.cs
    │   ├── Program.cs
    │   └── Properties/
    │       └── AssemblyInfo.cs
    ├── Confuser.Core/
    │   ├── Annotations.cs
    │   ├── Confuser.Core.csproj
    │   ├── ConfuserComponent.cs
    │   ├── ConfuserContext.cs
    │   ├── ConfuserEngine.cs
    │   ├── ConfuserException.cs
    │   ├── ConfuserParameters.cs
    │   ├── CoreComponent.cs
    │   ├── DependencyResolver.cs
    │   ├── DnlibUtils.cs
    │   ├── ILogger.cs
    │   ├── Marker.cs
    │   ├── MarkerResult.cs
    │   ├── ModuleSorter.cs
    │   ├── ModuleWriterListener.cs
    │   ├── NativeEraser.cs
    │   ├── NullLogger.cs
    │   ├── ObfAttrMarker.cs
    │   ├── ObfAttrParser.cs
    │   ├── Packer.cs
    │   ├── PluginDiscovery.cs
    │   ├── Protection.cs
    │   ├── ProtectionDependencyAttributes.cs
    │   ├── ProtectionParameters.cs
    │   ├── ProtectionPhase.cs
    │   ├── ProtectionPipeline.cs
    │   ├── ProtectionPreset.cs
    │   ├── ProtectionSettings.cs
    │   ├── ProtectionTargets.cs
    │   ├── ServiceRegistry.cs
    │   ├── UnreachableException.cs
    │   ├── Utils.cs
    │   ├── API/
    │   │   ├── APIStore.cs
    │   │   ├── IDataStore.cs
    │   │   └── IOpaquePredicate.cs
    │   ├── Helpers/
    │   │   ├── ControlFlowGraph.cs
    │   │   ├── InjectHelper.cs
    │   │   ├── KeySequence.cs
    │   │   └── MutationHelper.cs
    │   ├── LZMA/
    │   │   ├── ICoder.cs
    │   │   ├── Common/
    │   │   │   ├── CRC.cs
    │   │   │   ├── InBuffer.cs
    │   │   │   └── OutBuffer.cs
    │   │   └── Compress/
    │   │       ├── LZ/
    │   │       │   ├── IMatchFinder.cs
    │   │       │   ├── LzBinTree.cs
    │   │       │   ├── LzInWindow.cs
    │   │       │   └── LzOutWindow.cs
    │   │       ├── LZMA/
    │   │       │   ├── LzmaBase.cs
    │   │       │   ├── LzmaDecoder.cs
    │   │       │   └── LzmaEncoder.cs
    │   │       └── RangeCoder/
    │   │           ├── RangeCoder.cs
    │   │           ├── RangeCoderBit.cs
    │   │           └── RangeCoderBitTree.cs
    │   ├── Project/
    │   │   ├── ConfuserPrj.xsd
    │   │   ├── ConfuserProject.cs
    │   │   ├── InvalidPatternException.cs
    │   │   ├── PatternParser.cs
    │   │   ├── PatternToken.cs
    │   │   ├── PatternTokenizer.cs
    │   │   └── Patterns/
    │   │       ├── AndOperator.cs
    │   │       ├── DeclTypeFunction.cs
    │   │       ├── FullNameFunction.cs
    │   │       ├── HasAttrFunction.cs
    │   │       ├── InheritsFunction.cs
    │   │       ├── IsPublicFunction.cs
    │   │       ├── IsTypeFunction.cs
    │   │       ├── LiteralExpression.cs
    │   │       ├── MatchFunction.cs
    │   │       ├── MemberTypeFunction.cs
    │   │       ├── ModuleFunction.cs
    │   │       ├── NameFunction.cs
    │   │       ├── NamespaceFunction.cs
    │   │       ├── NotOperator.cs
    │   │       ├── OrOperator.cs
    │   │       ├── PatternExpression.cs
    │   │       ├── PatternFunction.cs
    │   │       └── PatternOperator.cs
    │   ├── Properties/
    │   │   └── AssemblyInfo.cs
    │   └── Services/
    │       ├── CompressionService.cs
    │       ├── MarkerService.cs
    │       ├── RandomService.cs
    │       ├── RuntimeService.cs
    │       └── TraceService.cs
    ├── Confuser.DynCipher/
    │   ├── Confuser.DynCipher.csproj
    │   ├── DynCipherComponent.cs
    │   ├── DynCipherService.cs
    │   ├── Utils.cs
    │   ├── AST/
    │   │   ├── ArrayIndexExpression.cs
    │   │   ├── AssignmentStatement.cs
    │   │   ├── BinOpExpression.cs
    │   │   ├── Expression.cs
    │   │   ├── LiteralExpression.cs
    │   │   ├── LoopStatement.cs
    │   │   ├── Statement.cs
    │   │   ├── StatementBlock.cs
    │   │   ├── UnaryOpExpression.cs
    │   │   ├── Variable.cs
    │   │   └── VariableExpression.cs
    │   ├── Elements/
    │   │   ├── AddKey.cs
    │   │   ├── BinOp.cs
    │   │   ├── CryptoElement.cs
    │   │   ├── Matrix.cs
    │   │   ├── NumOp.cs
    │   │   ├── RotateBit.cs
    │   │   └── Swap.cs
    │   ├── Generation/
    │   │   ├── CILCodeGen.cs
    │   │   ├── CipherGenContext.cs
    │   │   ├── CipherGenerator.cs
    │   │   ├── DMCodeGen.cs
    │   │   ├── ExpressionGenerator.cs
    │   │   └── x86CodeGen.cs
    │   ├── Properties/
    │   │   └── AssemblyInfo.cs
    │   └── Transforms/
    │       ├── ConvertVariables.cs
    │       ├── ExpansionTransform.cs
    │       ├── MulToShiftTransform.cs
    │       ├── NormalizeBinOpTransform.cs
    │       └── ShuffleTransform.cs
    ├── Confuser.Protections/
    │   ├── AntiDebugProtection.cs
    │   ├── AntiDumpProtection.cs
    │   ├── AntiILDasmProtection.cs
    │   ├── Confuser.Protections.csproj
    │   ├── InvalidMetadataProtection.cs
    │   ├── AntiTamper/
    │   │   ├── AntiTamperProtection.cs
    │   │   ├── DynamicDeriver.cs
    │   │   ├── IKeyDeriver.cs
    │   │   ├── IModeHandler.cs
    │   │   ├── JITBody.cs
    │   │   ├── JITMode.cs
    │   │   ├── NormalDeriver.cs
    │   │   └── NormalMode.cs
    │   ├── Compress/
    │   │   ├── Compressor.cs
    │   │   ├── CompressorContext.cs
    │   │   ├── DynamicDeriver.cs
    │   │   ├── ExtractPhase.cs
    │   │   ├── IKeyDeriver.cs
    │   │   ├── NormalDeriver.cs
    │   │   └── StubProtection.cs
    │   ├── Constants/
    │   │   ├── CEContext.cs
    │   │   ├── ConstantProtection.cs
    │   │   ├── DynamicMode.cs
    │   │   ├── EncodeElements.cs
    │   │   ├── EncodePhase.cs
    │   │   ├── IEncodeMode.cs
    │   │   ├── InjectPhase.cs
    │   │   ├── Mode.cs
    │   │   ├── NormalMode.cs
    │   │   ├── ReferenceReplacer.cs
    │   │   └── x86Mode.cs
    │   ├── ControlFlow/
    │   │   ├── BlockParser.cs
    │   │   ├── Blocks.cs
    │   │   ├── CFContext.cs
    │   │   ├── ControlFlowPhase.cs
    │   │   ├── ControlFlowProtection.cs
    │   │   ├── ExpressionPredicate.cs
    │   │   ├── IPredicate.cs
    │   │   ├── JumpMangler.cs
    │   │   ├── ManglerBase.cs
    │   │   ├── NormalPredicate.cs
    │   │   ├── SwitchMangler.cs
    │   │   └── x86Predicate.cs
    │   ├── Properties/
    │   │   └── AssemblyInfo.cs
    │   ├── ReferenceProxy/
    │   │   ├── ExpressionEncoding.cs
    │   │   ├── IRPEncoding.cs
    │   │   ├── MildMode.cs
    │   │   ├── NormalEncoding.cs
    │   │   ├── RPContext.cs
    │   │   ├── RPMode.cs
    │   │   ├── ReferenceProxyPhase.cs
    │   │   ├── ReferenceProxyProtection.cs
    │   │   ├── StrongMode.cs
    │   │   └── x86Encoding.cs
    │   └── Resources/
    │       ├── DynamicMode.cs
    │       ├── IEncodeMode.cs
    │       ├── InjectPhase.cs
    │       ├── MDPhase.cs
    │       ├── Mode.cs
    │       ├── NormalMode.cs
    │       ├── REContext.cs
    │       └── ResourceProtection.cs
    ├── Confuser.Renamer/
    │   ├── AnalyzePhase.cs
    │   ├── Confuser.Renamer.csproj
    │   ├── GenericArgumentResolver.cs
    │   ├── INameReference.cs
    │   ├── IRenamer.cs
    │   ├── NameProtection.cs
    │   ├── NameService.cs
    │   ├── PostRenamePhase.cs
    │   ├── RenameMode.cs
    │   ├── RenamePhase.cs
    │   ├── ReversibleRenamer.cs
    │   ├── RickRoller.cs
    │   ├── VTable.cs
    │   ├── Analyzers/
    │   │   ├── CaliburnAnalyzer.cs
    │   │   ├── InterReferenceAnalyzer.cs
    │   │   ├── JsonAnalyzer.cs
    │   │   ├── LdtokenEnumAnalyzer.cs
    │   │   ├── ResourceAnalyzer.cs
    │   │   ├── TypeBlobAnalyzer.cs
    │   │   ├── VTableAnalyzer.cs
    │   │   ├── WPFAnalyzer.cs
    │   │   └── WinFormsAnalyzer.cs
    │   ├── BAML/
    │   │   ├── BAMLAnalyzer.cs
    │   │   ├── BAMLPropertyReference.cs
    │   │   ├── BAMLStringReference.cs
    │   │   ├── BamlDocument.cs
    │   │   ├── BamlElement.cs
    │   │   ├── BamlRW.cs
    │   │   ├── BamlRecords.cs
    │   │   ├── IBAMLReference.cs
    │   │   ├── IKnownThings.cs
    │   │   ├── KnownThingsv3.cs
    │   │   ├── KnownThingsv4.cs
    │   │   └── PropertyPath.cs
    │   ├── Properties/
    │   │   └── AssemblyInfo.cs
    │   └── References/
    │       ├── BAMLAttributeReference.cs
    │       ├── BAMLConverterMemberReference.cs
    │       ├── BAMLConverterTypeReference.cs
    │       ├── BAMLEnumReference.cs
    │       ├── BAMLPathTypeReference.cs
    │       ├── BAMLTypeReference.cs
    │       ├── CAMemberReference.cs
    │       ├── MemberRefReference.cs
    │       ├── OverrideDirectiveReference.cs
    │       ├── ResourceReference.cs
    │       ├── StringTypeReference.cs
    │       └── TypeRefReference.cs
    ├── Confuser.Runtime/
    │   ├── AntiDebug.Antinet.cs
    │   ├── AntiDebug.Safe.cs
    │   ├── AntiDebug.Win32.cs
    │   ├── AntiDump.cs
    │   ├── AntiTamper.JIT.cs
    │   ├── AntiTamper.Normal.cs
    │   ├── Compressor.Compat.cs
    │   ├── Compressor.cs
    │   ├── Confuser.Runtime.csproj
    │   ├── Constant.cs
    │   ├── Lzma.cs
    │   ├── Mutation.cs
    │   ├── RefProxy.Strong.cs
    │   ├── Resource.cs
    │   ├── Properties/
    │   │   └── AssemblyInfo.cs
    │   └── antinet/
    │       ├── ABOUT
    │       ├── AntiManagedDebugger.cs
    │       ├── AntiManagedProfiler.cs
    │       ├── HandleProcessCorruptedStateExceptionsAttribute.cs
    │       └── PEInfo.cs
    ├── ConfuserEx/
    │   ├── App.xaml
    │   ├── App.xaml.cs
    │   ├── BoolToVisibilityConverter.cs
    │   ├── BrushToColorConverter.cs
    │   ├── CompComboBox.xaml
    │   ├── CompComboBox.xaml.cs
    │   ├── ComponentConverter.cs
    │   ├── ComponentDiscovery.cs
    │   ├── ConfuserEx.csproj
    │   ├── EnumValuesExtension.cs
    │   ├── FileDragDrop.cs
    │   ├── InvertBoolConverter.cs
    │   ├── MainWindow.xaml
    │   ├── MainWindow.xaml.cs
    │   ├── Skin.cs
    │   ├── Skin.xaml
    │   ├── StackTraceDecoder.xaml
    │   ├── StackTraceDecoder.xaml.cs
    │   ├── Views.xaml
    │   ├── app.config
    │   ├── packages.config
    │   ├── Properties/
    │   │   └── AssemblyInfo.cs
    │   ├── Resources/
    │   │   ├── CREDITS
    │   │   └── FontAwesome.otf
    │   ├── ViewModel/
    │   │   ├── IViewModel.cs
    │   │   ├── StringItem.cs
    │   │   ├── Utils.cs
    │   │   ├── ViewModelBase.cs
    │   │   ├── Project/
    │   │   │   ├── ProjectModuleVM.cs
    │   │   │   ├── ProjectRuleVM.cs
    │   │   │   ├── ProjectSettingVM.cs
    │   │   │   └── ProjectVM.cs
    │   │   └── UI/
    │   │       ├── AboutTabVM.cs
    │   │       ├── AppVM.cs
    │   │       ├── ProjectTabVM.cs
    │   │       ├── ProtectTabVM.cs
    │   │       ├── SettingsTabVM.cs
    │   │       └── TabViewModel.cs
    │   └── Views/
    │       ├── AboutTabView.xaml
    │       ├── ProjectModuleView.xaml
    │       ├── ProjectModuleView.xaml.cs
    │       ├── ProjectRuleView.xaml
    │       ├── ProjectRuleView.xaml.cs
    │       ├── ProjectTabAdvancedView.xaml
    │       ├── ProjectTabAdvancedView.xaml.cs
    │       ├── ProjectTabView.xaml
    │       ├── ProtectTabView.xaml
    │       └── SettingsTabView.xaml
    ├── additional/
    │   ├── Icon.pdn
    │   ├── Icon16.pdn
    │   ├── Icon256.pdn
    │   ├── Icon32.pdn
    │   ├── Icon48.pdn
    │   ├── Icon64.pdn
    │   ├── ilspy.crproj
    │   └── pdn.crproj
    ├── deps/
    ├── dnlib/
    ├── docs/
    │   ├── DeclarativeObfuscation.txt
    │   ├── ProjectFormat.md
    │   └── docs.shfbproj
    └── .nuget/
        ├── NuGet.Config
        └── NuGet.targets

================================================
File: README.md
================================================
ConfuserEx
========
ConfuserEx is a open-source protector for .NET applications.
It is the successor of [Confuser](http://confuser.codeplex.com) project.

NOTICE
======
This project is discontinued and unmaintained. Alternative forked projects can be found in [this issue](https://github.com/yck1509/ConfuserEx/issues/671).

Features
--------
* Supports .NET Framework 2.0/3.0/3.5/4.0/4.5
* Symbol renaming (Support WPF/BAML)
* Protection against debuggers/profilers
* Protection against memory dumping
* Protection against tampering (method encryption)
* Control flow obfuscation
* Constant/resources encryption
* Reference hiding proxies
* Disable decompilers
* Embedding dependency
* Compressing output
* Extensible plugin API
* Many more are coming!

Usage
-----
`Confuser.CLI <path to project file>`

The project file is a ConfuserEx Project (*.crproj).
The format of project file can be found in docs\ProjectFormat.md

Bug Report
----------
See the [Issues Report](http://yck1509.github.io/ConfuserEx/issues/) section of website.


License
-------
See LICENSE file for details.

Credits
-------
**[0xd4d](https://github.com/0xd4d)** for his awesome work and extensive knowledge!  
Members of **[Black Storm Forum](http://board.b-at-s.info/)** for their help!



================================================
File: Confuser2.mono.sln
================================================
ï»¿
Microsoft Visual Studio Solution File, Format Version 11.00
# Visual Studio 2010
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Confuser.Core", "Confuser.Core\Confuser.Core.csproj", "{BEB67A6E-4C54-4DE5-8C6B-2C12F44A7B92}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "dnlib", "dnlib\src\dnlib.csproj", "{FDFC1237-143F-4919-8318-4926901F4639}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Confuser.Protections", "Confuser.Protections\Confuser.Protections.csproj", "{3EAB01B5-9B49-48D8-BFA1-5493B26CCB71}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Confuser.CLI", "Confuser.CLI\Confuser.CLI.csproj", "{CE61ADEE-C032-43EC-ACD8-E4A742F894A3}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Confuser.Renamer", "Confuser.Renamer\Confuser.Renamer.csproj", "{862DA0DA-52E1-47CD-B9C2-46B106031B28}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Confuser.DynCipher", "Confuser.DynCipher\Confuser.DynCipher.csproj", "{E832E9B8-2158-4FC0-89A1-56C6ECC10F6B}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Confuser.Runtime", "Confuser.Runtime\Confuser.Runtime.csproj", "{A45C184F-F98F-4258-A928-BFF437034791}"
	ProjectSection(ProjectDependencies) = postProject
		{BEB67A6E-4C54-4DE5-8C6B-2C12F44A7B92} = {BEB67A6E-4C54-4DE5-8C6B-2C12F44A7B92}
	EndProjectSection
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{BEB67A6E-4C54-4DE5-8C6B-2C12F44A7B92}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{BEB67A6E-4C54-4DE5-8C6B-2C12F44A7B92}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{BEB67A6E-4C54-4DE5-8C6B-2C12F44A7B92}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{BEB67A6E-4C54-4DE5-8C6B-2C12F44A7B92}.Release|Any CPU.Build.0 = Release|Any CPU
		{FDFC1237-143F-4919-8318-4926901F4639}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{FDFC1237-143F-4919-8318-4926901F4639}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{FDFC1237-143F-4919-8318-4926901F4639}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{FDFC1237-143F-4919-8318-4926901F4639}.Release|Any CPU.Build.0 = Release|Any CPU
		{3EAB01B5-9B49-48D8-BFA1-5493B26CCB71}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{3EAB01B5-9B49-48D8-BFA1-5493B26CCB71}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{3EAB01B5-9B49-48D8-BFA1-5493B26CCB71}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{3EAB01B5-9B49-48D8-BFA1-5493B26CCB71}.Release|Any CPU.Build.0 = Release|Any CPU
		{CE61ADEE-C032-43EC-ACD8-E4A742F894A3}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{CE61ADEE-C032-43EC-ACD8-E4A742F894A3}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{CE61ADEE-C032-43EC-ACD8-E4A742F894A3}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{CE61ADEE-C032-43EC-ACD8-E4A742F894A3}.Release|Any CPU.Build.0 = Release|Any CPU
		{862DA0DA-52E1-47CD-B9C2-46B106031B28}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{862DA0DA-52E1-47CD-B9C2-46B106031B28}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{862DA0DA-52E1-47CD-B9C2-46B106031B28}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{862DA0DA-52E1-47CD-B9C2-46B106031B28}.Release|Any CPU.Build.0 = Release|Any CPU
		{E832E9B8-2158-4FC0-89A1-56C6ECC10F6B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{E832E9B8-2158-4FC0-89A1-56C6ECC10F6B}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{E832E9B8-2158-4FC0-89A1-56C6ECC10F6B}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{E832E9B8-2158-4FC0-89A1-56C6ECC10F6B}.Release|Any CPU.Build.0 = Release|Any CPU
		{A45C184F-F98F-4258-A928-BFF437034791}.Debug|Any CPU.ActiveCfg = Release|Any CPU
		{A45C184F-F98F-4258-A928-BFF437034791}.Debug|Any CPU.Build.0 = Release|Any CPU
		{A45C184F-F98F-4258-A928-BFF437034791}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{A45C184F-F98F-4258-A928-BFF437034791}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal



================================================
File: Confuser2.sln
================================================
ï»¿
Microsoft Visual Studio Solution File, Format Version 11.00
# Visual Studio 2010
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Confuser.Core", "Confuser.Core\Confuser.Core.csproj", "{BEB67A6E-4C54-4DE5-8C6B-2C12F44A7B92}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "dnlib", "dnlib\src\dnlib.csproj", "{FDFC1237-143F-4919-8318-4926901F4639}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Confuser.Protections", "Confuser.Protections\Confuser.Protections.csproj", "{3EAB01B5-9B49-48D8-BFA1-5493B26CCB71}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = ".nuget", ".nuget", "{2C631F61-84D5-4E49-8CD7-0876A07A3B21}"
	ProjectSection(SolutionItems) = preProject
		.nuget\NuGet.Config = .nuget\NuGet.Config
		.nuget\NuGet.targets = .nuget\NuGet.targets
	EndProjectSection
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Confuser.CLI", "Confuser.CLI\Confuser.CLI.csproj", "{CE61ADEE-C032-43EC-ACD8-E4A742F894A3}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Confuser.Renamer", "Confuser.Renamer\Confuser.Renamer.csproj", "{862DA0DA-52E1-47CD-B9C2-46B106031B28}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Confuser.DynCipher", "Confuser.DynCipher\Confuser.DynCipher.csproj", "{E832E9B8-2158-4FC0-89A1-56C6ECC10F6B}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Confuser.Runtime", "Confuser.Runtime\Confuser.Runtime.csproj", "{A45C184F-F98F-4258-A928-BFF437034791}"
	ProjectSection(ProjectDependencies) = postProject
		{BEB67A6E-4C54-4DE5-8C6B-2C12F44A7B92} = {BEB67A6E-4C54-4DE5-8C6B-2C12F44A7B92}
	EndProjectSection
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ConfuserEx", "ConfuserEx\ConfuserEx.csproj", "{B5205EBA-EC32-4C53-86A0-FAEEE7393EC0}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{BEB67A6E-4C54-4DE5-8C6B-2C12F44A7B92}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{BEB67A6E-4C54-4DE5-8C6B-2C12F44A7B92}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{BEB67A6E-4C54-4DE5-8C6B-2C12F44A7B92}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{BEB67A6E-4C54-4DE5-8C6B-2C12F44A7B92}.Release|Any CPU.Build.0 = Release|Any CPU
		{FDFC1237-143F-4919-8318-4926901F4639}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{FDFC1237-143F-4919-8318-4926901F4639}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{FDFC1237-143F-4919-8318-4926901F4639}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{FDFC1237-143F-4919-8318-4926901F4639}.Release|Any CPU.Build.0 = Release|Any CPU
		{3EAB01B5-9B49-48D8-BFA1-5493B26CCB71}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{3EAB01B5-9B49-48D8-BFA1-5493B26CCB71}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{3EAB01B5-9B49-48D8-BFA1-5493B26CCB71}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{3EAB01B5-9B49-48D8-BFA1-5493B26CCB71}.Release|Any CPU.Build.0 = Release|Any CPU
		{CE61ADEE-C032-43EC-ACD8-E4A742F894A3}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{CE61ADEE-C032-43EC-ACD8-E4A742F894A3}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{CE61ADEE-C032-43EC-ACD8-E4A742F894A3}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{CE61ADEE-C032-43EC-ACD8-E4A742F894A3}.Release|Any CPU.Build.0 = Release|Any CPU
		{862DA0DA-52E1-47CD-B9C2-46B106031B28}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{862DA0DA-52E1-47CD-B9C2-46B106031B28}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{862DA0DA-52E1-47CD-B9C2-46B106031B28}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{862DA0DA-52E1-47CD-B9C2-46B106031B28}.Release|Any CPU.Build.0 = Release|Any CPU
		{E832E9B8-2158-4FC0-89A1-56C6ECC10F6B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{E832E9B8-2158-4FC0-89A1-56C6ECC10F6B}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{E832E9B8-2158-4FC0-89A1-56C6ECC10F6B}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{E832E9B8-2158-4FC0-89A1-56C6ECC10F6B}.Release|Any CPU.Build.0 = Release|Any CPU
		{A45C184F-F98F-4258-A928-BFF437034791}.Debug|Any CPU.ActiveCfg = Release|Any CPU
		{A45C184F-F98F-4258-A928-BFF437034791}.Debug|Any CPU.Build.0 = Release|Any CPU
		{A45C184F-F98F-4258-A928-BFF437034791}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{A45C184F-F98F-4258-A928-BFF437034791}.Release|Any CPU.Build.0 = Release|Any CPU
		{B5205EBA-EC32-4C53-86A0-FAEEE7393EC0}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{B5205EBA-EC32-4C53-86A0-FAEEE7393EC0}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{B5205EBA-EC32-4C53-86A0-FAEEE7393EC0}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{B5205EBA-EC32-4C53-86A0-FAEEE7393EC0}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal



================================================
File: ConfuserEx.snk
================================================
[Non-text file]


================================================
File: GlobalAssemblyInfo.Template.cs
================================================
ï»¿using System.Reflection;

[assembly: AssemblyProduct("ConfuserEx")]
[assembly: AssemblyCompany("Ki")]
[assembly: AssemblyCopyright("Copyright (C) Ki 2014")]

#if DEBUG

[assembly: AssemblyConfiguration("Debug")]
#else

[assembly: AssemblyConfiguration("Release")]
#endif

[assembly: AssemblyVersion("{{VER}}")]
[assembly: AssemblyFileVersion("{{VER}}")]
[assembly: AssemblyInformationalVersion("{{TAG}}")]


================================================
File: LICENSE
================================================
ConfuserEx is licensed under MIT license.

----------------

Copyright (c) 2014 yck1509

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


================================================
File: VERSION
================================================
1.0.0


================================================
File: Confuser.CLI/Confuser.CLI.csproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProductVersion>8.0.30703</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{CE61ADEE-C032-43EC-ACD8-E4A742F894A3}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>Confuser.CLI</RootNamespace>
    <AssemblyName>Confuser.CLI</AssemblyName>
    <TargetFrameworkVersion Condition=" !$(DefineConstants.Contains('NET45')) ">v4.0</TargetFrameworkVersion>
    <TargetFrameworkVersion Condition=" $(DefineConstants.Contains('NET45')) ">v4.5</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <SolutionDir Condition="$(SolutionDir) == '' Or $(SolutionDir) == '*Undefined*'">..\</SolutionDir>
    <RestorePackages>true</RestorePackages>
    <TargetFrameworkProfile />
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>..\Debug\bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <DocumentationFile>
    </DocumentationFile>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>..\Release\bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <DocumentationFile>
    </DocumentationFile>
  </PropertyGroup>
  <PropertyGroup>
    <SignAssembly>true</SignAssembly>
  </PropertyGroup>
  <PropertyGroup>
    <AssemblyOriginatorKeyFile>..\ConfuserEx.snk</AssemblyOriginatorKeyFile>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="..\GlobalAssemblyInfo.cs">
      <Link>Properties\GlobalAssemblyInfo.cs</Link>
    </Compile>
    <Compile Include="Options.cs" />
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\Confuser.Core\Confuser.Core.csproj">
      <Project>{BEB67A6E-4C54-4DE5-8C6B-2C12F44A7B92}</Project>
      <Name>Confuser.Core</Name>
    </ProjectReference>
    <ProjectReference Include="..\Confuser.DynCipher\Confuser.DynCipher.csproj">
      <Project>{E832E9B8-2158-4FC0-89A1-56C6ECC10F6B}</Project>
      <Name>Confuser.DynCipher</Name>
    </ProjectReference>
    <ProjectReference Include="..\Confuser.Protections\Confuser.Protections.csproj">
      <Project>{3EAB01B5-9B49-48D8-BFA1-5493B26CCB71}</Project>
      <Name>Confuser.Protections</Name>
    </ProjectReference>
    <ProjectReference Include="..\Confuser.Renamer\Confuser.Renamer.csproj">
      <Project>{862DA0DA-52E1-47CD-B9C2-46B106031B28}</Project>
      <Name>Confuser.Renamer</Name>
    </ProjectReference>
    <ProjectReference Include="..\Confuser.Runtime\Confuser.Runtime.csproj">
      <Project>{A45C184F-F98F-4258-A928-BFF437034791}</Project>
      <Name>Confuser.Runtime</Name>
    </ProjectReference>
    <ProjectReference Include="..\dnlib\src\dnlib.csproj">
      <Project>{FDFC1237-143F-4919-8318-4926901F4639}</Project>
      <Name>dnlib</Name>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup>
    <None Include="..\ConfuserEx.snk">
      <Link>Properties\ConfuserEx.snk</Link>
    </None>
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <Import Project="$(SolutionDir)\.nuget\NuGet.targets" Condition="Exists('$(SolutionDir)\.nuget\NuGet.targets')" />
  <Target Name="EnsureNuGetPackageBuildImports" BeforeTargets="PrepareForBuild">
    <PropertyGroup>
      <ErrorText>This project references NuGet package(s) that are missing on this computer. Enable NuGet Package Restore to download them.  For more information, see http://go.microsoft.com/fwlink/?LinkID=322105. The missing file is {0}.</ErrorText>
    </PropertyGroup>
    <Error Condition="!Exists('$(SolutionDir)\.nuget\NuGet.targets')" Text="$([System.String]::Format('$(ErrorText)', '$(SolutionDir)\.nuget\NuGet.targets'))" />
  </Target>
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>


================================================
File: Confuser.CLI/Options.cs
================================================
//
// Options.cs
//
// Authors:
//  Jonathan Pryor <jpryor@novell.com>
//
// Copyright (C) 2008 Novell (http://www.novell.com)
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
// 
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

// Compile With:
//   gmcs -debug+ -r:System.Core Options.cs -o:NDesk.Options.dll
//   gmcs -debug+ -d:LINQ -r:System.Core Options.cs -o:NDesk.Options.dll
//
// The LINQ version just changes the implementation of
// OptionSet.Parse(IEnumerable<string>), and confers no semantic changes.

//
// A Getopt::Long-inspired option parsing library for C#.
//
// NDesk.Options.OptionSet is built upon a key/value table, where the
// key is a option format string and the value is a delegate that is 
// invoked when the format string is matched.
//
// Option format strings:
//  Regex-like BNF Grammar: 
//    name: .+
//    type: [=:]
//    sep: ( [^{}]+ | '{' .+ '}' )?
//    aliases: ( name type sep ) ( '|' name type sep )*
// 
// Each '|'-delimited name is an alias for the associated action.  If the
// format string ends in a '=', it has a required value.  If the format
// string ends in a ':', it has an optional value.  If neither '=' or ':'
// is present, no value is supported.  `=' or `:' need only be defined on one
// alias, but if they are provided on more than one they must be consistent.
//
// Each alias portion may also end with a "key/value separator", which is used
// to split option values if the option accepts > 1 value.  If not specified,
// it defaults to '=' and ':'.  If specified, it can be any character except
// '{' and '}' OR the *string* between '{' and '}'.  If no separator should be
// used (i.e. the separate values should be distinct arguments), then "{}"
// should be used as the separator.
//
// Options are extracted either from the current option by looking for
// the option name followed by an '=' or ':', or is taken from the
// following option IFF:
//  - The current option does not contain a '=' or a ':'
//  - The current option requires a value (i.e. not a Option type of ':')
//
// The `name' used in the option format string does NOT include any leading
// option indicator, such as '-', '--', or '/'.  All three of these are
// permitted/required on any named option.
//
// Option bundling is permitted so long as:
//   - '-' is used to start the option group
//   - all of the bundled options are a single character
//   - at most one of the bundled options accepts a value, and the value
//     provided starts from the next character to the end of the string.
//
// This allows specifying '-a -b -c' as '-abc', and specifying '-D name=value'
// as '-Dname=value'.
//
// Option processing is disabled by specifying "--".  All options after "--"
// are returned by OptionSet.Parse() unchanged and unprocessed.
//
// Unprocessed options are returned from OptionSet.Parse().
//
// Examples:
//  int verbose = 0;
//  OptionSet p = new OptionSet ()
//    .Add ("v", v => ++verbose)
//    .Add ("name=|value=", v => Console.WriteLine (v));
//  p.Parse (new string[]{"-v", "--v", "/v", "-name=A", "/name", "B", "extra"});
//
// The above would parse the argument string array, and would invoke the
// lambda expression three times, setting `verbose' to 3 when complete.  
// It would also print out "A" and "B" to standard output.
// The returned array would contain the string "extra".
//
// C# 3.0 collection initializers are supported and encouraged:
//  var p = new OptionSet () {
//    { "h|?|help", v => ShowHelp () },
//  };
//
// System.ComponentModel.TypeConverter is also supported, allowing the use of
// custom data types in the callback type; TypeConverter.ConvertFromString()
// is used to convert the value option to an instance of the specified
// type:
//
//  var p = new OptionSet () {
//    { "foo=", (Foo f) => Console.WriteLine (f.ToString ()) },
//  };
//
// Random other tidbits:
//  - Boolean options (those w/o '=' or ':' in the option format string)
//    are explicitly enabled if they are followed with '+', and explicitly
//    disabled if they are followed with '-':
//      string a = null;
//      var p = new OptionSet () {
//        { "a", s => a = s },
//      };
//      p.Parse (new string[]{"-a"});   // sets v != null
//      p.Parse (new string[]{"-a+"});  // sets v != null
//      p.Parse (new string[]{"-a-"});  // sets v == null
//

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Globalization;
using System.IO;
using System.Runtime.Serialization;
using System.Security.Permissions;
using System.Text;
using System.Text.RegularExpressions;

#if LINQ
using System.Linq;
#endif

#if TEST
using NDesk.Options;
#endif

namespace NDesk.Options {

	public class OptionValueCollection : IList, IList<string> {

		List<string> values = new List<string> ();
		OptionContext c;

		internal OptionValueCollection (OptionContext c)
		{
			this.c = c;
		}

		#region ICollection
		void ICollection.CopyTo (Array array, int index)  {(values as ICollection).CopyTo (array, index);}
		bool ICollection.IsSynchronized                   {get {return (values as ICollection).IsSynchronized;}}
		object ICollection.SyncRoot                       {get {return (values as ICollection).SyncRoot;}}
		#endregion

		#region ICollection<T>
		public void Add (string item)                       {values.Add (item);}
		public void Clear ()                                {values.Clear ();}
		public bool Contains (string item)                  {return values.Contains (item);}
		public void CopyTo (string[] array, int arrayIndex) {values.CopyTo (array, arrayIndex);}
		public bool Remove (string item)                    {return values.Remove (item);}
		public int Count                                    {get {return values.Count;}}
		public bool IsReadOnly                              {get {return false;}}
		#endregion

		#region IEnumerable
		IEnumerator IEnumerable.GetEnumerator () {return values.GetEnumerator ();}
		#endregion

		#region IEnumerable<T>
		public IEnumerator<string> GetEnumerator () {return values.GetEnumerator ();}
		#endregion

		#region IList
		int IList.Add (object value)                {return (values as IList).Add (value);}
		bool IList.Contains (object value)          {return (values as IList).Contains (value);}
		int IList.IndexOf (object value)            {return (values as IList).IndexOf (value);}
		void IList.Insert (int index, object value) {(values as IList).Insert (index, value);}
		void IList.Remove (object value)            {(values as IList).Remove (value);}
		void IList.RemoveAt (int index)             {(values as IList).RemoveAt (index);}
		bool IList.IsFixedSize                      {get {return false;}}
		object IList.this [int index]               {get {return this [index];} set {(values as IList)[index] = value;}}
		#endregion

		#region IList<T>
		public int IndexOf (string item)            {return values.IndexOf (item);}
		public void Insert (int index, string item) {values.Insert (index, item);}
		public void RemoveAt (int index)            {values.RemoveAt (index);}

		private void AssertValid (int index)
		{
			if (c.Option == null)
				throw new InvalidOperationException ("OptionContext.Option is null.");
			if (index >= c.Option.MaxValueCount)
				throw new ArgumentOutOfRangeException ("index");
			if (c.Option.OptionValueType == OptionValueType.Required &&
					index >= values.Count)
				throw new OptionException (string.Format (
							c.OptionSet.MessageLocalizer ("Missing required value for option '{0}'."), c.OptionName), 
						c.OptionName);
		}

		public string this [int index] {
			get {
				AssertValid (index);
				return index >= values.Count ? null : values [index];
			}
			set {
				values [index] = value;
			}
		}
		#endregion

		public List<string> ToList ()
		{
			return new List<string> (values);
		}

		public string[] ToArray ()
		{
			return values.ToArray ();
		}

		public override string ToString ()
		{
			return string.Join (", ", values.ToArray ());
		}
	}

	public class OptionContext {
		private Option                option;
		private string                name;
		private int                   index;
		private OptionSet             set;
		private OptionValueCollection c;

		public OptionContext (OptionSet set)
		{
			this.set = set;
			this.c   = new OptionValueCollection (this);
		}

		public Option Option {
			get {return option;}
			set {option = value;}
		}

		public string OptionName { 
			get {return name;}
			set {name = value;}
		}

		public int OptionIndex {
			get {return index;}
			set {index = value;}
		}

		public OptionSet OptionSet {
			get {return set;}
		}

		public OptionValueCollection OptionValues {
			get {return c;}
		}
	}

	public enum OptionValueType {
		None, 
		Optional,
		Required,
	}

	public abstract class Option {
		string prototype, description;
		string[] names;
		OptionValueType type;
		int count;
		string[] separators;

		protected Option (string prototype, string description)
			: this (prototype, description, 1)
		{
		}

		protected Option (string prototype, string description, int maxValueCount)
		{
			if (prototype == null)
				throw new ArgumentNullException ("prototype");
			if (prototype.Length == 0)
				throw new ArgumentException ("Cannot be the empty string.", "prototype");
			if (maxValueCount < 0)
				throw new ArgumentOutOfRangeException ("maxValueCount");

			this.prototype   = prototype;
			this.names       = prototype.Split ('|');
			this.description = description;
			this.count       = maxValueCount;
			this.type        = ParsePrototype ();

			if (this.count == 0 && type != OptionValueType.None)
				throw new ArgumentException (
						"Cannot provide maxValueCount of 0 for OptionValueType.Required or " +
							"OptionValueType.Optional.",
						"maxValueCount");
			if (this.type == OptionValueType.None && maxValueCount > 1)
				throw new ArgumentException (
						string.Format ("Cannot provide maxValueCount of {0} for OptionValueType.None.", maxValueCount),
						"maxValueCount");
			if (Array.IndexOf (names, "<>") >= 0 && 
					((names.Length == 1 && this.type != OptionValueType.None) ||
					 (names.Length > 1 && this.MaxValueCount > 1)))
				throw new ArgumentException (
						"The default option handler '<>' cannot require values.",
						"prototype");
		}

		public string           Prototype       {get {return prototype;}}
		public string           Description     {get {return description;}}
		public OptionValueType  OptionValueType {get {return type;}}
		public int              MaxValueCount   {get {return count;}}

		public string[] GetNames ()
		{
			return (string[]) names.Clone ();
		}

		public string[] GetValueSeparators ()
		{
			if (separators == null)
				return new string [0];
			return (string[]) separators.Clone ();
		}

		protected static T Parse<T> (string value, OptionContext c)
		{
			TypeConverter conv = TypeDescriptor.GetConverter (typeof (T));
			T t = default (T);
			try {
				if (value != null)
					t = (T) conv.ConvertFromString (value);
			}
			catch (Exception e) {
				throw new OptionException (
						string.Format (
							c.OptionSet.MessageLocalizer ("Could not convert string `{0}' to type {1} for option `{2}'."),
							value, typeof (T).Name, c.OptionName),
						c.OptionName, e);
			}
			return t;
		}

		internal string[] Names           {get {return names;}}
		internal string[] ValueSeparators {get {return separators;}}

		static readonly char[] NameTerminator = new char[]{'=', ':'};

		private OptionValueType ParsePrototype ()
		{
			char type = '\0';
			List<string> seps = new List<string> ();
			for (int i = 0; i < names.Length; ++i) {
				string name = names [i];
				if (name.Length == 0)
					throw new ArgumentException ("Empty option names are not supported.", "prototype");

				int end = name.IndexOfAny (NameTerminator);
				if (end == -1)
					continue;
				names [i] = name.Substring (0, end);
				if (type == '\0' || type == name [end])
					type = name [end];
				else 
					throw new ArgumentException (
							string.Format ("Conflicting option types: '{0}' vs. '{1}'.", type, name [end]),
							"prototype");
				AddSeparators (name, end, seps);
			}

			if (type == '\0')
				return OptionValueType.None;

			if (count <= 1 && seps.Count != 0)
				throw new ArgumentException (
						string.Format ("Cannot provide key/value separators for Options taking {0} value(s).", count),
						"prototype");
			if (count > 1) {
				if (seps.Count == 0)
					this.separators = new string[]{":", "="};
				else if (seps.Count == 1 && seps [0].Length == 0)
					this.separators = null;
				else
					this.separators = seps.ToArray ();
			}

			return type == '=' ? OptionValueType.Required : OptionValueType.Optional;
		}

		private static void AddSeparators (string name, int end, ICollection<string> seps)
		{
			int start = -1;
			for (int i = end+1; i < name.Length; ++i) {
				switch (name [i]) {
					case '{':
						if (start != -1)
							throw new ArgumentException (
									string.Format ("Ill-formed name/value separator found in \"{0}\".", name),
									"prototype");
						start = i+1;
						break;
					case '}':
						if (start == -1)
							throw new ArgumentException (
									string.Format ("Ill-formed name/value separator found in \"{0}\".", name),
									"prototype");
						seps.Add (name.Substring (start, i-start));
						start = -1;
						break;
					default:
						if (start == -1)
							seps.Add (name [i].ToString ());
						break;
				}
			}
			if (start != -1)
				throw new ArgumentException (
						string.Format ("Ill-formed name/value separator found in \"{0}\".", name),
						"prototype");
		}

		public void Invoke (OptionContext c)
		{
			OnParseComplete (c);
			c.OptionName  = null;
			c.Option      = null;
			c.OptionValues.Clear ();
		}

		protected abstract void OnParseComplete (OptionContext c);

		public override string ToString ()
		{
			return Prototype;
		}
	}

	[Serializable]
	public class OptionException : Exception {
		private string option;

		public OptionException ()
		{
		}

		public OptionException (string message, string optionName)
			: base (message)
		{
			this.option = optionName;
		}

		public OptionException (string message, string optionName, Exception innerException)
			: base (message, innerException)
		{
			this.option = optionName;
		}

		protected OptionException (SerializationInfo info, StreamingContext context)
			: base (info, context)
		{
			this.option = info.GetString ("OptionName");
		}

		public string OptionName {
			get {return this.option;}
		}

		[SecurityPermission (SecurityAction.LinkDemand, SerializationFormatter = true)]
		public override void GetObjectData (SerializationInfo info, StreamingContext context)
		{
			base.GetObjectData (info, context);
			info.AddValue ("OptionName", option);
		}
	}

	public delegate void OptionAction<TKey, TValue> (TKey key, TValue value);

	public class OptionSet : KeyedCollection<string, Option>
	{
		public OptionSet ()
			: this (delegate (string f) {return f;})
		{
		}

		public OptionSet (Converter<string, string> localizer)
		{
			this.localizer = localizer;
		}

		Converter<string, string> localizer;

		public Converter<string, string> MessageLocalizer {
			get {return localizer;}
		}

		protected override string GetKeyForItem (Option item)
		{
			if (item == null)
				throw new ArgumentNullException ("option");
			if (item.Names != null && item.Names.Length > 0)
				return item.Names [0];
			// This should never happen, as it's invalid for Option to be
			// constructed w/o any names.
			throw new InvalidOperationException ("Option has no names!");
		}

		[Obsolete ("Use KeyedCollection.this[string]")]
		protected Option GetOptionForName (string option)
		{
			if (option == null)
				throw new ArgumentNullException ("option");
			try {
				return base [option];
			}
			catch (KeyNotFoundException) {
				return null;
			}
		}

		protected override void InsertItem (int index, Option item)
		{
			base.InsertItem (index, item);
			AddImpl (item);
		}

		protected override void RemoveItem (int index)
		{
			base.RemoveItem (index);
			Option p = Items [index];
			// KeyedCollection.RemoveItem() handles the 0th item
			for (int i = 1; i < p.Names.Length; ++i) {
				Dictionary.Remove (p.Names [i]);
			}
		}

		protected override void SetItem (int index, Option item)
		{
			base.SetItem (index, item);
			RemoveItem (index);
			AddImpl (item);
		}

		private void AddImpl (Option option)
		{
			if (option == null)
				throw new ArgumentNullException ("option");
			List<string> added = new List<string> (option.Names.Length);
			try {
				// KeyedCollection.InsertItem/SetItem handle the 0th name.
				for (int i = 1; i < option.Names.Length; ++i) {
					Dictionary.Add (option.Names [i], option);
					added.Add (option.Names [i]);
				}
			}
			catch (Exception) {
				foreach (string name in added)
					Dictionary.Remove (name);
				throw;
			}
		}

		public new OptionSet Add (Option option)
		{
			base.Add (option);
			return this;
		}

		sealed class ActionOption : Option {
			Action<OptionValueCollection> action;

			public ActionOption (string prototype, string description, int count, Action<OptionValueCollection> action)
				: base (prototype, description, count)
			{
				if (action == null)
					throw new ArgumentNullException ("action");
				this.action = action;
			}

			protected override void OnParseComplete (OptionContext c)
			{
				action (c.OptionValues);
			}
		}

		public OptionSet Add (string prototype, Action<string> action)
		{
			return Add (prototype, null, action);
		}

		public OptionSet Add (string prototype, string description, Action<string> action)
		{
			if (action == null)
				throw new ArgumentNullException ("action");
			Option p = new ActionOption (prototype, description, 1, 
					delegate (OptionValueCollection v) { action (v [0]); });
			base.Add (p);
			return this;
		}

		public OptionSet Add (string prototype, OptionAction<string, string> action)
		{
			return Add (prototype, null, action);
		}

		public OptionSet Add (string prototype, string description, OptionAction<string, string> action)
		{
			if (action == null)
				throw new ArgumentNullException ("action");
			Option p = new ActionOption (prototype, description, 2, 
					delegate (OptionValueCollection v) {action (v [0], v [1]);});
			base.Add (p);
			return this;
		}

		sealed class ActionOption<T> : Option {
			Action<T> action;

			public ActionOption (string prototype, string description, Action<T> action)
				: base (prototype, description, 1)
			{
				if (action == null)
					throw new ArgumentNullException ("action");
				this.action = action;
			}

			protected override void OnParseComplete (OptionContext c)
			{
				action (Parse<T> (c.OptionValues [0], c));
			}
		}

		sealed class ActionOption<TKey, TValue> : Option {
			OptionAction<TKey, TValue> action;

			public ActionOption (string prototype, string description, OptionAction<TKey, TValue> action)
				: base (prototype, description, 2)
			{
				if (action == null)
					throw new ArgumentNullException ("action");
				this.action = action;
			}

			protected override void OnParseComplete (OptionContext c)
			{
				action (
						Parse<TKey> (c.OptionValues [0], c),
						Parse<TValue> (c.OptionValues [1], c));
			}
		}

		public OptionSet Add<T> (string prototype, Action<T> action)
		{
			return Add (prototype, null, action);
		}

		public OptionSet Add<T> (string prototype, string description, Action<T> action)
		{
			return Add (new ActionOption<T> (prototype, description, action));
		}

		public OptionSet Add<TKey, TValue> (string prototype, OptionAction<TKey, TValue> action)
		{
			return Add (prototype, null, action);
		}

		public OptionSet Add<TKey, TValue> (string prototype, string description, OptionAction<TKey, TValue> action)
		{
			return Add (new ActionOption<TKey, TValue> (prototype, description, action));
		}

		protected virtual OptionContext CreateOptionContext ()
		{
			return new OptionContext (this);
		}

#if LINQ
		public List<string> Parse (IEnumerable<string> arguments)
		{
			bool process = true;
			OptionContext c = CreateOptionContext ();
			c.OptionIndex = -1;
			var def = GetOptionForName ("<>");
			var unprocessed = 
				from argument in arguments
				where ++c.OptionIndex >= 0 && (process || def != null)
					? process
						? argument == "--" 
							? (process = false)
							: !Parse (argument, c)
								? def != null 
									? Unprocessed (null, def, c, argument) 
									: true
								: false
						: def != null 
							? Unprocessed (null, def, c, argument)
							: true
					: true
				select argument;
			List<string> r = unprocessed.ToList ();
			if (c.Option != null)
				c.Option.Invoke (c);
			return r;
		}
#else
		public List<string> Parse (IEnumerable<string> arguments)
		{
			OptionContext c = CreateOptionContext ();
			c.OptionIndex = -1;
			bool process = true;
			List<string> unprocessed = new List<string> ();
			Option def = Contains ("<>") ? this ["<>"] : null;
			foreach (string argument in arguments) {
				++c.OptionIndex;
				if (argument == "--") {
					process = false;
					continue;
				}
				if (!process) {
					Unprocessed (unprocessed, def, c, argument);
					continue;
				}
				if (!Parse (argument, c))
					Unprocessed (unprocessed, def, c, argument);
			}
			if (c.Option != null)
				c.Option.Invoke (c);
			return unprocessed;
		}
#endif

		private static bool Unprocessed (ICollection<string> extra, Option def, OptionContext c, string argument)
		{
			if (def == null) {
				extra.Add (argument);
				return false;
			}
			c.OptionValues.Add (argument);
			c.Option = def;
			c.Option.Invoke (c);
			return false;
		}

		private readonly Regex ValueOption = new Regex (
			@"^(?<flag>--|-|/)(?<name>[^:=]+)((?<sep>[:=])(?<value>.*))?$");

		protected bool GetOptionParts (string argument, out string flag, out string name, out string sep, out string value)
		{
			if (argument == null)
				throw new ArgumentNullException ("argument");

			flag = name = sep = value = null;
			Match m = ValueOption.Match (argument);
			if (!m.Success) {
				return false;
			}
			flag  = m.Groups ["flag"].Value;
			name  = m.Groups ["name"].Value;
			if (m.Groups ["sep"].Success && m.Groups ["value"].Success) {
				sep   = m.Groups ["sep"].Value;
				value = m.Groups ["value"].Value;
			}
			return true;
		}

		protected virtual bool Parse (string argument, OptionContext c)
		{
			if (c.Option != null) {
				ParseValue (argument, c);
				return true;
			}

			string f, n, s, v;
			if (!GetOptionParts (argument, out f, out n, out s, out v))
				return false;

			Option p;
			if (Contains (n)) {
				p = this [n];
				c.OptionName = f + n;
				c.Option     = p;
				switch (p.OptionValueType) {
					case OptionValueType.None:
						c.OptionValues.Add (n);
						c.Option.Invoke (c);
						break;
					case OptionValueType.Optional:
					case OptionValueType.Required: 
						ParseValue (v, c);
						break;
				}
				return true;
			}
			// no match; is it a bool option?
			if (ParseBool (argument, n, c))
				return true;
			// is it a bundled option?
			if (ParseBundledValue (f, string.Concat (n + s + v), c))
				return true;

			return false;
		}

		private void ParseValue (string option, OptionContext c)
		{
			if (option != null)
				foreach (string o in c.Option.ValueSeparators != null 
						? option.Split (c.Option.ValueSeparators, StringSplitOptions.None)
						: new string[]{option}) {
					c.OptionValues.Add (o);
				}
			if (c.OptionValues.Count == c.Option.MaxValueCount || 
					c.Option.OptionValueType == OptionValueType.Optional)
				c.Option.Invoke (c);
			else if (c.OptionValues.Count > c.Option.MaxValueCount) {
				throw new OptionException (localizer (string.Format (
								"Error: Found {0} option values when expecting {1}.", 
								c.OptionValues.Count, c.Option.MaxValueCount)),
						c.OptionName);
			}
		}

		private bool ParseBool (string option, string n, OptionContext c)
		{
			Option p;
			string rn;
			if (n.Length >= 1 && (n [n.Length-1] == '+' || n [n.Length-1] == '-') &&
					Contains ((rn = n.Substring (0, n.Length-1)))) {
				p = this [rn];
				string v = n [n.Length-1] == '+' ? option : null;
				c.OptionName  = option;
				c.Option      = p;
				c.OptionValues.Add (v);
				p.Invoke (c);
				return true;
			}
			return false;
		}

		private bool ParseBundledValue (string f, string n, OptionContext c)
		{
			if (f != "-")
				return false;
			for (int i = 0; i < n.Length; ++i) {
				Option p;
				string opt = f + n [i].ToString ();
				string rn = n [i].ToString ();
				if (!Contains (rn)) {
					if (i == 0)
						return false;
					throw new OptionException (string.Format (localizer (
									"Cannot bundle unregistered option '{0}'."), opt), opt);
				}
				p = this [rn];
				switch (p.OptionValueType) {
					case OptionValueType.None:
						Invoke (c, opt, n, p);
						break;
					case OptionValueType.Optional:
					case OptionValueType.Required: {
						string v     = n.Substring (i+1);
						c.Option     = p;
						c.OptionName = opt;
						ParseValue (v.Length != 0 ? v : null, c);
						return true;
					}
					default:
						throw new InvalidOperationException ("Unknown OptionValueType: " + p.OptionValueType);
				}
			}
			return true;
		}

		private static void Invoke (OptionContext c, string name, string value, Option option)
		{
			c.OptionName  = name;
			c.Option      = option;
			c.OptionValues.Add (value);
			option.Invoke (c);
		}

		private const int OptionWidth = 29;

		public void WriteOptionDescriptions (TextWriter o)
		{
			foreach (Option p in this) {
				int written = 0;
				if (!WriteOptionPrototype (o, p, ref written))
					continue;

				if (written < OptionWidth)
					o.Write (new string (' ', OptionWidth - written));
				else {
					o.WriteLine ();
					o.Write (new string (' ', OptionWidth));
				}

				List<string> lines = GetLines (localizer (GetDescription (p.Description)));
				o.WriteLine (lines [0]);
				string prefix = new string (' ', OptionWidth+2);
				for (int i = 1; i < lines.Count; ++i) {
					o.Write (prefix);
					o.WriteLine (lines [i]);
				}
			}
		}

		bool WriteOptionPrototype (TextWriter o, Option p, ref int written)
		{
			string[] names = p.Names;

			int i = GetNextOptionIndex (names, 0);
			if (i == names.Length)
				return false;

			if (names [i].Length == 1) {
				Write (o, ref written, "  -");
				Write (o, ref written, names [0]);
			}
			else {
				Write (o, ref written, "      --");
				Write (o, ref written, names [0]);
			}

			for ( i = GetNextOptionIndex (names, i+1); 
					i < names.Length; i = GetNextOptionIndex (names, i+1)) {
				Write (o, ref written, ", ");
				Write (o, ref written, names [i].Length == 1 ? "-" : "--");
				Write (o, ref written, names [i]);
			}

			if (p.OptionValueType == OptionValueType.Optional ||
					p.OptionValueType == OptionValueType.Required) {
				if (p.OptionValueType == OptionValueType.Optional) {
					Write (o, ref written, localizer ("["));
				}
				Write (o, ref written, localizer ("=" + GetArgumentName (0, p.MaxValueCount, p.Description)));
				string sep = p.ValueSeparators != null && p.ValueSeparators.Length > 0 
					? p.ValueSeparators [0]
					: " ";
				for (int c = 1; c < p.MaxValueCount; ++c) {
					Write (o, ref written, localizer (sep + GetArgumentName (c, p.MaxValueCount, p.Description)));
				}
				if (p.OptionValueType == OptionValueType.Optional) {
					Write (o, ref written, localizer ("]"));
				}
			}
			return true;
		}

		static int GetNextOptionIndex (string[] names, int i)
		{
			while (i < names.Length && names [i] == "<>") {
				++i;
			}
			return i;
		}

		static void Write (TextWriter o, ref int n, string s)
		{
			n += s.Length;
			o.Write (s);
		}

		private static string GetArgumentName (int index, int maxIndex, string description)
		{
			if (description == null)
				return maxIndex == 1 ? "VALUE" : "VALUE" + (index + 1);
			string[] nameStart;
			if (maxIndex == 1)
				nameStart = new string[]{"{0:", "{"};
			else
				nameStart = new string[]{"{" + index + ":"};
			for (int i = 0; i < nameStart.Length; ++i) {
				int start, j = 0;
				do {
					start = description.IndexOf (nameStart [i], j);
				} while (start >= 0 && j != 0 ? description [j++ - 1] == '{' : false);
				if (start == -1)
					continue;
				int end = description.IndexOf ("}", start);
				if (end == -1)
					continue;
				return description.Substring (start + nameStart [i].Length, end - start - nameStart [i].Length);
			}
			return maxIndex == 1 ? "VALUE" : "VALUE" + (index + 1);
		}

		private static string GetDescription (string description)
		{
			if (description == null)
				return string.Empty;
			StringBuilder sb = new StringBuilder (description.Length);
			int start = -1;
			for (int i = 0; i < description.Length; ++i) {
				switch (description [i]) {
					case '{':
						if (i == start) {
							sb.Append ('{');
							start = -1;
						}
						else if (start < 0)
							start = i + 1;
						break;
					case '}':
						if (start < 0) {
							if ((i+1) == description.Length || description [i+1] != '}')
								throw new InvalidOperationException ("Invalid option description: " + description);
							++i;
							sb.Append ("}");
						}
						else {
							sb.Append (description.Substring (start, i - start));
							start = -1;
						}
						break;
					case ':':
						if (start < 0)
							goto default;
						start = i + 1;
						break;
					default:
						if (start < 0)
							sb.Append (description [i]);
						break;
				}
			}
			return sb.ToString ();
		}

		private static List<string> GetLines (string description)
		{
			List<string> lines = new List<string> ();
			if (string.IsNullOrEmpty (description)) {
				lines.Add (string.Empty);
				return lines;
			}
			int length = 80 - OptionWidth - 2;
			int start = 0, end;
			do {
				end = GetLineEnd (start, length, description);
				bool cont = false;
				if (end < description.Length) {
					char c = description [end];
					if (c == '-' || (char.IsWhiteSpace (c) && c != '\n'))
						++end;
					else if (c != '\n') {
						cont = true;
						--end;
					}
				}
				lines.Add (description.Substring (start, end - start));
				if (cont) {
					lines [lines.Count-1] += "-";
				}
				start = end;
				if (start < description.Length && description [start] == '\n')
					++start;
			} while (end < description.Length);
			return lines;
		}

		private static int GetLineEnd (int start, int length, string description)
		{
			int end = Math.Min (start + length, description.Length);
			int sep = -1;
			for (int i = start; i < end; ++i) {
				switch (description [i]) {
					case ' ':
					case '\t':
					case '\v':
					case '-':
					case ',':
					case '.':
					case ';':
						sep = i;
						break;
					case '\n':
						return i;
				}
			}
			if (sep == -1 || end == description.Length)
				return end;
			return sep;
		}
	}
}




================================================
File: Confuser.CLI/Program.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Xml;
using Confuser.Core;
using Confuser.Core.Project;
using NDesk.Options;

namespace Confuser.CLI {
	internal class Program {
		static int Main(string[] args) {
			ConsoleColor original = Console.ForegroundColor;
			Console.ForegroundColor = ConsoleColor.White;
			string originalTitle = Console.Title;
			Console.Title = "ConfuserEx";
			try {
				bool noPause = false;
				bool debug = false;
				string outDir = null;
				List<string> probePaths = new List<string>();
				List<string> plugins = new List<string>();
				var p = new OptionSet {
					{
						"n|nopause", "no pause after finishing protection.",
						value => { noPause = (value != null); }
					}, {
						"o|out=", "specifies output directory.",
						value => { outDir = value; }
					}, {
						"probe=", "specifies probe directory.",
						value => { probePaths.Add(value); }
					}, {
						"plugin=", "specifies plugin path.",
						value => { plugins.Add(value); }
					}, {
						"debug", "specifies debug symbol generation.",
						value => { debug = (value != null); }
					}
				};

				List<string> files;
				try {
					files = p.Parse(args);
					if (files.Count == 0)
						throw new ArgumentException("No input files specified.");
				}
				catch (Exception ex) {
					Console.Write("ConfuserEx.CLI: ");
					Console.WriteLine(ex.Message);
					PrintUsage();
					return -1;
				}

				var parameters = new ConfuserParameters();

				if (files.Count == 1 && Path.GetExtension(files[0]) == ".crproj") {
					var proj = new ConfuserProject();
					try {
						var xmlDoc = new XmlDocument();
						xmlDoc.Load(files[0]);
						proj.Load(xmlDoc);
						proj.BaseDirectory = Path.Combine(Path.GetDirectoryName(files[0]), proj.BaseDirectory);
					}
					catch (Exception ex) {
						WriteLineWithColor(ConsoleColor.Red, "Failed to load project:");
						WriteLineWithColor(ConsoleColor.Red, ex.ToString());
						return -1;
					}

					parameters.Project = proj;
				}
				else {
					if (string.IsNullOrEmpty(outDir)) {
						Console.WriteLine("ConfuserEx.CLI: No output directory specified.");
						PrintUsage();
						return -1;
					}

					var proj = new ConfuserProject();

					if (Path.GetExtension(files[files.Count - 1]) == ".crproj") {
						var templateProj = new ConfuserProject();
						var xmlDoc = new XmlDocument();
						xmlDoc.Load(files[files.Count - 1]);
						templateProj.Load(xmlDoc);
						files.RemoveAt(files.Count - 1);

						foreach (var rule in templateProj.Rules)
							proj.Rules.Add(rule);
					}

					// Generate a ConfuserProject for input modules
					// Assuming first file = main module
					foreach (var input in files)
						proj.Add(new ProjectModule { Path = input });

					proj.BaseDirectory = Path.GetDirectoryName(files[0]);
					proj.OutputDirectory = outDir;
					foreach (var path in probePaths)
						proj.ProbePaths.Add(path);
					foreach (var path in plugins)
						proj.PluginPaths.Add(path);
					proj.Debug = debug;
					parameters.Project = proj;
				}

				int retVal = RunProject(parameters);

				if (NeedPause() && !noPause) {
					Console.WriteLine("Press any key to continue...");
					Console.ReadKey(true);
				}

				return retVal;
			}
			finally {
				Console.ForegroundColor = original;
				Console.Title = originalTitle;
			}
		}

		static int RunProject(ConfuserParameters parameters) {
			var logger = new ConsoleLogger();
			parameters.Logger = logger;

			Console.Title = "ConfuserEx - Running...";
			ConfuserEngine.Run(parameters).Wait();

			return logger.ReturnValue;
		}

		static bool NeedPause() {
			return Debugger.IsAttached || string.IsNullOrEmpty(Environment.GetEnvironmentVariable("PROMPT"));
		}

		static void PrintUsage() {
			WriteLine("Usage:");
			WriteLine("Confuser.CLI -n|noPause <project configuration>");
			WriteLine("Confuser.CLI -n|noPause -o|out=<output directory> <modules>");
			WriteLine("    -n|noPause : no pause after finishing protection.");
			WriteLine("    -o|out     : specifies output directory.");
			WriteLine("    -probe     : specifies probe directory.");
			WriteLine("    -plugin    : specifies plugin path.");
			WriteLine("    -debug     : specifies debug symbol generation.");
		}

		static void WriteLineWithColor(ConsoleColor color, string txt) {
			ConsoleColor original = Console.ForegroundColor;
			Console.ForegroundColor = color;
			Console.WriteLine(txt);
			Console.ForegroundColor = original;
		}

		static void WriteLine(string txt) {
			Console.WriteLine(txt);
		}

		static void WriteLine() {
			Console.WriteLine();
		}

		class ConsoleLogger : ILogger {
			readonly DateTime begin;

			public ConsoleLogger() {
				begin = DateTime.Now;
			}

			public int ReturnValue { get; private set; }

			public void Debug(string msg) {
				WriteLineWithColor(ConsoleColor.Gray, "[DEBUG] " + msg);
			}

			public void DebugFormat(string format, params object[] args) {
				WriteLineWithColor(ConsoleColor.Gray, "[DEBUG] " + string.Format(format, args));
			}

			public void Info(string msg) {
				WriteLineWithColor(ConsoleColor.White, " [INFO] " + msg);
			}

			public void InfoFormat(string format, params object[] args) {
				WriteLineWithColor(ConsoleColor.White, " [INFO] " + string.Format(format, args));
			}

			public void Warn(string msg) {
				WriteLineWithColor(ConsoleColor.Yellow, " [WARN] " + msg);
			}

			public void WarnFormat(string format, params object[] args) {
				WriteLineWithColor(ConsoleColor.Yellow, " [WARN] " + string.Format(format, args));
			}

			public void WarnException(string msg, Exception ex) {
				WriteLineWithColor(ConsoleColor.Yellow, " [WARN] " + msg);
				WriteLineWithColor(ConsoleColor.Yellow, "Exception: " + ex);
			}

			public void Error(string msg) {
				WriteLineWithColor(ConsoleColor.Red, "[ERROR] " + msg);
			}

			public void ErrorFormat(string format, params object[] args) {
				WriteLineWithColor(ConsoleColor.Red, "[ERROR] " + string.Format(format, args));
			}

			public void ErrorException(string msg, Exception ex) {
				WriteLineWithColor(ConsoleColor.Red, "[ERROR] " + msg);
				WriteLineWithColor(ConsoleColor.Red, "Exception: " + ex);
			}

			public void Progress(int progress, int overall) { }

			public void EndProgress() { }

			public void Finish(bool successful) {
				DateTime now = DateTime.Now;
				string timeString = string.Format(
					"at {0}, {1}:{2:d2} elapsed.",
					now.ToShortTimeString(),
					(int)now.Subtract(begin).TotalMinutes,
					now.Subtract(begin).Seconds);
				if (successful) {
					Console.Title = "ConfuserEx - Success";
					WriteLineWithColor(ConsoleColor.Green, "Finished " + timeString);
					ReturnValue = 0;
				}
				else {
					Console.Title = "ConfuserEx - Fail";
					WriteLineWithColor(ConsoleColor.Red, "Failed " + timeString);
					ReturnValue = 1;
				}
			}
		}
	}
}


================================================
File: Confuser.CLI/Properties/AssemblyInfo.cs
================================================
ï»¿using System;
using System.Reflection;

[assembly: AssemblyTitle("ConfuserEx Command-line")]
[assembly: AssemblyDescription("Command-line interface of ConfuserEx")]


================================================
File: Confuser.Core/Annotations.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Linq;

namespace Confuser.Core {
	/// <summary>
	///     Provides methods to annotate objects.
	/// </summary>
	/// <remarks>
	///     The annotations are stored using <see cref="WeakReference" />
	/// </remarks>
	public class Annotations {
		readonly Dictionary<object, ListDictionary> annotations = new Dictionary<object, ListDictionary>(WeakReferenceComparer.Instance);

		/// <summary>
		///     Retrieves the annotation on the specified object associated with the specified key.
		/// </summary>
		/// <typeparam name="TValue">The type of the value.</typeparam>
		/// <param name="obj">The object.</param>
		/// <param name="key">The key of annotation.</param>
		/// <param name="defValue">The default value if the specified annotation does not exists on the object.</param>
		/// <returns>The value of annotation, or default value if the annotation does not exist.</returns>
		/// <exception cref="System.ArgumentNullException">
		///     <paramref name="obj" /> or <paramref name="key" /> is <c>null</c>.
		/// </exception>
		public TValue Get<TValue>(object obj, object key, TValue defValue = default(TValue)) {
			if (obj == null)
				throw new ArgumentNullException("obj");
			if (key == null)
				throw new ArgumentNullException("key");

			ListDictionary objAnno;
			if (!annotations.TryGetValue(obj, out objAnno))
				return defValue;
			if (!objAnno.Contains(key))
				return defValue;

			Type valueType = typeof(TValue);
			if (valueType.IsValueType)
				return (TValue)Convert.ChangeType(objAnno[key], typeof(TValue));
			return (TValue)objAnno[key];
		}

		/// <summary>
		///     Retrieves the annotation on the specified object associated with the specified key.
		/// </summary>
		/// <typeparam name="TValue">The type of the value.</typeparam>
		/// <param name="obj">The object.</param>
		/// <param name="key">The key of annotation.</param>
		/// <param name="defValueFactory">The default value factory function.</param>
		/// <returns>The value of annotation, or default value if the annotation does not exist.</returns>
		/// <exception cref="System.ArgumentNullException">
		///     <paramref name="obj" /> or <paramref name="key" /> is <c>null</c>.
		/// </exception>
		public TValue GetLazy<TValue>(object obj, object key, Func<object, TValue> defValueFactory) {
			if (obj == null)
				throw new ArgumentNullException("obj");
			if (key == null)
				throw new ArgumentNullException("key");

			ListDictionary objAnno;
			if (!annotations.TryGetValue(obj, out objAnno))
				return defValueFactory(key);
			if (!objAnno.Contains(key))
				return defValueFactory(key);

			Type valueType = typeof(TValue);
			if (valueType.IsValueType)
				return (TValue)Convert.ChangeType(objAnno[key], typeof(TValue));
			return (TValue)objAnno[key];
		}

		/// <summary>
		///     Retrieves or create the annotation on the specified object associated with the specified key.
		/// </summary>
		/// <typeparam name="TValue">The type of the value.</typeparam>
		/// <param name="obj">The object.</param>
		/// <param name="key">The key of annotation.</param>
		/// <param name="factory">The factory function to create the annotation value when the annotation does not exist.</param>
		/// <returns>The value of annotation, or the newly created value.</returns>
		/// <exception cref="System.ArgumentNullException">
		///     <paramref name="obj" /> or <paramref name="key" /> is <c>null</c>.
		/// </exception>
		public TValue GetOrCreate<TValue>(object obj, object key, Func<object, TValue> factory) {
			if (obj == null)
				throw new ArgumentNullException("obj");
			if (key == null)
				throw new ArgumentNullException("key");

			ListDictionary objAnno;
			if (!annotations.TryGetValue(obj, out objAnno))
				objAnno = annotations[new WeakReferenceKey(obj)] = new ListDictionary();
			TValue ret;
			if (objAnno.Contains(key)) {
				Type valueType = typeof(TValue);
				if (valueType.IsValueType)
					return (TValue)Convert.ChangeType(objAnno[key], typeof(TValue));
				return (TValue)objAnno[key];
			}
			objAnno[key] = ret = factory(key);
			return ret;
		}

		/// <summary>
		///     Sets an annotation on the specified object.
		/// </summary>
		/// <typeparam name="TValue">The type of the value.</typeparam>
		/// <param name="obj">The object.</param>
		/// <param name="key">The key of annotation.</param>
		/// <param name="value">The value of annotation.</param>
		/// <exception cref="System.ArgumentNullException">
		///     <paramref name="obj" /> or <paramref name="key" /> is <c>null</c>.
		/// </exception>
		public void Set<TValue>(object obj, object key, TValue value) {
			if (obj == null)
				throw new ArgumentNullException("obj");
			if (key == null)
				throw new ArgumentNullException("key");

			ListDictionary objAnno;
			if (!annotations.TryGetValue(obj, out objAnno))
				objAnno = annotations[new WeakReferenceKey(obj)] = new ListDictionary();
			objAnno[key] = value;
		}

		/// <summary>
		///     Trims the annotations of unreachable objects from this instance.
		/// </summary>
		public void Trim() {
			foreach (object key in annotations.Where(kvp => !((WeakReferenceKey)kvp.Key).IsAlive).Select(kvp => kvp.Key))
				annotations.Remove(key);
		}

		/// <summary>
		///     Equality comparer of weak references.
		/// </summary>
		class WeakReferenceComparer : IEqualityComparer<object> {
			/// <summary>
			///     The singleton instance of this comparer.
			/// </summary>
			public static readonly WeakReferenceComparer Instance = new WeakReferenceComparer();

			/// <summary>
			///     Prevents a default instance of the <see cref="WeakReferenceComparer" /> class from being created.
			/// </summary>
			WeakReferenceComparer() { }

			/// <inheritdoc />
			public new bool Equals(object x, object y) {
				if (y is WeakReferenceKey && !(x is WeakReference))
					return Equals(y, x);
				var xWeak = x as WeakReferenceKey;
				var yWeak = y as WeakReferenceKey;
				if (xWeak != null && yWeak != null) {
					return xWeak.IsAlive && yWeak.IsAlive && ReferenceEquals(xWeak.Target, yWeak.Target);
				}
				if (xWeak != null && yWeak == null) {
					return xWeak.IsAlive && ReferenceEquals(xWeak.Target, y);
				}
				if (xWeak == null && yWeak == null) {
					return xWeak.IsAlive && ReferenceEquals(xWeak.Target, y);
				}
				throw new UnreachableException();
			}

			/// <inheritdoc />
			public int GetHashCode(object obj) {
				if (obj is WeakReferenceKey)
					return ((WeakReferenceKey)obj).HashCode;
				return obj.GetHashCode();
			}
		}

		/// <summary>
		///     Represent a key using <see cref="WeakReference" />.
		/// </summary>
		class WeakReferenceKey : WeakReference {
			/// <inheritdoc />
			public WeakReferenceKey(object target)
				: base(target) {
				HashCode = target.GetHashCode();
			}

			/// <summary>
			///     Gets the hash code of the target object.
			/// </summary>
			/// <value>The hash code.</value>
			public int HashCode { get; private set; }
		}
	}
}


================================================
File: Confuser.Core/Confuser.Core.csproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProductVersion>8.0.30703</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{BEB67A6E-4C54-4DE5-8C6B-2C12F44A7B92}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>Confuser.Core</RootNamespace>
    <AssemblyName>Confuser.Core</AssemblyName>
    <TargetFrameworkVersion Condition=" !$(DefineConstants.Contains('NET45')) ">v4.0</TargetFrameworkVersion>
    <TargetFrameworkVersion Condition=" $(DefineConstants.Contains('NET45')) ">v4.5</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <SolutionDir Condition="$(SolutionDir) == '' Or $(SolutionDir) == '*Undefined*'">..\</SolutionDir>
    <RestorePackages>true</RestorePackages>
    <TargetFrameworkProfile />
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>..\Debug\bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <DocumentationFile>..\Debug\bin\Confuser.Core.xml</DocumentationFile>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>..\Release\bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <DocumentationFile>..\Release\bin\Confuser.Core.xml</DocumentationFile>
  </PropertyGroup>
  <PropertyGroup>
    <SignAssembly>true</SignAssembly>
  </PropertyGroup>
  <PropertyGroup>
    <AssemblyOriginatorKeyFile>..\ConfuserEx.snk</AssemblyOriginatorKeyFile>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="..\GlobalAssemblyInfo.cs">
      <Link>Properties\GlobalAssemblyInfo.cs</Link>
    </Compile>
    <Compile Include="Annotations.cs" />
    <Compile Include="API\APIStore.cs" />
    <Compile Include="API\IDataStore.cs" />
    <Compile Include="API\IOpaquePredicate.cs" />
    <Compile Include="ModuleSorter.cs" />
    <Compile Include="Helpers\ControlFlowGraph.cs" />
    <Compile Include="Helpers\KeySequence.cs" />
    <Compile Include="LZMA\Common\CRC.cs" />
    <Compile Include="LZMA\Common\InBuffer.cs" />
    <Compile Include="LZMA\Common\OutBuffer.cs" />
    <Compile Include="LZMA\Compress\LZMA\LzmaBase.cs" />
    <Compile Include="LZMA\Compress\LZMA\LzmaDecoder.cs" />
    <Compile Include="LZMA\Compress\LZMA\LzmaEncoder.cs" />
    <Compile Include="LZMA\Compress\LZ\IMatchFinder.cs" />
    <Compile Include="LZMA\Compress\LZ\LzBinTree.cs" />
    <Compile Include="LZMA\Compress\LZ\LzInWindow.cs" />
    <Compile Include="LZMA\Compress\LZ\LzOutWindow.cs" />
    <Compile Include="LZMA\Compress\RangeCoder\RangeCoder.cs" />
    <Compile Include="LZMA\Compress\RangeCoder\RangeCoderBit.cs" />
    <Compile Include="LZMA\Compress\RangeCoder\RangeCoderBitTree.cs" />
    <Compile Include="LZMA\ICoder.cs" />
    <Compile Include="ConfuserEngine.cs" />
    <Compile Include="ConfuserException.cs" />
    <Compile Include="ConfuserParameters.cs" />
    <Compile Include="CoreComponent.cs" />
    <Compile Include="DependencyResolver.cs" />
    <Compile Include="ConfuserComponent.cs" />
    <Compile Include="DnlibUtils.cs" />
    <Compile Include="Helpers\InjectHelper.cs" />
    <Compile Include="Helpers\MutationHelper.cs" />
    <Compile Include="ILogger.cs" />
    <Compile Include="Marker.cs" />
    <Compile Include="MarkerResult.cs" />
    <Compile Include="ModuleWriterListener.cs" />
    <Compile Include="NativeEraser.cs" />
    <Compile Include="ObfAttrMarker.cs" />
    <Compile Include="ObfAttrParser.cs" />
    <Compile Include="PluginDiscovery.cs" />
    <Compile Include="NullLogger.cs" />
    <Compile Include="Packer.cs" />
    <Compile Include="Project\ConfuserProject.cs" />
    <Compile Include="Project\InvalidPatternException.cs" />
    <Compile Include="Project\PatternParser.cs" />
    <Compile Include="Project\Patterns\AndOperator.cs" />
    <Compile Include="Project\Patterns\HasAttrFunction.cs" />
    <Compile Include="Project\Patterns\IsTypeFunction.cs" />
    <Compile Include="Project\Patterns\InheritsFunction.cs" />
    <Compile Include="Project\Patterns\IsPublicFunction.cs" />
    <Compile Include="Project\Patterns\FullNameFunction.cs" />
    <Compile Include="Project\Patterns\NotOperator.cs" />
    <Compile Include="Project\Patterns\MemberTypeFunction.cs" />
    <Compile Include="Project\Patterns\DeclTypeFunction.cs" />
    <Compile Include="Project\Patterns\MatchFunction.cs" />
    <Compile Include="Project\Patterns\ModuleFunction.cs" />
    <Compile Include="Project\Patterns\NamespaceFunction.cs" />
    <Compile Include="Project\Patterns\OrOperator.cs" />
    <Compile Include="Project\Patterns\LiteralExpression.cs" />
    <Compile Include="Project\Patterns\NameFunction.cs" />
    <Compile Include="Project\Patterns\PatternExpression.cs" />
    <Compile Include="Project\Patterns\PatternFunction.cs" />
    <Compile Include="Project\Patterns\PatternOperator.cs" />
    <Compile Include="Project\PatternToken.cs" />
    <Compile Include="Project\PatternTokenizer.cs" />
    <Compile Include="Protection.cs" />
    <Compile Include="ProtectionDependencyAttributes.cs" />
    <Compile Include="ProtectionPhase.cs" />
    <Compile Include="ProtectionSettings.cs" />
    <Compile Include="ProtectionTargets.cs" />
    <Compile Include="ConfuserContext.cs" />
    <Compile Include="ProtectionParameters.cs" />
    <Compile Include="ProtectionPipeline.cs" />
    <Compile Include="ProtectionPreset.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="ServiceRegistry.cs" />
    <Compile Include="Services\CompressionService.cs" />
    <Compile Include="Services\RuntimeService.cs" />
    <Compile Include="Services\MarkerService.cs" />
    <Compile Include="Services\RandomService.cs" />
    <Compile Include="Services\TraceService.cs" />
    <Compile Include="UnreachableException.cs" />
    <Compile Include="Utils.cs" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\dnlib\src\dnlib.csproj">
      <Project>{FDFC1237-143F-4919-8318-4926901F4639}</Project>
      <Name>dnlib</Name>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup>
    <EmbeddedResource Include="Project\ConfuserPrj.xsd">
      <SubType>Designer</SubType>
    </EmbeddedResource>
  </ItemGroup>
  <ItemGroup>
    <None Include="..\ConfuserEx.snk">
      <Link>Properties\ConfuserEx.snk</Link>
    </None>
  </ItemGroup>
  <ItemGroup />
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <Import Project="$(SolutionDir)\.nuget\NuGet.targets" Condition="Exists('$(SolutionDir)\.nuget\NuGet.targets')" />
  <Target Name="EnsureNuGetPackageBuildImports" BeforeTargets="PrepareForBuild">
    <PropertyGroup>
      <ErrorText>This project references NuGet package(s) that are missing on this computer. Enable NuGet Package Restore to download them.  For more information, see http://go.microsoft.com/fwlink/?LinkID=322105. The missing file is {0}.</ErrorText>
    </PropertyGroup>
    <Error Condition="!Exists('$(SolutionDir)\.nuget\NuGet.targets')" Text="$([System.String]::Format('$(ErrorText)', '$(SolutionDir)\.nuget\NuGet.targets'))" />
  </Target>
  <Target Name="BeforeBuild">
    <MSBuild Projects="$(SolutionDir)\Build\UpdateVersion.csproj" Targets="Build" Properties="Configuration=Release" />
    <Exec WorkingDirectory="$(SolutionDir)\Build" Command="UpdateVersion.exe &quot;$(SolutionDir)" Timeout="60000" Condition=" '$(OS)' == 'Windows_NT' " />
    <Exec WorkingDirectory="$(SolutionDir)\Build" Command="mono UpdateVersion.exe &quot;$(SolutionDir)&quot;" Timeout="60000" Condition=" '$(OS)' != 'Windows_NT' " />
  </Target>
</Project>


================================================
File: Confuser.Core/ConfuserComponent.cs
================================================
ï»¿using System;

namespace Confuser.Core {
	/// <summary>
	///     Represent a component in Confuser
	/// </summary>
	public abstract class ConfuserComponent {
		/// <summary>
		///     Gets the name of component.
		/// </summary>
		/// <value>The name of component.</value>
		public abstract string Name { get; }

		/// <summary>
		///     Gets the description of component.
		/// </summary>
		/// <value>The description of component.</value>
		public abstract string Description { get; }

		/// <summary>
		///     Gets the identifier of component used by users.
		/// </summary>
		/// <value>The identifier of component.</value>
		public abstract string Id { get; }

		/// <summary>
		///     Gets the full identifier of component used in Confuser.
		/// </summary>
		/// <value>The full identifier of component.</value>
		public abstract string FullId { get; }

		/// <summary>
		///     Initializes the component.
		/// </summary>
		/// <param name="context">The working context.</param>
		protected internal abstract void Initialize(ConfuserContext context);

		/// <summary>
		///     Inserts protection stages into processing pipeline.
		/// </summary>
		/// <param name="pipeline">The processing pipeline.</param>
		protected internal abstract void PopulatePipeline(ProtectionPipeline pipeline);
	}
}


================================================
File: Confuser.Core/ConfuserContext.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Threading;
using Confuser.Core.Project;
using dnlib.DotNet;
using dnlib.DotNet.Writer;

namespace Confuser.Core {
	/// <summary>
	///     Context providing information on the current protection process.
	/// </summary>
	public class ConfuserContext {
		readonly Annotations annotations = new Annotations();
		readonly ServiceRegistry registry = new ServiceRegistry();
		internal CancellationToken token;

		/// <summary>
		///     Gets the logger used for logging events.
		/// </summary>
		/// <value>The logger.</value>
		public ILogger Logger { get; internal set; }

		/// <summary>
		///     Gets the project being processed.
		/// </summary>
		/// <value>The project.</value>
		public ConfuserProject Project { get; internal set; }

		internal bool PackerInitiated { get; set; }

		/// <summary>
		///     Gets the annotation storage.
		/// </summary>
		/// <value>The annotation storage.</value>
		public Annotations Annotations {
			get { return annotations; }
		}

		/// <summary>
		///     Gets the service registry.
		/// </summary>
		/// <value>The service registry.</value>
		public ServiceRegistry Registry {
			get { return registry; }
		}

		/// <summary>
		///     Gets the assembly resolver.
		/// </summary>
		/// <value>The assembly resolver.</value>
		public AssemblyResolver Resolver { get; internal set; }

		/// <summary>
		///     Gets the modules being protected.
		/// </summary>
		/// <value>The modules being protected.</value>
		public IList<ModuleDefMD> Modules { get; internal set; }

		/// <summary>
		///     Gets the external modules.
		/// </summary>
		/// <value>The external modules.</value>
		public IList<byte[]> ExternalModules { get; internal set; }

		/// <summary>
		///     Gets the base directory.
		/// </summary>
		/// <value>The base directory.</value>
		public string BaseDirectory { get; internal set; }

		/// <summary>
		///     Gets the output directory.
		/// </summary>
		/// <value>The output directory.</value>
		public string OutputDirectory { get; internal set; }

		/// <summary>
		///     Gets the packer.
		/// </summary>
		/// <value>The packer.</value>
		public Packer Packer { get; internal set; }

		/// <summary>
		///     Gets the current processing pipeline.
		/// </summary>
		/// <value>The processing pipeline.</value>
		public ProtectionPipeline Pipeline { get; internal set; }

		/// <summary>
		///     Gets the <c>byte[]</c> of modules after protected, or null if module is not protected yet.
		/// </summary>
		/// <value>The list of <c>byte[]</c> of protected modules.</value>
		public IList<byte[]> OutputModules { get; internal set; }

		/// <summary>
		///     Gets the <c>byte[]</c> of module debug symbols after protected, or null if module is not protected yet.
		/// </summary>
		/// <value>The list of <c>byte[]</c> of module debug symbols.</value>
		public IList<byte[]> OutputSymbols { get; internal set; }

		/// <summary>
		///     Gets the relative output paths of module, or null if module is not protected yet.
		/// </summary>
		/// <value>The relative output paths of protected modules.</value>
		public IList<string> OutputPaths { get; internal set; }

		/// <summary>
		///     Gets the current module index.
		/// </summary>
		/// <value>The current module index.</value>
		public int CurrentModuleIndex { get; internal set; }

		/// <summary>
		///     Gets the current module.
		/// </summary>
		/// <value>The current module.</value>
		public ModuleDefMD CurrentModule {
			get { return CurrentModuleIndex == -1 ? null : Modules[CurrentModuleIndex]; }
		}

		/// <summary>
		///     Gets the writer options of the current module.
		/// </summary>
		/// <value>The writer options.</value>
		public ModuleWriterOptionsBase CurrentModuleWriterOptions { get; internal set; }

		/// <summary>
		///     Gets the writer event listener of the current module.
		/// </summary>
		/// <value>The writer event listener.</value>
		public ModuleWriterListener CurrentModuleWriterListener { get; internal set; }

		/// <summary>
		///     Gets output <c>byte[]</c> of the current module
		/// </summary>
		/// <value>The output <c>byte[]</c>.</value>
		public byte[] CurrentModuleOutput { get; internal set; }

		/// <summary>
		///     Gets output <c>byte[]</c> debug symbol of the current module
		/// </summary>
		/// <value>The output <c>byte[]</c> debug symbol.</value>
		public byte[] CurrentModuleSymbol { get; internal set; }

		/// <summary>
		///		Gets the token used to indicate cancellation
		/// </summary>
		public CancellationToken CancellationToken { get { return token; } }

		/// <summary>
		///     Throws a System.OperationCanceledException if protection process has been canceled.
		/// </summary>
		/// <exception cref="OperationCanceledException">
		///     The protection process is canceled.
		/// </exception>
		public void CheckCancellation() {
			token.ThrowIfCancellationRequested();
		}

		/// <summary>
		///     Requests the current module to be written as mix-mode module, and return the native writer options.
		/// </summary>
		/// <returns>The native writer options.</returns>
		public NativeModuleWriterOptions RequestNative() {
			if (CurrentModule == null)
				return null;
			if (CurrentModuleWriterOptions == null)
				CurrentModuleWriterOptions = new NativeModuleWriterOptions(CurrentModule);

			if (CurrentModuleWriterOptions is NativeModuleWriterOptions)
				return (NativeModuleWriterOptions)CurrentModuleWriterOptions;
			var newOptions = new NativeModuleWriterOptions(CurrentModule, CurrentModuleWriterOptions.Listener);
			// Clone the current options to the new options
			newOptions.AddCheckSum = CurrentModuleWriterOptions.AddCheckSum;
			newOptions.Cor20HeaderOptions = CurrentModuleWriterOptions.Cor20HeaderOptions;
			newOptions.Logger = CurrentModuleWriterOptions.Logger;
			newOptions.MetaDataLogger = CurrentModuleWriterOptions.MetaDataLogger;
			newOptions.MetaDataOptions = CurrentModuleWriterOptions.MetaDataOptions;
			newOptions.ModuleKind = CurrentModuleWriterOptions.ModuleKind;
			newOptions.PEHeadersOptions = CurrentModuleWriterOptions.PEHeadersOptions;
			newOptions.ShareMethodBodies = CurrentModuleWriterOptions.ShareMethodBodies;
			newOptions.StrongNameKey = CurrentModuleWriterOptions.StrongNameKey;
			newOptions.StrongNamePublicKey = CurrentModuleWriterOptions.StrongNamePublicKey;
			newOptions.Win32Resources = CurrentModuleWriterOptions.Win32Resources;
			CurrentModuleWriterOptions = newOptions;
			return newOptions;
		}
	}
}


================================================
File: Confuser.Core/ConfuserEngine.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Threading;
using System.Threading.Tasks;
using Confuser.Core.Services;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using dnlib.DotNet.Writer;
using Microsoft.Win32;
using InformationalAttribute = System.Reflection.AssemblyInformationalVersionAttribute;
using ProductAttribute = System.Reflection.AssemblyProductAttribute;
using CopyrightAttribute = System.Reflection.AssemblyCopyrightAttribute;
using MethodAttributes = dnlib.DotNet.MethodAttributes;
using MethodImplAttributes = dnlib.DotNet.MethodImplAttributes;
using TypeAttributes = dnlib.DotNet.TypeAttributes;

namespace Confuser.Core {
	/// <summary>
	///     The processing engine of ConfuserEx.
	/// </summary>
	public static class ConfuserEngine {
		/// <summary>
		///     The version of ConfuserEx.
		/// </summary>
		public static readonly string Version;

		static readonly string Copyright;

		static ConfuserEngine() {
			Assembly assembly = typeof(ConfuserEngine).Assembly;
			var nameAttr = (ProductAttribute)assembly.GetCustomAttributes(typeof(ProductAttribute), false)[0];
			var verAttr = (InformationalAttribute)assembly.GetCustomAttributes(typeof(InformationalAttribute), false)[0];
			var cpAttr = (CopyrightAttribute)assembly.GetCustomAttributes(typeof(CopyrightAttribute), false)[0];
			Version = string.Format("{0} {1}", nameAttr.Product, verAttr.InformationalVersion);
			Copyright = cpAttr.Copyright;

			AppDomain.CurrentDomain.AssemblyResolve += (sender, e) => {
				try {
					var asmName = new AssemblyName(e.Name);
					foreach (var asm in AppDomain.CurrentDomain.GetAssemblies())
						if (asm.GetName().Name == asmName.Name)
							return asm;
					return null;
				}
				catch {
					return null;
				}
			};
		}

		/// <summary>
		///     Runs the engine with the specified parameters.
		/// </summary>
		/// <param name="parameters">The parameters.</param>
		/// <param name="token">The token used for cancellation.</param>
		/// <returns>Task to run the engine.</returns>
		/// <exception cref="System.ArgumentNullException">
		///     <paramref name="parameters" />.Project is <c>null</c>.
		/// </exception>
		public static Task Run(ConfuserParameters parameters, CancellationToken? token = null) {
			if (parameters.Project == null)
				throw new ArgumentNullException("parameters");
			if (token == null)
				token = new CancellationTokenSource().Token;
			return Task.Factory.StartNew(() => RunInternal(parameters, token.Value), token.Value);
		}

		/// <summary>
		///     Runs the engine.
		/// </summary>
		/// <param name="parameters">The parameters.</param>
		/// <param name="token">The cancellation token.</param>
		static void RunInternal(ConfuserParameters parameters, CancellationToken token) {
			// 1. Setup context
			var context = new ConfuserContext();
			context.Logger = parameters.GetLogger();
			context.Project = parameters.Project.Clone();
			context.PackerInitiated = parameters.PackerInitiated;
			context.token = token;

			PrintInfo(context);

			bool ok = false;
			try {
				var asmResolver = new AssemblyResolver();
				asmResolver.EnableTypeDefCache = true;
				asmResolver.DefaultModuleContext = new ModuleContext(asmResolver);
				context.Resolver = asmResolver;
				context.BaseDirectory = Path.Combine(Environment.CurrentDirectory, parameters.Project.BaseDirectory.TrimEnd(Path.DirectorySeparatorChar) + Path.DirectorySeparatorChar);
				context.OutputDirectory = Path.Combine(parameters.Project.BaseDirectory, parameters.Project.OutputDirectory.TrimEnd(Path.DirectorySeparatorChar) + Path.DirectorySeparatorChar);
				foreach (string probePath in parameters.Project.ProbePaths)
					asmResolver.PostSearchPaths.Insert(0, Path.Combine(context.BaseDirectory, probePath));

				context.CheckCancellation();

				Marker marker = parameters.GetMarker();

				// 2. Discover plugins
				context.Logger.Debug("Discovering plugins...");

				IList<Protection> prots;
				IList<Packer> packers;
				IList<ConfuserComponent> components;
				parameters.GetPluginDiscovery().GetPlugins(context, out prots, out packers, out components);

				context.Logger.InfoFormat("Discovered {0} protections, {1} packers.", prots.Count, packers.Count);

				context.CheckCancellation();

				// 3. Resolve dependency
				context.Logger.Debug("Resolving component dependency...");
				try {
					var resolver = new DependencyResolver(prots);
					prots = resolver.SortDependency();
				}
				catch (CircularDependencyException ex) {
					context.Logger.ErrorException("", ex);
					throw new ConfuserException(ex);
				}

				components.Insert(0, new CoreComponent(parameters, marker));
				foreach (Protection prot in prots)
					components.Add(prot);
				foreach (Packer packer in packers)
					components.Add(packer);

				context.CheckCancellation();

				// 4. Load modules
				context.Logger.Info("Loading input modules...");
				marker.Initalize(prots, packers);
				MarkerResult markings = marker.MarkProject(parameters.Project, context);
				context.Modules = new ModuleSorter(markings.Modules).Sort().ToList().AsReadOnly();
				foreach (var module in context.Modules)
					module.EnableTypeDefFindCache = false;
				context.OutputModules = Enumerable.Repeat<byte[]>(null, context.Modules.Count).ToArray();
				context.OutputSymbols = Enumerable.Repeat<byte[]>(null, context.Modules.Count).ToArray();
				context.OutputPaths = Enumerable.Repeat<string>(null, context.Modules.Count).ToArray();
				context.Packer = markings.Packer;
				context.ExternalModules = markings.ExternalModules;

				context.CheckCancellation();

				// 5. Initialize components
				context.Logger.Info("Initializing...");
				foreach (ConfuserComponent comp in components) {
					try {
						comp.Initialize(context);
					}
					catch (Exception ex) {
						context.Logger.ErrorException("Error occured during initialization of '" + comp.Name + "'.", ex);
						throw new ConfuserException(ex);
					}
					context.CheckCancellation();
				}

				context.CheckCancellation();

				// 6. Build pipeline
				context.Logger.Debug("Building pipeline...");
				var pipeline = new ProtectionPipeline();
				context.Pipeline = pipeline;
				foreach (ConfuserComponent comp in components) {
					comp.PopulatePipeline(pipeline);
				}

				context.CheckCancellation();

				//7. Run pipeline
				RunPipeline(pipeline, context);

				ok = true;
			}
			catch (AssemblyResolveException ex) {
				context.Logger.ErrorException("Failed to resolve an assembly, check if all dependencies are present in the correct version.", ex);
				PrintEnvironmentInfo(context);
			}
			catch (TypeResolveException ex) {
                context.Logger.ErrorException("Failed to resolve a type, check if all dependencies are present in the correct version.", ex);
				PrintEnvironmentInfo(context);
			}
			catch (MemberRefResolveException ex) {
				context.Logger.ErrorException("Failed to resolve a member, check if all dependencies are present in the correct version.", ex);
				PrintEnvironmentInfo(context);
			}
			catch (IOException ex) {
				context.Logger.ErrorException("An IO error occurred, check if all input/output locations are readable/writable.", ex);
			}
			catch (OperationCanceledException) {
				context.Logger.Error("Operation cancelled.");
			}
			catch (ConfuserException) {
				// Exception is already handled/logged, so just ignore and report failure
			}
			catch (Exception ex) {
				context.Logger.ErrorException("Unknown error occurred.", ex);
			}
			finally {
				if (context.Resolver != null)
					context.Resolver.Clear();
				context.Logger.Finish(ok);
			}
		}

		/// <summary>
		///     Runs the protection pipeline.
		/// </summary>
		/// <param name="pipeline">The protection pipeline.</param>
		/// <param name="context">The context.</param>
		static void RunPipeline(ProtectionPipeline pipeline, ConfuserContext context) {
			Func<IList<IDnlibDef>> getAllDefs = () => context.Modules.SelectMany(module => module.FindDefinitions()).ToList();
			Func<ModuleDef, IList<IDnlibDef>> getModuleDefs = module => module.FindDefinitions().ToList();

			context.CurrentModuleIndex = -1;

			pipeline.ExecuteStage(PipelineStage.Inspection, Inspection, () => getAllDefs(), context);

			var options = new ModuleWriterOptionsBase[context.Modules.Count];
			var listeners = new ModuleWriterListener[context.Modules.Count];
			for (int i = 0; i < context.Modules.Count; i++) {
				context.CurrentModuleIndex = i;
				context.CurrentModuleWriterOptions = null;
				context.CurrentModuleWriterListener = null;

				pipeline.ExecuteStage(PipelineStage.BeginModule, BeginModule, () => getModuleDefs(context.CurrentModule), context);
				pipeline.ExecuteStage(PipelineStage.ProcessModule, ProcessModule, () => getModuleDefs(context.CurrentModule), context);
				pipeline.ExecuteStage(PipelineStage.OptimizeMethods, OptimizeMethods, () => getModuleDefs(context.CurrentModule), context);
				pipeline.ExecuteStage(PipelineStage.EndModule, EndModule, () => getModuleDefs(context.CurrentModule), context);

				options[i] = context.CurrentModuleWriterOptions;
				listeners[i] = context.CurrentModuleWriterListener;
			}

			for (int i = 0; i < context.Modules.Count; i++) {
				context.CurrentModuleIndex = i;
				context.CurrentModuleWriterOptions = options[i];
				context.CurrentModuleWriterListener = listeners[i];

				pipeline.ExecuteStage(PipelineStage.WriteModule, WriteModule, () => getModuleDefs(context.CurrentModule), context);

				context.OutputModules[i] = context.CurrentModuleOutput;
				context.OutputSymbols[i] = context.CurrentModuleSymbol;
				context.CurrentModuleWriterOptions = null;
				context.CurrentModuleWriterListener = null;
				context.CurrentModuleOutput = null;
				context.CurrentModuleSymbol = null;
			}

			context.CurrentModuleIndex = -1;

			pipeline.ExecuteStage(PipelineStage.Debug, Debug, () => getAllDefs(), context);
			pipeline.ExecuteStage(PipelineStage.Pack, Pack, () => getAllDefs(), context);
			pipeline.ExecuteStage(PipelineStage.SaveModules, SaveModules, () => getAllDefs(), context);

			if (!context.PackerInitiated)
				context.Logger.Info("Done.");
		}

		static void Inspection(ConfuserContext context) {
			context.Logger.Info("Resolving dependencies...");
			foreach (var dependency in context.Modules
			                                  .SelectMany(module => module.GetAssemblyRefs().Select(asmRef => Tuple.Create(asmRef, module)))) {
				try {
					AssemblyDef assembly = context.Resolver.ResolveThrow(dependency.Item1, dependency.Item2);
				}
				catch (AssemblyResolveException ex) {
					context.Logger.ErrorException("Failed to resolve dependency of '" + dependency.Item2.Name + "'.", ex);
					throw new ConfuserException(ex);
				}
			}

			context.Logger.Debug("Checking Strong Name...");
			foreach (ModuleDefMD module in context.Modules) {
				var snKey = context.Annotations.Get<StrongNameKey>(module, Marker.SNKey);
				if (snKey == null && module.IsStrongNameSigned)
					context.Logger.WarnFormat("[{0}] SN Key is not provided for a signed module, the output may not be working.", module.Name);
				else if (snKey != null && !module.IsStrongNameSigned)
					context.Logger.WarnFormat("[{0}] SN Key is provided for an unsigned module, the output may not be working.", module.Name);
				else if (snKey != null && module.IsStrongNameSigned &&
				         !module.Assembly.PublicKey.Data.SequenceEqual(snKey.PublicKey))
					context.Logger.WarnFormat("[{0}] Provided SN Key and signed module's public key do not match, the output may not be working.", module.Name);
			}

			var marker = context.Registry.GetService<IMarkerService>();

			context.Logger.Debug("Creating global .cctors...");
			foreach (ModuleDefMD module in context.Modules) {
				TypeDef modType = module.GlobalType;
				if (modType == null) {
					modType = new TypeDefUser("", "<Module>", null);
					modType.Attributes = TypeAttributes.AnsiClass;
					module.Types.Add(modType);
					marker.Mark(modType, null);
				}
				MethodDef cctor = modType.FindOrCreateStaticConstructor();
				if (!marker.IsMarked(cctor))
					marker.Mark(cctor, null);
			}

			context.Logger.Debug("Watermarking...");
			foreach (ModuleDefMD module in context.Modules) {
				TypeRef attrRef = module.CorLibTypes.GetTypeRef("System", "Attribute");
				var attrType = new TypeDefUser("", "ConfusedByAttribute", attrRef);
				module.Types.Add(attrType);
				marker.Mark(attrType, null);

				var ctor = new MethodDefUser(
					".ctor",
					MethodSig.CreateInstance(module.CorLibTypes.Void, module.CorLibTypes.String),
					MethodImplAttributes.Managed,
					MethodAttributes.HideBySig | MethodAttributes.Public | MethodAttributes.SpecialName | MethodAttributes.RTSpecialName);
				ctor.Body = new CilBody();
				ctor.Body.MaxStack = 1;
				ctor.Body.Instructions.Add(OpCodes.Ldarg_0.ToInstruction());
				ctor.Body.Instructions.Add(OpCodes.Call.ToInstruction(new MemberRefUser(module, ".ctor", MethodSig.CreateInstance(module.CorLibTypes.Void), attrRef)));
				ctor.Body.Instructions.Add(OpCodes.Ret.ToInstruction());
				attrType.Methods.Add(ctor);
				marker.Mark(ctor, null);

				var attr = new CustomAttribute(ctor);
				attr.ConstructorArguments.Add(new CAArgument(module.CorLibTypes.String, Version));

				module.CustomAttributes.Add(attr);
			}
		}

		static void CopyPEHeaders(PEHeadersOptions writerOptions, ModuleDefMD module) {
			var image = module.MetaData.PEImage;
			writerOptions.MajorImageVersion = image.ImageNTHeaders.OptionalHeader.MajorImageVersion;
			writerOptions.MajorLinkerVersion = image.ImageNTHeaders.OptionalHeader.MajorLinkerVersion;
			writerOptions.MajorOperatingSystemVersion = image.ImageNTHeaders.OptionalHeader.MajorOperatingSystemVersion;
			writerOptions.MajorSubsystemVersion = image.ImageNTHeaders.OptionalHeader.MajorSubsystemVersion;
			writerOptions.MinorImageVersion = image.ImageNTHeaders.OptionalHeader.MinorImageVersion;
			writerOptions.MinorLinkerVersion = image.ImageNTHeaders.OptionalHeader.MinorLinkerVersion;
			writerOptions.MinorOperatingSystemVersion = image.ImageNTHeaders.OptionalHeader.MinorOperatingSystemVersion;
			writerOptions.MinorSubsystemVersion = image.ImageNTHeaders.OptionalHeader.MinorSubsystemVersion;
		}

		static void BeginModule(ConfuserContext context) {
			context.Logger.InfoFormat("Processing module '{0}'...", context.CurrentModule.Name);

			context.CurrentModuleWriterListener = new ModuleWriterListener();
			context.CurrentModuleWriterListener.OnWriterEvent += (sender, e) => context.CheckCancellation();
			context.CurrentModuleWriterOptions = new ModuleWriterOptions(context.CurrentModule, context.CurrentModuleWriterListener);
			CopyPEHeaders(context.CurrentModuleWriterOptions.PEHeadersOptions, context.CurrentModule);

			if (!context.CurrentModule.IsILOnly || context.CurrentModule.VTableFixups != null)
				context.RequestNative();
			
			var snKey = context.Annotations.Get<StrongNameKey>(context.CurrentModule, Marker.SNKey);
			context.CurrentModuleWriterOptions.InitializeStrongNameSigning(context.CurrentModule, snKey);

			foreach (TypeDef type in context.CurrentModule.GetTypes())
				foreach (MethodDef method in type.Methods) {
					if (method.Body != null) {
						method.Body.Instructions.SimplifyMacros(method.Body.Variables, method.Parameters);
					}
				}
		}

		static void ProcessModule(ConfuserContext context) { }

		static void OptimizeMethods(ConfuserContext context) {
			foreach (TypeDef type in context.CurrentModule.GetTypes())
				foreach (MethodDef method in type.Methods) {
					if (method.Body != null)
						method.Body.Instructions.OptimizeMacros();
				}
		}

		static void EndModule(ConfuserContext context) {
			string output = context.Modules[context.CurrentModuleIndex].Location;
			if (output != null) {
				if (!Path.IsPathRooted(output))
					output = Path.Combine(Environment.CurrentDirectory, output);
				output = Utils.GetRelativePath(output, context.BaseDirectory);
			}
			else {
				output = context.CurrentModule.Name;
			}
			context.OutputPaths[context.CurrentModuleIndex] = output;
		}

		static void WriteModule(ConfuserContext context) {
			context.Logger.InfoFormat("Writing module '{0}'...", context.CurrentModule.Name);

			MemoryStream pdb = null, output = new MemoryStream();

			if (context.CurrentModule.PdbState != null) {
				pdb = new MemoryStream();
				context.CurrentModuleWriterOptions.WritePdb = true;
				context.CurrentModuleWriterOptions.PdbFileName = Path.ChangeExtension(Path.GetFileName(context.OutputPaths[context.CurrentModuleIndex]), "pdb");
				context.CurrentModuleWriterOptions.PdbStream = pdb;
			}

			if (context.CurrentModuleWriterOptions is ModuleWriterOptions)
				context.CurrentModule.Write(output, (ModuleWriterOptions)context.CurrentModuleWriterOptions);
			else
				context.CurrentModule.NativeWrite(output, (NativeModuleWriterOptions)context.CurrentModuleWriterOptions);

			context.CurrentModuleOutput = output.ToArray();
			if (context.CurrentModule.PdbState != null)
				context.CurrentModuleSymbol = pdb.ToArray();
		}

		static void Debug(ConfuserContext context) {
			context.Logger.Info("Finalizing...");
			for (int i = 0; i < context.OutputModules.Count; i++) {
				if (context.OutputSymbols[i] == null)
					continue;
				string path = Path.GetFullPath(Path.Combine(context.OutputDirectory, context.OutputPaths[i]));
				string dir = Path.GetDirectoryName(path);
				if (!Directory.Exists(dir))
					Directory.CreateDirectory(dir);
				File.WriteAllBytes(Path.ChangeExtension(path, "pdb"), context.OutputSymbols[i]);
			}
		}

		static void Pack(ConfuserContext context) {
			if (context.Packer != null) {
				context.Logger.Info("Packing...");
				context.Packer.Pack(context, new ProtectionParameters(context.Packer, context.Modules.OfType<IDnlibDef>().ToList()));
			}
		}

		static void SaveModules(ConfuserContext context) {
			context.Resolver.Clear();
			for (int i = 0; i < context.OutputModules.Count; i++) {
				string path = Path.GetFullPath(Path.Combine(context.OutputDirectory, context.OutputPaths[i]));
				string dir = Path.GetDirectoryName(path);
				if (!Directory.Exists(dir))
					Directory.CreateDirectory(dir);
				context.Logger.DebugFormat("Saving to '{0}'...", path);
				File.WriteAllBytes(path, context.OutputModules[i]);
			}
		}

		/// <summary>
		///     Prints the copyright stuff and environment information.
		/// </summary>
		/// <param name="context">The working context.</param>
		static void PrintInfo(ConfuserContext context) {
			if (context.PackerInitiated) {
				context.Logger.Info("Protecting packer stub...");
			}
			else {
				context.Logger.InfoFormat("{0} {1}", Version, Copyright);

				Type mono = Type.GetType("Mono.Runtime");
				context.Logger.InfoFormat("Running on {0}, {1}, {2} bits",
				                          Environment.OSVersion,
				                          mono == null ?
					                          ".NET Framework v" + Environment.Version :
					                          mono.GetMethod("GetDisplayName", BindingFlags.NonPublic | BindingFlags.Static).Invoke(null, null),
				                          IntPtr.Size * 8);
			}
		}

		static IEnumerable<string> GetFrameworkVersions() {
			// http://msdn.microsoft.com/en-us/library/hh925568.aspx

			using (RegistryKey ndpKey =
				RegistryKey.OpenRemoteBaseKey(RegistryHive.LocalMachine, "").
				            OpenSubKey(@"SOFTWARE\Microsoft\NET Framework Setup\NDP\")) {
				foreach (string versionKeyName in ndpKey.GetSubKeyNames()) {
					if (!versionKeyName.StartsWith("v"))
						continue;

					RegistryKey versionKey = ndpKey.OpenSubKey(versionKeyName);
					var name = (string)versionKey.GetValue("Version", "");
					string sp = versionKey.GetValue("SP", "").ToString();
					string install = versionKey.GetValue("Install", "").ToString();
					if (install == "" || sp != "" && install == "1")
						yield return versionKeyName + "  " + name;

					if (name != "")
						continue;

					foreach (string subKeyName in versionKey.GetSubKeyNames()) {
						RegistryKey subKey = versionKey.OpenSubKey(subKeyName);
						name = (string)subKey.GetValue("Version", "");
						if (name != "")
							sp = subKey.GetValue("SP", "").ToString();
						install = subKey.GetValue("Install", "").ToString();

						if (install == "")
							yield return versionKeyName + "  " + name;
						else if (install == "1")
							yield return "  " + subKeyName + "  " + name;
					}
				}
			}

			using (RegistryKey ndpKey =
				RegistryKey.OpenRemoteBaseKey(RegistryHive.LocalMachine, "").
				            OpenSubKey(@"SOFTWARE\Microsoft\NET Framework Setup\NDP\v4\Full\")) {
				if (ndpKey.GetValue("Release") == null)
					yield break;
				var releaseKey = (int)ndpKey.GetValue("Release");
				yield return "v4.5 " + releaseKey;
			}
		}

		/// <summary>
		///     Prints the environment information when error occurred.
		/// </summary>
		/// <param name="context">The working context.</param>
		static void PrintEnvironmentInfo(ConfuserContext context) {
			if (context.PackerInitiated)
				return;

			context.Logger.Error("---BEGIN DEBUG INFO---");

			context.Logger.Error("Installed Framework Versions:");
			foreach (string ver in GetFrameworkVersions()) {
				context.Logger.ErrorFormat("    {0}", ver.Trim());
			}
			context.Logger.Error("");

			if (context.Resolver != null) {
				context.Logger.Error("Cached assemblies:");
				foreach (AssemblyDef asm in context.Resolver.GetCachedAssemblies()) {
					if (string.IsNullOrEmpty(asm.ManifestModule.Location))
						context.Logger.ErrorFormat("    {0}", asm.FullName);
					else
						context.Logger.ErrorFormat("    {0} ({1})", asm.FullName, asm.ManifestModule.Location);
					foreach (var reference in asm.Modules.OfType<ModuleDefMD>().SelectMany(m => m.GetAssemblyRefs()))
						context.Logger.ErrorFormat("        {0}", reference.FullName);
				}
			}

			context.Logger.Error("---END DEBUG INFO---");
		}
	}
}


================================================
File: Confuser.Core/ConfuserException.cs
================================================
ï»¿using System;

namespace Confuser.Core {
	/// <summary>
	///     The exception that is thrown when a handled error occurred during the protection process.
	/// </summary>
	public class ConfuserException : Exception {
		/// <summary>
		///     Initializes a new instance of the <see cref="ConfuserException" /> class.
		/// </summary>
		/// <param name="innerException">The inner exception, or null if no exception is associated with the error.</param>
		public ConfuserException(Exception innerException)
			: base("Exception occurred during the protection process.", innerException) { }
	}
}


================================================
File: Confuser.Core/ConfuserParameters.cs
================================================
ï»¿using System;
using Confuser.Core.Project;

namespace Confuser.Core {
	/// <summary>
	///     Parameters that passed to <see cref="ConfuserEngine" />.
	/// </summary>
	public class ConfuserParameters {
		/// <summary>
		///     Gets or sets the project that would be processed.
		/// </summary>
		/// <value>The Confuser project.</value>
		public ConfuserProject Project { get; set; }

		/// <summary>
		///     Gets or sets the logger that used to log the protection process.
		/// </summary>
		/// <value>The logger, or <c>null</c> if logging is not needed.</value>
		public ILogger Logger { get; set; }

		internal bool PackerInitiated { get; set; }

		/// <summary>
		///     Gets or sets the plugin discovery service.
		/// </summary>
		/// <value>The plugin discovery service, or <c>null</c> if default discovery is used.</value>
		public PluginDiscovery PluginDiscovery { get; set; }

		/// <summary>
		///     Gets or sets the marker.
		/// </summary>
		/// <value>The marker, or <c>null</c> if default marker is used.</value>
		public Marker Marker { get; set; }

		/// <summary>
		///     Gets the actual non-null logger.
		/// </summary>
		/// <returns>The logger.</returns>
		internal ILogger GetLogger() {
			return Logger ?? NullLogger.Instance;
		}

		/// <summary>
		///     Gets the actual non-null plugin discovery service.
		/// </summary>
		/// <returns>The plugin discovery service.</returns>
		internal PluginDiscovery GetPluginDiscovery() {
			return PluginDiscovery ?? PluginDiscovery.Instance;
		}

		/// <summary>
		///     Gets the actual non-null marker.
		/// </summary>
		/// <returns>The marker.</returns>
		internal Marker GetMarker() {
			return Marker ?? new ObfAttrMarker();
		}
	}
}


================================================
File: Confuser.Core/CoreComponent.cs
================================================
ï»¿using System;
using Confuser.Core.API;
using Confuser.Core.Services;

namespace Confuser.Core {
	/// <summary>
	///     Core component of Confuser.
	/// </summary>
	public class CoreComponent : ConfuserComponent {
		/// <summary>
		///     The service ID of RNG
		/// </summary>
		public const string _RandomServiceId = "Confuser.Random";

		/// <summary>
		///     The service ID of Marker
		/// </summary>
		public const string _MarkerServiceId = "Confuser.Marker";

		/// <summary>
		///     The service ID of Trace
		/// </summary>
		public const string _TraceServiceId = "Confuser.Trace";

		/// <summary>
		///     The service ID of Runtime
		/// </summary>
		public const string _RuntimeServiceId = "Confuser.Runtime";

		/// <summary>
		///     The service ID of Compression
		/// </summary>
		public const string _CompressionServiceId = "Confuser.Compression";

		/// <summary>
		///     The service ID of API Store
		/// </summary>
		public const string _APIStoreId = "Confuser.APIStore";

		readonly Marker marker;
		readonly ConfuserParameters parameters;

		/// <summary>
		///     Initializes a new instance of the <see cref="CoreComponent" /> class.
		/// </summary>
		/// <param name="parameters">The parameters.</param>
		/// <param name="marker">The marker.</param>
		internal CoreComponent(ConfuserParameters parameters, Marker marker) {
			this.parameters = parameters;
			this.marker = marker;
		}

		/// <inheritdoc />
		public override string Name {
			get { return "Confuser Core"; }
		}

		/// <inheritdoc />
		public override string Description {
			get { return "Initialization of Confuser core services."; }
		}

		/// <inheritdoc />
		public override string Id {
			get { return "Confuser.Core"; }
		}

		/// <inheritdoc />
		public override string FullId {
			get { return "Confuser.Core"; }
		}

		/// <inheritdoc />
		protected internal override void Initialize(ConfuserContext context) {
			context.Registry.RegisterService(_RandomServiceId, typeof(IRandomService), new RandomService(parameters.Project.Seed));
			context.Registry.RegisterService(_MarkerServiceId, typeof(IMarkerService), new MarkerService(context, marker));
			context.Registry.RegisterService(_TraceServiceId, typeof(ITraceService), new TraceService(context));
			context.Registry.RegisterService(_RuntimeServiceId, typeof(IRuntimeService), new RuntimeService());
			context.Registry.RegisterService(_CompressionServiceId, typeof(ICompressionService), new CompressionService(context));
			context.Registry.RegisterService(_APIStoreId, typeof(IAPIStore), new APIStore(context));
		}

		/// <inheritdoc />
		protected internal override void PopulatePipeline(ProtectionPipeline pipeline) {
			//
		}
	}
}


================================================
File: Confuser.Core/DependencyResolver.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;

namespace Confuser.Core {
	/// <summary>
	///     Resolves dependency between protections.
	/// </summary>
	internal class DependencyResolver {
		readonly List<Protection> protections;

		/// <summary>
		///     Initializes a new instance of the <see cref="DependencyResolver" /> class.
		/// </summary>
		/// <param name="protections">The protections for resolution.</param>
		public DependencyResolver(IEnumerable<Protection> protections) {
			this.protections = protections.OrderBy(prot => prot.FullId).ToList();
		}

		/// <summary>
		///     Sort the protection according to their dependency.
		/// </summary>
		/// <returns>Sorted protections with respect to dependencies.</returns>
		/// <exception cref="T:CircularDependencyException">
		///     The protections contain circular dependencies.
		/// </exception>
		public IList<Protection> SortDependency() {
			/* Here we do a topological sort of the protections.
             * First we construct a dependency graph of the protections.
             * The edges in the graph is recorded in a list.
             * Then the graph is sorted starting from the null root node.
             */

			var edges = new List<DependencyGraphEdge>();
			var roots = new HashSet<Protection>(protections);
			Dictionary<string, Protection> id2prot = protections.ToDictionary(prot => prot.FullId, prot => prot);

			foreach (Protection prot in protections) {
				Type protType = prot.GetType();

				BeforeProtectionAttribute before = protType
					.GetCustomAttributes(typeof(BeforeProtectionAttribute), false)
					.Cast<BeforeProtectionAttribute>()
					.SingleOrDefault();
				if (before != null) {
					// current -> target
					IEnumerable<Protection> targets = before.Ids.Select(id => id2prot[id]);
					foreach (Protection target in targets) {
						edges.Add(new DependencyGraphEdge(prot, target));
						roots.Remove(target);
					}
				}

				AfterProtectionAttribute after = protType
					.GetCustomAttributes(typeof(AfterProtectionAttribute), false)
					.Cast<AfterProtectionAttribute>()
					.SingleOrDefault();
				if (after != null) {
					// target -> current
					IEnumerable<Protection> targets = after.Ids.Select(id => id2prot[id]);
					foreach (Protection target in targets) {
						edges.Add(new DependencyGraphEdge(target, prot));
						roots.Remove(prot);
					}
				}
			}

			IEnumerable<Protection> sorted = SortGraph(roots, edges);
			return sorted.ToList();
		}

		/// <summary>
		///     Topologically sort the dependency graph.
		/// </summary>
		/// <param name="roots">The root protections.</param>
		/// <param name="edges">The dependency graph edges.</param>
		/// <returns>Topological sorted protections.</returns>
		IEnumerable<Protection> SortGraph(IEnumerable<Protection> roots, IList<DependencyGraphEdge> edges) {
			var queue = new Queue<Protection>(roots.OrderBy(prot => prot.FullId));
			while (queue.Count > 0) {
				Protection root = queue.Dequeue(); // Find a node with no incoming edges
				Debug.Assert(!edges.Where(edge => edge.To == root).Any());
				yield return root;

				foreach (DependencyGraphEdge edge in edges.Where(edge => edge.From == root).ToList()) {
					edges.Remove(edge);
					if (!edges.Any(e => e.To == edge.To)) // No more incoming edge to edge.To
						queue.Enqueue(edge.To); // Add new root node
				}
			}
			if (edges.Count != 0)
				throw new CircularDependencyException(edges[0].From, edges[0].To);
		}

		/// <summary>
		///     An edge of dependency graph.
		/// </summary>
		class DependencyGraphEdge {
			/// <summary>
			///     Initializes a new instance of the <see cref="DependencyGraphEdge" /> class.
			/// </summary>
			/// <param name="from">The source protection node.</param>
			/// <param name="to">The destination protection node.</param>
			public DependencyGraphEdge(Protection from, Protection to) {
				From = from;
				To = to;
			}

			/// <summary>
			///     The source protection node.
			/// </summary>
			public Protection From { get; private set; }

			/// <summary>
			///     The destination protection node.
			/// </summary>
			public Protection To { get; private set; }
		}
	}

	/// <summary>
	///     The exception that is thrown when there exists circular dependency between protections.
	/// </summary>
	internal class CircularDependencyException : Exception {
		/// <summary>
		///     Initializes a new instance of the <see cref="CircularDependencyException" /> class.
		/// </summary>
		/// <param name="a">The first protection.</param>
		/// <param name="b">The second protection.</param>
		internal CircularDependencyException(Protection a, Protection b)
			: base(string.Format("The protections '{0}' and '{1}' has a circular dependency between them.", a, b)) {
			Debug.Assert(a != null);
			Debug.Assert(b != null);
			ProtectionA = a;
			ProtectionB = b;
		}

		/// <summary>
		///     First protection that involved in circular dependency.
		/// </summary>
		public Protection ProtectionA { get; private set; }

		/// <summary>
		///     Second protection that involved in circular dependency.
		/// </summary>
		public Protection ProtectionB { get; private set; }
	}
}


================================================
File: Confuser.Core/DnlibUtils.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using dnlib.IO;

namespace Confuser.Core {
	/// <summary>
	///     Provides a set of utility methods about dnlib
	/// </summary>
	public static class DnlibUtils {
		/// <summary>
		///     Finds all definitions of interest in a module.
		/// </summary>
		/// <param name="module">The module.</param>
		/// <returns>A collection of all required definitions</returns>
		public static IEnumerable<IDnlibDef> FindDefinitions(this ModuleDef module) {
			yield return module;
			foreach (TypeDef type in module.GetTypes()) {
				yield return type;

				foreach (MethodDef method in type.Methods)
					yield return method;

				foreach (FieldDef field in type.Fields)
					yield return field;

				foreach (PropertyDef prop in type.Properties)
					yield return prop;

				foreach (EventDef evt in type.Events)
					yield return evt;
			}
		}

		/// <summary>
		///     Finds all definitions of interest in a type.
		/// </summary>
		/// <param name="typeDef">The type.</param>
		/// <returns>A collection of all required definitions</returns>
		public static IEnumerable<IDnlibDef> FindDefinitions(this TypeDef typeDef) {
			yield return typeDef;

			foreach (TypeDef nestedType in typeDef.NestedTypes)
				yield return nestedType;

			foreach (MethodDef method in typeDef.Methods)
				yield return method;

			foreach (FieldDef field in typeDef.Fields)
				yield return field;

			foreach (PropertyDef prop in typeDef.Properties)
				yield return prop;

			foreach (EventDef evt in typeDef.Events)
				yield return evt;
		}

		/// <summary>
		///     Determines whether the specified type is visible outside the containing assembly.
		/// </summary>
		/// <param name="typeDef">The type.</param>
		/// <param name="exeNonPublic">Visibility of executable modules.</param>
		/// <returns><c>true</c> if the specified type is visible outside the containing assembly; otherwise, <c>false</c>.</returns>
		public static bool IsVisibleOutside(this TypeDef typeDef, bool exeNonPublic = true) {
			// Assume executable modules' type is not visible
			if (exeNonPublic && (typeDef.Module.Kind == ModuleKind.Windows || typeDef.Module.Kind == ModuleKind.Console))
				return false;

			do {
				if (typeDef.DeclaringType == null)
					return typeDef.IsPublic;
				if (!typeDef.IsNestedPublic && !typeDef.IsNestedFamily && !typeDef.IsNestedFamilyOrAssembly)
					return false;
				typeDef = typeDef.DeclaringType;
			} while (typeDef != null);

			throw new UnreachableException();
		}

		/// <summary>
		///     Determines whether the object has the specified custom attribute.
		/// </summary>
		/// <param name="obj">The object.</param>
		/// <param name="fullName">The full name of the type of custom attribute.</param>
		/// <returns><c>true</c> if the specified object has custom attribute; otherwise, <c>false</c>.</returns>
		public static bool HasAttribute(this IHasCustomAttribute obj, string fullName) {
			return obj.CustomAttributes.Any(attr => attr.TypeFullName == fullName);
		}

		/// <summary>
		///     Determines whether the specified type is COM import.
		/// </summary>
		/// <param name="type">The type.</param>
		/// <returns><c>true</c> if specified type is COM import; otherwise, <c>false</c>.</returns>
		public static bool IsComImport(this TypeDef type) {
			return type.IsImport ||
			       type.HasAttribute("System.Runtime.InteropServices.ComImportAttribute") ||
			       type.HasAttribute("System.Runtime.InteropServices.TypeLibTypeAttribute");
		}

		/// <summary>
		///     Determines whether the specified type is compiler generated.
		/// </summary>
		/// <param name="type">The type.</param>
		/// <returns><c>true</c> if specified type is compiler generated; otherwise, <c>false</c>.</returns>
		public static bool IsCompilerGenerated(this TypeDef type) {
			return type.HasAttribute("System.Runtime.CompilerServices.CompilerGeneratedAttribute");
		}

		/// <summary>
		///     Determines whether the specified type is a delegate.
		/// </summary>
		/// <param name="type">The type.</param>
		/// <returns><c>true</c> if the specified type is a delegate; otherwise, <c>false</c>.</returns>
		public static bool IsDelegate(this TypeDef type) {
			if (type.BaseType == null)
				return false;

			string fullName = type.BaseType.FullName;
			return fullName == "System.Delegate" || fullName == "System.MulticastDelegate";
		}

		/// <summary>
		///     Determines whether the specified type is inherited from a base type in corlib.
		/// </summary>
		/// <param name="type">The type.</param>
		/// <param name="baseType">The full name of base type.</param>
		/// <returns><c>true</c> if the specified type is inherited from a base type; otherwise, <c>false</c>.</returns>
		public static bool InheritsFromCorlib(this TypeDef type, string baseType) {
			if (type.BaseType == null)
				return false;

			TypeDef bas = type;
			do {
				bas = bas.BaseType.ResolveTypeDefThrow();
				if (bas.ReflectionFullName == baseType)
					return true;
			} while (bas.BaseType != null && bas.BaseType.DefinitionAssembly.IsCorLib());
			return false;
		}

		/// <summary>
		///     Determines whether the specified type is inherited from a base type.
		/// </summary>
		/// <param name="type">The type.</param>
		/// <param name="baseType">The full name of base type.</param>
		/// <returns><c>true</c> if the specified type is inherited from a base type; otherwise, <c>false</c>.</returns>
		public static bool InheritsFrom(this TypeDef type, string baseType) {
			if (type.BaseType == null)
				return false;

			TypeDef bas = type;
			do {
				bas = bas.BaseType.ResolveTypeDefThrow();
				if (bas.ReflectionFullName == baseType)
					return true;
			} while (bas.BaseType != null);
			return false;
		}

		/// <summary>
		///     Determines whether the specified type implements the specified interface.
		/// </summary>
		/// <param name="type">The type.</param>
		/// <param name="fullName">The full name of the type of interface.</param>
		/// <returns><c>true</c> if the specified type implements the interface; otherwise, <c>false</c>.</returns>
		public static bool Implements(this TypeDef type, string fullName) {
			do {
				foreach (InterfaceImpl iface in type.Interfaces) {
					if (iface.Interface.ReflectionFullName == fullName)
						return true;
				}

				if (type.BaseType == null)
					return false;

				type = type.BaseType.ResolveTypeDefThrow();
			} while (type != null);
			throw new UnreachableException();
		}

		/// <summary>
		///     Resolves the method.
		/// </summary>
		/// <param name="method">The method to resolve.</param>
		/// <returns>A <see cref="MethodDef" /> instance.</returns>
		/// <exception cref="MemberRefResolveException">The method couldn't be resolved.</exception>
		public static MethodDef ResolveThrow(this IMethod method) {
			var def = method as MethodDef;
			if (def != null)
				return def;

			var spec = method as MethodSpec;
			if (spec != null)
				return spec.Method.ResolveThrow();

			return ((MemberRef)method).ResolveMethodThrow();
		}

		/// <summary>
		///     Resolves the field.
		/// </summary>
		/// <param name="field">The field to resolve.</param>
		/// <returns>A <see cref="FieldDef" /> instance.</returns>
		/// <exception cref="MemberRefResolveException">The method couldn't be resolved.</exception>
		public static FieldDef ResolveThrow(this IField field) {
			var def = field as FieldDef;
			if (def != null)
				return def;

			return ((MemberRef)field).ResolveFieldThrow();
		}

		/// <summary>
		///     Find the basic type reference.
		/// </summary>
		/// <param name="typeSig">The type signature to get the basic type.</param>
		/// <returns>A <see cref="ITypeDefOrRef" /> instance, or null if the typeSig cannot be resolved to basic type.</returns>
		public static ITypeDefOrRef ToBasicTypeDefOrRef(this TypeSig typeSig) {
			while (typeSig.Next != null)
				typeSig = typeSig.Next;

			if (typeSig is GenericInstSig)
				return ((GenericInstSig)typeSig).GenericType.TypeDefOrRef;
			if (typeSig is TypeDefOrRefSig)
				return ((TypeDefOrRefSig)typeSig).TypeDefOrRef;
			return null;
		}

		/// <summary>
		///     Find the type references within the specified type signature.
		/// </summary>
		/// <param name="typeSig">The type signature to find the type references.</param>
		/// <returns>A list of <see cref="ITypeDefOrRef" /> instance.</returns>
		public static IList<ITypeDefOrRef> FindTypeRefs(this TypeSig typeSig) {
			var ret = new List<ITypeDefOrRef>();
			FindTypeRefsInternal(typeSig, ret);
			return ret;
		}

		static void FindTypeRefsInternal(TypeSig typeSig, IList<ITypeDefOrRef> ret) {
			while (typeSig.Next != null) {
				if (typeSig is ModifierSig)
					ret.Add(((ModifierSig)typeSig).Modifier);
				typeSig = typeSig.Next;
			}

			if (typeSig is GenericInstSig) {
				var genInst = (GenericInstSig)typeSig;
				ret.Add(genInst.GenericType.TypeDefOrRef);
				foreach (TypeSig genArg in genInst.GenericArguments)
					FindTypeRefsInternal(genArg, ret);
			}
			else if (typeSig is TypeDefOrRefSig) {
				var type = ((TypeDefOrRefSig)typeSig).TypeDefOrRef;
				while (type != null) {
					ret.Add(type);
					type = type.DeclaringType;
				}
			}
		}

		/// <summary>
		///     Determines whether the specified property is public.
		/// </summary>
		/// <param name="property">The property.</param>
		/// <returns><c>true</c> if the specified property is public; otherwise, <c>false</c>.</returns>
		public static bool IsPublic(this PropertyDef property) {
			if (property.GetMethod != null && property.GetMethod.IsPublic)
				return true;

			if (property.SetMethod != null && property.SetMethod.IsPublic)
				return true;

			return property.OtherMethods.Any(method => method.IsPublic);
		}

		/// <summary>
		///     Determines whether the specified property is static.
		/// </summary>
		/// <param name="property">The property.</param>
		/// <returns><c>true</c> if the specified property is static; otherwise, <c>false</c>.</returns>
		public static bool IsStatic(this PropertyDef property) {
			if (property.GetMethod != null && property.GetMethod.IsStatic)
				return true;

			if (property.SetMethod != null && property.SetMethod.IsStatic)
				return true;

			return property.OtherMethods.Any(method => method.IsStatic);
		}

		/// <summary>
		///     Determines whether the specified event is public.
		/// </summary>
		/// <param name="evt">The event.</param>
		/// <returns><c>true</c> if the specified event is public; otherwise, <c>false</c>.</returns>
		public static bool IsPublic(this EventDef evt) {
			if (evt.AddMethod != null && evt.AddMethod.IsPublic)
				return true;

			if (evt.RemoveMethod != null && evt.RemoveMethod.IsPublic)
				return true;

			if (evt.InvokeMethod != null && evt.InvokeMethod.IsPublic)
				return true;

			return evt.OtherMethods.Any(method => method.IsPublic);
		}

		/// <summary>
		///     Determines whether the specified event is static.
		/// </summary>
		/// <param name="evt">The event.</param>
		/// <returns><c>true</c> if the specified event is static; otherwise, <c>false</c>.</returns>
		public static bool IsStatic(this EventDef evt) {
			if (evt.AddMethod != null && evt.AddMethod.IsStatic)
				return true;

			if (evt.RemoveMethod != null && evt.RemoveMethod.IsStatic)
				return true;

			if (evt.InvokeMethod != null && evt.InvokeMethod.IsStatic)
				return true;

			return evt.OtherMethods.Any(method => method.IsStatic);
		}

		/// <summary>
		///     Replaces the specified instruction reference with another instruction.
		/// </summary>
		/// <param name="body">The method body.</param>
		/// <param name="target">The instruction to replace.</param>
		/// <param name="newInstr">The new instruction.</param>
		public static void ReplaceReference(this CilBody body, Instruction target, Instruction newInstr) {
			foreach (ExceptionHandler eh in body.ExceptionHandlers) {
				if (eh.TryStart == target)
					eh.TryStart = newInstr;
				if (eh.TryEnd == target)
					eh.TryEnd = newInstr;
				if (eh.HandlerStart == target)
					eh.HandlerStart = newInstr;
				if (eh.HandlerEnd == target)
					eh.HandlerEnd = newInstr;
			}
			foreach (Instruction instr in body.Instructions) {
				if (instr.Operand == target)
					instr.Operand = newInstr;
				else if (instr.Operand is Instruction[]) {
					var targets = (Instruction[])instr.Operand;
					for (int i = 0; i < targets.Length; i++)
						if (targets[i] == target)
							targets[i] = newInstr;
				}
			}
		}

		/// <summary>
		///     Determines whether the specified method is array accessors.
		/// </summary>
		/// <param name="method">The method.</param>
		/// <returns><c>true</c> if the specified method is array accessors; otherwise, <c>false</c>.</returns>
		public static bool IsArrayAccessors(this IMethod method) {
			var declType = method.DeclaringType.ToTypeSig();
			if (declType is GenericInstSig)
				declType = ((GenericInstSig)declType).GenericType;

			if (declType.IsArray) {
				return method.Name == "Get" || method.Name == "Set" || method.Name == "Address";
			}
			return false;
		}
	}


	/// <summary>
	///     <see cref="Stream" /> wrapper of <see cref="IImageStream" />.
	/// </summary>
	public class ImageStream : Stream {
		/// <summary>
		///     Initializes a new instance of the <see cref="ImageStream" /> class.
		/// </summary>
		/// <param name="baseStream">The base stream.</param>
		public ImageStream(IImageStream baseStream) {
			BaseStream = baseStream;
		}

		/// <summary>
		///     Gets the base stream of this instance.
		/// </summary>
		/// <value>The base stream.</value>
		public IImageStream BaseStream { get; private set; }

		/// <inheritdoc />
		public override bool CanRead {
			get { return true; }
		}

		/// <inheritdoc />
		public override bool CanSeek {
			get { return true; }
		}

		/// <inheritdoc />
		public override bool CanWrite {
			get { return false; }
		}

		/// <inheritdoc />
		public override long Length {
			get { return BaseStream.Length; }
		}

		/// <inheritdoc />
		public override long Position {
			get { return BaseStream.Position; }
			set { BaseStream.Position = value; }
		}

		/// <inheritdoc />
		public override void Flush() { }

		/// <inheritdoc />
		public override int Read(byte[] buffer, int offset, int count) {
			return BaseStream.Read(buffer, offset, count);
		}

		/// <inheritdoc />
		public override long Seek(long offset, SeekOrigin origin) {
			switch (origin) {
				case SeekOrigin.Begin:
					BaseStream.Position = offset;
					break;
				case SeekOrigin.Current:
					BaseStream.Position += offset;
					break;
				case SeekOrigin.End:
					BaseStream.Position = BaseStream.Length + offset;
					break;
			}
			return BaseStream.Position;
		}

		/// <inheritdoc />
		public override void SetLength(long value) {
			throw new NotSupportedException();
		}

		/// <inheritdoc />
		public override void Write(byte[] buffer, int offset, int count) {
			throw new NotSupportedException();
		}
	}
}


================================================
File: Confuser.Core/ILogger.cs
================================================
ï»¿using System;

namespace Confuser.Core {
	/// <summary>
	///     Defines a logger used to log Confuser events
	/// </summary>
	public interface ILogger {
		/// <summary>
		///     Logs a message at DEBUG level.
		/// </summary>
		/// <param name="msg">The message.</param>
		void Debug(string msg);

		/// <summary>
		///     Logs a message at DEBUG level with specified parameters.
		/// </summary>
		/// <param name="format">The format.</param>
		/// <param name="args">The arguments.</param>
		void DebugFormat(string format, params object[] args);

		/// <summary>
		///     Logs a message at INFO level.
		/// </summary>
		/// <param name="msg">The message.</param>
		void Info(string msg);

		/// <summary>
		///     Logs a message at INFO level with specified parameters.
		/// </summary>
		/// <param name="format">The format.</param>
		/// <param name="args">The arguments.</param>
		void InfoFormat(string format, params object[] args);

		/// <summary>
		///     Logs a message at WARN level.
		/// </summary>
		/// <param name="msg">The message.</param>
		void Warn(string msg);

		/// <summary>
		///     Logs a message at WARN level with specified parameters.
		/// </summary>
		/// <param name="format">The format.</param>
		/// <param name="args">The arguments.</param>
		void WarnFormat(string format, params object[] args);

		/// <summary>
		///     Logs a message at WARN level with specified exception.
		/// </summary>
		/// <param name="msg">The message.</param>
		/// <param name="ex">The exception.</param>
		void WarnException(string msg, Exception ex);

		/// <summary>
		///     Logs a message at ERROR level.
		/// </summary>
		/// <param name="msg">The message.</param>
		void Error(string msg);

		/// <summary>
		///     Logs a message at ERROR level with specified parameters.
		/// </summary>
		/// <param name="format">The format.</param>
		/// <param name="args">The arguments.</param>
		void ErrorFormat(string format, params object[] args);

		/// <summary>
		///     Logs a message at ERROR level with specified exception.
		/// </summary>
		/// <param name="msg">The message.</param>
		/// <param name="ex">The exception.</param>
		void ErrorException(string msg, Exception ex);

		/// <summary>
		///     Logs the progress of protection.
		/// </summary>
		/// <remarks>
		///     This method is intended to be used with <see cref="EndProgress" />.
		/// </remarks>
		/// <example>
		///     <code> 
		///         for (int i = 0; i &lt; defs.Length; i++) {
		///             logger.Progress(i + 1, defs.Length);
		///         }
		///         logger.EndProgress();
		///     </code>
		/// </example>
		/// <param name="overall">The total work amount .</param>
		/// <param name="progress">The amount of work done.</param>
		void Progress(int progress, int overall);

		/// <summary>
		///     End the progress of protection.
		/// </summary>
		/// <seealso cref="Progress" />
		void EndProgress();

		/// <summary>
		///     Logs the finish of protection.
		/// </summary>
		/// <param name="successful">Indicated whether the protection process is successful.</param>
		void Finish(bool successful);
	}
}


================================================
File: Confuser.Core/Marker.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using Confuser.Core.Project;
using Confuser.Core.Project.Patterns;
using dnlib.DotNet;

namespace Confuser.Core {
	using Rules = Dictionary<Rule, PatternExpression>;

	/// <summary>
	///     Resolves and marks the modules with protection settings according to the rules.
	/// </summary>
	public class Marker {
		/// <summary>
		///     Annotation key of Strong Name Key.
		/// </summary>
		public static readonly object SNKey = new object();

		/// <summary>
		///     Annotation key of rules.
		/// </summary>
		public static readonly object RulesKey = new object();

		/// <summary>
		///     The packers available to use.
		/// </summary>
		protected Dictionary<string, Packer> packers;

		/// <summary>
		///     The protections available to use.
		/// </summary>
		protected Dictionary<string, Protection> protections;

		/// <summary>
		///     Initalizes the Marker with specified protections and packers.
		/// </summary>
		/// <param name="protections">The protections.</param>
		/// <param name="packers">The packers.</param>
		public virtual void Initalize(IList<Protection> protections, IList<Packer> packers) {
			this.protections = protections.ToDictionary(prot => prot.Id, prot => prot, StringComparer.OrdinalIgnoreCase);
			this.packers = packers.ToDictionary(packer => packer.Id, packer => packer, StringComparer.OrdinalIgnoreCase);
		}

		/// <summary>
		///     Fills the protection settings with the specified preset.
		/// </summary>
		/// <param name="preset">The preset.</param>
		/// <param name="settings">The settings.</param>
		void FillPreset(ProtectionPreset preset, ProtectionSettings settings) {
			foreach (Protection prot in protections.Values)
				if (prot.Preset != ProtectionPreset.None && prot.Preset <= preset && !settings.ContainsKey(prot))
					settings.Add(prot, new Dictionary<string, string>());
		}

		/// <summary>
		///     Loads the Strong Name Key at the specified path with a optional password.
		/// </summary>
		/// <param name="context">The working context.</param>
		/// <param name="path">The path to the key.</param>
		/// <param name="pass">
		///     The password of the certificate at <paramref name="path" /> if
		///     it is a pfx file; otherwise, <c>null</c>.
		/// </param>
		/// <returns>The loaded Strong Name Key.</returns>
		public static StrongNameKey LoadSNKey(ConfuserContext context, string path, string pass) {
			if (path == null) return null;

			try {
				if (pass != null) //pfx
				{
					// http://stackoverflow.com/a/12196742/462805
					var cert = new X509Certificate2();
					cert.Import(path, pass, X509KeyStorageFlags.Exportable);

					var rsa = cert.PrivateKey as RSACryptoServiceProvider;
					if (rsa == null)
						throw new ArgumentException("RSA key does not present in the certificate.", "path");

					return new StrongNameKey(rsa.ExportCspBlob(true));
				}
				return new StrongNameKey(path);
			}
			catch (Exception ex) {
				context.Logger.ErrorException("Cannot load the Strong Name Key located at: " + path, ex);
				throw new ConfuserException(ex);
			}
		}

		/// <summary>
		///     Loads the assembly and marks the project.
		/// </summary>
		/// <param name="proj">The project.</param>
		/// <param name="context">The working context.</param>
		/// <returns><see cref="MarkerResult" /> storing the marked modules and packer information.</returns>
		protected internal virtual MarkerResult MarkProject(ConfuserProject proj, ConfuserContext context) {
			Packer packer = null;
			Dictionary<string, string> packerParams = null;

			if (proj.Packer != null) {
				if (!packers.ContainsKey(proj.Packer.Id)) {
					context.Logger.ErrorFormat("Cannot find packer with ID '{0}'.", proj.Packer.Id);
					throw new ConfuserException(null);
				}
				if (proj.Debug)
					context.Logger.Warn("Generated Debug symbols might not be usable with packers!");

				packer = packers[proj.Packer.Id];
				packerParams = new Dictionary<string, string>(proj.Packer, StringComparer.OrdinalIgnoreCase);
			}

			var modules = new List<Tuple<ProjectModule, ModuleDefMD>>();
			var extModules = new List<byte[]>();
			foreach (ProjectModule module in proj) {
				if (module.IsExternal) {
					extModules.Add(module.LoadRaw(proj.BaseDirectory));
					continue;
				}

				ModuleDefMD modDef = module.Resolve(proj.BaseDirectory, context.Resolver.DefaultModuleContext);
				context.CheckCancellation();

				if (proj.Debug)
					modDef.LoadPdb();

				context.Resolver.AddToCache(modDef);
				modules.Add(Tuple.Create(module, modDef));
			}

			foreach (var module in modules) {
				context.Logger.InfoFormat("Loading '{0}'...", module.Item1.Path);
				Rules rules = ParseRules(proj, module.Item1, context);

				context.Annotations.Set(module.Item2, SNKey, LoadSNKey(context, module.Item1.SNKeyPath == null ? null : Path.Combine(proj.BaseDirectory, module.Item1.SNKeyPath), module.Item1.SNKeyPassword));
				context.Annotations.Set(module.Item2, RulesKey, rules);

				foreach (IDnlibDef def in module.Item2.FindDefinitions()) {
					ApplyRules(context, def, rules);
					context.CheckCancellation();
				}

				// Packer parameters are stored in modules
				if (packerParams != null)
					ProtectionParameters.GetParameters(context, module.Item2)[packer] = packerParams;
			}
			return new MarkerResult(modules.Select(module => module.Item2).ToList(), packer, extModules);
		}

		/// <summary>
		///     Marks the member definition.
		/// </summary>
		/// <param name="member">The member definition.</param>
		/// <param name="context">The working context.</param>
		protected internal virtual void MarkMember(IDnlibDef member, ConfuserContext context) {
			ModuleDef module = ((IMemberRef)member).Module;
			var rules = context.Annotations.Get<Rules>(module, RulesKey);
			ApplyRules(context, member, rules);
		}

		/// <summary>
		///     Parses the rules' patterns.
		/// </summary>
		/// <param name="proj">The project.</param>
		/// <param name="module">The module description.</param>
		/// <param name="context">The working context.</param>
		/// <returns>Parsed rule patterns.</returns>
		/// <exception cref="System.ArgumentException">
		///     One of the rules has invalid pattern.
		/// </exception>
		protected Rules ParseRules(ConfuserProject proj, ProjectModule module, ConfuserContext context) {
			var ret = new Rules();
			var parser = new PatternParser();
			foreach (Rule rule in proj.Rules.Concat(module.Rules)) {
				try {
					ret.Add(rule, parser.Parse(rule.Pattern));
				}
				catch (InvalidPatternException ex) {
					context.Logger.ErrorFormat("Invalid rule pattern: " + rule.Pattern + ".", ex);
					throw new ConfuserException(ex);
				}
				foreach (var setting in rule) {
					if (!protections.ContainsKey(setting.Id)) {
						context.Logger.ErrorFormat("Cannot find protection with ID '{0}'.", setting.Id);
						throw new ConfuserException(null);
					}
				}
			}
			return ret;
		}

		/// <summary>
		///     Applies the rules to the target definition.
		/// </summary>
		/// <param name="context">The working context.</param>
		/// <param name="target">The target definition.</param>
		/// <param name="rules">The rules.</param>
		/// <param name="baseSettings">The base settings.</param>
		protected void ApplyRules(ConfuserContext context, IDnlibDef target, Rules rules, ProtectionSettings baseSettings = null) {
			var ret = baseSettings == null ? new ProtectionSettings() : new ProtectionSettings(baseSettings);
			foreach (var i in rules) {
				if (!(bool)i.Value.Evaluate(target)) continue;

				if (!i.Key.Inherit)
					ret.Clear();

				FillPreset(i.Key.Preset, ret);
				foreach (var prot in i.Key) {
					if (prot.Action == SettingItemAction.Add)
						ret[protections[prot.Id]] = new Dictionary<string, string>(prot, StringComparer.OrdinalIgnoreCase);
					else
						ret.Remove(protections[prot.Id]);
				}
			}

			ProtectionParameters.SetParameters(context, target, ret);
		}
	}
}


================================================
File: Confuser.Core/MarkerResult.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using dnlib.DotNet;

namespace Confuser.Core {
	/// <summary>
	///     Result of the marker.
	/// </summary>
	public class MarkerResult {
		/// <summary>
		///     Initializes a new instance of the <see cref="MarkerResult" /> class.
		/// </summary>
		/// <param name="modules">The modules.</param>
		/// <param name="packer">The packer.</param>
		/// <param name="extModules">The external modules.</param>
		public MarkerResult(IList<ModuleDefMD> modules, Packer packer, IList<byte[]> extModules) {
			Modules = modules;
			Packer = packer;
			ExternalModules = extModules;
		}

		/// <summary>
		///     Gets a list of modules that is marked.
		/// </summary>
		/// <value>The list of modules.</value>
		public IList<ModuleDefMD> Modules { get; private set; }

		/// <summary>
		///     Gets a list of external modules.
		/// </summary>
		/// <value>The list of external modules.</value>
		public IList<byte[]> ExternalModules { get; private set; }

		/// <summary>
		///     Gets the packer if exists.
		/// </summary>
		/// <value>The packer, or null if no packer exists.</value>
		public Packer Packer { get; private set; }
	}
}


================================================
File: Confuser.Core/ModuleSorter.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using dnlib.DotNet;

namespace Confuser.Core {
	/// <summary>
	///     Sort modules according dependencies.
	/// </summary>
	internal class ModuleSorter {
		readonly List<ModuleDefMD> modules;

		public ModuleSorter(IEnumerable<ModuleDefMD> modules) {
			this.modules = modules.ToList();
		}

		public IList<ModuleDefMD> Sort() {
			var edges = new List<DependencyGraphEdge>();
			var roots = new HashSet<ModuleDefMD>(modules);
			var asmMap = modules.GroupBy(module => module.Assembly.ToAssemblyRef(), AssemblyNameComparer.CompareAll)
			                    .ToDictionary(gp => gp.Key, gp => gp.ToList(), AssemblyNameComparer.CompareAll);

			foreach (ModuleDefMD m in modules)
				foreach (AssemblyRef nameRef in m.GetAssemblyRefs()) {
					if (!asmMap.ContainsKey(nameRef))
						continue;

					foreach (var asmModule in asmMap[nameRef])
						edges.Add(new DependencyGraphEdge(asmModule, m));
					roots.Remove(m);
				}

			var sorted = SortGraph(roots, edges).ToList();
			Debug.Assert(sorted.Count == modules.Count);
			return sorted;
		}

		IEnumerable<ModuleDefMD> SortGraph(IEnumerable<ModuleDefMD> roots, IList<DependencyGraphEdge> edges) {
			var visited = new HashSet<ModuleDefMD>();
			var queue = new Queue<ModuleDefMD>(roots);
			do {
				while (queue.Count > 0) {
					var node = queue.Dequeue();
					visited.Add(node);

					Debug.Assert(!edges.Where(edge => edge.To == node).Any());
					yield return node;

					foreach (DependencyGraphEdge edge in edges.Where(edge => edge.From == node).ToList()) {
						edges.Remove(edge);
						if (!edges.Any(e => e.To == edge.To))
							queue.Enqueue(edge.To);
					}
				}
				if (edges.Count > 0) {
					foreach (var edge in edges) {
						if (!visited.Contains(edge.From)) {
							queue.Enqueue(edge.From);
							break;
						}
					}
				}
			} while (edges.Count > 0);
		}

		class DependencyGraphEdge {
			public DependencyGraphEdge(ModuleDefMD from, ModuleDefMD to) {
				From = from;
				To = to;
			}

			public ModuleDefMD From { get; private set; }
			public ModuleDefMD To { get; private set; }
		}
	}
}


================================================
File: Confuser.Core/ModuleWriterListener.cs
================================================
ï»¿using System;
using dnlib.DotNet;
using dnlib.DotNet.Writer;

namespace Confuser.Core {
	/// <summary>
	///     The listener of module writer event.
	/// </summary>
	public class ModuleWriterListener : IModuleWriterListener {
		/// <inheritdoc />
		void IModuleWriterListener.OnWriterEvent(ModuleWriterBase writer, ModuleWriterEvent evt) {
			if (evt == ModuleWriterEvent.PESectionsCreated)
				NativeEraser.Erase(writer as NativeModuleWriter, writer.Module as ModuleDefMD);
			if (OnWriterEvent != null) {
				OnWriterEvent(writer, new ModuleWriterListenerEventArgs(evt));
			}
		}

		/// <summary>
		///     Occurs when a module writer event is triggered.
		/// </summary>
		public event EventHandler<ModuleWriterListenerEventArgs> OnWriterEvent;
	}

	/// <summary>
	///     Indicates the triggered writer event.
	/// </summary>
	public class ModuleWriterListenerEventArgs : EventArgs {
		/// <summary>
		///     Initializes a new instance of the <see cref="ModuleWriterListenerEventArgs" /> class.
		/// </summary>
		/// <param name="evt">The triggered writer event.</param>
		public ModuleWriterListenerEventArgs(ModuleWriterEvent evt) {
			WriterEvent = evt;
		}

		/// <summary>
		///     Gets the triggered writer event.
		/// </summary>
		/// <value>The triggered writer event.</value>
		public ModuleWriterEvent WriterEvent { get; private set; }
	}
}


================================================
File: Confuser.Core/NativeEraser.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.IO;
using dnlib.DotNet;
using dnlib.DotNet.Writer;
using dnlib.IO;
using dnlib.PE;
using SR = System.Reflection;

namespace Confuser.Core {
	internal class NativeEraser {
		static void Erase(Tuple<uint, uint, byte[]> section, uint offset, uint len) {
			Array.Clear(section.Item3, (int)(offset - section.Item1), (int)len);
		}

		static void Erase(List<Tuple<uint, uint, byte[]>> sections, uint beginOffset, uint size) {
			foreach (var sect in sections)
				if (beginOffset >= sect.Item1 && beginOffset + size < sect.Item2) {
					Erase(sect, beginOffset, size);
					break;
				}
		}

		static void Erase(List<Tuple<uint, uint, byte[]>> sections, IFileSection s) {
			foreach (var sect in sections)
				if ((uint)s.StartOffset >= sect.Item1 && (uint)s.EndOffset < sect.Item2) {
					Erase(sect, (uint)s.StartOffset, (uint)(s.EndOffset - s.StartOffset));
					break;
				}
		}

		static void Erase(List<Tuple<uint, uint, byte[]>> sections, uint methodOffset) {
			foreach (var sect in sections)
				if (methodOffset >= sect.Item1 && methodOffset - sect.Item1 < sect.Item3.Length) {
					uint f = sect.Item3[methodOffset - sect.Item1];
					uint size;
					switch ((f & 7)) {
						case 2:
						case 6:
							size = (f >> 2) + 1;
							break;

						case 3:
							f |= (uint)((sect.Item3[methodOffset - sect.Item1 + 1]) << 8);
							size = (f >> 12) * 4;
							uint codeSize = BitConverter.ToUInt32(sect.Item3, (int)(methodOffset - sect.Item1 + 4));
							size += codeSize;
							break;
						default:
							return;
					}
					Erase(sect, methodOffset, size);
				}
		}

		public static void Erase(NativeModuleWriter writer, ModuleDefMD module) {
			if (writer == null || module == null)
				return;

			var sections = new List<Tuple<uint, uint, byte[]>>();
			var s = new MemoryStream();
			foreach (var origSect in writer.OrigSections) {
				var oldChunk = origSect.Chunk;
				var sectHdr = origSect.PESection;

				s.SetLength(0);
				oldChunk.WriteTo(new BinaryWriter(s));
				var buf = s.ToArray();
				var newChunk = new BinaryReaderChunk(MemoryImageStream.Create(buf), oldChunk.GetVirtualSize());
				newChunk.SetOffset(oldChunk.FileOffset, oldChunk.RVA);

				origSect.Chunk = newChunk;

				sections.Add(Tuple.Create(
					sectHdr.PointerToRawData,
					sectHdr.PointerToRawData + sectHdr.SizeOfRawData,
					buf));
			}

			var md = module.MetaData;

			var row = md.TablesStream.MethodTable.Rows;
			for (uint i = 1; i <= row; i++) {
				var method = md.TablesStream.ReadMethodRow(i);
				var codeType = ((MethodImplAttributes)method.ImplFlags & MethodImplAttributes.CodeTypeMask);
				if (codeType == MethodImplAttributes.IL)
					Erase(sections, (uint)md.PEImage.ToFileOffset((RVA)method.RVA));
			}

			var res = md.ImageCor20Header.Resources;
			if (res.Size > 0)
				Erase(sections, (uint)res.StartOffset, res.Size);

			Erase(sections, md.ImageCor20Header);
			Erase(sections, md.MetaDataHeader);
			foreach (var stream in md.AllStreams)
				Erase(sections, stream);
		}
	}
}


================================================
File: Confuser.Core/NullLogger.cs
================================================
ï»¿using System;
using dnlib.DotNet;

namespace Confuser.Core {
	/// <summary>
	///     An <see cref="ILogger" /> implementation that doesn't actually do any logging.
	/// </summary>
	internal class NullLogger : ILogger {
		/// <summary>
		///     The singleton instance of <see cref="NullLogger" />.
		/// </summary>
		public static readonly NullLogger Instance = new NullLogger();

		/// <summary>
		///     Prevents a default instance of the <see cref="NullLogger" /> class from being created.
		/// </summary>
		NullLogger() { }

		/// <inheritdoc />
		public void Debug(string msg) { }

		/// <inheritdoc />
		public void DebugFormat(string format, params object[] args) { }

		/// <inheritdoc />
		public void Info(string msg) { }

		/// <inheritdoc />
		public void InfoFormat(string format, params object[] args) { }

		/// <inheritdoc />
		public void Warn(string msg) { }

		/// <inheritdoc />
		public void WarnFormat(string format, params object[] args) { }

		/// <inheritdoc />
		public void WarnException(string msg, Exception ex) { }

		/// <inheritdoc />
		public void Error(string msg) { }

		/// <inheritdoc />
		public void ErrorFormat(string format, params object[] args) { }

		/// <inheritdoc />
		public void ErrorException(string msg, Exception ex) { }

		/// <inheritdoc />
		public void Progress(int overall, int progress) { }

		/// <inheritdoc />
		public void EndProgress() { }

		/// <inheritdoc />
		public void Finish(bool successful) { }

		/// <inheritdoc />
		public void BeginModule(ModuleDef module) { }

		/// <inheritdoc />
		public void EndModule(ModuleDef module) { }
	}
}


================================================
File: Confuser.Core/ObfAttrMarker.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using Confuser.Core.Project;
using Confuser.Core.Project.Patterns;
using dnlib.DotNet;

namespace Confuser.Core {
	using Rules = Dictionary<Rule, PatternExpression>;

	/// <summary>
	/// Obfuscation Attribute Marker
	/// </summary>
	public class ObfAttrMarker : Marker {
		struct ObfuscationAttributeInfo {
			public IHasCustomAttribute Owner;
			public bool? ApplyToMembers;
			public bool? Exclude;
			public string FeatureName;
			public string FeatureValue;
		}

		struct ProtectionSettingsInfo {
			public bool ApplyToMember;
			public bool Exclude;

			public PatternExpression Condition;
			public string Settings;
		}

		class ProtectionSettingsStack {
			readonly ConfuserContext context;
			readonly Stack<Tuple<ProtectionSettings, ProtectionSettingsInfo[]>> stack;
			readonly ObfAttrParser parser;
			ProtectionSettings settings;

			enum ApplyInfoType {
				CurrentInfoOnly,
				CurrentInfoInherits,
				ParentInfo
			}

			class PopHolder : IDisposable {
				ProtectionSettingsStack parent;

				public PopHolder(ProtectionSettingsStack parent) {
					this.parent = parent;
				}

				public void Dispose() {
					parent.Pop();
				}
			}

			public ProtectionSettingsStack(ConfuserContext context, Dictionary<string, Protection> protections) {
				this.context = context;
				stack = new Stack<Tuple<ProtectionSettings, ProtectionSettingsInfo[]>>();
				parser = new ObfAttrParser(protections);
			}

			public ProtectionSettingsStack(ProtectionSettingsStack copy) {
				context = copy.context;
				stack = new Stack<Tuple<ProtectionSettings, ProtectionSettingsInfo[]>>(copy.stack);
				parser = copy.parser;
			}

			void Pop() {
				settings = stack.Pop().Item1;
			}

			public IDisposable Apply(IDnlibDef target, IEnumerable<ProtectionSettingsInfo> infos) {
				ProtectionSettings settings;
				if (this.settings == null)
					settings = new ProtectionSettings();
				else
					settings = new ProtectionSettings(this.settings);

				var infoArray = infos.ToArray();

				if (stack.Count > 0) {
					foreach (var i in stack.Reverse())
						ApplyInfo(target, settings, i.Item2, ApplyInfoType.ParentInfo);
				}

				IDisposable result;
				if (infoArray.Length != 0) {
					var originalSettings = this.settings;

					// the settings that would apply to members
					ApplyInfo(target, settings, infoArray, ApplyInfoType.CurrentInfoInherits);
					this.settings = new ProtectionSettings(settings);

					// the settings that would apply to itself
					ApplyInfo(target, settings, infoArray, ApplyInfoType.CurrentInfoOnly);
					stack.Push(Tuple.Create(originalSettings, infoArray));

					result = new PopHolder(this);
				}
				else
					result = null;

				ProtectionParameters.SetParameters(context, target, settings);
				return result;
			}

			void ApplyInfo(IDnlibDef context, ProtectionSettings settings, IEnumerable<ProtectionSettingsInfo> infos, ApplyInfoType type) {
				foreach (var info in infos) {
					if (info.Condition != null && !(bool)info.Condition.Evaluate(context))
						continue;

					if (info.Condition == null && info.Exclude) {
						if (type == ApplyInfoType.CurrentInfoOnly ||
							(type == ApplyInfoType.CurrentInfoInherits && info.ApplyToMember)) {
							settings.Clear();
						}
					}
					if (!string.IsNullOrEmpty(info.Settings)) {
						if ((type == ApplyInfoType.ParentInfo && info.Condition != null && info.ApplyToMember) ||
							type == ApplyInfoType.CurrentInfoOnly ||
							(type == ApplyInfoType.CurrentInfoInherits && info.Condition == null && info.ApplyToMember)) {
							parser.ParseProtectionString(settings, info.Settings);
						}
					}
				}
			}
		}

		static readonly Regex OrderPattern = new Regex("^(\\d+)\\. (.+)$");

		static IEnumerable<ObfuscationAttributeInfo> ReadObfuscationAttributes(IHasCustomAttribute item) {
			var ret = new List<Tuple<int?, ObfuscationAttributeInfo>>();
			for (int i = item.CustomAttributes.Count - 1; i >= 0; i--) {
				var ca = item.CustomAttributes[i];
				if (ca.TypeFullName != "System.Reflection.ObfuscationAttribute")
					continue;

				var info = new ObfuscationAttributeInfo();
				int? order = null;

				info.Owner = item;
				bool strip = true;
				foreach (var prop in ca.Properties) {
					switch (prop.Name) {
						case "ApplyToMembers":
							Debug.Assert(prop.Type.ElementType == ElementType.Boolean);
							info.ApplyToMembers = (bool)prop.Value;
							break;

						case "Exclude":
							Debug.Assert(prop.Type.ElementType == ElementType.Boolean);
							info.Exclude = (bool)prop.Value;
							break;

						case "StripAfterObfuscation":
							Debug.Assert(prop.Type.ElementType == ElementType.Boolean);
							strip = (bool)prop.Value;
							break;

						case "Feature":
							Debug.Assert(prop.Type.ElementType == ElementType.String);
							string feature = (UTF8String)prop.Value;

							var match = OrderPattern.Match(feature);
							if (match.Success) {
								var orderStr = match.Groups[1].Value;
								var f = match.Groups[2].Value;
								int o;
								if (!int.TryParse(orderStr, out o))
									throw new NotSupportedException(string.Format("Failed to parse feature '{0}' in {1} ", feature, item));
								order = o;
								feature = f;
							}

							int sepIndex = feature.IndexOf(':');
							if (sepIndex == -1) {
								info.FeatureName = "";
								info.FeatureValue = feature;
							}
							else {
								info.FeatureName = feature.Substring(0, sepIndex);
								info.FeatureValue = feature.Substring(sepIndex + 1);
							}
							break;

						default:
							throw new NotSupportedException("Unsupported property: " + prop.Name);
					}
				}
				if (strip)
					item.CustomAttributes.RemoveAt(i);

				ret.Add(Tuple.Create(order, info));
			}
			ret.Reverse();
			return ret.OrderBy(pair => pair.Item1).Select(pair => pair.Item2);
		}

		bool ToInfo(ObfuscationAttributeInfo attr, out ProtectionSettingsInfo info) {
			info = new ProtectionSettingsInfo();

			info.Condition = null;

			info.Exclude = (attr.Exclude ?? true);
			info.ApplyToMember = (attr.ApplyToMembers ?? true);
			info.Settings = attr.FeatureValue;

			bool ok = true;
			try {
				new ObfAttrParser(protections).ParseProtectionString(null, info.Settings);
			}
			catch {
				ok = false;
			}

			if (!ok) {
				context.Logger.WarnFormat("Ignoring rule '{0}' in {1}.", info.Settings, attr.Owner);
				return false;
			}

			if (!string.IsNullOrEmpty(attr.FeatureName))
				throw new ArgumentException("Feature name must not be set. Owner=" + attr.Owner);
			if (info.Exclude && (!string.IsNullOrEmpty(attr.FeatureName) || !string.IsNullOrEmpty(attr.FeatureValue))) {
				throw new ArgumentException("Feature property cannot be set when Exclude is true. Owner=" + attr.Owner);
			}
			return true;
		}

		ProtectionSettingsInfo ToInfo(Rule rule, PatternExpression expr) {
			var info = new ProtectionSettingsInfo();

			info.Condition = expr;

			info.Exclude = false;
			info.ApplyToMember = true;

			var settings = new StringBuilder();
			if (rule.Preset != ProtectionPreset.None)
				settings.AppendFormat("preset({0});", rule.Preset.ToString().ToLowerInvariant());
			foreach (var item in rule) {
				settings.Append(item.Action == SettingItemAction.Add ? '+' : '-');
				settings.Append(item.Id);
				if (item.Count > 0) {
					settings.Append('(');
					int i = 0;
					foreach (var arg in item) {
						if (i != 0)
							settings.Append(',');
						settings.AppendFormat("{0}='{1}'", arg.Key, arg.Value.Replace("'", "\\'"));
						i++;
					}
					settings.Append(')');
				}
				settings.Append(';');
			}
			info.Settings = settings.ToString();

			return info;
		}

		IEnumerable<ProtectionSettingsInfo> ReadInfos(IHasCustomAttribute item) {
			foreach (var attr in ReadObfuscationAttributes(item)) {
				ProtectionSettingsInfo info;
				if (!string.IsNullOrEmpty(attr.FeatureName))
					yield return AddRule(attr, null);
				else if (ToInfo(attr, out info))
					yield return info;
			}
		}

		ConfuserContext context;
		ConfuserProject project;
		Packer packer;
		Dictionary<string, string> packerParams;
		List<byte[]> extModules;

		static readonly object ModuleSettingsKey = new object();

		/// <inheritdoc />
		protected internal override void MarkMember(IDnlibDef member, ConfuserContext context) {
			ModuleDef module = ((IMemberRef)member).Module;
			var stack = context.Annotations.Get<ProtectionSettingsStack>(module, ModuleSettingsKey);
			using (stack.Apply(member, Enumerable.Empty<ProtectionSettingsInfo>()))
				return;
		}

		/// <inheritdoc />
		protected internal override MarkerResult MarkProject(ConfuserProject proj, ConfuserContext context) {
			this.context = context;
			project = proj;
			extModules = new List<byte[]>();

			if (proj.Packer != null) {
				if (!packers.ContainsKey(proj.Packer.Id)) {
					context.Logger.ErrorFormat("Cannot find packer with ID '{0}'.", proj.Packer.Id);
					throw new ConfuserException(null);
				}

				packer = packers[proj.Packer.Id];
				packerParams = new Dictionary<string, string>(proj.Packer, StringComparer.OrdinalIgnoreCase);
			}

			var modules = new List<Tuple<ProjectModule, ModuleDefMD>>();
			foreach (ProjectModule module in proj) {
				if (module.IsExternal) {
					extModules.Add(module.LoadRaw(proj.BaseDirectory));
					continue;
				}

				ModuleDefMD modDef = module.Resolve(proj.BaseDirectory, context.Resolver.DefaultModuleContext);
				context.CheckCancellation();

				context.Resolver.AddToCache(modDef);
				modules.Add(Tuple.Create(module, modDef));
			}
			foreach (var module in modules) {
				context.Logger.InfoFormat("Loading '{0}'...", module.Item1.Path);

				Rules rules = ParseRules(proj, module.Item1, context);
				MarkModule(module.Item1, module.Item2, rules, module == modules[0]);

				context.Annotations.Set(module.Item2, RulesKey, rules);

				// Packer parameters are stored in modules
				if (packer != null)
					ProtectionParameters.GetParameters(context, module.Item2)[packer] = packerParams;
			}

			if (proj.Debug && proj.Packer != null)
				context.Logger.Warn("Generated Debug symbols might not be usable with packers!");

			return new MarkerResult(modules.Select(module => module.Item2).ToList(), packer, extModules);
		}

		ProtectionSettingsInfo AddRule(ObfuscationAttributeInfo attr, List<ProtectionSettingsInfo> infos) {
			Debug.Assert(attr.FeatureName != null);

			var pattern = attr.FeatureName;
			PatternExpression expr;
			try {
				expr = new PatternParser().Parse(pattern);
			}
			catch (Exception ex) {
				throw new Exception("Error when parsing pattern " + pattern + " in ObfuscationAttribute. Owner=" + attr.Owner, ex);
			}

			var info = new ProtectionSettingsInfo();
			info.Condition = expr;

			info.Exclude = (attr.Exclude ?? true);
			info.ApplyToMember = (attr.ApplyToMembers ?? true);
			info.Settings = attr.FeatureValue;

			bool ok = true;
			try {
				new ObfAttrParser(protections).ParseProtectionString(null, info.Settings);
			}
			catch {
				ok = false;
			}

			if (!ok)
				context.Logger.WarnFormat("Ignoring rule '{0}' in {1}.", info.Settings, attr.Owner);
			else if (infos != null)
				infos.Add(info);
			return info;
		}

		void MarkModule(ProjectModule projModule, ModuleDefMD module, Rules rules, bool isMain) {
			string snKeyPath = projModule.SNKeyPath, snKeyPass = projModule.SNKeyPassword;
			var stack = new ProtectionSettingsStack(context, protections);

			var layer = new List<ProtectionSettingsInfo>();
			// Add rules
			foreach (var rule in rules)
				layer.Add(ToInfo(rule.Key, rule.Value));

			// Add obfuscation attributes
			foreach (var attr in ReadObfuscationAttributes(module.Assembly)) {
				if (string.IsNullOrEmpty(attr.FeatureName)) {
					ProtectionSettingsInfo info;
					if (ToInfo(attr, out info))
						layer.Add(info);
				}
				else if (attr.FeatureName.Equals("generate debug symbol", StringComparison.OrdinalIgnoreCase)) {
					if (!isMain)
						throw new ArgumentException("Only main module can set 'generate debug symbol'.");
					project.Debug = bool.Parse(attr.FeatureValue);
				}
				else if (attr.FeatureName.Equals("random seed", StringComparison.OrdinalIgnoreCase)) {
					if (!isMain)
						throw new ArgumentException("Only main module can set 'random seed'.");
					project.Seed = attr.FeatureValue;
				}
				else if (attr.FeatureName.Equals("strong name key", StringComparison.OrdinalIgnoreCase)) {
					snKeyPath = Path.Combine(project.BaseDirectory, attr.FeatureValue);
				}
				else if (attr.FeatureName.Equals("strong name key password", StringComparison.OrdinalIgnoreCase)) {
					snKeyPass = attr.FeatureValue;
				}
				else if (attr.FeatureName.Equals("packer", StringComparison.OrdinalIgnoreCase)) {
					if (!isMain)
						throw new ArgumentException("Only main module can set 'packer'.");
					new ObfAttrParser(packers).ParsePackerString(attr.FeatureValue, out packer, out packerParams);
				}
				else if (attr.FeatureName.Equals("external module", StringComparison.OrdinalIgnoreCase)) {
					if (!isMain)
						throw new ArgumentException("Only main module can add external modules.");
					var rawModule = new ProjectModule { Path = attr.FeatureValue }.LoadRaw(project.BaseDirectory);
					extModules.Add(rawModule);
				}
				else {
					AddRule(attr, layer);
				}
			}

			if (project.Debug) {
				module.LoadPdb();
			}

			snKeyPath = snKeyPath == null ? null : Path.Combine(project.BaseDirectory, snKeyPath);
			var snKey = LoadSNKey(context, snKeyPath, snKeyPass);
			context.Annotations.Set(module, SNKey, snKey);

			using (stack.Apply(module, layer))
				ProcessModule(module, stack);
		}

		void ProcessModule(ModuleDefMD module, ProtectionSettingsStack stack) {
			context.Annotations.Set(module, ModuleSettingsKey, new ProtectionSettingsStack(stack));
			foreach (var type in module.Types) {
				using (stack.Apply(type, ReadInfos(type)))
					ProcessTypeMembers(type, stack);
			}
		}

		void ProcessTypeMembers(TypeDef type, ProtectionSettingsStack stack) {
			foreach (var nestedType in type.NestedTypes) {
				using (stack.Apply(nestedType, ReadInfos(nestedType)))
					ProcessTypeMembers(nestedType, stack);
			}

			foreach (var property in type.Properties) {
				using (stack.Apply(property, ReadInfos(property))) {
					if (property.GetMethod != null)
						ProcessMember(property.GetMethod, stack);

					if (property.SetMethod != null)
						ProcessMember(property.SetMethod, stack);

					foreach (var m in property.OtherMethods)
						ProcessMember(m, stack);
				}
			}

			foreach (var evt in type.Events) {
				using (stack.Apply(evt, ReadInfos(evt))) {
					if (evt.AddMethod != null)
						ProcessMember(evt.AddMethod, stack);

					if (evt.RemoveMethod != null)
						ProcessMember(evt.RemoveMethod, stack);

					if (evt.InvokeMethod != null)
						ProcessMember(evt.InvokeMethod, stack);

					foreach (var m in evt.OtherMethods)
						ProcessMember(m, stack);
				}
			}

			foreach (var method in type.Methods) {
				if (method.SemanticsAttributes == 0)
					ProcessMember(method, stack);
			}

			foreach (var field in type.Fields) {
				ProcessMember(field, stack);
			}
		}

		void ProcessMember(IDnlibDef member, ProtectionSettingsStack stack) {
			using (stack.Apply(member, ReadInfos(member)))
				ProcessBody(member as MethodDef, stack);
		}

		void ProcessBody(MethodDef method, ProtectionSettingsStack stack) {
			if (method == null || method.Body == null)
				return;

			var declType = method.DeclaringType;
			foreach (var instr in method.Body.Instructions)
				if (instr.Operand is MethodDef) {
					var cgType = ((MethodDef)instr.Operand).DeclaringType;
					if (cgType.DeclaringType == declType && cgType.IsCompilerGenerated()) {
						using (stack.Apply(cgType, ReadInfos(cgType)))
							ProcessTypeMembers(cgType, stack);
					}
				}
		}
	}
}



================================================
File: Confuser.Core/ObfAttrParser.cs
================================================
ï»¿using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Confuser.Core {
	internal struct ObfAttrParser {
		readonly IDictionary items;

		string str;
		int index;

		public ObfAttrParser(IDictionary items) {
			this.items = items;
			str = null;
			index = -1;
		}

		enum ParseState {
			Init,
			ReadPreset,
			ReadItemName,
			ProcessItemName,
			ReadParam,
			EndItem,
			End
		}

		bool ReadId(StringBuilder sb) {
			while (index < str.Length) {
				switch (str[index]) {
					case '(':
					case ')':
					case '+':
					case '-':
					case '=':
					case ';':
					case ',':
						return true;
					default:
						sb.Append(str[index++]);
						break;
				}
			}
			return false;
		}

		bool ReadString(StringBuilder sb) {
			Expect('\'');
			while (index < str.Length) {
				switch (str[index]) {
					case '\\':
						sb.Append(str[++index]);
						break;
					case '\'':
						index++;
						return true;
					default:
						sb.Append(str[index]);
						break;
				}
				index++;
			}
			return false;
		}

		void Expect(char chr) {
			if (str[index] != chr)
				throw new ArgumentException("Expect '" + chr + "' at position " + (index + 1) + ".");
			index++;
		}

		char Peek() {
			return str[index];
		}

		void Next() {
			index++;
		}

		bool IsEnd() {
			return index == str.Length;
		}

		public void ParseProtectionString(IDictionary<ConfuserComponent, Dictionary<string, string>> settings, string str) {
			if (str == null)
				return;

			this.str = str;
			index = 0;

			var state = ParseState.Init;
			var buffer = new StringBuilder();

			bool protAct = true;
			string protId = null;
			var protParams = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

			while (state != ParseState.End) {
				switch (state) {
					case ParseState.Init:
						ReadId(buffer);
						if (buffer.ToString().Equals("preset", StringComparison.OrdinalIgnoreCase)) {
							if (IsEnd())
								throw new ArgumentException("Unexpected end of string in Init state.");
							Expect('(');
							buffer.Length = 0;
							state = ParseState.ReadPreset;
						}
						else if (buffer.Length == 0) {
							if (IsEnd())
								throw new ArgumentException("Unexpected end of string in Init state.");
							state = ParseState.ReadItemName;
						}
						else {
							protAct = true;
							state = ParseState.ProcessItemName;
						}
						break;

					case ParseState.ReadPreset:
						if (!ReadId(buffer))
							throw new ArgumentException("Unexpected end of string in ReadPreset state.");
						Expect(')');

						var preset = (ProtectionPreset)Enum.Parse(typeof(ProtectionPreset), buffer.ToString(), true);
						foreach (var item in items.Values.OfType<Protection>().Where(prot => prot.Preset <= preset)) {
							if (item.Preset != ProtectionPreset.None && settings != null && !settings.ContainsKey(item))
								settings.Add(item, new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase));
						}
						buffer.Length = 0;

						if (IsEnd())
							state = ParseState.End;
						else {
							Expect(';');
							if (IsEnd())
								state = ParseState.End;
							else
								state = ParseState.ReadItemName;
						}
						break;

					case ParseState.ReadItemName:
						protAct = true;
						if (Peek() == '+') {
							protAct = true;
							Next();
						}
						else if (Peek() == '-') {
							protAct = false;
							Next();
						}
						ReadId(buffer);
						state = ParseState.ProcessItemName;
						break;

					case ParseState.ProcessItemName:
						protId = buffer.ToString();
						buffer.Length = 0;
						if (IsEnd() || Peek() == ';')
							state = ParseState.EndItem;
						else if (Peek() == '(') {
							if (!protAct)
								throw new ArgumentException("No parameters is allowed when removing protection.");
							Next();
							state = ParseState.ReadParam;
						}
						else
							throw new ArgumentException("Unexpected character in ProcessItemName state at " + index + ".");
						break;

					case ParseState.ReadParam:
						string paramName, paramValue;

						if (!ReadId(buffer))
							throw new ArgumentException("Unexpected end of string in ReadParam state.");
						paramName = buffer.ToString();
						buffer.Length = 0;

						Expect('=');
						if (!(Peek() == '\'' ? ReadString(buffer) : ReadId(buffer)))
							throw new ArgumentException("Unexpected end of string in ReadParam state.");

						paramValue = buffer.ToString();
						buffer.Length = 0;

						protParams.Add(paramName, paramValue);

						if (Peek() == ',') {
							Next();
							state = ParseState.ReadParam;
						}
						else if (Peek() == ')') {
							Next();
							state = ParseState.EndItem;
						}
						else
							throw new ArgumentException("Unexpected character in ReadParam state at " + index + ".");
						break;

					case ParseState.EndItem:
						if (settings != null) {
							if (!items.Contains(protId))
								throw new KeyNotFoundException("Cannot find protection with id '" + protId + "'.");

							if (protAct) {
								if (settings.ContainsKey((Protection)items[protId])) {
									var p = settings[(Protection)items[protId]];
									foreach (var kvp in protParams)
										p[kvp.Key] = kvp.Value;
								}
								else
									settings[(Protection)items[protId]] = protParams;
							}
							else
								settings.Remove((Protection)items[protId]);
						}
						protParams = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

						if (IsEnd())
							state = ParseState.End;
						else {
							Expect(';');
							if (IsEnd())
								state = ParseState.End;
							else
								state = ParseState.ReadItemName;
						}
						break;
				}
			}
		}

		public void ParsePackerString(string str, out Packer packer, out Dictionary<string, string> packerParams) {
			packer = null;
			packerParams = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

			if (str == null)
				return;

			this.str = str;
			index = 0;

			var state = ParseState.ReadItemName;
			var buffer = new StringBuilder();
			var ret = new ProtectionSettings();

			while (state != ParseState.End) {
				switch (state) {
					case ParseState.ReadItemName:
						ReadId(buffer);

						var packerId = buffer.ToString();
						if (!items.Contains(packerId))
							throw new KeyNotFoundException("Cannot find packer with id '" + packerId + "'.");

						packer = (Packer)items[packerId];
						buffer.Length = 0;

						if (IsEnd() || Peek() == ';')
							state = ParseState.EndItem;
						else if (Peek() == '(') {
							Next();
							state = ParseState.ReadParam;
						}
						else
							throw new ArgumentException("Unexpected character in ReadItemName state at " + index + ".");
						break;

					case ParseState.ReadParam:
						string paramName, paramValue;

						if (!ReadId(buffer))
							throw new ArgumentException("Unexpected end of string in ReadParam state.");
						paramName = buffer.ToString();
						buffer.Length = 0;

						Expect('=');
						if (!ReadId(buffer))
							throw new ArgumentException("Unexpected end of string in ReadParam state.");
						paramValue = buffer.ToString();
						buffer.Length = 0;

						packerParams.Add(paramName, paramValue);

						if (Peek() == ',') {
							Next();
							state = ParseState.ReadParam;
						}
						else if (Peek() == ')') {
							Next();
							state = ParseState.EndItem;
						}
						else
							throw new ArgumentException("Unexpected character in ReadParam state at " + index + ".");
						break;

					case ParseState.EndItem:
						if (IsEnd())
							state = ParseState.End;
						else {
							Expect(';');
							if (!IsEnd())
								throw new ArgumentException("Unexpected character in EndItem state at " + index + ".");
							state = ParseState.End;
						}
						break;
				}
			}
		}
	}
}


================================================
File: Confuser.Core/Packer.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.IO;
using Confuser.Core.Project;
using dnlib.DotNet;

namespace Confuser.Core {
	/// <summary>
	///     Base class of Confuser packers.
	/// </summary>
	/// <remarks>
	///     A parameterless constructor must exists in derived classes to enable plugin discovery.
	/// </remarks>
	public abstract class Packer : ConfuserComponent {
		/// <summary>
		///     Executes the packer.
		/// </summary>
		/// <param name="context">The working context.</param>
		/// <param name="parameters">The parameters of packer.</param>
		protected internal abstract void Pack(ConfuserContext context, ProtectionParameters parameters);

		/// <summary>
		///     Protects the stub using original project settings replace the current output with the protected stub.
		/// </summary>
		/// <param name="context">The working context.</param>
		/// <param name="fileName">The result file name.</param>
		/// <param name="module">The stub module.</param>
		/// <param name="snKey">The strong name key.</param>
		/// <param name="prot">The packer protection that applies to the stub.</param>
		protected void ProtectStub(ConfuserContext context, string fileName, byte[] module, StrongNameKey snKey, Protection prot = null) {
			string tmpDir = Path.Combine(Path.GetTempPath(), Path.GetRandomFileName());
			string outDir = Path.Combine(tmpDir, Path.GetRandomFileName());
			Directory.CreateDirectory(tmpDir);

			for (int i = 0; i < context.OutputModules.Count; i++) {
				string path = Path.GetFullPath(Path.Combine(tmpDir, context.OutputPaths[i]));
				var dir = Path.GetDirectoryName(path);
				if (!Directory.Exists(dir))
					Directory.CreateDirectory(dir);
				File.WriteAllBytes(path, context.OutputModules[i]);
			}
			File.WriteAllBytes(Path.Combine(tmpDir, fileName), module);

			var proj = new ConfuserProject();
			proj.Seed = context.Project.Seed;
			foreach (Rule rule in context.Project.Rules)
				proj.Rules.Add(rule);
			proj.Add(new ProjectModule {
				Path = fileName
			});
			proj.BaseDirectory = tmpDir;
			proj.OutputDirectory = outDir;
			foreach (var path in context.Project.ProbePaths)
				proj.ProbePaths.Add(path);
			proj.ProbePaths.Add(context.Project.BaseDirectory);

			PluginDiscovery discovery = null;
			if (prot != null) {
				var rule = new Rule {
					Preset = ProtectionPreset.None,
					Inherit = true,
					Pattern = "true"
				};
				rule.Add(new SettingItem<Protection> {
					Id = prot.Id,
					Action = SettingItemAction.Add
				});
				proj.Rules.Add(rule);
				discovery = new PackerDiscovery(prot);
			}

			try {
				ConfuserEngine.Run(new ConfuserParameters {
					Logger = new PackerLogger(context.Logger),
					PluginDiscovery = discovery,
					Marker = new PackerMarker(snKey),
					Project = proj,
					PackerInitiated = true
				}, context.token).Wait();
			}
			catch (AggregateException ex) {
				context.Logger.Error("Failed to protect packer stub.");
				throw new ConfuserException(ex);
			}

			context.OutputModules = new[] { File.ReadAllBytes(Path.Combine(outDir, fileName)) };
			context.OutputPaths = new[] { fileName };
		}
	}

	internal class PackerLogger : ILogger {
		readonly ILogger baseLogger;

		public PackerLogger(ILogger baseLogger) {
			this.baseLogger = baseLogger;
		}

		public void Debug(string msg) {
			baseLogger.Debug(msg);
		}

		public void DebugFormat(string format, params object[] args) {
			baseLogger.DebugFormat(format, args);
		}

		public void Info(string msg) {
			baseLogger.Info(msg);
		}

		public void InfoFormat(string format, params object[] args) {
			baseLogger.InfoFormat(format, args);
		}

		public void Warn(string msg) {
			baseLogger.Warn(msg);
		}

		public void WarnFormat(string format, params object[] args) {
			baseLogger.WarnFormat(format, args);
		}

		public void WarnException(string msg, Exception ex) {
			baseLogger.WarnException(msg, ex);
		}

		public void Error(string msg) {
			baseLogger.Error(msg);
		}

		public void ErrorFormat(string format, params object[] args) {
			baseLogger.ErrorFormat(format, args);
		}

		public void ErrorException(string msg, Exception ex) {
			baseLogger.ErrorException(msg, ex);
		}

		public void Progress(int progress, int overall) {
			baseLogger.Progress(progress, overall);
		}

		public void EndProgress() {
			baseLogger.EndProgress();
		}

		public void Finish(bool successful) {
			if (!successful)
				throw new ConfuserException(null);
			baseLogger.Info("Finish protecting packer stub.");
		}
	}

	internal class PackerMarker : Marker {
		readonly StrongNameKey snKey;

		public PackerMarker(StrongNameKey snKey) {
			this.snKey = snKey;
		}

		protected internal override MarkerResult MarkProject(ConfuserProject proj, ConfuserContext context) {
			MarkerResult result = base.MarkProject(proj, context);
			foreach (ModuleDefMD module in result.Modules)
				context.Annotations.Set(module, SNKey, snKey);
			return result;
		}
	}

	internal class PackerDiscovery : PluginDiscovery {
		readonly Protection prot;

		public PackerDiscovery(Protection prot) {
			this.prot = prot;
		}

		protected override void GetPluginsInternal(ConfuserContext context, IList<Protection> protections, IList<Packer> packers, IList<ConfuserComponent> components) {
			base.GetPluginsInternal(context, protections, packers, components);
			protections.Add(prot);
		}
	}
}


================================================
File: Confuser.Core/PluginDiscovery.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;

namespace Confuser.Core {
	/// <summary>
	///     Discovers available protection plugins.
	/// </summary>
	public class PluginDiscovery {
		/// <summary>
		///     The default plugin discovery service.
		/// </summary>
		internal static readonly PluginDiscovery Instance = new PluginDiscovery();

		/// <summary>
		///     Initializes a new instance of the <see cref="PluginDiscovery" /> class.
		/// </summary>
		protected PluginDiscovery() { }

		/// <summary>
		///     Retrieves the available protection plugins.
		/// </summary>
		/// <param name="context">The working context.</param>
		/// <param name="protections">A list of resolved protections.</param>
		/// <param name="packers">A list of resolved packers.</param>
		/// <param name="components">A list of resolved components.</param>
		public void GetPlugins(ConfuserContext context, out IList<Protection> protections, out IList<Packer> packers, out IList<ConfuserComponent> components) {
			protections = new List<Protection>();
			packers = new List<Packer>();
			components = new List<ConfuserComponent>();
			GetPluginsInternal(context, protections, packers, components);
		}

		/// <summary>
		///     Determines whether the specified type has an accessible default constructor.
		/// </summary>
		/// <param name="type">The type.</param>
		/// <returns><c>true</c> if the specified type has an accessible default constructor; otherwise, <c>false</c>.</returns>
		public static bool HasAccessibleDefConstructor(Type type) {
			ConstructorInfo ctor = type.GetConstructor(Type.EmptyTypes);
			if (ctor == null) return false;
			return ctor.IsPublic;
		}

		/// <summary>
		///     Adds plugins in the assembly to the protection list.
		/// </summary>
		/// <param name="context">The working context.</param>
		/// <param name="protections">The working list of protections.</param>
		/// <param name="packers">The working list of packers.</param>
		/// <param name="components">The working list of components.</param>
		/// <param name="asm">The assembly.</param>
		protected static void AddPlugins(
			ConfuserContext context, IList<Protection> protections, IList<Packer> packers,
			IList<ConfuserComponent> components, Assembly asm) {
			foreach(var module in asm.GetLoadedModules())
				foreach (var i in module.GetTypes()) {
					if (i.IsAbstract || !HasAccessibleDefConstructor(i))
						continue;

					if (typeof(Protection).IsAssignableFrom(i)) {
						try {
							protections.Add((Protection)Activator.CreateInstance(i));
						}
						catch (Exception ex) {
							context.Logger.ErrorException("Failed to instantiate protection '" + i.Name + "'.", ex);
						}
					}
					else if (typeof(Packer).IsAssignableFrom(i)) {
						try {
							packers.Add((Packer)Activator.CreateInstance(i));
						}
						catch (Exception ex) {
							context.Logger.ErrorException("Failed to instantiate packer '" + i.Name + "'.", ex);
						}
					}
					else if (typeof(ConfuserComponent).IsAssignableFrom(i)) {
						try {
							components.Add((ConfuserComponent)Activator.CreateInstance(i));
						}
						catch (Exception ex) {
							context.Logger.ErrorException("Failed to instantiate component '" + i.Name + "'.", ex);
						}
					}
				}
			context.CheckCancellation();
		}

		/// <summary>
		///     Retrieves the available protection plugins.
		/// </summary>
		/// <param name="context">The working context.</param>
		/// <param name="protections">The working list of protections.</param>
		/// <param name="packers">The working list of packers.</param>
		/// <param name="components">The working list of components.</param>
		protected virtual void GetPluginsInternal(
			ConfuserContext context, IList<Protection> protections,
			IList<Packer> packers, IList<ConfuserComponent> components) {
			try {
				Assembly protAsm = Assembly.Load("Confuser.Protections");
				AddPlugins(context, protections, packers, components, protAsm);
			}
			catch (Exception ex) {
				context.Logger.WarnException("Failed to load built-in protections.", ex);
			}

			try {
				Assembly renameAsm = Assembly.Load("Confuser.Renamer");
				AddPlugins(context, protections, packers, components, renameAsm);
			}
			catch (Exception ex) {
				context.Logger.WarnException("Failed to load renamer.", ex);
			}

			try {
				Assembly renameAsm = Assembly.Load("Confuser.DynCipher");
				AddPlugins(context, protections, packers, components, renameAsm);
			}
			catch (Exception ex) {
				context.Logger.WarnException("Failed to load dynamic cipher library.", ex);
			}

			foreach (string pluginPath in context.Project.PluginPaths) {
				string realPath = Path.Combine(context.BaseDirectory, pluginPath);
				try {
					Assembly plugin = Assembly.LoadFile(realPath);
					AddPlugins(context, protections, packers, components, plugin);
				}
				catch (Exception ex) {
					context.Logger.WarnException("Failed to load plugin '" + pluginPath + "'.", ex);
				}
			}
		}
	}
}


================================================
File: Confuser.Core/Protection.cs
================================================
ï»¿using System;

namespace Confuser.Core {
	/// <summary>
	///     Base class of Confuser protections.
	/// </summary>
	/// <remarks>
	///     A parameterless constructor must exists in derived classes to enable plugin discovery.
	/// </remarks>
	public abstract class Protection : ConfuserComponent {
		/// <summary>
		///     Gets the preset this protection is in.
		/// </summary>
		/// <value>The protection's preset.</value>
		public abstract ProtectionPreset Preset { get; }
	}
}


================================================
File: Confuser.Core/ProtectionDependencyAttributes.cs
================================================
ï»¿using System;

namespace Confuser.Core {
	/// <summary>
	///     Indicates the <see cref="Protection" /> must initialize before the specified protections.
	/// </summary>
	[AttributeUsage(AttributeTargets.Class)]
	public class BeforeProtectionAttribute : Attribute {
		/// <summary>
		///     Initializes a new instance of the <see cref="BeforeProtectionAttribute" /> class.
		/// </summary>
		/// <param name="ids">The full IDs of the specified protections.</param>
		public BeforeProtectionAttribute(params string[] ids) {
			Ids = ids;
		}

		/// <summary>
		///     Gets the full IDs of the specified protections.
		/// </summary>
		/// <value>The IDs of protections.</value>
		public string[] Ids { get; private set; }
	}

	/// <summary>
	///     Indicates the <see cref="Protection" /> must initialize after the specified protections.
	/// </summary>
	[AttributeUsage(AttributeTargets.Class)]
	public class AfterProtectionAttribute : Attribute {
		/// <summary>
		///     Initializes a new instance of the <see cref="BeforeProtectionAttribute" /> class.
		/// </summary>
		/// <param name="ids">The full IDs of the specified protections.</param>
		public AfterProtectionAttribute(params string[] ids) {
			Ids = ids;
		}

		/// <summary>
		///     Gets the full IDs of the specified protections.
		/// </summary>
		/// <value>The IDs of protections.</value>
		public string[] Ids { get; private set; }
	}
}


================================================
File: Confuser.Core/ProtectionParameters.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using dnlib.DotNet;

namespace Confuser.Core {
	using ProtectionParams = Dictionary<string, object>;

	/// <summary>
	///     Parameters of <see cref="ConfuserComponent" />.
	/// </summary>
	public class ProtectionParameters {
		static readonly object ParametersKey = new object();

		/// <summary>
		///     A empty instance of <see cref="ProtectionParameters" />.
		/// </summary>
		public static readonly ProtectionParameters Empty = new ProtectionParameters(null, new IDnlibDef[0]);

		readonly ConfuserComponent comp;

		/// <summary>
		///     Initializes a new instance of the <see cref="ProtectionParameters" /> class.
		/// </summary>
		/// <param name="component">The component that this parameters applied to.</param>
		/// <param name="targets">The protection targets.</param>
		internal ProtectionParameters(ConfuserComponent component, IList<IDnlibDef> targets) {
			comp = component;
			Targets = targets;
		}

		/// <summary>
		///     Gets the targets of protection.
		///     Possible targets are module, types, methods, fields, events, properties.
		/// </summary>
		/// <value>A list of protection targets.</value>
		public IList<IDnlibDef> Targets { get; private set; }


		/// <summary>
		///     Obtains the value of a parameter of the specified target.
		/// </summary>
		/// <typeparam name="T">The type of the parameter value.</typeparam>
		/// <param name="context">The working context.</param>
		/// <param name="target">The protection target.</param>
		/// <param name="name">The name of the parameter.</param>
		/// <param name="defValue">Default value if the parameter does not exist.</param>
		/// <returns>The value of the parameter.</returns>
		public T GetParameter<T>(ConfuserContext context, IDnlibDef target, string name, T defValue = default(T)) {
			Dictionary<string, string> parameters;

			if (comp == null)
				return defValue;

			if (comp is Packer && target == null) {
				// Packer parameters are stored in modules
				target = context.Modules[0];
			}

			var objParams = context.Annotations.Get<ProtectionSettings>(target, ParametersKey);
			if (objParams == null)
				return defValue;
			if (!objParams.TryGetValue(comp, out parameters))
				return defValue;

			string ret;
			if (parameters.TryGetValue(name, out ret)) {
				Type paramType = typeof(T);
				Type nullable = Nullable.GetUnderlyingType(paramType);
				if (nullable != null)
					paramType = nullable;

				if (paramType.IsEnum)
					return (T)Enum.Parse(paramType, ret, true);
				return (T)Convert.ChangeType(ret, paramType);
			}
			return defValue;
		}

		/// <summary>
		///     Sets the protection parameters of the specified target.
		/// </summary>
		/// <param name="context">The context.</param>
		/// <param name="target">The protection target.</param>
		/// <param name="parameters">The parameters.</param>
		public static void SetParameters(
			ConfuserContext context, IDnlibDef target, ProtectionSettings parameters) {
			context.Annotations.Set(target, ParametersKey, parameters);
		}

		/// <summary>
		///     Gets the protection parameters of the specified target.
		/// </summary>
		/// <param name="context">The context.</param>
		/// <param name="target">The protection target.</param>
		/// <returns>The parameters.</returns>
		public static ProtectionSettings GetParameters(
			ConfuserContext context, IDnlibDef target) {
			return context.Annotations.Get<ProtectionSettings>(target, ParametersKey);
		}
	}
}


================================================
File: Confuser.Core/ProtectionPhase.cs
================================================
ï»¿using System;

namespace Confuser.Core {
	/// <summary>
	///     Base class of protection phases.
	/// </summary>
	public abstract class ProtectionPhase {
		/// <summary>
		///     Initializes a new instance of the <see cref="ProtectionPhase" /> class.
		/// </summary>
		/// <param name="parent">The parent component of this phase.</param>
		public ProtectionPhase(ConfuserComponent parent) {
			Parent = parent;
		}

		/// <summary>
		///     Gets the parent component.
		/// </summary>
		/// <value>The parent component.</value>
		public ConfuserComponent Parent { get; private set; }

		/// <summary>
		///     Gets the targets of protection.
		/// </summary>
		/// <value>The protection targets.</value>
		public abstract ProtectionTargets Targets { get; }

		/// <summary>
		///     Gets the name of the phase.
		/// </summary>
		/// <value>The name of phase.</value>
		public abstract string Name { get; }

		/// <summary>
		///     Gets a value indicating whether this phase process all targets, not just the targets that requires the component.
		/// </summary>
		/// <value><c>true</c> if this phase process all targets; otherwise, <c>false</c>.</value>
		public virtual bool ProcessAll {
			get { return false; }
		}

		/// <summary>
		///     Executes the protection phase.
		/// </summary>
		/// <param name="context">The working context.</param>
		/// <param name="parameters">The parameters of protection.</param>
		protected internal abstract void Execute(ConfuserContext context, ProtectionParameters parameters);
	}
}


================================================
File: Confuser.Core/ProtectionPipeline.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using dnlib.DotNet;

namespace Confuser.Core {
	/// <summary>
	///     Various stages in <see cref="ProtectionPipeline" />.
	/// </summary>
	public enum PipelineStage {
		/// <summary>
		///     Confuser engine inspects the loaded modules and makes necessary changes.
		///     This stage occurs only once per pipeline run.
		/// </summary>
		Inspection,

		/// <summary>
		///     Confuser engine begins to process a module.
		///     This stage occurs once per module.
		/// </summary>
		BeginModule,

		/// <summary>
		///     Confuser engine processes a module.
		///     This stage occurs once per module.
		/// </summary>
		ProcessModule,

		/// <summary>
		///     Confuser engine optimizes opcodes of the method bodys.
		///     This stage occurs once per module.
		/// </summary>
		OptimizeMethods,

		/// <summary>
		///     Confuser engine finishes processing a module.
		///     This stage occurs once per module.
		/// </summary>
		EndModule,

		/// <summary>
		///     Confuser engine writes the module to byte array.
		///     This stage occurs once per module, after all processing of modules are completed.
		/// </summary>
		WriteModule,

		/// <summary>
		///     Confuser engine generates debug symbols.
		///     This stage occurs only once per pipeline run.
		/// </summary>
		Debug,

		/// <summary>
		///     Confuser engine packs up the output if packer is present.
		///     This stage occurs only once per pipeline run.
		/// </summary>
		Pack,

		/// <summary>
		///     Confuser engine saves the output.
		///     This stage occurs only once per pipeline run.
		/// </summary>
		SaveModules
	}

	/// <summary>
	///     Protection processing pipeline.
	/// </summary>
	public class ProtectionPipeline {
		readonly Dictionary<PipelineStage, List<ProtectionPhase>> postStage;
		readonly Dictionary<PipelineStage, List<ProtectionPhase>> preStage;

		/// <summary>
		///     Initializes a new instance of the <see cref="ProtectionPipeline" /> class.
		/// </summary>
		public ProtectionPipeline() {
			var stages = (PipelineStage[])Enum.GetValues(typeof(PipelineStage));
			preStage = stages.ToDictionary(stage => stage, stage => new List<ProtectionPhase>());
			postStage = stages.ToDictionary(stage => stage, stage => new List<ProtectionPhase>());
		}

		/// <summary>
		///     Inserts the phase into pre-processing pipeline of the specified stage.
		/// </summary>
		/// <param name="stage">The pipeline stage.</param>
		/// <param name="phase">The protection phase.</param>
		public void InsertPreStage(PipelineStage stage, ProtectionPhase phase) {
			preStage[stage].Add(phase);
		}

		/// <summary>
		///     Inserts the phase into post-processing pipeline of the specified stage.
		/// </summary>
		/// <param name="stage">The pipeline stage.</param>
		/// <param name="phase">The protection phase.</param>
		public void InsertPostStage(PipelineStage stage, ProtectionPhase phase) {
			postStage[stage].Add(phase);
		}

		/// <summary>
		///     Finds the phase with the specified type in the pipeline.
		/// </summary>
		/// <typeparam name="T">The type of the phase.</typeparam>
		/// <returns>The phase with specified type in the pipeline.</returns>
		public T FindPhase<T>() where T : ProtectionPhase {
			foreach (var phases in preStage.Values)
				foreach (ProtectionPhase phase in phases) {
					if (phase is T)
						return (T)phase;
				}
			foreach (var phases in postStage.Values)
				foreach (ProtectionPhase phase in phases) {
					if (phase is T)
						return (T)phase;
				}
			return null;
		}

		/// <summary>
		///     Execute the specified pipeline stage with pre-processing and post-processing.
		/// </summary>
		/// <param name="stage">The pipeline stage.</param>
		/// <param name="func">The stage function.</param>
		/// <param name="targets">The target list of the stage.</param>
		/// <param name="context">The working context.</param>
		internal void ExecuteStage(PipelineStage stage, Action<ConfuserContext> func, Func<IList<IDnlibDef>> targets, ConfuserContext context) {
			foreach (ProtectionPhase pre in preStage[stage]) {
				context.CheckCancellation();
				context.Logger.DebugFormat("Executing '{0}' phase...", pre.Name);
				pre.Execute(context, new ProtectionParameters(pre.Parent, Filter(context, targets(), pre)));
			}
			context.CheckCancellation();
			func(context);
			context.CheckCancellation();
			foreach (ProtectionPhase post in postStage[stage]) {
				context.Logger.DebugFormat("Executing '{0}' phase...", post.Name);
				post.Execute(context, new ProtectionParameters(post.Parent, Filter(context, targets(), post)));
				context.CheckCancellation();
			}
		}

		/// <summary>
		///     Returns only the targets with the specified type and used by specified component.
		/// </summary>
		/// <param name="context">The working context.</param>
		/// <param name="targets">List of targets.</param>
		/// <param name="phase">The component phase.</param>
		/// <returns>Filtered targets.</returns>
		static IList<IDnlibDef> Filter(ConfuserContext context, IList<IDnlibDef> targets, ProtectionPhase phase) {
			ProtectionTargets targetType = phase.Targets;

			IEnumerable<IDnlibDef> filter = targets;
			if ((targetType & ProtectionTargets.Modules) == 0)
				filter = filter.Where(def => !(def is ModuleDef));
			if ((targetType & ProtectionTargets.Types) == 0)
				filter = filter.Where(def => !(def is TypeDef));
			if ((targetType & ProtectionTargets.Methods) == 0)
				filter = filter.Where(def => !(def is MethodDef));
			if ((targetType & ProtectionTargets.Fields) == 0)
				filter = filter.Where(def => !(def is FieldDef));
			if ((targetType & ProtectionTargets.Properties) == 0)
				filter = filter.Where(def => !(def is PropertyDef));
			if ((targetType & ProtectionTargets.Events) == 0)
				filter = filter.Where(def => !(def is EventDef));

			if (phase.ProcessAll)
				return filter.ToList();
			return filter.Where(def => {
				ProtectionSettings parameters = ProtectionParameters.GetParameters(context, def);
				Debug.Assert(parameters != null);
				if (parameters == null) {
					context.Logger.ErrorFormat("'{0}' not marked for obfuscation, possibly a bug.", def);
					throw new ConfuserException(null);
				}
				return parameters.ContainsKey(phase.Parent);
			}).ToList();
		}
	}
}


================================================
File: Confuser.Core/ProtectionPreset.cs
================================================
ï»¿using System;

namespace Confuser.Core {
	/// <summary>
	///     Various presets of protections.
	/// </summary>
	public enum ProtectionPreset {
		/// <summary> The protection does not belong to any preset. </summary>
		None = 0,

		/// <summary> The protection provides basic security. </summary>
		Minimum = 1,

		/// <summary> The protection provides normal security for public release. </summary>
		Normal = 2,

		/// <summary> The protection provides better security with observable performance impact. </summary>
		Aggressive = 3,

		/// <summary> The protection provides strongest security with possible incompatibility. </summary>
		Maximum = 4
	}
}


================================================
File: Confuser.Core/ProtectionSettings.cs
================================================
ï»¿using System;
using System.Collections.Generic;

namespace Confuser.Core {
	/// <summary>
	///     Protection settings for a certain component
	/// </summary>
	public class ProtectionSettings : Dictionary<ConfuserComponent, Dictionary<string, string>> {
		/// <summary>
		///     Initializes a new instance of the <see cref="ProtectionSettings" /> class.
		/// </summary>
		public ProtectionSettings() { }

		/// <summary>
		///     Initializes a new instance of the <see cref="ProtectionSettings" /> class
		///     from an existing <see cref="ProtectionSettings" />.
		/// </summary>
		/// <param name="settings">The settings to copy from.</param>
		public ProtectionSettings(ProtectionSettings settings) {
			if (settings == null)
				return;

			foreach (var i in settings)
				Add(i.Key, new Dictionary<string, string>(i.Value));
		}

		/// <summary>
		///     Determines whether the settings is empty.
		/// </summary>
		/// <returns><c>true</c> if the settings is empty; otherwise, <c>false</c>.</returns>
		public bool IsEmpty() {
			return Count == 0;
		}
	}
}


================================================
File: Confuser.Core/ProtectionTargets.cs
================================================
ï»¿using System;

namespace Confuser.Core {
	/// <summary>
	///     Targets of protection.
	/// </summary>
	[Flags]
	public enum ProtectionTargets {
		/// <summary> Type definitions. </summary>
		Types = 1,

		/// <summary> Method definitions. </summary>
		Methods = 2,

		/// <summary> Field definitions. </summary>
		Fields = 4,

		/// <summary> Event definitions. </summary>
		Events = 8,

		/// <summary> Property definitions. </summary>
		Properties = 16,

		/// <summary> All member definitions (i.e. type, methods, fields, events and properties). </summary>
		AllMembers = Types | Methods | Fields | Events | Properties,

		/// <summary> Module definitions. </summary>
		Modules = 32,

		/// <summary> All definitions (i.e. All member definitions and modules). </summary>
		AllDefinitions = AllMembers | Modules
	}
}


================================================
File: Confuser.Core/ServiceRegistry.cs
================================================
ï»¿using System;
using System.Collections.Generic;

namespace Confuser.Core {
	/// <summary>
	///     A registry of different services provided by protections
	/// </summary>
	public class ServiceRegistry : IServiceProvider {
		readonly HashSet<string> serviceIds = new HashSet<string>();
		readonly Dictionary<Type, object> services = new Dictionary<Type, object>();

		/// <inheritdoc />
		object IServiceProvider.GetService(Type serviceType) {
			return services.GetValueOrDefault(serviceType, null);
		}

		/// <summary>
		///     Retrieves the service of type <typeparamref name="T" />.
		/// </summary>
		/// <typeparam name="T">The type of service.</typeparam>
		/// <returns>The service instance.</returns>
		public T GetService<T>() {
			return (T)services.GetValueOrDefault(typeof(T), null);
		}

		/// <summary>
		///     Registers the service with specified ID .
		/// </summary>
		/// <param name="serviceId">The service identifier.</param>
		/// <param name="serviceType">The service type.</param>
		/// <param name="service">The service.</param>
		/// <exception cref="System.ArgumentException">Service with same ID or type has already registered.</exception>
		public void RegisterService(string serviceId, Type serviceType, object service) {
			if (!serviceIds.Add(serviceId))
				throw new ArgumentException("Service with ID '" + serviceIds + "' has already registered.", "serviceId");
			if (services.ContainsKey(serviceType))
				throw new ArgumentException("Service with type '" + service.GetType().Name + "' has already registered.", "service");
			services.Add(serviceType, service);
		}

		/// <summary>
		///     Determines whether the service with specified identifier has already registered.
		/// </summary>
		/// <param name="serviceId">The service identifier.</param>
		/// <returns><c>true</c> if the service with specified identifier has already registered; otherwise, <c>false</c>.</returns>
		public bool Contains(string serviceId) {
			return serviceIds.Contains(serviceId);
		}
	}
}


================================================
File: Confuser.Core/UnreachableException.cs
================================================
ï»¿using System;

namespace Confuser.Core {
	/// <summary>
	///     The exception that is thrown when supposedly unreachable code is executed.
	/// </summary>
	public class UnreachableException : SystemException {
		/// <summary>
		///     Initializes a new instance of the <see cref="UnreachableException" /> class.
		/// </summary>
		public UnreachableException() :
			base("Unreachable code reached.") { }
	}
}


================================================
File: Confuser.Core/Utils.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.IO;
using System.Security.Cryptography;
using System.Text;

namespace Confuser.Core {
	/// <summary>
	///     Provides a set of utility methods
	/// </summary>
	public static class Utils {
		static readonly char[] hexCharset = "0123456789abcdef".ToCharArray();

		/// <summary>
		///     Gets the value associated with the specified key, or default value if the key does not exists.
		/// </summary>
		/// <typeparam name="TKey">The type of the key.</typeparam>
		/// <typeparam name="TValue">The type of the value.</typeparam>
		/// <param name="dictionary">The dictionary.</param>
		/// <param name="key">The key of the value to get.</param>
		/// <param name="defValue">The default value.</param>
		/// <returns>The value associated with the specified key, or the default value if the key does not exists</returns>
		public static TValue GetValueOrDefault<TKey, TValue>(
			this Dictionary<TKey, TValue> dictionary,
			TKey key,
			TValue defValue = default(TValue)) {
			TValue ret;
			if (dictionary.TryGetValue(key, out ret))
				return ret;
			return defValue;
		}

		/// <summary>
		///     Gets the value associated with the specified key, or default value if the key does not exists.
		/// </summary>
		/// <typeparam name="TKey">The type of the key.</typeparam>
		/// <typeparam name="TValue">The type of the value.</typeparam>
		/// <param name="dictionary">The dictionary.</param>
		/// <param name="key">The key of the value to get.</param>
		/// <param name="defValueFactory">The default value factory function.</param>
		/// <returns>The value associated with the specified key, or the default value if the key does not exists</returns>
		public static TValue GetValueOrDefaultLazy<TKey, TValue>(
			this Dictionary<TKey, TValue> dictionary,
			TKey key,
			Func<TKey, TValue> defValueFactory) {
			TValue ret;
			if (dictionary.TryGetValue(key, out ret))
				return ret;
			return defValueFactory(key);
		}

		/// <summary>
		///     Adds the specified key and value to the multi dictionary.
		/// </summary>
		/// <typeparam name="TKey">The type of key.</typeparam>
		/// <typeparam name="TValue">The type of value.</typeparam>
		/// <param name="self">The dictionary to add to.</param>
		/// <param name="key">The key of the element to add.</param>
		/// <param name="value">The value of the element to add.</param>
		/// <exception cref="System.ArgumentNullException">key is <c>null</c>.</exception>
		public static void AddListEntry<TKey, TValue>(this IDictionary<TKey, List<TValue>> self, TKey key, TValue value) {
			if (key == null)
				throw new ArgumentNullException("key");
			List<TValue> list;
			if (!self.TryGetValue(key, out list))
				list = self[key] = new List<TValue>();
			list.Add(value);
		}

		/// <summary>
		///     Obtains the relative path from the specified base path.
		/// </summary>
		/// <param name="filespec">The file path.</param>
		/// <param name="folder">The base path.</param>
		/// <returns>The path of <paramref name="filespec" /> relative to <paramref name="folder" />.</returns>
		public static string GetRelativePath(string filespec, string folder) {
			//http://stackoverflow.com/a/703292/462805

			var pathUri = new Uri(filespec);
			// Folders must end in a slash
			if (!folder.EndsWith(Path.DirectorySeparatorChar.ToString())) {
				folder += Path.DirectorySeparatorChar;
			}
			var folderUri = new Uri(folder);
			return Uri.UnescapeDataString(folderUri.MakeRelativeUri(pathUri).ToString().Replace('/', Path.DirectorySeparatorChar));
		}

		/// <summary>
		///     If the input string is empty, return null; otherwise, return the original input string.
		/// </summary>
		/// <param name="val">The input string.</param>
		/// <returns><c>null</c> if the input string is empty; otherwise, the original input string.</returns>
		public static string NullIfEmpty(this string val) {
			if (string.IsNullOrEmpty(val))
				return null;
			return val;
		}

		/// <summary>
		///     Compute the SHA1 hash of the input buffer.
		/// </summary>
		/// <param name="buffer">The input buffer.</param>
		/// <returns>The SHA1 hash of the input buffer.</returns>
		public static byte[] SHA1(byte[] buffer) {
			var sha = new SHA1Managed();
			return sha.ComputeHash(buffer);
		}

		/// <summary>
		///     Xor the values in the two buffer together.
		/// </summary>
		/// <param name="buffer1">The input buffer 1.</param>
		/// <param name="buffer2">The input buffer 2.</param>
		/// <returns>The result buffer.</returns>
		/// <exception cref="System.ArgumentException">Length of the two buffers are not equal.</exception>
		public static byte[] Xor(byte[] buffer1, byte[] buffer2) {
			if (buffer1.Length != buffer2.Length)
				throw new ArgumentException("Length mismatched.");
			var ret = new byte[buffer1.Length];
			for (int i = 0; i < ret.Length; i++)
				ret[i] = (byte)(buffer1[i] ^ buffer2[i]);
			return ret;
		}

		/// <summary>
		///     Compute the SHA256 hash of the input buffer.
		/// </summary>
		/// <param name="buffer">The input buffer.</param>
		/// <returns>The SHA256 hash of the input buffer.</returns>
		public static byte[] SHA256(byte[] buffer) {
			var sha = new SHA256Managed();
			return sha.ComputeHash(buffer);
		}

		/// <summary>
		///     Encoding the buffer to a string using specified charset.
		/// </summary>
		/// <param name="buff">The input buffer.</param>
		/// <param name="charset">The charset.</param>
		/// <returns>The encoded string.</returns>
		public static string EncodeString(byte[] buff, char[] charset) {
			int current = buff[0];
			var ret = new StringBuilder();
			for (int i = 1; i < buff.Length; i++) {
				current = (current << 8) + buff[i];
				while (current >= charset.Length) {
					ret.Append(charset[current % charset.Length]);
					current /= charset.Length;
				}
			}
			if (current != 0)
				ret.Append(charset[current % charset.Length]);
			return ret.ToString();
		}

		/// <summary>
		///     Returns a new string in which all occurrences of a specified string in
		///     <paramref name="str" /><paramref name="str" /> are replaced with another specified string.
		/// </summary>
		/// <returns>
		///     A <see cref="string" /> equivalent to <paramref name="str" /> but with all instances of
		///     <paramref name="oldValue" />
		///     replaced with <paramref name="newValue" />.
		/// </returns>
		/// <param name="str">A string to do the replace in. </param>
		/// <param name="oldValue">A string to be replaced. </param>
		/// <param name="newValue">A string to replace all occurrences of <paramref name="oldValue" />. </param>
		/// <param name="comparison">One of the <see cref="StringComparison" /> values. </param>
		/// <remarks>Adopted from http://stackoverflow.com/a/244933 </remarks>
		public static string Replace(this string str, string oldValue, string newValue, StringComparison comparison) {
			StringBuilder sb = new StringBuilder();

			int previousIndex = 0;
			int index = str.IndexOf(oldValue, comparison);
			while (index != -1) {
				sb.Append(str.Substring(previousIndex, index - previousIndex));
				sb.Append(newValue);
				index += oldValue.Length;
				previousIndex = index;
				index = str.IndexOf(oldValue, index, comparison);
			}
			sb.Append(str.Substring(previousIndex));

			return sb.ToString();
		}


		/// <summary>
		///     Encode the buffer to a hexadecimal string.
		/// </summary>
		/// <param name="buff">The input buffer.</param>
		/// <returns>A hexadecimal representation of input buffer.</returns>
		public static string ToHexString(byte[] buff) {
			var ret = new char[buff.Length * 2];
			int i = 0;
			foreach (byte val in buff) {
				ret[i++] = hexCharset[val >> 4];
				ret[i++] = hexCharset[val & 0xf];
			}
			return new string(ret);
		}

		/// <summary>
		///     Removes all elements that match the conditions defined by the specified predicate from a the list.
		/// </summary>
		/// <typeparam name="T">The type of the elements of <paramref name="self" />.</typeparam>
		/// <param name="self">The list to remove from.</param>
		/// <param name="match">The predicate that defines the conditions of the elements to remove.</param>
		/// <returns><paramref name="self" /> for method chaining.</returns>
		public static IList<T> RemoveWhere<T>(this IList<T> self, Predicate<T> match) {
			for (int i = self.Count - 1; i >= 0; i--) {
				if (match(self[i]))
					self.RemoveAt(i);
			}
			return self;
		}

		/// <summary>
		///     Returns a <see cref="IEnumerable{T}" /> that log the progress of iterating the specified list.
		/// </summary>
		/// <typeparam name="T">The type of list element</typeparam>
		/// <param name="enumerable">The list.</param>
		/// <param name="logger">The logger.</param>
		/// <returns>A wrapper of the list.</returns>
		public static IEnumerable<T> WithProgress<T>(this IEnumerable<T> enumerable, ILogger logger) {
			var list = new List<T>(enumerable);
			int i;
			for (i = 0; i < list.Count; i++) {
				logger.Progress(i, list.Count);
				yield return list[i];
			}
			logger.Progress(i, list.Count);
			logger.EndProgress();
		}
	}
}


================================================
File: Confuser.Core/API/APIStore.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using Confuser.Core.Services;
using dnlib.DotNet;

namespace Confuser.Core.API {
	internal class APIStore : IAPIStore {
		readonly ConfuserContext context;
		readonly RandomGenerator random;
		readonly SortedList<int, List<IDataStore>> dataStores;
		readonly List<IOpaquePredicateDescriptor> predicates;

		/// <summary>
		///     Initializes a new instance of the <see cref="APIStore" /> class.
		/// </summary>
		/// <param name="context">The working context.</param>
		public APIStore(ConfuserContext context) {
			this.context = context;
			random = context.Registry.GetService<IRandomService>().GetRandomGenerator("APIStore");

			dataStores = new SortedList<int, List<IDataStore>>();
			predicates = new List<IOpaquePredicateDescriptor>();
		}

		/// <inheritdoc />
		public void AddStore(IDataStore dataStore) {
			dataStores.AddListEntry(dataStore.Priority, dataStore);
		}

		/// <inheritdoc />
		public void AddPredicate(IOpaquePredicateDescriptor predicate) {
			predicates.Add(predicate);
		}

		/// <inheritdoc />
		public IDataStore GetStore(MethodDef method) {
			for (int i = dataStores.Count - 1; i >= 0; i--) {
				var list = dataStores[i];
				for (int j = list.Count - 1; j >= 0; i--) {
					if (list[j].IsUsable(method))
						return list[j];
				}
			}
			return null;
		}

		/// <inheritdoc />
		public IOpaquePredicateDescriptor GetPredicate(MethodDef method, OpaquePredicateType? type, params int[] argCount) {
			var randomPredicates = predicates.ToArray();
			random.Shuffle(randomPredicates);
			foreach (var predicate in randomPredicates) {
				if (predicate.IsUsable(method) &&
				    (type == null || predicate.Type == type.Value) &&
				    (argCount == null || Array.IndexOf(argCount, predicate.ArgumentCount) != -1))
					return predicate;
			}
			return null;
		}
	}

	/// <summary>
	///     Provides storage for API interfaces
	/// </summary>
	public interface IAPIStore {
		/// <summary>
		///     Adds the specified data store into this store.
		/// </summary>
		/// <param name="dataStore">The data store.</param>
		void AddStore(IDataStore dataStore);

		/// <summary>
		///     Finds a suitable data store for the specified method, with the
		///     specified number of keys.
		/// </summary>
		/// <param name="method">The method.</param>
		/// <returns>The suitable data store if found, or <c>null</c> if not found.</returns>
		/// <remarks>
		///     It should never returns null --- ConfuserEx has internal data store.
		/// </remarks>
		IDataStore GetStore(MethodDef method);

		/// <summary>
		///     Adds the specified opaque predicate into this store.
		/// </summary>
		/// <param name="predicate">The opaque predicate.</param>
		void AddPredicate(IOpaquePredicateDescriptor predicate);

		/// <summary>
		///     Finds a suitable opaque predicate for the specified method, with the
		///     specified properties.
		/// </summary>
		/// <param name="method">The method.</param>
		/// <param name="type">The required type of predicate, or <c>null</c> if it does not matter.</param>
		/// <param name="argCount">The required numbers of arguments, or <c>null</c> if it does not matter.</param>
		/// <returns>The suitable opaque predicate if found, or <c>null</c> if not found.</returns>
		IOpaquePredicateDescriptor GetPredicate(MethodDef method, OpaquePredicateType? type, params int[] argCount);
	}
}


================================================
File: Confuser.Core/API/IDataStore.cs
================================================
ï»¿using System;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Core.API {
	/// <summary>
	///     A data store.
	/// </summary>
	public interface IDataStore {
		/// <summary>
		///     Gets the priority of this data store; higher priority means it
		///     would be tried earlier.
		/// </summary>
		/// <value>The priority of this data store.</value>
		int Priority { get; }

		/// <summary>
		///     Gets the number of keys this predicate has.
		/// </summary>
		/// <remarks>
		///     Keys are used by the data store to encrypt data/whatever purpose.
		/// </remarks>
		/// <value>The number of keys this data store has.</value>
		int KeyCount { get; }

		/// <summary>
		///     Determines whether this data store can be used in the specified method.
		/// </summary>
		/// <param name="method">The method.</param>
		/// <value><c>true</c> if this data store can be used in the specified method; otherwise, <c>false</c>.</value>
		bool IsUsable(MethodDef method);

		/// <summary>
		///     Creates an accessor of this data store for the specified method.
		/// </summary>
		/// <param name="method">The method.</param>
		/// <param name="keys">The keys.</param>
		/// <param name="data">The data to store.</param>
		/// <returns>A newly accessor of this data store.</returns>
		IDataStoreAccessor CreateAccessor(MethodDef method, uint[] keys, byte[] data);
	}

	/// <summary>
	///     An accessor of data store.
	/// </summary>
	public interface IDataStoreAccessor {
		/// <summary>
		///     Emits the runtime instruction sequence for this accessor.
		/// </summary>
		/// <returns>An instruction sequence that returns the stored data.</returns>
		Instruction[] Emit();
	}
}


================================================
File: Confuser.Core/API/IOpaquePredicate.cs
================================================
ï»¿using System;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Core.API {
	/// <summary>
	///     The descriptor of a type of opaque predicate.
	/// </summary>
	public interface IOpaquePredicateDescriptor {
		/// <summary>
		///     Gets the type of the opaque predicate.
		/// </summary>
		/// <value>The type of the opaque predicate.</value>
		OpaquePredicateType Type { get; }

		/// <summary>
		///     Gets the number of arguments this predicate has.
		/// </summary>
		/// <remarks>
		///     When <see cref="IOpaquePredicateDescriptor.Type" /> is <see cref="OpaquePredicateType.Invariant" />,
		///     there can be 0 or more arguments.
		///     When <see cref="IOpaquePredicateDescriptor.Type" /> is <see cref="OpaquePredicateType.Function" />,
		///     there must be more than 0 arguments.
		/// </remarks>
		/// <value>The number of arguments this predicate has.</value>
		int ArgumentCount { get; }

		/// <summary>
		///     Determines whether this predicate can be used with the specified method.
		/// </summary>
		/// <param name="method">The method.</param>
		/// <value><c>true</c> if this predicate can be used with the specified method; otherwise, <c>false</c>.</value>
		bool IsUsable(MethodDef method);

		/// <summary>
		///     Creates a new opaque predicate for the specified method.
		/// </summary>
		/// <param name="method">The method.</param>
		/// <returns>A newly create opaque predicate.</returns>
		IOpaquePredicate CreatePredicate(MethodDef method);
	}

	/// <summary>
	///     An instance of opaque predicate.
	/// </summary>
	public interface IOpaquePredicate {
		/// <summary>
		///     Emits the runtime instruction sequence for this predicate.
		/// </summary>
		/// <param name="loadArg">
		///     A function that returns an instruction sequence that returns the input value,
		///     or <c>null</c> if <see cref="IOpaquePredicateDescriptor.ArgumentCount" /> is 0.
		/// </param>
		/// <returns>An instruction sequence that returns the value of this predicate.</returns>
		Instruction[] Emit(Func<Instruction[]> loadArg);

		/// <summary>
		///     Computes the value of this predicate with the specified argument.
		/// </summary>
		/// <param name="arg">The argument to this predicate.</param>
		/// <returns>The return value of this predicate.</returns>
		uint GetValue(uint[] arg);
	}

	/// <summary>
	///     The type of opaque predicate.
	/// </summary>
	public enum OpaquePredicateType {
		/// <summary>
		///     A function, in a mathematics sense, with one input and one output.
		/// </summary>
		Function,

		/// <summary>
		///     A constant function, always returning the same value.
		/// </summary>
		Invariant
	}
}


================================================
File: Confuser.Core/Helpers/ControlFlowGraph.cs
================================================
ï»¿using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using dnlib.DotNet.Emit;

namespace Confuser.Core.Helpers {
	/// <summary>
	///     A Control Flow Graph (CFG) of a method
	/// </summary>
	public class ControlFlowGraph : IEnumerable<ControlFlowBlock> {
		readonly List<ControlFlowBlock> blocks;
		readonly CilBody body;
		readonly int[] instrBlocks;
		readonly Dictionary<Instruction, int> indexMap;

		ControlFlowGraph(CilBody body) {
			this.body = body;
			instrBlocks = new int[body.Instructions.Count];
			blocks = new List<ControlFlowBlock>();

			indexMap = new Dictionary<Instruction, int>();
			for (int i = 0; i < body.Instructions.Count; i++)
				indexMap.Add(body.Instructions[i], i);
		}

		/// <summary>
		///     Gets the number of blocks in this CFG.
		/// </summary>
		/// <value>The number of blocks.</value>
		public int Count {
			get { return blocks.Count; }
		}

		/// <summary>
		///     Gets the <see cref="ControlFlowBlock" /> of the specified id.
		/// </summary>
		/// <param name="id">The id.</param>
		/// <returns>The block with specified id.</returns>
		public ControlFlowBlock this[int id] {
			get { return blocks[id]; }
		}

		/// <summary>
		///     Gets the corresponding method body.
		/// </summary>
		/// <value>The method body.</value>
		public CilBody Body {
			get { return body; }
		}

		IEnumerator<ControlFlowBlock> IEnumerable<ControlFlowBlock>.GetEnumerator() {
			return blocks.GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator() {
			return blocks.GetEnumerator();
		}

		/// <summary>
		///     Gets the block containing the specified instruction.
		/// </summary>
		/// <param name="instrIndex">The index of instruction.</param>
		/// <returns>The block containing the instruction.</returns>
		public ControlFlowBlock GetContainingBlock(int instrIndex) {
			return blocks[instrBlocks[instrIndex]];
		}

		/// <summary>
		///     Gets the index of the specified instruction.
		/// </summary>
		/// <param name="instr">The instruction.</param>
		/// <returns>The index of instruction.</returns>
		public int IndexOf(Instruction instr) {
			return indexMap[instr];
		}

		void PopulateBlockHeaders(HashSet<Instruction> blockHeaders, HashSet<Instruction> entryHeaders) {
			for (int i = 0; i < body.Instructions.Count; i++) {
				Instruction instr = body.Instructions[i];

				if (instr.Operand is Instruction) {
					blockHeaders.Add((Instruction)instr.Operand);
					if (i + 1 < body.Instructions.Count)
						blockHeaders.Add(body.Instructions[i + 1]);
				}
				else if (instr.Operand is Instruction[]) {
					foreach (Instruction target in (Instruction[])instr.Operand)
						blockHeaders.Add(target);
					if (i + 1 < body.Instructions.Count)
						blockHeaders.Add(body.Instructions[i + 1]);
				}
				else if ((instr.OpCode.FlowControl == FlowControl.Throw || instr.OpCode.FlowControl == FlowControl.Return) &&
				         i + 1 < body.Instructions.Count) {
					blockHeaders.Add(body.Instructions[i + 1]);
				}
			}
			blockHeaders.Add(body.Instructions[0]);
			foreach (ExceptionHandler eh in body.ExceptionHandlers) {
				blockHeaders.Add(eh.TryStart);
				blockHeaders.Add(eh.HandlerStart);
				blockHeaders.Add(eh.FilterStart);
				entryHeaders.Add(eh.HandlerStart);
				entryHeaders.Add(eh.FilterStart);
			}
		}

		void SplitBlocks(HashSet<Instruction> blockHeaders, HashSet<Instruction> entryHeaders) {
			int nextBlockId = 0;
			int currentBlockId = -1;
			Instruction currentBlockHdr = null;

			for (int i = 0; i < body.Instructions.Count; i++) {
				Instruction instr = body.Instructions[i];
				if (blockHeaders.Contains(instr)) {
					if (currentBlockHdr != null) {
						Instruction footer = body.Instructions[i - 1];

						var type = ControlFlowBlockType.Normal;
						if (entryHeaders.Contains(currentBlockHdr) || currentBlockHdr == body.Instructions[0])
							type |= ControlFlowBlockType.Entry;
						if (footer.OpCode.FlowControl == FlowControl.Return || footer.OpCode.FlowControl == FlowControl.Throw)
							type |= ControlFlowBlockType.Exit;

						blocks.Add(new ControlFlowBlock(currentBlockId, type, currentBlockHdr, footer));
					}

					currentBlockId = nextBlockId++;
					currentBlockHdr = instr;
				}

				instrBlocks[i] = currentBlockId;
			}
			if (blocks.Count == 0 || blocks[blocks.Count - 1].Id != currentBlockId) {
				Instruction footer = body.Instructions[body.Instructions.Count - 1];

				var type = ControlFlowBlockType.Normal;
				if (entryHeaders.Contains(currentBlockHdr) || currentBlockHdr == body.Instructions[0])
					type |= ControlFlowBlockType.Entry;
				if (footer.OpCode.FlowControl == FlowControl.Return || footer.OpCode.FlowControl == FlowControl.Throw)
					type |= ControlFlowBlockType.Exit;

				blocks.Add(new ControlFlowBlock(currentBlockId, type, currentBlockHdr, footer));
			}
		}

		void LinkBlocks() {
			for (int i = 0; i < body.Instructions.Count; i++) {
				Instruction instr = body.Instructions[i];
				if (instr.Operand is Instruction) {
					ControlFlowBlock srcBlock = blocks[instrBlocks[i]];
					ControlFlowBlock dstBlock = blocks[instrBlocks[indexMap[(Instruction)instr.Operand]]];
					dstBlock.Sources.Add(srcBlock);
					srcBlock.Targets.Add(dstBlock);
				}
				else if (instr.Operand is Instruction[]) {
					foreach (Instruction target in (Instruction[])instr.Operand) {
						ControlFlowBlock srcBlock = blocks[instrBlocks[i]];
						ControlFlowBlock dstBlock = blocks[instrBlocks[indexMap[target]]];
						dstBlock.Sources.Add(srcBlock);
						srcBlock.Targets.Add(dstBlock);
					}
				}
			}
			for (int i = 0; i < blocks.Count; i++) {
				if (blocks[i].Footer.OpCode.FlowControl != FlowControl.Branch &&
				    blocks[i].Footer.OpCode.FlowControl != FlowControl.Return &&
				    blocks[i].Footer.OpCode.FlowControl != FlowControl.Throw) {
					blocks[i].Targets.Add(blocks[i + 1]);
					blocks[i + 1].Sources.Add(blocks[i]);
				}
			}
		}

		/// <summary>
		///     Constructs a CFG from the specified method body.
		/// </summary>
		/// <param name="body">The method body.</param>
		/// <returns>The CFG of the given method body.</returns>
		public static ControlFlowGraph Construct(CilBody body) {
			var graph = new ControlFlowGraph(body);
			if (body.Instructions.Count == 0)
				return graph;

			// Populate block headers
			var blockHeaders = new HashSet<Instruction>();
			var entryHeaders = new HashSet<Instruction>();
			graph.PopulateBlockHeaders(blockHeaders, entryHeaders);

			// Split blocks
			graph.SplitBlocks(blockHeaders, entryHeaders);

			// Link blocks
			graph.LinkBlocks();

			return graph;
		}
	}

	/// <summary>
	///     The type of Control Flow Block
	/// </summary>
	[Flags]
	public enum ControlFlowBlockType {
		/// <summary>
		///     The block is a normal block
		/// </summary>
		Normal = 0,

		/// <summary>
		///     There are unknown edges to this block. Usually used at exception handlers / method entry.
		/// </summary>
		Entry = 1,

		/// <summary>
		///     There are unknown edges from this block. Usually used at filter blocks / throw / method exit.
		/// </summary>
		Exit = 2
	}

	/// <summary>
	///     A block in Control Flow Graph (CFG).
	/// </summary>
	public class ControlFlowBlock {
		/// <summary>
		///     The footer instruction
		/// </summary>
		public readonly Instruction Footer;

		/// <summary>
		///     The header instruction
		/// </summary>
		public readonly Instruction Header;

		/// <summary>
		///     The identifier of this block
		/// </summary>
		public readonly int Id;

		/// <summary>
		///     The type of this block
		/// </summary>
		public readonly ControlFlowBlockType Type;

		internal ControlFlowBlock(int id, ControlFlowBlockType type, Instruction header, Instruction footer) {
			Id = id;
			Type = type;
			Header = header;
			Footer = footer;

			Sources = new List<ControlFlowBlock>();
			Targets = new List<ControlFlowBlock>();
		}

		/// <summary>
		///     Gets the source blocks of this control flow block.
		/// </summary>
		/// <value>The source blocks.</value>
		public IList<ControlFlowBlock> Sources { get; private set; }

		/// <summary>
		///     Gets the target blocks of this control flow block.
		/// </summary>
		/// <value>The target blocks.</value>
		public IList<ControlFlowBlock> Targets { get; private set; }

		/// <summary>
		///     Returns a <see cref="System.String" /> that represents this block.
		/// </summary>
		/// <returns>A <see cref="System.String" /> that represents this block.</returns>
		public override string ToString() {
			return string.Format("Block {0} => {1} {2}", Id, Type, string.Join(", ", Targets.Select(block => block.Id.ToString()).ToArray()));
		}
	}
}


================================================
File: Confuser.Core/Helpers/InjectHelper.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Core.Helpers {
	/// <summary>
	///     Provides methods to inject a <see cref="TypeDef" /> into another module.
	/// </summary>
	public static class InjectHelper {
		/// <summary>
		///     Clones the specified origin TypeDef.
		/// </summary>
		/// <param name="origin">The origin TypeDef.</param>
		/// <returns>The cloned TypeDef.</returns>
		static TypeDefUser Clone(TypeDef origin) {
			var ret = new TypeDefUser(origin.Namespace, origin.Name);
			ret.Attributes = origin.Attributes;

			if (origin.ClassLayout != null)
				ret.ClassLayout = new ClassLayoutUser(origin.ClassLayout.PackingSize, origin.ClassSize);

			foreach (GenericParam genericParam in origin.GenericParameters)
				ret.GenericParameters.Add(new GenericParamUser(genericParam.Number, genericParam.Flags, "-"));

			return ret;
		}

		/// <summary>
		///     Clones the specified origin MethodDef.
		/// </summary>
		/// <param name="origin">The origin MethodDef.</param>
		/// <returns>The cloned MethodDef.</returns>
		static MethodDefUser Clone(MethodDef origin) {
			var ret = new MethodDefUser(origin.Name, null, origin.ImplAttributes, origin.Attributes);

			foreach (GenericParam genericParam in origin.GenericParameters)
				ret.GenericParameters.Add(new GenericParamUser(genericParam.Number, genericParam.Flags, "-"));

			return ret;
		}

		/// <summary>
		///     Clones the specified origin FieldDef.
		/// </summary>
		/// <param name="origin">The origin FieldDef.</param>
		/// <returns>The cloned FieldDef.</returns>
		static FieldDefUser Clone(FieldDef origin) {
			var ret = new FieldDefUser(origin.Name, null, origin.Attributes);
			return ret;
		}

		/// <summary>
		///     Populates the context mappings.
		/// </summary>
		/// <param name="typeDef">The origin TypeDef.</param>
		/// <param name="ctx">The injection context.</param>
		/// <returns>The new TypeDef.</returns>
		static TypeDef PopulateContext(TypeDef typeDef, InjectContext ctx) {
			TypeDef ret;
			IDnlibDef existing;
			if (!ctx.Map.TryGetValue(typeDef, out existing)) {
				ret = Clone(typeDef);
				ctx.Map[typeDef] = ret;
			}
			else
				ret = (TypeDef)existing;

			foreach (TypeDef nestedType in typeDef.NestedTypes)
				ret.NestedTypes.Add(PopulateContext(nestedType, ctx));

			foreach (MethodDef method in typeDef.Methods)
				ret.Methods.Add((MethodDef)(ctx.Map[method] = Clone(method)));

			foreach (FieldDef field in typeDef.Fields)
				ret.Fields.Add((FieldDef)(ctx.Map[field] = Clone(field)));

			return ret;
		}

		/// <summary>
		///     Copies the information from the origin type to injected type.
		/// </summary>
		/// <param name="typeDef">The origin TypeDef.</param>
		/// <param name="ctx">The injection context.</param>
		static void CopyTypeDef(TypeDef typeDef, InjectContext ctx) {
			var newTypeDef = (TypeDef)ctx.Map[typeDef];

			newTypeDef.BaseType = (ITypeDefOrRef)ctx.Importer.Import(typeDef.BaseType);

			foreach (InterfaceImpl iface in typeDef.Interfaces)
				newTypeDef.Interfaces.Add(new InterfaceImplUser((ITypeDefOrRef)ctx.Importer.Import(iface.Interface)));
		}

		/// <summary>
		///     Copies the information from the origin method to injected method.
		/// </summary>
		/// <param name="methodDef">The origin MethodDef.</param>
		/// <param name="ctx">The injection context.</param>
		static void CopyMethodDef(MethodDef methodDef, InjectContext ctx) {
			var newMethodDef = (MethodDef)ctx.Map[methodDef];

			newMethodDef.Signature = ctx.Importer.Import(methodDef.Signature);
			newMethodDef.Parameters.UpdateParameterTypes();

			if (methodDef.ImplMap != null)
				newMethodDef.ImplMap = new ImplMapUser(new ModuleRefUser(ctx.TargetModule, methodDef.ImplMap.Module.Name), methodDef.ImplMap.Name, methodDef.ImplMap.Attributes);

			foreach (CustomAttribute ca in methodDef.CustomAttributes)
				newMethodDef.CustomAttributes.Add(new CustomAttribute((ICustomAttributeType)ctx.Importer.Import(ca.Constructor)));

			if (methodDef.HasBody) {
				newMethodDef.Body = new CilBody(methodDef.Body.InitLocals, new List<Instruction>(), new List<ExceptionHandler>(), new List<Local>());
				newMethodDef.Body.MaxStack = methodDef.Body.MaxStack;

				var bodyMap = new Dictionary<object, object>();

				foreach (Local local in methodDef.Body.Variables) {
					var newLocal = new Local(ctx.Importer.Import(local.Type));
					newMethodDef.Body.Variables.Add(newLocal);
					newLocal.Name = local.Name;
					newLocal.PdbAttributes = local.PdbAttributes;

					bodyMap[local] = newLocal;
				}

				foreach (Instruction instr in methodDef.Body.Instructions) {
					var newInstr = new Instruction(instr.OpCode, instr.Operand);
					newInstr.SequencePoint = instr.SequencePoint;

					if (newInstr.Operand is IType)
						newInstr.Operand = ctx.Importer.Import((IType)newInstr.Operand);

					else if (newInstr.Operand is IMethod)
						newInstr.Operand = ctx.Importer.Import((IMethod)newInstr.Operand);

					else if (newInstr.Operand is IField)
						newInstr.Operand = ctx.Importer.Import((IField)newInstr.Operand);

					newMethodDef.Body.Instructions.Add(newInstr);
					bodyMap[instr] = newInstr;
				}

				foreach (Instruction instr in newMethodDef.Body.Instructions) {
					if (instr.Operand != null && bodyMap.ContainsKey(instr.Operand))
						instr.Operand = bodyMap[instr.Operand];

					else if (instr.Operand is Instruction[])
						instr.Operand = ((Instruction[])instr.Operand).Select(target => (Instruction)bodyMap[target]).ToArray();
				}

				foreach (ExceptionHandler eh in methodDef.Body.ExceptionHandlers)
					newMethodDef.Body.ExceptionHandlers.Add(new ExceptionHandler(eh.HandlerType) {
						CatchType = eh.CatchType == null ? null : (ITypeDefOrRef)ctx.Importer.Import(eh.CatchType),
						TryStart = (Instruction)bodyMap[eh.TryStart],
						TryEnd = (Instruction)bodyMap[eh.TryEnd],
						HandlerStart = (Instruction)bodyMap[eh.HandlerStart],
						HandlerEnd = (Instruction)bodyMap[eh.HandlerEnd],
						FilterStart = eh.FilterStart == null ? null : (Instruction)bodyMap[eh.FilterStart]
					});

				newMethodDef.Body.SimplifyMacros(newMethodDef.Parameters);
			}
		}

		/// <summary>
		///     Copies the information from the origin field to injected field.
		/// </summary>
		/// <param name="fieldDef">The origin FieldDef.</param>
		/// <param name="ctx">The injection context.</param>
		static void CopyFieldDef(FieldDef fieldDef, InjectContext ctx) {
			var newFieldDef = (FieldDef)ctx.Map[fieldDef];

			newFieldDef.Signature = ctx.Importer.Import(fieldDef.Signature);
		}

		/// <summary>
		///     Copies the information to the injected definitions.
		/// </summary>
		/// <param name="typeDef">The origin TypeDef.</param>
		/// <param name="ctx">The injection context.</param>
		/// <param name="copySelf">if set to <c>true</c>, copy information of <paramref name="typeDef" />.</param>
		static void Copy(TypeDef typeDef, InjectContext ctx, bool copySelf) {
			if (copySelf)
				CopyTypeDef(typeDef, ctx);

			foreach (TypeDef nestedType in typeDef.NestedTypes)
				Copy(nestedType, ctx, true);

			foreach (MethodDef method in typeDef.Methods)
				CopyMethodDef(method, ctx);

			foreach (FieldDef field in typeDef.Fields)
				CopyFieldDef(field, ctx);
		}

		/// <summary>
		///     Injects the specified TypeDef to another module.
		/// </summary>
		/// <param name="typeDef">The source TypeDef.</param>
		/// <param name="target">The target module.</param>
		/// <returns>The injected TypeDef.</returns>
		public static TypeDef Inject(TypeDef typeDef, ModuleDef target) {
			var ctx = new InjectContext(typeDef.Module, target);
			PopulateContext(typeDef, ctx);
			Copy(typeDef, ctx, true);
			return (TypeDef)ctx.Map[typeDef];
		}

		/// <summary>
		///     Injects the specified MethodDef to another module.
		/// </summary>
		/// <param name="methodDef">The source MethodDef.</param>
		/// <param name="target">The target module.</param>
		/// <returns>The injected MethodDef.</returns>
		public static MethodDef Inject(MethodDef methodDef, ModuleDef target) {
			var ctx = new InjectContext(methodDef.Module, target);
			ctx.Map[methodDef] = Clone(methodDef);
			CopyMethodDef(methodDef, ctx);
			return (MethodDef)ctx.Map[methodDef];
		}

		/// <summary>
		///     Injects the members of specified TypeDef to another module.
		/// </summary>
		/// <param name="typeDef">The source TypeDef.</param>
		/// <param name="newType">The new type.</param>
		/// <param name="target">The target module.</param>
		/// <returns>Injected members.</returns>
		public static IEnumerable<IDnlibDef> Inject(TypeDef typeDef, TypeDef newType, ModuleDef target) {
			var ctx = new InjectContext(typeDef.Module, target);
			ctx.Map[typeDef] = newType;
			PopulateContext(typeDef, ctx);
			Copy(typeDef, ctx, false);
			return ctx.Map.Values.Except(new[] { newType });
		}

		/// <summary>
		///     Context of the injection process.
		/// </summary>
		class InjectContext : ImportResolver {
			/// <summary>
			///     The mapping of origin definitions to injected definitions.
			/// </summary>
			public readonly Dictionary<IDnlibDef, IDnlibDef> Map = new Dictionary<IDnlibDef, IDnlibDef>();

			/// <summary>
			///     The module which source type originated from.
			/// </summary>
			public readonly ModuleDef OriginModule;

			/// <summary>
			///     The module which source type is being injected to.
			/// </summary>
			public readonly ModuleDef TargetModule;

			/// <summary>
			///     The importer.
			/// </summary>
			readonly Importer importer;

			/// <summary>
			///     Initializes a new instance of the <see cref="InjectContext" /> class.
			/// </summary>
			/// <param name="module">The origin module.</param>
			/// <param name="target">The target module.</param>
			public InjectContext(ModuleDef module, ModuleDef target) {
				OriginModule = module;
				TargetModule = target;
				importer = new Importer(target, ImporterOptions.TryToUseTypeDefs);
				importer.Resolver = this;
			}

			/// <summary>
			///     Gets the importer.
			/// </summary>
			/// <value>The importer.</value>
			public Importer Importer {
				get { return importer; }
			}

			/// <inheritdoc />
			public override TypeDef Resolve(TypeDef typeDef) {
				if (Map.ContainsKey(typeDef))
					return (TypeDef)Map[typeDef];
				return null;
			}

			/// <inheritdoc />
			public override MethodDef Resolve(MethodDef methodDef) {
				if (Map.ContainsKey(methodDef))
					return (MethodDef)Map[methodDef];
				return null;
			}

			/// <inheritdoc />
			public override FieldDef Resolve(FieldDef fieldDef) {
				if (Map.ContainsKey(fieldDef))
					return (FieldDef)Map[fieldDef];
				return null;
			}
		}
	}
}


================================================
File: Confuser.Core/Helpers/KeySequence.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using Confuser.Core.Services;
using dnlib.DotNet.Emit;

namespace Confuser.Core.Helpers {
	/// <summary>
	///     The type of block in the key sequence
	/// </summary>
	public enum BlockKeyType {
		/// <summary>
		///     The state key should be explicitly set in the block
		/// </summary>
		Explicit,

		/// <summary>
		///     The state key could be assumed to be same as <see cref="BlockKey.EntryState" /> at the beginning of block.
		/// </summary>
		Incremental
	}

	/// <summary>
	///     The information of the block in the key sequence
	/// </summary>
	public struct BlockKey {
		/// <summary>
		///     The state key at the beginning of the block
		/// </summary>
		public uint EntryState;

		/// <summary>
		///     The state key at the end of the block
		/// </summary>
		public uint ExitState;

		/// <summary>
		///     The type of block
		/// </summary>
		public BlockKeyType Type;
	}

	/// <summary>
	///     Computes a key sequence that is valid according to the execution of the CFG.
	/// </summary>
	/// <remarks>
	///     The caller can utilize the information provided by this classes to instruments state machines.
	///     For example:
	///     <code>
	/// int state = 4;
	/// for (int i = 0 ; i &lt; 10; i++) {
	///     state = 6;
	///     if (i % 2 == 0) {
	///         state = 3;
	///     else {
	///         // The state varaible is guaranteed to be 6 in here.
	///     }
	/// }
	///     </code>
	/// </remarks>
	public static class KeySequence {
		/// <summary>
		///     Computes a key sequence of the given CFG.
		/// </summary>
		/// <param name="graph">The CFG.</param>
		/// <param name="random">The random source, or <c>null</c> if key id is needed.</param>
		/// <returns>The generated key sequence of the CFG.</returns>
		public static BlockKey[] ComputeKeys(ControlFlowGraph graph, RandomGenerator random) {
			var keys = new BlockKey[graph.Count];

			foreach (ControlFlowBlock block in graph) {
				var key = new BlockKey();
				if ((block.Type & ControlFlowBlockType.Entry) != 0)
					key.Type = BlockKeyType.Explicit;
				else
					key.Type = BlockKeyType.Incremental;
				keys[block.Id] = key;
			}
			ProcessBlocks(keys, graph, random);
			return keys;
		}

		static void ProcessBlocks(BlockKey[] keys, ControlFlowGraph graph, RandomGenerator random) {
			uint id = 0;
			for (int i = 0; i < keys.Length; i++) {
				keys[i].EntryState = id++;
				keys[i].ExitState = id++;
			}

			var finallyIds = new Dictionary<ExceptionHandler, uint>();
			var ehMap = new Dictionary<ControlFlowBlock, List<ExceptionHandler>>();

			bool updated;
			do {
				updated = false;

				// Update the state ids with the maximum id
				foreach (ControlFlowBlock block in graph) {
					BlockKey key = keys[block.Id];
					if (block.Sources.Count > 0) {
						uint newEntry = block.Sources.Select(b => keys[b.Id].ExitState).Max();
						if (key.EntryState != newEntry) {
							key.EntryState = newEntry;
							updated = true;
						}
					}
					if (block.Targets.Count > 0) {
						uint newExit = block.Targets.Select(b => keys[b.Id].EntryState).Max();
						if (key.ExitState != newExit) {
							key.ExitState = newExit;
							updated = true;
						}
					}
					if (block.Footer.OpCode.Code == Code.Endfilter || block.Footer.OpCode.Code == Code.Endfinally) {
						// Match the exit state within finally/fault/filter
						List<ExceptionHandler> ehs;
						if (!ehMap.TryGetValue(block, out ehs)) {
							ehs = new List<ExceptionHandler>();
							int footerIndex = graph.IndexOf(block.Footer);
							foreach (var eh in graph.Body.ExceptionHandlers) {
								if (eh.FilterStart != null && block.Footer.OpCode.Code == Code.Endfilter) {
									if (footerIndex >= graph.IndexOf(eh.FilterStart) &&
									    footerIndex < graph.IndexOf(eh.HandlerStart))
										ehs.Add(eh);
								}
								else if (eh.HandlerType == ExceptionHandlerType.Finally ||
								         eh.HandlerType == ExceptionHandlerType.Fault) {
									if (footerIndex >= graph.IndexOf(eh.HandlerStart) &&
									    (eh.HandlerEnd == null || footerIndex < graph.IndexOf(eh.HandlerEnd)))
										ehs.Add(eh);
								}
							}
							ehMap[block] = ehs;
						}
						foreach (var eh in ehs) {
							uint ehVal;
							if (finallyIds.TryGetValue(eh, out ehVal)) {
								if (key.ExitState > ehVal) {
									finallyIds[eh] = key.ExitState;
									updated = true;
								}
								else if (key.ExitState < ehVal) {
									key.ExitState = ehVal;
									updated = true;
								}
							}
							else {
								finallyIds[eh] = key.ExitState;
								updated = true;
							}
						}
					}
					else if (block.Footer.OpCode.Code == Code.Leave || block.Footer.OpCode.Code == Code.Leave_S) {
						// Match the exit state with finally/fault/filter
						List<ExceptionHandler> ehs;
						if (!ehMap.TryGetValue(block, out ehs)) {
							ehs = new List<ExceptionHandler>();
							int footerIndex = graph.IndexOf(block.Footer);
							foreach (var eh in graph.Body.ExceptionHandlers) {
								if (footerIndex >= graph.IndexOf(eh.TryStart) &&
								    (eh.TryEnd == null || footerIndex < graph.IndexOf(eh.TryEnd)))
									ehs.Add(eh);
							}
							ehMap[block] = ehs;
						}

						uint? maxVal = null;
						foreach (var eh in ehs) {
							uint ehVal;
							if (finallyIds.TryGetValue(eh, out ehVal) && (maxVal == null || ehVal > maxVal)) {
								if (maxVal != null)
									updated = true;
								maxVal = ehVal;
							}
						}
						if (maxVal != null) {
							if (key.ExitState > maxVal.Value) {
								maxVal = key.ExitState;
								updated = true;
							}
							else if (key.ExitState < maxVal.Value) {
								key.ExitState = maxVal.Value;
								updated = true;
							}
							foreach (var eh in ehs)
								finallyIds[eh] = maxVal.Value;
						}
					}
					keys[block.Id] = key;
				}
			} while (updated);

			if (random != null) {
				// Replace id with actual values
				var idMap = new Dictionary<uint, uint>();
				for (int i = 0; i < keys.Length; i++) {
					BlockKey key = keys[i];

					uint entryId = key.EntryState;
					if (!idMap.TryGetValue(entryId, out key.EntryState))
						key.EntryState = idMap[entryId] = random.NextUInt32();

					uint exitId = key.ExitState;
					if (!idMap.TryGetValue(exitId, out key.ExitState))
						key.ExitState = idMap[exitId] = random.NextUInt32();

					keys[i] = key;
				}
			}
		}
	}
}


================================================
File: Confuser.Core/Helpers/MutationHelper.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using Confuser.Core.Services;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Core.Helpers {
	/// <summary>
	///     Provides methods to mutated injected methods.
	/// </summary>
	public static class MutationHelper {
		const string mutationType = "Mutation";

		static readonly Dictionary<string, int> field2index = new Dictionary<string, int> {
			{ "KeyI0", 0 },
			{ "KeyI1", 1 },
			{ "KeyI2", 2 },
			{ "KeyI3", 3 },
			{ "KeyI4", 4 },
			{ "KeyI5", 5 },
			{ "KeyI6", 6 },
			{ "KeyI7", 7 },
			{ "KeyI8", 8 },
			{ "KeyI9", 9 },
			{ "KeyI10", 10 },
			{ "KeyI11", 11 },
			{ "KeyI12", 12 },
			{ "KeyI13", 13 },
			{ "KeyI14", 14 },
			{ "KeyI15", 15 }
		};

		/// <summary>
		///     Replaces the mutation key placeholder in method with actual key.
		/// </summary>
		/// <param name="method">The method to process.</param>
		/// <param name="keyId">The mutation key ID.</param>
		/// <param name="key">The actual key.</param>
		public static void InjectKey(MethodDef method, int keyId, int key) {
			foreach (Instruction instr in method.Body.Instructions) {
				if (instr.OpCode == OpCodes.Ldsfld) {
					var field = (IField)instr.Operand;
					int _keyId;
					if (field.DeclaringType.FullName == mutationType &&
					    field2index.TryGetValue(field.Name, out _keyId) &&
					    _keyId == keyId) {
						instr.OpCode = OpCodes.Ldc_I4;
						instr.Operand = key;
					}
				}
			}
		}

		/// <summary>
		///     Replaces the mutation key placeholders in method with actual keys.
		/// </summary>
		/// <param name="method">The method to process.</param>
		/// <param name="keyIds">The mutation key IDs.</param>
		/// <param name="keys">The actual keys.</param>
		public static void InjectKeys(MethodDef method, int[] keyIds, int[] keys) {
			foreach (Instruction instr in method.Body.Instructions) {
				if (instr.OpCode == OpCodes.Ldsfld) {
					var field = (IField)instr.Operand;
					int _keyIndex;
					if (field.DeclaringType.FullName == mutationType &&
					    field2index.TryGetValue(field.Name, out _keyIndex) &&
					    (_keyIndex = Array.IndexOf(keyIds, _keyIndex)) != -1) {
						instr.OpCode = OpCodes.Ldc_I4;
						instr.Operand = keys[_keyIndex];
					}
				}
			}
		}

		/// <summary>
		///     Replaces the placeholder call in method with actual instruction sequence.
		/// </summary>
		/// <param name="method">The methodto process.</param>
		/// <param name="repl">The function replacing the argument of placeholder call with actual instruction sequence.</param>
		public static void ReplacePlaceholder(MethodDef method, Func<Instruction[], Instruction[]> repl) {
			MethodTrace trace = new MethodTrace(method).Trace();
			for (int i = 0; i < method.Body.Instructions.Count; i++) {
				Instruction instr = method.Body.Instructions[i];
				if (instr.OpCode == OpCodes.Call) {
					var operand = (IMethod)instr.Operand;
					if (operand.DeclaringType.FullName == mutationType &&
					    operand.Name == "Placeholder") {
						int[] argIndexes = trace.TraceArguments(instr);
						if (argIndexes == null)
							throw new ArgumentException("Failed to trace placeholder argument.");

						int argIndex = argIndexes[0];
						Instruction[] arg = method.Body.Instructions.Skip(argIndex).Take(i - argIndex).ToArray();
						for (int j = 0; j < arg.Length; j++)
							method.Body.Instructions.RemoveAt(argIndex);
						method.Body.Instructions.RemoveAt(argIndex);
						arg = repl(arg);
						for (int j = arg.Length - 1; j >= 0; j--)
							method.Body.Instructions.Insert(argIndex, arg[j]);
						return;
					}
				}
			}
		}
	}
}


================================================
File: Confuser.Core/LZMA/ICoder.cs
================================================
// ICoder.h

using System;
using System.IO;

namespace SevenZip {
	/// <summary>
	///     The exception that is thrown when an error in input stream occurs during decoding.
	/// </summary>
	internal class DataErrorException : ApplicationException {

		public DataErrorException() : base("Data Error") { }

	}

	/// <summary>
	///     The exception that is thrown when the value of an argument is outside the allowable range.
	/// </summary>
	internal class InvalidParamException : ApplicationException {

		public InvalidParamException() : base("Invalid Parameter") { }

	}

	internal interface ICodeProgress {

		/// <summary>
		///     Callback progress.
		/// </summary>
		/// <param name="inSize">
		///     input size. -1 if unknown.
		/// </param>
		/// <param name="outSize">
		///     output size. -1 if unknown.
		/// </param>
		void SetProgress(Int64 inSize, Int64 outSize);

	};

	internal interface ICoder {

		/// <summary>
		///     Codes streams.
		/// </summary>
		/// <param name="inStream">
		///     input Stream.
		/// </param>
		/// <param name="outStream">
		///     output Stream.
		/// </param>
		/// <param name="inSize">
		///     input Size. -1 if unknown.
		/// </param>
		/// <param name="outSize">
		///     output Size. -1 if unknown.
		/// </param>
		/// <param name="progress">
		///     callback progress reference.
		/// </param>
		/// <exception cref="SevenZip.DataErrorException">
		///     if input stream is not valid
		/// </exception>
		void Code(Stream inStream, Stream outStream,
		          Int64 inSize, Int64 outSize, ICodeProgress progress);

	};

	/*
    public interface ICoder2
    {
         void Code(ISequentialInStream []inStreams,
                const UInt64 []inSizes, 
                ISequentialOutStream []outStreams, 
                UInt64 []outSizes,
                ICodeProgress progress);
    };
  */

	/// <summary>
	///     Provides the fields that represent properties idenitifiers for compressing.
	/// </summary>
	internal enum CoderPropID {

		/// <summary>
		///     Specifies default property.
		/// </summary>
		DefaultProp = 0,

		/// <summary>
		///     Specifies size of dictionary.
		/// </summary>
		DictionarySize,

		/// <summary>
		///     Specifies size of memory for PPM*.
		/// </summary>
		UsedMemorySize,

		/// <summary>
		///     Specifies order for PPM methods.
		/// </summary>
		Order,

		/// <summary>
		///     Specifies Block Size.
		/// </summary>
		BlockSize,

		/// <summary>
		///     Specifies number of postion state bits for LZMA (0 &lt;= x &lt;= 4).
		/// </summary>
		PosStateBits,

		/// <summary>
		///     Specifies number of literal context bits for LZMA (0 &lt;= x &lt;= 8).
		/// </summary>
		LitContextBits,

		/// <summary>
		///     Specifies number of literal position bits for LZMA (0 &lt;= x &lt;= 4).
		/// </summary>
		LitPosBits,

		/// <summary>
		///     Specifies number of fast bytes for LZ*.
		/// </summary>
		NumFastBytes,

		/// <summary>
		///     Specifies match finder. LZMA: "BT2", "BT4" or "BT4B".
		/// </summary>
		MatchFinder,

		/// <summary>
		///     Specifies the number of match finder cyckes.
		/// </summary>
		MatchFinderCycles,

		/// <summary>
		///     Specifies number of passes.
		/// </summary>
		NumPasses,

		/// <summary>
		///     Specifies number of algorithm.
		/// </summary>
		Algorithm,

		/// <summary>
		///     Specifies the number of threads.
		/// </summary>
		NumThreads,

		/// <summary>
		///     Specifies mode with end marker.
		/// </summary>
		EndMarker

	};


	internal interface ISetCoderProperties {

		void SetCoderProperties(CoderPropID[] propIDs, object[] properties);

	};

	internal interface IWriteCoderProperties {

		void WriteCoderProperties(Stream outStream);

	}

	internal interface ISetDecoderProperties {

		void SetDecoderProperties(byte[] properties);

	}
}


================================================
File: Confuser.Core/LZMA/Common/CRC.cs
================================================
// Common/CRC.cs

using System;

namespace SevenZip {
	internal class CRC {

		public static readonly uint[] Table;

		private uint _value = 0xFFFFFFFF;

		static CRC() {
			Table = new uint[256];
			const uint kPoly = 0xEDB88320;
			for (uint i = 0; i < 256; i++) {
				uint r = i;
				for (int j = 0; j < 8; j++)
					if ((r & 1) != 0)
						r = (r >> 1) ^ kPoly;
					else
						r >>= 1;
				Table[i] = r;
			}
		}

		public void Init() {
			_value = 0xFFFFFFFF;
		}

		public void UpdateByte(byte b) {
			_value = Table[(((byte)(_value)) ^ b)] ^ (_value >> 8);
		}

		public void Update(byte[] data, uint offset, uint size) {
			for (uint i = 0; i < size; i++)
				_value = Table[(((byte)(_value)) ^ data[offset + i])] ^ (_value >> 8);
		}

		public uint GetDigest() {
			return _value ^ 0xFFFFFFFF;
		}

		private static uint CalculateDigest(byte[] data, uint offset, uint size) {
			var crc = new CRC();
			// crc.Init();
			crc.Update(data, offset, size);
			return crc.GetDigest();
		}

		private static bool VerifyDigest(uint digest, byte[] data, uint offset, uint size) {
			return (CalculateDigest(data, offset, size) == digest);
		}

	}
}


================================================
File: Confuser.Core/LZMA/Common/InBuffer.cs
================================================
// InBuffer.cs

using System;
using System.IO;

namespace SevenZip.Buffer {
	internal class InBuffer {

		private readonly byte[] m_Buffer;
		private readonly uint m_BufferSize;
		private uint m_Limit;
		private uint m_Pos;
		private ulong m_ProcessedSize;
		private Stream m_Stream;
		private bool m_StreamWasExhausted;

		public InBuffer(uint bufferSize) {
			m_Buffer = new byte[bufferSize];
			m_BufferSize = bufferSize;
		}

		public void Init(Stream stream) {
			m_Stream = stream;
			m_ProcessedSize = 0;
			m_Limit = 0;
			m_Pos = 0;
			m_StreamWasExhausted = false;
		}

		public bool ReadBlock() {
			if (m_StreamWasExhausted)
				return false;
			m_ProcessedSize += m_Pos;
			int aNumProcessedBytes = m_Stream.Read(m_Buffer, 0, (int)m_BufferSize);
			m_Pos = 0;
			m_Limit = (uint)aNumProcessedBytes;
			m_StreamWasExhausted = (aNumProcessedBytes == 0);
			return (!m_StreamWasExhausted);
		}


		public void ReleaseStream() {
			// m_Stream.Close(); 
			m_Stream = null;
		}

		public bool ReadByte(byte b) // check it
		{
			if (m_Pos >= m_Limit)
				if (!ReadBlock())
					return false;
			b = m_Buffer[m_Pos++];
			return true;
		}

		public byte ReadByte() {
			// return (byte)m_Stream.ReadByte();
			if (m_Pos >= m_Limit)
				if (!ReadBlock())
					return 0xFF;
			return m_Buffer[m_Pos++];
		}

		public ulong GetProcessedSize() {
			return m_ProcessedSize + m_Pos;
		}

	}
}


================================================
File: Confuser.Core/LZMA/Common/OutBuffer.cs
================================================
// OutBuffer.cs

using System;
using System.IO;

namespace SevenZip.Buffer {
	internal class OutBuffer {

		private readonly byte[] m_Buffer;
		private readonly uint m_BufferSize;
		private uint m_Pos;
		private ulong m_ProcessedSize;
		private Stream m_Stream;

		public OutBuffer(uint bufferSize) {
			m_Buffer = new byte[bufferSize];
			m_BufferSize = bufferSize;
		}

		public void SetStream(Stream stream) {
			m_Stream = stream;
		}

		public void FlushStream() {
			m_Stream.Flush();
		}

		public void CloseStream() {
			m_Stream.Close();
		}

		public void ReleaseStream() {
			m_Stream = null;
		}

		public void Init() {
			m_ProcessedSize = 0;
			m_Pos = 0;
		}

		public void WriteByte(byte b) {
			m_Buffer[m_Pos++] = b;
			if (m_Pos >= m_BufferSize)
				FlushData();
		}

		public void FlushData() {
			if (m_Pos == 0)
				return;
			m_Stream.Write(m_Buffer, 0, (int)m_Pos);
			m_Pos = 0;
		}

		public ulong GetProcessedSize() {
			return m_ProcessedSize + m_Pos;
		}

	}
}


================================================
File: Confuser.Core/LZMA/Compress/LZ/IMatchFinder.cs
================================================
// IMatchFinder.cs

using System;
using System.IO;

namespace SevenZip.Compression.LZ {
	internal interface IInWindowStream {

		void SetStream(Stream inStream);
		void Init();
		void ReleaseStream();
		Byte GetIndexByte(Int32 index);
		UInt32 GetMatchLen(Int32 index, UInt32 distance, UInt32 limit);
		UInt32 GetNumAvailableBytes();

	}

	internal interface IMatchFinder : IInWindowStream {

		void Create(UInt32 historySize, UInt32 keepAddBufferBefore,
		            UInt32 matchMaxLen, UInt32 keepAddBufferAfter);

		UInt32 GetMatches(UInt32[] distances);
		void Skip(UInt32 num);

	}
}


================================================
File: Confuser.Core/LZMA/Compress/LZ/LzBinTree.cs
================================================
// LzBinTree.cs

using System;
using System.IO;

namespace SevenZip.Compression.LZ {
	internal class BinTree : InWindow, IMatchFinder {

		private const UInt32 kHash2Size = 1 << 10;
		private const UInt32 kHash3Size = 1 << 16;
		private const UInt32 kBT2HashSize = 1 << 16;
		private const UInt32 kStartMaxLen = 1;
		private const UInt32 kHash3Offset = kHash2Size;
		private const UInt32 kEmptyHashValue = 0;
		private const UInt32 kMaxValForNormalize = ((UInt32)1 << 31) - 1;
		private bool HASH_ARRAY = true;
		private UInt32 _cutValue = 0xFF;
		private UInt32 _cyclicBufferPos;
		private UInt32 _cyclicBufferSize;
		private UInt32[] _hash;
		private UInt32 _hashMask;
		private UInt32 _hashSizeSum;
		private UInt32 _matchMaxLen;

		private UInt32[] _son;

		private UInt32 kFixHashSize = kHash2Size + kHash3Size;
		private UInt32 kMinMatchCheck = 4;
		private UInt32 kNumHashDirectBytes;

		public new void SetStream(Stream stream) {
			base.SetStream(stream);
		}

		public new void ReleaseStream() {
			base.ReleaseStream();
		}

		public new void Init() {
			base.Init();
			for (UInt32 i = 0; i < _hashSizeSum; i++)
				_hash[i] = kEmptyHashValue;
			_cyclicBufferPos = 0;
			ReduceOffsets(-1);
		}

		public new Byte GetIndexByte(Int32 index) {
			return base.GetIndexByte(index);
		}

		public new UInt32 GetMatchLen(Int32 index, UInt32 distance, UInt32 limit) {
			return base.GetMatchLen(index, distance, limit);
		}

		public new UInt32 GetNumAvailableBytes() {
			return base.GetNumAvailableBytes();
		}

		public void Create(UInt32 historySize, UInt32 keepAddBufferBefore,
		                   UInt32 matchMaxLen, UInt32 keepAddBufferAfter) {
			if (historySize > kMaxValForNormalize - 256)
				throw new Exception();
			_cutValue = 16 + (matchMaxLen >> 1);

			UInt32 windowReservSize = (historySize + keepAddBufferBefore +
			                           matchMaxLen + keepAddBufferAfter) / 2 + 256;

			base.Create(historySize + keepAddBufferBefore, matchMaxLen + keepAddBufferAfter, windowReservSize);

			_matchMaxLen = matchMaxLen;

			UInt32 cyclicBufferSize = historySize + 1;
			if (_cyclicBufferSize != cyclicBufferSize)
				_son = new UInt32[(_cyclicBufferSize = cyclicBufferSize) * 2];

			UInt32 hs = kBT2HashSize;

			if (HASH_ARRAY) {
				hs = historySize - 1;
				hs |= (hs >> 1);
				hs |= (hs >> 2);
				hs |= (hs >> 4);
				hs |= (hs >> 8);
				hs >>= 1;
				hs |= 0xFFFF;
				if (hs > (1 << 24))
					hs >>= 1;
				_hashMask = hs;
				hs++;
				hs += kFixHashSize;
			}
			if (hs != _hashSizeSum)
				_hash = new UInt32[_hashSizeSum = hs];
		}

		public UInt32 GetMatches(UInt32[] distances) {
			UInt32 lenLimit;
			if (_pos + _matchMaxLen <= _streamPos)
				lenLimit = _matchMaxLen;
			else {
				lenLimit = _streamPos - _pos;
				if (lenLimit < kMinMatchCheck) {
					MovePos();
					return 0;
				}
			}

			UInt32 offset = 0;
			UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;
			UInt32 cur = _bufferOffset + _pos;
			UInt32 maxLen = kStartMaxLen; // to avoid items for len < hashSize;
			UInt32 hashValue, hash2Value = 0, hash3Value = 0;

			if (HASH_ARRAY) {
				UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];
				hash2Value = temp & (kHash2Size - 1);
				temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);
				hash3Value = temp & (kHash3Size - 1);
				hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;
			}
			else
				hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);

			UInt32 curMatch = _hash[kFixHashSize + hashValue];
			if (HASH_ARRAY) {
				UInt32 curMatch2 = _hash[hash2Value];
				UInt32 curMatch3 = _hash[kHash3Offset + hash3Value];
				_hash[hash2Value] = _pos;
				_hash[kHash3Offset + hash3Value] = _pos;
				if (curMatch2 > matchMinPos)
					if (_bufferBase[_bufferOffset + curMatch2] == _bufferBase[cur]) {
						distances[offset++] = maxLen = 2;
						distances[offset++] = _pos - curMatch2 - 1;
					}
				if (curMatch3 > matchMinPos)
					if (_bufferBase[_bufferOffset + curMatch3] == _bufferBase[cur]) {
						if (curMatch3 == curMatch2)
							offset -= 2;
						distances[offset++] = maxLen = 3;
						distances[offset++] = _pos - curMatch3 - 1;
						curMatch2 = curMatch3;
					}
				if (offset != 0 && curMatch2 == curMatch) {
					offset -= 2;
					maxLen = kStartMaxLen;
				}
			}

			_hash[kFixHashSize + hashValue] = _pos;

			UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;
			UInt32 ptr1 = (_cyclicBufferPos << 1);

			UInt32 len0, len1;
			len0 = len1 = kNumHashDirectBytes;

			if (kNumHashDirectBytes != 0) {
				if (curMatch > matchMinPos) {
					if (_bufferBase[_bufferOffset + curMatch + kNumHashDirectBytes] !=
					    _bufferBase[cur + kNumHashDirectBytes]) {
						distances[offset++] = maxLen = kNumHashDirectBytes;
						distances[offset++] = _pos - curMatch - 1;
					}
				}
			}

			UInt32 count = _cutValue;

			while (true) {
				if (curMatch <= matchMinPos || count-- == 0) {
					_son[ptr0] = _son[ptr1] = kEmptyHashValue;
					break;
				}
				UInt32 delta = _pos - curMatch;
				UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ?
					                    (_cyclicBufferPos - delta) :
					                    (_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;

				UInt32 pby1 = _bufferOffset + curMatch;
				UInt32 len = Math.Min(len0, len1);
				if (_bufferBase[pby1 + len] == _bufferBase[cur + len]) {
					while (++len != lenLimit)
						if (_bufferBase[pby1 + len] != _bufferBase[cur + len])
							break;
					if (maxLen < len) {
						distances[offset++] = maxLen = len;
						distances[offset++] = delta - 1;
						if (len == lenLimit) {
							_son[ptr1] = _son[cyclicPos];
							_son[ptr0] = _son[cyclicPos + 1];
							break;
						}
					}
				}
				if (_bufferBase[pby1 + len] < _bufferBase[cur + len]) {
					_son[ptr1] = curMatch;
					ptr1 = cyclicPos + 1;
					curMatch = _son[ptr1];
					len1 = len;
				}
				else {
					_son[ptr0] = curMatch;
					ptr0 = cyclicPos;
					curMatch = _son[ptr0];
					len0 = len;
				}
			}
			MovePos();
			return offset;
		}

		public void Skip(UInt32 num) {
			do {
				UInt32 lenLimit;
				if (_pos + _matchMaxLen <= _streamPos)
					lenLimit = _matchMaxLen;
				else {
					lenLimit = _streamPos - _pos;
					if (lenLimit < kMinMatchCheck) {
						MovePos();
						continue;
					}
				}

				UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;
				UInt32 cur = _bufferOffset + _pos;

				UInt32 hashValue;

				if (HASH_ARRAY) {
					UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];
					UInt32 hash2Value = temp & (kHash2Size - 1);
					_hash[hash2Value] = _pos;
					temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);
					UInt32 hash3Value = temp & (kHash3Size - 1);
					_hash[kHash3Offset + hash3Value] = _pos;
					hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;
				}
				else
					hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);

				UInt32 curMatch = _hash[kFixHashSize + hashValue];
				_hash[kFixHashSize + hashValue] = _pos;

				UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;
				UInt32 ptr1 = (_cyclicBufferPos << 1);

				UInt32 len0, len1;
				len0 = len1 = kNumHashDirectBytes;

				UInt32 count = _cutValue;
				while (true) {
					if (curMatch <= matchMinPos || count-- == 0) {
						_son[ptr0] = _son[ptr1] = kEmptyHashValue;
						break;
					}

					UInt32 delta = _pos - curMatch;
					UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ?
						                    (_cyclicBufferPos - delta) :
						                    (_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;

					UInt32 pby1 = _bufferOffset + curMatch;
					UInt32 len = Math.Min(len0, len1);
					if (_bufferBase[pby1 + len] == _bufferBase[cur + len]) {
						while (++len != lenLimit)
							if (_bufferBase[pby1 + len] != _bufferBase[cur + len])
								break;
						if (len == lenLimit) {
							_son[ptr1] = _son[cyclicPos];
							_son[ptr0] = _son[cyclicPos + 1];
							break;
						}
					}
					if (_bufferBase[pby1 + len] < _bufferBase[cur + len]) {
						_son[ptr1] = curMatch;
						ptr1 = cyclicPos + 1;
						curMatch = _son[ptr1];
						len1 = len;
					}
					else {
						_son[ptr0] = curMatch;
						ptr0 = cyclicPos;
						curMatch = _son[ptr0];
						len0 = len;
					}
				}
				MovePos();
			} while (--num != 0);
		}

		public void SetType(int numHashBytes) {
			HASH_ARRAY = (numHashBytes > 2);
			if (HASH_ARRAY) {
				kNumHashDirectBytes = 0;
				kMinMatchCheck = 4;
				kFixHashSize = kHash2Size + kHash3Size;
			}
			else {
				kNumHashDirectBytes = 2;
				kMinMatchCheck = 2 + 1;
				kFixHashSize = 0;
			}
		}

		public new void MovePos() {
			if (++_cyclicBufferPos >= _cyclicBufferSize)
				_cyclicBufferPos = 0;
			base.MovePos();
			if (_pos == kMaxValForNormalize)
				Normalize();
		}

		private void NormalizeLinks(UInt32[] items, UInt32 numItems, UInt32 subValue) {
			for (UInt32 i = 0; i < numItems; i++) {
				UInt32 value = items[i];
				if (value <= subValue)
					value = kEmptyHashValue;
				else
					value -= subValue;
				items[i] = value;
			}
		}

		private void Normalize() {
			UInt32 subValue = _pos - _cyclicBufferSize;
			NormalizeLinks(_son, _cyclicBufferSize * 2, subValue);
			NormalizeLinks(_hash, _hashSizeSum, subValue);
			ReduceOffsets((Int32)subValue);
		}

		public void SetCutValue(UInt32 cutValue) {
			_cutValue = cutValue;
		}

	}
}


================================================
File: Confuser.Core/LZMA/Compress/LZ/LzInWindow.cs
================================================
// LzInWindow.cs

using System;
using System.IO;

namespace SevenZip.Compression.LZ {
	internal class InWindow {

		public UInt32 _blockSize; // Size of Allocated memory block
		public Byte[] _bufferBase = null; // pointer to buffer with data

		public UInt32 _bufferOffset;

		private UInt32 _keepSizeAfter; // how many BYTEs must be kept buffer after _pos
		private UInt32 _keepSizeBefore; // how many BYTEs must be kept in buffer before _pos
		private UInt32 _pointerToLastSafePosition;
		public UInt32 _pos; // offset (from _buffer) of curent byte
		private UInt32 _posLimit; // offset (from _buffer) of first byte when new block reading must be done
		private Stream _stream;
		private bool _streamEndWasReached; // if (true) then _streamPos shows real end of stream
		public UInt32 _streamPos; // offset (from _buffer) of first not read byte from Stream

		public void MoveBlock() {
			UInt32 offset = _bufferOffset + _pos - _keepSizeBefore;
			// we need one additional byte, since MovePos moves on 1 byte.
			if (offset > 0)
				offset--;

			UInt32 numBytes = _bufferOffset + _streamPos - offset;

			// check negative offset ????
			for (UInt32 i = 0; i < numBytes; i++)
				_bufferBase[i] = _bufferBase[offset + i];
			_bufferOffset -= offset;
		}

		public virtual void ReadBlock() {
			if (_streamEndWasReached)
				return;
			while (true) {
				var size = (int)((0 - _bufferOffset) + _blockSize - _streamPos);
				if (size == 0)
					return;
				int numReadBytes = _stream.Read(_bufferBase, (int)(_bufferOffset + _streamPos), size);
				if (numReadBytes == 0) {
					_posLimit = _streamPos;
					UInt32 pointerToPostion = _bufferOffset + _posLimit;
					if (pointerToPostion > _pointerToLastSafePosition)
						_posLimit = _pointerToLastSafePosition - _bufferOffset;

					_streamEndWasReached = true;
					return;
				}
				_streamPos += (UInt32)numReadBytes;
				if (_streamPos >= _pos + _keepSizeAfter)
					_posLimit = _streamPos - _keepSizeAfter;
			}
		}

		private void Free() {
			_bufferBase = null;
		}

		public void Create(UInt32 keepSizeBefore, UInt32 keepSizeAfter, UInt32 keepSizeReserv) {
			_keepSizeBefore = keepSizeBefore;
			_keepSizeAfter = keepSizeAfter;
			UInt32 blockSize = keepSizeBefore + keepSizeAfter + keepSizeReserv;
			if (_bufferBase == null || _blockSize != blockSize) {
				Free();
				_blockSize = blockSize;
				_bufferBase = new Byte[_blockSize];
			}
			_pointerToLastSafePosition = _blockSize - keepSizeAfter;
		}

		public void SetStream(Stream stream) {
			_stream = stream;
		}

		public void ReleaseStream() {
			_stream = null;
		}

		public void Init() {
			_bufferOffset = 0;
			_pos = 0;
			_streamPos = 0;
			_streamEndWasReached = false;
			ReadBlock();
		}

		public void MovePos() {
			_pos++;
			if (_pos > _posLimit) {
				UInt32 pointerToPostion = _bufferOffset + _pos;
				if (pointerToPostion > _pointerToLastSafePosition)
					MoveBlock();
				ReadBlock();
			}
		}

		public Byte GetIndexByte(Int32 index) {
			return _bufferBase[_bufferOffset + _pos + index];
		}

		// index + limit have not to exceed _keepSizeAfter;
		public UInt32 GetMatchLen(Int32 index, UInt32 distance, UInt32 limit) {
			if (_streamEndWasReached)
				if ((_pos + index) + limit > _streamPos)
					limit = _streamPos - (UInt32)(_pos + index);
			distance++;
			// Byte *pby = _buffer + (size_t)_pos + index;
			UInt32 pby = _bufferOffset + _pos + (UInt32)index;

			UInt32 i;
			for (i = 0; i < limit && _bufferBase[pby + i] == _bufferBase[pby + i - distance]; i++) ;
			return i;
		}

		public UInt32 GetNumAvailableBytes() {
			return _streamPos - _pos;
		}

		public void ReduceOffsets(Int32 subValue) {
			_bufferOffset += (UInt32)subValue;
			_posLimit -= (UInt32)subValue;
			_pos -= (UInt32)subValue;
			_streamPos -= (UInt32)subValue;
		}

	}
}


================================================
File: Confuser.Core/LZMA/Compress/LZ/LzOutWindow.cs
================================================
// LzOutWindow.cs

using System;
using System.IO;

namespace SevenZip.Compression.LZ {
	internal class OutWindow {

		public uint TrainSize = 0;
		private byte[] _buffer;
		private uint _pos;
		private Stream _stream;
		private uint _streamPos;
		private uint _windowSize;

		public void Create(uint windowSize) {
			if (_windowSize != windowSize) {
				// System.GC.Collect();
				_buffer = new byte[windowSize];
			}
			_windowSize = windowSize;
			_pos = 0;
			_streamPos = 0;
		}

		public void Init(Stream stream, bool solid) {
			ReleaseStream();
			_stream = stream;
			if (!solid) {
				_streamPos = 0;
				_pos = 0;
				TrainSize = 0;
			}
		}

		public bool Train(Stream stream) {
			long len = stream.Length;
			uint size = (len < _windowSize) ? (uint)len : _windowSize;
			TrainSize = size;
			stream.Position = len - size;
			_streamPos = _pos = 0;
			while (size > 0) {
				uint curSize = _windowSize - _pos;
				if (size < curSize)
					curSize = size;
				int numReadBytes = stream.Read(_buffer, (int)_pos, (int)curSize);
				if (numReadBytes == 0)
					return false;
				size -= (uint)numReadBytes;
				_pos += (uint)numReadBytes;
				_streamPos += (uint)numReadBytes;
				if (_pos == _windowSize)
					_streamPos = _pos = 0;
			}
			return true;
		}

		public void ReleaseStream() {
			Flush();
			_stream = null;
		}

		public void Flush() {
			uint size = _pos - _streamPos;
			if (size == 0)
				return;
			_stream.Write(_buffer, (int)_streamPos, (int)size);
			if (_pos >= _windowSize)
				_pos = 0;
			_streamPos = _pos;
		}

		public void CopyBlock(uint distance, uint len) {
			uint pos = _pos - distance - 1;
			if (pos >= _windowSize)
				pos += _windowSize;
			for (; len > 0; len--) {
				if (pos >= _windowSize)
					pos = 0;
				_buffer[_pos++] = _buffer[pos++];
				if (_pos >= _windowSize)
					Flush();
			}
		}

		public void PutByte(byte b) {
			_buffer[_pos++] = b;
			if (_pos >= _windowSize)
				Flush();
		}

		public byte GetByte(uint distance) {
			uint pos = _pos - distance - 1;
			if (pos >= _windowSize)
				pos += _windowSize;
			return _buffer[pos];
		}

	}
}


================================================
File: Confuser.Core/LZMA/Compress/LZMA/LzmaBase.cs
================================================
// LzmaBase.cs

using System;

namespace SevenZip.Compression.LZMA {
	internal abstract class Base {

		public const uint kNumRepDistances = 4;
		public const uint kNumStates = 12;

		// static byte []kLiteralNextStates  = {0, 0, 0, 0, 1, 2, 3, 4,  5,  6,   4, 5};
		// static byte []kMatchNextStates    = {7, 7, 7, 7, 7, 7, 7, 10, 10, 10, 10, 10};
		// static byte []kRepNextStates      = {8, 8, 8, 8, 8, 8, 8, 11, 11, 11, 11, 11};
		// static byte []kShortRepNextStates = {9, 9, 9, 9, 9, 9, 9, 11, 11, 11, 11, 11};

		public const int kNumPosSlotBits = 6;
		public const int kDicLogSizeMin = 0;
		// public const int kDicLogSizeMax = 30;
		// public const uint kDistTableSizeMax = kDicLogSizeMax * 2;

		public const int kNumLenToPosStatesBits = 2; // it's for speed optimization
		public const uint kNumLenToPosStates = 1 << kNumLenToPosStatesBits;

		public const uint kMatchMinLen = 2;

		public const int kNumAlignBits = 4;
		public const uint kAlignTableSize = 1 << kNumAlignBits;
		public const uint kAlignMask = (kAlignTableSize - 1);

		public const uint kStartPosModelIndex = 4;
		public const uint kEndPosModelIndex = 14;
		public const uint kNumPosModels = kEndPosModelIndex - kStartPosModelIndex;

		public const uint kNumFullDistances = 1 << ((int)kEndPosModelIndex / 2);

		public const uint kNumLitPosStatesBitsEncodingMax = 4;
		public const uint kNumLitContextBitsMax = 8;

		public const int kNumPosStatesBitsMax = 4;
		public const uint kNumPosStatesMax = (1 << kNumPosStatesBitsMax);
		public const int kNumPosStatesBitsEncodingMax = 4;
		public const uint kNumPosStatesEncodingMax = (1 << kNumPosStatesBitsEncodingMax);

		public const int kNumLowLenBits = 3;
		public const int kNumMidLenBits = 3;
		public const int kNumHighLenBits = 8;
		public const uint kNumLowLenSymbols = 1 << kNumLowLenBits;
		public const uint kNumMidLenSymbols = 1 << kNumMidLenBits;

		public const uint kNumLenSymbols = kNumLowLenSymbols + kNumMidLenSymbols +
		                                   (1 << kNumHighLenBits);

		public const uint kMatchMaxLen = kMatchMinLen + kNumLenSymbols - 1;

		public static uint GetLenToPosState(uint len) {
			len -= kMatchMinLen;
			if (len < kNumLenToPosStates)
				return len;
			return kNumLenToPosStates - 1;
		}

		public struct State {

			public uint Index;

			public void Init() {
				Index = 0;
			}

			public void UpdateChar() {
				if (Index < 4) Index = 0;
				else if (Index < 10) Index -= 3;
				else Index -= 6;
			}

			public void UpdateMatch() {
				Index = (uint)(Index < 7 ? 7 : 10);
			}

			public void UpdateRep() {
				Index = (uint)(Index < 7 ? 8 : 11);
			}

			public void UpdateShortRep() {
				Index = (uint)(Index < 7 ? 9 : 11);
			}

			public bool IsCharState() {
				return Index < 7;
			}

		}

	}
}


================================================
File: Confuser.Core/LZMA/Compress/LZMA/LzmaDecoder.cs
================================================
// LzmaDecoder.cs

using System;
using System.IO;
using SevenZip.Compression.LZ;
using SevenZip.Compression.RangeCoder;

namespace SevenZip.Compression.LZMA {
	internal class Decoder : ICoder, ISetDecoderProperties // ,System.IO.Stream
	{

		private readonly BitDecoder[] m_IsMatchDecoders = new BitDecoder[Base.kNumStates << Base.kNumPosStatesBitsMax];
		private readonly BitDecoder[] m_IsRep0LongDecoders = new BitDecoder[Base.kNumStates << Base.kNumPosStatesBitsMax];
		private readonly BitDecoder[] m_IsRepDecoders = new BitDecoder[Base.kNumStates];
		private readonly BitDecoder[] m_IsRepG0Decoders = new BitDecoder[Base.kNumStates];
		private readonly BitDecoder[] m_IsRepG1Decoders = new BitDecoder[Base.kNumStates];
		private readonly BitDecoder[] m_IsRepG2Decoders = new BitDecoder[Base.kNumStates];

		private readonly LenDecoder m_LenDecoder = new LenDecoder();

		private readonly LiteralDecoder m_LiteralDecoder = new LiteralDecoder();
		private readonly OutWindow m_OutWindow = new OutWindow();
		private readonly BitDecoder[] m_PosDecoders = new BitDecoder[Base.kNumFullDistances - Base.kEndPosModelIndex];
		private readonly BitTreeDecoder[] m_PosSlotDecoder = new BitTreeDecoder[Base.kNumLenToPosStates];
		private readonly RangeCoder.Decoder m_RangeDecoder = new RangeCoder.Decoder();
		private readonly LenDecoder m_RepLenDecoder = new LenDecoder();
		private bool _solid;

		private uint m_DictionarySize;
		private uint m_DictionarySizeCheck;
		private BitTreeDecoder m_PosAlignDecoder = new BitTreeDecoder(Base.kNumAlignBits);

		private uint m_PosStateMask;

		public Decoder() {
			m_DictionarySize = 0xFFFFFFFF;
			for (int i = 0; i < Base.kNumLenToPosStates; i++)
				m_PosSlotDecoder[i] = new BitTreeDecoder(Base.kNumPosSlotBits);
		}

		public void Code(Stream inStream, Stream outStream,
		                 Int64 inSize, Int64 outSize, ICodeProgress progress) {
			Init(inStream, outStream);

			var state = new Base.State();
			state.Init();
			uint rep0 = 0, rep1 = 0, rep2 = 0, rep3 = 0;

			UInt64 nowPos64 = 0;
			var outSize64 = (UInt64)outSize;
			if (nowPos64 < outSize64) {
				if (m_IsMatchDecoders[state.Index << Base.kNumPosStatesBitsMax].Decode(m_RangeDecoder) != 0)
					throw new DataErrorException();
				state.UpdateChar();
				byte b = m_LiteralDecoder.DecodeNormal(m_RangeDecoder, 0, 0);
				m_OutWindow.PutByte(b);
				nowPos64++;
			}
			while (nowPos64 < outSize64) {
				// UInt64 next = Math.Min(nowPos64 + (1 << 18), outSize64);
				// while(nowPos64 < next)
				{
					uint posState = (uint)nowPos64 & m_PosStateMask;
					if (m_IsMatchDecoders[(state.Index << Base.kNumPosStatesBitsMax) + posState].Decode(m_RangeDecoder) == 0) {
						byte b;
						byte prevByte = m_OutWindow.GetByte(0);
						if (!state.IsCharState())
							b = m_LiteralDecoder.DecodeWithMatchByte(m_RangeDecoder,
							                                         (uint)nowPos64, prevByte, m_OutWindow.GetByte(rep0));
						else
							b = m_LiteralDecoder.DecodeNormal(m_RangeDecoder, (uint)nowPos64, prevByte);
						m_OutWindow.PutByte(b);
						state.UpdateChar();
						nowPos64++;
					}
					else {
						uint len;
						if (m_IsRepDecoders[state.Index].Decode(m_RangeDecoder) == 1) {
							if (m_IsRepG0Decoders[state.Index].Decode(m_RangeDecoder) == 0) {
								if (m_IsRep0LongDecoders[(state.Index << Base.kNumPosStatesBitsMax) + posState].Decode(m_RangeDecoder) == 0) {
									state.UpdateShortRep();
									m_OutWindow.PutByte(m_OutWindow.GetByte(rep0));
									nowPos64++;
									continue;
								}
							}
							else {
								UInt32 distance;
								if (m_IsRepG1Decoders[state.Index].Decode(m_RangeDecoder) == 0) {
									distance = rep1;
								}
								else {
									if (m_IsRepG2Decoders[state.Index].Decode(m_RangeDecoder) == 0)
										distance = rep2;
									else {
										distance = rep3;
										rep3 = rep2;
									}
									rep2 = rep1;
								}
								rep1 = rep0;
								rep0 = distance;
							}
							len = m_RepLenDecoder.Decode(m_RangeDecoder, posState) + Base.kMatchMinLen;
							state.UpdateRep();
						}
						else {
							rep3 = rep2;
							rep2 = rep1;
							rep1 = rep0;
							len = Base.kMatchMinLen + m_LenDecoder.Decode(m_RangeDecoder, posState);
							state.UpdateMatch();
							uint posSlot = m_PosSlotDecoder[Base.GetLenToPosState(len)].Decode(m_RangeDecoder);
							if (posSlot >= Base.kStartPosModelIndex) {
								var numDirectBits = (int)((posSlot >> 1) - 1);
								rep0 = ((2 | (posSlot & 1)) << numDirectBits);
								if (posSlot < Base.kEndPosModelIndex)
									rep0 += BitTreeDecoder.ReverseDecode(m_PosDecoders,
									                                     rep0 - posSlot - 1, m_RangeDecoder, numDirectBits);
								else {
									rep0 += (m_RangeDecoder.DecodeDirectBits(
										numDirectBits - Base.kNumAlignBits) << Base.kNumAlignBits);
									rep0 += m_PosAlignDecoder.ReverseDecode(m_RangeDecoder);
								}
							}
							else
								rep0 = posSlot;
						}
						if (rep0 >= m_OutWindow.TrainSize + nowPos64 || rep0 >= m_DictionarySizeCheck) {
							if (rep0 == 0xFFFFFFFF)
								break;
							throw new DataErrorException();
						}
						m_OutWindow.CopyBlock(rep0, len);
						nowPos64 += len;
					}
				}
			}
			m_OutWindow.Flush();
			m_OutWindow.ReleaseStream();
			m_RangeDecoder.ReleaseStream();
		}

		public void SetDecoderProperties(byte[] properties) {
			if (properties.Length < 5)
				throw new InvalidParamException();
			int lc = properties[0] % 9;
			int remainder = properties[0] / 9;
			int lp = remainder % 5;
			int pb = remainder / 5;
			if (pb > Base.kNumPosStatesBitsMax)
				throw new InvalidParamException();
			UInt32 dictionarySize = 0;
			for (int i = 0; i < 4; i++)
				dictionarySize += ((UInt32)(properties[1 + i])) << (i * 8);
			SetDictionarySize(dictionarySize);
			SetLiteralProperties(lp, lc);
			SetPosBitsProperties(pb);
		}

		private void SetDictionarySize(uint dictionarySize) {
			if (m_DictionarySize != dictionarySize) {
				m_DictionarySize = dictionarySize;
				m_DictionarySizeCheck = Math.Max(m_DictionarySize, 1);
				uint blockSize = Math.Max(m_DictionarySizeCheck, (1 << 12));
				m_OutWindow.Create(blockSize);
			}
		}

		private void SetLiteralProperties(int lp, int lc) {
			if (lp > 8)
				throw new InvalidParamException();
			if (lc > 8)
				throw new InvalidParamException();
			m_LiteralDecoder.Create(lp, lc);
		}

		private void SetPosBitsProperties(int pb) {
			if (pb > Base.kNumPosStatesBitsMax)
				throw new InvalidParamException();
			uint numPosStates = (uint)1 << pb;
			m_LenDecoder.Create(numPosStates);
			m_RepLenDecoder.Create(numPosStates);
			m_PosStateMask = numPosStates - 1;
		}

		private void Init(Stream inStream, Stream outStream) {
			m_RangeDecoder.Init(inStream);
			m_OutWindow.Init(outStream, _solid);

			uint i;
			for (i = 0; i < Base.kNumStates; i++) {
				for (uint j = 0; j <= m_PosStateMask; j++) {
					uint index = (i << Base.kNumPosStatesBitsMax) + j;
					m_IsMatchDecoders[index].Init();
					m_IsRep0LongDecoders[index].Init();
				}
				m_IsRepDecoders[i].Init();
				m_IsRepG0Decoders[i].Init();
				m_IsRepG1Decoders[i].Init();
				m_IsRepG2Decoders[i].Init();
			}

			m_LiteralDecoder.Init();
			for (i = 0; i < Base.kNumLenToPosStates; i++)
				m_PosSlotDecoder[i].Init();
			// m_PosSpecDecoder.Init();
			for (i = 0; i < Base.kNumFullDistances - Base.kEndPosModelIndex; i++)
				m_PosDecoders[i].Init();

			m_LenDecoder.Init();
			m_RepLenDecoder.Init();
			m_PosAlignDecoder.Init();
		}

		public bool Train(Stream stream) {
			_solid = true;
			return m_OutWindow.Train(stream);
		}

		private class LenDecoder {

			private readonly BitTreeDecoder[] m_LowCoder = new BitTreeDecoder[Base.kNumPosStatesMax];
			private readonly BitTreeDecoder[] m_MidCoder = new BitTreeDecoder[Base.kNumPosStatesMax];
			private BitDecoder m_Choice = new BitDecoder();
			private BitDecoder m_Choice2 = new BitDecoder();
			private BitTreeDecoder m_HighCoder = new BitTreeDecoder(Base.kNumHighLenBits);
			private uint m_NumPosStates;

			public void Create(uint numPosStates) {
				for (uint posState = m_NumPosStates; posState < numPosStates; posState++) {
					m_LowCoder[posState] = new BitTreeDecoder(Base.kNumLowLenBits);
					m_MidCoder[posState] = new BitTreeDecoder(Base.kNumMidLenBits);
				}
				m_NumPosStates = numPosStates;
			}

			public void Init() {
				m_Choice.Init();
				for (uint posState = 0; posState < m_NumPosStates; posState++) {
					m_LowCoder[posState].Init();
					m_MidCoder[posState].Init();
				}
				m_Choice2.Init();
				m_HighCoder.Init();
			}

			public uint Decode(RangeCoder.Decoder rangeDecoder, uint posState) {
				if (m_Choice.Decode(rangeDecoder) == 0)
					return m_LowCoder[posState].Decode(rangeDecoder);
				uint symbol = Base.kNumLowLenSymbols;
				if (m_Choice2.Decode(rangeDecoder) == 0)
					symbol += m_MidCoder[posState].Decode(rangeDecoder);
				else {
					symbol += Base.kNumMidLenSymbols;
					symbol += m_HighCoder.Decode(rangeDecoder);
				}
				return symbol;
			}

		}

		private class LiteralDecoder {

			private Decoder2[] m_Coders;
			private int m_NumPosBits;
			private int m_NumPrevBits;
			private uint m_PosMask;

			public void Create(int numPosBits, int numPrevBits) {
				if (m_Coders != null && m_NumPrevBits == numPrevBits &&
				    m_NumPosBits == numPosBits)
					return;
				m_NumPosBits = numPosBits;
				m_PosMask = ((uint)1 << numPosBits) - 1;
				m_NumPrevBits = numPrevBits;
				uint numStates = (uint)1 << (m_NumPrevBits + m_NumPosBits);
				m_Coders = new Decoder2[numStates];
				for (uint i = 0; i < numStates; i++)
					m_Coders[i].Create();
			}

			public void Init() {
				uint numStates = (uint)1 << (m_NumPrevBits + m_NumPosBits);
				for (uint i = 0; i < numStates; i++)
					m_Coders[i].Init();
			}

			private uint GetState(uint pos, byte prevByte) {
				return ((pos & m_PosMask) << m_NumPrevBits) + (uint)(prevByte >> (8 - m_NumPrevBits));
			}

			public byte DecodeNormal(RangeCoder.Decoder rangeDecoder, uint pos, byte prevByte) {
				return m_Coders[GetState(pos, prevByte)].DecodeNormal(rangeDecoder);
			}

			public byte DecodeWithMatchByte(RangeCoder.Decoder rangeDecoder, uint pos, byte prevByte, byte matchByte) {
				return m_Coders[GetState(pos, prevByte)].DecodeWithMatchByte(rangeDecoder, matchByte);
			}

			private struct Decoder2 {

				private BitDecoder[] m_Decoders;

				public void Create() {
					m_Decoders = new BitDecoder[0x300];
				}

				public void Init() {
					for (int i = 0; i < 0x300; i++) m_Decoders[i].Init();
				}

				public byte DecodeNormal(RangeCoder.Decoder rangeDecoder) {
					uint symbol = 1;
					do
						symbol = (symbol << 1) | m_Decoders[symbol].Decode(rangeDecoder); while (symbol < 0x100);
					return (byte)symbol;
				}

				public byte DecodeWithMatchByte(RangeCoder.Decoder rangeDecoder, byte matchByte) {
					uint symbol = 1;
					do {
						uint matchBit = (uint)(matchByte >> 7) & 1;
						matchByte <<= 1;
						uint bit = m_Decoders[((1 + matchBit) << 8) + symbol].Decode(rangeDecoder);
						symbol = (symbol << 1) | bit;
						if (matchBit != bit) {
							while (symbol < 0x100)
								symbol = (symbol << 1) | m_Decoders[symbol].Decode(rangeDecoder);
							break;
						}
					} while (symbol < 0x100);
					return (byte)symbol;
				}

			}

		};

		/*
        public override bool CanRead { get { return true; }}
        public override bool CanWrite { get { return true; }}
        public override bool CanSeek { get { return true; }}
        public override long Length { get { return 0; }}
        public override long Position
        {
            get { return 0;	}
            set { }
        }
        public override void Flush() { }
        public override int Read(byte[] buffer, int offset, int count) 
        {
            return 0;
        }
        public override void Write(byte[] buffer, int offset, int count)
        {
        }
        public override long Seek(long offset, System.IO.SeekOrigin origin)
        {
            return 0;
        }
        public override void SetLength(long value) {}
        */

	}
}


================================================
File: Confuser.Core/LZMA/Compress/LZMA/LzmaEncoder.cs
================================================
// LzmaEncoder.cs

using System;
using System.IO;
using SevenZip.Compression.LZ;
using SevenZip.Compression.RangeCoder;

namespace SevenZip.Compression.LZMA {
	internal class Encoder : ICoder, ISetCoderProperties, IWriteCoderProperties {

		private const UInt32 kIfinityPrice = 0xFFFFFFF;

		private const int kDefaultDictionaryLogSize = 22;
		private const UInt32 kNumFastBytesDefault = 0x20;

		private const UInt32 kNumLenSpecSymbols = Base.kNumLowLenSymbols + Base.kNumMidLenSymbols;

		private const UInt32 kNumOpts = 1 << 12;
		private const int kPropSize = 5;
		private static readonly Byte[] g_FastPos = new Byte[1 << 11];

		private static readonly string[] kMatchFinderIDs = {
			"BT2",
			"BT4"
		};

		private readonly UInt32[] _alignPrices = new UInt32[Base.kAlignTableSize];
		private readonly UInt32[] _distancesPrices = new UInt32[Base.kNumFullDistances << Base.kNumLenToPosStatesBits];

		private readonly BitEncoder[] _isMatch = new BitEncoder[Base.kNumStates << Base.kNumPosStatesBitsMax];
		private readonly BitEncoder[] _isRep = new BitEncoder[Base.kNumStates];
		private readonly BitEncoder[] _isRep0Long = new BitEncoder[Base.kNumStates << Base.kNumPosStatesBitsMax];
		private readonly BitEncoder[] _isRepG0 = new BitEncoder[Base.kNumStates];
		private readonly BitEncoder[] _isRepG1 = new BitEncoder[Base.kNumStates];
		private readonly BitEncoder[] _isRepG2 = new BitEncoder[Base.kNumStates];

		private readonly LenPriceTableEncoder _lenEncoder = new LenPriceTableEncoder();

		private readonly LiteralEncoder _literalEncoder = new LiteralEncoder();

		private readonly UInt32[] _matchDistances = new UInt32[Base.kMatchMaxLen * 2 + 2];
		private readonly Optimal[] _optimum = new Optimal[kNumOpts];
		private readonly BitEncoder[] _posEncoders = new BitEncoder[Base.kNumFullDistances - Base.kEndPosModelIndex];
		private readonly BitTreeEncoder[] _posSlotEncoder = new BitTreeEncoder[Base.kNumLenToPosStates];

		private readonly UInt32[] _posSlotPrices = new UInt32[1 << (Base.kNumPosSlotBits + Base.kNumLenToPosStatesBits)];
		private readonly RangeCoder.Encoder _rangeEncoder = new RangeCoder.Encoder();
		private readonly UInt32[] _repDistances = new UInt32[Base.kNumRepDistances];
		private readonly LenPriceTableEncoder _repMatchLenEncoder = new LenPriceTableEncoder();
		private readonly Byte[] properties = new Byte[kPropSize];
		private readonly UInt32[] repLens = new UInt32[Base.kNumRepDistances];
		private readonly UInt32[] reps = new UInt32[Base.kNumRepDistances];
		private readonly UInt32[] tempPrices = new UInt32[Base.kNumFullDistances];
		private UInt32 _additionalOffset;
		private UInt32 _alignPriceCount;

		private UInt32 _dictionarySize = (1 << kDefaultDictionaryLogSize);
		private UInt32 _dictionarySizePrev = 0xFFFFFFFF;
		private UInt32 _distTableSize = (kDefaultDictionaryLogSize * 2);
		private bool _finished;
		private Stream _inStream;
		private UInt32 _longestMatchLength;
		private bool _longestMatchWasFound;
		private IMatchFinder _matchFinder;

		private EMatchFinderType _matchFinderType = EMatchFinderType.BT4;
		private UInt32 _matchPriceCount;

		private bool _needReleaseMFStream;
		private UInt32 _numDistancePairs;
		private UInt32 _numFastBytes = kNumFastBytesDefault;
		private UInt32 _numFastBytesPrev = 0xFFFFFFFF;
		private int _numLiteralContextBits = 3;
		private int _numLiteralPosStateBits;
		private UInt32 _optimumCurrentIndex;
		private UInt32 _optimumEndIndex;
		private BitTreeEncoder _posAlignEncoder = new BitTreeEncoder(Base.kNumAlignBits);
		private int _posStateBits = 2;
		private UInt32 _posStateMask = (4 - 1);
		private Byte _previousByte;
		private Base.State _state = new Base.State();
		private uint _trainSize;
		private bool _writeEndMark;
		private Int64 nowPos64;

		static Encoder() {
			const Byte kFastSlots = 22;
			int c = 2;
			g_FastPos[0] = 0;
			g_FastPos[1] = 1;
			for (Byte slotFast = 2; slotFast < kFastSlots; slotFast++) {
				UInt32 k = ((UInt32)1 << ((slotFast >> 1) - 1));
				for (UInt32 j = 0; j < k; j++, c++)
					g_FastPos[c] = slotFast;
			}
		}

		public Encoder() {
			for (int i = 0; i < kNumOpts; i++)
				_optimum[i] = new Optimal();
			for (int i = 0; i < Base.kNumLenToPosStates; i++)
				_posSlotEncoder[i] = new BitTreeEncoder(Base.kNumPosSlotBits);
		}

		public void Code(Stream inStream, Stream outStream,
		                 Int64 inSize, Int64 outSize, ICodeProgress progress) {
			_needReleaseMFStream = false;
			try {
				SetStreams(inStream, outStream, inSize, outSize);
				while (true) {
					Int64 processedInSize;
					Int64 processedOutSize;
					bool finished;
					CodeOneBlock(out processedInSize, out processedOutSize, out finished);
					if (finished)
						return;
					if (progress != null) {
						progress.SetProgress(processedInSize, processedOutSize);
					}
				}
			}
			finally {
				ReleaseStreams();
			}
		}

		public void SetCoderProperties(CoderPropID[] propIDs, object[] properties) {
			for (UInt32 i = 0; i < properties.Length; i++) {
				object prop = properties[i];
				switch (propIDs[i]) {
					case CoderPropID.NumFastBytes: {
						if (!(prop is Int32))
							throw new InvalidParamException();
						var numFastBytes = (Int32)prop;
						if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)
							throw new InvalidParamException();
						_numFastBytes = (UInt32)numFastBytes;
						break;
					}
					case CoderPropID.Algorithm: {
						/*
                            if (!(prop is Int32))
                                throw new InvalidParamException();
                            Int32 maximize = (Int32)prop;
                            _fastMode = (maximize == 0);
                            _maxMode = (maximize >= 2);
                            */
						break;
					}
					case CoderPropID.MatchFinder: {
						if (!(prop is String))
							throw new InvalidParamException();
						EMatchFinderType matchFinderIndexPrev = _matchFinderType;
						int m = FindMatchFinder(((string)prop).ToUpper());
						if (m < 0)
							throw new InvalidParamException();
						_matchFinderType = (EMatchFinderType)m;
						if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType) {
							_dictionarySizePrev = 0xFFFFFFFF;
							_matchFinder = null;
						}
						break;
					}
					case CoderPropID.DictionarySize: {
						const int kDicLogSizeMaxCompress = 30;
						if (!(prop is Int32))
							throw new InvalidParamException();
						;
						var dictionarySize = (Int32)prop;
						if (dictionarySize < (UInt32)(1 << Base.kDicLogSizeMin) ||
						    dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))
							throw new InvalidParamException();
						_dictionarySize = (UInt32)dictionarySize;
						int dicLogSize;
						for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)
							if (dictionarySize <= ((UInt32)(1) << dicLogSize))
								break;
						_distTableSize = (UInt32)dicLogSize * 2;
						break;
					}
					case CoderPropID.PosStateBits: {
						if (!(prop is Int32))
							throw new InvalidParamException();
						var v = (Int32)prop;
						if (v < 0 || v > (UInt32)Base.kNumPosStatesBitsEncodingMax)
							throw new InvalidParamException();
						_posStateBits = v;
						_posStateMask = (((UInt32)1) << _posStateBits) - 1;
						break;
					}
					case CoderPropID.LitPosBits: {
						if (!(prop is Int32))
							throw new InvalidParamException();
						var v = (Int32)prop;
						if (v < 0 || v > Base.kNumLitPosStatesBitsEncodingMax)
							throw new InvalidParamException();
						_numLiteralPosStateBits = v;
						break;
					}
					case CoderPropID.LitContextBits: {
						if (!(prop is Int32))
							throw new InvalidParamException();
						var v = (Int32)prop;
						if (v < 0 || v > Base.kNumLitContextBitsMax)
							throw new InvalidParamException();
						;
						_numLiteralContextBits = v;
						break;
					}
					case CoderPropID.EndMarker: {
						if (!(prop is Boolean))
							throw new InvalidParamException();
						SetWriteEndMarkerMode((Boolean)prop);
						break;
					}
					default:
						throw new InvalidParamException();
				}
			}
		}

		public void WriteCoderProperties(Stream outStream) {
			properties[0] = (Byte)((_posStateBits * 5 + _numLiteralPosStateBits) * 9 + _numLiteralContextBits);
			for (int i = 0; i < 4; i++)
				properties[1 + i] = (Byte)((_dictionarySize >> (8 * i)) & 0xFF);
			outStream.Write(properties, 0, kPropSize);
		}

		private static UInt32 GetPosSlot(UInt32 pos) {
			if (pos < (1 << 11))
				return g_FastPos[pos];
			if (pos < (1 << 21))
				return (UInt32)(g_FastPos[pos >> 10] + 20);
			return (UInt32)(g_FastPos[pos >> 20] + 40);
		}

		private static UInt32 GetPosSlot2(UInt32 pos) {
			if (pos < (1 << 17))
				return (UInt32)(g_FastPos[pos >> 6] + 12);
			if (pos < (1 << 27))
				return (UInt32)(g_FastPos[pos >> 16] + 32);
			return (UInt32)(g_FastPos[pos >> 26] + 52);
		}

		private void BaseInit() {
			_state.Init();
			_previousByte = 0;
			for (UInt32 i = 0; i < Base.kNumRepDistances; i++)
				_repDistances[i] = 0;
		}

		private void Create() {
			if (_matchFinder == null) {
				var bt = new BinTree();
				int numHashBytes = 4;
				if (_matchFinderType == EMatchFinderType.BT2)
					numHashBytes = 2;
				bt.SetType(numHashBytes);
				_matchFinder = bt;
			}
			_literalEncoder.Create(_numLiteralPosStateBits, _numLiteralContextBits);

			if (_dictionarySize == _dictionarySizePrev && _numFastBytesPrev == _numFastBytes)
				return;
			_matchFinder.Create(_dictionarySize, kNumOpts, _numFastBytes, Base.kMatchMaxLen + 1);
			_dictionarySizePrev = _dictionarySize;
			_numFastBytesPrev = _numFastBytes;
		}

		private void SetWriteEndMarkerMode(bool writeEndMarker) {
			_writeEndMark = writeEndMarker;
		}

		private void Init() {
			BaseInit();
			_rangeEncoder.Init();

			uint i;
			for (i = 0; i < Base.kNumStates; i++) {
				for (uint j = 0; j <= _posStateMask; j++) {
					uint complexState = (i << Base.kNumPosStatesBitsMax) + j;
					_isMatch[complexState].Init();
					_isRep0Long[complexState].Init();
				}
				_isRep[i].Init();
				_isRepG0[i].Init();
				_isRepG1[i].Init();
				_isRepG2[i].Init();
			}
			_literalEncoder.Init();
			for (i = 0; i < Base.kNumLenToPosStates; i++)
				_posSlotEncoder[i].Init();
			for (i = 0; i < Base.kNumFullDistances - Base.kEndPosModelIndex; i++)
				_posEncoders[i].Init();

			_lenEncoder.Init((UInt32)1 << _posStateBits);
			_repMatchLenEncoder.Init((UInt32)1 << _posStateBits);

			_posAlignEncoder.Init();

			_longestMatchWasFound = false;
			_optimumEndIndex = 0;
			_optimumCurrentIndex = 0;
			_additionalOffset = 0;
		}

		private void ReadMatchDistances(out UInt32 lenRes, out UInt32 numDistancePairs) {
			lenRes = 0;
			numDistancePairs = _matchFinder.GetMatches(_matchDistances);
			if (numDistancePairs > 0) {
				lenRes = _matchDistances[numDistancePairs - 2];
				if (lenRes == _numFastBytes)
					lenRes += _matchFinder.GetMatchLen((int)lenRes - 1, _matchDistances[numDistancePairs - 1],
					                                   Base.kMatchMaxLen - lenRes);
			}
			_additionalOffset++;
		}


		private void MovePos(UInt32 num) {
			if (num > 0) {
				_matchFinder.Skip(num);
				_additionalOffset += num;
			}
		}

		private UInt32 GetRepLen1Price(Base.State state, UInt32 posState) {
			return _isRepG0[state.Index].GetPrice0() +
			       _isRep0Long[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0();
		}

		private UInt32 GetPureRepPrice(UInt32 repIndex, Base.State state, UInt32 posState) {
			UInt32 price;
			if (repIndex == 0) {
				price = _isRepG0[state.Index].GetPrice0();
				price += _isRep0Long[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();
			}
			else {
				price = _isRepG0[state.Index].GetPrice1();
				if (repIndex == 1)
					price += _isRepG1[state.Index].GetPrice0();
				else {
					price += _isRepG1[state.Index].GetPrice1();
					price += _isRepG2[state.Index].GetPrice(repIndex - 2);
				}
			}
			return price;
		}

		private UInt32 GetRepPrice(UInt32 repIndex, UInt32 len, Base.State state, UInt32 posState) {
			UInt32 price = _repMatchLenEncoder.GetPrice(len - Base.kMatchMinLen, posState);
			return price + GetPureRepPrice(repIndex, state, posState);
		}

		private UInt32 GetPosLenPrice(UInt32 pos, UInt32 len, UInt32 posState) {
			UInt32 price;
			UInt32 lenToPosState = Base.GetLenToPosState(len);
			if (pos < Base.kNumFullDistances)
				price = _distancesPrices[(lenToPosState * Base.kNumFullDistances) + pos];
			else
				price = _posSlotPrices[(lenToPosState << Base.kNumPosSlotBits) + GetPosSlot2(pos)] +
				        _alignPrices[pos & Base.kAlignMask];
			return price + _lenEncoder.GetPrice(len - Base.kMatchMinLen, posState);
		}

		private UInt32 Backward(out UInt32 backRes, UInt32 cur) {
			_optimumEndIndex = cur;
			UInt32 posMem = _optimum[cur].PosPrev;
			UInt32 backMem = _optimum[cur].BackPrev;
			do {
				if (_optimum[cur].Prev1IsChar) {
					_optimum[posMem].MakeAsChar();
					_optimum[posMem].PosPrev = posMem - 1;
					if (_optimum[cur].Prev2) {
						_optimum[posMem - 1].Prev1IsChar = false;
						_optimum[posMem - 1].PosPrev = _optimum[cur].PosPrev2;
						_optimum[posMem - 1].BackPrev = _optimum[cur].BackPrev2;
					}
				}
				UInt32 posPrev = posMem;
				UInt32 backCur = backMem;

				backMem = _optimum[posPrev].BackPrev;
				posMem = _optimum[posPrev].PosPrev;

				_optimum[posPrev].BackPrev = backCur;
				_optimum[posPrev].PosPrev = cur;
				cur = posPrev;
			} while (cur > 0);
			backRes = _optimum[0].BackPrev;
			_optimumCurrentIndex = _optimum[0].PosPrev;
			return _optimumCurrentIndex;
		}


		private UInt32 GetOptimum(UInt32 position, out UInt32 backRes) {
			if (_optimumEndIndex != _optimumCurrentIndex) {
				UInt32 lenRes = _optimum[_optimumCurrentIndex].PosPrev - _optimumCurrentIndex;
				backRes = _optimum[_optimumCurrentIndex].BackPrev;
				_optimumCurrentIndex = _optimum[_optimumCurrentIndex].PosPrev;
				return lenRes;
			}
			_optimumCurrentIndex = _optimumEndIndex = 0;

			UInt32 lenMain, numDistancePairs;
			if (!_longestMatchWasFound) {
				ReadMatchDistances(out lenMain, out numDistancePairs);
			}
			else {
				lenMain = _longestMatchLength;
				numDistancePairs = _numDistancePairs;
				_longestMatchWasFound = false;
			}

			UInt32 numAvailableBytes = _matchFinder.GetNumAvailableBytes() + 1;
			if (numAvailableBytes < 2) {
				backRes = 0xFFFFFFFF;
				return 1;
			}
			if (numAvailableBytes > Base.kMatchMaxLen)
				numAvailableBytes = Base.kMatchMaxLen;

			UInt32 repMaxIndex = 0;
			UInt32 i;
			for (i = 0; i < Base.kNumRepDistances; i++) {
				reps[i] = _repDistances[i];
				repLens[i] = _matchFinder.GetMatchLen(0 - 1, reps[i], Base.kMatchMaxLen);
				if (repLens[i] > repLens[repMaxIndex])
					repMaxIndex = i;
			}
			if (repLens[repMaxIndex] >= _numFastBytes) {
				backRes = repMaxIndex;
				UInt32 lenRes = repLens[repMaxIndex];
				MovePos(lenRes - 1);
				return lenRes;
			}

			if (lenMain >= _numFastBytes) {
				backRes = _matchDistances[numDistancePairs - 1] + Base.kNumRepDistances;
				MovePos(lenMain - 1);
				return lenMain;
			}

			Byte currentByte = _matchFinder.GetIndexByte(0 - 1);
			Byte matchByte = _matchFinder.GetIndexByte((Int32)(0 - _repDistances[0] - 1 - 1));

			if (lenMain < 2 && currentByte != matchByte && repLens[repMaxIndex] < 2) {
				backRes = 0xFFFFFFFF;
				return 1;
			}

			_optimum[0].State = _state;

			UInt32 posState = (position & _posStateMask);

			_optimum[1].Price = _isMatch[(_state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +
			                    _literalEncoder.GetSubCoder(position, _previousByte).GetPrice(!_state.IsCharState(), matchByte, currentByte);
			_optimum[1].MakeAsChar();

			UInt32 matchPrice = _isMatch[(_state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();
			UInt32 repMatchPrice = matchPrice + _isRep[_state.Index].GetPrice1();

			if (matchByte == currentByte) {
				UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(_state, posState);
				if (shortRepPrice < _optimum[1].Price) {
					_optimum[1].Price = shortRepPrice;
					_optimum[1].MakeAsShortRep();
				}
			}

			UInt32 lenEnd = ((lenMain >= repLens[repMaxIndex]) ? lenMain : repLens[repMaxIndex]);

			if (lenEnd < 2) {
				backRes = _optimum[1].BackPrev;
				return 1;
			}

			_optimum[1].PosPrev = 0;

			_optimum[0].Backs0 = reps[0];
			_optimum[0].Backs1 = reps[1];
			_optimum[0].Backs2 = reps[2];
			_optimum[0].Backs3 = reps[3];

			UInt32 len = lenEnd;
			do
				_optimum[len--].Price = kIfinityPrice; while (len >= 2);

			for (i = 0; i < Base.kNumRepDistances; i++) {
				UInt32 repLen = repLens[i];
				if (repLen < 2)
					continue;
				UInt32 price = repMatchPrice + GetPureRepPrice(i, _state, posState);
				do {
					UInt32 curAndLenPrice = price + _repMatchLenEncoder.GetPrice(repLen - 2, posState);
					Optimal optimum = _optimum[repLen];
					if (curAndLenPrice < optimum.Price) {
						optimum.Price = curAndLenPrice;
						optimum.PosPrev = 0;
						optimum.BackPrev = i;
						optimum.Prev1IsChar = false;
					}
				} while (--repLen >= 2);
			}

			UInt32 normalMatchPrice = matchPrice + _isRep[_state.Index].GetPrice0();

			len = ((repLens[0] >= 2) ? repLens[0] + 1 : 2);
			if (len <= lenMain) {
				UInt32 offs = 0;
				while (len > _matchDistances[offs])
					offs += 2;
				for (;; len++) {
					UInt32 distance = _matchDistances[offs + 1];
					UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(distance, len, posState);
					Optimal optimum = _optimum[len];
					if (curAndLenPrice < optimum.Price) {
						optimum.Price = curAndLenPrice;
						optimum.PosPrev = 0;
						optimum.BackPrev = distance + Base.kNumRepDistances;
						optimum.Prev1IsChar = false;
					}
					if (len == _matchDistances[offs]) {
						offs += 2;
						if (offs == numDistancePairs)
							break;
					}
				}
			}

			UInt32 cur = 0;

			while (true) {
				cur++;
				if (cur == lenEnd)
					return Backward(out backRes, cur);
				UInt32 newLen;
				ReadMatchDistances(out newLen, out numDistancePairs);
				if (newLen >= _numFastBytes) {
					_numDistancePairs = numDistancePairs;
					_longestMatchLength = newLen;
					_longestMatchWasFound = true;
					return Backward(out backRes, cur);
				}
				position++;
				UInt32 posPrev = _optimum[cur].PosPrev;
				Base.State state;
				if (_optimum[cur].Prev1IsChar) {
					posPrev--;
					if (_optimum[cur].Prev2) {
						state = _optimum[_optimum[cur].PosPrev2].State;
						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)
							state.UpdateRep();
						else
							state.UpdateMatch();
					}
					else
						state = _optimum[posPrev].State;
					state.UpdateChar();
				}
				else
					state = _optimum[posPrev].State;
				if (posPrev == cur - 1) {
					if (_optimum[cur].IsShortRep())
						state.UpdateShortRep();
					else
						state.UpdateChar();
				}
				else {
					UInt32 pos;
					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2) {
						posPrev = _optimum[cur].PosPrev2;
						pos = _optimum[cur].BackPrev2;
						state.UpdateRep();
					}
					else {
						pos = _optimum[cur].BackPrev;
						if (pos < Base.kNumRepDistances)
							state.UpdateRep();
						else
							state.UpdateMatch();
					}
					Optimal opt = _optimum[posPrev];
					if (pos < Base.kNumRepDistances) {
						if (pos == 0) {
							reps[0] = opt.Backs0;
							reps[1] = opt.Backs1;
							reps[2] = opt.Backs2;
							reps[3] = opt.Backs3;
						}
						else if (pos == 1) {
							reps[0] = opt.Backs1;
							reps[1] = opt.Backs0;
							reps[2] = opt.Backs2;
							reps[3] = opt.Backs3;
						}
						else if (pos == 2) {
							reps[0] = opt.Backs2;
							reps[1] = opt.Backs0;
							reps[2] = opt.Backs1;
							reps[3] = opt.Backs3;
						}
						else {
							reps[0] = opt.Backs3;
							reps[1] = opt.Backs0;
							reps[2] = opt.Backs1;
							reps[3] = opt.Backs2;
						}
					}
					else {
						reps[0] = (pos - Base.kNumRepDistances);
						reps[1] = opt.Backs0;
						reps[2] = opt.Backs1;
						reps[3] = opt.Backs2;
					}
				}
				_optimum[cur].State = state;
				_optimum[cur].Backs0 = reps[0];
				_optimum[cur].Backs1 = reps[1];
				_optimum[cur].Backs2 = reps[2];
				_optimum[cur].Backs3 = reps[3];
				UInt32 curPrice = _optimum[cur].Price;

				currentByte = _matchFinder.GetIndexByte(0 - 1);
				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));

				posState = (position & _posStateMask);

				UInt32 curAnd1Price = curPrice +
				                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +
				                      _literalEncoder.GetSubCoder(position, _matchFinder.GetIndexByte(0 - 2)).
				                                      GetPrice(!state.IsCharState(), matchByte, currentByte);

				Optimal nextOptimum = _optimum[cur + 1];

				bool nextIsChar = false;
				if (curAnd1Price < nextOptimum.Price) {
					nextOptimum.Price = curAnd1Price;
					nextOptimum.PosPrev = cur;
					nextOptimum.MakeAsChar();
					nextIsChar = true;
				}

				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();
				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();

				if (matchByte == currentByte &&
				    !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {
					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state, posState);
					if (shortRepPrice <= nextOptimum.Price) {
						nextOptimum.Price = shortRepPrice;
						nextOptimum.PosPrev = cur;
						nextOptimum.MakeAsShortRep();
						nextIsChar = true;
					}
				}

				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;
				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur, numAvailableBytesFull);
				numAvailableBytes = numAvailableBytesFull;

				if (numAvailableBytes < 2)
					continue;
				if (numAvailableBytes > _numFastBytes)
					numAvailableBytes = _numFastBytes;
				if (!nextIsChar && matchByte != currentByte) {
					// try Literal + rep0
					UInt32 t = Math.Min(numAvailableBytesFull - 1, _numFastBytes);
					UInt32 lenTest2 = _matchFinder.GetMatchLen(0, reps[0], t);
					if (lenTest2 >= 2) {
						Base.State state2 = state;
						state2.UpdateChar();
						UInt32 posStateNext = (position + 1) & _posStateMask;
						UInt32 nextRepMatchPrice = curAnd1Price +
						                           _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +
						                           _isRep[state2.Index].GetPrice1();
						{
							UInt32 offset = cur + 1 + lenTest2;
							while (lenEnd < offset)
								_optimum[++lenEnd].Price = kIfinityPrice;
							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(
								0, lenTest2, state2, posStateNext);
							Optimal optimum = _optimum[offset];
							if (curAndLenPrice < optimum.Price) {
								optimum.Price = curAndLenPrice;
								optimum.PosPrev = cur + 1;
								optimum.BackPrev = 0;
								optimum.Prev1IsChar = true;
								optimum.Prev2 = false;
							}
						}
					}
				}

				UInt32 startLen = 2; // speed optimization 

				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {
					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1, reps[repIndex], numAvailableBytes);
					if (lenTest < 2)
						continue;
					UInt32 lenTestTemp = lenTest;
					do {
						while (lenEnd < cur + lenTest)
							_optimum[++lenEnd].Price = kIfinityPrice;
						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex, lenTest, state, posState);
						Optimal optimum = _optimum[cur + lenTest];
						if (curAndLenPrice < optimum.Price) {
							optimum.Price = curAndLenPrice;
							optimum.PosPrev = cur;
							optimum.BackPrev = repIndex;
							optimum.Prev1IsChar = false;
						}
					} while (--lenTest >= 2);
					lenTest = lenTestTemp;

					if (repIndex == 0)
						startLen = lenTest + 1;

					// if (_maxMode)
					if (lenTest < numAvailableBytesFull) {
						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest, _numFastBytes);
						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest, reps[repIndex], t);
						if (lenTest2 >= 2) {
							Base.State state2 = state;
							state2.UpdateRep();
							UInt32 posStateNext = (position + lenTest) & _posStateMask;
							UInt32 curAndLenCharPrice =
								repMatchPrice + GetRepPrice(repIndex, lenTest, state, posState) +
								_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +
								_literalEncoder.GetSubCoder(position + lenTest,
								                            _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true,
								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)),
								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1));
							state2.UpdateChar();
							posStateNext = (position + lenTest + 1) & _posStateMask;
							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();
							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();

							// for(; lenTest2 >= 2; lenTest2--)
							{
								UInt32 offset = lenTest + 1 + lenTest2;
								while (lenEnd < cur + offset)
									_optimum[++lenEnd].Price = kIfinityPrice;
								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0, lenTest2, state2, posStateNext);
								Optimal optimum = _optimum[cur + offset];
								if (curAndLenPrice < optimum.Price) {
									optimum.Price = curAndLenPrice;
									optimum.PosPrev = cur + lenTest + 1;
									optimum.BackPrev = 0;
									optimum.Prev1IsChar = true;
									optimum.Prev2 = true;
									optimum.PosPrev2 = cur;
									optimum.BackPrev2 = repIndex;
								}
							}
						}
					}
				}

				if (newLen > numAvailableBytes) {
					newLen = numAvailableBytes;
					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;
					_matchDistances[numDistancePairs] = newLen;
					numDistancePairs += 2;
				}
				if (newLen >= startLen) {
					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();
					while (lenEnd < cur + newLen)
						_optimum[++lenEnd].Price = kIfinityPrice;

					UInt32 offs = 0;
					while (startLen > _matchDistances[offs])
						offs += 2;

					for (UInt32 lenTest = startLen;; lenTest++) {
						UInt32 curBack = _matchDistances[offs + 1];
						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack, lenTest, posState);
						Optimal optimum = _optimum[cur + lenTest];
						if (curAndLenPrice < optimum.Price) {
							optimum.Price = curAndLenPrice;
							optimum.PosPrev = cur;
							optimum.BackPrev = curBack + Base.kNumRepDistances;
							optimum.Prev1IsChar = false;
						}

						if (lenTest == _matchDistances[offs]) {
							if (lenTest < numAvailableBytesFull) {
								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest, _numFastBytes);
								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest, curBack, t);
								if (lenTest2 >= 2) {
									Base.State state2 = state;
									state2.UpdateMatch();
									UInt32 posStateNext = (position + lenTest) & _posStateMask;
									UInt32 curAndLenCharPrice = curAndLenPrice +
									                            _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +
									                            _literalEncoder.GetSubCoder(position + lenTest,
									                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).
									                                            GetPrice(true,
									                                                     _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1),
									                                                     _matchFinder.GetIndexByte((Int32)lenTest - 1));
									state2.UpdateChar();
									posStateNext = (position + lenTest + 1) & _posStateMask;
									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();
									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();

									UInt32 offset = lenTest + 1 + lenTest2;
									while (lenEnd < cur + offset)
										_optimum[++lenEnd].Price = kIfinityPrice;
									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0, lenTest2, state2, posStateNext);
									optimum = _optimum[cur + offset];
									if (curAndLenPrice < optimum.Price) {
										optimum.Price = curAndLenPrice;
										optimum.PosPrev = cur + lenTest + 1;
										optimum.BackPrev = 0;
										optimum.Prev1IsChar = true;
										optimum.Prev2 = true;
										optimum.PosPrev2 = cur;
										optimum.BackPrev2 = curBack + Base.kNumRepDistances;
									}
								}
							}
							offs += 2;
							if (offs == numDistancePairs)
								break;
						}
					}
				}
			}
		}

		private bool ChangePair(UInt32 smallDist, UInt32 bigDist) {
			const int kDif = 7;
			return (smallDist < ((UInt32)(1) << (32 - kDif)) && bigDist >= (smallDist << kDif));
		}

		private void WriteEndMarker(UInt32 posState) {
			if (!_writeEndMark)
				return;

			_isMatch[(_state.Index << Base.kNumPosStatesBitsMax) + posState].Encode(_rangeEncoder, 1);
			_isRep[_state.Index].Encode(_rangeEncoder, 0);
			_state.UpdateMatch();
			UInt32 len = Base.kMatchMinLen;
			_lenEncoder.Encode(_rangeEncoder, len - Base.kMatchMinLen, posState);
			UInt32 posSlot = (1 << Base.kNumPosSlotBits) - 1;
			UInt32 lenToPosState = Base.GetLenToPosState(len);
			_posSlotEncoder[lenToPosState].Encode(_rangeEncoder, posSlot);
			int footerBits = 30;
			UInt32 posReduced = (((UInt32)1) << footerBits) - 1;
			_rangeEncoder.EncodeDirectBits(posReduced >> Base.kNumAlignBits, footerBits - Base.kNumAlignBits);
			_posAlignEncoder.ReverseEncode(_rangeEncoder, posReduced & Base.kAlignMask);
		}

		private void Flush(UInt32 nowPos) {
			ReleaseMFStream();
			WriteEndMarker(nowPos & _posStateMask);
			_rangeEncoder.FlushData();
			_rangeEncoder.FlushStream();
		}

		public void CodeOneBlock(out Int64 inSize, out Int64 outSize, out bool finished) {
			inSize = 0;
			outSize = 0;
			finished = true;

			if (_inStream != null) {
				_matchFinder.SetStream(_inStream);
				_matchFinder.Init();
				_needReleaseMFStream = true;
				_inStream = null;
				if (_trainSize > 0)
					_matchFinder.Skip(_trainSize);
			}

			if (_finished)
				return;
			_finished = true;


			Int64 progressPosValuePrev = nowPos64;
			if (nowPos64 == 0) {
				if (_matchFinder.GetNumAvailableBytes() == 0) {
					Flush((UInt32)nowPos64);
					return;
				}
				UInt32 len, numDistancePairs; // it's not used
				ReadMatchDistances(out len, out numDistancePairs);
				UInt32 posState = (UInt32)(nowPos64) & _posStateMask;
				_isMatch[(_state.Index << Base.kNumPosStatesBitsMax) + posState].Encode(_rangeEncoder, 0);
				_state.UpdateChar();
				Byte curByte = _matchFinder.GetIndexByte((Int32)(0 - _additionalOffset));
				_literalEncoder.GetSubCoder((UInt32)(nowPos64), _previousByte).Encode(_rangeEncoder, curByte);
				_previousByte = curByte;
				_additionalOffset--;
				nowPos64++;
			}
			if (_matchFinder.GetNumAvailableBytes() == 0) {
				Flush((UInt32)nowPos64);
				return;
			}
			while (true) {
				UInt32 pos;
				UInt32 len = GetOptimum((UInt32)nowPos64, out pos);

				UInt32 posState = ((UInt32)nowPos64) & _posStateMask;
				UInt32 complexState = (_state.Index << Base.kNumPosStatesBitsMax) + posState;
				if (len == 1 && pos == 0xFFFFFFFF) {
					_isMatch[complexState].Encode(_rangeEncoder, 0);
					Byte curByte = _matchFinder.GetIndexByte((Int32)(0 - _additionalOffset));
					LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder((UInt32)nowPos64, _previousByte);
					if (!_state.IsCharState()) {
						Byte matchByte = _matchFinder.GetIndexByte((Int32)(0 - _repDistances[0] - 1 - _additionalOffset));
						subCoder.EncodeMatched(_rangeEncoder, matchByte, curByte);
					}
					else
						subCoder.Encode(_rangeEncoder, curByte);
					_previousByte = curByte;
					_state.UpdateChar();
				}
				else {
					_isMatch[complexState].Encode(_rangeEncoder, 1);
					if (pos < Base.kNumRepDistances) {
						_isRep[_state.Index].Encode(_rangeEncoder, 1);
						if (pos == 0) {
							_isRepG0[_state.Index].Encode(_rangeEncoder, 0);
							if (len == 1)
								_isRep0Long[complexState].Encode(_rangeEncoder, 0);
							else
								_isRep0Long[complexState].Encode(_rangeEncoder, 1);
						}
						else {
							_isRepG0[_state.Index].Encode(_rangeEncoder, 1);
							if (pos == 1)
								_isRepG1[_state.Index].Encode(_rangeEncoder, 0);
							else {
								_isRepG1[_state.Index].Encode(_rangeEncoder, 1);
								_isRepG2[_state.Index].Encode(_rangeEncoder, pos - 2);
							}
						}
						if (len == 1)
							_state.UpdateShortRep();
						else {
							_repMatchLenEncoder.Encode(_rangeEncoder, len - Base.kMatchMinLen, posState);
							_state.UpdateRep();
						}
						UInt32 distance = _repDistances[pos];
						if (pos != 0) {
							for (UInt32 i = pos; i >= 1; i--)
								_repDistances[i] = _repDistances[i - 1];
							_repDistances[0] = distance;
						}
					}
					else {
						_isRep[_state.Index].Encode(_rangeEncoder, 0);
						_state.UpdateMatch();
						_lenEncoder.Encode(_rangeEncoder, len - Base.kMatchMinLen, posState);
						pos -= Base.kNumRepDistances;
						UInt32 posSlot = GetPosSlot(pos);
						UInt32 lenToPosState = Base.GetLenToPosState(len);
						_posSlotEncoder[lenToPosState].Encode(_rangeEncoder, posSlot);

						if (posSlot >= Base.kStartPosModelIndex) {
							var footerBits = (int)((posSlot >> 1) - 1);
							UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);
							UInt32 posReduced = pos - baseVal;

							if (posSlot < Base.kEndPosModelIndex)
								BitTreeEncoder.ReverseEncode(_posEncoders,
								                             baseVal - posSlot - 1, _rangeEncoder, footerBits, posReduced);
							else {
								_rangeEncoder.EncodeDirectBits(posReduced >> Base.kNumAlignBits, footerBits - Base.kNumAlignBits);
								_posAlignEncoder.ReverseEncode(_rangeEncoder, posReduced & Base.kAlignMask);
								_alignPriceCount++;
							}
						}
						UInt32 distance = pos;
						for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)
							_repDistances[i] = _repDistances[i - 1];
						_repDistances[0] = distance;
						_matchPriceCount++;
					}
					_previousByte = _matchFinder.GetIndexByte((Int32)(len - 1 - _additionalOffset));
				}
				_additionalOffset -= len;
				nowPos64 += len;
				if (_additionalOffset == 0) {
					// if (!_fastMode)
					if (_matchPriceCount >= (1 << 7))
						FillDistancesPrices();
					if (_alignPriceCount >= Base.kAlignTableSize)
						FillAlignPrices();
					inSize = nowPos64;
					outSize = _rangeEncoder.GetProcessedSizeAdd();
					if (_matchFinder.GetNumAvailableBytes() == 0) {
						Flush((UInt32)nowPos64);
						return;
					}

					if (nowPos64 - progressPosValuePrev >= (1 << 12)) {
						_finished = false;
						finished = false;
						return;
					}
				}
			}
		}

		private void ReleaseMFStream() {
			if (_matchFinder != null && _needReleaseMFStream) {
				_matchFinder.ReleaseStream();
				_needReleaseMFStream = false;
			}
		}

		private void SetOutStream(Stream outStream) {
			_rangeEncoder.SetStream(outStream);
		}

		private void ReleaseOutStream() {
			_rangeEncoder.ReleaseStream();
		}

		private void ReleaseStreams() {
			ReleaseMFStream();
			ReleaseOutStream();
		}

		private void SetStreams(Stream inStream, Stream outStream,
		                        Int64 inSize, Int64 outSize) {
			_inStream = inStream;
			_finished = false;
			Create();
			SetOutStream(outStream);
			Init();

			// if (!_fastMode)
			                        {
				                        FillDistancesPrices();
				                        FillAlignPrices();
			                        }

			_lenEncoder.SetTableSize(_numFastBytes + 1 - Base.kMatchMinLen);
			_lenEncoder.UpdateTables((UInt32)1 << _posStateBits);
			_repMatchLenEncoder.SetTableSize(_numFastBytes + 1 - Base.kMatchMinLen);
			_repMatchLenEncoder.UpdateTables((UInt32)1 << _posStateBits);

			nowPos64 = 0;
		}


		private void FillDistancesPrices() {
			for (UInt32 i = Base.kStartPosModelIndex; i < Base.kNumFullDistances; i++) {
				UInt32 posSlot = GetPosSlot(i);
				var footerBits = (int)((posSlot >> 1) - 1);
				UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);
				tempPrices[i] = BitTreeEncoder.ReverseGetPrice(_posEncoders,
				                                               baseVal - posSlot - 1, footerBits, i - baseVal);
			}

			for (UInt32 lenToPosState = 0; lenToPosState < Base.kNumLenToPosStates; lenToPosState++) {
				UInt32 posSlot;
				BitTreeEncoder encoder = _posSlotEncoder[lenToPosState];

				UInt32 st = (lenToPosState << Base.kNumPosSlotBits);
				for (posSlot = 0; posSlot < _distTableSize; posSlot++)
					_posSlotPrices[st + posSlot] = encoder.GetPrice(posSlot);
				for (posSlot = Base.kEndPosModelIndex; posSlot < _distTableSize; posSlot++)
					_posSlotPrices[st + posSlot] += ((((posSlot >> 1) - 1) - Base.kNumAlignBits) << BitEncoder.kNumBitPriceShiftBits);

				UInt32 st2 = lenToPosState * Base.kNumFullDistances;
				UInt32 i;
				for (i = 0; i < Base.kStartPosModelIndex; i++)
					_distancesPrices[st2 + i] = _posSlotPrices[st + i];
				for (; i < Base.kNumFullDistances; i++)
					_distancesPrices[st2 + i] = _posSlotPrices[st + GetPosSlot(i)] + tempPrices[i];
			}
			_matchPriceCount = 0;
		}

		private void FillAlignPrices() {
			for (UInt32 i = 0; i < Base.kAlignTableSize; i++)
				_alignPrices[i] = _posAlignEncoder.ReverseGetPrice(i);
			_alignPriceCount = 0;
		}


		private static int FindMatchFinder(string s) {
			for (int m = 0; m < kMatchFinderIDs.Length; m++)
				if (s == kMatchFinderIDs[m])
					return m;
			return -1;
		}

		public void SetTrainSize(uint trainSize) {
			_trainSize = trainSize;
		}

		private enum EMatchFinderType {

			BT2,
			BT4,

		};

		private class LenEncoder {

			private readonly BitTreeEncoder[] _lowCoder = new BitTreeEncoder[Base.kNumPosStatesEncodingMax];
			private readonly BitTreeEncoder[] _midCoder = new BitTreeEncoder[Base.kNumPosStatesEncodingMax];
			private BitEncoder _choice = new BitEncoder();
			private BitEncoder _choice2 = new BitEncoder();
			private BitTreeEncoder _highCoder = new BitTreeEncoder(Base.kNumHighLenBits);

			public LenEncoder() {
				for (UInt32 posState = 0; posState < Base.kNumPosStatesEncodingMax; posState++) {
					_lowCoder[posState] = new BitTreeEncoder(Base.kNumLowLenBits);
					_midCoder[posState] = new BitTreeEncoder(Base.kNumMidLenBits);
				}
			}

			public void Init(UInt32 numPosStates) {
				_choice.Init();
				_choice2.Init();
				for (UInt32 posState = 0; posState < numPosStates; posState++) {
					_lowCoder[posState].Init();
					_midCoder[posState].Init();
				}
				_highCoder.Init();
			}

			public void Encode(RangeCoder.Encoder rangeEncoder, UInt32 symbol, UInt32 posState) {
				if (symbol < Base.kNumLowLenSymbols) {
					_choice.Encode(rangeEncoder, 0);
					_lowCoder[posState].Encode(rangeEncoder, symbol);
				}
				else {
					symbol -= Base.kNumLowLenSymbols;
					_choice.Encode(rangeEncoder, 1);
					if (symbol < Base.kNumMidLenSymbols) {
						_choice2.Encode(rangeEncoder, 0);
						_midCoder[posState].Encode(rangeEncoder, symbol);
					}
					else {
						_choice2.Encode(rangeEncoder, 1);
						_highCoder.Encode(rangeEncoder, symbol - Base.kNumMidLenSymbols);
					}
				}
			}

			public void SetPrices(UInt32 posState, UInt32 numSymbols, UInt32[] prices, UInt32 st) {
				UInt32 a0 = _choice.GetPrice0();
				UInt32 a1 = _choice.GetPrice1();
				UInt32 b0 = a1 + _choice2.GetPrice0();
				UInt32 b1 = a1 + _choice2.GetPrice1();
				UInt32 i = 0;
				for (i = 0; i < Base.kNumLowLenSymbols; i++) {
					if (i >= numSymbols)
						return;
					prices[st + i] = a0 + _lowCoder[posState].GetPrice(i);
				}
				for (; i < Base.kNumLowLenSymbols + Base.kNumMidLenSymbols; i++) {
					if (i >= numSymbols)
						return;
					prices[st + i] = b0 + _midCoder[posState].GetPrice(i - Base.kNumLowLenSymbols);
				}
				for (; i < numSymbols; i++)
					prices[st + i] = b1 + _highCoder.GetPrice(i - Base.kNumLowLenSymbols - Base.kNumMidLenSymbols);
			}

		};

		private class LenPriceTableEncoder : LenEncoder {

			private readonly UInt32[] _counters = new UInt32[Base.kNumPosStatesEncodingMax];
			private readonly UInt32[] _prices = new UInt32[Base.kNumLenSymbols << Base.kNumPosStatesBitsEncodingMax];
			private UInt32 _tableSize;

			public void SetTableSize(UInt32 tableSize) {
				_tableSize = tableSize;
			}

			public UInt32 GetPrice(UInt32 symbol, UInt32 posState) {
				return _prices[posState * Base.kNumLenSymbols + symbol];
			}

			private void UpdateTable(UInt32 posState) {
				SetPrices(posState, _tableSize, _prices, posState * Base.kNumLenSymbols);
				_counters[posState] = _tableSize;
			}

			public void UpdateTables(UInt32 numPosStates) {
				for (UInt32 posState = 0; posState < numPosStates; posState++)
					UpdateTable(posState);
			}

			public new void Encode(RangeCoder.Encoder rangeEncoder, UInt32 symbol, UInt32 posState) {
				base.Encode(rangeEncoder, symbol, posState);
				if (--_counters[posState] == 0)
					UpdateTable(posState);
			}

		}

		private class LiteralEncoder {

			private Encoder2[] m_Coders;
			private int m_NumPosBits;
			private int m_NumPrevBits;
			private uint m_PosMask;

			public void Create(int numPosBits, int numPrevBits) {
				if (m_Coders != null && m_NumPrevBits == numPrevBits && m_NumPosBits == numPosBits)
					return;
				m_NumPosBits = numPosBits;
				m_PosMask = ((uint)1 << numPosBits) - 1;
				m_NumPrevBits = numPrevBits;
				uint numStates = (uint)1 << (m_NumPrevBits + m_NumPosBits);
				m_Coders = new Encoder2[numStates];
				for (uint i = 0; i < numStates; i++)
					m_Coders[i].Create();
			}

			public void Init() {
				uint numStates = (uint)1 << (m_NumPrevBits + m_NumPosBits);
				for (uint i = 0; i < numStates; i++)
					m_Coders[i].Init();
			}

			public Encoder2 GetSubCoder(UInt32 pos, Byte prevByte) {
				return m_Coders[((pos & m_PosMask) << m_NumPrevBits) + (uint)(prevByte >> (8 - m_NumPrevBits))];
			}

			public struct Encoder2 {

				private BitEncoder[] m_Encoders;

				public void Create() {
					m_Encoders = new BitEncoder[0x300];
				}

				public void Init() {
					for (int i = 0; i < 0x300; i++) m_Encoders[i].Init();
				}

				public void Encode(RangeCoder.Encoder rangeEncoder, byte symbol) {
					uint context = 1;
					for (int i = 7; i >= 0; i--) {
						var bit = (uint)((symbol >> i) & 1);
						m_Encoders[context].Encode(rangeEncoder, bit);
						context = (context << 1) | bit;
					}
				}

				public void EncodeMatched(RangeCoder.Encoder rangeEncoder, byte matchByte, byte symbol) {
					uint context = 1;
					bool same = true;
					for (int i = 7; i >= 0; i--) {
						var bit = (uint)((symbol >> i) & 1);
						uint state = context;
						if (same) {
							var matchBit = (uint)((matchByte >> i) & 1);
							state += ((1 + matchBit) << 8);
							same = (matchBit == bit);
						}
						m_Encoders[state].Encode(rangeEncoder, bit);
						context = (context << 1) | bit;
					}
				}

				public uint GetPrice(bool matchMode, byte matchByte, byte symbol) {
					uint price = 0;
					uint context = 1;
					int i = 7;
					if (matchMode) {
						for (; i >= 0; i--) {
							uint matchBit = (uint)(matchByte >> i) & 1;
							uint bit = (uint)(symbol >> i) & 1;
							price += m_Encoders[((1 + matchBit) << 8) + context].GetPrice(bit);
							context = (context << 1) | bit;
							if (matchBit != bit) {
								i--;
								break;
							}
						}
					}
					for (; i >= 0; i--) {
						uint bit = (uint)(symbol >> i) & 1;
						price += m_Encoders[context].GetPrice(bit);
						context = (context << 1) | bit;
					}
					return price;
				}

			}

		}

		private class Optimal {

			public UInt32 BackPrev;
			public UInt32 BackPrev2;

			public UInt32 Backs0;
			public UInt32 Backs1;
			public UInt32 Backs2;
			public UInt32 Backs3;
			public UInt32 PosPrev;
			public UInt32 PosPrev2;
			public bool Prev1IsChar;
			public bool Prev2;
			public UInt32 Price;
			public Base.State State;

			public void MakeAsChar() {
				BackPrev = 0xFFFFFFFF;
				Prev1IsChar = false;
			}

			public void MakeAsShortRep() {
				BackPrev = 0;
				;
				Prev1IsChar = false;
			}

			public bool IsShortRep() {
				return (BackPrev == 0);
			}

		};

	}
}


================================================
File: Confuser.Core/LZMA/Compress/RangeCoder/RangeCoder.cs
================================================
using System;
using System.IO;

namespace SevenZip.Compression.RangeCoder {
	internal class Encoder {

		public const uint kTopValue = (1 << 24);

		public UInt64 Low;
		public uint Range;

		private long StartPosition;
		private Stream Stream;
		private byte _cache;
		private uint _cacheSize;

		public void SetStream(Stream stream) {
			Stream = stream;
		}

		public void ReleaseStream() {
			Stream = null;
		}

		public void Init() {
			StartPosition = Stream.Position;

			Low = 0;
			Range = 0xFFFFFFFF;
			_cacheSize = 1;
			_cache = 0;
		}

		public void FlushData() {
			for (int i = 0; i < 5; i++)
				ShiftLow();
		}

		public void FlushStream() {
			Stream.Flush();
		}

		public void CloseStream() {
			Stream.Close();
		}

		public void Encode(uint start, uint size, uint total) {
			Low += start * (Range /= total);
			Range *= size;
			while (Range < kTopValue) {
				Range <<= 8;
				ShiftLow();
			}
		}

		public void ShiftLow() {
			if ((uint)Low < 0xFF000000 || (uint)(Low >> 32) == 1) {
				byte temp = _cache;
				do {
					Stream.WriteByte((byte)(temp + (Low >> 32)));
					temp = 0xFF;
				} while (--_cacheSize != 0);
				_cache = (byte)(((uint)Low) >> 24);
			}
			_cacheSize++;
			Low = ((uint)Low) << 8;
		}

		public void EncodeDirectBits(uint v, int numTotalBits) {
			for (int i = numTotalBits - 1; i >= 0; i--) {
				Range >>= 1;
				if (((v >> i) & 1) == 1)
					Low += Range;
				if (Range < kTopValue) {
					Range <<= 8;
					ShiftLow();
				}
			}
		}

		public void EncodeBit(uint size0, int numTotalBits, uint symbol) {
			uint newBound = (Range >> numTotalBits) * size0;
			if (symbol == 0)
				Range = newBound;
			else {
				Low += newBound;
				Range -= newBound;
			}
			while (Range < kTopValue) {
				Range <<= 8;
				ShiftLow();
			}
		}

		public long GetProcessedSizeAdd() {
			return _cacheSize +
			       Stream.Position - StartPosition + 4;
			// (long)Stream.GetProcessedSize();
		}

	}

	internal class Decoder {

		public const uint kTopValue = (1 << 24);
		public uint Code;
		public uint Range;
		// public Buffer.InBuffer Stream = new Buffer.InBuffer(1 << 16);
		public Stream Stream;

		public void Init(Stream stream) {
			// Stream.Init(stream);
			Stream = stream;

			Code = 0;
			Range = 0xFFFFFFFF;
			for (int i = 0; i < 5; i++)
				Code = (Code << 8) | (byte)Stream.ReadByte();
		}

		public void ReleaseStream() {
			// Stream.ReleaseStream();
			Stream = null;
		}

		public void CloseStream() {
			Stream.Close();
		}

		public void Normalize() {
			while (Range < kTopValue) {
				Code = (Code << 8) | (byte)Stream.ReadByte();
				Range <<= 8;
			}
		}

		public void Normalize2() {
			if (Range < kTopValue) {
				Code = (Code << 8) | (byte)Stream.ReadByte();
				Range <<= 8;
			}
		}

		public uint GetThreshold(uint total) {
			return Code / (Range /= total);
		}

		public void Decode(uint start, uint size, uint total) {
			Code -= start * Range;
			Range *= size;
			Normalize();
		}

		public uint DecodeDirectBits(int numTotalBits) {
			uint range = Range;
			uint code = Code;
			uint result = 0;
			for (int i = numTotalBits; i > 0; i--) {
				range >>= 1;
				/*
                result <<= 1;
                if (code >= range)
                {
                    code -= range;
                    result |= 1;
                }
                */
				uint t = (code - range) >> 31;
				code -= range & (t - 1);
				result = (result << 1) | (1 - t);

				if (range < kTopValue) {
					code = (code << 8) | (byte)Stream.ReadByte();
					range <<= 8;
				}
			}
			Range = range;
			Code = code;
			return result;
		}

		public uint DecodeBit(uint size0, int numTotalBits) {
			uint newBound = (Range >> numTotalBits) * size0;
			uint symbol;
			if (Code < newBound) {
				symbol = 0;
				Range = newBound;
			}
			else {
				symbol = 1;
				Code -= newBound;
				Range -= newBound;
			}
			Normalize();
			return symbol;
		}

		// ulong GetProcessedSize() {return Stream.GetProcessedSize(); }
	}
}


================================================
File: Confuser.Core/LZMA/Compress/RangeCoder/RangeCoderBit.cs
================================================
using System;

namespace SevenZip.Compression.RangeCoder {
	internal struct BitEncoder {

		public const int kNumBitModelTotalBits = 11;
		public const uint kBitModelTotal = (1 << kNumBitModelTotalBits);
		private const int kNumMoveBits = 5;
		private const int kNumMoveReducingBits = 2;
		public const int kNumBitPriceShiftBits = 6;
		private static readonly UInt32[] ProbPrices = new UInt32[kBitModelTotal >> kNumMoveReducingBits];

		private uint Prob;

		static BitEncoder() {
			const int kNumBits = (kNumBitModelTotalBits - kNumMoveReducingBits);
			for (int i = kNumBits - 1; i >= 0; i--) {
				UInt32 start = (UInt32)1 << (kNumBits - i - 1);
				UInt32 end = (UInt32)1 << (kNumBits - i);
				for (UInt32 j = start; j < end; j++)
					ProbPrices[j] = ((UInt32)i << kNumBitPriceShiftBits) +
					                (((end - j) << kNumBitPriceShiftBits) >> (kNumBits - i - 1));
			}
		}

		public void Init() {
			Prob = kBitModelTotal >> 1;
		}

		public void UpdateModel(uint symbol) {
			if (symbol == 0)
				Prob += (kBitModelTotal - Prob) >> kNumMoveBits;
			else
				Prob -= (Prob) >> kNumMoveBits;
		}

		public void Encode(Encoder encoder, uint symbol) {
			// encoder.EncodeBit(Prob, kNumBitModelTotalBits, symbol);
			// UpdateModel(symbol);
			uint newBound = (encoder.Range >> kNumBitModelTotalBits) * Prob;
			if (symbol == 0) {
				encoder.Range = newBound;
				Prob += (kBitModelTotal - Prob) >> kNumMoveBits;
			}
			else {
				encoder.Low += newBound;
				encoder.Range -= newBound;
				Prob -= (Prob) >> kNumMoveBits;
			}
			if (encoder.Range < Encoder.kTopValue) {
				encoder.Range <<= 8;
				encoder.ShiftLow();
			}
		}

		public uint GetPrice(uint symbol) {
			return ProbPrices[(((Prob - symbol) ^ ((-(int)symbol))) & (kBitModelTotal - 1)) >> kNumMoveReducingBits];
		}

		public uint GetPrice0() {
			return ProbPrices[Prob >> kNumMoveReducingBits];
		}

		public uint GetPrice1() {
			return ProbPrices[(kBitModelTotal - Prob) >> kNumMoveReducingBits];
		}

	}

	internal struct BitDecoder {

		public const int kNumBitModelTotalBits = 11;
		public const uint kBitModelTotal = (1 << kNumBitModelTotalBits);
		private const int kNumMoveBits = 5;

		private uint Prob;

		public void UpdateModel(int numMoveBits, uint symbol) {
			if (symbol == 0)
				Prob += (kBitModelTotal - Prob) >> numMoveBits;
			else
				Prob -= (Prob) >> numMoveBits;
		}

		public void Init() {
			Prob = kBitModelTotal >> 1;
		}

		public uint Decode(Decoder rangeDecoder) {
			uint newBound = (rangeDecoder.Range >> kNumBitModelTotalBits) * Prob;
			if (rangeDecoder.Code < newBound) {
				rangeDecoder.Range = newBound;
				Prob += (kBitModelTotal - Prob) >> kNumMoveBits;
				if (rangeDecoder.Range < Decoder.kTopValue) {
					rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();
					rangeDecoder.Range <<= 8;
				}
				return 0;
			}
			rangeDecoder.Range -= newBound;
			rangeDecoder.Code -= newBound;
			Prob -= (Prob) >> kNumMoveBits;
			if (rangeDecoder.Range < Decoder.kTopValue) {
				rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();
				rangeDecoder.Range <<= 8;
			}
			return 1;
		}

	}
}


================================================
File: Confuser.Core/LZMA/Compress/RangeCoder/RangeCoderBitTree.cs
================================================
using System;

namespace SevenZip.Compression.RangeCoder {
	internal struct BitTreeEncoder {

		private readonly BitEncoder[] Models;
		private readonly int NumBitLevels;

		public BitTreeEncoder(int numBitLevels) {
			NumBitLevels = numBitLevels;
			Models = new BitEncoder[1 << numBitLevels];
		}

		public void Init() {
			for (uint i = 1; i < (1 << NumBitLevels); i++)
				Models[i].Init();
		}

		public void Encode(Encoder rangeEncoder, UInt32 symbol) {
			UInt32 m = 1;
			for (int bitIndex = NumBitLevels; bitIndex > 0;) {
				bitIndex--;
				UInt32 bit = (symbol >> bitIndex) & 1;
				Models[m].Encode(rangeEncoder, bit);
				m = (m << 1) | bit;
			}
		}

		public void ReverseEncode(Encoder rangeEncoder, UInt32 symbol) {
			UInt32 m = 1;
			for (UInt32 i = 0; i < NumBitLevels; i++) {
				UInt32 bit = symbol & 1;
				Models[m].Encode(rangeEncoder, bit);
				m = (m << 1) | bit;
				symbol >>= 1;
			}
		}

		public UInt32 GetPrice(UInt32 symbol) {
			UInt32 price = 0;
			UInt32 m = 1;
			for (int bitIndex = NumBitLevels; bitIndex > 0;) {
				bitIndex--;
				UInt32 bit = (symbol >> bitIndex) & 1;
				price += Models[m].GetPrice(bit);
				m = (m << 1) + bit;
			}
			return price;
		}

		public UInt32 ReverseGetPrice(UInt32 symbol) {
			UInt32 price = 0;
			UInt32 m = 1;
			for (int i = NumBitLevels; i > 0; i--) {
				UInt32 bit = symbol & 1;
				symbol >>= 1;
				price += Models[m].GetPrice(bit);
				m = (m << 1) | bit;
			}
			return price;
		}

		public static UInt32 ReverseGetPrice(BitEncoder[] Models, UInt32 startIndex,
		                                     int NumBitLevels, UInt32 symbol) {
			UInt32 price = 0;
			UInt32 m = 1;
			for (int i = NumBitLevels; i > 0; i--) {
				UInt32 bit = symbol & 1;
				symbol >>= 1;
				price += Models[startIndex + m].GetPrice(bit);
				m = (m << 1) | bit;
			}
			return price;
		}

		public static void ReverseEncode(BitEncoder[] Models, UInt32 startIndex,
		                                 Encoder rangeEncoder, int NumBitLevels, UInt32 symbol) {
			UInt32 m = 1;
			for (int i = 0; i < NumBitLevels; i++) {
				UInt32 bit = symbol & 1;
				Models[startIndex + m].Encode(rangeEncoder, bit);
				m = (m << 1) | bit;
				symbol >>= 1;
			}
		}

	}

	internal struct BitTreeDecoder {

		private readonly BitDecoder[] Models;
		private readonly int NumBitLevels;

		public BitTreeDecoder(int numBitLevels) {
			NumBitLevels = numBitLevels;
			Models = new BitDecoder[1 << numBitLevels];
		}

		public void Init() {
			for (uint i = 1; i < (1 << NumBitLevels); i++)
				Models[i].Init();
		}

		public uint Decode(Decoder rangeDecoder) {
			uint m = 1;
			for (int bitIndex = NumBitLevels; bitIndex > 0; bitIndex--)
				m = (m << 1) + Models[m].Decode(rangeDecoder);
			return m - ((uint)1 << NumBitLevels);
		}

		public uint ReverseDecode(Decoder rangeDecoder) {
			uint m = 1;
			uint symbol = 0;
			for (int bitIndex = 0; bitIndex < NumBitLevels; bitIndex++) {
				uint bit = Models[m].Decode(rangeDecoder);
				m <<= 1;
				m += bit;
				symbol |= (bit << bitIndex);
			}
			return symbol;
		}

		public static uint ReverseDecode(BitDecoder[] Models, UInt32 startIndex,
		                                 Decoder rangeDecoder, int NumBitLevels) {
			uint m = 1;
			uint symbol = 0;
			for (int bitIndex = 0; bitIndex < NumBitLevels; bitIndex++) {
				uint bit = Models[startIndex + m].Decode(rangeDecoder);
				m <<= 1;
				m += bit;
				symbol |= (bit << bitIndex);
			}
			return symbol;
		}

	}
}


================================================
File: Confuser.Core/Project/ConfuserPrj.xsd
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>

<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
           targetNamespace="http://confuser.codeplex.com"
           xmlns="http://confuser.codeplex.com"
           attributeFormDefault="unqualified"
           elementFormDefault="qualified">

  <xs:simpleType name="action">
    <xs:restriction base="xs:string">
      <xs:enumeration value="add" />
      <xs:enumeration value="remove" />
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="preset">
    <xs:restriction base="xs:string">
      <xs:enumeration value="none" />
      <xs:enumeration value="minimum" />
      <xs:enumeration value="normal" />
      <xs:enumeration value="aggressive" />
      <xs:enumeration value="maximum" />
    </xs:restriction>
  </xs:simpleType>

  <xs:complexType name="argument">
    <xs:attribute name="name" type="xs:string" use="required" />
    <xs:attribute name="value" type="xs:string" use="required" />
  </xs:complexType>

  <xs:complexType name="objSettings">
    <xs:sequence>
      <xs:element name="argument" type="argument" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="id" type="xs:string" use="required" />
    <xs:attribute name="action" type="action" default="add" />
  </xs:complexType>

  <xs:complexType name="rule">
    <xs:sequence>
      <xs:element name="protection" type="objSettings" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="preset" type="preset" default="none" />

    <xs:attribute name="inherit" type="xs:boolean" default="true" />
    <xs:attribute name="pattern" type="xs:string" use="required" />
  </xs:complexType>

  <xs:complexType name="module">
    <xs:sequence>
      <xs:element name="rule" type="rule" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="path" type="xs:string" use="required" />
    <xs:attribute name="external" type="xs:boolean" default="false" />
    <xs:attribute name="snKey" type="xs:string" use="optional" />
    <xs:attribute name="snKeyPass" type="xs:string" use="optional" />
  </xs:complexType>


  <xs:element name="project">
    <xs:complexType>
      <xs:sequence>
        <xs:element name="rule" type="rule" minOccurs="0" maxOccurs="unbounded" />
        <xs:element name="packer" type="objSettings" minOccurs="0" maxOccurs="1" />
        <xs:element name="module" type="module" minOccurs="0" maxOccurs="unbounded" />
        <xs:element name="probePath" type="xs:string" minOccurs="0" maxOccurs="unbounded" />
        <xs:element name="plugin" type="xs:string" minOccurs="0" maxOccurs="unbounded" />
      </xs:sequence>
      <xs:attribute name="outputDir" type="xs:string" use="required" />
      <xs:attribute name="baseDir" type="xs:string" use="required" />
      <xs:attribute name="seed" type="xs:string" use="optional" />
      <xs:attribute name="debug" type="xs:boolean" default="false" />
    </xs:complexType>
  </xs:element>
</xs:schema>


================================================
File: Confuser.Core/Project/ConfuserProject.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Xml;
using System.Xml.Schema;
using dnlib.DotNet;

namespace Confuser.Core.Project {
	/// <summary>
	///     A module description in a Confuser project.
	/// </summary>
	public class ProjectModule {
		/// <summary>
		///     Initializes a new instance of the <see cref="ProjectModule" /> class.
		/// </summary>
		public ProjectModule() {
			Rules = new List<Rule>();
		}

		/// <summary>
		///     Gets the path to the module.
		/// </summary>
		public string Path { get; set; }

		/// <summary>
		///     Indicates whether this module is external and should not be obfuscated.
		/// </summary>
		public bool IsExternal { get; set; }

		/// <summary>
		///     Gets or sets the path to the strong name private key for signing.
		/// </summary>
		/// <value>The path to the strong name private key, or null if not necessary.</value>
		public string SNKeyPath { get; set; }

		/// <summary>
		///     Gets or sets the password of the strong name private key.
		/// </summary>
		/// <value>The password of the strong name private key, or null if not necessary.</value>
		public string SNKeyPassword { get; set; }

		/// <summary>
		///     Gets a list of protection rules applies to the module.
		/// </summary>
		/// <value>A list of protection rules.</value>
		public IList<Rule> Rules { get; private set; }

		/// <summary>
		///     Resolves the module from the path.
		/// </summary>
		/// <param name="basePath">
		///     The base path for the relative module path,
		///     or null if the module path is absolute or relative to current directory.
		/// </param>
		/// <param name="context">The resolved module's context.</param>
		/// <returns>The resolved module.</returns>
		public ModuleDefMD Resolve(string basePath, ModuleContext context = null) {
			if (basePath == null)
				return ModuleDefMD.Load(Path, context);
			return ModuleDefMD.Load(System.IO.Path.Combine(basePath, Path), context);
		}

		/// <summary>
		///     Read the raw bytes of the module from the path.
		/// </summary>
		/// <param name="basePath">
		///     The base path for the relative module path,
		///     or null if the module path is absolute or relative to current directory.
		/// </param>
		/// <returns>The loaded module.</returns>
		public byte[] LoadRaw(string basePath) {
			if (basePath == null)
				return File.ReadAllBytes(Path);
			return File.ReadAllBytes(System.IO.Path.Combine(basePath, Path));
		}

		/// <summary>
		///     Saves the module description as XML element.
		/// </summary>
		/// <param name="xmlDoc">The root XML document.</param>
		/// <returns>The serialized module description.</returns>
		internal XmlElement Save(XmlDocument xmlDoc) {
			XmlElement elem = xmlDoc.CreateElement("module", ConfuserProject.Namespace);

			XmlAttribute nameAttr = xmlDoc.CreateAttribute("path");
			nameAttr.Value = Path;
			elem.Attributes.Append(nameAttr);

			if (IsExternal) {
				XmlAttribute extAttr = xmlDoc.CreateAttribute("external");
				extAttr.Value = IsExternal.ToString();
				elem.Attributes.Append(extAttr);
			}
			if (SNKeyPath != null) {
				XmlAttribute snKeyAttr = xmlDoc.CreateAttribute("snKey");
				snKeyAttr.Value = SNKeyPath;
				elem.Attributes.Append(snKeyAttr);
			}
			if (SNKeyPassword != null) {
				XmlAttribute snKeyPassAttr = xmlDoc.CreateAttribute("snKeyPass");
				snKeyPassAttr.Value = SNKeyPassword;
				elem.Attributes.Append(snKeyPassAttr);
			}


			foreach (Rule i in Rules)
				elem.AppendChild(i.Save(xmlDoc));

			return elem;
		}

		/// <summary>
		///     Loads the module description from XML element.
		/// </summary>
		/// <param name="elem">The serialized module description.</param>
		internal void Load(XmlElement elem) {
			Path = elem.Attributes["path"].Value;

			if (elem.Attributes["external"] != null)
				IsExternal = bool.Parse(elem.Attributes["external"].Value);
			else
				IsExternal = false;

			if (elem.Attributes["snKey"] != null)
				SNKeyPath = elem.Attributes["snKey"].Value.NullIfEmpty();
			else
				SNKeyPath = null;

			if (elem.Attributes["snKeyPass"] != null)
				SNKeyPassword = elem.Attributes["snKeyPass"].Value.NullIfEmpty();
			else
				SNKeyPassword = null;

			Rules.Clear();
			foreach (XmlElement i in elem.ChildNodes.OfType<XmlElement>()) {
				var rule = new Rule();
				rule.Load(i);
				Rules.Add(rule);
			}
		}

		/// <summary>
		///     Returns a <see cref="string" /> that represents this instance.
		/// </summary>
		/// <returns>A <see cref="string" /> that represents this instance.</returns>
		public override string ToString() {
			return Path;
		}

		/// <summary>
		///     Clones this instance.
		/// </summary>
		/// <returns>A duplicated module.</returns>
		public ProjectModule Clone() {
			var ret = new ProjectModule();
			ret.Path = Path;
			ret.IsExternal = IsExternal;
			ret.SNKeyPath = SNKeyPath;
			ret.SNKeyPassword = SNKeyPassword;
			foreach (var r in Rules)
				ret.Rules.Add(r.Clone());
			return ret;
		}
	}

	/// <summary>
	///     Indicates add or remove the protection from the active protections
	/// </summary>
	public enum SettingItemAction {
		/// <summary>
		///     Add the protection to the active protections
		/// </summary>
		Add,

		/// <summary>
		///     Remove the protection from the active protections
		/// </summary>
		Remove
	}

	/// <summary>
	///     A <see cref="ConfuserComponent" /> setting within a rule.
	/// </summary>
	/// <typeparam name="T"><see cref="Protection" /> or <see cref="Packer" /></typeparam>
	public class SettingItem<T> : Dictionary<string, string> {
		/// <summary>
		/// Initialize this setting item instance
		/// </summary>
		/// <param name="id">The protection id</param>
		/// <param name="action">The action to take</param>
		public SettingItem(string id = null, SettingItemAction action = SettingItemAction.Add) {
			Id = id;
			Action = action;
		}

		/// <summary>
		///     The identifier of component
		/// </summary>
		/// <value>The identifier of component.</value>
		/// <seealso cref="ConfuserComponent.Id" />
		public string Id { get; set; }

		/// <summary>
		///     Gets or sets the action of component.
		/// </summary>
		/// <value>The action of component.</value>
		public SettingItemAction Action { get; set; }

		/// <summary>
		///     Saves the setting description as XML element.
		/// </summary>
		/// <param name="xmlDoc">The root XML document.</param>
		/// <returns>The setting module description.</returns>
		internal XmlElement Save(XmlDocument xmlDoc) {
			XmlElement elem = xmlDoc.CreateElement(typeof(T) == typeof(Packer) ? "packer" : "protection", ConfuserProject.Namespace);

			XmlAttribute idAttr = xmlDoc.CreateAttribute("id");
			idAttr.Value = Id;
			elem.Attributes.Append(idAttr);

			if (Action != SettingItemAction.Add) {
				XmlAttribute pAttr = xmlDoc.CreateAttribute("action");
				pAttr.Value = Action.ToString().ToLower();
				elem.Attributes.Append(pAttr);
			}

			foreach (var i in this) {
				XmlElement arg = xmlDoc.CreateElement("argument", ConfuserProject.Namespace);

				XmlAttribute nameAttr = xmlDoc.CreateAttribute("name");
				nameAttr.Value = i.Key;
				arg.Attributes.Append(nameAttr);
				XmlAttribute valAttr = xmlDoc.CreateAttribute("value");
				valAttr.Value = i.Value;
				arg.Attributes.Append(valAttr);

				elem.AppendChild(arg);
			}

			return elem;
		}

		/// <summary>
		///     Loads the setting description from XML element.
		/// </summary>
		/// <param name="elem">The serialized setting description.</param>
		internal void Load(XmlElement elem) {
			Id = elem.Attributes["id"].Value;

			if (elem.Attributes["action"] != null)
				Action = (SettingItemAction)Enum.Parse(typeof(SettingItemAction), elem.Attributes["action"].Value, true);
			else
				Action = SettingItemAction.Add;

			Clear();
			foreach (XmlElement i in elem.ChildNodes.OfType<XmlElement>())
				Add(i.Attributes["name"].Value, i.Attributes["value"].Value);
		}

		/// <summary>
		///     Clones this instance.
		/// </summary>
		/// <returns>A duplicated setting item.</returns>
		public SettingItem<T> Clone() {
			var item = new SettingItem<T>(Id, Action);
			foreach (var entry in this)
				item.Add(entry.Key, entry.Value);
			return item;
		}
	}


	/// <summary>
	///     A rule that control how <see cref="Protection" />s are applied to module
	/// </summary>
	public class Rule : List<SettingItem<Protection>> {
		/// <summary>
		/// Initialize this rule instance
		/// </summary>
		/// <param name="pattern">The pattern</param>
		/// <param name="preset">The preset</param>
		/// <param name="inherit">Inherits protection</param>
		public Rule(string pattern = "true", ProtectionPreset preset = ProtectionPreset.None, bool inherit = false) {
			Pattern = pattern;
			Preset = preset;
			Inherit = inherit;
		}

		/// <summary>
		///     Gets or sets the pattern that determine the target components of the rule.
		/// </summary>
		/// <value>The pattern expression.</value>
		public string Pattern { get; set; }

		/// <summary>
		///     Gets or sets the protection preset this rule uses.
		/// </summary>
		/// <value>The protection preset.</value>
		public ProtectionPreset Preset { get; set; }

		/// <summary>
		///     Gets or sets a value indicating whether this <see cref="Rule" /> inherits settings from earlier rules.
		/// </summary>
		/// <value><c>true</c> if it inherits settings; otherwise, <c>false</c>.</value>
		public bool Inherit { get; set; }

		/// <summary>
		///     Saves the rule description as XML element.
		/// </summary>
		/// <param name="xmlDoc">The root XML document.</param>
		/// <returns>The serialized rule description.</returns>
		internal XmlElement Save(XmlDocument xmlDoc) {
			XmlElement elem = xmlDoc.CreateElement("rule", ConfuserProject.Namespace);

			XmlAttribute ruleAttr = xmlDoc.CreateAttribute("pattern");
			ruleAttr.Value = Pattern;
			elem.Attributes.Append(ruleAttr);

			if (Preset != ProtectionPreset.None) {
				XmlAttribute pAttr = xmlDoc.CreateAttribute("preset");
				pAttr.Value = Preset.ToString().ToLower();
				elem.Attributes.Append(pAttr);
			}

			if (Inherit != true) {
				XmlAttribute attr = xmlDoc.CreateAttribute("inherit");
				attr.Value = Inherit.ToString().ToLower();
				elem.Attributes.Append(attr);
			}

			foreach (var i in this)
				elem.AppendChild(i.Save(xmlDoc));

			return elem;
		}

		/// <summary>
		///     Loads the rule description from XML element.
		/// </summary>
		/// <param name="elem">The serialized module description.</param>
		internal void Load(XmlElement elem) {
			Pattern = elem.Attributes["pattern"].Value;

			if (elem.Attributes["preset"] != null)
				Preset = (ProtectionPreset)Enum.Parse(typeof(ProtectionPreset), elem.Attributes["preset"].Value, true);
			else
				Preset = ProtectionPreset.None;

			if (elem.Attributes["inherit"] != null)
				Inherit = bool.Parse(elem.Attributes["inherit"].Value);
			else
				Inherit = true;

			Clear();
			foreach (XmlElement i in elem.ChildNodes.OfType<XmlElement>()) {
				var x = new SettingItem<Protection>();
				x.Load(i);
				Add(x);
			}
		}


		/// <summary>
		///     Clones this instance.
		/// </summary>
		/// <returns>A duplicated rule.</returns>
		public Rule Clone() {
			var ret = new Rule();
			ret.Preset = Preset;
			ret.Pattern = Pattern;
			ret.Inherit = Inherit;
			foreach (var i in this) {
				var item = new SettingItem<Protection>();
				item.Id = i.Id;
				item.Action = i.Action;
				foreach (string j in i.Keys)
					item.Add(j, i[j]);
				ret.Add(item);
			}
			return ret;
		}
	}

	/// <summary>
	///     The exception that is thrown when there exists schema errors in the project XML.
	/// </summary>
	public class ProjectValidationException : Exception {
		/// <summary>
		///     Initializes a new instance of the <see cref="ProjectValidationException" /> class.
		/// </summary>
		/// <param name="exceptions">The list of schema exceptions.</param>
		internal ProjectValidationException(List<XmlSchemaException> exceptions)
			: base(exceptions[0].Message) {
			Errors = exceptions;
		}

		/// <summary>
		///     Gets the schema exceptions.
		/// </summary>
		/// <value>A list of schema exceptions.</value>
		public IList<XmlSchemaException> Errors { get; private set; }
	}

	/// <summary>
	///     Represent a project of Confuser.
	/// </summary>
	public class ConfuserProject : List<ProjectModule> {
		/// <summary>
		///     The namespace of Confuser project schema
		/// </summary>
		public const string Namespace = "http://confuser.codeplex.com";

		/// <summary>
		///     The schema of project XML.
		/// </summary>
		public static readonly XmlSchema Schema = XmlSchema.Read(typeof(ConfuserProject).Assembly.GetManifestResourceStream("Confuser.Core.Project.ConfuserPrj.xsd"), null);

		/// <summary>
		///     Initializes a new instance of the <see cref="ConfuserProject" /> class.
		/// </summary>
		public ConfuserProject() {
			ProbePaths = new List<string>();
			PluginPaths = new List<string>();
			Rules = new List<Rule>();
		}

		/// <summary>
		///     Gets or sets the seed of pseudo-random generator used in process of protection.
		/// </summary>
		/// <value>The random seed.</value>
		public string Seed { get; set; }

		/// <summary>
		///     Gets or sets a value indicating whether debug symbols are generated.
		/// </summary>
		/// <value><c>true</c> if debug symbols are generated; otherwise, <c>false</c>.</value>
		public bool Debug { get; set; }

		/// <summary>
		///     Gets or sets the output directory.
		/// </summary>
		/// <value>The output directory.</value>
		public string OutputDirectory { get; set; }

		/// <summary>
		///     Gets or sets the base directory of the project.
		/// </summary>
		/// <value>The base directory.</value>
		public string BaseDirectory { get; set; }

		/// <summary>
		///     Gets a list of protection rules that applies globally.
		/// </summary>
		/// <value>A list of protection rules.</value>
		public IList<Rule> Rules { get; private set; }

		/// <summary>
		///     Gets or sets the packer used to pack up the output.
		/// </summary>
		/// <value>The packer.</value>
		public SettingItem<Packer> Packer { get; set; }

		/// <summary>
		///     Gets a list of paths that used to resolve assemblies.
		/// </summary>
		/// <value>The list of paths.</value>
		public IList<string> ProbePaths { get; private set; }

		/// <summary>
		///     Gets a list of paths to plugin.
		/// </summary>
		/// <value>The list of plugins.</value>
		public IList<string> PluginPaths { get; private set; }

		/// <summary>
		///     Saves the project as XML document.
		/// </summary>
		/// <returns>The serialized project XML.</returns>
		public XmlDocument Save() {
			var xmlDoc = new XmlDocument();
			xmlDoc.Schemas.Add(Schema);

			XmlElement elem = xmlDoc.CreateElement("project", Namespace);

			XmlAttribute outputAttr = xmlDoc.CreateAttribute("outputDir");
			outputAttr.Value = OutputDirectory;
			elem.Attributes.Append(outputAttr);

			XmlAttribute baseAttr = xmlDoc.CreateAttribute("baseDir");
			baseAttr.Value = BaseDirectory;
			elem.Attributes.Append(baseAttr);

			if (Seed != null) {
				XmlAttribute seedAttr = xmlDoc.CreateAttribute("seed");
				seedAttr.Value = Seed;
				elem.Attributes.Append(seedAttr);
			}

			if (Debug) {
				XmlAttribute debugAttr = xmlDoc.CreateAttribute("debug");
				debugAttr.Value = Debug.ToString().ToLower();
				elem.Attributes.Append(debugAttr);
			}

			foreach (Rule i in Rules)
				elem.AppendChild(i.Save(xmlDoc));

			if (Packer != null)
				elem.AppendChild(Packer.Save(xmlDoc));

			foreach (ProjectModule i in this)
				elem.AppendChild(i.Save(xmlDoc));

			foreach (string i in ProbePaths) {
				XmlElement path = xmlDoc.CreateElement("probePath", Namespace);
				path.InnerText = i;
				elem.AppendChild(path);
			}

			foreach (string i in PluginPaths) {
				XmlElement path = xmlDoc.CreateElement("plugin", Namespace);
				path.InnerText = i;
				elem.AppendChild(path);
			}

			xmlDoc.AppendChild(elem);
			return xmlDoc;
		}

		/// <summary>
		///     Loads the project from specified XML document.
		/// </summary>
		/// <param name="doc">The XML document storing the project.</param>
		/// <exception cref="Confuser.Core.Project.ProjectValidationException">
		///     The project XML contains schema errors.
		/// </exception>
		public void Load(XmlDocument doc) {
			doc.Schemas.Add(Schema);
			var exceptions = new List<XmlSchemaException>();
			doc.Validate((sender, e) => {
				if (e.Severity != XmlSeverityType.Error) return;
				exceptions.Add(e.Exception);
			});
			if (exceptions.Count > 0) {
				throw new ProjectValidationException(exceptions);
			}

			XmlElement docElem = doc.DocumentElement;

			OutputDirectory = docElem.Attributes["outputDir"].Value;
			BaseDirectory = docElem.Attributes["baseDir"].Value;

			if (docElem.Attributes["seed"] != null)
				Seed = docElem.Attributes["seed"].Value.NullIfEmpty();
			else
				Seed = null;

			if (docElem.Attributes["debug"] != null)
				Debug = bool.Parse(docElem.Attributes["debug"].Value);
			else
				Debug = false;

			Packer = null;
			Clear();
			ProbePaths.Clear();
			PluginPaths.Clear();
			Rules.Clear();
			foreach (XmlElement i in docElem.ChildNodes.OfType<XmlElement>()) {
				if (i.Name == "rule") {
					var rule = new Rule();
					rule.Load(i);
					Rules.Add(rule);
				}
				else if (i.Name == "packer") {
					Packer = new SettingItem<Packer>();
					Packer.Load(i);
				}
				else if (i.Name == "probePath") {
					ProbePaths.Add(i.InnerText);
				}
				else if (i.Name == "plugin") {
					PluginPaths.Add(i.InnerText);
				}
				else {
					var asm = new ProjectModule();
					asm.Load(i);
					Add(asm);
				}
			}
		}

		/// <summary>
		///     Clones this instance.
		/// </summary>
		/// <returns>A duplicated project.</returns>
		public ConfuserProject Clone() {
			var ret = new ConfuserProject();
			ret.Seed = Seed;
			ret.Debug = Debug;
			ret.OutputDirectory = OutputDirectory;
			ret.BaseDirectory = BaseDirectory;
			ret.Packer = Packer == null ? null : Packer.Clone();
			ret.ProbePaths = new List<string>(ProbePaths);
			ret.PluginPaths = new List<string>(PluginPaths);
			foreach (var module in this)
				ret.Add(module.Clone());
			foreach (var r in Rules)
				ret.Rules.Add(r);
			return ret;
		}
	}
}


================================================
File: Confuser.Core/Project/InvalidPatternException.cs
================================================
ï»¿using System;

namespace Confuser.Core.Project {
	/// <summary>
	///     The exception that is thrown when attempted to parse an invalid pattern.
	/// </summary>
	public class InvalidPatternException : Exception {
		/// <summary>
		///     Initializes a new instance of the <see cref="ConfuserException" /> class.
		/// </summary>
		/// <param name="message">The message that describes the error.</param>
		public InvalidPatternException(string message)
			: base(message) { }

		/// <summary>
		///     Initializes a new instance of the <see cref="ConfuserException" /> class.
		/// </summary>
		/// <param name="message">The error message that explains the reason for the exception.</param>
		/// <param name="innerException">
		///     The exception that is the cause of the current exception, or a null reference (Nothing in
		///     Visual Basic) if no inner exception is specified.
		/// </param>
		public InvalidPatternException(string message, Exception innerException)
			: base(message, innerException) { }
	}
}


================================================
File: Confuser.Core/Project/PatternParser.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using Confuser.Core.Project.Patterns;

namespace Confuser.Core.Project {
	/// <summary>
	///     Parser of pattern expressions.
	/// </summary>
	public class PatternParser {
		static readonly Dictionary<string, Func<PatternFunction>> fns;
		static readonly Dictionary<string, Func<PatternOperator>> ops;
		readonly PatternTokenizer tokenizer = new PatternTokenizer();
		PatternToken? lookAhead;

		static PatternParser() {
			fns = new Dictionary<string, Func<PatternFunction>>(StringComparer.OrdinalIgnoreCase);
			fns.Add(ModuleFunction.FnName, () => new ModuleFunction());
			fns.Add(DeclTypeFunction.FnName, () => new DeclTypeFunction());
			fns.Add(NamespaceFunction.FnName, () => new NamespaceFunction());
			fns.Add(NameFunction.FnName, () => new NameFunction());
			fns.Add(FullNameFunction.FnName, () => new FullNameFunction());
			fns.Add(MatchFunction.FnName, () => new MatchFunction());
			fns.Add(MatchNameFunction.FnName, () => new MatchNameFunction());
			fns.Add(MatchTypeNameFunction.FnName, () => new MatchTypeNameFunction());
			fns.Add(MemberTypeFunction.FnName, () => new MemberTypeFunction());
			fns.Add(IsPublicFunction.FnName, () => new IsPublicFunction());
			fns.Add(InheritsFunction.FnName, () => new InheritsFunction());
			fns.Add(IsTypeFunction.FnName, () => new IsTypeFunction());
			fns.Add(HasAttrFunction.FnName, () => new HasAttrFunction());

			ops = new Dictionary<string, Func<PatternOperator>>(StringComparer.OrdinalIgnoreCase);
			ops.Add(AndOperator.OpName, () => new AndOperator());
			ops.Add(OrOperator.OpName, () => new OrOperator());
			ops.Add(NotOperator.OpName, () => new NotOperator());
		}

		/// <summary>
		///     Parses the specified pattern into expression.
		/// </summary>
		/// <param name="pattern">The pattern to parse.</param>
		/// <returns>The parsed expression.</returns>
		/// <exception cref="InvalidPatternException">
		///     The pattern is invalid.
		/// </exception>
		public PatternExpression Parse(string pattern) {
			if (pattern == null)
				throw new ArgumentNullException("pattern");

			try {
				tokenizer.Initialize(pattern);
				lookAhead = tokenizer.NextToken();
				PatternExpression ret = ParseExpression(true);
				if (PeekToken() != null)
					throw new InvalidPatternException("Extra tokens beyond the end of pattern.");
				return ret;
			}
			catch (Exception ex) {
				if (ex is InvalidPatternException)
					throw;
				throw new InvalidPatternException("Invalid pattern.", ex);
			}
		}

		static bool IsFunction(PatternToken token) {
			if (token.Type != TokenType.Identifier)
				return false;
			return fns.ContainsKey(token.Value);
		}

		static bool IsOperator(PatternToken token) {
			if (token.Type != TokenType.Identifier)
				return false;
			return ops.ContainsKey(token.Value);
		}

		Exception UnexpectedEnd() {
			throw new InvalidPatternException("Unexpected end of pattern.");
		}

		Exception MismatchParens(int position) {
			throw new InvalidPatternException(string.Format("Mismatched parentheses at position {0}.", position));
		}

		Exception UnknownToken(PatternToken token) {
			throw new InvalidPatternException(string.Format("Unknown token '{0}' at position {1}.", token.Value, token.Position));
		}

		Exception UnexpectedToken(PatternToken token) {
			throw new InvalidPatternException(string.Format("Unexpected token '{0}' at position {1}.", token.Value, token.Position));
		}

		Exception UnexpectedToken(PatternToken token, char expect) {
			throw new InvalidPatternException(string.Format("Unexpected token '{0}' at position {1}. Expected '{2}'.", token.Value, token.Position, expect));
		}

		Exception BadArgCount(PatternToken token, int expected) {
			throw new InvalidPatternException(string.Format("Invalid argument count for '{0}' at position {1}. Expected {2}", token.Value, token.Position, expected));
		}

		PatternToken ReadToken() {
			if (lookAhead == null)
				throw UnexpectedEnd();
			PatternToken ret = lookAhead.Value;
			lookAhead = tokenizer.NextToken();
			return ret;
		}

		PatternToken? PeekToken() {
			return lookAhead;
		}

		PatternExpression ParseExpression(bool readBinOp = false) {
			PatternExpression ret;
			PatternToken token = ReadToken();
			switch (token.Type) {
				case TokenType.Literal:
					ret = new LiteralExpression(token.Value);
					break;
				case TokenType.LParens: {
					ret = ParseExpression(true);
					PatternToken parens = ReadToken();
					if (parens.Type != TokenType.RParens)
						throw MismatchParens(token.Position.Value);
				}
					break;
				case TokenType.Identifier:
					if (IsOperator(token)) {
						// unary operator
						PatternOperator op = ops[token.Value]();
						if (!op.IsUnary)
							throw UnexpectedToken(token);
						op.OperandA = ParseExpression();
						ret = op;
					}
					else if (IsFunction(token)) {
						// function
						PatternFunction fn = fns[token.Value]();

						PatternToken parens = ReadToken();
						if (parens.Type != TokenType.LParens)
							throw UnexpectedToken(parens, '(');

						fn.Arguments = new List<PatternExpression>(fn.ArgumentCount);
						for (int i = 0; i < fn.ArgumentCount; i++) {
							if (PeekToken() == null)
								throw UnexpectedEnd();
							if (PeekToken().Value.Type == TokenType.RParens)
								throw BadArgCount(token, fn.ArgumentCount);
							if (i != 0) {
								PatternToken comma = ReadToken();
								if (comma.Type != TokenType.Comma)
									throw UnexpectedToken(comma, ',');
							}
							fn.Arguments.Add(ParseExpression());
						}

						parens = ReadToken();
						if (parens.Type == TokenType.Comma)
							throw BadArgCount(token, fn.ArgumentCount);
						if (parens.Type != TokenType.RParens)
							throw MismatchParens(parens.Position.Value);

						ret = fn;
					}
					else {
						bool boolValue;
						if (bool.TryParse(token.Value, out boolValue))
							ret = new LiteralExpression(boolValue);
						else
							throw UnknownToken(token);
					}

					break;
				default:
					throw UnexpectedToken(token);
			}

			if (!readBinOp)
				return ret;

			// binary operator
			PatternToken? peek = PeekToken();
			while (peek != null) {
				if (peek.Value.Type != TokenType.Identifier)
					break;
				if (!IsOperator(peek.Value))
					break;

				PatternToken binOpToken = ReadToken();
				PatternOperator binOp = ops[binOpToken.Value]();
				if (binOp.IsUnary)
					throw UnexpectedToken(binOpToken);
				binOp.OperandA = ret;
				binOp.OperandB = ParseExpression();
				ret = binOp;

				peek = PeekToken();
			}

			return ret;
		}
	}
}


================================================
File: Confuser.Core/Project/PatternToken.cs
================================================
ï»¿using System;

namespace Confuser.Core.Project {
	/// <summary>
	///     The type of pattern tokens
	/// </summary>
	public enum TokenType {
		/// <summary>
		///     An identifier, could be functions/operators.
		/// </summary>
		Identifier,

		/// <summary>
		///     A string literal.
		/// </summary>
		Literal,

		/// <summary>
		///     A left parenthesis.
		/// </summary>
		LParens,

		/// <summary>
		///     A right parenthesis.
		/// </summary>
		RParens,

		/// <summary>
		///     A comma.
		/// </summary>
		Comma
	}


	/// <summary>
	///     Represent a token in pattern
	/// </summary>
	public struct PatternToken {
		/// <summary>
		///     The position of this token in the pattern, or null if position not available.
		/// </summary>
		public readonly int? Position;

		/// <summary>
		///     The type of this token.
		/// </summary>
		public readonly TokenType Type;

		/// <summary>
		///     The value of this token, applicable to identifiers and literals.
		/// </summary>
		public readonly string Value;

		/// <summary>
		///     Initializes a new instance of the <see cref="PatternToken" /> struct.
		/// </summary>
		/// <param name="pos">The position of token.</param>
		/// <param name="type">The type of token.</param>
		public PatternToken(int pos, TokenType type) {
			Position = pos;
			Type = type;
			Value = null;
		}

		/// <summary>
		///     Initializes a new instance of the <see cref="PatternToken" /> struct.
		/// </summary>
		/// <param name="pos">The position of token.</param>
		/// <param name="type">The type of token.</param>
		/// <param name="value">The value of token.</param>
		public PatternToken(int pos, TokenType type, string value) {
			Position = pos;
			Type = type;
			Value = value;
		}

		/// <summary>
		///     Initializes a new instance of the <see cref="PatternToken" /> struct.
		/// </summary>
		/// <param name="type">The type of token.</param>
		public PatternToken(TokenType type) {
			Position = null;
			Type = type;
			Value = null;
		}

		/// <summary>
		///     Initializes a new instance of the <see cref="PatternToken" /> struct.
		/// </summary>
		/// <param name="type">The type of token.</param>
		/// <param name="value">The value of token.</param>
		public PatternToken(TokenType type, string value) {
			Position = null;
			Type = type;
			Value = value;
		}

		/// <inheritdoc />
		public override string ToString() {
			if (Position != null) {
				if (Value != null)
					return string.Format("[{0}] {1} @ {2}", Type, Value, Position);
				return string.Format("[{0}] @ {1}", Type, Position);
			}
			if (Value != null)
				return string.Format("[{0}] {1}", Type, Value);
			return string.Format("[{0}]", Type);
		}
	}
}


================================================
File: Confuser.Core/Project/PatternTokenizer.cs
================================================
ï»¿using System;
using System.Diagnostics;
using System.Text;

namespace Confuser.Core.Project {
	internal class PatternTokenizer {
		int index;
		string rulePattern;

		public void Initialize(string pattern) {
			rulePattern = pattern;
			index = 0;
		}

		void SkipWhitespace() {
			while (index < rulePattern.Length && char.IsWhiteSpace(rulePattern[index]))
				index++;
		}

		char? PeekChar() {
			if (index >= rulePattern.Length)
				return null;
			return rulePattern[index];
		}

		char NextChar() {
			if (index >= rulePattern.Length)
				throw new InvalidPatternException("Unexpected end of pattern.");
			return rulePattern[index++];
		}

		string ReadLiteral() {
			var ret = new StringBuilder();
			char delim = NextChar();
			Debug.Assert(delim == '"' || delim == '\'');

			char chr = NextChar();
			while (chr != delim) {
				// Escape sequence
				if (chr == '\\')
					ret.Append(NextChar());
				else
					ret.Append(chr);
				chr = NextChar();
			}
			return ret.ToString();
		}

		string ReadIdentifier() {
			var ret = new StringBuilder();

			char? chr = PeekChar();
			while (chr != null && (char.IsLetterOrDigit(chr.Value) || chr == '_' || chr == '-')) {
				ret.Append(NextChar());
				chr = PeekChar();
			}

			return ret.ToString();
		}

		public PatternToken? NextToken() {
			if (rulePattern == null)
				throw new InvalidOperationException("Tokenizer not initialized.");

			SkipWhitespace();
			char? tokenBegin = PeekChar();
			if (tokenBegin == null)
				return null;

			int pos = index;
			switch (tokenBegin.Value) {
				case ',':
					index++;
					return new PatternToken(pos, TokenType.Comma);
				case '(':
					index++;
					return new PatternToken(pos, TokenType.LParens);
				case ')':
					index++;
					return new PatternToken(pos, TokenType.RParens);

				case '"':
				case '\'':
					return new PatternToken(pos, TokenType.Literal, ReadLiteral());

				default:
					if (!char.IsLetter(tokenBegin.Value))
						throw new InvalidPatternException(string.Format("Unknown token '{0}' at position {1}.", tokenBegin, pos));

					return new PatternToken(pos, TokenType.Identifier, ReadIdentifier());
			}
		}
	}
}


================================================
File: Confuser.Core/Project/Patterns/AndOperator.cs
================================================
ï»¿using System;
using dnlib.DotNet;

namespace Confuser.Core.Project.Patterns {
	/// <summary>
	///     The AND operator.
	/// </summary>
	public class AndOperator : PatternOperator {
		internal const string OpName = "and";

		/// <inheritdoc />
		public override string Name {
			get { return OpName; }
		}

		/// <inheritdoc />
		public override bool IsUnary {
			get { return false; }
		}

		/// <inheritdoc />
		public override object Evaluate(IDnlibDef definition) {
			var a = (bool)OperandA.Evaluate(definition);
			if (!a) return false;
			return (bool)OperandB.Evaluate(definition);
		}
	}
}


================================================
File: Confuser.Core/Project/Patterns/DeclTypeFunction.cs
================================================
ï»¿using System;
using dnlib.DotNet;

namespace Confuser.Core.Project.Patterns {
	/// <summary>
	///     A function that compare the full name of declaring type.
	/// </summary>
	public class DeclTypeFunction : PatternFunction {
		internal const string FnName = "decl-type";

		/// <inheritdoc />
		public override string Name {
			get { return FnName; }
		}

		/// <inheritdoc />
		public override int ArgumentCount {
			get { return 1; }
		}

		/// <inheritdoc />
		public override object Evaluate(IDnlibDef definition) {
			if (!(definition is IMemberDef) || ((IMemberDef)definition).DeclaringType == null)
				return false;
			object fullName = Arguments[0].Evaluate(definition);
			return ((IMemberDef)definition).DeclaringType.FullName == fullName.ToString();
		}
	}
}


================================================
File: Confuser.Core/Project/Patterns/FullNameFunction.cs
================================================
ï»¿using System;
using dnlib.DotNet;

namespace Confuser.Core.Project.Patterns {
	/// <summary>
	///     A function that compare the full name of definition.
	/// </summary>
	public class FullNameFunction : PatternFunction {
		internal const string FnName = "full-name";

		/// <inheritdoc />
		public override string Name {
			get { return FnName; }
		}

		/// <inheritdoc />
		public override int ArgumentCount {
			get { return 1; }
		}

		/// <inheritdoc />
		public override object Evaluate(IDnlibDef definition) {
			object name = Arguments[0].Evaluate(definition);
			return definition.FullName == name.ToString();
		}
	}
}


================================================
File: Confuser.Core/Project/Patterns/HasAttrFunction.cs
================================================
ï»¿using System;
using dnlib.DotNet;

namespace Confuser.Core.Project.Patterns {
	/// <summary>
	///     A function that indicate whether the item has the given custom attribute.
	/// </summary>
	public class HasAttrFunction : PatternFunction {
		internal const string FnName = "has-attr";

		/// <inheritdoc />
		public override string Name {
			get { return FnName; }
		}

		/// <inheritdoc />
		public override int ArgumentCount {
			get { return 1; }
		}

		/// <inheritdoc />
		public override object Evaluate(IDnlibDef definition) {
			string attrName = Arguments[0].Evaluate(definition).ToString();
			return definition.CustomAttributes.IsDefined(attrName);
		}
	}
}


================================================
File: Confuser.Core/Project/Patterns/InheritsFunction.cs
================================================
ï»¿using System;
using dnlib.DotNet;

namespace Confuser.Core.Project.Patterns {
	/// <summary>
	///     A function that indicate whether the type inherits from the specified type.
	/// </summary>
	public class InheritsFunction : PatternFunction {
		internal const string FnName = "inherits";

		/// <inheritdoc />
		public override string Name {
			get { return FnName; }
		}

		/// <inheritdoc />
		public override int ArgumentCount {
			get { return 1; }
		}

		/// <inheritdoc />
		public override object Evaluate(IDnlibDef definition) {
			string name = Arguments[0].Evaluate(definition).ToString();

			var type = definition as TypeDef;
			if (type == null && definition is IMemberDef)
				type = ((IMemberDef)definition).DeclaringType;
			if (type == null)
				return false;

			if (type.InheritsFrom(name) || type.Implements(name))
				return true;

			return false;
		}
	}
}


================================================
File: Confuser.Core/Project/Patterns/IsPublicFunction.cs
================================================
ï»¿using System;
using dnlib.DotNet;

namespace Confuser.Core.Project.Patterns {
	/// <summary>
	///     A function that indicate the visibility of members.
	/// </summary>
	public class IsPublicFunction : PatternFunction {
		internal const string FnName = "is-public";

		/// <inheritdoc />
		public override string Name {
			get { return FnName; }
		}

		/// <inheritdoc />
		public override int ArgumentCount {
			get { return 0; }
		}

		/// <inheritdoc />
		public override object Evaluate(IDnlibDef definition) {
			var member = definition as IMemberDef;
			if (member == null)
				return false;

			var declType = ((IMemberDef)definition).DeclaringType;
			while (declType != null) {
				if (!declType.IsPublic)
					return false;
				declType = declType.DeclaringType;
			}

			if (member is MethodDef)
				return ((MethodDef)member).IsPublic;
			if (member is FieldDef)
				return ((FieldDef)member).IsPublic;
			if (member is PropertyDef)
				return ((PropertyDef)member).IsPublic();
			if (member is EventDef)
				return ((EventDef)member).IsPublic();
			if (member is TypeDef)
				return ((TypeDef)member).IsPublic || ((TypeDef)member).IsNestedPublic;

			throw new NotSupportedException();
		}
	}
}


================================================
File: Confuser.Core/Project/Patterns/IsTypeFunction.cs
================================================
ï»¿using System;
using System.Text;
using System.Text.RegularExpressions;
using dnlib.DotNet;

namespace Confuser.Core.Project.Patterns {
	/// <summary>
	///     A function that indicate the type of type(?).
	/// </summary>
	public class IsTypeFunction : PatternFunction {
		internal const string FnName = "is-type";

		/// <inheritdoc />
		public override string Name {
			get { return FnName; }
		}

		/// <inheritdoc />
		public override int ArgumentCount {
			get { return 1; }
		}

		/// <inheritdoc />
		public override object Evaluate(IDnlibDef definition) {
			TypeDef type = definition as TypeDef;
			if (type == null && definition is IMemberDef)
				type = ((IMemberDef)definition).DeclaringType;
			if (type == null)
				return false;

			string typeRegex = Arguments[0].Evaluate(definition).ToString();

			var typeType = new StringBuilder();

			if (type.IsEnum)
				typeType.Append("enum ");

			if (type.IsInterface)
				typeType.Append("interface ");

			if (type.IsValueType)
				typeType.Append("valuetype ");

			if (type.IsDelegate())
				typeType.Append("delegate ");

			if (type.IsAbstract)
				typeType.Append("abstract ");

			if (type.IsNested)
				typeType.Append("nested ");

			if (type.IsSerializable)
				typeType.Append("serializable ");

			return Regex.IsMatch(typeType.ToString(), typeRegex);
		}
	}
}


================================================
File: Confuser.Core/Project/Patterns/LiteralExpression.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using dnlib.DotNet;

namespace Confuser.Core.Project.Patterns {
	/// <summary>
	///     A literal expression.
	/// </summary>
	public class LiteralExpression : PatternExpression {
		/// <summary>
		///     Initializes a new instance of the <see cref="LiteralExpression" /> class.
		/// </summary>
		/// <param name="literal">The literal.</param>
		public LiteralExpression(object literal) {
			Literal = literal;
		}

		/// <summary>
		///     Gets the value of literal.
		/// </summary>
		/// <value>The value of literal.</value>
		public object Literal { get; private set; }

		/// <inheritdoc />
		public override object Evaluate(IDnlibDef definition) {
			return Literal;
		}

		/// <inheritdoc />
		public override void Serialize(IList<PatternToken> tokens) {
			if (Literal is bool) {
				var value = (bool)Literal;
				tokens.Add(new PatternToken(TokenType.Identifier, value.ToString().ToLowerInvariant()));
			}
			else
				tokens.Add(new PatternToken(TokenType.Literal, Literal.ToString()));
		}
	}
}


================================================
File: Confuser.Core/Project/Patterns/MatchFunction.cs
================================================
ï»¿using System;
using System.Text.RegularExpressions;
using dnlib.DotNet;

namespace Confuser.Core.Project.Patterns {
	/// <summary>
	///     A function that match the full name of the definition with specified RegEx.
	/// </summary>
	public class MatchFunction : PatternFunction {
		internal const string FnName = "match";

		/// <inheritdoc />
		public override string Name {
			get { return FnName; }
		}

		/// <inheritdoc />
		public override int ArgumentCount {
			get { return 1; }
		}

		/// <inheritdoc />
		public override object Evaluate(IDnlibDef definition) {
			string regex = Arguments[0].Evaluate(definition).ToString();
			return Regex.IsMatch(definition.FullName, regex);
		}
	}

	/// <summary>
	///     A function that match the name of the definition with specified RegEx.
	/// </summary>
	public class MatchNameFunction : PatternFunction {
		internal const string FnName = "match-name";

		/// <inheritdoc />
		public override string Name {
			get { return FnName; }
		}

		/// <inheritdoc />
		public override int ArgumentCount {
			get { return 1; }
		}

		/// <inheritdoc />
		public override object Evaluate(IDnlibDef definition) {
			string regex = Arguments[0].Evaluate(definition).ToString();
			return Regex.IsMatch(definition.Name, regex);
		}
	}

	/// <summary>
	///     A function that match the name of declaring type with specified RegEx.
	/// </summary>
	public class MatchTypeNameFunction : PatternFunction {
		internal const string FnName = "match-type-name";

		/// <inheritdoc />
		public override string Name {
			get { return FnName; }
		}

		/// <inheritdoc />
		public override int ArgumentCount {
			get { return 1; }
		}

		/// <inheritdoc />
		public override object Evaluate(IDnlibDef definition) {
			if (definition is TypeDef) {
				string regex = Arguments[0].Evaluate(definition).ToString();
				return Regex.IsMatch(definition.Name, regex);
			}
			if (definition is IMemberDef && ((IMemberDef)definition).DeclaringType != null) {
				string regex = Arguments[0].Evaluate(definition).ToString();
				return Regex.IsMatch(((IMemberDef)definition).DeclaringType.Name, regex);
			}
			return false;
		}
	}
}


================================================
File: Confuser.Core/Project/Patterns/MemberTypeFunction.cs
================================================
ï»¿using System;
using System.Text;
using System.Text.RegularExpressions;
using dnlib.DotNet;

namespace Confuser.Core.Project.Patterns {
	/// <summary>
	///     A function that compare the type of definition.
	/// </summary>
	public class MemberTypeFunction : PatternFunction {
		internal const string FnName = "member-type";

		/// <inheritdoc />
		public override string Name {
			get { return FnName; }
		}

		/// <inheritdoc />
		public override int ArgumentCount {
			get { return 1; }
		}

		/// <inheritdoc />
		public override object Evaluate(IDnlibDef definition) {
			string typeRegex = Arguments[0].Evaluate(definition).ToString();

			var memberType = new StringBuilder();

			if (definition is TypeDef)
				memberType.Append("type ");

			if (definition is MethodDef) {
				memberType.Append("method ");

				var method = (MethodDef)definition;
				if (method.IsGetter)
					memberType.Append("propertym getter ");
				else if (method.IsSetter)
					memberType.Append("propertym setter ");
				else if (method.IsAddOn)
					memberType.Append("eventm add ");
				else if (method.IsRemoveOn)
					memberType.Append("eventm remove ");
				else if (method.IsFire)
					memberType.Append("eventm fire ");
				else if (method.IsOther)
					memberType.Append("other ");
			}

			if (definition is FieldDef)
				memberType.Append("field ");

			if (definition is PropertyDef)
				memberType.Append("property ");

			if (definition is EventDef)
				memberType.Append("event ");

			if (definition is ModuleDef)
				memberType.Append("module ");

			return Regex.IsMatch(memberType.ToString(), typeRegex);
		}
	}
}


================================================
File: Confuser.Core/Project/Patterns/ModuleFunction.cs
================================================
ï»¿using System;
using dnlib.DotNet;

namespace Confuser.Core.Project.Patterns {
	/// <summary>
	///     A function that compare the module of definition.
	/// </summary>
	public class ModuleFunction : PatternFunction {
		internal const string FnName = "module";

		/// <inheritdoc />
		public override string Name {
			get { return FnName; }
		}

		/// <inheritdoc />
		public override int ArgumentCount {
			get { return 1; }
		}

		/// <inheritdoc />
		public override object Evaluate(IDnlibDef definition) {
			if (!(definition is IOwnerModule) && !(definition is IModule))
				return false;
			object name = Arguments[0].Evaluate(definition);
			if (definition is IModule)
				return ((IModule)definition).Name == name.ToString();
			return ((IOwnerModule)definition).Module.Name == name.ToString();
		}
	}
}


================================================
File: Confuser.Core/Project/Patterns/NameFunction.cs
================================================
ï»¿using System;
using dnlib.DotNet;

namespace Confuser.Core.Project.Patterns {
	/// <summary>
	///     A function that compare the name of definition.
	/// </summary>
	public class NameFunction : PatternFunction {
		internal const string FnName = "name";

		/// <inheritdoc />
		public override string Name {
			get { return FnName; }
		}

		/// <inheritdoc />
		public override int ArgumentCount {
			get { return 1; }
		}

		/// <inheritdoc />
		public override object Evaluate(IDnlibDef definition) {
			object name = Arguments[0].Evaluate(definition);
			return definition.Name == name.ToString();
		}
	}
}


================================================
File: Confuser.Core/Project/Patterns/NamespaceFunction.cs
================================================
ï»¿using System;
using System.Text.RegularExpressions;
using dnlib.DotNet;

namespace Confuser.Core.Project.Patterns {
	/// <summary>
	///     A function that compare the namespace of definition.
	/// </summary>
	public class NamespaceFunction : PatternFunction {
		internal const string FnName = "namespace";

		/// <inheritdoc />
		public override string Name {
			get { return FnName; }
		}

		/// <inheritdoc />
		public override int ArgumentCount {
			get { return 1; }
		}

		/// <inheritdoc />
		public override object Evaluate(IDnlibDef definition) {
			if (!(definition is TypeDef) && !(definition is IMemberDef))
				return false;
			var ns = "^" + Arguments[0].Evaluate(definition).ToString() + "$";

			var type = definition as TypeDef;
			if (type == null)
				type = ((IMemberDef)definition).DeclaringType;

			if (type == null)
				return false;

			while (type.IsNested)
				type = type.DeclaringType;

			return type != null && Regex.IsMatch(type.Namespace ?? "", ns);
		}
	}
}


================================================
File: Confuser.Core/Project/Patterns/NotOperator.cs
================================================
ï»¿using System;
using dnlib.DotNet;

namespace Confuser.Core.Project.Patterns {
	/// <summary>
	///     The NOT operator.
	/// </summary>
	public class NotOperator : PatternOperator {
		internal const string OpName = "not";

		/// <inheritdoc />
		public override string Name {
			get { return OpName; }
		}

		/// <inheritdoc />
		public override bool IsUnary {
			get { return true; }
		}

		/// <inheritdoc />
		public override object Evaluate(IDnlibDef definition) {
			return !(bool)OperandA.Evaluate(definition);
		}
	}
}


================================================
File: Confuser.Core/Project/Patterns/OrOperator.cs
================================================
ï»¿using System;
using dnlib.DotNet;

namespace Confuser.Core.Project.Patterns {
	/// <summary>
	///     The OR operator.
	/// </summary>
	public class OrOperator : PatternOperator {
		internal const string OpName = "or";

		/// <inheritdoc />
		public override string Name {
			get { return OpName; }
		}

		/// <inheritdoc />
		public override bool IsUnary {
			get { return false; }
		}

		/// <inheritdoc />
		public override object Evaluate(IDnlibDef definition) {
			var a = (bool)OperandA.Evaluate(definition);
			if (a) return true;
			return (bool)OperandB.Evaluate(definition);
		}
	}
}


================================================
File: Confuser.Core/Project/Patterns/PatternExpression.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using dnlib.DotNet;

namespace Confuser.Core.Project.Patterns {
	/// <summary>
	///     A pattern expression.
	/// </summary>
	public abstract class PatternExpression {
		/// <summary>
		///     Evaluates the expression on the specified definition.
		/// </summary>
		/// <param name="definition">The definition.</param>
		/// <returns>The result value.</returns>
		public abstract object Evaluate(IDnlibDef definition);

		/// <summary>
		///     Serializes the expression into tokens.
		/// </summary>
		/// <param name="tokens">The output list of tokens.</param>
		public abstract void Serialize(IList<PatternToken> tokens);
	}
}


================================================
File: Confuser.Core/Project/Patterns/PatternFunction.cs
================================================
ï»¿using System;
using System.Collections.Generic;

namespace Confuser.Core.Project.Patterns {
	/// <summary>
	///     A pattern function.
	/// </summary>
	public abstract class PatternFunction : PatternExpression {
		/// <summary>
		///     Gets the name of function.
		/// </summary>
		/// <value>The name.</value>
		public abstract string Name { get; }

		/// <summary>
		///     Gets the number of arguments of the function.
		/// </summary>
		/// <value>The number of arguments.</value>
		public abstract int ArgumentCount { get; }

		/// <summary>
		///     Gets or sets the arguments of function.
		/// </summary>
		/// <value>The arguments.</value>
		public IList<PatternExpression> Arguments { get; set; }

		/// <inheritdoc />
		public override void Serialize(IList<PatternToken> tokens) {
			tokens.Add(new PatternToken(TokenType.Identifier, Name));
			tokens.Add(new PatternToken(TokenType.LParens));
			for (int i = 0; i < Arguments.Count; i++) {
				if (i != 0)
					tokens.Add(new PatternToken(TokenType.Comma));
				Arguments[i].Serialize(tokens);
			}
			tokens.Add(new PatternToken(TokenType.RParens));
		}
	}
}


================================================
File: Confuser.Core/Project/Patterns/PatternOperator.cs
================================================
ï»¿using System;
using System.Collections.Generic;

namespace Confuser.Core.Project.Patterns {
	/// <summary>
	///     A pattern operator.
	/// </summary>
	public abstract class PatternOperator : PatternExpression {
		/// <summary>
		///     Gets the name of operator.
		/// </summary>
		/// <value>The name.</value>
		public abstract string Name { get; }

		/// <summary>
		///     Gets a value indicating whether this is an unary operator.
		/// </summary>
		/// <value><c>true</c> if this is an unary operator; otherwise, <c>false</c>.</value>
		public abstract bool IsUnary { get; }

		/// <summary>
		///     Gets or sets the first operand.
		/// </summary>
		/// <value>The first operand.</value>
		public PatternExpression OperandA { get; set; }

		/// <summary>
		///     Gets or sets the second operand.
		/// </summary>
		/// <value>The second operand.</value>
		public PatternExpression OperandB { get; set; }

		/// <inheritdoc />
		public override void Serialize(IList<PatternToken> tokens) {
			if (IsUnary) {
				tokens.Add(new PatternToken(TokenType.Identifier, Name));
				OperandA.Serialize(tokens);
			}
			else {
				OperandA.Serialize(tokens);
				tokens.Add(new PatternToken(TokenType.Identifier, Name));
				OperandB.Serialize(tokens);
			}
		}
	}
}


================================================
File: Confuser.Core/Properties/AssemblyInfo.cs
================================================
ï»¿using System;
using System.Reflection;

[assembly: AssemblyTitle("ConfuserEx Core")]
[assembly: AssemblyDescription("Core framework of ConfuserEx")]


================================================
File: Confuser.Core/Services/CompressionService.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using Confuser.Core.Helpers;
using dnlib.DotNet;
using SevenZip;
using SevenZip.Compression.LZMA;

namespace Confuser.Core.Services {
	internal class CompressionService : ICompressionService {
		static readonly object Decompressor = new object();
		readonly ConfuserContext context;

		/// <summary>
		///     Initializes a new instance of the <see cref="CompressionService" /> class.
		/// </summary>
		/// <param name="context">The working context.</param>
		public CompressionService(ConfuserContext context) {
			this.context = context;
		}

		/// <inheritdoc />
		public MethodDef TryGetRuntimeDecompressor(ModuleDef module, Action<IDnlibDef> init) {
			var decompressor = context.Annotations.Get<Tuple<MethodDef, List<IDnlibDef>>>(module, Decompressor);
			if (decompressor == null)
				return null;

			foreach (IDnlibDef member in decompressor.Item2)
				init(member);
			return decompressor.Item1;
		}

		/// <inheritdoc />
		public MethodDef GetRuntimeDecompressor(ModuleDef module, Action<IDnlibDef> init) {
			Tuple<MethodDef, List<IDnlibDef>> decompressor = context.Annotations.GetOrCreate(module, Decompressor, m => {
				var rt = context.Registry.GetService<IRuntimeService>();

				List<IDnlibDef> members = InjectHelper.Inject(rt.GetRuntimeType("Confuser.Runtime.Lzma"), module.GlobalType, module).ToList();
				MethodDef decomp = null;
				foreach (IDnlibDef member in members) {
					if (member is MethodDef) {
						var method = (MethodDef)member;
						if (method.Access == MethodAttributes.Public)
							method.Access = MethodAttributes.Assembly;
						if (!method.IsConstructor)
							method.IsSpecialName = false;

						if (method.Name == "Decompress")
							decomp = method;
					}
					else if (member is FieldDef) {
						var field = (FieldDef)member;
						if (field.Access == FieldAttributes.Public)
							field.Access = FieldAttributes.Assembly;
						if (field.IsLiteral) {
							field.DeclaringType.Fields.Remove(field);
						}
					}
				}
				members.RemoveWhere(def => def is FieldDef && ((FieldDef)def).IsLiteral);

				Debug.Assert(decomp != null);
				return Tuple.Create(decomp, members);
			});
			foreach (IDnlibDef member in decompressor.Item2)
				init(member);
			return decompressor.Item1;
		}

		/// <inheritdoc />
		public byte[] Compress(byte[] data, Action<double> progressFunc = null) {
			CoderPropID[] propIDs = {
				CoderPropID.DictionarySize,
				CoderPropID.PosStateBits,
				CoderPropID.LitContextBits,
				CoderPropID.LitPosBits,
				CoderPropID.Algorithm,
				CoderPropID.NumFastBytes,
				CoderPropID.MatchFinder,
				CoderPropID.EndMarker
			};
			object[] properties = {
				1 << 23,
				2,
				3,
				0,
				2,
				128,
				"bt4",
				false
			};

			var x = new MemoryStream();
			var encoder = new Encoder();
			encoder.SetCoderProperties(propIDs, properties);
			encoder.WriteCoderProperties(x);
			Int64 fileSize;
			fileSize = data.Length;
			for (int i = 0; i < 8; i++)
				x.WriteByte((Byte)(fileSize >> (8 * i)));

			ICodeProgress progress = null;
			if (progressFunc != null)
				progress = new CompressionLogger(progressFunc, data.Length);
			encoder.Code(new MemoryStream(data), x, -1, -1, progress);

			return x.ToArray();
		}

		class CompressionLogger : ICodeProgress {
			readonly Action<double> progressFunc;
			readonly int size;

			public CompressionLogger(Action<double> progressFunc, int size) {
				this.progressFunc = progressFunc;
				this.size = size;
			}

			public void SetProgress(long inSize, long outSize) {
				double precentage = (double)inSize / size;
				progressFunc(precentage);
			}
		}
	}

	/// <summary>
	///     Provides methods to do compression and inject decompression algorithm.
	/// </summary>
	public interface ICompressionService {
		/// <summary>
		///     Gets the runtime decompression method in the module, or null if it's not yet injected.
		/// </summary>
		/// <param name="module">The module which the decompression method resides in.</param>
		/// <param name="init">The initializing method for compression helper definitions.</param>
		/// <returns>
		///     The requested decompression method with signature 'static Byte[] (Byte[])',
		///     or null if it hasn't been injected yet.
		/// </returns>
		MethodDef TryGetRuntimeDecompressor(ModuleDef module, Action<IDnlibDef> init);

		/// <summary>
		///     Gets the runtime decompression method in the module and inject if it does not exists.
		/// </summary>
		/// <param name="module">The module which the decompression method resides in.</param>
		/// <param name="init">The initializing method for injected helper definitions.</param>
		/// <returns>The requested decompression method with signature 'static Byte[] (Byte[])'.</returns>
		MethodDef GetRuntimeDecompressor(ModuleDef module, Action<IDnlibDef> init);

		/// <summary>
		///     Compresses the specified data.
		/// </summary>
		/// <param name="data">The buffer storing the data.</param>
		/// <param name="progressFunc">The function that receive the progress of compression.</param>
		/// <returns>The compressed data.</returns>
		byte[] Compress(byte[] data, Action<double> progressFunc = null);
	}
}


================================================
File: Confuser.Core/Services/MarkerService.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using dnlib.DotNet;

namespace Confuser.Core.Services {
	internal class MarkerService : IMarkerService {
		readonly ConfuserContext context;
		readonly Marker marker;
		readonly Dictionary<IDnlibDef, ConfuserComponent> helperParents;

		/// <summary>
		///     Initializes a new instance of the <see cref="MarkerService" /> class.
		/// </summary>
		/// <param name="context">The working context.</param>
		/// <param name="marker">The marker.</param>
		public MarkerService(ConfuserContext context, Marker marker) {
			this.context = context;
			this.marker = marker;
			helperParents = new Dictionary<IDnlibDef, ConfuserComponent>();
		}

		/// <inheritdoc />
		public void Mark(IDnlibDef member, ConfuserComponent parentComp) {
			if (member == null)
				throw new ArgumentNullException("member");
			if (member is ModuleDef)
				throw new ArgumentException("New ModuleDef cannot be marked.");
			if (IsMarked(member)) // avoid double marking
				return;

			marker.MarkMember(member, context);
			if (parentComp != null)
				helperParents[member] = parentComp;
		}

		/// <inheritdoc />
		public bool IsMarked(IDnlibDef def) {
			return ProtectionParameters.GetParameters(context, def) != null;
		}

		/// <inheritdoc />
		public ConfuserComponent GetHelperParent(IDnlibDef def) {
			ConfuserComponent parent;
			if (!helperParents.TryGetValue(def, out parent))
				return null;
			return parent;
		}
	}

	/// <summary>
	///     Provides methods to access the obfuscation marker.
	/// </summary>
	public interface IMarkerService {
		/// <summary>
		///     Marks the helper member.
		/// </summary>
		/// <param name="member">The helper member.</param>
		/// <param name="parentComp">The parent component.</param>
		/// <exception cref="System.ArgumentException"><paramref name="member" /> is a <see cref="ModuleDef" />.</exception>
		/// <exception cref="System.ArgumentNullException"><paramref name="member" /> is <c>null</c>.</exception>
		void Mark(IDnlibDef member, ConfuserComponent parentComp);

		/// <summary>
		///     Determines whether the specified definition is marked.
		/// </summary>
		/// <param name="def">The definition.</param>
		/// <returns><c>true</c> if the specified definition is marked; otherwise, <c>false</c>.</returns>
		bool IsMarked(IDnlibDef def);

		/// <summary>
		///     Gets the parent component of the specified helper.
		/// </summary>
		/// <param name="def">The helper definition.</param>
		/// <returns>The parent component of the helper, or <c>null</c> if the specified definition is not a helper.</returns>
		ConfuserComponent GetHelperParent(IDnlibDef def);
	}
}


================================================
File: Confuser.Core/Services/RandomService.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Security.Cryptography;
using System.Text;

namespace Confuser.Core.Services {
	/// <summary>
	///     A seeded SHA256 PRNG.
	/// </summary>
	public class RandomGenerator {
		/// <summary>
		///     The prime numbers used for generation
		/// </summary>
		static readonly byte[] primes = { 7, 11, 23, 37, 43, 59, 71 };

		readonly SHA256Managed sha256 = new SHA256Managed();
		int mixIndex;
		byte[] state; //32 bytes
		int stateFilled;

		/// <summary>
		///     Initializes a new instance of the <see cref="RandomGenerator" /> class.
		/// </summary>
		/// <param name="seed">The seed.</param>
		internal RandomGenerator(byte[] seed) {
			state = (byte[])seed.Clone();
			stateFilled = 32;
			mixIndex = 0;
		}

		/// <summary>
		///     Creates a seed buffer.
		/// </summary>
		/// <param name="seed">The seed data.</param>
		/// <returns>The seed buffer.</returns>
		internal static byte[] Seed(string seed) {
			byte[] ret;
			if (!string.IsNullOrEmpty(seed))
				ret = Utils.SHA256(Encoding.UTF8.GetBytes(seed));
			else
				ret = Utils.SHA256(Guid.NewGuid().ToByteArray());

			for (int i = 0; i < 32; i++) {
				ret[i] *= primes[i % primes.Length];
				ret = Utils.SHA256(ret);
			}
			return ret;
		}

		/// <summary>
		///     Refills the state buffer.
		/// </summary>
		void NextState() {
			for (int i = 0; i < 32; i++)
				state[i] ^= primes[mixIndex = (mixIndex + 1) % primes.Length];
			state = sha256.ComputeHash(state);
			stateFilled = 32;
		}

		/// <summary>
		///     Fills the specified buffer with random bytes.
		/// </summary>
		/// <param name="buffer">The buffer.</param>
		/// <param name="offset">The offset of buffer to fill in.</param>
		/// <param name="length">The number of random bytes.</param>
		/// <exception cref="System.ArgumentNullException"><paramref name="buffer" /> is <c>null</c>.</exception>
		/// <exception cref="System.ArgumentOutOfRangeException">
		///     <paramref name="offset" /> or <paramref name="length" /> is less than 0.
		/// </exception>
		/// <exception cref="System.ArgumentException">Invalid <paramref name="offset" /> or <paramref name="length" />.</exception>
		public void NextBytes(byte[] buffer, int offset, int length) {
			if (buffer == null)
				throw new ArgumentNullException("buffer");
			if (offset < 0)
				throw new ArgumentOutOfRangeException("offset");
			if (length < 0)
				throw new ArgumentOutOfRangeException("length");
			if (buffer.Length - offset < length)
				throw new ArgumentException("Invalid offset or length.");

			while (length > 0) {
				if (length >= stateFilled) {
					Buffer.BlockCopy(state, 32 - stateFilled, buffer, offset, stateFilled);
					offset += stateFilled;
					length -= stateFilled;
					stateFilled = 0;
				}
				else {
					Buffer.BlockCopy(state, 32 - stateFilled, buffer, offset, length);
					stateFilled -= length;
					length = 0;
				}
				if (stateFilled == 0)
					NextState();
			}
		}

		/// <summary>
		///     Returns a random byte.
		/// </summary>
		/// <returns>Requested random byte.</returns>
		public byte NextByte() {
			byte ret = state[32 - stateFilled];
			stateFilled--;
			if (stateFilled == 0)
				NextState();
			return ret;
		}

		/// <summary>
		///     Gets a buffer of random bytes with the specified length.
		/// </summary>
		/// <param name="length">The number of random bytes.</param>
		/// <returns>A buffer of random bytes.</returns>
		public byte[] NextBytes(int length) {
			var ret = new byte[length];
			NextBytes(ret, 0, length);
			return ret;
		}

		/// <summary>
		///     Returns a random signed integer.
		/// </summary>
		/// <returns>Requested random number.</returns>
		public int NextInt32() {
			return BitConverter.ToInt32(NextBytes(4), 0);
		}

		/// <summary>
		///     Returns a nonnegative random integer that is less than the specified maximum.
		/// </summary>
		/// <param name="max">The exclusive upper bound.</param>
		/// <returns>Requested random number.</returns>
		public int NextInt32(int max) {
			return (int)(NextUInt32() % max);
		}

		/// <summary>
		///     Returns a random integer that is within a specified range.
		/// </summary>
		/// <param name="min">The inclusive lower bound.</param>
		/// <param name="max">The exclusive upper bound.</param>
		/// <returns>Requested random number.</returns>
		public int NextInt32(int min, int max) {
			if (max <= min) return min;
			return min + (int)(NextUInt32() % (max - min));
		}

		/// <summary>
		///     Returns a random unsigned integer.
		/// </summary>
		/// <returns>Requested random number.</returns>
		public uint NextUInt32() {
			return BitConverter.ToUInt32(NextBytes(4), 0);
		}

		/// <summary>
		///     Returns a random double floating pointer number from 0 (inclusive) to 1 (exclusive).
		/// </summary>
		/// <returns>Requested random number.</returns>
		public double NextDouble() {
			return NextUInt32() / ((double)uint.MaxValue + 1);
		}

		/// <summary>
		///     Returns a random boolean value.
		/// </summary>
		/// <returns>Requested random boolean value.</returns>
		public bool NextBoolean() {
			byte s = state[32 - stateFilled];
			stateFilled--;
			if (stateFilled == 0)
				NextState();
			return s % 2 == 0;
		}

		/// <summary>
		///     Shuffles the element in the specified list.
		/// </summary>
		/// <typeparam name="T"></typeparam>
		/// <param name="list">The list to shuffle.</param>
		public void Shuffle<T>(IList<T> list) {
			for (int i = list.Count - 1; i > 1; i--) {
				int k = NextInt32(i + 1);
				T tmp = list[k];
				list[k] = list[i];
				list[i] = tmp;
			}
		}
	}

	/// <summary>
	///     Implementation of <see cref="IRandomService" />.
	/// </summary>
	internal class RandomService : IRandomService {
		readonly byte[] seed; //32 bytes

		/// <summary>
		///     Initializes a new instance of the <see cref="RandomService" /> class.
		/// </summary>
		/// <param name="seed">The project seed.</param>
		public RandomService(string seed) {
			this.seed = RandomGenerator.Seed(seed);
		}

		/// <inheritdoc />
		public RandomGenerator GetRandomGenerator(string id) {
			if (string.IsNullOrEmpty(id))
				throw new ArgumentNullException("id");
			byte[] newSeed = seed;
			byte[] idHash = Utils.SHA256(Encoding.UTF8.GetBytes(id));
			for (int i = 0; i < 32; i++)
				newSeed[i] ^= idHash[i];
			return new RandomGenerator(Utils.SHA256(newSeed));
		}
	}

	/// <summary>
	///     Provides methods to obtain a unique stable PRNG for any given ID.
	/// </summary>
	public interface IRandomService {
		/// <summary>
		///     Gets a RNG with the specified identifier.
		/// </summary>
		/// <param name="id">The identifier.</param>
		/// <returns>The requested RNG.</returns>
		/// <exception cref="System.ArgumentNullException"><paramref name="id" /> is <c>null</c>.</exception>
		RandomGenerator GetRandomGenerator(string id);
	}
}


================================================
File: Confuser.Core/Services/RuntimeService.cs
================================================
ï»¿using System;
using System.IO;
using System.Reflection;
using dnlib.DotNet;

namespace Confuser.Core.Services {
	internal class RuntimeService : IRuntimeService {
		ModuleDef rtModule;

		/// <inheritdoc />
		public TypeDef GetRuntimeType(string fullName) {
			if (rtModule == null) {
				Module module = typeof(RuntimeService).Assembly.ManifestModule;
				string rtPath = "Confuser.Runtime.dll";
				if (module.FullyQualifiedName[0] != '<')
					rtPath = Path.Combine(Path.GetDirectoryName(module.FullyQualifiedName), rtPath);
				rtModule = ModuleDefMD.Load(rtPath, new ModuleCreationOptions() { TryToLoadPdbFromDisk = true });
				rtModule.EnableTypeDefFindCache = true;
			}
			return rtModule.Find(fullName, true);
		}
	}

	/// <summary>
	///     Provides methods to obtain runtime library injection type.
	/// </summary>
	public interface IRuntimeService {
		/// <summary>
		///     Gets the specified runtime type for injection.
		/// </summary>
		/// <param name="fullName">The full name of the runtime type.</param>
		/// <returns>The requested runtime type.</returns>
		TypeDef GetRuntimeType(string fullName);
	}
}


================================================
File: Confuser.Core/Services/TraceService.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Core.Services {
	internal class TraceService : ITraceService {
		readonly Dictionary<MethodDef, MethodTrace> cache = new Dictionary<MethodDef, MethodTrace>();
		ConfuserContext context;

		/// <summary>
		///     Initializes a new instance of the <see cref="TraceService" /> class.
		/// </summary>
		/// <param name="context">The working context.</param>
		public TraceService(ConfuserContext context) {
			this.context = context;
		}


		/// <inheritdoc />
		public MethodTrace Trace(MethodDef method) {
			if (method == null)
				throw new ArgumentNullException("method");
			return cache.GetValueOrDefaultLazy(method, m => cache[m] = new MethodTrace(m)).Trace();
		}
	}

	/// <summary>
	///     Provides methods to trace stack of method body.
	/// </summary>
	public interface ITraceService {
		/// <summary>
		///     Trace the stack of the specified method.
		/// </summary>
		/// <param name="method">The method to trace.</param>
		/// <exception cref="InvalidMethodException"><paramref name="method" /> has invalid body.</exception>
		/// <exception cref="System.ArgumentNullException"><paramref name="method" /> is <c>null</c>.</exception>
		MethodTrace Trace(MethodDef method);
	}


	/// <summary>
	///     The trace result of a method.
	/// </summary>
	public class MethodTrace {
		readonly MethodDef method;
		Dictionary<int, List<Instruction>> fromInstrs;
		Dictionary<uint, int> offset2index;

		/// <summary>
		///     Initializes a new instance of the <see cref="MethodTrace" /> class.
		/// </summary>
		/// <param name="method">The method to trace.</param>
		internal MethodTrace(MethodDef method) {
			this.method = method;
		}

		/// <summary>
		///     Gets the method this trace belongs to.
		/// </summary>
		/// <value>The method.</value>
		public MethodDef Method {
			get { return method; }
		}

		/// <summary>
		///     Gets the instructions this trace is performed on.
		/// </summary>
		/// <value>The instructions.</value>
		public Instruction[] Instructions { get; private set; }

		/// <summary>
		///     Gets the map of offset to index.
		/// </summary>
		/// <value>The map.</value>
		public Func<uint, int> OffsetToIndexMap {
			get { return offset => offset2index[offset]; }
		}

		/// <summary>
		///     Gets the stack depths of method body.
		/// </summary>
		/// <value>The stack depths.</value>
		public int[] BeforeStackDepths { get; private set; }

		/// <summary>
		///     Gets the stack depths of method body.
		/// </summary>
		/// <value>The stack depths.</value>
		public int[] AfterStackDepths { get; private set; }

		/// <summary>
		///     Determines whether the specified instruction is the target of a branch instruction.
		/// </summary>
		/// <param name="instrIndex">The index of instruction.</param>
		/// <returns><c>true</c> if the specified instruction is a branch target; otherwise, <c>false</c>.</returns>
		public bool IsBranchTarget(int instrIndex) {
			return fromInstrs.ContainsKey(instrIndex);
		}

		/// <summary>
		///     Perform the actual tracing.
		/// </summary>
		/// <returns>This instance.</returns>
		/// <exception cref="InvalidMethodException">Bad method body.</exception>
		internal MethodTrace Trace() {
			CilBody body = method.Body;
			method.Body.UpdateInstructionOffsets();
			Instructions = method.Body.Instructions.ToArray();

			offset2index = new Dictionary<uint, int>();
			var beforeDepths = new int[body.Instructions.Count];
			var afterDepths = new int[body.Instructions.Count];
			fromInstrs = new Dictionary<int, List<Instruction>>();

			IList<Instruction> instrs = body.Instructions;
			for (int i = 0; i < instrs.Count; i++) {
				offset2index.Add(instrs[i].Offset, i);
				beforeDepths[i] = int.MinValue;
			}

			foreach (ExceptionHandler eh in body.ExceptionHandlers) {
				beforeDepths[offset2index[eh.TryStart.Offset]] = 0;
				beforeDepths[offset2index[eh.HandlerStart.Offset]] = (eh.HandlerType != ExceptionHandlerType.Finally ? 1 : 0);
				if (eh.FilterStart != null)
					beforeDepths[offset2index[eh.FilterStart.Offset]] = 1;
			}

			// Just do a simple forward scan to build the stack depth map
			int currentStack = 0;
			for (int i = 0; i < instrs.Count; i++) {
				Instruction instr = instrs[i];

				if (beforeDepths[i] != int.MinValue) // Already set due to being target of a branch / beginning of EHs.
					currentStack = beforeDepths[i];

				beforeDepths[i] = currentStack;
				instr.UpdateStack(ref currentStack);
				afterDepths[i] = currentStack;

				switch (instr.OpCode.FlowControl) {
					case FlowControl.Branch:
						int index = offset2index[((Instruction)instr.Operand).Offset];
						if (beforeDepths[index] == int.MinValue)
							beforeDepths[index] = currentStack;
						fromInstrs.AddListEntry(offset2index[((Instruction)instr.Operand).Offset], instr);
						currentStack = 0;
						break;
					case FlowControl.Break:
						break;
					case FlowControl.Call:
						if (instr.OpCode.Code == Code.Jmp)
							currentStack = 0;
						break;
					case FlowControl.Cond_Branch:
						if (instr.OpCode.Code == Code.Switch) {
							foreach (Instruction target in (Instruction[])instr.Operand) {
								int targetIndex = offset2index[target.Offset];
								if (beforeDepths[targetIndex] == int.MinValue)
									beforeDepths[targetIndex] = currentStack;
								fromInstrs.AddListEntry(offset2index[target.Offset], instr);
							}
						}
						else {
							int targetIndex = offset2index[((Instruction)instr.Operand).Offset];
							if (beforeDepths[targetIndex] == int.MinValue)
								beforeDepths[targetIndex] = currentStack;
							fromInstrs.AddListEntry(offset2index[((Instruction)instr.Operand).Offset], instr);
						}
						break;
					case FlowControl.Meta:
						break;
					case FlowControl.Next:
						break;
					case FlowControl.Return:
						break;
					case FlowControl.Throw:
						break;
					default:
						throw new UnreachableException();
				}
			}

			foreach (int stackDepth in beforeDepths)
				if (stackDepth == int.MinValue)
					throw new InvalidMethodException("Bad method body.");

			foreach (int stackDepth in afterDepths)
				if (stackDepth == int.MinValue)
					throw new InvalidMethodException("Bad method body.");

			BeforeStackDepths = beforeDepths;
			AfterStackDepths = afterDepths;

			return this;
		}

		/// <summary>
		///     Traces the arguments of the specified call instruction.
		/// </summary>
		/// <param name="instr">The call instruction.</param>
		/// <returns>The indexes of the begin instruction of arguments.</returns>
		/// <exception cref="System.ArgumentException">The specified call instruction is invalid.</exception>
		/// <exception cref="InvalidMethodException">The method body is invalid.</exception>
		public int[] TraceArguments(Instruction instr) {
			if (instr.OpCode.Code != Code.Call && instr.OpCode.Code != Code.Callvirt && instr.OpCode.Code != Code.Newobj)
				throw new ArgumentException("Invalid call instruction.", "instr");

			int push, pop;
			instr.CalculateStackUsage(out push, out pop); // pop is number of arguments
			if (pop == 0)
				return new int[0];

			int instrIndex = offset2index[instr.Offset];
			int argCount = pop;
			int targetStack = BeforeStackDepths[instrIndex] - argCount;

			// Find the begin instruction of method call
			int beginInstrIndex = -1;
			var seen = new HashSet<uint>();
			var working = new Queue<int>();
			working.Enqueue(offset2index[instr.Offset] - 1);
			while (working.Count > 0) {
				int index = working.Dequeue();
				while (index >= 0) {
					if (BeforeStackDepths[index] == targetStack)
						break;

					if (fromInstrs.ContainsKey(index))
						foreach (Instruction fromInstr in fromInstrs[index]) {
							if (!seen.Contains(fromInstr.Offset)) {
								seen.Add(fromInstr.Offset);
								working.Enqueue(offset2index[fromInstr.Offset]);
							}
						}
					index--;
				}
				if (index < 0)
					return null;

				if (beginInstrIndex == -1)
					beginInstrIndex = index;
				else if (beginInstrIndex != index)
					return null;
			}

			// Trace the index of arguments
			seen.Clear();
			var working2 = new Queue<Tuple<int, Stack<int>>>();
			working2.Clear();
			working2.Enqueue(Tuple.Create(beginInstrIndex, new Stack<int>()));
			int[] ret = null;
			while (working2.Count > 0) {
				Tuple<int, Stack<int>> tuple = working2.Dequeue();
				int index = tuple.Item1;
				Stack<int> evalStack = tuple.Item2;

				while (index != instrIndex && index < method.Body.Instructions.Count) {
					Instruction currentInstr = Instructions[index];
					currentInstr.CalculateStackUsage(out push, out pop);
					int stackUsage = pop - push;
					if (stackUsage < 0) {
						Debug.Assert(stackUsage == -1); // i.e. push
						evalStack.Push(index);
					}
					else {
						if (evalStack.Count < stackUsage)
							return null;

						for (int i = 0; i < stackUsage; i++)
							evalStack.Pop();
					}

					object instrOperand = currentInstr.Operand;
					if (currentInstr.Operand is Instruction) {
						int targetIndex = offset2index[((Instruction)currentInstr.Operand).Offset];
						if (currentInstr.OpCode.FlowControl == FlowControl.Branch)
							index = targetIndex;
						else {
							working2.Enqueue(Tuple.Create(targetIndex, new Stack<int>(evalStack)));
							index++;
						}
					}
					else if (currentInstr.Operand is Instruction[]) {
						foreach (Instruction targetInstr in (Instruction[])currentInstr.Operand)
							working2.Enqueue(Tuple.Create(offset2index[targetInstr.Offset], new Stack<int>(evalStack)));
						index++;
					}
					else
						index++;
				}

				if (evalStack.Count != argCount)
					return null;
				if (ret != null && !evalStack.SequenceEqual(ret))
					return null;
				ret = evalStack.ToArray();
			}

			if (ret == null)
				return ret;

			Array.Reverse(ret);
			return ret;
		}
	}
}


================================================
File: Confuser.DynCipher/Confuser.DynCipher.csproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProductVersion>8.0.30703</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{E832E9B8-2158-4FC0-89A1-56C6ECC10F6B}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>Confuser.DynCipher</RootNamespace>
    <AssemblyName>Confuser.DynCipher</AssemblyName>
    <TargetFrameworkVersion Condition=" !$(DefineConstants.Contains('NET45')) ">v4.0</TargetFrameworkVersion>
    <TargetFrameworkVersion Condition=" $(DefineConstants.Contains('NET45')) ">v4.5</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <TargetFrameworkProfile />
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>..\Debug\bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>..\Release\bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup>
    <SignAssembly>true</SignAssembly>
  </PropertyGroup>
  <PropertyGroup>
    <AssemblyOriginatorKeyFile>..\ConfuserEx.snk</AssemblyOriginatorKeyFile>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Core" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="..\GlobalAssemblyInfo.cs">
      <Link>Properties\GlobalAssemblyInfo.cs</Link>
    </Compile>
    <Compile Include="AST\ArrayIndexExpression.cs" />
    <Compile Include="AST\AssignmentStatement.cs" />
    <Compile Include="AST\BinOpExpression.cs" />
    <Compile Include="AST\Expression.cs" />
    <Compile Include="AST\LiteralExpression.cs" />
    <Compile Include="AST\LoopStatement.cs" />
    <Compile Include="AST\Statement.cs" />
    <Compile Include="AST\StatementBlock.cs" />
    <Compile Include="AST\UnaryOpExpression.cs" />
    <Compile Include="AST\Variable.cs" />
    <Compile Include="AST\VariableExpression.cs" />
    <Compile Include="DynCipherComponent.cs" />
    <Compile Include="DynCipherService.cs" />
    <Compile Include="Elements\AddKey.cs" />
    <Compile Include="Elements\BinOp.cs" />
    <Compile Include="Elements\CryptoElement.cs" />
    <Compile Include="Elements\Matrix.cs" />
    <Compile Include="Elements\NumOp.cs" />
    <Compile Include="Elements\RotateBit.cs" />
    <Compile Include="Elements\Swap.cs" />
    <Compile Include="Generation\CipherGenContext.cs" />
    <Compile Include="Generation\CipherGenerator.cs" />
    <Compile Include="Generation\CILCodeGen.cs" />
    <Compile Include="Generation\DMCodeGen.cs" />
    <Compile Include="Generation\ExpressionGenerator.cs" />
    <Compile Include="Generation\x86CodeGen.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="Transforms\ConvertVariables.cs" />
    <Compile Include="Transforms\ExpansionTransform.cs" />
    <Compile Include="Transforms\MulToShiftTransform.cs" />
    <Compile Include="Transforms\NormalizeBinOpTransform.cs" />
    <Compile Include="Transforms\ShuffleTransform.cs" />
    <Compile Include="Utils.cs" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\Confuser.Core\Confuser.Core.csproj">
      <Project>{BEB67A6E-4C54-4DE5-8C6B-2C12F44A7B92}</Project>
      <Name>Confuser.Core</Name>
    </ProjectReference>
    <ProjectReference Include="..\dnlib\src\dnlib.csproj">
      <Project>{FDFC1237-143F-4919-8318-4926901F4639}</Project>
      <Name>dnlib</Name>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup>
    <None Include="..\ConfuserEx.snk">
      <Link>Properties\ConfuserEx.snk</Link>
    </None>
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>


================================================
File: Confuser.DynCipher/DynCipherComponent.cs
================================================
ï»¿using System;
using Confuser.Core;

namespace Confuser.DynCipher {
	internal class DynCipherComponent : ConfuserComponent {
		public const string _ServiceId = "Confuser.DynCipher";

		public override string Name {
			get { return "Dynamic Cipher"; }
		}

		public override string Description {
			get { return "Provides dynamic cipher generation services."; }
		}

		public override string Id {
			get { return _ServiceId; }
		}

		public override string FullId {
			get { return _ServiceId; }
		}

		protected override void Initialize(ConfuserContext context) {
			context.Registry.RegisterService(_ServiceId, typeof(IDynCipherService), new DynCipherService());
		}

		protected override void PopulatePipeline(ProtectionPipeline pipeline) {
			//
		}
	}
}


================================================
File: Confuser.DynCipher/DynCipherService.cs
================================================
ï»¿using System;
using Confuser.Core.Services;
using Confuser.DynCipher.AST;
using Confuser.DynCipher.Generation;

namespace Confuser.DynCipher {
	public interface IDynCipherService {
		void GenerateCipherPair(RandomGenerator random, out StatementBlock encrypt, out StatementBlock decrypt);
		void GenerateExpressionPair(RandomGenerator random, Expression var, Expression result, int depth, out Expression expression, out Expression inverse);
	}

	internal class DynCipherService : IDynCipherService {
		public void GenerateCipherPair(RandomGenerator random, out StatementBlock encrypt, out StatementBlock decrypt) {
			CipherGenerator.GeneratePair(random, out encrypt, out decrypt);
		}

		public void GenerateExpressionPair(RandomGenerator random, Expression var, Expression result, int depth, out Expression expression, out Expression inverse) {
			ExpressionGenerator.GeneratePair(random, var, result, depth, out expression, out inverse);
		}
	}
}


================================================
File: Confuser.DynCipher/Utils.cs
================================================
ï»¿using System;
using System.IO;
using Confuser.DynCipher.Generation;

namespace Confuser.DynCipher {
	public static class MathsUtils {
		const ulong MODULO32 = 0x100000000;

		public static ulong modInv(ulong num, ulong mod) {
			ulong a = mod, b = num % mod;
			ulong p0 = 0, p1 = 1;
			while (b != 0) {
				if (b == 1) return p1;
				p0 += (a / b) * p1;
				a = a % b;

				if (a == 0) break;
				if (a == 1) return mod - p0;

				p1 += (b / a) * p0;
				b = b % a;
			}
			return 0;
		}

		public static uint modInv(uint num) {
			return (uint)modInv(num, MODULO32);
		}

		public static byte modInv(byte num) {
			return (byte)modInv(num, 0x100);
		}
	}

	public static class CodeGenUtils {
		public static byte[] AssembleCode(x86CodeGen codeGen, x86Register reg) {
			var stream = new MemoryStream();
			using (var writer = new BinaryWriter(stream)) {
				/* 
                 *      mov eax, esp
                 *      push ebx
                 *      push edi
                 *      push esi
                 *      sub eax, esp
                 *      cmp eax, 24             ; determine the bitness of platform
                 *      je n
                 *      mov eax, [esp + 4]      ; 32 bits => argument in stack
                 *      push eax
                 *      jmp z
                 *  n:  push ecx                ; 64 bits => argument in register
                 *  z:  XXX
                 *      pop esi
                 *      pop edi
                 *      pop ebx
                 *      pop ret
                 *      
                 */
				writer.Write(new byte[] { 0x89, 0xe0 });
				writer.Write(new byte[] { 0x53 });
				writer.Write(new byte[] { 0x57 });
				writer.Write(new byte[] { 0x56 });
				writer.Write(new byte[] { 0x29, 0xe0 });
				writer.Write(new byte[] { 0x83, 0xf8, 0x18 });
				writer.Write(new byte[] { 0x74, 0x07 });
				writer.Write(new byte[] { 0x8b, 0x44, 0x24, 0x10 });
				writer.Write(new byte[] { 0x50 });
				writer.Write(new byte[] { 0xeb, 0x01 });
				writer.Write(new byte[] { 0x51 });

				foreach (x86Instruction i in codeGen.Instructions)
					writer.Write(i.Assemble());

				if (reg != x86Register.EAX)
					writer.Write(x86Instruction.Create(x86OpCode.MOV, new x86RegisterOperand(x86Register.EAX), new x86RegisterOperand(reg)).Assemble());

				writer.Write(new byte[] { 0x5e });
				writer.Write(new byte[] { 0x5f });
				writer.Write(new byte[] { 0x5b });
				writer.Write(new byte[] { 0xc3 });
			}
			return stream.ToArray();
		}
	}
}


================================================
File: Confuser.DynCipher/AST/ArrayIndexExpression.cs
================================================
ï»¿using System;

namespace Confuser.DynCipher.AST {
	public class ArrayIndexExpression : Expression {
		public Expression Array { get; set; }
		public int Index { get; set; }

		public override string ToString() {
			return string.Format("{0}[{1}]", Array, Index);
		}
	}
}


================================================
File: Confuser.DynCipher/AST/AssignmentStatement.cs
================================================
ï»¿using System;

namespace Confuser.DynCipher.AST {
	public class AssignmentStatement : Statement {
		public Expression Target { get; set; }
		public Expression Value { get; set; }

		public override string ToString() {
			return string.Format("{0} = {1};", Target, Value);
		}
	}
}


================================================
File: Confuser.DynCipher/AST/BinOpExpression.cs
================================================
ï»¿using System;

namespace Confuser.DynCipher.AST {
	public enum BinOps {
		Add,
		Sub,
		Div,
		Mul,
		Or,
		And,
		Xor,
		Lsh,
		Rsh
	}

	public class BinOpExpression : Expression {
		public Expression Left { get; set; }
		public Expression Right { get; set; }
		public BinOps Operation { get; set; }

		public override string ToString() {
			string op;
			switch (Operation) {
				case BinOps.Add:
					op = "+";
					break;
				case BinOps.Sub:
					op = "-";
					break;
				case BinOps.Div:
					op = "/";
					break;
				case BinOps.Mul:
					op = "*";
					break;
				case BinOps.Or:
					op = "|";
					break;
				case BinOps.And:
					op = "&";
					break;
				case BinOps.Xor:
					op = "^";
					break;
				case BinOps.Lsh:
					op = "<<";
					break;
				case BinOps.Rsh:
					op = ">>";
					break;
				default:
					throw new Exception();
			}
			return string.Format("({0} {1} {2})", Left, op, Right);
		}
	}
}


================================================
File: Confuser.DynCipher/AST/Expression.cs
================================================
ï»¿using System;

namespace Confuser.DynCipher.AST {
	public abstract class Expression {
		public object Tag { get; set; }
		public abstract override string ToString();

		public static BinOpExpression operator +(Expression a, Expression b) {
			return new BinOpExpression {
				Left = a,
				Right = b,
				Operation = BinOps.Add
			};
		}

		public static BinOpExpression operator -(Expression a, Expression b) {
			return new BinOpExpression {
				Left = a,
				Right = b,
				Operation = BinOps.Sub
			};
		}

		public static BinOpExpression operator *(Expression a, Expression b) {
			return new BinOpExpression {
				Left = a,
				Right = b,
				Operation = BinOps.Mul
			};
		}

		public static BinOpExpression operator >>(Expression a, int b) {
			return new BinOpExpression {
				Left = a,
				Right = (LiteralExpression)(uint)b,
				Operation = BinOps.Rsh
			};
		}

		public static BinOpExpression operator <<(Expression a, int b) {
			return new BinOpExpression {
				Left = a,
				Right = (LiteralExpression)(uint)b,
				Operation = BinOps.Lsh
			};
		}

		public static BinOpExpression operator |(Expression a, Expression b) {
			return new BinOpExpression {
				Left = a,
				Right = b,
				Operation = BinOps.Or
			};
		}

		public static BinOpExpression operator &(Expression a, Expression b) {
			return new BinOpExpression {
				Left = a,
				Right = b,
				Operation = BinOps.And
			};
		}

		public static BinOpExpression operator ^(Expression a, Expression b) {
			return new BinOpExpression {
				Left = a,
				Right = b,
				Operation = BinOps.Xor
			};
		}

		public static UnaryOpExpression operator ~(Expression val) {
			return new UnaryOpExpression {
				Value = val,
				Operation = UnaryOps.Not
			};
		}

		public static UnaryOpExpression operator -(Expression val) {
			return new UnaryOpExpression {
				Value = val,
				Operation = UnaryOps.Negate
			};
		}
	}
}


================================================
File: Confuser.DynCipher/AST/LiteralExpression.cs
================================================
ï»¿using System;

namespace Confuser.DynCipher.AST {
	public class LiteralExpression : Expression {
		public uint Value { get; set; }

		public static implicit operator LiteralExpression(uint val) {
			return new LiteralExpression { Value = val };
		}

		public override string ToString() {
			return Value.ToString("x8") + "h";
		}
	}
}


================================================
File: Confuser.DynCipher/AST/LoopStatement.cs
================================================
ï»¿using System;
using System.Text;

namespace Confuser.DynCipher.AST {
	// i.e. for loop
	public class LoopStatement : StatementBlock {
		public int Begin { get; set; }
		public int Limit { get; set; }

		public override string ToString() {
			var ret = new StringBuilder();
			ret.AppendFormat("for (int i = {0}; i < {1}; i++)", Begin, Limit);
			ret.AppendLine();
			ret.Append(base.ToString());
			return ret.ToString();
		}
	}
}


================================================
File: Confuser.DynCipher/AST/Statement.cs
================================================
ï»¿using System;

namespace Confuser.DynCipher.AST {
	public abstract class Statement {
		public object Tag { get; set; }
		public abstract override string ToString();
	}
}


================================================
File: Confuser.DynCipher/AST/StatementBlock.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Text;

namespace Confuser.DynCipher.AST {
	public class StatementBlock : Statement {
		public StatementBlock() {
			Statements = new List<Statement>();
		}

		public IList<Statement> Statements { get; private set; }

		public override string ToString() {
			var sb = new StringBuilder();
			sb.AppendLine("{");
			foreach (Statement i in Statements)
				sb.AppendLine(i.ToString());
			sb.AppendLine("}");
			return sb.ToString();
		}
	}
}


================================================
File: Confuser.DynCipher/AST/UnaryOpExpression.cs
================================================
ï»¿using System;

namespace Confuser.DynCipher.AST {
	public enum UnaryOps {
		Not,
		Negate
	}

	public class UnaryOpExpression : Expression {
		public Expression Value { get; set; }
		public UnaryOps Operation { get; set; }

		public override string ToString() {
			string op;
			switch (Operation) {
				case UnaryOps.Not:
					op = "~";
					break;
				case UnaryOps.Negate:
					op = "-";
					break;
				default:
					throw new Exception();
			}
			return op + Value;
		}
	}
}


================================================
File: Confuser.DynCipher/AST/Variable.cs
================================================
ï»¿using System;

namespace Confuser.DynCipher.AST {
	public class Variable {
		public Variable(string name) {
			Name = name;
		}

		public string Name { get; set; }
		public object Tag { get; set; }

		public override string ToString() {
			return Name;
		}
	}
}


================================================
File: Confuser.DynCipher/AST/VariableExpression.cs
================================================
ï»¿using System;

namespace Confuser.DynCipher.AST {
	public class VariableExpression : Expression {
		public Variable Variable { get; set; }

		public override string ToString() {
			return Variable.Name;
		}
	}
}


================================================
File: Confuser.DynCipher/Elements/AddKey.cs
================================================
ï»¿using System;
using Confuser.Core.Services;
using Confuser.DynCipher.AST;
using Confuser.DynCipher.Generation;

namespace Confuser.DynCipher.Elements {
	internal class AddKey : CryptoElement {
		public AddKey(int index)
			: base(0) {
			Index = index;
		}

		public int Index { get; private set; }

		public override void Initialize(RandomGenerator random) { }

		void EmitCore(CipherGenContext context) {
			Expression val = context.GetDataExpression(Index);

			context.Emit(new AssignmentStatement {
				Value = val ^ context.GetKeyExpression(Index),
				Target = val
			});
		}

		public override void Emit(CipherGenContext context) {
			EmitCore(context);
		}

		public override void EmitInverse(CipherGenContext context) {
			EmitCore(context);
		}
	}
}


================================================
File: Confuser.DynCipher/Elements/BinOp.cs
================================================
ï»¿using System;
using Confuser.Core.Services;
using Confuser.DynCipher.AST;
using Confuser.DynCipher.Generation;

namespace Confuser.DynCipher.Elements {
	internal enum CryptoBinOps {
		Add,
		Xor,
		Xnor
	}

	internal class BinOp : CryptoElement {
		public BinOp()
			: base(2) { }

		public CryptoBinOps Operation { get; private set; }

		public override void Initialize(RandomGenerator random) {
			Operation = (CryptoBinOps)random.NextInt32(3);
		}

		public override void Emit(CipherGenContext context) {
			Expression a = context.GetDataExpression(DataIndexes[0]);
			Expression b = context.GetDataExpression(DataIndexes[1]);
			switch (Operation) {
				case CryptoBinOps.Add:
					context.Emit(new AssignmentStatement {
						Value = a + b,
						Target = a
					});
					break;
				case CryptoBinOps.Xor:
					context.Emit(new AssignmentStatement {
						Value = a ^ b,
						Target = a
					});
					break;
				case CryptoBinOps.Xnor:
					context.Emit(new AssignmentStatement {
						Value = ~(a ^ b),
						Target = a
					});
					break;
			}
		}

		public override void EmitInverse(CipherGenContext context) {
			Expression a = context.GetDataExpression(DataIndexes[0]);
			Expression b = context.GetDataExpression(DataIndexes[1]);
			switch (Operation) {
				case CryptoBinOps.Add:
					context.Emit(new AssignmentStatement {
						Value = a - b,
						Target = a
					});
					break;
				case CryptoBinOps.Xor:
					context.Emit(new AssignmentStatement {
						Value = a ^ b,
						Target = a
					});
					break;
				case CryptoBinOps.Xnor:
					context.Emit(new AssignmentStatement {
						Value = a ^ (~b),
						Target = a
					});
					break;
			}
		}
	}
}


================================================
File: Confuser.DynCipher/Elements/CryptoElement.cs
================================================
ï»¿using System;
using Confuser.Core.Services;
using Confuser.DynCipher.Generation;

namespace Confuser.DynCipher.Elements {
	internal abstract class CryptoElement {
		public CryptoElement(int count) {
			DataCount = count;
			DataIndexes = new int[count];
		}

		public int DataCount { get; private set; }
		public int[] DataIndexes { get; private set; }

		public abstract void Initialize(RandomGenerator random);
		public abstract void Emit(CipherGenContext context);
		public abstract void EmitInverse(CipherGenContext context);
	}
}


================================================
File: Confuser.DynCipher/Elements/Matrix.cs
================================================
ï»¿using System;
using Confuser.Core.Services;
using Confuser.DynCipher.AST;
using Confuser.DynCipher.Generation;

namespace Confuser.DynCipher.Elements {
	internal class Matrix : CryptoElement {
		public Matrix()
			: base(4) { }

		public uint[,] Key { get; private set; }
		public uint[,] InverseKey { get; private set; }

		static uint[,] GenerateUnimodularMatrix(RandomGenerator random) {
			Func<uint> next = () => (uint)random.NextInt32(4);

			uint[,] l = {
				{ 1, 0, 0, 0 },
				{ next(), 1, 0, 0 },
				{ next(), next(), 1, 0 },
				{ next(), next(), next(), 1 }
			};
			uint[,] u = {
				{ 1, next(), next(), next() },
				{ 0, 1, next(), next() },
				{ 0, 0, 1, next() },
				{ 0, 0, 0, 1 }
			};

			return mul(l, u);
		}

		static uint[,] mul(uint[,] a, uint[,] b) {
			int n = a.GetLength(0), p = b.GetLength(1);
			int m = a.GetLength(1);
			if (b.GetLength(0) != m) return null;

			var ret = new uint[n, p];
			for (int i = 0; i < n; i++)
				for (int j = 0; j < p; j++) {
					ret[i, j] = 0;
					for (int k = 0; k < m; k++)
						ret[i, j] += a[i, k] * b[k, j];
				}
			return ret;
		}

		static uint cofactor4(uint[,] mat, int i, int j) {
			var sub = new uint[3, 3];
			for (int ci = 0, si = 0; ci < 4; ci++, si++) {
				if (ci == i) {
					si--;
					continue;
				}
				for (int cj = 0, sj = 0; cj < 4; cj++, sj++) {
					if (cj == j) {
						sj--;
						continue;
					}
					sub[si, sj] = mat[ci, cj];
				}
			}
			uint ret = det3(sub);
			if ((i + j) % 2 == 0) return ret;
			return (uint)(-ret);
		}

		static uint det3(uint[,] mat) {
			return mat[0, 0] * mat[1, 1] * mat[2, 2] +
			       mat[0, 1] * mat[1, 2] * mat[2, 0] +
			       mat[0, 2] * mat[1, 0] * mat[2, 1] -
			       mat[0, 2] * mat[1, 1] * mat[2, 0] -
			       mat[0, 1] * mat[1, 0] * mat[2, 2] -
			       mat[0, 0] * mat[1, 2] * mat[2, 1];
		}

		static uint[,] transpose4(uint[,] mat) {
			var ret = new uint[4, 4];
			for (int i = 0; i < 4; i++)
				for (int j = 0; j < 4; j++)
					ret[j, i] = mat[i, j];
			return ret;
		}

		public override void Initialize(RandomGenerator random) {
			InverseKey = mul(transpose4(GenerateUnimodularMatrix(random)), GenerateUnimodularMatrix(random));

			var cof = new uint[4, 4];
			for (int i = 0; i < 4; i++)
				for (int j = 0; j < 4; j++)
					cof[i, j] = cofactor4(InverseKey, i, j);
			Key = transpose4(cof);
		}

		void EmitCore(CipherGenContext context, uint[,] k) {
			Expression a = context.GetDataExpression(DataIndexes[0]);
			Expression b = context.GetDataExpression(DataIndexes[1]);
			Expression c = context.GetDataExpression(DataIndexes[2]);
			Expression d = context.GetDataExpression(DataIndexes[3]);

			VariableExpression ta, tb, tc, td;

			Func<uint, LiteralExpression> l = v => (LiteralExpression)v;
			using (context.AcquireTempVar(out ta))
			using (context.AcquireTempVar(out tb))
			using (context.AcquireTempVar(out tc))
			using (context.AcquireTempVar(out td)) {
				context.Emit(new AssignmentStatement {
					Value = a * l(k[0, 0]) + b * l(k[0, 1]) + c * l(k[0, 2]) + d * l(k[0, 3]),
					Target = ta
				}).Emit(new AssignmentStatement {
					Value = a * l(k[1, 0]) + b * l(k[1, 1]) + c * l(k[1, 2]) + d * l(k[1, 3]),
					Target = tb
				}).Emit(new AssignmentStatement {
					Value = a * l(k[2, 0]) + b * l(k[2, 1]) + c * l(k[2, 2]) + d * l(k[2, 3]),
					Target = tc
				}).Emit(new AssignmentStatement {
					Value = a * l(k[3, 0]) + b * l(k[3, 1]) + c * l(k[3, 2]) + d * l(k[3, 3]),
					Target = td
				})
				       .Emit(new AssignmentStatement { Value = ta, Target = a })
				       .Emit(new AssignmentStatement { Value = tb, Target = b })
				       .Emit(new AssignmentStatement { Value = tc, Target = c })
				       .Emit(new AssignmentStatement { Value = td, Target = d });
			}
		}

		public override void Emit(CipherGenContext context) {
			EmitCore(context, Key);
		}

		public override void EmitInverse(CipherGenContext context) {
			EmitCore(context, InverseKey);
		}
	}
}


================================================
File: Confuser.DynCipher/Elements/NumOp.cs
================================================
ï»¿using System;
using Confuser.Core.Services;
using Confuser.DynCipher.AST;
using Confuser.DynCipher.Generation;

namespace Confuser.DynCipher.Elements {
	internal enum CryptoNumOps {
		Add,
		Mul,
		Xor,
		Xnor
	}

	internal class NumOp : CryptoElement {
		public NumOp()
			: base(1) { }

		public uint Key { get; private set; }
		public uint InverseKey { get; private set; }
		public CryptoNumOps Operation { get; private set; }

		public override void Initialize(RandomGenerator random) {
			Operation = (CryptoNumOps)(random.NextInt32(4));
			switch (Operation) {
				case CryptoNumOps.Add:
				case CryptoNumOps.Xor:
					Key = InverseKey = random.NextUInt32();
					break;
				case CryptoNumOps.Mul:
					Key = random.NextUInt32() | 1;
					InverseKey = MathsUtils.modInv(Key);
					break;
				case CryptoNumOps.Xnor:
					Key = random.NextUInt32();
					InverseKey = ~Key;
					break;
			}
		}

		public override void Emit(CipherGenContext context) {
			Expression val = context.GetDataExpression(DataIndexes[0]);
			switch (Operation) {
				case CryptoNumOps.Add:
					context.Emit(new AssignmentStatement {
						Value = val + (LiteralExpression)Key,
						Target = val
					});
					break;
				case CryptoNumOps.Xor:
					context.Emit(new AssignmentStatement {
						Value = val ^ (LiteralExpression)Key,
						Target = val
					});
					break;
				case CryptoNumOps.Mul:
					context.Emit(new AssignmentStatement {
						Value = val * (LiteralExpression)Key,
						Target = val
					});
					break;
				case CryptoNumOps.Xnor:
					context.Emit(new AssignmentStatement {
						Value = ~(val ^ (LiteralExpression)Key),
						Target = val
					});
					break;
			}
		}

		public override void EmitInverse(CipherGenContext context) {
			Expression val = context.GetDataExpression(DataIndexes[0]);
			switch (Operation) {
				case CryptoNumOps.Add:
					context.Emit(new AssignmentStatement {
						Value = val - (LiteralExpression)InverseKey,
						Target = val
					});
					break;
				case CryptoNumOps.Xor:
					context.Emit(new AssignmentStatement {
						Value = val ^ (LiteralExpression)InverseKey,
						Target = val
					});
					break;
				case CryptoNumOps.Mul:
					context.Emit(new AssignmentStatement {
						Value = val * (LiteralExpression)InverseKey,
						Target = val
					});
					break;
				case CryptoNumOps.Xnor:
					context.Emit(new AssignmentStatement {
						Value = val ^ (LiteralExpression)InverseKey,
						Target = val
					});
					break;
			}
		}
	}
}


================================================
File: Confuser.DynCipher/Elements/RotateBit.cs
================================================
ï»¿using System;
using Confuser.Core.Services;
using Confuser.DynCipher.AST;
using Confuser.DynCipher.Generation;

namespace Confuser.DynCipher.Elements {
	internal class RotateBit : CryptoElement {
		public RotateBit()
			: base(1) { }

		public int Bits { get; private set; }
		public bool IsAlternate { get; private set; }

		public override void Initialize(RandomGenerator random) {
			Bits = random.NextInt32(1, 32);
			IsAlternate = (random.NextInt32() % 2 == 0);
		}

		public override void Emit(CipherGenContext context) {
			Expression val = context.GetDataExpression(DataIndexes[0]);
			VariableExpression tmp;
			using (context.AcquireTempVar(out tmp)) {
				if (IsAlternate)
					context.Emit(new AssignmentStatement {
						Value = (val >> (32 - Bits)),
						Target = tmp
					}).Emit(new AssignmentStatement {
						Value = (val << Bits) | tmp,
						Target = val
					});
				else
					context.Emit(new AssignmentStatement {
						Value = (val << (32 - Bits)),
						Target = tmp
					}).Emit(new AssignmentStatement {
						Value = (val >> Bits) | tmp,
						Target = val
					});
			}
		}

		public override void EmitInverse(CipherGenContext context) {
			Expression val = context.GetDataExpression(DataIndexes[0]);
			VariableExpression tmp;
			using (context.AcquireTempVar(out tmp)) {
				if (IsAlternate)
					context.Emit(new AssignmentStatement {
						Value = (val << (32 - Bits)),
						Target = tmp
					}).Emit(new AssignmentStatement {
						Value = (val >> Bits) | tmp,
						Target = val
					});
				else
					context.Emit(new AssignmentStatement {
						Value = (val >> (32 - Bits)),
						Target = tmp
					}).Emit(new AssignmentStatement {
						Value = (val << Bits) | tmp,
						Target = val
					});
			}
		}
	}
}


================================================
File: Confuser.DynCipher/Elements/Swap.cs
================================================
ï»¿using System;
using Confuser.Core.Services;
using Confuser.DynCipher.AST;
using Confuser.DynCipher.Generation;

namespace Confuser.DynCipher.Elements {
	internal class Swap : CryptoElement {
		public Swap()
			: base(2) { }

		public uint Mask { get; private set; }
		public uint Key { get; private set; }

		public override void Initialize(RandomGenerator random) {
			if (random.NextInt32(3) == 0)
				Mask = 0xffffffff;
			else
				Mask = random.NextUInt32();
			Key = random.NextUInt32() | 1;
		}

		void EmitCore(CipherGenContext context) {
			Expression a = context.GetDataExpression(DataIndexes[0]);
			Expression b = context.GetDataExpression(DataIndexes[1]);
			VariableExpression tmp;

			if (Mask == 0xffffffff) {
				/*  t = a * k;
                    a = b;
                    b = t * k^-1;
                 */
				using (context.AcquireTempVar(out tmp)) {
					context.Emit(new AssignmentStatement {
						Value = a * (LiteralExpression)Key,
						Target = tmp
					}).Emit(new AssignmentStatement {
						Value = b,
						Target = a
					}).Emit(new AssignmentStatement {
						Value = tmp * (LiteralExpression)MathsUtils.modInv(Key),
						Target = b
					});
				}
			}
			else {
				var mask = (LiteralExpression)Mask;
				var notMask = (LiteralExpression)~Mask;
				/*  t = (a & mask) * k;
                    a = a & (~mask) | (b & mask);
                    b = b & (~mask) | (t * k^-1);
                 */
				using (context.AcquireTempVar(out tmp)) {
					context.Emit(new AssignmentStatement {
						Value = (a & mask) * (LiteralExpression)Key,
						Target = tmp
					}).Emit(new AssignmentStatement {
						Value = (a & notMask) | (b & mask),
						Target = a
					}).Emit(new AssignmentStatement {
						Value = (b & notMask) | (tmp * (LiteralExpression)MathsUtils.modInv(Key)),
						Target = b
					});
				}
			}
		}

		public override void Emit(CipherGenContext context) {
			EmitCore(context);
		}

		public override void EmitInverse(CipherGenContext context) {
			EmitCore(context);
		}
	}
}


================================================
File: Confuser.DynCipher/Generation/CILCodeGen.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using Confuser.DynCipher.AST;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.DynCipher.Generation {
	public class CILCodeGen {
		readonly Dictionary<string, Local> localMap = new Dictionary<string, Local>();

		public CILCodeGen(MethodDef method, IList<Instruction> instrs) {
			Method = method;
			Instructions = instrs;
		}

		public MethodDef Method { get; private set; }
		public IList<Instruction> Instructions { get; private set; }

		protected void Emit(Instruction instr) {
			Instructions.Add(instr);
		}

		protected virtual Local Var(Variable var) {
			Local ret;
			if (!localMap.TryGetValue(var.Name, out ret)) {
				ret = new Local(Method.Module.CorLibTypes.UInt32);
				ret.Name = var.Name;
				localMap[var.Name] = ret;
			}
			return ret;
		}

		protected virtual void LoadVar(Variable var) {
			Emit(Instruction.Create(OpCodes.Ldloc, Var(var)));
		}

		protected virtual void StoreVar(Variable var) {
			Emit(Instruction.Create(OpCodes.Stloc, Var(var)));
		}

		public void Commit(CilBody body) {
			foreach (Local i in localMap.Values) {
				body.InitLocals = true;
				body.Variables.Add(i);
			}
		}


		public void GenerateCIL(Expression expression) {
			EmitLoad(expression);
		}

		public void GenerateCIL(Statement statement) {
			EmitStatement(statement);
		}

		void EmitLoad(Expression exp) {
			if (exp is ArrayIndexExpression) {
				var arrIndex = (ArrayIndexExpression)exp;
				EmitLoad(arrIndex.Array);
				Emit(Instruction.CreateLdcI4(arrIndex.Index));
				Emit(Instruction.Create(OpCodes.Ldelem_U4));
			}
			else if (exp is BinOpExpression) {
				var binOp = (BinOpExpression)exp;
				EmitLoad(binOp.Left);
				EmitLoad(binOp.Right);
				OpCode op;
				switch (binOp.Operation) {
					case BinOps.Add:
						op = OpCodes.Add;
						break;
					case BinOps.Sub:
						op = OpCodes.Sub;
						break;
					case BinOps.Div:
						op = OpCodes.Div;
						break;
					case BinOps.Mul:
						op = OpCodes.Mul;
						break;
					case BinOps.Or:
						op = OpCodes.Or;
						break;
					case BinOps.And:
						op = OpCodes.And;
						break;
					case BinOps.Xor:
						op = OpCodes.Xor;
						break;
					case BinOps.Lsh:
						op = OpCodes.Shl;
						break;
					case BinOps.Rsh:
						op = OpCodes.Shr_Un;
						break;
					default:
						throw new NotSupportedException();
				}
				Emit(Instruction.Create(op));
			}
			else if (exp is UnaryOpExpression) {
				var unaryOp = (UnaryOpExpression)exp;
				EmitLoad(unaryOp.Value);
				OpCode op;
				switch (unaryOp.Operation) {
					case UnaryOps.Not:
						op = OpCodes.Not;
						break;
					case UnaryOps.Negate:
						op = OpCodes.Neg;
						break;
					default:
						throw new NotSupportedException();
				}
				Emit(Instruction.Create(op));
			}
			else if (exp is LiteralExpression) {
				var literal = (LiteralExpression)exp;
				Emit(Instruction.CreateLdcI4((int)literal.Value));
			}
			else if (exp is VariableExpression) {
				var var = (VariableExpression)exp;
				LoadVar(var.Variable);
			}
			else
				throw new NotSupportedException();
		}

		void EmitStore(Expression exp, Expression value) {
			if (exp is ArrayIndexExpression) {
				var arrIndex = (ArrayIndexExpression)exp;
				EmitLoad(arrIndex.Array);
				Emit(Instruction.CreateLdcI4(arrIndex.Index));
				EmitLoad(value);
				Emit(Instruction.Create(OpCodes.Stelem_I4));
			}
			else if (exp is VariableExpression) {
				var var = (VariableExpression)exp;
				EmitLoad(value);
				StoreVar(var.Variable);
			}
			else
				throw new NotSupportedException();
		}

		void EmitStatement(Statement statement) {
			if (statement is AssignmentStatement) {
				var assignment = (AssignmentStatement)statement;
				EmitStore(assignment.Target, assignment.Value);
			}
			else if (statement is LoopStatement) {
				var loop = (LoopStatement)statement;
				/*
                 *      ldc.i4  begin
                 *      br      cmp
                 *      ldc.i4  dummy   //hint for dnlib
                 * lop: nop
                 *      ...
                 *      ...
                 *      ldc.i4.1
                 *      add
                 * cmp: dup
                 *      ldc.i4  limit
                 *      blt     lop
                 *      pop
                 */
				Instruction lbl = Instruction.Create(OpCodes.Nop);
				Instruction dup = Instruction.Create(OpCodes.Dup);
				Emit(Instruction.CreateLdcI4(loop.Begin));
				Emit(Instruction.Create(OpCodes.Br, dup));
				Emit(Instruction.CreateLdcI4(loop.Begin));
				Emit(lbl);

				foreach (Statement child in loop.Statements)
					EmitStatement(child);

				Emit(Instruction.CreateLdcI4(1));
				Emit(Instruction.Create(OpCodes.Add));
				Emit(dup);
				Emit(Instruction.CreateLdcI4(loop.Limit));
				Emit(Instruction.Create(OpCodes.Blt, lbl));
				Emit(Instruction.Create(OpCodes.Pop));
			}
			else if (statement is StatementBlock) {
				foreach (Statement child in ((StatementBlock)statement).Statements)
					EmitStatement(child);
			}
			else
				throw new NotSupportedException();
		}
	}
}


================================================
File: Confuser.DynCipher/Generation/CipherGenContext.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using Confuser.Core.Services;
using Confuser.DynCipher.AST;

namespace Confuser.DynCipher.Generation {
	internal class CipherGenContext {
		readonly Variable[] dataVars;
		readonly Variable keyVar = new Variable("{KEY}");
		readonly RandomGenerator random;
		readonly List<Variable> tempVars = new List<Variable>();
		int tempVarCounter;

		public CipherGenContext(RandomGenerator random, int dataVarCount) {
			this.random = random;
			Block = new StatementBlock(); // new LoopStatement() { Begin = 0, Limit = 4 };
			dataVars = new Variable[dataVarCount];
			for (int i = 0; i < dataVarCount; i++)
				dataVars[i] = new Variable("v" + i) { Tag = i };
		}

		public StatementBlock Block { get; private set; }

		public Expression GetDataExpression(int index) {
			return new VariableExpression { Variable = dataVars[index] };
		}

		public Expression GetKeyExpression(int index) {
			return new ArrayIndexExpression {
				Array = new VariableExpression { Variable = keyVar },
				Index = index
			};
		}

		public CipherGenContext Emit(Statement statement) {
			Block.Statements.Add(statement);
			return this;
		}

		public IDisposable AcquireTempVar(out VariableExpression exp) {
			Variable var;
			if (tempVars.Count == 0)
				var = new Variable("t" + tempVarCounter++);
			else {
				var = tempVars[random.NextInt32(tempVars.Count)];
				tempVars.Remove(var);
			}
			exp = new VariableExpression { Variable = var };
			return new TempVarHolder(this, var);
		}

		struct TempVarHolder : IDisposable {
			readonly CipherGenContext parent;
			readonly Variable tempVar;

			public TempVarHolder(CipherGenContext p, Variable v) {
				parent = p;
				tempVar = v;
			}

			public void Dispose() {
				parent.tempVars.Add(tempVar);
			}
		}
	}
}


================================================
File: Confuser.DynCipher/Generation/CipherGenerator.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using Confuser.Core.Services;
using Confuser.DynCipher.AST;
using Confuser.DynCipher.Elements;
using Confuser.DynCipher.Transforms;

namespace Confuser.DynCipher.Generation {
	internal class CipherGenerator {
		const int MAT_RATIO = 4;
		const int NUMOP_RATIO = 10;
		const int SWAP_RATIO = 6;
		const int BINOP_RATIO = 9;
		const int ROTATE_RATIO = 6;
		const int RATIO_SUM = MAT_RATIO + NUMOP_RATIO + SWAP_RATIO + BINOP_RATIO + ROTATE_RATIO;
		const double VARIANCE = 0.2;


		static void Shuffle<T>(RandomGenerator random, IList<T> arr) {
			for (int i = 1; i < arr.Count; i++) {
				int j = random.NextInt32(i + 1);
				T tmp = arr[i];
				arr[i] = arr[j];
				arr[j] = tmp;
			}
		}

		static void PostProcessStatements(StatementBlock block, RandomGenerator random) {
			MulToShiftTransform.Run(block);
			NormalizeBinOpTransform.Run(block);
			ExpansionTransform.Run(block);
			ShuffleTransform.Run(block, random);
			ConvertVariables.Run(block);
		}

		public static void GeneratePair(RandomGenerator random, out StatementBlock encrypt, out StatementBlock decrypt) {
			double varPrecentage = 1 + ((random.NextDouble() * 2) - 1) * VARIANCE;
			var totalElements = (int)(((random.NextDouble() + 1) * RATIO_SUM) * varPrecentage);

			var elems = new List<CryptoElement>();
			for (int i = 0; i < totalElements * MAT_RATIO / RATIO_SUM; i++)
				elems.Add(new Matrix());
			for (int i = 0; i < totalElements * NUMOP_RATIO / RATIO_SUM; i++)
				elems.Add(new NumOp());
			for (int i = 0; i < totalElements * SWAP_RATIO / RATIO_SUM; i++)
				elems.Add(new Swap());
			for (int i = 0; i < totalElements * BINOP_RATIO / RATIO_SUM; i++)
				elems.Add(new BinOp());
			for (int i = 0; i < totalElements * ROTATE_RATIO / RATIO_SUM; i++)
				elems.Add(new RotateBit());
			for (int i = 0; i < 16; i++)
				elems.Add(new AddKey(i));
			Shuffle(random, elems);


			int[] x = Enumerable.Range(0, 16).ToArray();
			int index = 16;
			bool overdue = false;
			foreach (CryptoElement elem in elems) {
				elem.Initialize(random);
				for (int i = 0; i < elem.DataCount; i++) {
					if (index == 16) {
						overdue = true; // Can't shuffle now to prevent duplication
						index = 0;
					}
					elem.DataIndexes[i] = x[index++];
				}
				if (overdue) {
					Shuffle(random, x);
					index = 0;
					overdue = false;
				}
			}

			var encryptContext = new CipherGenContext(random, 16);
			foreach (CryptoElement elem in elems)
				elem.Emit(encryptContext);
			encrypt = encryptContext.Block;
			PostProcessStatements(encrypt, random);


			var decryptContext = new CipherGenContext(random, 16);
			foreach (CryptoElement elem in Enumerable.Reverse(elems))
				elem.EmitInverse(decryptContext);
			decrypt = decryptContext.Block;
			PostProcessStatements(decrypt, random);
		}
	}
}


================================================
File: Confuser.DynCipher/Generation/DMCodeGen.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection.Emit;
using Confuser.DynCipher.AST;

namespace Confuser.DynCipher.Generation {
	public class DMCodeGen {
		readonly DynamicMethod dm;
		readonly ILGenerator ilGen;

		readonly Dictionary<string, LocalBuilder> localMap = new Dictionary<string, LocalBuilder>();
		readonly Dictionary<string, int> paramMap;

		public DMCodeGen(Type returnType, Tuple<string, Type>[] parameters) {
			dm = new DynamicMethod("", returnType, parameters.Select(param => param.Item2).ToArray(), true);
			paramMap = new Dictionary<string, int>();
			for (int i = 0; i < parameters.Length; i++)
				paramMap.Add(parameters[i].Item1, i);
			ilGen = dm.GetILGenerator();
		}

		protected virtual LocalBuilder Var(Variable var) {
			LocalBuilder ret;
			if (!localMap.TryGetValue(var.Name, out ret)) {
				ret = ilGen.DeclareLocal(typeof(int));
				localMap[var.Name] = ret;
			}
			return ret;
		}

		protected virtual void LoadVar(Variable var) {
			if (paramMap.ContainsKey(var.Name))
				ilGen.Emit(OpCodes.Ldarg, paramMap[var.Name]);
			else
				ilGen.Emit(OpCodes.Ldloc, Var(var));
		}

		protected virtual void StoreVar(Variable var) {
			if (paramMap.ContainsKey(var.Name))
				ilGen.Emit(OpCodes.Starg, paramMap[var.Name]);
			else
				ilGen.Emit(OpCodes.Stloc, Var(var));
		}

		public T Compile<T>() {
			ilGen.Emit(OpCodes.Ret);
			return (T)(object)dm.CreateDelegate(typeof(T));
		}


		public DMCodeGen GenerateCIL(Expression expression) {
			EmitLoad(expression);
			return this;
		}

		public DMCodeGen GenerateCIL(Statement statement) {
			EmitStatement(statement);
			return this;
		}

		void EmitLoad(Expression exp) {
			if (exp is ArrayIndexExpression) {
				var arrIndex = (ArrayIndexExpression)exp;
				EmitLoad(arrIndex.Array);
				ilGen.Emit(OpCodes.Ldc_I4, arrIndex.Index);
				ilGen.Emit(OpCodes.Ldelem_U4);
			}
			else if (exp is BinOpExpression) {
				var binOp = (BinOpExpression)exp;
				EmitLoad(binOp.Left);
				EmitLoad(binOp.Right);
				OpCode op;
				switch (binOp.Operation) {
					case BinOps.Add:
						op = OpCodes.Add;
						break;
					case BinOps.Sub:
						op = OpCodes.Sub;
						break;
					case BinOps.Div:
						op = OpCodes.Div;
						break;
					case BinOps.Mul:
						op = OpCodes.Mul;
						break;
					case BinOps.Or:
						op = OpCodes.Or;
						break;
					case BinOps.And:
						op = OpCodes.And;
						break;
					case BinOps.Xor:
						op = OpCodes.Xor;
						break;
					case BinOps.Lsh:
						op = OpCodes.Shl;
						break;
					case BinOps.Rsh:
						op = OpCodes.Shr_Un;
						break;
					default:
						throw new NotSupportedException();
				}
				ilGen.Emit(op);
			}
			else if (exp is UnaryOpExpression) {
				var unaryOp = (UnaryOpExpression)exp;
				EmitLoad(unaryOp.Value);
				OpCode op;
				switch (unaryOp.Operation) {
					case UnaryOps.Not:
						op = OpCodes.Not;
						break;
					case UnaryOps.Negate:
						op = OpCodes.Neg;
						break;
					default:
						throw new NotSupportedException();
				}
				ilGen.Emit(op);
			}
			else if (exp is LiteralExpression) {
				var literal = (LiteralExpression)exp;
				ilGen.Emit(OpCodes.Ldc_I4, (int)literal.Value);
			}
			else if (exp is VariableExpression) {
				var var = (VariableExpression)exp;
				LoadVar(var.Variable);
			}
			else
				throw new NotSupportedException();
		}

		void EmitStore(Expression exp, Expression value) {
			if (exp is ArrayIndexExpression) {
				var arrIndex = (ArrayIndexExpression)exp;
				EmitLoad(arrIndex.Array);
				ilGen.Emit(OpCodes.Ldc_I4, arrIndex.Index);
				EmitLoad(value);
				ilGen.Emit(OpCodes.Stelem_I4);
			}
			else if (exp is VariableExpression) {
				var var = (VariableExpression)exp;
				EmitLoad(value);
				StoreVar(var.Variable);
			}
			else
				throw new NotSupportedException();
		}

		void EmitStatement(Statement statement) {
			if (statement is AssignmentStatement) {
				var assignment = (AssignmentStatement)statement;
				EmitStore(assignment.Target, assignment.Value);
			}
			else if (statement is LoopStatement) {
				var loop = (LoopStatement)statement;
				/*
                 *      ldc.i4  begin
                 *      br      cmp
                 *      ldc.i4  dummy   //hint for dnlib
                 * lop: nop
                 *      ...
                 *      ...
                 *      ldc.i4.1
                 *      add
                 * cmp: dup
                 *      ldc.i4  limit
                 *      blt     lop
                 *      pop
                 */
				Label lbl = ilGen.DefineLabel();
				Label dup = ilGen.DefineLabel();
				ilGen.Emit(OpCodes.Ldc_I4, loop.Begin);
				ilGen.Emit(OpCodes.Br, dup);
				ilGen.Emit(OpCodes.Ldc_I4, loop.Begin);
				ilGen.MarkLabel(lbl);

				foreach (Statement child in loop.Statements)
					EmitStatement(child);

				ilGen.Emit(OpCodes.Ldc_I4_1);
				ilGen.Emit(OpCodes.Add);
				ilGen.MarkLabel(dup);
				ilGen.Emit(OpCodes.Dup);
				ilGen.Emit(OpCodes.Ldc_I4, loop.Limit);
				ilGen.Emit(OpCodes.Blt, lbl);
				ilGen.Emit(OpCodes.Pop);
			}
			else if (statement is StatementBlock) {
				foreach (Statement child in ((StatementBlock)statement).Statements)
					EmitStatement(child);
			}
			else
				throw new NotSupportedException();
		}
	}
}


================================================
File: Confuser.DynCipher/Generation/ExpressionGenerator.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Diagnostics;
using Confuser.Core;
using Confuser.Core.Services;
using Confuser.DynCipher.AST;

namespace Confuser.DynCipher.Generation {
	internal class ExpressionGenerator {
		static Expression GenerateExpression(RandomGenerator random, Expression current, int currentDepth, int targetDepth) {
			if (currentDepth == targetDepth || (currentDepth > targetDepth / 3 && random.NextInt32(100) > 85))
				return current;

			switch ((ExpressionOps)random.NextInt32(6)) {
				case ExpressionOps.Add:
					return GenerateExpression(random, current, currentDepth + 1, targetDepth) +
					       GenerateExpression(random, (LiteralExpression)random.NextUInt32(), currentDepth + 1, targetDepth);

				case ExpressionOps.Sub:
					return GenerateExpression(random, current, currentDepth + 1, targetDepth) -
					       GenerateExpression(random, (LiteralExpression)random.NextUInt32(), currentDepth + 1, targetDepth);

				case ExpressionOps.Mul:
					return GenerateExpression(random, current, currentDepth + 1, targetDepth) * (LiteralExpression)(random.NextUInt32() | 1);

				case ExpressionOps.Xor:
					return GenerateExpression(random, current, currentDepth + 1, targetDepth) ^
					       GenerateExpression(random, (LiteralExpression)random.NextUInt32(), currentDepth + 1, targetDepth);

				case ExpressionOps.Not:
					return ~GenerateExpression(random, current, currentDepth + 1, targetDepth);

				case ExpressionOps.Neg:
					return -GenerateExpression(random, current, currentDepth + 1, targetDepth);
			}
			throw new UnreachableException();
		}

		static void SwapOperands(RandomGenerator random, Expression exp) {
			if (exp is BinOpExpression) {
				var binExp = (BinOpExpression)exp;
				if (random.NextBoolean()) {
					Expression tmp = binExp.Left;
					binExp.Left = binExp.Right;
					binExp.Right = tmp;
				}
				SwapOperands(random, binExp.Left);
				SwapOperands(random, binExp.Right);
			}
			else if (exp is UnaryOpExpression)
				SwapOperands(random, ((UnaryOpExpression)exp).Value);
			else if (exp is LiteralExpression || exp is VariableExpression)
				return;
			else
				throw new UnreachableException();
		}

		static bool HasVariable(Expression exp, Dictionary<Expression, bool> hasVar) {
			bool ret;
			if (!hasVar.TryGetValue(exp, out ret)) {
				if (exp is VariableExpression)
					ret = true;
				else if (exp is LiteralExpression)
					ret = false;
				else if (exp is BinOpExpression) {
					var binExp = (BinOpExpression)exp;
					ret = HasVariable(binExp.Left, hasVar) || HasVariable(binExp.Right, hasVar);
				}
				else if (exp is UnaryOpExpression) {
					ret = HasVariable(((UnaryOpExpression)exp).Value, hasVar);
				}
				else
					throw new UnreachableException();
				hasVar[exp] = ret;
			}
			return ret;
		}

		static Expression GenerateInverse(Expression exp, Expression var, Dictionary<Expression, bool> hasVar) {
			Expression result = var;
			while (!(exp is VariableExpression)) {
				Debug.Assert(hasVar[exp]);
				if (exp is UnaryOpExpression) {
					var unaryOp = (UnaryOpExpression)exp;
					result = new UnaryOpExpression {
						Operation = unaryOp.Operation,
						Value = result
					};
					exp = unaryOp.Value;
				}
				else if (exp is BinOpExpression) {
					var binOp = (BinOpExpression)exp;
					bool leftHasVar = hasVar[binOp.Left];
					Expression varExp = leftHasVar ? binOp.Left : binOp.Right;
					Expression constExp = leftHasVar ? binOp.Right : binOp.Left;

					if (binOp.Operation == BinOps.Add)
						result = new BinOpExpression {
							Operation = BinOps.Sub,
							Left = result,
							Right = constExp
						};

					else if (binOp.Operation == BinOps.Sub) {
						if (leftHasVar) {
							// v - k = r => v = r + k
							result = new BinOpExpression {
								Operation = BinOps.Add,
								Left = result,
								Right = constExp
							};
						}
						else {
							// k - v = r => v = k - r
							result = new BinOpExpression {
								Operation = BinOps.Sub,
								Left = constExp,
								Right = result
							};
						}
					}
					else if (binOp.Operation == BinOps.Mul) {
						Debug.Assert(constExp is LiteralExpression);
						uint val = ((LiteralExpression)constExp).Value;
						val = MathsUtils.modInv(val);
						result = new BinOpExpression {
							Operation = BinOps.Mul,
							Left = result,
							Right = (LiteralExpression)val
						};
					}
					else if (binOp.Operation == BinOps.Xor)
						result = new BinOpExpression {
							Operation = BinOps.Xor,
							Left = result,
							Right = constExp
						};

					exp = varExp;
				}
			}
			return result;
		}

		public static void GeneratePair(RandomGenerator random, Expression var, Expression result, int depth, out Expression expression, out Expression inverse) {
			expression = GenerateExpression(random, var, 0, depth);
			SwapOperands(random, expression);

			var hasVar = new Dictionary<Expression, bool>();
			HasVariable(expression, hasVar);

			inverse = GenerateInverse(expression, result, hasVar);
		}

		enum ExpressionOps {
			Add,
			Sub,
			Mul,
			Xor,
			Not,
			Neg
		}
	}
}


================================================
File: Confuser.DynCipher/Generation/x86CodeGen.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using Confuser.DynCipher.AST;

namespace Confuser.DynCipher.Generation {
	public class x86CodeGen {
		List<x86Instruction> instrs;
		bool[] usedRegs;

		public IList<x86Instruction> Instructions {
			get { return instrs; }
		}

		public int MaxUsedRegister { get; private set; }

		public x86Register? GenerateX86(Expression expression, Func<Variable, x86Register, IEnumerable<x86Instruction>> loadArg) {
			instrs = new List<x86Instruction>();
			usedRegs = new bool[8];
			MaxUsedRegister = -1;

			// CRITICAL registers!
			usedRegs[(int)x86Register.EBP] = true;
			usedRegs[(int)x86Register.ESP] = true;

			try {
				return ((x86RegisterOperand)Emit(expression, loadArg)).Register;
			}
			catch (Exception ex) {
				if (ex.Message == "Register overflowed.")
					return null;
				throw;
			}
		}

		x86Register GetFreeRegister() {
			for (int i = 0; i < 8; i++)
				if (!usedRegs[i])
					return (x86Register)i;

			throw new Exception("Register overflowed.");
		}

		void TakeRegister(x86Register reg) {
			usedRegs[(int)reg] = true;
			if ((int)reg > MaxUsedRegister)
				MaxUsedRegister = (int)reg;
		}

		void ReleaseRegister(x86Register reg) {
			usedRegs[(int)reg] = false;
		}

		x86Register Normalize(x86Instruction instr) {
			if (instr.Operands.Length == 2 &&
			    instr.Operands[0] is x86ImmediateOperand &&
			    instr.Operands[1] is x86ImmediateOperand) {
				/*
                 * op imm1, imm2
                 * ==>
                 * mov reg, imm1
                 * op reg, imm2
                 */
				x86Register reg = GetFreeRegister();
				instrs.Add(x86Instruction.Create(x86OpCode.MOV, new x86RegisterOperand(reg), instr.Operands[0]));
				instr.Operands[0] = new x86RegisterOperand(reg);
				instrs.Add(instr);

				return reg;
			}

			if (instr.Operands.Length == 1 &&
			    instr.Operands[0] is x86ImmediateOperand) {
				/*
                 * op imm
                 * ==>
                 * mov reg, imm
                 * op reg
                 */
				x86Register reg = GetFreeRegister();
				instrs.Add(x86Instruction.Create(x86OpCode.MOV, new x86RegisterOperand(reg), instr.Operands[0]));
				instr.Operands[0] = new x86RegisterOperand(reg);
				instrs.Add(instr);

				return reg;
			}

			if (instr.OpCode == x86OpCode.SUB &&
			    instr.Operands[0] is x86ImmediateOperand &&
			    instr.Operands[1] is x86RegisterOperand) {
				/*
                 * sub imm, reg
                 * ==>
                 * neg reg
                 * add reg, imm
                 */

				x86Register reg = ((x86RegisterOperand)instr.Operands[1]).Register;
				instrs.Add(x86Instruction.Create(x86OpCode.NEG, new x86RegisterOperand(reg)));
				instr.OpCode = x86OpCode.ADD;
				instr.Operands[1] = instr.Operands[0];
				instr.Operands[0] = new x86RegisterOperand(reg);
				instrs.Add(instr);

				return reg;
			}

			if (instr.Operands.Length == 2 &&
			    instr.Operands[0] is x86ImmediateOperand &&
			    instr.Operands[1] is x86RegisterOperand) {
				/*
                 * op imm, reg
                 * ==>
                 * op reg, imm
                 */

				x86Register reg = ((x86RegisterOperand)instr.Operands[1]).Register;
				instr.Operands[1] = instr.Operands[0];
				instr.Operands[0] = new x86RegisterOperand(reg);
				instrs.Add(instr);

				return reg;
			}
			Debug.Assert(instr.Operands.Length > 0);
			Debug.Assert(instr.Operands[0] is x86RegisterOperand);

			if (instr.Operands.Length == 2 && instr.Operands[1] is x86RegisterOperand)
				ReleaseRegister(((x86RegisterOperand)instr.Operands[1]).Register);

			instrs.Add(instr);

			return ((x86RegisterOperand)instr.Operands[0]).Register;
		}

		Ix86Operand Emit(Expression exp, Func<Variable, x86Register, IEnumerable<x86Instruction>> loadArg) {
			if (exp is BinOpExpression) {
				var binOp = (BinOpExpression)exp;
				x86Register reg;
				switch (binOp.Operation) {
					case BinOps.Add:
						reg = Normalize(x86Instruction.Create(x86OpCode.ADD, Emit(binOp.Left, loadArg), Emit(binOp.Right, loadArg)));
						break;

					case BinOps.Sub:
						reg = Normalize(x86Instruction.Create(x86OpCode.SUB, Emit(binOp.Left, loadArg), Emit(binOp.Right, loadArg)));
						break;

					case BinOps.Mul:
						reg = Normalize(x86Instruction.Create(x86OpCode.IMUL, Emit(binOp.Left, loadArg), Emit(binOp.Right, loadArg)));
						break;

					case BinOps.Xor:
						reg = Normalize(x86Instruction.Create(x86OpCode.XOR, Emit(binOp.Left, loadArg), Emit(binOp.Right, loadArg)));
						break;

					default:
						throw new NotSupportedException();
				}
				TakeRegister(reg);
				return new x86RegisterOperand(reg);
			}

			if (exp is UnaryOpExpression) {
				var unaryOp = (UnaryOpExpression)exp;
				x86Register reg;
				switch (unaryOp.Operation) {
					case UnaryOps.Negate:
						reg = Normalize(x86Instruction.Create(x86OpCode.NEG, Emit(unaryOp.Value, loadArg)));
						break;

					case UnaryOps.Not:
						reg = Normalize(x86Instruction.Create(x86OpCode.NOT, Emit(unaryOp.Value, loadArg)));
						break;

					default:
						throw new NotSupportedException();
				}
				TakeRegister(reg);
				return new x86RegisterOperand(reg);
			}

			if (exp is LiteralExpression)
				return new x86ImmediateOperand((int)((LiteralExpression)exp).Value);

			if (exp is VariableExpression) {
				x86Register reg = GetFreeRegister();
				TakeRegister(reg);
				instrs.AddRange(loadArg(((VariableExpression)exp).Variable, reg));
				return new x86RegisterOperand(reg);
			}

			throw new NotSupportedException();
		}

		public override string ToString() {
			return string.Join("\r\n", instrs.Select(instr => instr.ToString()).ToArray());
		}
	}

	public enum x86OpCode {
		MOV,
		ADD,
		SUB,
		IMUL,
		DIV,
		NEG,
		NOT,
		XOR,
		POP
	}

	public enum x86Register {
		EAX,
		ECX,
		EDX,
		EBX,
		ESP,
		EBP,
		ESI,
		EDI
	}

	public interface Ix86Operand { }

	public class x86RegisterOperand : Ix86Operand {
		public x86RegisterOperand(x86Register reg) {
			Register = reg;
		}

		public x86Register Register { get; set; }

		public override string ToString() {
			return Register.ToString();
		}
	}

	public class x86ImmediateOperand : Ix86Operand {
		public x86ImmediateOperand(int imm) {
			Immediate = imm;
		}

		public int Immediate { get; set; }

		public override string ToString() {
			return Immediate.ToString("X") + "h";
		}
	}

	public class x86Instruction {
		public x86OpCode OpCode { get; set; }
		public Ix86Operand[] Operands { get; set; }

		public static x86Instruction Create(x86OpCode opCode, params Ix86Operand[] operands) {
			var ret = new x86Instruction();
			ret.OpCode = opCode;
			ret.Operands = operands;
			return ret;
		}

		public byte[] Assemble() {
			switch (OpCode) {
				case x86OpCode.MOV: {
					if (Operands.Length != 2) throw new InvalidOperationException();
					if (Operands[0] is x86RegisterOperand &&
					    Operands[1] is x86RegisterOperand) {
						var ret = new byte[2];
						ret[0] = 0x89;
						ret[1] = 0xc0;
						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);
						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);
						return ret;
					}
					if (Operands[0] is x86RegisterOperand &&
					    Operands[1] is x86ImmediateOperand) {
						var ret = new byte[5];
						ret[0] = 0xb8;
						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);
						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate), 0, ret, 1, 4);
						return ret;
					}
					throw new NotSupportedException();
				}

				case x86OpCode.ADD: {
					if (Operands.Length != 2) throw new InvalidOperationException();
					if (Operands[0] is x86RegisterOperand &&
					    Operands[1] is x86RegisterOperand) {
						var ret = new byte[2];
						ret[0] = 0x01;
						ret[1] = 0xc0;
						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);
						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);
						return ret;
					}
					if (Operands[0] is x86RegisterOperand &&
					    Operands[1] is x86ImmediateOperand) {
						var ret = new byte[6];
						ret[0] = 0x81;
						ret[1] = 0xc0;
						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);
						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate), 0, ret, 2, 4);
						return ret;
					}
					throw new NotSupportedException();
				}

				case x86OpCode.SUB: {
					if (Operands.Length != 2) throw new InvalidOperationException();
					if (Operands[0] is x86RegisterOperand &&
					    Operands[1] is x86RegisterOperand) {
						var ret = new byte[2];
						ret[0] = 0x29;
						ret[1] = 0xc0;
						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);
						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);
						return ret;
					}
					if (Operands[0] is x86RegisterOperand &&
					    Operands[1] is x86ImmediateOperand) {
						var ret = new byte[6];
						ret[0] = 0x81;
						ret[1] = 0xe8;
						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);
						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate), 0, ret, 2, 4);
						return ret;
					}
					throw new NotSupportedException();
				}

				case x86OpCode.NEG: {
					if (Operands.Length != 1) throw new InvalidOperationException();
					if (Operands[0] is x86RegisterOperand) {
						var ret = new byte[2];
						ret[0] = 0xf7;
						ret[1] = 0xd8;
						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);
						return ret;
					}
					throw new NotSupportedException();
				}

				case x86OpCode.NOT: {
					if (Operands.Length != 1) throw new InvalidOperationException();
					if (Operands[0] is x86RegisterOperand) {
						var ret = new byte[2];
						ret[0] = 0xf7;
						ret[1] = 0xd0;
						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);
						return ret;
					}
					throw new NotSupportedException();
				}

				case x86OpCode.XOR: {
					if (Operands.Length != 2) throw new InvalidOperationException();
					if (Operands[0] is x86RegisterOperand &&
					    Operands[1] is x86RegisterOperand) {
						var ret = new byte[2];
						ret[0] = 0x31;
						ret[1] = 0xc0;
						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);
						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);
						return ret;
					}
					if (Operands[0] is x86RegisterOperand &&
					    Operands[1] is x86ImmediateOperand) {
						var ret = new byte[6];
						ret[0] = 0x81;
						ret[1] = 0xf0;
						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);
						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate), 0, ret, 2, 4);
						return ret;
					}
					throw new NotSupportedException();
				}

				case x86OpCode.POP: {
					if (Operands.Length != 1) throw new InvalidOperationException();
					if (Operands[0] is x86RegisterOperand) {
						var ret = new byte[1];
						ret[0] = 0x58;
						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);
						return ret;
					}
					throw new NotSupportedException();
				}

				case x86OpCode.IMUL: {
					if (Operands.Length != 2) throw new InvalidOperationException();
					if (Operands[0] is x86RegisterOperand &&
					    Operands[1] is x86RegisterOperand) {
						var ret = new byte[3];
						ret[0] = 0x0f;
						ret[1] = 0xaf;
						ret[1] = 0xc0;
						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);
						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);
						return ret;
					}
					if (Operands[0] is x86RegisterOperand &&
					    Operands[1] is x86ImmediateOperand) {
						var ret = new byte[6];
						ret[0] = 0x69;
						ret[1] = 0xc0;
						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);
						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);
						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate), 0, ret, 2, 4);
						return ret;
					}
					throw new NotSupportedException();
				}

				default:
					throw new NotSupportedException();
			}
		}

		public override string ToString() {
			var ret = new StringBuilder();
			ret.Append(OpCode);
			for (int i = 0; i < Operands.Length; i++) {
				ret.AppendFormat("{0}{1}", i == 0 ? " " : ", ", Operands[i]);
			}
			return ret.ToString();
		}
	}
}


================================================
File: Confuser.DynCipher/Properties/AssemblyInfo.cs
================================================
ï»¿using System;
using System.Reflection;

[assembly: AssemblyTitle("ConfuserEx Dynamic Cipher Library")]
[assembly: AssemblyDescription("Cipher generator of ConfuserEx")]


================================================
File: Confuser.DynCipher/Transforms/ConvertVariables.cs
================================================
ï»¿using System;
using Confuser.DynCipher.AST;

namespace Confuser.DynCipher.Transforms {
	internal class ConvertVariables {
		static Expression ReplaceVar(Expression exp, Variable buff) {
			if (exp is VariableExpression) {
				if (((VariableExpression)exp).Variable.Name[0] != 'v') return exp;
				return new ArrayIndexExpression {
					Array = new VariableExpression { Variable = buff },
					Index = (int)(exp as VariableExpression).Variable.Tag
				};
			}
			if (exp is ArrayIndexExpression) {
				((ArrayIndexExpression)exp).Array = ReplaceVar(((ArrayIndexExpression)exp).Array, buff);
			}
			else if (exp is BinOpExpression) {
				((BinOpExpression)exp).Left = ReplaceVar(((BinOpExpression)exp).Left, buff);
				((BinOpExpression)exp).Right = ReplaceVar(((BinOpExpression)exp).Right, buff);
			}
			else if (exp is UnaryOpExpression) {
				((UnaryOpExpression)exp).Value = ReplaceVar(((UnaryOpExpression)exp).Value, buff);
			}
			return exp;
		}

		static Statement ReplaceVar(Statement st, Variable buff) {
			if (st is AssignmentStatement) {
				((AssignmentStatement)st).Value = ReplaceVar(((AssignmentStatement)st).Value, buff);
				((AssignmentStatement)st).Target = ReplaceVar(((AssignmentStatement)st).Target, buff);
			}
			return st;
		}

		public static void Run(StatementBlock block) {
			var mainBuff = new Variable("{BUFFER}");
			for (int i = 0; i < block.Statements.Count; i++)
				block.Statements[i] = ReplaceVar(block.Statements[i], mainBuff);
		}
	}
}


================================================
File: Confuser.DynCipher/Transforms/ExpansionTransform.cs
================================================
ï»¿using System;
using System.Linq;
using Confuser.DynCipher.AST;

namespace Confuser.DynCipher.Transforms {
	internal class ExpansionTransform {
		static bool ProcessStatement(Statement st, StatementBlock block) {
			if (st is AssignmentStatement) {
				var assign = (AssignmentStatement)st;
				if (assign.Value is BinOpExpression) {
					var exp = (BinOpExpression)assign.Value;
					if ((exp.Left is BinOpExpression || exp.Right is BinOpExpression) &&
					    exp.Left != assign.Target) {
						block.Statements.Add(new AssignmentStatement {
							Target = assign.Target,
							Value = exp.Left
						});
						block.Statements.Add(new AssignmentStatement {
							Target = assign.Target,
							Value = new BinOpExpression {
								Left = assign.Target,
								Operation = exp.Operation,
								Right = exp.Right
							}
						});
						return true;
					}
				}
			}
			block.Statements.Add(st);
			return false;
		}

		public static void Run(StatementBlock block) {
			bool workDone;
			do {
				workDone = false;
				Statement[] copy = block.Statements.ToArray();
				block.Statements.Clear();
				foreach (Statement st in copy)
					workDone |= ProcessStatement(st, block);
			} while (workDone);
		}
	}
}


================================================
File: Confuser.DynCipher/Transforms/MulToShiftTransform.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using Confuser.DynCipher.AST;

namespace Confuser.DynCipher.Transforms {
	internal class MulToShiftTransform {
		static uint NumberOfSetBits(uint i) {
			i = i - ((i >> 1) & 0x55555555);
			i = (i & 0x33333333) + ((i >> 2) & 0x33333333);
			return (((i + (i >> 4)) & 0x0F0F0F0F) * 0x01010101) >> 24;
		}

		static Expression ProcessExpression(Expression exp) {
			if (exp is BinOpExpression) {
				var binOp = (BinOpExpression)exp;
				if (binOp.Operation == BinOps.Mul && binOp.Right is LiteralExpression) {
					// Decompose multiplication into shifts, e.g. x * 3 => x << 1 + x
					uint literal = ((LiteralExpression)binOp.Right).Value;
					if (literal == 0) return (LiteralExpression)0;
					if (literal == 1) return binOp.Left;

					uint bits = NumberOfSetBits(literal);
					if (bits <= 2) {
						var sum = new List<Expression>();
						int n = 0;
						while (literal != 0) {
							if ((literal & 1) != 0) {
								if (n == 0)
									sum.Add(binOp.Left);
								else
									sum.Add(binOp.Left << n);
							}
							literal >>= 1;
							n++;
						}
						BinOpExpression x = sum.OfType<BinOpExpression>().First();
						foreach (Expression i in sum.Except(new[] { x }))
							x += i;
						return x;
					}
				}
				else {
					binOp.Left = ProcessExpression(binOp.Left);
					binOp.Right = ProcessExpression(binOp.Right);
				}
			}
			else if (exp is ArrayIndexExpression) {
				((ArrayIndexExpression)exp).Array = ProcessExpression(((ArrayIndexExpression)exp).Array);
			}
			else if (exp is UnaryOpExpression) {
				((UnaryOpExpression)exp).Value = ProcessExpression(((UnaryOpExpression)exp).Value);
			}
			return exp;
		}

		static void ProcessStatement(Statement st) {
			if (st is AssignmentStatement) {
				var assign = (AssignmentStatement)st;
				assign.Target = ProcessExpression(assign.Target);
				assign.Value = ProcessExpression(assign.Value);
			}
		}

		public static void Run(StatementBlock block) {
			foreach (Statement st in block.Statements)
				ProcessStatement(st);
		}
	}
}


================================================
File: Confuser.DynCipher/Transforms/NormalizeBinOpTransform.cs
================================================
ï»¿using System;
using Confuser.DynCipher.AST;

namespace Confuser.DynCipher.Transforms {
	internal class NormalizeBinOpTransform {
		static Expression ProcessExpression(Expression exp) {
			if (exp is BinOpExpression) {
				var binOp = (BinOpExpression)exp;
				var binOpRight = binOp.Right as BinOpExpression;
				//  a + (b + c) => (a + b) + c
				if (binOpRight != null && binOpRight.Operation == binOp.Operation &&
				    (binOp.Operation == BinOps.Add || binOp.Operation == BinOps.Mul ||
				     binOp.Operation == BinOps.Or || binOp.Operation == BinOps.And ||
				     binOp.Operation == BinOps.Xor)) {
					binOp.Left = new BinOpExpression {
						Left = binOp.Left,
						Operation = binOp.Operation,
						Right = binOpRight.Left
					};
					binOp.Right = binOpRight.Right;
				}

				binOp.Left = ProcessExpression(binOp.Left);
				binOp.Right = ProcessExpression(binOp.Right);

				if (binOp.Right is LiteralExpression && ((LiteralExpression)binOp.Right).Value == 0 &&
				    binOp.Operation == BinOps.Add) // x + 0 => x
					return binOp.Left;
			}
			else if (exp is ArrayIndexExpression) {
				((ArrayIndexExpression)exp).Array = ProcessExpression(((ArrayIndexExpression)exp).Array);
			}
			else if (exp is UnaryOpExpression) {
				((UnaryOpExpression)exp).Value = ProcessExpression(((UnaryOpExpression)exp).Value);
			}
			return exp;
		}

		static void ProcessStatement(Statement st) {
			if (st is AssignmentStatement) {
				var assign = (AssignmentStatement)st;
				assign.Target = ProcessExpression(assign.Target);
				assign.Value = ProcessExpression(assign.Value);
			}
		}

		public static void Run(StatementBlock block) {
			foreach (Statement st in block.Statements)
				ProcessStatement(st);
		}
	}
}


================================================
File: Confuser.DynCipher/Transforms/ShuffleTransform.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using Confuser.Core.Services;
using Confuser.DynCipher.AST;

namespace Confuser.DynCipher.Transforms {
	internal class ShuffleTransform {
		const int ITERATION = 20;

		static IEnumerable<Variable> GetVariableUsage(Expression exp) {
			if (exp is VariableExpression)
				yield return ((VariableExpression)exp).Variable;
			else if (exp is ArrayIndexExpression) {
				foreach (Variable i in GetVariableUsage(((ArrayIndexExpression)exp).Array))
					yield return i;
			}
			else if (exp is BinOpExpression) {
				foreach (Variable i in GetVariableUsage(((BinOpExpression)exp).Left)
					.Concat(GetVariableUsage(((BinOpExpression)exp).Right)))
					yield return i;
			}
			else if (exp is UnaryOpExpression) {
				foreach (Variable i in GetVariableUsage(((UnaryOpExpression)exp).Value))
					yield return i;
			}
		}

		static IEnumerable<Variable> GetVariableUsage(Statement st) {
			if (st is AssignmentStatement) {
				foreach (Variable i in GetVariableUsage(((AssignmentStatement)st).Value))
					yield return i;
			}
		}

		static IEnumerable<Variable> GetVariableDefinition(Expression exp) {
			if (exp is VariableExpression)
				yield return ((VariableExpression)exp).Variable;
		}

		static IEnumerable<Variable> GetVariableDefinition(Statement st) {
			if (st is AssignmentStatement) {
				foreach (Variable i in GetVariableDefinition(((AssignmentStatement)st).Target))
					yield return i;
			}
		}


		// Cannot go before the statements that use the variable defined at the statement
		// Cannot go further than the statements that override the variable used at the statement
		static int SearchUpwardKill(TransformContext context, Statement st, StatementBlock block, int startIndex) {
			Variable[] usage = context.Usages[st];
			Variable[] definition = context.Definitions[st];
			for (int i = startIndex - 1; i >= 0; i--) {
				if (context.Usages[block.Statements[i]].Intersect(definition).Count() > 0 ||
				    context.Definitions[block.Statements[i]].Intersect(usage).Count() > 0)
					return i;
			}
			return 0;
		}

		static int SearchDownwardKill(TransformContext context, Statement st, StatementBlock block, int startIndex) {
			Variable[] usage = context.Usages[st];
			Variable[] definition = context.Definitions[st];
			for (int i = startIndex + 1; i < block.Statements.Count; i++) {
				if (context.Usages[block.Statements[i]].Intersect(definition).Count() > 0 ||
				    context.Definitions[block.Statements[i]].Intersect(usage).Count() > 0)
					return i;
			}
			return block.Statements.Count - 1;
		}

		public static void Run(StatementBlock block, RandomGenerator random) {
			var context = new TransformContext {
				Statements = block.Statements.ToArray(),
				Usages = block.Statements.ToDictionary(s => s, s => GetVariableUsage(s).ToArray()),
				Definitions = block.Statements.ToDictionary(s => s, s => GetVariableDefinition(s).ToArray())
			};
			for (int i = 0; i < ITERATION; i++) {
				foreach (Statement st in context.Statements) {
					int index = block.Statements.IndexOf(st);
					Variable[] vars = GetVariableUsage(st).Concat(GetVariableDefinition(st)).ToArray();

					// Statement can move between defIndex & useIndex without side effects
					int defIndex = SearchUpwardKill(context, st, block, index);
					int useIndex = SearchDownwardKill(context, st, block, index);


					// Move to a random spot in the interval
					int newIndex = defIndex + random.NextInt32(1, useIndex - defIndex);
					if (newIndex > index) newIndex--;
					block.Statements.RemoveAt(index);
					block.Statements.Insert(newIndex, st);
				}
			}
		}

		class TransformContext {
			public Dictionary<Statement, Variable[]> Definitions;
			public Statement[] Statements;
			public Dictionary<Statement, Variable[]> Usages;
		}
	}
}


================================================
File: Confuser.Protections/AntiDebugProtection.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using Confuser.Core;
using Confuser.Core.Helpers;
using Confuser.Core.Services;
using Confuser.Renamer;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections {
	[BeforeProtection("Ki.ControlFlow")]
	internal class AntiDebugProtection : Protection {
		public const string _Id = "anti debug";
		public const string _FullId = "Ki.AntiDebug";

		public override string Name {
			get { return "Anti Debug Protection"; }
		}

		public override string Description {
			get { return "This protection prevents the assembly from being debugged or profiled."; }
		}

		public override string Id {
			get { return _Id; }
		}

		public override string FullId {
			get { return _FullId; }
		}

		public override ProtectionPreset Preset {
			get { return ProtectionPreset.Minimum; }
		}

		protected override void Initialize(ConfuserContext context) {
			//
		}

		protected override void PopulatePipeline(ProtectionPipeline pipeline) {
			pipeline.InsertPreStage(PipelineStage.ProcessModule, new AntiDebugPhase(this));
		}

		class AntiDebugPhase : ProtectionPhase {
			public AntiDebugPhase(AntiDebugProtection parent)
				: base(parent) { }

			public override ProtectionTargets Targets {
				get { return ProtectionTargets.Modules; }
			}

			public override string Name {
				get { return "Anti-debug injection"; }
			}

			protected override void Execute(ConfuserContext context, ProtectionParameters parameters) {
				var rt = context.Registry.GetService<IRuntimeService>();
				var marker = context.Registry.GetService<IMarkerService>();
				var name = context.Registry.GetService<INameService>();

				foreach (ModuleDef module in parameters.Targets.OfType<ModuleDef>()) {
					AntiMode mode = parameters.GetParameter(context, module, "mode", AntiMode.Safe);

					TypeDef rtType;
					TypeDef attr = null;
					const string attrName = "System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute";
					switch (mode) {
						case AntiMode.Safe:
							rtType = rt.GetRuntimeType("Confuser.Runtime.AntiDebugSafe");
							break;
						case AntiMode.Win32:
							rtType = rt.GetRuntimeType("Confuser.Runtime.AntiDebugWin32");
							break;
						case AntiMode.Antinet:
							rtType = rt.GetRuntimeType("Confuser.Runtime.AntiDebugAntinet");

							attr = rt.GetRuntimeType(attrName);
							module.Types.Add(attr = InjectHelper.Inject(attr, module));
							foreach (IDnlibDef member in attr.FindDefinitions()) {
								marker.Mark(member, (Protection)Parent);
								name.Analyze(member);
							}
							name.SetCanRename(attr, false);
							break;
						default:
							throw new UnreachableException();
					}

					IEnumerable<IDnlibDef> members = InjectHelper.Inject(rtType, module.GlobalType, module);

					MethodDef cctor = module.GlobalType.FindStaticConstructor();
					var init = (MethodDef)members.Single(method => method.Name == "Initialize");
					cctor.Body.Instructions.Insert(0, Instruction.Create(OpCodes.Call, init));

					foreach (IDnlibDef member in members) {
						marker.Mark(member, (Protection)Parent);
						name.Analyze(member);

						bool ren = true;
						if (member is MethodDef) {
							var method = (MethodDef)member;
							if (method.Access == MethodAttributes.Public)
								method.Access = MethodAttributes.Assembly;
							if (!method.IsConstructor)
								method.IsSpecialName = false;
							else
								ren = false;

							CustomAttribute ca = method.CustomAttributes.Find(attrName);
							if (ca != null)
								ca.Constructor = attr.FindMethod(".ctor");
						}
						else if (member is FieldDef) {
							var field = (FieldDef)member;
							if (field.Access == FieldAttributes.Public)
								field.Access = FieldAttributes.Assembly;
							if (field.IsLiteral) {
								field.DeclaringType.Fields.Remove(field);
								continue;
							}
						}
						if (ren) {
							member.Name = name.ObfuscateName(member.Name, RenameMode.Unicode);
							name.SetCanRename(member, false);
						}
					}
				}
			}

			enum AntiMode {
				Safe,
				Win32,
				Antinet
			}
		}
	}
}


================================================
File: Confuser.Protections/AntiDumpProtection.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using Confuser.Core;
using Confuser.Core.Helpers;
using Confuser.Core.Services;
using Confuser.Renamer;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections {
	[BeforeProtection("Ki.ControlFlow")]
	internal class AntiDumpProtection : Protection {
		public const string _Id = "anti dump";
		public const string _FullId = "Ki.AntiDump";

		public override string Name {
			get { return "Anti Dump Protection"; }
		}

		public override string Description {
			get { return "This protection prevents the assembly from being dumped from memory."; }
		}

		public override string Id {
			get { return _Id; }
		}

		public override string FullId {
			get { return _FullId; }
		}

		public override ProtectionPreset Preset {
			get { return ProtectionPreset.Maximum; }
		}

		protected override void Initialize(ConfuserContext context) {
			//
		}

		protected override void PopulatePipeline(ProtectionPipeline pipeline) {
			pipeline.InsertPreStage(PipelineStage.ProcessModule, new AntiDumpPhase(this));
		}

		class AntiDumpPhase : ProtectionPhase {
			public AntiDumpPhase(AntiDumpProtection parent)
				: base(parent) { }

			public override ProtectionTargets Targets {
				get { return ProtectionTargets.Modules; }
			}

			public override string Name {
				get { return "Anti-dump injection"; }
			}

			protected override void Execute(ConfuserContext context, ProtectionParameters parameters) {
				TypeDef rtType = context.Registry.GetService<IRuntimeService>().GetRuntimeType("Confuser.Runtime.AntiDump");

				var marker = context.Registry.GetService<IMarkerService>();
				var name = context.Registry.GetService<INameService>();

				foreach (ModuleDef module in parameters.Targets.OfType<ModuleDef>()) {
					IEnumerable<IDnlibDef> members = InjectHelper.Inject(rtType, module.GlobalType, module);

					MethodDef cctor = module.GlobalType.FindStaticConstructor();
					var init = (MethodDef)members.Single(method => method.Name == "Initialize");
					cctor.Body.Instructions.Insert(0, Instruction.Create(OpCodes.Call, init));

					foreach (IDnlibDef member in members)
						name.MarkHelper(member, marker, (Protection)Parent);
				}
			}
		}
	}
}


================================================
File: Confuser.Protections/AntiILDasmProtection.cs
================================================
ï»¿using System;
using System.Linq;
using Confuser.Core;
using dnlib.DotNet;

namespace Confuser.Protections {
	internal class AntiILDasmProtection : Protection {
		public const string _Id = "anti ildasm";
		public const string _FullId = "Ki.AntiILDasm";

		public override string Name {
			get { return "Anti IL Dasm Protection"; }
		}

		public override string Description {
			get { return "This protection marks the module with a attribute that discourage ILDasm from disassembling it."; }
		}

		public override string Id {
			get { return _Id; }
		}

		public override string FullId {
			get { return _FullId; }
		}

		public override ProtectionPreset Preset {
			get { return ProtectionPreset.Minimum; }
		}

		protected override void Initialize(ConfuserContext context) {
			//
		}

		protected override void PopulatePipeline(ProtectionPipeline pipeline) {
			pipeline.InsertPreStage(PipelineStage.ProcessModule, new AntiILDasmPhase(this));
		}

		class AntiILDasmPhase : ProtectionPhase {
			public AntiILDasmPhase(AntiILDasmProtection parent)
				: base(parent) { }

			public override ProtectionTargets Targets {
				get { return ProtectionTargets.Modules; }
			}

			public override string Name {
				get { return "Anti-ILDasm marking"; }
			}

			protected override void Execute(ConfuserContext context, ProtectionParameters parameters) {
				foreach (ModuleDef module in parameters.Targets.OfType<ModuleDef>()) {
					TypeRef attrRef = module.CorLibTypes.GetTypeRef("System.Runtime.CompilerServices", "SuppressIldasmAttribute");
					var ctorRef = new MemberRefUser(module, ".ctor", MethodSig.CreateInstance(module.CorLibTypes.Void), attrRef);

					var attr = new CustomAttribute(ctorRef);
					module.CustomAttributes.Add(attr);
				}
			}
		}
	}
}


================================================
File: Confuser.Protections/Confuser.Protections.csproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProductVersion>8.0.30703</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{3EAB01B5-9B49-48D8-BFA1-5493B26CCB71}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>Confuser.Protections</RootNamespace>
    <AssemblyName>Confuser.Protections</AssemblyName>
    <TargetFrameworkVersion Condition=" !$(DefineConstants.Contains('NET45')) ">v4.0</TargetFrameworkVersion>
    <TargetFrameworkVersion Condition=" $(DefineConstants.Contains('NET45')) ">v4.5</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <SolutionDir Condition="$(SolutionDir) == '' Or $(SolutionDir) == '*Undefined*'">..\</SolutionDir>
    <RestorePackages>true</RestorePackages>
    <TargetFrameworkProfile />
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>..\Debug\bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>..\Release\bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup>
    <SignAssembly>true</SignAssembly>
  </PropertyGroup>
  <PropertyGroup>
    <AssemblyOriginatorKeyFile>..\ConfuserEx.snk</AssemblyOriginatorKeyFile>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="..\GlobalAssemblyInfo.cs">
      <Link>Properties\GlobalAssemblyInfo.cs</Link>
    </Compile>
    <Compile Include="AntiILDasmProtection.cs" />
    <Compile Include="AntiTamper\AntiTamperProtection.cs" />
    <Compile Include="AntiTamper\DynamicDeriver.cs" />
    <Compile Include="AntiTamper\IKeyDeriver.cs" />
    <Compile Include="AntiTamper\IModeHandler.cs" />
    <Compile Include="AntiTamper\JITBody.cs" />
    <Compile Include="AntiTamper\JITMode.cs" />
    <Compile Include="AntiTamper\NormalDeriver.cs" />
    <Compile Include="AntiTamper\NormalMode.cs" />
    <Compile Include="Compress\Compressor.cs" />
    <Compile Include="Compress\CompressorContext.cs" />
    <Compile Include="Compress\DynamicDeriver.cs" />
    <Compile Include="Compress\ExtractPhase.cs" />
    <Compile Include="Compress\IKeyDeriver.cs" />
    <Compile Include="Compress\NormalDeriver.cs" />
    <Compile Include="Compress\StubProtection.cs" />
    <Compile Include="Constants\CEContext.cs" />
    <Compile Include="Constants\ConstantProtection.cs">
      <SubType>Code</SubType>
    </Compile>
    <Compile Include="Constants\ReferenceReplacer.cs" />
    <Compile Include="Constants\x86Mode.cs" />
    <Compile Include="Constants\DynamicMode.cs" />
    <Compile Include="Constants\EncodeElements.cs" />
    <Compile Include="Constants\EncodePhase.cs">
      <SubType>Code</SubType>
    </Compile>
    <Compile Include="Constants\IEncodeMode.cs" />
    <Compile Include="Constants\InjectPhase.cs">
      <SubType>Code</SubType>
    </Compile>
    <Compile Include="Constants\Mode.cs" />
    <Compile Include="Constants\NormalMode.cs" />
    <Compile Include="ControlFlow\CFContext.cs" />
    <Compile Include="ControlFlow\ControlFlowPhase.cs" />
    <Compile Include="ControlFlow\ControlFlowProtection.cs" />
    <Compile Include="ControlFlow\BlockParser.cs" />
    <Compile Include="ControlFlow\Blocks.cs" />
    <Compile Include="ControlFlow\NormalPredicate.cs" />
    <Compile Include="ControlFlow\x86Predicate.cs" />
    <Compile Include="ControlFlow\ExpressionPredicate.cs" />
    <Compile Include="ControlFlow\IPredicate.cs" />
    <Compile Include="ControlFlow\JumpMangler.cs" />
    <Compile Include="ControlFlow\ManglerBase.cs" />
    <Compile Include="ControlFlow\SwitchMangler.cs" />
    <Compile Include="AntiDumpProtection.cs" />
    <Compile Include="AntiDebugProtection.cs" />
    <Compile Include="InvalidMetadataProtection.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="ReferenceProxy\x86Encoding.cs" />
    <Compile Include="ReferenceProxy\ExpressionEncoding.cs" />
    <Compile Include="ReferenceProxy\NormalEncoding.cs" />
    <Compile Include="ReferenceProxy\MildMode.cs" />
    <Compile Include="ReferenceProxy\IRPEncoding.cs" />
    <Compile Include="ReferenceProxy\RPMode.cs" />
    <Compile Include="ReferenceProxy\StrongMode.cs" />
    <Compile Include="ReferenceProxy\ReferenceProxyPhase.cs" />
    <Compile Include="ReferenceProxy\ReferenceProxyProtection.cs" />
    <Compile Include="ReferenceProxy\RPContext.cs" />
    <Compile Include="Resources\DynamicMode.cs" />
    <Compile Include="Resources\IEncodeMode.cs" />
    <Compile Include="Resources\InjectPhase.cs" />
    <Compile Include="Resources\MDPhase.cs" />
    <Compile Include="Resources\Mode.cs" />
    <Compile Include="Resources\NormalMode.cs" />
    <Compile Include="Resources\REContext.cs" />
    <Compile Include="Resources\ResourceProtection.cs" />
  </ItemGroup>
  <ItemGroup>
    <None Include="..\ConfuserEx.snk">
      <Link>Properties\ConfuserEx.snk</Link>
    </None>
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\Confuser.Core\Confuser.Core.csproj">
      <Project>{BEB67A6E-4C54-4DE5-8C6B-2C12F44A7B92}</Project>
      <Name>Confuser.Core</Name>
    </ProjectReference>
    <ProjectReference Include="..\Confuser.DynCipher\Confuser.DynCipher.csproj">
      <Project>{E832E9B8-2158-4FC0-89A1-56C6ECC10F6B}</Project>
      <Name>Confuser.DynCipher</Name>
    </ProjectReference>
    <ProjectReference Include="..\Confuser.Renamer\Confuser.Renamer.csproj">
      <Project>{862DA0DA-52E1-47CD-B9C2-46B106031B28}</Project>
      <Name>Confuser.Renamer</Name>
    </ProjectReference>
    <ProjectReference Include="..\Confuser.Runtime\Confuser.Runtime.csproj">
      <Project>{A45C184F-F98F-4258-A928-BFF437034791}</Project>
      <Name>Confuser.Runtime</Name>
    </ProjectReference>
    <ProjectReference Include="..\dnlib\src\dnlib.csproj">
      <Project>{FDFC1237-143F-4919-8318-4926901F4639}</Project>
      <Name>dnlib</Name>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup />
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <Import Project="$(SolutionDir)\.nuget\NuGet.targets" Condition="Exists('$(SolutionDir)\.nuget\NuGet.targets')" />
  <Target Name="EnsureNuGetPackageBuildImports" BeforeTargets="PrepareForBuild">
    <PropertyGroup>
      <ErrorText>This project references NuGet package(s) that are missing on this computer. Enable NuGet Package Restore to download them.  For more information, see http://go.microsoft.com/fwlink/?LinkID=322105. The missing file is {0}.</ErrorText>
    </PropertyGroup>
    <Error Condition="!Exists('$(SolutionDir)\.nuget\NuGet.targets')" Text="$([System.String]::Format('$(ErrorText)', '$(SolutionDir)\.nuget\NuGet.targets'))" />
  </Target>
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>


================================================
File: Confuser.Protections/InvalidMetadataProtection.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Confuser.Core;
using Confuser.Core.Services;
using dnlib.DotNet.MD;
using dnlib.DotNet.Writer;

namespace Confuser.Protections {
	internal class InvalidMetadataProtection : Protection {
		public const string _Id = "invalid metadata";
		public const string _FullId = "Ki.InvalidMD";

		public override string Name {
			get { return "Invalid Metadata Protection"; }
		}

		public override string Description {
			get { return "This protection adds invalid metadata to modules to prevent disassembler/decompiler from opening them."; }
		}

		public override string Id {
			get { return _Id; }
		}

		public override string FullId {
			get { return _FullId; }
		}

		public override ProtectionPreset Preset {
			get { return ProtectionPreset.None; }
		}

		protected override void Initialize(ConfuserContext context) {
			//
		}

		protected override void PopulatePipeline(ProtectionPipeline pipeline) {
			pipeline.InsertPostStage(PipelineStage.BeginModule, new InvalidMDPhase(this));
		}

		class InvalidMDPhase : ProtectionPhase {
			RandomGenerator random;

			public InvalidMDPhase(InvalidMetadataProtection parent)
				: base(parent) { }

			public override ProtectionTargets Targets {
				get { return ProtectionTargets.Modules; }
			}

			public override string Name {
				get { return "Invalid metadata addition"; }
			}

			protected override void Execute(ConfuserContext context, ProtectionParameters parameters) {
				if (parameters.Targets.Contains(context.CurrentModule)) {
					random = context.Registry.GetService<IRandomService>().GetRandomGenerator(_FullId);
					context.CurrentModuleWriterListener.OnWriterEvent += OnWriterEvent;
				}
			}

			void Randomize<T>(MDTable<T> table) where T : IRawRow {
				List<T> rows = table.ToList();
				random.Shuffle(rows);
				table.Reset();
				foreach (T row in rows)
					table.Add(row);
			}

			void OnWriterEvent(object sender, ModuleWriterListenerEventArgs e) {
				var writer = (ModuleWriterBase)sender;
				if (e.WriterEvent == ModuleWriterEvent.MDEndCreateTables) {
					// These hurts reflection

					/*
					uint methodLen = (uint)writer.MetaData.TablesHeap.MethodTable.Rows + 1;
					uint fieldLen = (uint)writer.MetaData.TablesHeap.FieldTable.Rows + 1;

					var root = writer.MetaData.TablesHeap.TypeDefTable.Add(new RawTypeDefRow(
							0, 0x7fff7fff, 0, 0x3FFFD, fieldLen, methodLen));
					writer.MetaData.TablesHeap.NestedClassTable.Add(new RawNestedClassRow(root, root));

					var namespaces = writer.MetaData.TablesHeap.TypeDefTable
						.Select(row => row.Namespace)
						.Distinct()
						.ToList();
					foreach (var ns in namespaces)
					{
						if (ns == 0) continue;
						var type = writer.MetaData.TablesHeap.TypeDefTable.Add(new RawTypeDefRow(
							0, 0, ns, 0x3FFFD, fieldLen, methodLen));
						writer.MetaData.TablesHeap.NestedClassTable.Add(new RawNestedClassRow(root, type));
					}
					
					foreach (var row in writer.MetaData.TablesHeap.ParamTable)
						row.Name = 0x7fff7fff;
					*/

					writer.MetaData.TablesHeap.ModuleTable.Add(new RawModuleRow(0, 0x7fff7fff, 0, 0, 0));
					writer.MetaData.TablesHeap.AssemblyTable.Add(new RawAssemblyRow(0, 0, 0, 0, 0, 0, 0, 0x7fff7fff, 0));

					int r = random.NextInt32(8, 16);
					for (int i = 0; i < r; i++)
						writer.MetaData.TablesHeap.ENCLogTable.Add(new RawENCLogRow(random.NextUInt32(), random.NextUInt32()));
					r = random.NextInt32(8, 16);
					for (int i = 0; i < r; i++)
						writer.MetaData.TablesHeap.ENCMapTable.Add(new RawENCMapRow(random.NextUInt32()));

					//Randomize(writer.MetaData.TablesHeap.NestedClassTable);
					Randomize(writer.MetaData.TablesHeap.ManifestResourceTable);
					//Randomize(writer.MetaData.TablesHeap.GenericParamConstraintTable);

					writer.TheOptions.MetaDataOptions.TablesHeapOptions.ExtraData = random.NextUInt32();
					writer.TheOptions.MetaDataOptions.TablesHeapOptions.UseENC = false;
					writer.TheOptions.MetaDataOptions.MetaDataHeaderOptions.VersionString += "\0\0\0\0";

					/*
					We are going to create a new specific '#GUID' Heap to avoid UnConfuserEX to work.
					<sarcasm>UnConfuserEX is so well coded, it relies on static cmp between values</sarcasm>
					If you deobfuscate this tool, you can see that it check for #GUID size and compare it to
					'16', so we have to create a new array of byte wich size is exactly 16 and put it into 
					our brand new Heap
					*/
					//
                    writer.TheOptions.MetaDataOptions.OtherHeapsEnd.Add(new RawHeap("#GUID", Guid.NewGuid().ToByteArray()));
					//
					writer.TheOptions.MetaDataOptions.OtherHeapsEnd.Add(new RawHeap("#Strings", new byte[1]));
					writer.TheOptions.MetaDataOptions.OtherHeapsEnd.Add(new RawHeap("#Blob", new byte[1]));
					writer.TheOptions.MetaDataOptions.OtherHeapsEnd.Add(new RawHeap("#Schema", new byte[1]));
				}
				else if (e.WriterEvent == ModuleWriterEvent.MDOnAllTablesSorted) {
					writer.MetaData.TablesHeap.DeclSecurityTable.Add(new RawDeclSecurityRow(
						                                                 unchecked(0x7fff), 0xffff7fff, 0xffff7fff));
					/*
					writer.MetaData.TablesHeap.ManifestResourceTable.Add(new RawManifestResourceRow(
						0x7fff7fff, (uint)ManifestResourceAttributes.Private, 0x7fff7fff, 2));
					*/
				}
			}
		}

		class RawHeap : HeapBase {
			readonly byte[] content;
			readonly string name;

			public RawHeap(string name, byte[] content) {
				this.name = name;
				this.content = content;
			}

			public override string Name {
				get { return name; }
			}

			public override uint GetRawLength() {
				return (uint)content.Length;
			}

			protected override void WriteToImpl(BinaryWriter writer) {
				writer.Write(content);
			}
		}
	}
}



================================================
File: Confuser.Protections/AntiTamper/AntiTamperProtection.cs
================================================
ï»¿using System;
using System.Linq;
using Confuser.Core;
using Confuser.Protections.AntiTamper;
using dnlib.DotNet;

namespace Confuser.Protections {
	public interface IAntiTamperService {
		void ExcludeMethod(ConfuserContext context, MethodDef method);
	}

	[BeforeProtection("Ki.ControlFlow"), AfterProtection("Ki.Constants")]
	internal class AntiTamperProtection : Protection, IAntiTamperService {
		public const string _Id = "anti tamper";
		public const string _FullId = "Ki.AntiTamper";
		public const string _ServiceId = "Ki.AntiTamper";
		static readonly object HandlerKey = new object();

		public override string Name {
			get { return "Anti Tamper Protection"; }
		}

		public override string Description {
			get { return "This protection ensures the integrity of application."; }
		}

		public override string Id {
			get { return _Id; }
		}

		public override string FullId {
			get { return _FullId; }
		}

		public override ProtectionPreset Preset {
			get { return ProtectionPreset.Maximum; }
		}

		protected override void Initialize(ConfuserContext context) {
			context.Registry.RegisterService(_ServiceId, typeof(IAntiTamperService), this);
		}

		protected override void PopulatePipeline(ProtectionPipeline pipeline) {
			pipeline.InsertPreStage(PipelineStage.OptimizeMethods, new InjectPhase(this));
			pipeline.InsertPreStage(PipelineStage.EndModule, new MDPhase(this));
		}

		public void ExcludeMethod(ConfuserContext context, MethodDef method) {
			ProtectionParameters.GetParameters(context, method).Remove(this);
		}

		class InjectPhase : ProtectionPhase {
			public InjectPhase(AntiTamperProtection parent)
				: base(parent) { }

			public override ProtectionTargets Targets {
				get { return ProtectionTargets.Methods; }
			}

			public override string Name {
				get { return "Anti-tamper helpers injection"; }
			}

			protected override void Execute(ConfuserContext context, ProtectionParameters parameters) {
				if (!parameters.Targets.Any())
					return;

				Mode mode = parameters.GetParameter(context, context.CurrentModule, "mode", Mode.Normal);
				IModeHandler modeHandler;
				switch (mode) {
					case Mode.Normal:
						modeHandler = new NormalMode();
						break;
					case Mode.JIT:
						modeHandler = new JITMode();
						break;
					default:
						throw new UnreachableException();
				}
				modeHandler.HandleInject((AntiTamperProtection)Parent, context, parameters);
				context.Annotations.Set(context.CurrentModule, HandlerKey, modeHandler);
			}
		}

		class MDPhase : ProtectionPhase {
			public MDPhase(AntiTamperProtection parent)
				: base(parent) { }

			public override ProtectionTargets Targets {
				get { return ProtectionTargets.Methods; }
			}

			public override string Name {
				get { return "Anti-tamper metadata preparation"; }
			}

			protected override void Execute(ConfuserContext context, ProtectionParameters parameters) {
				if (!parameters.Targets.Any())
					return;

				var modeHandler = context.Annotations.Get<IModeHandler>(context.CurrentModule, HandlerKey);
				modeHandler.HandleMD((AntiTamperProtection)Parent, context, parameters);
			}
		}

		enum Mode {
			Normal,
			JIT
		}
	}
}


================================================
File: Confuser.Protections/AntiTamper/DynamicDeriver.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using Confuser.Core;
using Confuser.Core.Services;
using Confuser.DynCipher;
using Confuser.DynCipher.AST;
using Confuser.DynCipher.Generation;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.AntiTamper {
	internal class DynamicDeriver : IKeyDeriver {
		StatementBlock derivation;
		Action<uint[], uint[]> encryptFunc;

		public void Init(ConfuserContext ctx, RandomGenerator random) {
			StatementBlock dummy;
			ctx.Registry.GetService<IDynCipherService>().GenerateCipherPair(random, out derivation, out dummy);

			var dmCodeGen = new DMCodeGen(typeof(void), new[] {
				Tuple.Create("{BUFFER}", typeof(uint[])),
				Tuple.Create("{KEY}", typeof(uint[]))
			});
			dmCodeGen.GenerateCIL(derivation);
			encryptFunc = dmCodeGen.Compile<Action<uint[], uint[]>>();
		}

		public uint[] DeriveKey(uint[] a, uint[] b) {
			var ret = new uint[0x10];
			Buffer.BlockCopy(a, 0, ret, 0, a.Length * sizeof(uint));
			encryptFunc(ret, b);
			return ret;
		}

		public IEnumerable<Instruction> EmitDerivation(MethodDef method, ConfuserContext ctx, Local dst, Local src) {
			var ret = new List<Instruction>();
			var codeGen = new CodeGen(dst, src, method, ret);
			codeGen.GenerateCIL(derivation);
			codeGen.Commit(method.Body);
			return ret;
		}

		class CodeGen : CILCodeGen {
			readonly Local block;
			readonly Local key;

			public CodeGen(Local block, Local key, MethodDef method, IList<Instruction> instrs)
				: base(method, instrs) {
				this.block = block;
				this.key = key;
			}

			protected override Local Var(Variable var) {
				if (var.Name == "{BUFFER}")
					return block;
				if (var.Name == "{KEY}")
					return key;
				return base.Var(var);
			}
		}
	}
}


================================================
File: Confuser.Protections/AntiTamper/IKeyDeriver.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using Confuser.Core;
using Confuser.Core.Services;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.AntiTamper {
	internal enum Mode {
		Normal,
		Dynamic
	}

	internal interface IKeyDeriver {
		void Init(ConfuserContext ctx, RandomGenerator random);
		uint[] DeriveKey(uint[] a, uint[] b);
		IEnumerable<Instruction> EmitDerivation(MethodDef method, ConfuserContext ctx, Local dst, Local src);
	}
}


================================================
File: Confuser.Protections/AntiTamper/IModeHandler.cs
================================================
ï»¿using System;
using Confuser.Core;

namespace Confuser.Protections.AntiTamper {
	internal interface IModeHandler {
		void HandleInject(AntiTamperProtection parent, ConfuserContext context, ProtectionParameters parameters);
		void HandleMD(AntiTamperProtection parent, ConfuserContext context, ProtectionParameters parameters);
	}
}


================================================
File: Confuser.Protections/AntiTamper/JITBody.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using dnlib.DotNet.Writer;
using dnlib.IO;
using dnlib.PE;

namespace Confuser.Protections.AntiTamper {
	internal struct JITEHClause {
		public uint ClassTokenOrFilterOffset;
		public uint Flags;
		public uint HandlerLength;
		public uint HandlerOffset;
		public uint TryLength;
		public uint TryOffset;
	}

	internal class JITMethodBody : IChunk {
		public byte[] Body;
		public JITEHClause[] EHs;
		public byte[] ILCode;
		public byte[] LocalVars;
		public uint MaxStack;
		public uint MulSeed;

		public uint Offset;
		public uint Options;

		public FileOffset FileOffset { get; set; }

		public RVA RVA { get; set; }

		public void SetOffset(FileOffset offset, RVA rva) {
			this.FileOffset = offset;
			this.RVA = rva;
		}

		public uint GetFileLength() {
			return (uint)Body.Length + 4;
		}

		public uint GetVirtualSize() {
			return GetFileLength();
		}

		public void WriteTo(BinaryWriter writer) {
			writer.Write((uint)(Body.Length >> 2));
			writer.Write(Body);
		}

		public void Serialize(uint token, uint key, byte[] fieldLayout) {
			using (var ms = new MemoryStream()) {
				var writer = new BinaryWriter(ms);
				foreach (byte i in fieldLayout)
					switch (i) {
						case 0:
							writer.Write((uint)ILCode.Length);
							break;
						case 1:
							writer.Write(MaxStack);
							break;
						case 2:
							writer.Write((uint)EHs.Length);
							break;
						case 3:
							writer.Write((uint)LocalVars.Length);
							break;
						case 4:
							writer.Write(Options);
							break;
						case 5:
							writer.Write(MulSeed);
							break;
					}

				writer.Write(ILCode);
				writer.Write(LocalVars);
				foreach (JITEHClause clause in EHs) {
					writer.Write(clause.Flags);
					writer.Write(clause.TryOffset);
					writer.Write(clause.TryLength);
					writer.Write(clause.HandlerOffset);
					writer.Write(clause.HandlerLength);
					writer.Write(clause.ClassTokenOrFilterOffset);
				}
				writer.WriteZeros(4 - ((int)ms.Length & 3)); // pad to 4 bytes
				Body = ms.ToArray();
			}
			Debug.Assert(Body.Length % 4 == 0);
			// encrypt body
			uint state = token * key;
			uint counter = state;
			for (uint i = 0; i < Body.Length; i += 4) {
				uint data = Body[i] | (uint)(Body[i + 1] << 8) | (uint)(Body[i + 2] << 16) | (uint)(Body[i + 3] << 24);
				Body[i + 0] ^= (byte)(state >> 0);
				Body[i + 1] ^= (byte)(state >> 8);
				Body[i + 2] ^= (byte)(state >> 16);
				Body[i + 3] ^= (byte)(state >> 24);
				state += data ^ counter;
				counter ^= (state >> 5) | (state << 27);
			}
		}
	}

	internal class JITMethodBodyWriter : MethodBodyWriterBase {
		readonly CilBody body;
		readonly JITMethodBody jitBody;
		readonly bool keepMaxStack;
		readonly MetaData metadata;

		public JITMethodBodyWriter(MetaData md, CilBody body, JITMethodBody jitBody, uint mulSeed, bool keepMaxStack) :
			base(body.Instructions, body.ExceptionHandlers) {
			metadata = md;
			this.body = body;
			this.jitBody = jitBody;
			this.keepMaxStack = keepMaxStack;
			this.jitBody.MulSeed = mulSeed;
		}

		public void Write() {
			uint codeSize = InitializeInstructionOffsets();
			jitBody.MaxStack = keepMaxStack ? body.MaxStack : GetMaxStack();

			jitBody.Options = 0;
			if (body.InitLocals)
				jitBody.Options |= 0x10;

			if (body.Variables.Count > 0) {
				var local = new LocalSig(body.Variables.Select(var => var.Type).ToList());
				jitBody.LocalVars = SignatureWriter.Write(metadata, local);
			}
			else
				jitBody.LocalVars = new byte[0];

			using (var ms = new MemoryStream()) {
				uint _codeSize = WriteInstructions(new BinaryWriter(ms));
				Debug.Assert(codeSize == _codeSize);
				jitBody.ILCode = ms.ToArray();
			}

			jitBody.EHs = new JITEHClause[exceptionHandlers.Count];
			if (exceptionHandlers.Count > 0) {
				jitBody.Options |= 8;
				for (int i = 0; i < exceptionHandlers.Count; i++) {
					ExceptionHandler eh = exceptionHandlers[i];
					jitBody.EHs[i].Flags = (uint)eh.HandlerType;

					uint tryStart = GetOffset(eh.TryStart);
					uint tryEnd = GetOffset(eh.TryEnd);
					jitBody.EHs[i].TryOffset = tryStart;
					jitBody.EHs[i].TryLength = tryEnd - tryStart;

					uint handlerStart = GetOffset(eh.HandlerStart);
					uint handlerEnd = GetOffset(eh.HandlerEnd);
					jitBody.EHs[i].HandlerOffset = handlerStart;
					jitBody.EHs[i].HandlerLength = handlerEnd - handlerStart;

					if (eh.HandlerType == ExceptionHandlerType.Catch) {
						uint token = metadata.GetToken(eh.CatchType).Raw;
						if ((token & 0xff000000) == 0x1b000000)
							jitBody.Options |= 0x80;

						jitBody.EHs[i].ClassTokenOrFilterOffset = token;
					}
					else if (eh.HandlerType == ExceptionHandlerType.Filter) {
						jitBody.EHs[i].ClassTokenOrFilterOffset = GetOffset(eh.FilterStart);
					}
				}
			}
		}

		protected override void WriteInlineField(BinaryWriter writer, Instruction instr) {
			writer.Write(metadata.GetToken(instr.Operand).Raw);
		}

		protected override void WriteInlineMethod(BinaryWriter writer, Instruction instr) {
			writer.Write(metadata.GetToken(instr.Operand).Raw);
		}

		protected override void WriteInlineSig(BinaryWriter writer, Instruction instr) {
			writer.Write(metadata.GetToken(instr.Operand).Raw);
		}

		protected override void WriteInlineString(BinaryWriter writer, Instruction instr) {
			writer.Write(metadata.GetToken(instr.Operand).Raw);
		}

		protected override void WriteInlineTok(BinaryWriter writer, Instruction instr) {
			writer.Write(metadata.GetToken(instr.Operand).Raw);
		}

		protected override void WriteInlineType(BinaryWriter writer, Instruction instr) {
			writer.Write(metadata.GetToken(instr.Operand).Raw);
		}
	}

	internal class JITBodyIndex : IChunk {
		readonly Dictionary<uint, JITMethodBody> bodies;

		public JITBodyIndex(IEnumerable<uint> tokens) {
			bodies = tokens.ToDictionary(token => token, token => (JITMethodBody)null);
		}

		public FileOffset FileOffset { get; set; }

		public RVA RVA { get; set; }

		public void SetOffset(FileOffset offset, RVA rva) {
			this.FileOffset = offset;
			this.RVA = rva;
		}

		public uint GetFileLength() {
			return (uint)bodies.Count * 8 + 4;
		}

		public uint GetVirtualSize() {
			return GetFileLength();
		}

		public void WriteTo(BinaryWriter writer) {
			uint length = GetFileLength() - 4; // minus length field
			writer.Write((uint)bodies.Count);
			foreach (var entry in bodies.OrderBy(entry => entry.Key)) {
				writer.Write(entry.Key);
				Debug.Assert(entry.Value != null);
				Debug.Assert((length + entry.Value.Offset) % 4 == 0);
				writer.Write((length + entry.Value.Offset) >> 2);
			}
		}

		public void Add(uint token, JITMethodBody body) {
			Debug.Assert(bodies.ContainsKey(token));
			bodies[token] = body;
		}

		public void PopulateSection(PESection section) {
			uint offset = 0;
			foreach (var entry in bodies.OrderBy(entry => entry.Key)) {
				Debug.Assert(entry.Value != null);
				section.Add(entry.Value, 4);
				entry.Value.Offset = offset;

				Debug.Assert(entry.Value.GetFileLength() % 4 == 0);
				offset += entry.Value.GetFileLength();
			}
		}
	}
}


================================================
File: Confuser.Protections/AntiTamper/JITMode.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using Confuser.Core;
using Confuser.Core.Helpers;
using Confuser.Core.Services;
using Confuser.Renamer;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using dnlib.DotNet.Writer;

namespace Confuser.Protections.AntiTamper {
	internal class JITMode : IModeHandler {
		static readonly CilBody NopBody = new CilBody {
			Instructions = {
				Instruction.Create(OpCodes.Ldnull),
				Instruction.Create(OpCodes.Throw)
			}
		};

		uint c;
		MethodDef cctor;
		MethodDef cctorRepl;
		ConfuserContext context;
		IKeyDeriver deriver;
		byte[] fieldLayout;

		MethodDef initMethod;
		uint key;
		List<MethodDef> methods;
		uint name1, name2;
		RandomGenerator random;
		uint v;
		uint x;
		uint z;

		public void HandleInject(AntiTamperProtection parent, ConfuserContext context, ProtectionParameters parameters) {
			this.context = context;
			random = context.Registry.GetService<IRandomService>().GetRandomGenerator(parent.FullId);
			z = random.NextUInt32();
			x = random.NextUInt32();
			c = random.NextUInt32();
			v = random.NextUInt32();
			name1 = random.NextUInt32() & 0x7f7f7f7f;
			name2 = random.NextUInt32() & 0x7f7f7f7f;
			key = random.NextUInt32();

			fieldLayout = new byte[6];
			for (int i = 0; i < 6; i++) {
				int index = random.NextInt32(0, 6);
				while (fieldLayout[index] != 0)
					index = random.NextInt32(0, 6);
				fieldLayout[index] = (byte)i;
			}

			switch (parameters.GetParameter(context, context.CurrentModule, "key", Mode.Normal)) {
				case Mode.Normal:
					deriver = new NormalDeriver();
					break;
				case Mode.Dynamic:
					deriver = new DynamicDeriver();
					break;
				default:
					throw new UnreachableException();
			}
			deriver.Init(context, random);

			var rt = context.Registry.GetService<IRuntimeService>();
			TypeDef initType = rt.GetRuntimeType("Confuser.Runtime.AntiTamperJIT");
			IEnumerable<IDnlibDef> defs = InjectHelper.Inject(initType, context.CurrentModule.GlobalType, context.CurrentModule);
			initMethod = defs.OfType<MethodDef>().Single(method => method.Name == "Initialize");

			initMethod.Body.SimplifyMacros(initMethod.Parameters);
			List<Instruction> instrs = initMethod.Body.Instructions.ToList();
			for (int i = 0; i < instrs.Count; i++) {
				Instruction instr = instrs[i];
				if (instr.OpCode == OpCodes.Ldtoken) {
					instr.Operand = context.CurrentModule.GlobalType;
				}
				else if (instr.OpCode == OpCodes.Call) {
					var method = (IMethod)instr.Operand;
					if (method.DeclaringType.Name == "Mutation" &&
					    method.Name == "Crypt") {
						Instruction ldDst = instrs[i - 2];
						Instruction ldSrc = instrs[i - 1];
						Debug.Assert(ldDst.OpCode == OpCodes.Ldloc && ldSrc.OpCode == OpCodes.Ldloc);
						instrs.RemoveAt(i);
						instrs.RemoveAt(i - 1);
						instrs.RemoveAt(i - 2);
						instrs.InsertRange(i - 2, deriver.EmitDerivation(initMethod, context, (Local)ldDst.Operand, (Local)ldSrc.Operand));
					}
				}
			}
			initMethod.Body.Instructions.Clear();
			foreach (Instruction instr in instrs)
				initMethod.Body.Instructions.Add(instr);

			MutationHelper.InjectKeys(initMethod,
			                          new[] { 0, 1, 2, 3, 4 },
			                          new[] { (int)(name1 * name2), (int)z, (int)x, (int)c, (int)v });

			var name = context.Registry.GetService<INameService>();
			var marker = context.Registry.GetService<IMarkerService>();

			cctor = context.CurrentModule.GlobalType.FindStaticConstructor();

			cctorRepl = new MethodDefUser(name.RandomName(), MethodSig.CreateStatic(context.CurrentModule.CorLibTypes.Void));
			cctorRepl.IsStatic = true;
			cctorRepl.Access = MethodAttributes.CompilerControlled;
			cctorRepl.Body = new CilBody();
			cctorRepl.Body.Instructions.Add(Instruction.Create(OpCodes.Ret));
			context.CurrentModule.GlobalType.Methods.Add(cctorRepl);
			name.MarkHelper(cctorRepl, marker, parent);

			MutationHelper.InjectKeys(defs.OfType<MethodDef>().Single(method => method.Name == "HookHandler"),
			                          new[] { 0 }, new[] { (int)key });
			foreach (IDnlibDef def in defs) {
				if (def.Name == "MethodData") {
					var dataType = (TypeDef)def;
					FieldDef[] fields = dataType.Fields.ToArray();
					var layout = fieldLayout.Clone() as byte[];
					Array.Sort(layout, fields);
					for (byte j = 0; j < 6; j++)
						layout[j] = j;
					Array.Sort(fieldLayout, layout);
					fieldLayout = layout;
					dataType.Fields.Clear();
					foreach (FieldDef f in fields)
						dataType.Fields.Add(f);
				}
				name.MarkHelper(def, marker, parent);
				if (def is MethodDef)
					parent.ExcludeMethod(context, (MethodDef)def);
			}
			parent.ExcludeMethod(context, cctor);
		}

		public void HandleMD(AntiTamperProtection parent, ConfuserContext context, ProtectionParameters parameters) {
			// move initialization away from module initializer
			cctorRepl.Body = cctor.Body;
			cctor.Body = new CilBody();
			cctor.Body.Instructions.Add(Instruction.Create(OpCodes.Call, initMethod));
			cctor.Body.Instructions.Add(Instruction.Create(OpCodes.Call, cctorRepl));
			cctor.Body.Instructions.Add(Instruction.Create(OpCodes.Ret));

			methods = parameters.Targets.OfType<MethodDef>().Where(method => method.HasBody).ToList();
			context.CurrentModuleWriterListener.OnWriterEvent += OnWriterEvent;
		}

		void OnWriterEvent(object sender, ModuleWriterListenerEventArgs e) {
			var writer = (ModuleWriterBase)sender;
			if (e.WriterEvent == ModuleWriterEvent.MDBeginWriteMethodBodies) {
				context.Logger.Debug("Extracting method bodies...");
				CreateSection(writer);
			}
			else if (e.WriterEvent == ModuleWriterEvent.BeginStrongNameSign) {
				context.Logger.Debug("Encrypting method section...");
				EncryptSection(writer);
			}
		}

		void CreateSection(ModuleWriterBase writer) {
			// move some PE parts to separate section to prevent it from being hashed
			var peSection = new PESection("", 0x60000020);
			bool moved = false;
			uint alignment;
			if (writer.StrongNameSignature != null) {
				alignment = writer.TextSection.Remove(writer.StrongNameSignature).Value;
				peSection.Add(writer.StrongNameSignature, alignment);
				moved = true;
			}
			var managedWriter = writer as ModuleWriter;
			if (managedWriter != null) {
				if (managedWriter.ImportAddressTable != null) {
					alignment = writer.TextSection.Remove(managedWriter.ImportAddressTable).Value;
					peSection.Add(managedWriter.ImportAddressTable, alignment);
					moved = true;
				}
				if (managedWriter.StartupStub != null) {
					alignment = writer.TextSection.Remove(managedWriter.StartupStub).Value;
					peSection.Add(managedWriter.StartupStub, alignment);
					moved = true;
				}
			}
			if (moved)
				writer.Sections.Add(peSection);

			// create section
			var nameBuffer = new byte[8];
			nameBuffer[0] = (byte)(name1 >> 0);
			nameBuffer[1] = (byte)(name1 >> 8);
			nameBuffer[2] = (byte)(name1 >> 16);
			nameBuffer[3] = (byte)(name1 >> 24);
			nameBuffer[4] = (byte)(name2 >> 0);
			nameBuffer[5] = (byte)(name2 >> 8);
			nameBuffer[6] = (byte)(name2 >> 16);
			nameBuffer[7] = (byte)(name2 >> 24);
			var newSection = new PESection(Encoding.ASCII.GetString(nameBuffer), 0xE0000040);
			writer.Sections.Insert(random.NextInt32(writer.Sections.Count), newSection);

			// random padding at beginning to prevent revealing hash key
			newSection.Add(new ByteArrayChunk(random.NextBytes(0x10)), 0x10);

			// create index
			var bodyIndex = new JITBodyIndex(methods.Select(method => writer.MetaData.GetToken(method).Raw));
			newSection.Add(bodyIndex, 0x10);

			// save methods
			foreach (MethodDef method in methods.WithProgress(context.Logger)) {
				if (!method.HasBody)
					continue;

				MDToken token = writer.MetaData.GetToken(method);

				var jitBody = new JITMethodBody();
				var bodyWriter = new JITMethodBodyWriter(writer.MetaData, method.Body, jitBody, random.NextUInt32(), writer.MetaData.KeepOldMaxStack || method.Body.KeepOldMaxStack);
				bodyWriter.Write();
				jitBody.Serialize(token.Raw, key, fieldLayout);
				bodyIndex.Add(token.Raw, jitBody);

				method.Body = NopBody;
				writer.MetaData.TablesHeap.MethodTable[token.Rid].ImplFlags |= (ushort)MethodImplAttributes.NoInlining;
				context.CheckCancellation();
			}
			bodyIndex.PopulateSection(newSection);

			// padding to prevent bad size due to shift division
			newSection.Add(new ByteArrayChunk(new byte[4]), 4);
		}

		void EncryptSection(ModuleWriterBase writer) {
			Stream stream = writer.DestinationStream;
			var reader = new BinaryReader(writer.DestinationStream);
			stream.Position = 0x3C;
			stream.Position = reader.ReadUInt32();

			stream.Position += 6;
			ushort sections = reader.ReadUInt16();
			stream.Position += 0xc;
			ushort optSize = reader.ReadUInt16();
			stream.Position += 2 + optSize;

			uint encLoc = 0, encSize = 0;
			int origSects = -1;
			if (writer is NativeModuleWriter && writer.Module is ModuleDefMD)
				origSects = ((ModuleDefMD)writer.Module).MetaData.PEImage.ImageSectionHeaders.Count;
			for (int i = 0; i < sections; i++) {
				uint nameHash;
				if (origSects > 0) {
					origSects--;
					stream.Write(new byte[8], 0, 8);
					nameHash = 0;
				}
				else
					nameHash = reader.ReadUInt32() * reader.ReadUInt32();
				stream.Position += 8;
				if (nameHash == name1 * name2) {
					encSize = reader.ReadUInt32();
					encLoc = reader.ReadUInt32();
				}
				else if (nameHash != 0) {
					uint sectSize = reader.ReadUInt32();
					uint sectLoc = reader.ReadUInt32();
					Hash(stream, reader, sectLoc, sectSize);
				}
				else
					stream.Position += 8;
				stream.Position += 16;
			}

			uint[] key = DeriveKey();
			encSize >>= 2;
			stream.Position = encLoc;
			var result = new uint[encSize];
			for (uint i = 0; i < encSize; i++) {
				uint data = reader.ReadUInt32();
				result[i] = data ^ key[i & 0xf];
				key[i & 0xf] = (key[i & 0xf] ^ data) + 0x3dbb2819;
			}
			var byteResult = new byte[encSize << 2];
			Buffer.BlockCopy(result, 0, byteResult, 0, byteResult.Length);
			stream.Position = encLoc;
			stream.Write(byteResult, 0, byteResult.Length);
		}

		void Hash(Stream stream, BinaryReader reader, uint offset, uint size) {
			long original = stream.Position;
			stream.Position = offset;
			size >>= 2;
			for (uint i = 0; i < size; i++) {
				uint data = reader.ReadUInt32();
				uint tmp = (z ^ data) + x + c * v;
				z = x;
				x = c;
				x = v;
				v = tmp;
			}
			stream.Position = original;
		}

		uint[] DeriveKey() {
			uint[] dst = new uint[0x10], src = new uint[0x10];
			for (int i = 0; i < 0x10; i++) {
				dst[i] = v;
				src[i] = x;
				z = (x >> 5) | (x << 27);
				x = (c >> 3) | (c << 29);
				c = (v >> 7) | (v << 25);
				v = (z >> 11) | (z << 21);
			}
			return deriver.DeriveKey(dst, src);
		}
	}
}


================================================
File: Confuser.Protections/AntiTamper/NormalDeriver.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using Confuser.Core;
using Confuser.Core.Services;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.AntiTamper {
	internal class NormalDeriver : IKeyDeriver {
		public void Init(ConfuserContext ctx, RandomGenerator random) {
			//
		}

		public uint[] DeriveKey(uint[] a, uint[] b) {
			var ret = new uint[0x10];
			for (int i = 0; i < 0x10; i++) {
				switch (i % 3) {
					case 0:
						ret[i] = a[i] ^ b[i];
						break;
					case 1:
						ret[i] = a[i] * b[i];
						break;
					case 2:
						ret[i] = a[i] + b[i];
						break;
				}
			}
			return ret;
		}

		public IEnumerable<Instruction> EmitDerivation(MethodDef method, ConfuserContext ctx, Local dst, Local src) {
			for (int i = 0; i < 0x10; i++) {
				yield return Instruction.Create(OpCodes.Ldloc, dst);
				yield return Instruction.Create(OpCodes.Ldc_I4, i);
				yield return Instruction.Create(OpCodes.Ldloc, dst);
				yield return Instruction.Create(OpCodes.Ldc_I4, i);
				yield return Instruction.Create(OpCodes.Ldelem_U4);
				yield return Instruction.Create(OpCodes.Ldloc, src);
				yield return Instruction.Create(OpCodes.Ldc_I4, i);
				yield return Instruction.Create(OpCodes.Ldelem_U4);
				switch (i % 3) {
					case 0:
						yield return Instruction.Create(OpCodes.Xor);
						break;
					case 1:
						yield return Instruction.Create(OpCodes.Mul);
						break;
					case 2:
						yield return Instruction.Create(OpCodes.Add);
						break;
				}
				yield return Instruction.Create(OpCodes.Stelem_I4);
			}
		}
	}
}


================================================
File: Confuser.Protections/AntiTamper/NormalMode.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using Confuser.Core;
using Confuser.Core.Helpers;
using Confuser.Core.Services;
using Confuser.Renamer;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using dnlib.DotNet.Writer;
using MethodBody = dnlib.DotNet.Writer.MethodBody;

namespace Confuser.Protections.AntiTamper {
	internal class NormalMode : IModeHandler {
		uint c;
		IKeyDeriver deriver;

		List<MethodDef> methods;
		uint name1, name2;
		RandomGenerator random;
		uint v;
		uint x;
		uint z;

		public void HandleInject(AntiTamperProtection parent, ConfuserContext context, ProtectionParameters parameters) {
			random = context.Registry.GetService<IRandomService>().GetRandomGenerator(parent.FullId);
			z = random.NextUInt32();
			x = random.NextUInt32();
			c = random.NextUInt32();
			v = random.NextUInt32();
			name1 = random.NextUInt32() & 0x7f7f7f7f;
			name2 = random.NextUInt32() & 0x7f7f7f7f;

			switch (parameters.GetParameter(context, context.CurrentModule, "key", Mode.Normal)) {
				case Mode.Normal:
					deriver = new NormalDeriver();
					break;
				case Mode.Dynamic:
					deriver = new DynamicDeriver();
					break;
				default:
					throw new UnreachableException();
			}
			deriver.Init(context, random);

			var rt = context.Registry.GetService<IRuntimeService>();
			TypeDef initType = rt.GetRuntimeType("Confuser.Runtime.AntiTamperNormal");
			IEnumerable<IDnlibDef> members = InjectHelper.Inject(initType, context.CurrentModule.GlobalType, context.CurrentModule);
			var initMethod = (MethodDef)members.Single(m => m.Name == "Initialize");

			initMethod.Body.SimplifyMacros(initMethod.Parameters);
			List<Instruction> instrs = initMethod.Body.Instructions.ToList();
			for (int i = 0; i < instrs.Count; i++) {
				Instruction instr = instrs[i];
				if (instr.OpCode == OpCodes.Ldtoken) {
					instr.Operand = context.CurrentModule.GlobalType;
				}
				else if (instr.OpCode == OpCodes.Call) {
					var method = (IMethod)instr.Operand;
					if (method.DeclaringType.Name == "Mutation" &&
					    method.Name == "Crypt") {
						Instruction ldDst = instrs[i - 2];
						Instruction ldSrc = instrs[i - 1];
						Debug.Assert(ldDst.OpCode == OpCodes.Ldloc && ldSrc.OpCode == OpCodes.Ldloc);
						instrs.RemoveAt(i);
						instrs.RemoveAt(i - 1);
						instrs.RemoveAt(i - 2);
						instrs.InsertRange(i - 2, deriver.EmitDerivation(initMethod, context, (Local)ldDst.Operand, (Local)ldSrc.Operand));
					}
				}
			}
			initMethod.Body.Instructions.Clear();
			foreach (Instruction instr in instrs)
				initMethod.Body.Instructions.Add(instr);

			MutationHelper.InjectKeys(initMethod,
			                          new[] { 0, 1, 2, 3, 4 },
			                          new[] { (int)(name1 * name2), (int)z, (int)x, (int)c, (int)v });

			var name = context.Registry.GetService<INameService>();
			var marker = context.Registry.GetService<IMarkerService>();
			foreach (IDnlibDef def in members) {
				name.MarkHelper(def, marker, parent);
				if (def is MethodDef)
					parent.ExcludeMethod(context, (MethodDef)def);
			}

			MethodDef cctor = context.CurrentModule.GlobalType.FindStaticConstructor();
			cctor.Body.Instructions.Insert(0, Instruction.Create(OpCodes.Call, initMethod));

			parent.ExcludeMethod(context, cctor);
		}

		public void HandleMD(AntiTamperProtection parent, ConfuserContext context, ProtectionParameters parameters) {
			methods = parameters.Targets.OfType<MethodDef>().ToList();
			context.CurrentModuleWriterListener.OnWriterEvent += OnWriterEvent;
		}

		void OnWriterEvent(object sender, ModuleWriterListenerEventArgs e) {
			var writer = (ModuleWriterBase)sender;
			if (e.WriterEvent == ModuleWriterEvent.MDEndCreateTables) {
				CreateSections(writer);
			}
			else if (e.WriterEvent == ModuleWriterEvent.BeginStrongNameSign) {
				EncryptSection(writer);
			}
		}

		void CreateSections(ModuleWriterBase writer) {
			var nameBuffer = new byte[8];
			nameBuffer[0] = (byte)(name1 >> 0);
			nameBuffer[1] = (byte)(name1 >> 8);
			nameBuffer[2] = (byte)(name1 >> 16);
			nameBuffer[3] = (byte)(name1 >> 24);
			nameBuffer[4] = (byte)(name2 >> 0);
			nameBuffer[5] = (byte)(name2 >> 8);
			nameBuffer[6] = (byte)(name2 >> 16);
			nameBuffer[7] = (byte)(name2 >> 24);
			var newSection = new PESection(Encoding.ASCII.GetString(nameBuffer), 0xE0000040);
			writer.Sections.Insert(0, newSection); // insert first to ensure proper RVA

			uint alignment;

			alignment = writer.TextSection.Remove(writer.MetaData).Value;
			writer.TextSection.Add(writer.MetaData, alignment);

			alignment = writer.TextSection.Remove(writer.NetResources).Value;
			writer.TextSection.Add(writer.NetResources, alignment);

			alignment = writer.TextSection.Remove(writer.Constants).Value;
			newSection.Add(writer.Constants, alignment);

			// move some PE parts to separate section to prevent it from being hashed
			var peSection = new PESection("", 0x60000020);
			bool moved = false;
			if (writer.StrongNameSignature != null) {
				alignment = writer.TextSection.Remove(writer.StrongNameSignature).Value;
				peSection.Add(writer.StrongNameSignature, alignment);
				moved = true;
			}
			var managedWriter = writer as ModuleWriter;
			if (managedWriter != null) {
				if (managedWriter.ImportAddressTable != null) {
					alignment = writer.TextSection.Remove(managedWriter.ImportAddressTable).Value;
					peSection.Add(managedWriter.ImportAddressTable, alignment);
					moved = true;
				}
				if (managedWriter.StartupStub != null) {
					alignment = writer.TextSection.Remove(managedWriter.StartupStub).Value;
					peSection.Add(managedWriter.StartupStub, alignment);
					moved = true;
				}
			}
			if (moved)
				writer.Sections.Add(peSection);

			// move encrypted methods
			var encryptedChunk = new MethodBodyChunks(writer.TheOptions.ShareMethodBodies);
			newSection.Add(encryptedChunk, 4);
			foreach (MethodDef method in methods) {
				if (!method.HasBody)
					continue;
				MethodBody body = writer.MetaData.GetMethodBody(method);
				bool ok = writer.MethodBodies.Remove(body);
				encryptedChunk.Add(body);
			}

			// padding to prevent bad size due to shift division
			newSection.Add(new ByteArrayChunk(new byte[4]), 4);
		}

		void EncryptSection(ModuleWriterBase writer) {
			Stream stream = writer.DestinationStream;
			var reader = new BinaryReader(writer.DestinationStream);
			stream.Position = 0x3C;
			stream.Position = reader.ReadUInt32();

			stream.Position += 6;
			ushort sections = reader.ReadUInt16();
			stream.Position += 0xc;
			ushort optSize = reader.ReadUInt16();
			stream.Position += 2 + optSize;

			uint encLoc = 0, encSize = 0;
			int origSects = -1;
			if (writer is NativeModuleWriter && writer.Module is ModuleDefMD)
				origSects = ((ModuleDefMD)writer.Module).MetaData.PEImage.ImageSectionHeaders.Count;
			for (int i = 0; i < sections; i++) {
				uint nameHash;
				if (origSects > 0) {
					origSects--;
					stream.Write(new byte[8], 0, 8);
					nameHash = 0;
				}
				else
					nameHash = reader.ReadUInt32() * reader.ReadUInt32();
				stream.Position += 8;
				if (nameHash == name1 * name2) {
					encSize = reader.ReadUInt32();
					encLoc = reader.ReadUInt32();
				}
				else if (nameHash != 0) {
					uint sectSize = reader.ReadUInt32();
					uint sectLoc = reader.ReadUInt32();
					Hash(stream, reader, sectLoc, sectSize);
				}
				else
					stream.Position += 8;
				stream.Position += 16;
			}

			uint[] key = DeriveKey();
			encSize >>= 2;
			stream.Position = encLoc;
			var result = new uint[encSize];
			for (uint i = 0; i < encSize; i++) {
				uint data = reader.ReadUInt32();
				result[i] = data ^ key[i & 0xf];
				key[i & 0xf] = (key[i & 0xf] ^ data) + 0x3dbb2819;
			}
			var byteResult = new byte[encSize << 2];
			Buffer.BlockCopy(result, 0, byteResult, 0, byteResult.Length);
			stream.Position = encLoc;
			stream.Write(byteResult, 0, byteResult.Length);
		}

		void Hash(Stream stream, BinaryReader reader, uint offset, uint size) {
			long original = stream.Position;
			stream.Position = offset;
			size >>= 2;
			for (uint i = 0; i < size; i++) {
				uint data = reader.ReadUInt32();
				uint tmp = (z ^ data) + x + c * v;
				z = x;
				x = c;
				x = v;
				v = tmp;
			}
			stream.Position = original;
		}

		uint[] DeriveKey() {
			uint[] dst = new uint[0x10], src = new uint[0x10];
			for (int i = 0; i < 0x10; i++) {
				dst[i] = v;
				src[i] = x;
				z = (x >> 5) | (x << 27);
				x = (c >> 3) | (c << 29);
				c = (v >> 7) | (v << 25);
				v = (z >> 11) | (z << 21);
			}
			return deriver.DeriveKey(dst, src);
		}
	}
}


================================================
File: Confuser.Protections/Compress/Compressor.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Security.Cryptography;
using System.Text;
using Confuser.Core;
using Confuser.Core.Helpers;
using Confuser.Core.Services;
using Confuser.Protections.Compress;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using dnlib.DotNet.MD;
using dnlib.DotNet.Writer;
using dnlib.PE;
using FileAttributes = dnlib.DotNet.FileAttributes;
using SR = System.Reflection;

namespace Confuser.Protections {
	internal class Compressor : Packer {
		public const string _Id = "compressor";
		public const string _FullId = "Ki.Compressor";
		public const string _ServiceId = "Ki.Compressor";
		public static readonly object ContextKey = new object();

		public override string Name {
			get { return "Compressing Packer"; }
		}

		public override string Description {
			get { return "This packer reduces the size of output."; }
		}

		public override string Id {
			get { return _Id; }
		}

		public override string FullId {
			get { return _FullId; }
		}

		protected override void Initialize(ConfuserContext context) { }

		protected override void PopulatePipeline(ProtectionPipeline pipeline) {
			pipeline.InsertPreStage(PipelineStage.WriteModule, new ExtractPhase(this));
		}

		protected override void Pack(ConfuserContext context, ProtectionParameters parameters) {
			var ctx = context.Annotations.Get<CompressorContext>(context, ContextKey);
			if (ctx == null) {
				context.Logger.Error("No executable module!");
				throw new ConfuserException(null);
			}

			ModuleDefMD originModule = context.Modules[ctx.ModuleIndex];
			ctx.OriginModuleDef = originModule;

			var stubModule = new ModuleDefUser(ctx.ModuleName, originModule.Mvid, originModule.CorLibTypes.AssemblyRef);
			if (ctx.CompatMode) {
				var assembly = new AssemblyDefUser(originModule.Assembly);
				assembly.Name += ".cr";
				assembly.Modules.Add(stubModule);
			}
			else {
				ctx.Assembly.Modules.Insert(0, stubModule);
				ImportAssemblyTypeReferences(originModule, stubModule);
			}
			stubModule.Characteristics = originModule.Characteristics;
			stubModule.Cor20HeaderFlags = originModule.Cor20HeaderFlags;
			stubModule.Cor20HeaderRuntimeVersion = originModule.Cor20HeaderRuntimeVersion;
			stubModule.DllCharacteristics = originModule.DllCharacteristics;
			stubModule.EncBaseId = originModule.EncBaseId;
			stubModule.EncId = originModule.EncId;
			stubModule.Generation = originModule.Generation;
			stubModule.Kind = ctx.Kind;
			stubModule.Machine = originModule.Machine;
			stubModule.RuntimeVersion = originModule.RuntimeVersion;
			stubModule.TablesHeaderVersion = originModule.TablesHeaderVersion;
			stubModule.Win32Resources = originModule.Win32Resources;

			InjectStub(context, ctx, parameters, stubModule);

			var snKey = context.Annotations.Get<StrongNameKey>(originModule, Marker.SNKey);
			using (var ms = new MemoryStream()) {
				stubModule.Write(ms, new ModuleWriterOptions(stubModule, new KeyInjector(ctx)) {
					StrongNameKey = snKey
				});
				context.CheckCancellation();
				ProtectStub(context, context.OutputPaths[ctx.ModuleIndex], ms.ToArray(), snKey, new StubProtection(ctx, originModule));
			}
		}

		static string GetId(byte[] module) {
			var md = MetaDataCreator.CreateMetaData(new PEImage(module));
			var assemblyRow = md.TablesStream.ReadAssemblyRow(1);
			var assembly = new AssemblyNameInfo();
			assembly.Name = md.StringsStream.ReadNoNull(assemblyRow.Name);
			assembly.Culture = md.StringsStream.ReadNoNull(assemblyRow.Locale);
			assembly.PublicKeyOrToken = new PublicKey(md.BlobStream.Read(assemblyRow.PublicKey));
			assembly.HashAlgId = (AssemblyHashAlgorithm)assemblyRow.HashAlgId;
			assembly.Version = new Version(assemblyRow.MajorVersion, assemblyRow.MinorVersion, assemblyRow.BuildNumber, assemblyRow.RevisionNumber);
			assembly.Attributes = (AssemblyAttributes)assemblyRow.Flags;
			return GetId(assembly);
		}

		static string GetId(IAssembly assembly) {
			return new SR.AssemblyName(assembly.FullName).FullName.ToUpperInvariant();
		}

		void PackModules(ConfuserContext context, CompressorContext compCtx, ModuleDef stubModule, ICompressionService comp, RandomGenerator random) {
			int maxLen = 0;
			var modules = new Dictionary<string, byte[]>();
			for (int i = 0; i < context.OutputModules.Count; i++) {
				if (i == compCtx.ModuleIndex)
					continue;

				string id = GetId(context.Modules[i].Assembly);
				modules.Add(id, context.OutputModules[i]);

				int strLen = Encoding.UTF8.GetByteCount(id);
				if (strLen > maxLen)
					maxLen = strLen;
			}
			foreach (var extModule in context.ExternalModules) {
				var name = GetId(extModule).ToUpperInvariant();
				modules.Add(name, extModule);

				int strLen = Encoding.UTF8.GetByteCount(name);
				if (strLen > maxLen)
					maxLen = strLen;
			}

			byte[] key = random.NextBytes(4 + maxLen);
			key[0] = (byte)(compCtx.EntryPointToken >> 0);
			key[1] = (byte)(compCtx.EntryPointToken >> 8);
			key[2] = (byte)(compCtx.EntryPointToken >> 16);
			key[3] = (byte)(compCtx.EntryPointToken >> 24);
			for (int i = 4; i < key.Length; i++) // no zero bytes
				key[i] |= 1;
			compCtx.KeySig = key;

			int moduleIndex = 0;
			foreach (var entry in modules) {
				byte[] name = Encoding.UTF8.GetBytes(entry.Key);
				for (int i = 0; i < name.Length; i++)
					name[i] *= key[i + 4];

				uint state = 0x6fff61;
				foreach (byte chr in name)
					state = state * 0x5e3f1f + chr;
				byte[] encrypted = compCtx.Encrypt(comp, entry.Value, state, progress => {
					progress = (progress + moduleIndex) / modules.Count;
					context.Logger.Progress((int)(progress * 10000), 10000);
				});
				context.CheckCancellation();

				var resource = new EmbeddedResource(Convert.ToBase64String(name), encrypted, ManifestResourceAttributes.Private);
				stubModule.Resources.Add(resource);
				moduleIndex++;
			}
			context.Logger.EndProgress();
		}

		void InjectData(ModuleDef stubModule, MethodDef method, byte[] data) {
			var dataType = new TypeDefUser("", "DataType", stubModule.CorLibTypes.GetTypeRef("System", "ValueType"));
			dataType.Layout = TypeAttributes.ExplicitLayout;
			dataType.Visibility = TypeAttributes.NestedPrivate;
			dataType.IsSealed = true;
			dataType.ClassLayout = new ClassLayoutUser(1, (uint)data.Length);
			stubModule.GlobalType.NestedTypes.Add(dataType);

			var dataField = new FieldDefUser("DataField", new FieldSig(dataType.ToTypeSig())) {
				IsStatic = true,
				HasFieldRVA = true,
				InitialValue = data,
				Access = FieldAttributes.CompilerControlled
			};
			stubModule.GlobalType.Fields.Add(dataField);

			MutationHelper.ReplacePlaceholder(method, arg => {
				var repl = new List<Instruction>();
				repl.AddRange(arg);
				repl.Add(Instruction.Create(OpCodes.Dup));
				repl.Add(Instruction.Create(OpCodes.Ldtoken, dataField));
				repl.Add(Instruction.Create(OpCodes.Call, stubModule.Import(
					typeof(RuntimeHelpers).GetMethod("InitializeArray"))));
				return repl.ToArray();
			});
		}

		void InjectStub(ConfuserContext context, CompressorContext compCtx, ProtectionParameters parameters, ModuleDef stubModule) {
			var rt = context.Registry.GetService<IRuntimeService>();
			RandomGenerator random = context.Registry.GetService<IRandomService>().GetRandomGenerator(Id);
			var comp = context.Registry.GetService<ICompressionService>();

			var rtType = rt.GetRuntimeType(compCtx.CompatMode ? "Confuser.Runtime.CompressorCompat" : "Confuser.Runtime.Compressor");
			IEnumerable<IDnlibDef> defs = InjectHelper.Inject(rtType, stubModule.GlobalType, stubModule);

			switch (parameters.GetParameter(context, context.CurrentModule, "key", Mode.Normal)) {
				case Mode.Normal:
					compCtx.Deriver = new NormalDeriver();
					break;
				case Mode.Dynamic:
					compCtx.Deriver = new DynamicDeriver();
					break;
				default:
					throw new UnreachableException();
			}
			compCtx.Deriver.Init(context, random);

			context.Logger.Debug("Encrypting modules...");

			// Main
			MethodDef entryPoint = defs.OfType<MethodDef>().Single(method => method.Name == "Main");
			stubModule.EntryPoint = entryPoint;

			if (compCtx.EntryPoint.HasAttribute("System.STAThreadAttribute")) {
				var attrType = stubModule.CorLibTypes.GetTypeRef("System", "STAThreadAttribute");
				var ctorSig = MethodSig.CreateInstance(stubModule.CorLibTypes.Void);
				entryPoint.CustomAttributes.Add(new CustomAttribute(
					new MemberRefUser(stubModule, ".ctor", ctorSig, attrType)));
			}
			else if (compCtx.EntryPoint.HasAttribute("System.MTAThreadAttribute")) {
				var attrType = stubModule.CorLibTypes.GetTypeRef("System", "MTAThreadAttribute");
				var ctorSig = MethodSig.CreateInstance(stubModule.CorLibTypes.Void);
				entryPoint.CustomAttributes.Add(new CustomAttribute(
					new MemberRefUser(stubModule, ".ctor", ctorSig, attrType)));
			}

			uint seed = random.NextUInt32();
			compCtx.OriginModule = context.OutputModules[compCtx.ModuleIndex];

			byte[] encryptedModule = compCtx.Encrypt(comp, compCtx.OriginModule, seed,
			                                         progress => context.Logger.Progress((int)(progress * 10000), 10000));
			context.Logger.EndProgress();
			context.CheckCancellation();

			compCtx.EncryptedModule = encryptedModule;

			MutationHelper.InjectKeys(entryPoint,
			                          new[] { 0, 1 },
			                          new[] { encryptedModule.Length >> 2, (int)seed });
			InjectData(stubModule, entryPoint, encryptedModule);

			// Decrypt
			MethodDef decrypter = defs.OfType<MethodDef>().Single(method => method.Name == "Decrypt");
			decrypter.Body.SimplifyMacros(decrypter.Parameters);
			List<Instruction> instrs = decrypter.Body.Instructions.ToList();
			for (int i = 0; i < instrs.Count; i++) {
				Instruction instr = instrs[i];
				if (instr.OpCode == OpCodes.Call) {
					var method = (IMethod)instr.Operand;
					if (method.DeclaringType.Name == "Mutation" &&
					    method.Name == "Crypt") {
						Instruction ldDst = instrs[i - 2];
						Instruction ldSrc = instrs[i - 1];
						Debug.Assert(ldDst.OpCode == OpCodes.Ldloc && ldSrc.OpCode == OpCodes.Ldloc);
						instrs.RemoveAt(i);
						instrs.RemoveAt(i - 1);
						instrs.RemoveAt(i - 2);
						instrs.InsertRange(i - 2, compCtx.Deriver.EmitDerivation(decrypter, context, (Local)ldDst.Operand, (Local)ldSrc.Operand));
					}
					else if (method.DeclaringType.Name == "Lzma" &&
					         method.Name == "Decompress") {
						MethodDef decomp = comp.GetRuntimeDecompressor(stubModule, member => { });
						instr.Operand = decomp;
					}
				}
			}
			decrypter.Body.Instructions.Clear();
			foreach (Instruction instr in instrs)
				decrypter.Body.Instructions.Add(instr);

			// Pack modules
			PackModules(context, compCtx, stubModule, comp, random);
		}

		void ImportAssemblyTypeReferences(ModuleDef originModule, ModuleDef stubModule) {
			var assembly = stubModule.Assembly;
			foreach (var ca in assembly.CustomAttributes) {
				if (ca.AttributeType.Scope == originModule)
					ca.Constructor = (ICustomAttributeType)stubModule.Import(ca.Constructor);
			}
			foreach (var ca in assembly.DeclSecurities.SelectMany(declSec => declSec.CustomAttributes)) {
				if (ca.AttributeType.Scope == originModule)
					ca.Constructor = (ICustomAttributeType)stubModule.Import(ca.Constructor);
			}
		}

		class KeyInjector : IModuleWriterListener {
			readonly CompressorContext ctx;

			public KeyInjector(CompressorContext ctx) {
				this.ctx = ctx;
			}

			public void OnWriterEvent(ModuleWriterBase writer, ModuleWriterEvent evt) {
				if (evt == ModuleWriterEvent.MDBeginCreateTables) {
					// Add key signature
					uint sigBlob = writer.MetaData.BlobHeap.Add(ctx.KeySig);
					uint sigRid = writer.MetaData.TablesHeap.StandAloneSigTable.Add(new RawStandAloneSigRow(sigBlob));
					Debug.Assert(sigRid == 1);
					uint sigToken = 0x11000000 | sigRid;
					ctx.KeyToken = sigToken;
					MutationHelper.InjectKey(writer.Module.EntryPoint, 2, (int)sigToken);
				}
				else if (evt == ModuleWriterEvent.MDBeginAddResources && !ctx.CompatMode) {
					// Compute hash
					byte[] hash = SHA1.Create().ComputeHash(ctx.OriginModule);
					uint hashBlob = writer.MetaData.BlobHeap.Add(hash);

					MDTable<RawFileRow> fileTbl = writer.MetaData.TablesHeap.FileTable;
					uint fileRid = fileTbl.Add(new RawFileRow(
						                           (uint)FileAttributes.ContainsMetaData,
						                           writer.MetaData.StringsHeap.Add("koi"),
						                           hashBlob));
					uint impl = CodedToken.Implementation.Encode(new MDToken(Table.File, fileRid));

					// Add resources
					MDTable<RawManifestResourceRow> resTbl = writer.MetaData.TablesHeap.ManifestResourceTable;
					foreach (var resource in ctx.ManifestResources)
						resTbl.Add(new RawManifestResourceRow(resource.Item1, resource.Item2, writer.MetaData.StringsHeap.Add(resource.Item3), impl));

					// Add exported types
					var exTbl = writer.MetaData.TablesHeap.ExportedTypeTable;
					foreach (var type in ctx.OriginModuleDef.GetTypes()) {
						if (!type.IsVisibleOutside())
							continue;
						exTbl.Add(new RawExportedTypeRow((uint)type.Attributes, 0,
						                                 writer.MetaData.StringsHeap.Add(type.Name),
						                                 writer.MetaData.StringsHeap.Add(type.Namespace), impl));
					}
				}
			}
		}
	}
}


================================================
File: Confuser.Protections/Compress/CompressorContext.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using Confuser.Core.Services;
using dnlib.DotNet;

namespace Confuser.Protections.Compress {
	internal class CompressorContext {
		public AssemblyDef Assembly;
		public IKeyDeriver Deriver;
		public byte[] EncryptedModule;
		public MethodDef EntryPoint;
		public uint EntryPointToken;
		public byte[] KeySig;
		public uint KeyToken;
		public ModuleKind Kind;
		public List<Tuple<uint, uint, string>> ManifestResources;
		public int ModuleIndex;
		public string ModuleName;
		public byte[] OriginModule;
		public ModuleDef OriginModuleDef;
		public bool CompatMode;

		public byte[] Encrypt(ICompressionService compress, byte[] data, uint seed, Action<double> progressFunc) {
			data = (byte[])data.Clone();
			var dst = new uint[0x10];
			var src = new uint[0x10];
			ulong state = seed;
			for (int i = 0; i < 0x10; i++) {
				state = (state * state) % 0x143fc089;
				src[i] = (uint)state;
				dst[i] = (uint)((state * state) % 0x444d56fb);
			}
			uint[] key = Deriver.DeriveKey(dst, src);

			var z = (uint)(state % 0x8a5cb7);
			for (int i = 0; i < data.Length; i++) {
				data[i] ^= (byte)state;
				if ((i & 0xff) == 0)
					state = (state * state) % 0x8a5cb7;
			}
			data = compress.Compress(data, progressFunc);
			Array.Resize(ref data, (data.Length + 3) & ~3);

			var encryptedData = new byte[data.Length];
			int keyIndex = 0;
			for (int i = 0; i < data.Length; i += 4) {
				var datum = (uint)(data[i + 0] | (data[i + 1] << 8) | (data[i + 2] << 16) | (data[i + 3] << 24));
				uint encrypted = datum ^ key[keyIndex & 0xf];
				key[keyIndex & 0xf] = (key[keyIndex & 0xf] ^ datum) + 0x3ddb2819;
				encryptedData[i + 0] = (byte)(encrypted >> 0);
				encryptedData[i + 1] = (byte)(encrypted >> 8);
				encryptedData[i + 2] = (byte)(encrypted >> 16);
				encryptedData[i + 3] = (byte)(encrypted >> 24);
				keyIndex++;
			}

			return encryptedData;
		}
	}
}


================================================
File: Confuser.Protections/Compress/DynamicDeriver.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using Confuser.Core;
using Confuser.Core.Services;
using Confuser.DynCipher;
using Confuser.DynCipher.AST;
using Confuser.DynCipher.Generation;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.Compress {
	internal class DynamicDeriver : IKeyDeriver {
		StatementBlock derivation;
		Action<uint[], uint[]> encryptFunc;

		public void Init(ConfuserContext ctx, RandomGenerator random) {
			StatementBlock dummy;
			ctx.Registry.GetService<IDynCipherService>().GenerateCipherPair(random, out derivation, out dummy);

			var dmCodeGen = new DMCodeGen(typeof(void), new[] {
				Tuple.Create("{BUFFER}", typeof(uint[])),
				Tuple.Create("{KEY}", typeof(uint[]))
			});
			dmCodeGen.GenerateCIL(derivation);
			encryptFunc = dmCodeGen.Compile<Action<uint[], uint[]>>();
		}

		public uint[] DeriveKey(uint[] a, uint[] b) {
			var ret = new uint[0x10];
			Buffer.BlockCopy(a, 0, ret, 0, a.Length * sizeof(uint));
			encryptFunc(ret, b);
			return ret;
		}

		public IEnumerable<Instruction> EmitDerivation(MethodDef method, ConfuserContext ctx, Local dst, Local src) {
			var ret = new List<Instruction>();
			var codeGen = new CodeGen(dst, src, method, ret);
			codeGen.GenerateCIL(derivation);
			codeGen.Commit(method.Body);
			return ret;
		}

		class CodeGen : CILCodeGen {
			readonly Local block;
			readonly Local key;

			public CodeGen(Local block, Local key, MethodDef method, IList<Instruction> instrs)
				: base(method, instrs) {
				this.block = block;
				this.key = key;
			}

			protected override Local Var(Variable var) {
				if (var.Name == "{BUFFER}")
					return block;
				if (var.Name == "{KEY}")
					return key;
				return base.Var(var);
			}
		}
	}
}


================================================
File: Confuser.Protections/Compress/ExtractPhase.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Confuser.Core;
using dnlib.DotNet;
using dnlib.DotNet.MD;
using dnlib.DotNet.Writer;

namespace Confuser.Protections.Compress {
	internal class ExtractPhase : ProtectionPhase {
		public ExtractPhase(Compressor parent) : base(parent) { }

		public override ProtectionTargets Targets {
			get { return ProtectionTargets.Modules; }
		}

		public override string Name {
			get { return "Packer info extraction"; }
		}

		protected override void Execute(ConfuserContext context, ProtectionParameters parameters) {
			if (context.Packer == null)
				return;

			bool isExe = context.CurrentModule.Kind == ModuleKind.Windows ||
			             context.CurrentModule.Kind == ModuleKind.Console;

			if (context.Annotations.Get<CompressorContext>(context, Compressor.ContextKey) != null) {
				if (isExe) {
					context.Logger.Error("Too many executable modules!");
					throw new ConfuserException(null);
				}
				return;
			}

			if (isExe) {
				var ctx = new CompressorContext {
					ModuleIndex = context.CurrentModuleIndex,
					Assembly = context.CurrentModule.Assembly,
					CompatMode = parameters.GetParameter(context, null, "compat", false)
				};
				context.Annotations.Set(context, Compressor.ContextKey, ctx);

				ctx.ModuleName = context.CurrentModule.Name;
				ctx.EntryPoint = context.CurrentModule.EntryPoint;
				ctx.Kind = context.CurrentModule.Kind;

				if (!ctx.CompatMode) {
					context.CurrentModule.Name = "koi";
					context.CurrentModule.EntryPoint = null;
					context.CurrentModule.Kind = ModuleKind.NetModule;
				}

				context.CurrentModuleWriterListener.OnWriterEvent += new ResourceRecorder(ctx, context.CurrentModule).OnWriterEvent;
			}
		}

		class ResourceRecorder {
			readonly CompressorContext ctx;
			ModuleDef targetModule;

			public ResourceRecorder(CompressorContext ctx, ModuleDef module) {
				this.ctx = ctx;
				targetModule = module;
			}

			public void OnWriterEvent(object sender, ModuleWriterListenerEventArgs e) {
				if (e.WriterEvent == ModuleWriterEvent.MDEndAddResources) {
					var writer = (ModuleWriterBase)sender;
					ctx.ManifestResources = new List<Tuple<uint, uint, string>>();
					Dictionary<uint, byte[]> stringDict = writer.MetaData.StringsHeap.GetAllRawData().ToDictionary(pair => pair.Key, pair => pair.Value);
					foreach (RawManifestResourceRow resource in writer.MetaData.TablesHeap.ManifestResourceTable)
						ctx.ManifestResources.Add(Tuple.Create(resource.Offset, resource.Flags, Encoding.UTF8.GetString(stringDict[resource.Name])));
					ctx.EntryPointToken = writer.MetaData.GetToken(ctx.EntryPoint).Raw;
				}
			}
		}
	}
}


================================================
File: Confuser.Protections/Compress/IKeyDeriver.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using Confuser.Core;
using Confuser.Core.Services;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.Compress {
	internal enum Mode {
		Normal,
		Dynamic
	}

	internal interface IKeyDeriver {
		void Init(ConfuserContext ctx, RandomGenerator random);
		uint[] DeriveKey(uint[] a, uint[] b);
		IEnumerable<Instruction> EmitDerivation(MethodDef method, ConfuserContext ctx, Local dst, Local src);
	}
}


================================================
File: Confuser.Protections/Compress/NormalDeriver.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using Confuser.Core;
using Confuser.Core.Services;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.Compress {
	internal class NormalDeriver : IKeyDeriver {
		uint k1;
		uint k2;
		uint k3;
		uint seed;

		public void Init(ConfuserContext ctx, RandomGenerator random) {
			k1 = random.NextUInt32() | 1;
			k2 = random.NextUInt32() | 1;
			k3 = random.NextUInt32() | 1;
			seed = random.NextUInt32();
		}

		public uint[] DeriveKey(uint[] a, uint[] b) {
			var ret = new uint[0x10];
			var state = seed;
			for (int i = 0; i < 0x10; i++) {
				switch (state % 3) {
					case 0:
						ret[i] = a[i] ^ b[i];
						break;
					case 1:
						ret[i] = a[i] * b[i];
						break;
					case 2:
						ret[i] = a[i] + b[i];
						break;
				}
				state = (state * state) % 0x2E082D35;
				switch (state % 3) {
					case 0:
						ret[i] += k1;
						break;
					case 1:
						ret[i] ^= k2;
						break;
					case 2:
						ret[i] *= k3;
						break;
				}
				state = (state * state) % 0x2E082D35;
			}
			return ret;
		}

		public IEnumerable<Instruction> EmitDerivation(MethodDef method, ConfuserContext ctx, Local dst, Local src) {
			var state = seed;
			for (int i = 0; i < 0x10; i++) {
				yield return Instruction.Create(OpCodes.Ldloc, dst);
				yield return Instruction.Create(OpCodes.Ldc_I4, i);
				yield return Instruction.Create(OpCodes.Ldloc, dst);
				yield return Instruction.Create(OpCodes.Ldc_I4, i);
				yield return Instruction.Create(OpCodes.Ldelem_U4);
				yield return Instruction.Create(OpCodes.Ldloc, src);
				yield return Instruction.Create(OpCodes.Ldc_I4, i);
				yield return Instruction.Create(OpCodes.Ldelem_U4);
				switch (state % 3) {
					case 0:
						yield return Instruction.Create(OpCodes.Xor);
						break;
					case 1:
						yield return Instruction.Create(OpCodes.Mul);
						break;
					case 2:
						yield return Instruction.Create(OpCodes.Add);
						break;
				}
				state = (state * state) % 0x2E082D35;
				switch (state % 3) {
					case 0:
						yield return Instruction.Create(OpCodes.Ldc_I4, (int)k1);
						yield return Instruction.Create(OpCodes.Add);
						break;
					case 1:
						yield return Instruction.Create(OpCodes.Ldc_I4, (int)k2);
						yield return Instruction.Create(OpCodes.Xor);
						break;
					case 2:
						yield return Instruction.Create(OpCodes.Ldc_I4, (int)k3);
						yield return Instruction.Create(OpCodes.Mul);
						break;
				}
				state = (state * state) % 0x2E082D35;
				yield return Instruction.Create(OpCodes.Stelem_I4);
			}
		}
	}
}


================================================
File: Confuser.Protections/Compress/StubProtection.cs
================================================
ï»¿using System;
using System.Diagnostics;
using System.Security.Cryptography;
using Confuser.Core;
using Confuser.Renamer;
using dnlib.DotNet;
using dnlib.DotNet.MD;
using dnlib.DotNet.Writer;

namespace Confuser.Protections.Compress {
	internal class StubProtection : Protection {
		readonly CompressorContext ctx;
		readonly ModuleDef originModule;

		internal StubProtection(CompressorContext ctx, ModuleDef originModule) {
			this.ctx = ctx;
			this.originModule = originModule;
		}

		public override string Name {
			get { return "Compressor Stub Protection"; }
		}

		public override string Description {
			get { return "Do some extra works on the protected stub."; }
		}

		public override string Id {
			get { return "Ki.Compressor.Protection"; }
		}

		public override string FullId {
			get { return "Ki.Compressor.Protection"; }
		}

		public override ProtectionPreset Preset {
			get { return ProtectionPreset.None; }
		}

		protected override void Initialize(ConfuserContext context) {
			//
		}

		protected override void PopulatePipeline(ProtectionPipeline pipeline) {
			if (!ctx.CompatMode)
				pipeline.InsertPreStage(PipelineStage.Inspection, new InjPhase(this));
			pipeline.InsertPostStage(PipelineStage.BeginModule, new SigPhase(this));
		}

		class InjPhase : ProtectionPhase {
			public InjPhase(StubProtection parent)
				: base(parent) { }

			public override ProtectionTargets Targets {
				get { return ProtectionTargets.Modules; }
			}

			public override bool ProcessAll {
				get { return true; }
			}

			public override string Name {
				get { return "Module injection"; }
			}

			protected override void Execute(ConfuserContext context, ProtectionParameters parameters) {
				// Hack the origin module into the assembly to make sure correct type resolution
				var originModule = ((StubProtection)Parent).originModule;
				originModule.Assembly.Modules.Remove(originModule);
				context.Modules[0].Assembly.Modules.Add(((StubProtection)Parent).originModule);
			}
		}

		class SigPhase : ProtectionPhase {
			public SigPhase(StubProtection parent)
				: base(parent) { }

			public override ProtectionTargets Targets {
				get { return ProtectionTargets.Modules; }
			}

			public override string Name {
				get { return "Packer info encoding"; }
			}

			protected override void Execute(ConfuserContext context, ProtectionParameters parameters) {
				var field = context.CurrentModule.Types[0].FindField("DataField");
				Debug.Assert(field != null);
				context.Registry.GetService<INameService>().SetCanRename(field, true);

				context.CurrentModuleWriterListener.OnWriterEvent += (sender, e) => {
					if (e.WriterEvent == ModuleWriterEvent.MDBeginCreateTables) {
						// Add key signature
						var writer = (ModuleWriterBase)sender;
						var prot = (StubProtection)Parent;
						uint blob = writer.MetaData.BlobHeap.Add(prot.ctx.KeySig);
						uint rid = writer.MetaData.TablesHeap.StandAloneSigTable.Add(new RawStandAloneSigRow(blob));
						Debug.Assert((0x11000000 | rid) == prot.ctx.KeyToken);

						if (prot.ctx.CompatMode)
							return;

						// Add File reference
						byte[] hash = SHA1.Create().ComputeHash(prot.ctx.OriginModule);
						uint hashBlob = writer.MetaData.BlobHeap.Add(hash);

						MDTable<RawFileRow> fileTbl = writer.MetaData.TablesHeap.FileTable;
						uint fileRid = fileTbl.Add(new RawFileRow(
							                           (uint)FileAttributes.ContainsMetaData,
							                           writer.MetaData.StringsHeap.Add("koi"),
							                           hashBlob));
					}
				};
			}
		}
	}
}


================================================
File: Confuser.Protections/Constants/CEContext.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using Confuser.Core;
using Confuser.Core.Services;
using Confuser.DynCipher;
using Confuser.Renamer;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.Constants {
	internal class CEContext {
		public ConfuserContext Context;
		public ConstantProtection Protection;
		public ModuleDef Module;

		public FieldDef BufferField;
		public FieldDef DataField;
		public TypeDef DataType;
		public MethodDef InitMethod;

		public int DecoderCount;
		public List<Tuple<MethodDef, DecoderDesc>> Decoders;

		public EncodeElements Elements;
		public List<uint> EncodedBuffer;

		public Mode Mode;
		public IEncodeMode ModeHandler;

		public IDynCipherService DynCipher;
		public IMarkerService Marker;
		public INameService Name;
		public RandomGenerator Random;

		public TypeDef CfgCtxType;
		public MethodDef CfgCtxCtor;
		public MethodDef CfgCtxNext;
		public Dictionary<MethodDef, List<Tuple<Instruction, uint, IMethod>>> ReferenceRepl;
	}

	internal class DecoderDesc {
		public object Data;
		public byte InitializerID;
		public byte NumberID;
		public byte StringID;
	}
}


================================================
File: Confuser.Protections/Constants/ConstantProtection.cs
================================================
ï»¿using System;
using Confuser.Core;
using Confuser.Protections.Constants;
using dnlib.DotNet;

namespace Confuser.Protections {
	public interface IConstantService {
		void ExcludeMethod(ConfuserContext context, MethodDef method);
	}

	[BeforeProtection("Ki.ControlFlow"), AfterProtection("Ki.RefProxy")]
	internal class ConstantProtection : Protection, IConstantService {
		public const string _Id = "constants";
		public const string _FullId = "Ki.Constants";
		public const string _ServiceId = "Ki.Constants";
		internal static readonly object ContextKey = new object();

		public override string Name {
			get { return "Constants Protection"; }
		}

		public override string Description {
			get { return "This protection encodes and compresses constants in the code."; }
		}

		public override string Id {
			get { return _Id; }
		}

		public override string FullId {
			get { return _FullId; }
		}

		public override ProtectionPreset Preset {
			get { return ProtectionPreset.Normal; }
		}

		public void ExcludeMethod(ConfuserContext context, MethodDef method) {
			ProtectionParameters.GetParameters(context, method).Remove(this);
		}

		protected override void Initialize(ConfuserContext context) {
			context.Registry.RegisterService(_ServiceId, typeof(IConstantService), this);
		}

		protected override void PopulatePipeline(ProtectionPipeline pipeline) {
			pipeline.InsertPreStage(PipelineStage.ProcessModule, new InjectPhase(this));
			pipeline.InsertPostStage(PipelineStage.ProcessModule, new EncodePhase(this));
		}
	}
}


================================================
File: Confuser.Protections/Constants/DynamicMode.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Diagnostics;
using Confuser.Core.Helpers;
using Confuser.DynCipher;
using Confuser.DynCipher.AST;
using Confuser.DynCipher.Generation;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.Constants {
	internal class DynamicMode : IEncodeMode {
		Action<uint[], uint[]> encryptFunc;

		public IEnumerable<Instruction> EmitDecrypt(MethodDef init, CEContext ctx, Local block, Local key) {
			StatementBlock encrypt, decrypt;
			ctx.DynCipher.GenerateCipherPair(ctx.Random, out encrypt, out decrypt);
			var ret = new List<Instruction>();

			var codeGen = new CodeGen(block, key, init, ret);
			codeGen.GenerateCIL(decrypt);
			codeGen.Commit(init.Body);

			var dmCodeGen = new DMCodeGen(typeof(void), new[] {
				Tuple.Create("{BUFFER}", typeof(uint[])),
				Tuple.Create("{KEY}", typeof(uint[]))
			});
			dmCodeGen.GenerateCIL(encrypt);
			encryptFunc = dmCodeGen.Compile<Action<uint[], uint[]>>();

			return ret;
		}

		public uint[] Encrypt(uint[] data, int offset, uint[] key) {
			var ret = new uint[key.Length];
			Buffer.BlockCopy(data, offset * sizeof(uint), ret, 0, key.Length * sizeof(uint));
			encryptFunc(ret, key);
			return ret;
		}

		public object CreateDecoder(MethodDef decoder, CEContext ctx) {
			uint k1 = ctx.Random.NextUInt32() | 1;
			uint k2 = ctx.Random.NextUInt32();
			MutationHelper.ReplacePlaceholder(decoder, arg => {
				var repl = new List<Instruction>();
				repl.AddRange(arg);
				repl.Add(Instruction.Create(OpCodes.Ldc_I4, (int)MathsUtils.modInv(k1)));
				repl.Add(Instruction.Create(OpCodes.Mul));
				repl.Add(Instruction.Create(OpCodes.Ldc_I4, (int)k2));
				repl.Add(Instruction.Create(OpCodes.Xor));
				return repl.ToArray();
			});
			return Tuple.Create(k1, k2);
		}

		public uint Encode(object data, CEContext ctx, uint id) {
			var key = (Tuple<uint, uint>)data;
			uint ret = (id ^ key.Item2) * key.Item1;
			Debug.Assert(((ret * MathsUtils.modInv(key.Item1)) ^ key.Item2) == id);
			return ret;
		}

		class CodeGen : CILCodeGen {
			readonly Local block;
			readonly Local key;

			public CodeGen(Local block, Local key, MethodDef init, IList<Instruction> instrs)
				: base(init, instrs) {
				this.block = block;
				this.key = key;
			}

			protected override Local Var(Variable var) {
				if (var.Name == "{BUFFER}")
					return block;
				if (var.Name == "{KEY}")
					return key;
				return base.Var(var);
			}
		}
	}
}


================================================
File: Confuser.Protections/Constants/EncodeElements.cs
================================================
ï»¿using System;

namespace Confuser.Protections.Constants {
	[Flags]
	internal enum EncodeElements {
		Strings = 1,
		Numbers = 2,
		Primitive = 4,
		Initializers = 8
	}
}


================================================
File: Confuser.Protections/Constants/EncodePhase.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
using Confuser.Core;
using Confuser.Core.Helpers;
using Confuser.Core.Services;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.Constants {
	internal class EncodePhase : ProtectionPhase {
		public EncodePhase(ConstantProtection parent)
			: base(parent) { }

		public override ProtectionTargets Targets {
			get { return ProtectionTargets.Methods; }
		}

		public override string Name {
			get { return "Constants encoding"; }
		}

		protected override void Execute(ConfuserContext context, ProtectionParameters parameters) {
			var moduleCtx = context.Annotations.Get<CEContext>(context.CurrentModule, ConstantProtection.ContextKey);
			if (!parameters.Targets.Any() || moduleCtx == null)
				return;

			var ldc = new Dictionary<object, List<Tuple<MethodDef, Instruction>>>();
			var ldInit = new Dictionary<byte[], List<Tuple<MethodDef, Instruction>>>(new ByteArrayComparer());

			// Extract constants
			ExtractConstants(context, parameters, moduleCtx, ldc, ldInit);

			// Encode constants
			moduleCtx.ReferenceRepl = new Dictionary<MethodDef, List<Tuple<Instruction, uint, IMethod>>>();
			moduleCtx.EncodedBuffer = new List<uint>();
			foreach (var entry in ldInit.WithProgress(context.Logger)) // Ensure the array length haven't been encoded yet
			{
				EncodeInitializer(moduleCtx, entry.Key, entry.Value);
				context.CheckCancellation();
			}
			foreach (var entry in ldc.WithProgress(context.Logger)) {
				if (entry.Key is string) {
					EncodeString(moduleCtx, (string)entry.Key, entry.Value);
				}
				else if (entry.Key is int) {
					EncodeConstant32(moduleCtx, (uint)(int)entry.Key, context.CurrentModule.CorLibTypes.Int32, entry.Value);
				}
				else if (entry.Key is long) {
					EncodeConstant64(moduleCtx, (uint)((long)entry.Key >> 32), (uint)(long)entry.Key, context.CurrentModule.CorLibTypes.Int64, entry.Value);
				}
				else if (entry.Key is float) {
					var t = new RTransform();
					t.R4 = (float)entry.Key;
					EncodeConstant32(moduleCtx, t.Lo, context.CurrentModule.CorLibTypes.Single, entry.Value);
				}
				else if (entry.Key is double) {
					var t = new RTransform();
					t.R8 = (double)entry.Key;
					EncodeConstant64(moduleCtx, t.Hi, t.Lo, context.CurrentModule.CorLibTypes.Double, entry.Value);
				}
				else
					throw new UnreachableException();
				context.CheckCancellation();
			}
			ReferenceReplacer.ReplaceReference(moduleCtx, parameters);

			// compress
			var encodedBuff = new byte[moduleCtx.EncodedBuffer.Count * 4];
			int buffIndex = 0;
			foreach (uint dat in moduleCtx.EncodedBuffer) {
				encodedBuff[buffIndex++] = (byte)((dat >> 0) & 0xff);
				encodedBuff[buffIndex++] = (byte)((dat >> 8) & 0xff);
				encodedBuff[buffIndex++] = (byte)((dat >> 16) & 0xff);
				encodedBuff[buffIndex++] = (byte)((dat >> 24) & 0xff);
			}
			Debug.Assert(buffIndex == encodedBuff.Length);
			encodedBuff = context.Registry.GetService<ICompressionService>().Compress(encodedBuff);
			context.CheckCancellation();

			uint compressedLen = (uint)(encodedBuff.Length + 3) / 4;
			compressedLen = (compressedLen + 0xfu) & ~0xfu;
			var compressedBuff = new uint[compressedLen];
			Buffer.BlockCopy(encodedBuff, 0, compressedBuff, 0, encodedBuff.Length);
			Debug.Assert(compressedLen % 0x10 == 0);

			// encrypt
			uint keySeed = moduleCtx.Random.NextUInt32();
			var key = new uint[0x10];
			uint state = keySeed;
			for (int i = 0; i < 0x10; i++) {
				state ^= state >> 12;
				state ^= state << 25;
				state ^= state >> 27;
				key[i] = state;
			}

			var encryptedBuffer = new byte[compressedBuff.Length * 4];
			buffIndex = 0;
			while (buffIndex < compressedBuff.Length) {
				uint[] enc = moduleCtx.ModeHandler.Encrypt(compressedBuff, buffIndex, key);
				for (int j = 0; j < 0x10; j++)
					key[j] ^= compressedBuff[buffIndex + j];
				Buffer.BlockCopy(enc, 0, encryptedBuffer, buffIndex * 4, 0x40);
				buffIndex += 0x10;
			}
			Debug.Assert(buffIndex == compressedBuff.Length);

			moduleCtx.DataField.InitialValue = encryptedBuffer;
			moduleCtx.DataField.HasFieldRVA = true;
			moduleCtx.DataType.ClassLayout = new ClassLayoutUser(0, (uint)encryptedBuffer.Length);
			MutationHelper.InjectKeys(moduleCtx.InitMethod,
			                          new[] { 0, 1 },
			                          new[] { encryptedBuffer.Length / 4, (int)keySeed });
			MutationHelper.ReplacePlaceholder(moduleCtx.InitMethod, arg => {
				var repl = new List<Instruction>();
				repl.AddRange(arg);
				repl.Add(Instruction.Create(OpCodes.Dup));
				repl.Add(Instruction.Create(OpCodes.Ldtoken, moduleCtx.DataField));
				repl.Add(Instruction.Create(OpCodes.Call, moduleCtx.Module.Import(
					typeof(RuntimeHelpers).GetMethod("InitializeArray"))));
				return repl.ToArray();
			});
		}

		void EncodeString(CEContext moduleCtx, string value, List<Tuple<MethodDef, Instruction>> references) {
			int buffIndex = EncodeByteArray(moduleCtx, Encoding.UTF8.GetBytes(value));

			UpdateReference(moduleCtx, moduleCtx.Module.CorLibTypes.String, references, buffIndex, desc => desc.StringID);
		}

		void EncodeConstant32(CEContext moduleCtx, uint value, TypeSig valueType, List<Tuple<MethodDef, Instruction>> references) {
			int buffIndex = moduleCtx.EncodedBuffer.IndexOf(value);
			if (buffIndex == -1) {
				buffIndex = moduleCtx.EncodedBuffer.Count;
				moduleCtx.EncodedBuffer.Add(value);
			}

			UpdateReference(moduleCtx, valueType, references, buffIndex, desc => desc.NumberID);
		}

		void EncodeConstant64(CEContext moduleCtx, uint hi, uint lo, TypeSig valueType, List<Tuple<MethodDef, Instruction>> references) {
			int buffIndex = -1;
			do {
				buffIndex = moduleCtx.EncodedBuffer.IndexOf(lo, buffIndex + 1);
				if (buffIndex + 1 < moduleCtx.EncodedBuffer.Count && moduleCtx.EncodedBuffer[buffIndex + 1] == hi)
					break;
			} while (buffIndex >= 0);
			
			if (buffIndex == -1) {
				buffIndex = moduleCtx.EncodedBuffer.Count;
				moduleCtx.EncodedBuffer.Add(lo);
				moduleCtx.EncodedBuffer.Add(hi);
			}

			UpdateReference(moduleCtx, valueType, references, buffIndex, desc => desc.NumberID);
		}

		void EncodeInitializer(CEContext moduleCtx, byte[] init, List<Tuple<MethodDef, Instruction>> references) {
			int buffIndex = -1;

			foreach (var instr in references) {
				IList<Instruction> instrs = instr.Item1.Body.Instructions;
				int i = instrs.IndexOf(instr.Item2);

				if (buffIndex == -1)
					buffIndex = EncodeByteArray(moduleCtx, init);

				Tuple<MethodDef, DecoderDesc> decoder = moduleCtx.Decoders[moduleCtx.Random.NextInt32(moduleCtx.Decoders.Count)];
				uint id = (uint)buffIndex | (uint)(decoder.Item2.InitializerID << 30);
				id = moduleCtx.ModeHandler.Encode(decoder.Item2.Data, moduleCtx, id);

				instrs[i - 4].Operand = (int)id;
				instrs[i - 3].OpCode = OpCodes.Call;
				var arrType = new SZArraySig(((ITypeDefOrRef)instrs[i - 3].Operand).ToTypeSig());
				instrs[i - 3].Operand = new MethodSpecUser(decoder.Item1, new GenericInstMethodSig(arrType));
				instrs.RemoveAt(i - 2);
				instrs.RemoveAt(i - 2);
				instrs.RemoveAt(i - 2);
			}
		}

		int EncodeByteArray(CEContext moduleCtx, byte[] buff) {
			int buffIndex = moduleCtx.EncodedBuffer.Count;
			moduleCtx.EncodedBuffer.Add((uint)buff.Length);

			// byte[] -> uint[]
			int integral = buff.Length / 4, remainder = buff.Length % 4;
			for (int i = 0; i < integral; i++) {
				var data = (uint)(buff[i * 4] | (buff[i * 4 + 1] << 8) | (buff[i * 4 + 2] << 16) | (buff[i * 4 + 3] << 24));
				moduleCtx.EncodedBuffer.Add(data);
			}
			if (remainder > 0) {
				int baseIndex = integral * 4;
				uint r = 0;
				for (int i = 0; i < remainder; i++)
					r |= (uint)(buff[baseIndex + i] << (i * 8));
				moduleCtx.EncodedBuffer.Add(r);
			}
			return buffIndex;
		}

		void UpdateReference(CEContext moduleCtx, TypeSig valueType, List<Tuple<MethodDef, Instruction>> references, int buffIndex, Func<DecoderDesc, byte> typeID) {
			foreach (var instr in references) {
				Tuple<MethodDef, DecoderDesc> decoder = moduleCtx.Decoders[moduleCtx.Random.NextInt32(moduleCtx.Decoders.Count)];
				uint id = (uint)buffIndex | (uint)(typeID(decoder.Item2) << 30);
				id = moduleCtx.ModeHandler.Encode(decoder.Item2.Data, moduleCtx, id);

				var targetDecoder = new MethodSpecUser(decoder.Item1, new GenericInstMethodSig(valueType));
				moduleCtx.ReferenceRepl.AddListEntry(instr.Item1, Tuple.Create(instr.Item2, id, (IMethod)targetDecoder));
			}
		}

		void RemoveDataFieldRefs(ConfuserContext context, HashSet<FieldDef> dataFields, HashSet<Instruction> fieldRefs) {
			foreach (var type in context.CurrentModule.GetTypes())
				foreach (var method in type.Methods.Where(m => m.HasBody)) {
					foreach (var instr in method.Body.Instructions)
						if (instr.Operand is FieldDef && !fieldRefs.Contains(instr))
							dataFields.Remove((FieldDef)instr.Operand);
				}

			foreach (var fieldToRemove in dataFields) {
				fieldToRemove.DeclaringType.Fields.Remove(fieldToRemove);
			}
		}

		void ExtractConstants(
			ConfuserContext context, ProtectionParameters parameters, CEContext moduleCtx,
			Dictionary<object, List<Tuple<MethodDef, Instruction>>> ldc,
			Dictionary<byte[], List<Tuple<MethodDef, Instruction>>> ldInit) {
			var dataFields = new HashSet<FieldDef>();
			var fieldRefs = new HashSet<Instruction>();
			foreach (MethodDef method in parameters.Targets.OfType<MethodDef>().WithProgress(context.Logger)) {
				if (!method.HasBody)
					continue;

				moduleCtx.Elements = 0;
				string elements = parameters.GetParameter(context, method, "elements", "SI");
				foreach (char elem in elements)
					switch (elem) {
						case 'S':
						case 's':
							moduleCtx.Elements |= EncodeElements.Strings;
							break;
						case 'N':
						case 'n':
							moduleCtx.Elements |= EncodeElements.Numbers;
							break;
						case 'P':
						case 'p':
							moduleCtx.Elements |= EncodeElements.Primitive;
							break;
						case 'I':
						case 'i':
							moduleCtx.Elements |= EncodeElements.Initializers;
							break;
					}

				if (moduleCtx.Elements == 0)
					continue;

				foreach (Instruction instr in method.Body.Instructions) {
					bool eligible = false;
					if (instr.OpCode == OpCodes.Ldstr && (moduleCtx.Elements & EncodeElements.Strings) != 0) {
						var operand = (string)instr.Operand;
						if (string.IsNullOrEmpty(operand) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)
							continue;
						eligible = true;
					}
					else if (instr.OpCode == OpCodes.Call && (moduleCtx.Elements & EncodeElements.Initializers) != 0) {
						var operand = (IMethod)instr.Operand;
						if (operand.DeclaringType.DefinitionAssembly.IsCorLib() &&
						    operand.DeclaringType.Namespace == "System.Runtime.CompilerServices" &&
						    operand.DeclaringType.Name == "RuntimeHelpers" &&
						    operand.Name == "InitializeArray") {
							IList<Instruction> instrs = method.Body.Instructions;
							int i = instrs.IndexOf(instr);
							if (instrs[i - 1].OpCode != OpCodes.Ldtoken) continue;
							if (instrs[i - 2].OpCode != OpCodes.Dup) continue;
							if (instrs[i - 3].OpCode != OpCodes.Newarr) continue;
							if (instrs[i - 4].OpCode != OpCodes.Ldc_I4) continue;

							var dataField = instrs[i - 1].Operand as FieldDef;
							if (dataField == null)
								continue;
							if (!dataField.HasFieldRVA || dataField.InitialValue == null)
								continue;

							// Prevent array length from being encoded
							var arrLen = (int)instrs[i - 4].Operand;
							if (ldc.ContainsKey(arrLen)) {
								List<Tuple<MethodDef, Instruction>> list = ldc[arrLen];
								list.RemoveWhere(entry => entry.Item2 == instrs[i - 4]);
								if (list.Count == 0)
									ldc.Remove(arrLen);
							}

							dataFields.Add(dataField);
							fieldRefs.Add(instrs[i - 1]);

							var value = new byte[dataField.InitialValue.Length + 4];
							value[0] = (byte)(arrLen >> 0);
							value[1] = (byte)(arrLen >> 8);
							value[2] = (byte)(arrLen >> 16);
							value[3] = (byte)(arrLen >> 24);
							Buffer.BlockCopy(dataField.InitialValue, 0, value, 4, dataField.InitialValue.Length);
							ldInit.AddListEntry(value, Tuple.Create(method, instr));
						}
					}
					else if ((moduleCtx.Elements & EncodeElements.Numbers) != 0) {
						if (instr.OpCode == OpCodes.Ldc_I4) {
							var operand = (int)instr.Operand;
							if ((operand >= -1 && operand <= 8) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)
								continue;
							eligible = true;
						}
						else if (instr.OpCode == OpCodes.Ldc_I8) {
							var operand = (long)instr.Operand;
							if ((operand >= -1 && operand <= 1) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)
								continue;
							eligible = true;
						}
						else if (instr.OpCode == OpCodes.Ldc_R4) {
							var operand = (float)instr.Operand;
							if ((operand == -1 || operand == 0 || operand == 1) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)
								continue;
							eligible = true;
						}
						else if (instr.OpCode == OpCodes.Ldc_R8) {
							var operand = (double)instr.Operand;
							if ((operand == -1 || operand == 0 || operand == 1) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)
								continue;
							eligible = true;
						}
					}

					if (eligible)
						ldc.AddListEntry(instr.Operand, Tuple.Create(method, instr));
				}

				context.CheckCancellation();
			}
			RemoveDataFieldRefs(context, dataFields, fieldRefs);
		}

		class ByteArrayComparer : IEqualityComparer<byte[]> {
			public bool Equals(byte[] x, byte[] y) {
				return x.SequenceEqual(y);
			}

			public int GetHashCode(byte[] obj) {
				int ret = 31;
				foreach (byte v in obj)
					ret = ret * 17 + v;
				return ret;
			}
		}

		[StructLayout(LayoutKind.Explicit)]
		struct RTransform {
			[FieldOffset(0)] public float R4;
			[FieldOffset(0)] public double R8;

			[FieldOffset(4)] public readonly uint Hi;
			[FieldOffset(0)] public readonly uint Lo;
		}
	}
}


================================================
File: Confuser.Protections/Constants/IEncodeMode.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.Constants {
	internal interface IEncodeMode {
		IEnumerable<Instruction> EmitDecrypt(MethodDef init, CEContext ctx, Local block, Local key);
		uint[] Encrypt(uint[] data, int offset, uint[] key);

		object CreateDecoder(MethodDef decoder, CEContext ctx);
		uint Encode(object data, CEContext ctx, uint id);
	}
}


================================================
File: Confuser.Protections/Constants/InjectPhase.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using Confuser.Core;
using Confuser.Core.Helpers;
using Confuser.Core.Services;
using Confuser.DynCipher;
using Confuser.Renamer;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using dnlib.DotNet.MD;

namespace Confuser.Protections.Constants {
	internal class InjectPhase : ProtectionPhase {
		public InjectPhase(ConstantProtection parent)
			: base(parent) { }

		public override ProtectionTargets Targets {
			get { return ProtectionTargets.Methods; }
		}

		public override string Name {
			get { return "Constant encryption helpers injection"; }
		}

		protected override void Execute(ConfuserContext context, ProtectionParameters parameters) {
			if (parameters.Targets.Any()) {
				var compression = context.Registry.GetService<ICompressionService>();
				var name = context.Registry.GetService<INameService>();
				var marker = context.Registry.GetService<IMarkerService>();
				var rt = context.Registry.GetService<IRuntimeService>();
				var moduleCtx = new CEContext {
					Protection = (ConstantProtection)Parent,
					Random = context.Registry.GetService<IRandomService>().GetRandomGenerator(Parent.Id),
					Context = context,
					Module = context.CurrentModule,
					Marker = marker,
					DynCipher = context.Registry.GetService<IDynCipherService>(),
					Name = name
				};

				// Extract parameters
				moduleCtx.Mode = parameters.GetParameter(context, context.CurrentModule, "mode", Mode.Normal);
				moduleCtx.DecoderCount = parameters.GetParameter(context, context.CurrentModule, "decoderCount", 5);

				switch (moduleCtx.Mode) {
					case Mode.Normal:
						moduleCtx.ModeHandler = new NormalMode();
						break;
					case Mode.Dynamic:
						moduleCtx.ModeHandler = new DynamicMode();
						break;
					case Mode.x86:
						moduleCtx.ModeHandler = new x86Mode();
						if ((context.CurrentModule.Cor20HeaderFlags & ComImageFlags.ILOnly) != 0)
							context.CurrentModuleWriterOptions.Cor20HeaderOptions.Flags &= ~ComImageFlags.ILOnly;
						break;
					default:
						throw new UnreachableException();
				}

				// Inject helpers
				MethodDef decomp = compression.GetRuntimeDecompressor(context.CurrentModule, member => {
					name.MarkHelper(member, marker, (Protection)Parent);
					if (member is MethodDef)
						ProtectionParameters.GetParameters(context, member).Remove(Parent);
				});
				InjectHelpers(context, compression, rt, moduleCtx);

				// Mutate codes
				MutateInitializer(moduleCtx, decomp);

				MethodDef cctor = context.CurrentModule.GlobalType.FindStaticConstructor();
				cctor.Body.Instructions.Insert(0, Instruction.Create(OpCodes.Call, moduleCtx.InitMethod));

				context.Annotations.Set(context.CurrentModule, ConstantProtection.ContextKey, moduleCtx);
			}
		}

		void InjectHelpers(ConfuserContext context, ICompressionService compression, IRuntimeService rt, CEContext moduleCtx) {
			IEnumerable<IDnlibDef> members = InjectHelper.Inject(rt.GetRuntimeType("Confuser.Runtime.Constant"), context.CurrentModule.GlobalType, context.CurrentModule);
			foreach (IDnlibDef member in members) {
				if (member.Name == "Get") {
					context.CurrentModule.GlobalType.Remove((MethodDef)member);
					continue;
				}
				if (member.Name == "b")
					moduleCtx.BufferField = (FieldDef)member;
				else if (member.Name == "Initialize")
					moduleCtx.InitMethod = (MethodDef)member;
				moduleCtx.Name.MarkHelper(member, moduleCtx.Marker, (Protection)Parent);
			}
			ProtectionParameters.GetParameters(context, moduleCtx.InitMethod).Remove(Parent);

			var dataType = new TypeDefUser("", moduleCtx.Name.RandomName(), context.CurrentModule.CorLibTypes.GetTypeRef("System", "ValueType"));
			dataType.Layout = TypeAttributes.ExplicitLayout;
			dataType.Visibility = TypeAttributes.NestedPrivate;
			dataType.IsSealed = true;
			moduleCtx.DataType = dataType;
			context.CurrentModule.GlobalType.NestedTypes.Add(dataType);
			moduleCtx.Name.MarkHelper(dataType, moduleCtx.Marker, (Protection)Parent);

			moduleCtx.DataField = new FieldDefUser(moduleCtx.Name.RandomName(), new FieldSig(dataType.ToTypeSig())) {
				IsStatic = true,
				Access = FieldAttributes.CompilerControlled
			};
			context.CurrentModule.GlobalType.Fields.Add(moduleCtx.DataField);
			moduleCtx.Name.MarkHelper(moduleCtx.DataField, moduleCtx.Marker, (Protection)Parent);

			MethodDef decoder = rt.GetRuntimeType("Confuser.Runtime.Constant").FindMethod("Get");
			moduleCtx.Decoders = new List<Tuple<MethodDef, DecoderDesc>>();
			for (int i = 0; i < moduleCtx.DecoderCount; i++) {
				MethodDef decoderInst = InjectHelper.Inject(decoder, context.CurrentModule);
				for (int j = 0; j < decoderInst.Body.Instructions.Count; j++) {
					Instruction instr = decoderInst.Body.Instructions[j];
					var method = instr.Operand as IMethod;
					var field = instr.Operand as IField;
					if (instr.OpCode == OpCodes.Call &&
					    method.DeclaringType.Name == "Mutation" &&
					    method.Name == "Value") {
						decoderInst.Body.Instructions[j] = Instruction.Create(OpCodes.Sizeof, new GenericMVar(0).ToTypeDefOrRef());
					}
					else if (instr.OpCode == OpCodes.Ldsfld &&
					         method.DeclaringType.Name == "Constant") {
						if (field.Name == "b") instr.Operand = moduleCtx.BufferField;
						else throw new UnreachableException();
					}
				}
				context.CurrentModule.GlobalType.Methods.Add(decoderInst);
				moduleCtx.Name.MarkHelper(decoderInst, moduleCtx.Marker, (Protection)Parent);
				ProtectionParameters.GetParameters(context, decoderInst).Remove(Parent);

				var decoderDesc = new DecoderDesc();

				decoderDesc.StringID = (byte)(moduleCtx.Random.NextByte() & 3);

				do decoderDesc.NumberID = (byte)(moduleCtx.Random.NextByte() & 3); while (decoderDesc.NumberID == decoderDesc.StringID);

				do decoderDesc.InitializerID = (byte)(moduleCtx.Random.NextByte() & 3); while (decoderDesc.InitializerID == decoderDesc.StringID || decoderDesc.InitializerID == decoderDesc.NumberID);

				MutationHelper.InjectKeys(decoderInst,
				                          new[] { 0, 1, 2 },
				                          new int[] { decoderDesc.StringID, decoderDesc.NumberID, decoderDesc.InitializerID });
				decoderDesc.Data = moduleCtx.ModeHandler.CreateDecoder(decoderInst, moduleCtx);
				moduleCtx.Decoders.Add(Tuple.Create(decoderInst, decoderDesc));
			}
		}

		void MutateInitializer(CEContext moduleCtx, MethodDef decomp) {
			moduleCtx.InitMethod.Body.SimplifyMacros(moduleCtx.InitMethod.Parameters);
			List<Instruction> instrs = moduleCtx.InitMethod.Body.Instructions.ToList();
			for (int i = 0; i < instrs.Count; i++) {
				Instruction instr = instrs[i];
				var method = instr.Operand as IMethod;
				if (instr.OpCode == OpCodes.Call) {
					if (method.DeclaringType.Name == "Mutation" &&
					    method.Name == "Crypt") {
						Instruction ldBlock = instrs[i - 2];
						Instruction ldKey = instrs[i - 1];
						Debug.Assert(ldBlock.OpCode == OpCodes.Ldloc && ldKey.OpCode == OpCodes.Ldloc);
						instrs.RemoveAt(i);
						instrs.RemoveAt(i - 1);
						instrs.RemoveAt(i - 2);
						instrs.InsertRange(i - 2, moduleCtx.ModeHandler.EmitDecrypt(moduleCtx.InitMethod, moduleCtx, (Local)ldBlock.Operand, (Local)ldKey.Operand));
					}
					else if (method.DeclaringType.Name == "Lzma" &&
					         method.Name == "Decompress") {
						instr.Operand = decomp;
					}
				}
			}
			moduleCtx.InitMethod.Body.Instructions.Clear();
			foreach (Instruction instr in instrs)
				moduleCtx.InitMethod.Body.Instructions.Add(instr);
		}
	}
}


================================================
File: Confuser.Protections/Constants/Mode.cs
================================================
ï»¿using System;

namespace Confuser.Protections.Constants {
	internal enum Mode {
		Normal,
		Dynamic,
		x86
	}
}


================================================
File: Confuser.Protections/Constants/NormalMode.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Diagnostics;
using Confuser.Core.Helpers;
using Confuser.DynCipher;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.Constants {
	internal class NormalMode : IEncodeMode {
		public IEnumerable<Instruction> EmitDecrypt(MethodDef init, CEContext ctx, Local block, Local key) {
			for (int i = 0; i < 0x10; i++) {
				yield return Instruction.Create(OpCodes.Ldloc, block);
				yield return Instruction.Create(OpCodes.Ldc_I4, i);
				yield return Instruction.Create(OpCodes.Ldloc, block);
				yield return Instruction.Create(OpCodes.Ldc_I4, i);
				yield return Instruction.Create(OpCodes.Ldelem_U4);
				yield return Instruction.Create(OpCodes.Ldloc, key);
				yield return Instruction.Create(OpCodes.Ldc_I4, i);
				yield return Instruction.Create(OpCodes.Ldelem_U4);
				yield return Instruction.Create(OpCodes.Xor);
				yield return Instruction.Create(OpCodes.Stelem_I4);
			}
		}

		public uint[] Encrypt(uint[] data, int offset, uint[] key) {
			var ret = new uint[key.Length];
			for (int i = 0; i < key.Length; i++)
				ret[i] = data[i + offset] ^ key[i];
			return ret;
		}

		public object CreateDecoder(MethodDef decoder, CEContext ctx) {
			uint k1 = ctx.Random.NextUInt32() | 1;
			uint k2 = ctx.Random.NextUInt32();
			MutationHelper.ReplacePlaceholder(decoder, arg => {
				var repl = new List<Instruction>();
				repl.AddRange(arg);
				repl.Add(Instruction.Create(OpCodes.Ldc_I4, (int)MathsUtils.modInv(k1)));
				repl.Add(Instruction.Create(OpCodes.Mul));
				repl.Add(Instruction.Create(OpCodes.Ldc_I4, (int)k2));
				repl.Add(Instruction.Create(OpCodes.Xor));
				return repl.ToArray();
			});
			return Tuple.Create(k1, k2);
		}

		public uint Encode(object data, CEContext ctx, uint id) {
			var key = (Tuple<uint, uint>)data;
			uint ret = (id ^ key.Item2) * key.Item1;
			Debug.Assert(((ret * MathsUtils.modInv(key.Item1)) ^ key.Item2) == id);
			return ret;
		}
	}
}


================================================
File: Confuser.Protections/Constants/ReferenceReplacer.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using Confuser.Core;
using Confuser.Core.Helpers;
using Confuser.Core.Services;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.Constants {
	internal class ReferenceReplacer {
		public static void ReplaceReference(CEContext ctx, ProtectionParameters parameters) {
			foreach (var entry in ctx.ReferenceRepl) {
				if (parameters.GetParameter<bool>(ctx.Context, entry.Key, "cfg"))
					ReplaceCFG(entry.Key, entry.Value, ctx);
				else
					ReplaceNormal(entry.Key, entry.Value);
			}
		}

		static void ReplaceNormal(MethodDef method, List<Tuple<Instruction, uint, IMethod>> instrs) {
			foreach (var instr in instrs) {
				int i = method.Body.Instructions.IndexOf(instr.Item1);
				instr.Item1.OpCode = OpCodes.Ldc_I4;
				instr.Item1.Operand = (int)instr.Item2;
				method.Body.Instructions.Insert(i + 1, Instruction.Create(OpCodes.Call, instr.Item3));
			}
		}

		struct CFGContext {
			public CEContext Ctx;
			public ControlFlowGraph Graph;
			public BlockKey[] Keys;
			public RandomGenerator Random;
			public Dictionary<uint, CFGState> StatesMap;
			public Local StateVariable;
		}

		struct CFGState {
			public uint A;
			public uint B;
			public uint C;
			public uint D;

			public CFGState(uint seed) {
				A = seed *= 0x21412321;
				B = seed *= 0x21412321;
				C = seed *= 0x21412321;
				D = seed *= 0x21412321;
			}

			public void UpdateExplicit(int id, uint value) {
				switch (id) {
					case 0:
						A = value;
						break;
					case 1:
						B = value;
						break;
					case 2:
						C = value;
						break;
					case 3:
						D = value;
						break;
				}
			}

			public void UpdateIncremental(int id, uint value) {
				switch (id) {
					case 0:
						A *= value;
						break;
					case 1:
						B += value;
						break;
					case 2:
						C ^= value;
						break;
					case 3:
						D -= value;
						break;
				}
			}

			public uint GetIncrementalUpdate(int id, uint target) {
				switch (id) {
					case 0:
						return A ^ target;
					case 1:
						return target - B;
					case 2:
						return C ^ target;
					case 3:
						return D - target;
				}
				throw new UnreachableException();
			}

			public uint Get(int id) {
				switch (id) {
					case 0:
						return A;
					case 1:
						return B;
					case 2:
						return C;
					case 3:
						return D;
				}
				throw new UnreachableException();
			}

			public static byte EncodeFlag(bool exp, int updateId, int getId) {
				byte fl = (byte)(exp ? 0x80 : 0);
				fl |= (byte)updateId;
				fl |= (byte)(getId << 2);
				return fl;
			}
		}

		static void InjectStateType(CEContext ctx) {
			if (ctx.CfgCtxType == null) {
				var type = ctx.Context.Registry.GetService<IRuntimeService>().GetRuntimeType("Confuser.Runtime.CFGCtx");
				ctx.CfgCtxType = InjectHelper.Inject(type, ctx.Module);
				ctx.Module.Types.Add(ctx.CfgCtxType);
				ctx.CfgCtxCtor = ctx.CfgCtxType.FindMethod(".ctor");
				ctx.CfgCtxNext = ctx.CfgCtxType.FindMethod("Next");

				ctx.Name.MarkHelper(ctx.CfgCtxType, ctx.Marker, ctx.Protection);
				foreach (var def in ctx.CfgCtxType.Fields)
					ctx.Name.MarkHelper(def, ctx.Marker, ctx.Protection);
				foreach (var def in ctx.CfgCtxType.Methods)
					ctx.Name.MarkHelper(def, ctx.Marker, ctx.Protection);
			}
		}

		static void InsertEmptyStateUpdate(CFGContext ctx, ControlFlowBlock block) {
			var body = ctx.Graph.Body;
			var key = ctx.Keys[block.Id];
			if (key.EntryState == key.ExitState)
				return;

			Instruction first = null;
			// Cannot use graph.IndexOf because instructions has been modified.
			int targetIndex = body.Instructions.IndexOf(block.Header);

			CFGState entry;
			if (!ctx.StatesMap.TryGetValue(key.EntryState, out entry)) {
				key.Type = BlockKeyType.Explicit;
			}


			if (key.Type == BlockKeyType.Incremental) {
				// Incremental

				CFGState exit;
				if (!ctx.StatesMap.TryGetValue(key.ExitState, out exit)) {
					// Create new exit state
					// Update one of the entry states to be exit state
					exit = entry;
					int updateId = ctx.Random.NextInt32(3);
					uint targetValue = ctx.Random.NextUInt32();
					exit.UpdateExplicit(updateId, targetValue);

					int getId = ctx.Random.NextInt32(3);
					var fl = CFGState.EncodeFlag(false, updateId, getId);
					var incr = entry.GetIncrementalUpdate(updateId, targetValue);

					body.Instructions.Insert(targetIndex++, first = Instruction.Create(OpCodes.Ldloca, ctx.StateVariable));
					body.Instructions.Insert(targetIndex++, Instruction.Create(OpCodes.Ldc_I4_S, (sbyte)fl));
					body.Instructions.Insert(targetIndex++, Instruction.Create(OpCodes.Ldc_I4, (int)incr));
					body.Instructions.Insert(targetIndex++, Instruction.Create(OpCodes.Call, ctx.Ctx.CfgCtxNext));
					body.Instructions.Insert(targetIndex++, Instruction.Create(OpCodes.Pop));

					ctx.StatesMap[key.ExitState] = exit;
				}
				else {
					// Scan for updated state
					var headerIndex = targetIndex;
					for (int stateId = 0; stateId < 4; stateId++) {
						if (entry.Get(stateId) == exit.Get(stateId))
							continue;

						uint targetValue = exit.Get(stateId);
						int getId = ctx.Random.NextInt32(3);
						var fl = CFGState.EncodeFlag(false, stateId, getId);
						var incr = entry.GetIncrementalUpdate(stateId, targetValue);

						body.Instructions.Insert(targetIndex++, Instruction.Create(OpCodes.Ldloca, ctx.StateVariable));
						body.Instructions.Insert(targetIndex++, Instruction.Create(OpCodes.Ldc_I4_S, (sbyte)fl));
						body.Instructions.Insert(targetIndex++, Instruction.Create(OpCodes.Ldc_I4, (int)incr));
						body.Instructions.Insert(targetIndex++, Instruction.Create(OpCodes.Call, ctx.Ctx.CfgCtxNext));
						body.Instructions.Insert(targetIndex++, Instruction.Create(OpCodes.Pop));
					}
					first = body.Instructions[headerIndex];
				}
			}
			else {
				// Explicit

				CFGState exit;
				if (!ctx.StatesMap.TryGetValue(key.ExitState, out exit)) {
					// Create new exit state from random seed
					var seed = ctx.Random.NextUInt32();
					exit = new CFGState(seed);
					body.Instructions.Insert(targetIndex++, first = Instruction.Create(OpCodes.Ldloca, ctx.StateVariable));
					body.Instructions.Insert(targetIndex++, Instruction.Create(OpCodes.Ldc_I4, (int)seed));
					body.Instructions.Insert(targetIndex++, Instruction.Create(OpCodes.Call, ctx.Ctx.CfgCtxCtor));

					ctx.StatesMap[key.ExitState] = exit;
				}
				else {
					// Scan for updated state
					var headerIndex = targetIndex;
					for (int stateId = 0; stateId < 4; stateId++) {
						uint targetValue = exit.Get(stateId);
						int getId = ctx.Random.NextInt32(3);
						var fl = CFGState.EncodeFlag(true, stateId, getId);

						body.Instructions.Insert(targetIndex++, Instruction.Create(OpCodes.Ldloca, ctx.StateVariable));
						body.Instructions.Insert(targetIndex++, Instruction.Create(OpCodes.Ldc_I4_S, (sbyte)fl));
						body.Instructions.Insert(targetIndex++, Instruction.Create(OpCodes.Ldc_I4, (int)targetValue));
						body.Instructions.Insert(targetIndex++, Instruction.Create(OpCodes.Call, ctx.Ctx.CfgCtxNext));
						body.Instructions.Insert(targetIndex++, Instruction.Create(OpCodes.Pop));
					}
					first = body.Instructions[headerIndex];
				}
			}

			ctx.Graph.Body.ReplaceReference(block.Header, first);
		}

		static uint InsertStateGetAndUpdate(CFGContext ctx, ref int index, BlockKeyType type, ref CFGState currentState, CFGState? targetState) {
			var body = ctx.Graph.Body;

			if (type == BlockKeyType.Incremental) {
				// Incremental

				if (targetState == null) {
					// Randomly update and get state
					int updateId = ctx.Random.NextInt32(3);
					uint targetValue = ctx.Random.NextUInt32();

					int getId = ctx.Random.NextInt32(3);
					var fl = CFGState.EncodeFlag(false, updateId, getId);
					var incr = currentState.GetIncrementalUpdate(updateId, targetValue);
					currentState.UpdateExplicit(updateId, targetValue);

					body.Instructions.Insert(index++, Instruction.Create(OpCodes.Ldloca, ctx.StateVariable));
					body.Instructions.Insert(index++, Instruction.Create(OpCodes.Ldc_I4_S, (sbyte)fl));
					body.Instructions.Insert(index++, Instruction.Create(OpCodes.Ldc_I4, (int)incr));
					body.Instructions.Insert(index++, Instruction.Create(OpCodes.Call, ctx.Ctx.CfgCtxNext));

					return currentState.Get(getId);
				}
				// Scan for updated state
				int[] stateIds = { 0, 1, 2, 3 };
				ctx.Random.Shuffle(stateIds);
				int i = 0;
				uint getValue = 0;
				foreach (var stateId in stateIds) {
					// There must be at least one update&get
					if (currentState.Get(stateId) == targetState.Value.Get(stateId) &&
					    i != stateIds.Length - 1) {
						i++;
						continue;
					}

					uint targetValue = targetState.Value.Get(stateId);
					int getId = ctx.Random.NextInt32(3);
					var fl = CFGState.EncodeFlag(false, stateId, getId);
					var incr = currentState.GetIncrementalUpdate(stateId, targetValue);
					currentState.UpdateExplicit(stateId, targetValue);

					body.Instructions.Insert(index++, Instruction.Create(OpCodes.Ldloca, ctx.StateVariable));
					body.Instructions.Insert(index++, Instruction.Create(OpCodes.Ldc_I4_S, (sbyte)fl));
					body.Instructions.Insert(index++, Instruction.Create(OpCodes.Ldc_I4, (int)incr));
					body.Instructions.Insert(index++, Instruction.Create(OpCodes.Call, ctx.Ctx.CfgCtxNext));

					i++;
					if (i == stateIds.Length)
						getValue = currentState.Get(getId);
					else
						body.Instructions.Insert(index++, Instruction.Create(OpCodes.Pop));
				}
				return getValue;
			}
			else {
				// Explicit

				if (targetState == null) {
					// Create new exit state from random seed
					var seed = ctx.Random.NextUInt32();
					currentState = new CFGState(seed);
					body.Instructions.Insert(index++, Instruction.Create(OpCodes.Ldloca, ctx.StateVariable));
					body.Instructions.Insert(index++, Instruction.Create(OpCodes.Dup));
					body.Instructions.Insert(index++, Instruction.Create(OpCodes.Ldc_I4, (int)seed));
					body.Instructions.Insert(index++, Instruction.Create(OpCodes.Call, ctx.Ctx.CfgCtxCtor));

					// Randomly get state
					int updateId = ctx.Random.NextInt32(3);
					uint targetValue = ctx.Random.NextUInt32();

					int getId = ctx.Random.NextInt32(3);
					var fl = CFGState.EncodeFlag(false, updateId, getId);
					var incr = currentState.GetIncrementalUpdate(updateId, targetValue);
					currentState.UpdateExplicit(updateId, targetValue);

					body.Instructions.Insert(index++, Instruction.Create(OpCodes.Ldc_I4_S, (sbyte)fl));
					body.Instructions.Insert(index++, Instruction.Create(OpCodes.Ldc_I4, (int)incr));
					body.Instructions.Insert(index++, Instruction.Create(OpCodes.Call, ctx.Ctx.CfgCtxNext));

					return currentState.Get(getId);
				}
				else {
					// Scan for updated state
					int[] stateIds = { 0, 1, 2, 3 };
					ctx.Random.Shuffle(stateIds);
					int i = 0;
					uint getValue = 0;
					foreach (var stateId in stateIds) {
						uint targetValue = targetState.Value.Get(stateId);
						int getId = ctx.Random.NextInt32(3);
						var fl = CFGState.EncodeFlag(true, stateId, getId);
						currentState.UpdateExplicit(stateId, targetValue);

						body.Instructions.Insert(index++, Instruction.Create(OpCodes.Ldloca, ctx.StateVariable));
						body.Instructions.Insert(index++, Instruction.Create(OpCodes.Ldc_I4_S, (sbyte)fl));
						body.Instructions.Insert(index++, Instruction.Create(OpCodes.Ldc_I4, (int)targetValue));
						body.Instructions.Insert(index++, Instruction.Create(OpCodes.Call, ctx.Ctx.CfgCtxNext));

						i++;
						if (i == stateIds.Length)
							getValue = targetState.Value.Get(getId);
						else
							body.Instructions.Insert(index++, Instruction.Create(OpCodes.Pop));
					}
					return getValue;
				}
			}
		}

		static void ReplaceCFG(MethodDef method, List<Tuple<Instruction, uint, IMethod>> instrs, CEContext ctx) {
			InjectStateType(ctx);

			var graph = ControlFlowGraph.Construct(method.Body);
			var sequence = KeySequence.ComputeKeys(graph, null);

			var cfgCtx = new CFGContext {
				Ctx = ctx,
				Graph = graph,
				Keys = sequence,
				StatesMap = new Dictionary<uint, CFGState>(),
				Random = ctx.Random
			};

			cfgCtx.StateVariable = new Local(ctx.CfgCtxType.ToTypeSig());
			method.Body.Variables.Add(cfgCtx.StateVariable);
			method.Body.InitLocals = true;

			var blockReferences = new Dictionary<int, SortedList<int, Tuple<Instruction, uint, IMethod>>>();
			foreach (var instr in instrs) {
				var index = graph.IndexOf(instr.Item1);
				var block = graph.GetContainingBlock(index);

				SortedList<int, Tuple<Instruction, uint, IMethod>> list;
				if (!blockReferences.TryGetValue(block.Id, out list))
					list = blockReferences[block.Id] = new SortedList<int, Tuple<Instruction, uint, IMethod>>();

				list.Add(index, instr);
			}

			// Update state for blocks not in use
			for (int i = 0; i < graph.Count; i++) {
				var block = graph[i];
				if (blockReferences.ContainsKey(block.Id))
					continue;
				InsertEmptyStateUpdate(cfgCtx, block);
			}

			// Update references
			foreach (var blockRef in blockReferences) {
				var key = sequence[blockRef.Key];
				CFGState currentState;
				if (!cfgCtx.StatesMap.TryGetValue(key.EntryState, out currentState)) {
					Debug.Assert((graph[blockRef.Key].Type & ControlFlowBlockType.Entry) != 0);
					Debug.Assert(key.Type == BlockKeyType.Explicit);

					// Create new entry state
					uint blockSeed = ctx.Random.NextUInt32();
					currentState = new CFGState(blockSeed);
					cfgCtx.StatesMap[key.EntryState] = currentState;

					var index = graph.Body.Instructions.IndexOf(graph[blockRef.Key].Header);
					Instruction newHeader;
					method.Body.Instructions.Insert(index++, newHeader = Instruction.Create(OpCodes.Ldloca, cfgCtx.StateVariable));
					method.Body.Instructions.Insert(index++, Instruction.Create(OpCodes.Ldc_I4, (int)blockSeed));
					method.Body.Instructions.Insert(index++, Instruction.Create(OpCodes.Call, ctx.CfgCtxCtor));
					method.Body.ReplaceReference(graph[blockRef.Key].Header, newHeader);
					key.Type = BlockKeyType.Incremental;
				}
				var type = key.Type;

				for (int i = 0; i < blockRef.Value.Count; i++) {
					var refEntry = blockRef.Value.Values[i];

					CFGState? targetState = null;
					if (i == blockRef.Value.Count - 1) {
						CFGState exitState;
						if (cfgCtx.StatesMap.TryGetValue(key.ExitState, out exitState))
							targetState = exitState;
					}

					var index = graph.Body.Instructions.IndexOf(refEntry.Item1) + 1;
					var value = InsertStateGetAndUpdate(cfgCtx, ref index, type, ref currentState, targetState);

					refEntry.Item1.OpCode = OpCodes.Ldc_I4;
					refEntry.Item1.Operand = (int)(refEntry.Item2 ^ value);
					method.Body.Instructions.Insert(index++, Instruction.Create(OpCodes.Xor));
					method.Body.Instructions.Insert(index, Instruction.Create(OpCodes.Call, refEntry.Item3));

					if (i == blockRef.Value.Count - 1 && targetState == null) {
						cfgCtx.StatesMap[key.ExitState] = currentState;
					}

					type = BlockKeyType.Incremental;
				}
			}
		}
	}
}


================================================
File: Confuser.Protections/Constants/x86Mode.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using Confuser.Core;
using Confuser.Core.Helpers;
using Confuser.DynCipher;
using Confuser.DynCipher.AST;
using Confuser.DynCipher.Generation;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using dnlib.DotNet.Writer;
using MethodBody = dnlib.DotNet.Writer.MethodBody;

namespace Confuser.Protections.Constants {
	internal class x86Mode : IEncodeMode {
		Action<uint[], uint[]> encryptFunc;

		public IEnumerable<Instruction> EmitDecrypt(MethodDef init, CEContext ctx, Local block, Local key) {
			StatementBlock encrypt, decrypt;
			ctx.DynCipher.GenerateCipherPair(ctx.Random, out encrypt, out decrypt);
			var ret = new List<Instruction>();

			var codeGen = new CipherCodeGen(block, key, init, ret);
			codeGen.GenerateCIL(decrypt);
			codeGen.Commit(init.Body);

			var dmCodeGen = new DMCodeGen(typeof(void), new[] {
				Tuple.Create("{BUFFER}", typeof(uint[])),
				Tuple.Create("{KEY}", typeof(uint[]))
			});
			dmCodeGen.GenerateCIL(encrypt);
			encryptFunc = dmCodeGen.Compile<Action<uint[], uint[]>>();

			return ret;
		}

		public uint[] Encrypt(uint[] data, int offset, uint[] key) {
			var ret = new uint[key.Length];
			Buffer.BlockCopy(data, offset * sizeof(uint), ret, 0, key.Length * sizeof(uint));
			encryptFunc(ret, key);
			return ret;
		}

		public object CreateDecoder(MethodDef decoder, CEContext ctx) {
			var encoding = new x86Encoding();
			encoding.Compile(ctx);
			MutationHelper.ReplacePlaceholder(decoder, arg => {
				var repl = new List<Instruction>();
				repl.AddRange(arg);
				repl.Add(Instruction.Create(OpCodes.Call, encoding.native));
				return repl.ToArray();
			});
			return encoding;
		}

		public uint Encode(object data, CEContext ctx, uint id) {
			var encoding = (x86Encoding)data;
			return (uint)encoding.expCompiled((int)id);
		}

		class CipherCodeGen : CILCodeGen {
			readonly Local block;
			readonly Local key;

			public CipherCodeGen(Local block, Local key, MethodDef init, IList<Instruction> instrs)
				: base(init, instrs) {
				this.block = block;
				this.key = key;
			}

			protected override Local Var(Variable var) {
				if (var.Name == "{BUFFER}")
					return block;
				if (var.Name == "{KEY}")
					return key;
				return base.Var(var);
			}
		}

		class x86Encoding {
			byte[] code;
			MethodBody codeChunk;

			public Func<int, int> expCompiled;
			Expression expression;
			Expression inverse;
			public MethodDef native;

			public void Compile(CEContext ctx) {
				var var = new Variable("{VAR}");
				var result = new Variable("{RESULT}");

				CorLibTypeSig int32 = ctx.Module.CorLibTypes.Int32;
				native = new MethodDefUser("", MethodSig.CreateStatic(int32, int32), MethodAttributes.PinvokeImpl | MethodAttributes.PrivateScope | MethodAttributes.Static);
				native.ImplAttributes = MethodImplAttributes.Native | MethodImplAttributes.Unmanaged | MethodImplAttributes.PreserveSig;
				// Attempt to improve performance --- failed with StackOverflowException... :/
				//var suppressAttr = ctx.Method.Module.CorLibTypes.GetTypeRef("System.Security", "SuppressUnmanagedCodeSecurityAttribute").ResolveThrow();
				//native.CustomAttributes.Add(new CustomAttribute((MemberRef)ctx.Method.Module.Import(suppressAttr.FindDefaultConstructor())));
				//native.HasSecurity = true;
				ctx.Module.GlobalType.Methods.Add(native);

				ctx.Name.MarkHelper(native, ctx.Marker, ctx.Protection);

				x86Register? reg;
				var codeGen = new x86CodeGen();
				do {
					ctx.DynCipher.GenerateExpressionPair(
						ctx.Random,
						new VariableExpression { Variable = var }, new VariableExpression { Variable = result },
						4, out expression, out inverse);

					reg = codeGen.GenerateX86(inverse, (v, r) => { return new[] { x86Instruction.Create(x86OpCode.POP, new x86RegisterOperand(r)) }; });
				} while (reg == null);

				code = CodeGenUtils.AssembleCode(codeGen, reg.Value);

				expCompiled = new DMCodeGen(typeof(int), new[] { Tuple.Create("{VAR}", typeof(int)) })
					.GenerateCIL(expression)
					.Compile<Func<int, int>>();


				ctx.Context.CurrentModuleWriterListener.OnWriterEvent += InjectNativeCode;
			}

			void InjectNativeCode(object sender, ModuleWriterListenerEventArgs e) {
				var writer = (ModuleWriterBase)sender;
				if (e.WriterEvent == ModuleWriterEvent.MDEndWriteMethodBodies) {
					codeChunk = writer.MethodBodies.Add(new MethodBody(code));
				}
				else if (e.WriterEvent == ModuleWriterEvent.EndCalculateRvasAndFileOffsets) {
					uint rid = writer.MetaData.GetRid(native);
					writer.MetaData.TablesHeap.MethodTable[rid].RVA = (uint)codeChunk.RVA;
				}
			}
		}
	}
}


================================================
File: Confuser.Protections/ControlFlow/BlockParser.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.ControlFlow {
	internal static class BlockParser {
		public static ScopeBlock ParseBody(CilBody body) {
			var ehScopes = new Dictionary<ExceptionHandler, Tuple<ScopeBlock, ScopeBlock, ScopeBlock>>();
			foreach (ExceptionHandler eh in body.ExceptionHandlers) {
				var tryBlock = new ScopeBlock(BlockType.Try, eh);

				var handlerType = BlockType.Handler;

				if (eh.HandlerType == ExceptionHandlerType.Finally)
					handlerType = BlockType.Finally;
				else if (eh.HandlerType == ExceptionHandlerType.Fault)
					handlerType = BlockType.Fault;

				var handlerBlock = new ScopeBlock(handlerType, eh);

				if (eh.FilterStart != null) {
					var filterBlock = new ScopeBlock(BlockType.Filter, eh);
					ehScopes[eh] = Tuple.Create(tryBlock, handlerBlock, filterBlock);
				}
				else
					ehScopes[eh] = Tuple.Create(tryBlock, handlerBlock, (ScopeBlock)null);
			}

			var root = new ScopeBlock(BlockType.Normal, null);
			var scopeStack = new Stack<ScopeBlock>();

			scopeStack.Push(root);
			foreach (Instruction instr in body.Instructions) {
				foreach (ExceptionHandler eh in body.ExceptionHandlers) {
					Tuple<ScopeBlock, ScopeBlock, ScopeBlock> ehScope = ehScopes[eh];

					if (instr == eh.TryEnd)
						scopeStack.Pop();

					if (instr == eh.HandlerEnd)
						scopeStack.Pop();

					if (eh.FilterStart != null && instr == eh.HandlerStart) {
						// Filter must precede handler immediately
						Debug.Assert(scopeStack.Peek().Type == BlockType.Filter);
						scopeStack.Pop();
					}
				}
				foreach (ExceptionHandler eh in body.ExceptionHandlers.Reverse()) {
					Tuple<ScopeBlock, ScopeBlock, ScopeBlock> ehScope = ehScopes[eh];
					ScopeBlock parent = scopeStack.Count > 0 ? scopeStack.Peek() : null;

					if (instr == eh.TryStart) {
						if (parent != null)
							parent.Children.Add(ehScope.Item1);
						scopeStack.Push(ehScope.Item1);
					}

					if (instr == eh.HandlerStart) {
						if (parent != null)
							parent.Children.Add(ehScope.Item2);
						scopeStack.Push(ehScope.Item2);
					}

					if (instr == eh.FilterStart) {
						if (parent != null)
							parent.Children.Add(ehScope.Item3);
						scopeStack.Push(ehScope.Item3);
					}
				}

				ScopeBlock scope = scopeStack.Peek();
				var block = scope.Children.LastOrDefault() as InstrBlock;
				if (block == null)
					scope.Children.Add(block = new InstrBlock());
				block.Instructions.Add(instr);
			}
			foreach (ExceptionHandler eh in body.ExceptionHandlers) {
				if (eh.TryEnd == null)
					scopeStack.Pop();
				if (eh.HandlerEnd == null)
					scopeStack.Pop();
			}
			Debug.Assert(scopeStack.Count == 1);
			return root;
		}
	}
}


================================================
File: Confuser.Protections/ControlFlow/Blocks.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.ControlFlow {
	internal abstract class BlockBase {
		public BlockBase(BlockType type) {
			Type = type;
		}

		public ScopeBlock Parent { get; private set; }

		public BlockType Type { get; private set; }
		public abstract void ToBody(CilBody body);
	}

	internal enum BlockType {
		Normal,
		Try,
		Handler,
		Finally,
		Filter,
		Fault
	}

	internal class ScopeBlock : BlockBase {
		public ScopeBlock(BlockType type, ExceptionHandler handler)
			: base(type) {
			Handler = handler;
			Children = new List<BlockBase>();
		}

		public ExceptionHandler Handler { get; private set; }

		public List<BlockBase> Children { get; set; }

		public override string ToString() {
			var ret = new StringBuilder();
			if (Type == BlockType.Try)
				ret.Append("try ");
			else if (Type == BlockType.Handler)
				ret.Append("handler ");
			else if (Type == BlockType.Finally)
				ret.Append("finally ");
			else if (Type == BlockType.Fault)
				ret.Append("fault ");
			ret.AppendLine("{");
			foreach (BlockBase child in Children)
				ret.Append(child);
			ret.AppendLine("}");
			return ret.ToString();
		}

		public Instruction GetFirstInstr() {
			BlockBase firstBlock = Children.First();
			if (firstBlock is ScopeBlock)
				return ((ScopeBlock)firstBlock).GetFirstInstr();
			return ((InstrBlock)firstBlock).Instructions.First();
		}

		public Instruction GetLastInstr() {
			BlockBase firstBlock = Children.Last();
			if (firstBlock is ScopeBlock)
				return ((ScopeBlock)firstBlock).GetLastInstr();
			return ((InstrBlock)firstBlock).Instructions.Last();
		}

		public override void ToBody(CilBody body) {
			if (Type != BlockType.Normal) {
				if (Type == BlockType.Try) {
					Handler.TryStart = GetFirstInstr();
					Handler.TryEnd = GetLastInstr();
				}
				else if (Type == BlockType.Filter) {
					Handler.FilterStart = GetFirstInstr();
				}
				else {
					Handler.HandlerStart = GetFirstInstr();
					Handler.HandlerEnd = GetLastInstr();
				}
			}

			foreach (BlockBase block in Children)
				block.ToBody(body);
		}
	}

	internal class InstrBlock : BlockBase {
		public InstrBlock()
			: base(BlockType.Normal) {
			Instructions = new List<Instruction>();
		}

		public List<Instruction> Instructions { get; set; }

		public override string ToString() {
			var ret = new StringBuilder();
			foreach (Instruction instr in Instructions)
				ret.AppendLine(instr.ToString());
			return ret.ToString();
		}

		public override void ToBody(CilBody body) {
			foreach (Instruction instr in Instructions)
				body.Instructions.Add(instr);
		}
	}
}


================================================
File: Confuser.Protections/ControlFlow/CFContext.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using Confuser.Core;
using Confuser.Core.Services;
using Confuser.DynCipher;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.ControlFlow {
	internal enum CFType {
		Switch,
		Jump
	}

	internal enum PredicateType {
		Normal,
		Expression,
		x86
	}

	internal class CFContext {
		public ConfuserContext Context;
		public ControlFlowProtection Protection;
		public int Depth;
		public IDynCipherService DynCipher;

		public double Intensity;
		public bool JunkCode;
		public MethodDef Method;
		public PredicateType Predicate;
		public RandomGenerator Random;
		public CFType Type;

		public void AddJump(IList<Instruction> instrs, Instruction target) {
			if (!Method.Module.IsClr40 && JunkCode &&
			    !Method.DeclaringType.HasGenericParameters && !Method.HasGenericParameters &&
			    (instrs[0].OpCode.FlowControl == FlowControl.Call || instrs[0].OpCode.FlowControl == FlowControl.Next)) {
				switch (Random.NextInt32(3)) {
					case 0:
						instrs.Add(Instruction.Create(OpCodes.Ldc_I4_0));
						instrs.Add(Instruction.Create(OpCodes.Brtrue, instrs[0]));
						break;

					case 1:
						instrs.Add(Instruction.Create(OpCodes.Ldc_I4_1));
						instrs.Add(Instruction.Create(OpCodes.Brfalse, instrs[0]));
						break;

					case 2: // Take that, de4dot + ILSpy :)
						bool addDefOk = false;
						if (Random.NextBoolean()) {
							TypeDef randomType;
							randomType = Method.Module.Types[Random.NextInt32(Method.Module.Types.Count)];

							if (randomType.HasMethods) {
								instrs.Add(Instruction.Create(OpCodes.Ldtoken, randomType.Methods[Random.NextInt32(randomType.Methods.Count)]));
								instrs.Add(Instruction.Create(OpCodes.Box, Method.Module.CorLibTypes.GetTypeRef("System", "RuntimeMethodHandle")));
								addDefOk = true;
							}
						}

						if (!addDefOk) {
							instrs.Add(Instruction.Create(OpCodes.Ldc_I4, Random.NextBoolean() ? 0 : 1));
							instrs.Add(Instruction.Create(OpCodes.Box, Method.Module.CorLibTypes.Int32.TypeDefOrRef));
						}
						Instruction pop = Instruction.Create(OpCodes.Pop);
						instrs.Add(Instruction.Create(OpCodes.Brfalse, instrs[0]));
						instrs.Add(Instruction.Create(OpCodes.Ldc_I4, Random.NextBoolean() ? 0 : 1));
						instrs.Add(pop);
						break;
				}
			}

			instrs.Add(Instruction.Create(OpCodes.Br, target));
		}

		public void AddJunk(IList<Instruction> instrs) {
			if (Method.Module.IsClr40 || !JunkCode)
				return;

			switch (Random.NextInt32(6)) {
				case 0:
					instrs.Add(Instruction.Create(OpCodes.Pop));
					break;
				case 1:
					instrs.Add(Instruction.Create(OpCodes.Dup));
					break;
				case 2:
					instrs.Add(Instruction.Create(OpCodes.Throw));
					break;
				case 3:
					instrs.Add(Instruction.Create(OpCodes.Ldarg, new Parameter(0xff)));
					break;
				case 4:
					instrs.Add(Instruction.Create(OpCodes.Ldloc, new Local(null) { Index = 0xff }));
					break;
				case 5:
					instrs.Add(Instruction.Create(OpCodes.Ldtoken, Method));
					break;
			}
		}
	}
}


================================================
File: Confuser.Protections/ControlFlow/ControlFlowPhase.cs
================================================
ï»¿using System;
using System.Diagnostics;
using System.Linq;
using Confuser.Core;
using Confuser.Core.Services;
using Confuser.DynCipher;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using dnlib.DotNet.MD;
using dnlib.DotNet.Writer;

namespace Confuser.Protections.ControlFlow {
	internal class ControlFlowPhase : ProtectionPhase {
		static readonly JumpMangler Jump = new JumpMangler();
		static readonly SwitchMangler Switch = new SwitchMangler();

		public ControlFlowPhase(ControlFlowProtection parent)
			: base(parent) { }

		public override ProtectionTargets Targets {
			get { return ProtectionTargets.Methods; }
		}

		public override string Name {
			get { return "Control flow mangling"; }
		}

		CFContext ParseParameters(MethodDef method, ConfuserContext context, ProtectionParameters parameters, RandomGenerator random, bool disableOpti) {
			var ret = new CFContext();
			ret.Type = parameters.GetParameter(context, method, "type", CFType.Switch);
			ret.Predicate = parameters.GetParameter(context, method, "predicate", PredicateType.Normal);

			int rawIntensity = parameters.GetParameter(context, method, "intensity", 60);
			ret.Intensity = rawIntensity / 100.0;
			ret.Depth = parameters.GetParameter(context, method, "depth", 4);

			ret.JunkCode = parameters.GetParameter(context, method, "junk", false) && !disableOpti;

			ret.Protection = (ControlFlowProtection)Parent;
			ret.Random = random;
			ret.Method = method;
			ret.Context = context;
			ret.DynCipher = context.Registry.GetService<IDynCipherService>();

			if (ret.Predicate == PredicateType.x86) {
				if ((context.CurrentModule.Cor20HeaderFlags & ComImageFlags.ILOnly) != 0)
					context.CurrentModuleWriterOptions.Cor20HeaderOptions.Flags &= ~ComImageFlags.ILOnly;
			}

			return ret;
		}

		static bool DisabledOptimization(ModuleDef module) {
			bool disableOpti = false;
			CustomAttribute debugAttr = module.Assembly.CustomAttributes.Find("System.Diagnostics.DebuggableAttribute");
			if (debugAttr != null) {
				if (debugAttr.ConstructorArguments.Count == 1)
					disableOpti |= ((DebuggableAttribute.DebuggingModes)(int)debugAttr.ConstructorArguments[0].Value & DebuggableAttribute.DebuggingModes.DisableOptimizations) != 0;
				else
					disableOpti |= (bool)debugAttr.ConstructorArguments[1].Value;
			}
			debugAttr = module.CustomAttributes.Find("System.Diagnostics.DebuggableAttribute");
			if (debugAttr != null) {
				if (debugAttr.ConstructorArguments.Count == 1)
					disableOpti |= ((DebuggableAttribute.DebuggingModes)(int)debugAttr.ConstructorArguments[0].Value & DebuggableAttribute.DebuggingModes.DisableOptimizations) != 0;
				else
					disableOpti |= (bool)debugAttr.ConstructorArguments[1].Value;
			}
			return disableOpti;
		}

		protected override void Execute(ConfuserContext context, ProtectionParameters parameters) {
			bool disabledOpti = DisabledOptimization(context.CurrentModule);
			RandomGenerator random = context.Registry.GetService<IRandomService>().GetRandomGenerator(ControlFlowProtection._FullId);

			foreach (MethodDef method in parameters.Targets.OfType<MethodDef>().WithProgress(context.Logger))
				if (method.HasBody && method.Body.Instructions.Count > 0) {
					ProcessMethod(method.Body, ParseParameters(method, context, parameters, random, disabledOpti));
					context.CheckCancellation();
				}
		}

		static ManglerBase GetMangler(CFType type) {
			if (type == CFType.Switch)
				return Switch;
			return Jump;
		}

		void ProcessMethod(CilBody body, CFContext ctx) {
			uint maxStack;
			if (!MaxStackCalculator.GetMaxStack(body.Instructions, body.ExceptionHandlers, out maxStack)) {
				ctx.Context.Logger.Error("Failed to calcuate maxstack.");
				throw new ConfuserException(null);
			}
			body.MaxStack = (ushort)maxStack;
			ScopeBlock root = BlockParser.ParseBody(body);

			GetMangler(ctx.Type).Mangle(body, root, ctx);

			body.Instructions.Clear();
			root.ToBody(body);
			foreach (ExceptionHandler eh in body.ExceptionHandlers) {
				var index = body.Instructions.IndexOf(eh.TryEnd) + 1;
				eh.TryEnd = index < body.Instructions.Count ? body.Instructions[index] : null;
				index = body.Instructions.IndexOf(eh.HandlerEnd) + 1;
				eh.HandlerEnd = index < body.Instructions.Count ? body.Instructions[index] : null;
			}
			body.KeepOldMaxStack = true;
		}
	}
}


================================================
File: Confuser.Protections/ControlFlow/ControlFlowProtection.cs
================================================
ï»¿using System;
using Confuser.Core;
using Confuser.Protections.ControlFlow;
using dnlib.DotNet;

namespace Confuser.Protections {
	public interface IControlFlowService {
		void ExcludeMethod(ConfuserContext context, MethodDef method);
	}

	internal class ControlFlowProtection : Protection, IControlFlowService {
		public const string _Id = "ctrl flow";
		public const string _FullId = "Ki.ControlFlow";
		public const string _ServiceId = "Ki.ControlFlow";

		public override string Name {
			get { return "Control Flow Protection"; }
		}

		public override string Description {
			get { return "This protection mangles the code in the methods so that decompilers cannot decompile the methods."; }
		}

		public override string Id {
			get { return _Id; }
		}

		public override string FullId {
			get { return _FullId; }
		}

		public override ProtectionPreset Preset {
			get { return ProtectionPreset.Normal; }
		}

		public void ExcludeMethod(ConfuserContext context, MethodDef method) {
			ProtectionParameters.GetParameters(context, method).Remove(this);
		}

		protected override void Initialize(ConfuserContext context) {
			context.Registry.RegisterService(_ServiceId, typeof(IControlFlowService), this);
		}

		protected override void PopulatePipeline(ProtectionPipeline pipeline) {
			pipeline.InsertPreStage(PipelineStage.OptimizeMethods, new ControlFlowPhase(this));
		}
	}
}


================================================
File: Confuser.Protections/ControlFlow/ExpressionPredicate.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using Confuser.DynCipher.AST;
using Confuser.DynCipher.Generation;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.ControlFlow {
	internal class ExpressionPredicate : IPredicate {
		readonly CFContext ctx;
		Func<int, int> expCompiled;
		Expression expression;

		bool inited;
		List<Instruction> invCompiled;
		Expression inverse;
		Local stateVar;

		public ExpressionPredicate(CFContext ctx) {
			this.ctx = ctx;
		}

		public void Init(CilBody body) {
			if (inited)
				return;
			stateVar = new Local(ctx.Method.Module.CorLibTypes.Int32);
			body.Variables.Add(stateVar);
			body.InitLocals = true;
			Compile(body);
			inited = true;
		}

		public void EmitSwitchLoad(IList<Instruction> instrs) {
			instrs.Add(Instruction.Create(OpCodes.Stloc, stateVar));
			foreach (Instruction instr in invCompiled)
				instrs.Add(instr.Clone());
		}

		public int GetSwitchKey(int key) {
			return expCompiled(key);
		}

		void Compile(CilBody body) {
			var var = new Variable("{VAR}");
			var result = new Variable("{RESULT}");

			ctx.DynCipher.GenerateExpressionPair(
				ctx.Random,
				new VariableExpression { Variable = var }, new VariableExpression { Variable = result },
				ctx.Depth, out expression, out inverse);

			expCompiled = new DMCodeGen(typeof(int), new[] { Tuple.Create("{VAR}", typeof(int)) })
				.GenerateCIL(expression)
				.Compile<Func<int, int>>();

			invCompiled = new List<Instruction>();
			new CodeGen(stateVar, ctx, invCompiled).GenerateCIL(inverse);
			body.MaxStack += (ushort)ctx.Depth;
		}

		class CodeGen : CILCodeGen {
			readonly Local state;

			public CodeGen(Local state, CFContext ctx, IList<Instruction> instrs)
				: base(ctx.Method, instrs) {
				this.state = state;
			}

			protected override Local Var(Variable var) {
				if (var.Name == "{RESULT}")
					return state;
				return base.Var(var);
			}
		}
	}
}


================================================
File: Confuser.Protections/ControlFlow/IPredicate.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.ControlFlow {
	internal interface IPredicate {
		void Init(CilBody body);
		void EmitSwitchLoad(IList<Instruction> instrs);
		int GetSwitchKey(int key);
	}
}


================================================
File: Confuser.Protections/ControlFlow/JumpMangler.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.ControlFlow {
	internal class JumpMangler : ManglerBase {
		LinkedList<Instruction[]> SpiltFragments(InstrBlock block, CFContext ctx) {
			var fragments = new LinkedList<Instruction[]>();
			var currentFragment = new List<Instruction>();

			int skipCount = -1;
			for (int i = 0; i < block.Instructions.Count; i++) {
				if (skipCount != -1) {
					if (skipCount > 0) {
						currentFragment.Add(block.Instructions[i]);
						skipCount--;
						continue;
					}
					fragments.AddLast(currentFragment.ToArray());
					currentFragment.Clear();

					skipCount = -1;
				}

				if (block.Instructions[i].OpCode.OpCodeType == OpCodeType.Prefix) {
					skipCount = 1;
					currentFragment.Add(block.Instructions[i]);
				}
				if (i + 2 < block.Instructions.Count &&
				    block.Instructions[i + 0].OpCode.Code == Code.Dup &&
				    block.Instructions[i + 1].OpCode.Code == Code.Ldvirtftn &&
				    block.Instructions[i + 2].OpCode.Code == Code.Newobj) {
					skipCount = 2;
					currentFragment.Add(block.Instructions[i]);
				}
				if (i + 4 < block.Instructions.Count &&
				    block.Instructions[i + 0].OpCode.Code == Code.Ldc_I4 &&
				    block.Instructions[i + 1].OpCode.Code == Code.Newarr &&
				    block.Instructions[i + 2].OpCode.Code == Code.Dup &&
				    block.Instructions[i + 3].OpCode.Code == Code.Ldtoken &&
				    block.Instructions[i + 4].OpCode.Code == Code.Call) // Array initializer
				{
					skipCount = 4;
					currentFragment.Add(block.Instructions[i]);
				}
				if (i + 1 < block.Instructions.Count &&
				    block.Instructions[i + 0].OpCode.Code == Code.Ldftn &&
				    block.Instructions[i + 1].OpCode.Code == Code.Newobj) {
					skipCount = 1;
					currentFragment.Add(block.Instructions[i]);
				}
				currentFragment.Add(block.Instructions[i]);

				if (ctx.Intensity > ctx.Random.NextDouble()) {
					fragments.AddLast(currentFragment.ToArray());
					currentFragment.Clear();
				}
			}

			if (currentFragment.Count > 0)
				fragments.AddLast(currentFragment.ToArray());

			return fragments;
		}

		public override void Mangle(CilBody body, ScopeBlock root, CFContext ctx) {
			body.MaxStack++;
			foreach (InstrBlock block in GetAllBlocks(root)) {
				LinkedList<Instruction[]> fragments = SpiltFragments(block, ctx);
				if (fragments.Count < 4) continue;

				LinkedListNode<Instruction[]> current = fragments.First;
				while (current.Next != null) {
					var newFragment = new List<Instruction>(current.Value);
					ctx.AddJump(newFragment, current.Next.Value[0]);
					ctx.AddJunk(newFragment);
					current.Value = newFragment.ToArray();
					current = current.Next;
				}
				Instruction[] first = fragments.First.Value;
				fragments.RemoveFirst();
				Instruction[] last = fragments.Last.Value;
				fragments.RemoveLast();

				List<Instruction[]> newFragments = fragments.ToList();
				ctx.Random.Shuffle(newFragments);

				block.Instructions = first
					.Concat(newFragments.SelectMany(fragment => fragment))
					.Concat(last).ToList();
			}
		}
	}
}


================================================
File: Confuser.Protections/ControlFlow/ManglerBase.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.ControlFlow {
	internal abstract class ManglerBase {
		protected static IEnumerable<InstrBlock> GetAllBlocks(ScopeBlock scope) {
			foreach (BlockBase child in scope.Children) {
				if (child is InstrBlock)
					yield return (InstrBlock)child;
				else {
					foreach (InstrBlock block in GetAllBlocks((ScopeBlock)child))
						yield return block;
				}
			}
		}

		public abstract void Mangle(CilBody body, ScopeBlock root, CFContext ctx);
	}
}


================================================
File: Confuser.Protections/ControlFlow/NormalPredicate.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.ControlFlow {
	internal class NormalPredicate : IPredicate {
		readonly CFContext ctx;
		bool inited;
		int xorKey;

		public NormalPredicate(CFContext ctx) {
			this.ctx = ctx;
		}

		public void Init(CilBody body) {
			if (inited)
				return;

			xorKey = ctx.Random.NextInt32();
			inited = true;
		}

		public void EmitSwitchLoad(IList<Instruction> instrs) {
			instrs.Add(Instruction.Create(OpCodes.Ldc_I4, xorKey));
			instrs.Add(Instruction.Create(OpCodes.Xor));
		}

		public int GetSwitchKey(int key) {
			return key ^ xorKey;
		}
	}
}


================================================
File: Confuser.Protections/ControlFlow/SwitchMangler.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using Confuser.Core;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.ControlFlow {
	internal class SwitchMangler : ManglerBase {
		struct Trace {
			public Dictionary<uint, int> RefCount;
			public Dictionary<uint, List<Instruction>> BrRefs;
			public Dictionary<uint, int> BeforeStack;
			public Dictionary<uint, int> AfterStack;

			static void Increment(Dictionary<uint, int> counts, uint key) {
				int value;
				if (!counts.TryGetValue(key, out value))
					value = 0;
				counts[key] = value + 1;
			}

			public Trace(CilBody body, bool hasReturnValue) {
				RefCount = new Dictionary<uint, int>();
				BrRefs = new Dictionary<uint, List<Instruction>>();
				BeforeStack = new Dictionary<uint, int>();
				AfterStack = new Dictionary<uint, int>();

				body.UpdateInstructionOffsets();

				foreach (ExceptionHandler eh in body.ExceptionHandlers) {
					BeforeStack[eh.TryStart.Offset] = 0;
					BeforeStack[eh.HandlerStart.Offset] = (eh.HandlerType != ExceptionHandlerType.Finally ? 1 : 0);
					if (eh.FilterStart != null)
						BeforeStack[eh.FilterStart.Offset] = 1;
				}

				int currentStack = 0;
				for (int i = 0; i < body.Instructions.Count; i++) {
					var instr = body.Instructions[i];

					if (BeforeStack.ContainsKey(instr.Offset))
						currentStack = BeforeStack[instr.Offset];

					BeforeStack[instr.Offset] = currentStack;
					instr.UpdateStack(ref currentStack, hasReturnValue);
					AfterStack[instr.Offset] = currentStack;

					uint offset;
					switch (instr.OpCode.FlowControl) {
						case FlowControl.Branch:
							offset = ((Instruction)instr.Operand).Offset;
							if (!BeforeStack.ContainsKey(offset))
								BeforeStack[offset] = currentStack;

							Increment(RefCount, offset);
							BrRefs.AddListEntry(offset, instr);

							currentStack = 0;
							continue;
						case FlowControl.Call:
							if (instr.OpCode.Code == Code.Jmp)
								currentStack = 0;
							break;
						case FlowControl.Cond_Branch:
							if (instr.OpCode.Code == Code.Switch) {
								foreach (Instruction target in (Instruction[])instr.Operand) {
									if (!BeforeStack.ContainsKey(target.Offset))
										BeforeStack[target.Offset] = currentStack;

									Increment(RefCount, target.Offset);
									BrRefs.AddListEntry(target.Offset, instr);
								}
							}
							else {
								offset = ((Instruction)instr.Operand).Offset;
								if (!BeforeStack.ContainsKey(offset))
									BeforeStack[offset] = currentStack;

								Increment(RefCount, offset);
								BrRefs.AddListEntry(offset, instr);
							}
							break;
						case FlowControl.Meta:
						case FlowControl.Next:
						case FlowControl.Break:
							break;
						case FlowControl.Return:
						case FlowControl.Throw:
							continue;
						default:
							throw new UnreachableException();
					}

					if (i + 1 < body.Instructions.Count) {
						offset = body.Instructions[i + 1].Offset;
						Increment(RefCount, offset);
					}
				}
			}

			public bool IsBranchTarget(uint offset) {
				List<Instruction> src;
				if (BrRefs.TryGetValue(offset, out src))
					return src.Count > 0;
				return false;
			}

			public bool HasMultipleSources(uint offset) {
				int src;
				if (RefCount.TryGetValue(offset, out src))
					return src > 1;
				return false;
			}
		}

		LinkedList<Instruction[]> SpiltStatements(InstrBlock block, Trace trace, CFContext ctx) {
			var statements = new LinkedList<Instruction[]>();
			var currentStatement = new List<Instruction>();

			// Instructions that must be included in the ccurrent statement to ensure all outgoing
			// branches have stack = 0
			var requiredInstr = new HashSet<Instruction>();

			for (int i = 0; i < block.Instructions.Count; i++) {
				Instruction instr = block.Instructions[i];
				currentStatement.Add(instr);

				bool shouldSpilt = i + 1 < block.Instructions.Count && trace.HasMultipleSources(block.Instructions[i + 1].Offset);
				switch (instr.OpCode.FlowControl) {
					case FlowControl.Branch:
					case FlowControl.Cond_Branch:
					case FlowControl.Return:
					case FlowControl.Throw:
						shouldSpilt = true;
						if (trace.AfterStack[instr.Offset] != 0) {
							if (instr.Operand is Instruction)
								requiredInstr.Add((Instruction)instr.Operand);
							else if (instr.Operand is Instruction[]) {
								foreach (var target in (Instruction[])instr.Operand)
									requiredInstr.Add(target);
							}
						}
						break;
				}
				requiredInstr.Remove(instr);
				if ((instr.OpCode.OpCodeType != OpCodeType.Prefix && trace.AfterStack[instr.Offset] == 0 &&
				     requiredInstr.Count == 0) &&
				    (shouldSpilt || ctx.Intensity > ctx.Random.NextDouble())) {
					statements.AddLast(currentStatement.ToArray());
					currentStatement.Clear();
				}
			}

			if (currentStatement.Count > 0)
				statements.AddLast(currentStatement.ToArray());

			return statements;
		}

		static OpCode InverseBranch(OpCode opCode) {
			switch (opCode.Code) {
				case Code.Bge:
					return OpCodes.Blt;
				case Code.Bge_Un:
					return OpCodes.Blt_Un;
				case Code.Blt:
					return OpCodes.Bge;
				case Code.Blt_Un:
					return OpCodes.Bge_Un;
				case Code.Bgt:
					return OpCodes.Ble;
				case Code.Bgt_Un:
					return OpCodes.Ble_Un;
				case Code.Ble:
					return OpCodes.Bgt;
				case Code.Ble_Un:
					return OpCodes.Bgt_Un;
				case Code.Brfalse:
					return OpCodes.Brtrue;
				case Code.Brtrue:
					return OpCodes.Brfalse;
				case Code.Beq:
					return OpCodes.Bne_Un;
				case Code.Bne_Un:
					return OpCodes.Beq;
			}
			throw new NotSupportedException();
		}

		public override void Mangle(CilBody body, ScopeBlock root, CFContext ctx) {
			Trace trace = new Trace(body, ctx.Method.ReturnType.RemoveModifiers().ElementType != ElementType.Void);
			var local = new Local(ctx.Method.Module.CorLibTypes.UInt32);
			body.Variables.Add(local);
			body.InitLocals = true;

			body.MaxStack += 2;
			IPredicate predicate = null;
			if (ctx.Predicate == PredicateType.Normal) {
				predicate = new NormalPredicate(ctx);
			}
			else if (ctx.Predicate == PredicateType.Expression) {
				predicate = new ExpressionPredicate(ctx);
			}
			else if (ctx.Predicate == PredicateType.x86) {
				predicate = new x86Predicate(ctx);
			}

			foreach (InstrBlock block in GetAllBlocks(root)) {
				LinkedList<Instruction[]> statements = SpiltStatements(block, trace, ctx);

				// Make sure .ctor is executed before switch
				if (ctx.Method.IsInstanceConstructor) {
					var newStatement = new List<Instruction>();
					while (statements.First != null) {
						newStatement.AddRange(statements.First.Value);
						Instruction lastInstr = statements.First.Value.Last();
						statements.RemoveFirst();
						if (lastInstr.OpCode == OpCodes.Call && ((IMethod)lastInstr.Operand).Name == ".ctor")
							break;
					}
					statements.AddFirst(newStatement.ToArray());
				}

				if (statements.Count < 3) continue;

				int i;

				var keyId = Enumerable.Range(0, statements.Count).ToArray();
				ctx.Random.Shuffle(keyId);
				var key = new int[keyId.Length];
				for (i = 0; i < key.Length; i++) {
					var q = ctx.Random.NextInt32() & 0x7fffffff;
					key[i] = q - q % statements.Count + keyId[i];
				}

				var statementKeys = new Dictionary<Instruction, int>();
				LinkedListNode<Instruction[]> current = statements.First;
				i = 0;
				while (current != null) {
					if (i != 0)
						statementKeys[current.Value[0]] = key[i];
					i++;
					current = current.Next;
				}

				var statementLast = new HashSet<Instruction>(statements.Select(st => st.Last()));

				Func<IList<Instruction>, bool> hasUnknownSource;
				hasUnknownSource = instrs => instrs.Any(instr => {
					if (trace.HasMultipleSources(instr.Offset))
						return true;
					List<Instruction> srcs;
					if (trace.BrRefs.TryGetValue(instr.Offset, out srcs)) {
						// Target of switch => assume unknown
						if (srcs.Any(src => src.Operand is Instruction[]))
							return true;

						// Not within current instruction block / targeted in first statement
						if (srcs.Any(src => src.Offset <= statements.First.Value.Last().Offset ||
						                    src.Offset >= block.Instructions.Last().Offset))
							return true;

						// Not targeted by the last of statements
						if (srcs.Any(src => statementLast.Contains(src)))
							return true;
					}
					return false;
				});

				var switchInstr = new Instruction(OpCodes.Switch);
				var switchHdr = new List<Instruction>();

				if (predicate != null) {
					predicate.Init(body);
					switchHdr.Add(Instruction.CreateLdcI4(predicate.GetSwitchKey(key[1])));
					predicate.EmitSwitchLoad(switchHdr);
				}
				else {
					switchHdr.Add(Instruction.CreateLdcI4(key[1]));
				}

				switchHdr.Add(Instruction.Create(OpCodes.Dup));
				switchHdr.Add(Instruction.Create(OpCodes.Stloc, local));
				switchHdr.Add(Instruction.Create(OpCodes.Ldc_I4, statements.Count));
				switchHdr.Add(Instruction.Create(OpCodes.Rem_Un));
				switchHdr.Add(switchInstr);

				ctx.AddJump(switchHdr, statements.Last.Value[0]);
				ctx.AddJunk(switchHdr);

				var operands = new Instruction[statements.Count];
				current = statements.First;
				i = 0;
				while (current.Next != null) {
					var newStatement = new List<Instruction>(current.Value);

					if (i != 0) {
						// Convert to switch
						bool converted = false;

						if (newStatement.Last().IsBr()) {
							// Unconditional

							var target = (Instruction)newStatement.Last().Operand;
							int brKey;
							if (!trace.IsBranchTarget(newStatement.Last().Offset) &&
							    statementKeys.TryGetValue(target, out brKey)) {
								var targetKey = predicate != null ? predicate.GetSwitchKey(brKey) : brKey;
								var unkSrc = hasUnknownSource(newStatement);

								newStatement.RemoveAt(newStatement.Count - 1);

								if (unkSrc) {
									newStatement.Add(Instruction.Create(OpCodes.Ldc_I4, targetKey));
								}
								else {
									var thisKey = key[i];
									var r = ctx.Random.NextInt32();
									newStatement.Add(Instruction.Create(OpCodes.Ldloc, local));
									newStatement.Add(Instruction.CreateLdcI4(r));
									newStatement.Add(Instruction.Create(OpCodes.Mul));
									newStatement.Add(Instruction.Create(OpCodes.Ldc_I4, (thisKey * r) ^ targetKey));
									newStatement.Add(Instruction.Create(OpCodes.Xor));
								}

								ctx.AddJump(newStatement, switchHdr[1]);
								ctx.AddJunk(newStatement);
								operands[keyId[i]] = newStatement[0];
								converted = true;
							}
						}
						else if (newStatement.Last().IsConditionalBranch()) {
							// Conditional

							var target = (Instruction)newStatement.Last().Operand;
							int brKey;
							if (!trace.IsBranchTarget(newStatement.Last().Offset) &&
							    statementKeys.TryGetValue(target, out brKey)) {
								bool unkSrc = hasUnknownSource(newStatement);
								int nextKey = key[i + 1];
								OpCode condBr = newStatement.Last().OpCode;
								newStatement.RemoveAt(newStatement.Count - 1);

								if (ctx.Random.NextBoolean()) {
									condBr = InverseBranch(condBr);
									int tmp = brKey;
									brKey = nextKey;
									nextKey = tmp;
								}

								var thisKey = key[i];
								int r = 0, xorKey = 0;
								if (!unkSrc) {
									r = ctx.Random.NextInt32();
									xorKey = thisKey * r;
								}

								Instruction brKeyInstr = Instruction.CreateLdcI4(xorKey ^ (predicate != null ? predicate.GetSwitchKey(brKey) : brKey));
								Instruction nextKeyInstr = Instruction.CreateLdcI4(xorKey ^ (predicate != null ? predicate.GetSwitchKey(nextKey) : nextKey));
								Instruction pop = Instruction.Create(OpCodes.Pop);

								newStatement.Add(Instruction.Create(condBr, brKeyInstr));
								newStatement.Add(nextKeyInstr);
								newStatement.Add(Instruction.Create(OpCodes.Dup));
								newStatement.Add(Instruction.Create(OpCodes.Br, pop));
								newStatement.Add(brKeyInstr);
								newStatement.Add(Instruction.Create(OpCodes.Dup));
								newStatement.Add(pop);

								if (!unkSrc) {
									newStatement.Add(Instruction.Create(OpCodes.Ldloc, local));
									newStatement.Add(Instruction.CreateLdcI4(r));
									newStatement.Add(Instruction.Create(OpCodes.Mul));
									newStatement.Add(Instruction.Create(OpCodes.Xor));
								}

								ctx.AddJump(newStatement, switchHdr[1]);
								ctx.AddJunk(newStatement);
								operands[keyId[i]] = newStatement[0];
								converted = true;
							}
						}

						if (!converted) {
							// Normal

							var targetKey = predicate != null ? predicate.GetSwitchKey(key[i + 1]) : key[i + 1];
							if (!hasUnknownSource(newStatement)) {
								var thisKey = key[i];
								var r = ctx.Random.NextInt32();
								newStatement.Add(Instruction.Create(OpCodes.Ldloc, local));
								newStatement.Add(Instruction.CreateLdcI4(r));
								newStatement.Add(Instruction.Create(OpCodes.Mul));
								newStatement.Add(Instruction.Create(OpCodes.Ldc_I4, (thisKey * r) ^ targetKey));
								newStatement.Add(Instruction.Create(OpCodes.Xor));
							}
							else {
								newStatement.Add(Instruction.Create(OpCodes.Ldc_I4, targetKey));
							}

							ctx.AddJump(newStatement, switchHdr[1]);
							ctx.AddJunk(newStatement);
							operands[keyId[i]] = newStatement[0];
						}
					}
					else
						operands[keyId[i]] = switchHdr[0];

					current.Value = newStatement.ToArray();
					current = current.Next;
					i++;
				}
				operands[keyId[i]] = current.Value[0];
				switchInstr.Operand = operands;

				Instruction[] first = statements.First.Value;
				statements.RemoveFirst();
				Instruction[] last = statements.Last.Value;
				statements.RemoveLast();

				List<Instruction[]> newStatements = statements.ToList();
				ctx.Random.Shuffle(newStatements);

				block.Instructions.Clear();
				block.Instructions.AddRange(first);
				block.Instructions.AddRange(switchHdr);
				foreach (var statement in newStatements)
					block.Instructions.AddRange(statement);
				block.Instructions.AddRange(last);
			}
		}
	}
}


================================================
File: Confuser.Protections/ControlFlow/x86Predicate.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using Confuser.Core;
using Confuser.Core.Services;
using Confuser.DynCipher;
using Confuser.DynCipher.AST;
using Confuser.DynCipher.Generation;
using Confuser.Renamer;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using dnlib.DotNet.Writer;
using MethodBody = dnlib.DotNet.Writer.MethodBody;

namespace Confuser.Protections.ControlFlow {
	internal class x86Predicate : IPredicate {
		static readonly object Encoding = new object();
		readonly CFContext ctx;
		x86Encoding encoding;

		bool inited;

		public x86Predicate(CFContext ctx) {
			this.ctx = ctx;
		}

		public void Init(CilBody body) {
			if (inited)
				return;

			encoding = ctx.Context.Annotations.Get<x86Encoding>(ctx.Method.DeclaringType, Encoding, null);
			if (encoding == null) {
				encoding = new x86Encoding();
				encoding.Compile(ctx);
				ctx.Context.Annotations.Set(ctx.Method.DeclaringType, Encoding, encoding);
			}

			inited = true;
		}

		public void EmitSwitchLoad(IList<Instruction> instrs) {
			instrs.Add(Instruction.Create(OpCodes.Call, encoding.native));
		}

		public int GetSwitchKey(int key) {
			return encoding.expCompiled(key);
		}

		class x86Encoding {
			byte[] code;
			MethodBody codeChunk;

			public Func<int, int> expCompiled;
			Expression expression;
			Expression inverse;
			public MethodDef native;

			public void Compile(CFContext ctx) {
				var var = new Variable("{VAR}");
				var result = new Variable("{RESULT}");

				CorLibTypeSig int32 = ctx.Method.Module.CorLibTypes.Int32;
				native = new MethodDefUser(ctx.Context.Registry.GetService<INameService>().RandomName(), MethodSig.CreateStatic(int32, int32), MethodAttributes.PinvokeImpl | MethodAttributes.PrivateScope | MethodAttributes.Static);
				native.ImplAttributes = MethodImplAttributes.Native | MethodImplAttributes.Unmanaged | MethodImplAttributes.PreserveSig;
				// Attempt to improve performance --- failed with StackOverflowException... :/
				//var suppressAttr = ctx.Method.Module.CorLibTypes.GetTypeRef("System.Security", "SuppressUnmanagedCodeSecurityAttribute").ResolveThrow();
				//native.CustomAttributes.Add(new CustomAttribute((MemberRef)ctx.Method.Module.Import(suppressAttr.FindDefaultConstructor())));
				//native.HasSecurity = true;
				ctx.Method.Module.GlobalType.Methods.Add(native);

				ctx.Context.Registry.GetService<IMarkerService>().Mark(native, ctx.Protection);
				ctx.Context.Registry.GetService<INameService>().SetCanRename(native, false);

				x86Register? reg;
				var codeGen = new x86CodeGen();
				do {
					ctx.DynCipher.GenerateExpressionPair(
						ctx.Random,
						new VariableExpression { Variable = var }, new VariableExpression { Variable = result },
						ctx.Depth, out expression, out inverse);

					reg = codeGen.GenerateX86(inverse, (v, r) => { return new[] { x86Instruction.Create(x86OpCode.POP, new x86RegisterOperand(r)) }; });
				} while (reg == null);

				code = CodeGenUtils.AssembleCode(codeGen, reg.Value);

				expCompiled = new DMCodeGen(typeof(int), new[] { Tuple.Create("{VAR}", typeof(int)) })
					.GenerateCIL(expression)
					.Compile<Func<int, int>>();


				ctx.Context.CurrentModuleWriterListener.OnWriterEvent += InjectNativeCode;
			}

			void InjectNativeCode(object sender, ModuleWriterListenerEventArgs e) {
				var writer = (ModuleWriterBase)sender;
				if (e.WriterEvent == ModuleWriterEvent.MDEndWriteMethodBodies) {
					codeChunk = writer.MethodBodies.Add(new MethodBody(code));
				}
				else if (e.WriterEvent == ModuleWriterEvent.EndCalculateRvasAndFileOffsets) {
					uint rid = writer.MetaData.GetRid(native);
					writer.MetaData.TablesHeap.MethodTable[rid].RVA = (uint)codeChunk.RVA;
				}
			}
		}
	}
}


================================================
File: Confuser.Protections/Properties/AssemblyInfo.cs
================================================
ï»¿using System;
using System.Reflection;

[assembly: AssemblyTitle("ConfuserEx Protections")]
[assembly: AssemblyDescription("Protections and packers of ConfuserEx")]


================================================
File: Confuser.Protections/ReferenceProxy/ExpressionEncoding.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using Confuser.DynCipher.AST;
using Confuser.DynCipher.Generation;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.ReferenceProxy {
	internal class ExpressionEncoding : IRPEncoding {
		readonly Dictionary<MethodDef, Tuple<Expression, Func<int, int>>> keys = new Dictionary<MethodDef, Tuple<Expression, Func<int, int>>>();

		public Instruction[] EmitDecode(MethodDef init, RPContext ctx, Instruction[] arg) {
			Tuple<Expression, Func<int, int>> key = GetKey(ctx, init);

			var invCompiled = new List<Instruction>();
			new CodeGen(arg, ctx.Method, invCompiled).GenerateCIL(key.Item1);
			init.Body.MaxStack += (ushort)ctx.Depth;
			return invCompiled.ToArray();
		}

		public int Encode(MethodDef init, RPContext ctx, int value) {
			Tuple<Expression, Func<int, int>> key = GetKey(ctx, init);
			return key.Item2(value);
		}

		void Compile(RPContext ctx, CilBody body, out Func<int, int> expCompiled, out Expression inverse) {
			var var = new Variable("{VAR}");
			var result = new Variable("{RESULT}");

			Expression expression;
			ctx.DynCipher.GenerateExpressionPair(
				ctx.Random,
				new VariableExpression { Variable = var }, new VariableExpression { Variable = result },
				ctx.Depth, out expression, out inverse);

			expCompiled = new DMCodeGen(typeof(int), new[] { Tuple.Create("{VAR}", typeof(int)) })
				.GenerateCIL(expression)
				.Compile<Func<int, int>>();
		}

		Tuple<Expression, Func<int, int>> GetKey(RPContext ctx, MethodDef init) {
			Tuple<Expression, Func<int, int>> ret;
			if (!keys.TryGetValue(init, out ret)) {
				Func<int, int> keyFunc;
				Expression inverse;
				Compile(ctx, init.Body, out keyFunc, out inverse);
				keys[init] = ret = Tuple.Create(inverse, keyFunc);
			}
			return ret;
		}

		class CodeGen : CILCodeGen {
			readonly Instruction[] arg;

			public CodeGen(Instruction[] arg, MethodDef method, IList<Instruction> instrs)
				: base(method, instrs) {
				this.arg = arg;
			}

			protected override void LoadVar(Variable var) {
				if (var.Name == "{RESULT}") {
					foreach (Instruction instr in arg)
						Emit(instr);
				}
				else
					base.LoadVar(var);
			}
		}
	}
}


================================================
File: Confuser.Protections/ReferenceProxy/IRPEncoding.cs
================================================
ï»¿using System;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.ReferenceProxy {
	internal interface IRPEncoding {
		Instruction[] EmitDecode(MethodDef init, RPContext ctx, Instruction[] arg);
		int Encode(MethodDef init, RPContext ctx, int value);
	}
}


================================================
File: Confuser.Protections/ReferenceProxy/MildMode.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using Confuser.Core;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.ReferenceProxy {
	internal class MildMode : RPMode {
		// proxy method, { opCode, calling type, target method}
		readonly Dictionary<Tuple<Code, TypeDef, IMethod>, MethodDef> proxies = new Dictionary<Tuple<Code, TypeDef, IMethod>, MethodDef>();

		public override void ProcessCall(RPContext ctx, int instrIndex) {
			Instruction invoke = ctx.Body.Instructions[instrIndex];
			var target = (IMethod)invoke.Operand;

			// Value type proxy is not supported in mild mode.
			if (target.DeclaringType.ResolveTypeDefThrow().IsValueType)
				return;
			// Skipping visibility is not supported in mild mode.
			if (!target.ResolveThrow().IsPublic && !target.ResolveThrow().IsAssembly)
				return;

			Tuple<Code, TypeDef, IMethod> key = Tuple.Create(invoke.OpCode.Code, ctx.Method.DeclaringType, target);
			MethodDef proxy;
			if (!proxies.TryGetValue(key, out proxy)) {
				MethodSig sig = CreateProxySignature(ctx, target, invoke.OpCode.Code == Code.Newobj);

				proxy = new MethodDefUser(ctx.Name.RandomName(), sig);
				proxy.Attributes = MethodAttributes.PrivateScope | MethodAttributes.Static;
				proxy.ImplAttributes = MethodImplAttributes.Managed | MethodImplAttributes.IL;
				ctx.Method.DeclaringType.Methods.Add(proxy);

				// Fix peverify --- Non-virtual call to virtual methods must be done on this pointer
				if (invoke.OpCode.Code == Code.Call && target.ResolveThrow().IsVirtual) {
					proxy.IsStatic = false;
					sig.HasThis = true;
					sig.Params.RemoveAt(0);
				}

				ctx.Marker.Mark(proxy, ctx.Protection);
				ctx.Name.Analyze(proxy);
				ctx.Name.SetCanRename(proxy, false);

				proxy.Body = new CilBody();
				for (int i = 0; i < proxy.Parameters.Count; i++)
					proxy.Body.Instructions.Add(Instruction.Create(OpCodes.Ldarg, proxy.Parameters[i]));
				proxy.Body.Instructions.Add(Instruction.Create(invoke.OpCode, target));
				proxy.Body.Instructions.Add(Instruction.Create(OpCodes.Ret));

				proxies[key] = proxy;
			}

			invoke.OpCode = OpCodes.Call;
			if (ctx.Method.DeclaringType.HasGenericParameters) {
				var genArgs = new GenericVar[ctx.Method.DeclaringType.GenericParameters.Count];
				for (int i = 0; i < genArgs.Length; i++)
					genArgs[i] = new GenericVar(i);

				invoke.Operand = new MemberRefUser(
					ctx.Module,
					proxy.Name,
					proxy.MethodSig,
					new GenericInstSig((ClassOrValueTypeSig)ctx.Method.DeclaringType.ToTypeSig(), genArgs).ToTypeDefOrRef());
			}
			else
				invoke.Operand = proxy;

			var targetDef = target.ResolveMethodDef();
			if (targetDef != null)
				ctx.Context.Annotations.Set(targetDef, ReferenceProxyProtection.Targeted, ReferenceProxyProtection.Targeted);
		}

		public override void Finalize(RPContext ctx) { }
	}
}


================================================
File: Confuser.Protections/ReferenceProxy/NormalEncoding.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using Confuser.Core.Services;
using Confuser.DynCipher;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.ReferenceProxy {
	internal class NormalEncoding : IRPEncoding {
		readonly Dictionary<MethodDef, Tuple<int, int>> keys = new Dictionary<MethodDef, Tuple<int, int>>();

		public Instruction[] EmitDecode(MethodDef init, RPContext ctx, Instruction[] arg) {
			Tuple<int, int> key = GetKey(ctx.Random, init);
			var ret = new List<Instruction>();
			if (ctx.Random.NextBoolean()) {
				ret.Add(Instruction.Create(OpCodes.Ldc_I4, key.Item1));
				ret.AddRange(arg);
			}
			else {
				ret.AddRange(arg);
				ret.Add(Instruction.Create(OpCodes.Ldc_I4, key.Item1));
			}
			ret.Add(Instruction.Create(OpCodes.Mul));
			return ret.ToArray();
		}

		public int Encode(MethodDef init, RPContext ctx, int value) {
			Tuple<int, int> key = GetKey(ctx.Random, init);
			return value * key.Item2;
		}

		Tuple<int, int> GetKey(RandomGenerator random, MethodDef init) {
			Tuple<int, int> ret;
			if (!keys.TryGetValue(init, out ret)) {
				int key = random.NextInt32() | 1;
				keys[init] = ret = Tuple.Create(key, (int)MathsUtils.modInv((uint)key));
			}
			return ret;
		}
	}
}


================================================
File: Confuser.Protections/ReferenceProxy/RPContext.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using Confuser.Core;
using Confuser.Core.Services;
using Confuser.DynCipher;
using Confuser.Renamer;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.ReferenceProxy {
	internal enum Mode {
		Mild,
		Strong,
		Ftn
	}

	internal enum EncodingType {
		Normal,
		Expression,
		x86
	}

	internal class RPContext {
		public ReferenceProxyProtection Protection;
		public CilBody Body;
		public HashSet<Instruction> BranchTargets;
		public ConfuserContext Context;
		public Dictionary<MethodSig, TypeDef> Delegates;
		public int Depth;
		public IDynCipherService DynCipher;
		public EncodingType Encoding;
		public IRPEncoding EncodingHandler;
		public int InitCount;
		public bool InternalAlso;
		public IMarkerService Marker;
		public MethodDef Method;
		public Mode Mode;

		public RPMode ModeHandler;
		public ModuleDef Module;
		public INameService Name;
		public RandomGenerator Random;
		public bool TypeErasure;
	}
}


================================================
File: Confuser.Protections/ReferenceProxy/RPMode.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using Confuser.Core;
using Confuser.Renamer;
using Confuser.Renamer.References;
using dnlib.DotNet;

namespace Confuser.Protections.ReferenceProxy {
	internal abstract class RPMode {
		public abstract void ProcessCall(RPContext ctx, int instrIndex);
		public abstract void Finalize(RPContext ctx);

		static ITypeDefOrRef Import(RPContext ctx, TypeDef typeDef) {
			ITypeDefOrRef retTypeRef = new Importer(ctx.Module, ImporterOptions.TryToUseTypeDefs).Import(typeDef);
			if (typeDef.Module != ctx.Module && ctx.Context.Modules.Contains((ModuleDefMD)typeDef.Module))
				ctx.Name.AddReference(typeDef, new TypeRefReference((TypeRef)retTypeRef, typeDef));
			return retTypeRef;
		}

		protected static MethodSig CreateProxySignature(RPContext ctx, IMethod method, bool newObj) {
			ModuleDef module = ctx.Module;
			if (newObj) {
				Debug.Assert(method.MethodSig.HasThis);
				Debug.Assert(method.Name == ".ctor");
				TypeSig[] paramTypes = method.MethodSig.Params.Select(type => {
					if (ctx.TypeErasure && type.IsClassSig && method.MethodSig.HasThis)
						return module.CorLibTypes.Object;
					return type;
				}).ToArray();

				TypeSig retType;
				if (ctx.TypeErasure) // newobj will not be used with value types
					retType = module.CorLibTypes.Object;
				else {
					TypeDef declType = method.DeclaringType.ResolveTypeDefThrow();
					retType = Import(ctx, declType).ToTypeSig();
				}
				return MethodSig.CreateStatic(retType, paramTypes);
			}
			else {
				IEnumerable<TypeSig> paramTypes = method.MethodSig.Params.Select(type => {
					if (ctx.TypeErasure && type.IsClassSig && method.MethodSig.HasThis)
						return module.CorLibTypes.Object;
					return type;
				});
				if (method.MethodSig.HasThis && !method.MethodSig.ExplicitThis) {
					TypeDef declType = method.DeclaringType.ResolveTypeDefThrow();
					if (ctx.TypeErasure && !declType.IsValueType)
						paramTypes = new[] { module.CorLibTypes.Object }.Concat(paramTypes);
					else
						paramTypes = new[] { Import(ctx, declType).ToTypeSig() }.Concat(paramTypes);
				}
				TypeSig retType = method.MethodSig.RetType;
				if (ctx.TypeErasure && retType.IsClassSig)
					retType = module.CorLibTypes.Object;
				return MethodSig.CreateStatic(retType, paramTypes.ToArray());
			}
		}

		protected static TypeDef GetDelegateType(RPContext ctx, MethodSig sig) {
			TypeDef ret;
			if (ctx.Delegates.TryGetValue(sig, out ret))
				return ret;

			ret = new TypeDefUser(ctx.Name.ObfuscateName(ctx.Method.DeclaringType.Namespace, RenameMode.Unicode), ctx.Name.RandomName(), ctx.Module.CorLibTypes.GetTypeRef("System", "MulticastDelegate"));
			ret.Attributes = TypeAttributes.NotPublic | TypeAttributes.Sealed;

			var ctor = new MethodDefUser(".ctor", MethodSig.CreateInstance(ctx.Module.CorLibTypes.Void, ctx.Module.CorLibTypes.Object, ctx.Module.CorLibTypes.IntPtr));
			ctor.Attributes = MethodAttributes.Assembly | MethodAttributes.HideBySig | MethodAttributes.RTSpecialName | MethodAttributes.SpecialName;
			ctor.ImplAttributes = MethodImplAttributes.Runtime;
			ret.Methods.Add(ctor);

			var invoke = new MethodDefUser("Invoke", sig.Clone());
			invoke.MethodSig.HasThis = true;
			invoke.Attributes = MethodAttributes.Assembly | MethodAttributes.HideBySig | MethodAttributes.Virtual | MethodAttributes.NewSlot;
			invoke.ImplAttributes = MethodImplAttributes.Runtime;
			ret.Methods.Add(invoke);

			ctx.Module.Types.Add(ret);

			foreach (IDnlibDef def in ret.FindDefinitions()) {
				ctx.Marker.Mark(def, ctx.Protection);
				ctx.Name.SetCanRename(def, false);
			}

			ctx.Delegates[sig] = ret;
			return ret;
		}
	}
}


================================================
File: Confuser.Protections/ReferenceProxy/ReferenceProxyPhase.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using Confuser.Core;
using Confuser.Core.Services;
using Confuser.DynCipher;
using Confuser.Renamer;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using dnlib.DotNet.MD;

namespace Confuser.Protections.ReferenceProxy {
	internal class ReferenceProxyPhase : ProtectionPhase {
		public ReferenceProxyPhase(ReferenceProxyProtection parent)
			: base(parent) { }

		public override ProtectionTargets Targets {
			get { return ProtectionTargets.Methods; }
		}

		public override string Name {
			get { return "Encoding reference proxies"; }
		}

		RPContext ParseParameters(MethodDef method, ConfuserContext context, ProtectionParameters parameters, RPStore store) {
			var ret = new RPContext();
			ret.Mode = parameters.GetParameter(context, method, "mode", Mode.Mild);
			ret.Encoding = parameters.GetParameter(context, method, "encoding", EncodingType.Normal);
			ret.InternalAlso = parameters.GetParameter(context, method, "internal", false);
			ret.TypeErasure = parameters.GetParameter(context, method, "typeErasure", false);
			ret.Depth = parameters.GetParameter(context, method, "depth", 3);

			ret.Module = method.Module;
			ret.Method = method;
			ret.Body = method.Body;
			ret.BranchTargets = new HashSet<Instruction>(
				method.Body.Instructions
				      .Select(instr => instr.Operand as Instruction)
				      .Concat(method.Body.Instructions
				                    .Where(instr => instr.Operand is Instruction[])
				                    .SelectMany(instr => (Instruction[])instr.Operand))
				      .Where(target => target != null));

			ret.Protection = (ReferenceProxyProtection)Parent;
			ret.Random = store.random;
			ret.Context = context;
			ret.Marker = context.Registry.GetService<IMarkerService>();
			ret.DynCipher = context.Registry.GetService<IDynCipherService>();
			ret.Name = context.Registry.GetService<INameService>();

			ret.Delegates = store.delegates;

			switch (ret.Mode) {
				case Mode.Mild:
					ret.ModeHandler = store.mild ?? (store.mild = new MildMode());
					break;
				case Mode.Strong:
					ret.ModeHandler = store.strong ?? (store.strong = new StrongMode());
					break;
				default:
					throw new UnreachableException();
			}

			switch (ret.Encoding) {
				case EncodingType.Normal:
					ret.EncodingHandler = store.normal ?? (store.normal = new NormalEncoding());
					break;
				case EncodingType.Expression:
					ret.EncodingHandler = store.expression ?? (store.expression = new ExpressionEncoding());
					break;
				case EncodingType.x86:
					ret.EncodingHandler = store.x86 ?? (store.x86 = new x86Encoding());

					if ((context.CurrentModule.Cor20HeaderFlags & ComImageFlags.ILOnly) != 0)
						context.CurrentModuleWriterOptions.Cor20HeaderOptions.Flags &= ~ComImageFlags.ILOnly;
					break;
				default:
					throw new UnreachableException();
			}

			return ret;
		}

		static RPContext ParseParameters(ModuleDef module, ConfuserContext context, ProtectionParameters parameters, RPStore store) {
			var ret = new RPContext();
			ret.Depth = parameters.GetParameter(context, module, "depth", 3);
			ret.InitCount = parameters.GetParameter(context, module, "initCount", 0x10);

			ret.Random = store.random;
			ret.Module = module;
			ret.Context = context;
			ret.Marker = context.Registry.GetService<IMarkerService>();
			ret.DynCipher = context.Registry.GetService<IDynCipherService>();
			ret.Name = context.Registry.GetService<INameService>();

			ret.Delegates = store.delegates;

			return ret;
		}

		protected override void Execute(ConfuserContext context, ProtectionParameters parameters) {
			RandomGenerator random = context.Registry.GetService<IRandomService>().GetRandomGenerator(ReferenceProxyProtection._FullId);

			var store = new RPStore { random = random };

			foreach (MethodDef method in parameters.Targets.OfType<MethodDef>().WithProgress(context.Logger))
				if (method.HasBody && method.Body.Instructions.Count > 0) {
					ProcessMethod(ParseParameters(method, context, parameters, store));
					context.CheckCancellation();
				}

			RPContext ctx = ParseParameters(context.CurrentModule, context, parameters, store);

			if (store.mild != null)
				store.mild.Finalize(ctx);

			if (store.strong != null)
				store.strong.Finalize(ctx);
		}

		void ProcessMethod(RPContext ctx) {
			for (int i = 0; i < ctx.Body.Instructions.Count; i++) {
				Instruction instr = ctx.Body.Instructions[i];
				if (instr.OpCode.Code == Code.Call || instr.OpCode.Code == Code.Callvirt || instr.OpCode.Code == Code.Newobj) {
					var operand = (IMethod)instr.Operand;
					var def = operand.ResolveMethodDef();

					if (def != null && ctx.Context.Annotations.Get<object>(def, ReferenceProxyProtection.TargetExcluded) != null)
						return;

					// Call constructor
					if (instr.OpCode.Code != Code.Newobj && operand.Name == ".ctor")
						continue;
					// Internal reference option
					if (operand is MethodDef && !ctx.InternalAlso)
						continue;
					// No generic methods
					if (operand is MethodSpec)
						continue;
					// No generic types / array types
					if (operand.DeclaringType is TypeSpec)
						continue;
					// No varargs
					if (operand.MethodSig.ParamsAfterSentinel != null &&
						operand.MethodSig.ParamsAfterSentinel.Count > 0)
						continue;
					TypeDef declType = operand.DeclaringType.ResolveTypeDefThrow();
					// No delegates
					if (declType.IsDelegate())
						continue;
					// No instance value type methods
					if (declType.IsValueType && operand.MethodSig.HasThis)
						return;
					// No prefixed call
					if (i - 1 >= 0 && ctx.Body.Instructions[i - 1].OpCode.OpCodeType == OpCodeType.Prefix)
						continue;

					ctx.ModeHandler.ProcessCall(ctx, i);
				}
			}
		}

		class RPStore {
			public readonly Dictionary<MethodSig, TypeDef> delegates = new Dictionary<MethodSig, TypeDef>(new MethodSigComparer());
			public ExpressionEncoding expression;
			public MildMode mild;

			public NormalEncoding normal;
			public RandomGenerator random;
			public StrongMode strong;
			public x86Encoding x86;

			class MethodSigComparer : IEqualityComparer<MethodSig> {
				public bool Equals(MethodSig x, MethodSig y) {
					return new SigComparer().Equals(x, y);
				}

				public int GetHashCode(MethodSig obj) {
					return new SigComparer().GetHashCode(obj);
				}
			}
		}
	}
}


================================================
File: Confuser.Protections/ReferenceProxy/ReferenceProxyProtection.cs
================================================
ï»¿using System;
using Confuser.Core;
using Confuser.Protections.ReferenceProxy;
using dnlib.DotNet;

namespace Confuser.Protections {
	public interface IReferenceProxyService {
		void ExcludeMethod(ConfuserContext context, MethodDef method);
		void ExcludeTarget(ConfuserContext context, MethodDef method);
		bool IsTargeted(ConfuserContext context, MethodDef method);
	}

	[AfterProtection("Ki.AntiDebug", "Ki.AntiDump")]
	[BeforeProtection("Ki.ControlFlow")]
	internal class ReferenceProxyProtection : Protection, IReferenceProxyService {
		public const string _Id = "ref proxy";
		public const string _FullId = "Ki.RefProxy";
		public const string _ServiceId = "Ki.RefProxy";

		internal static object TargetExcluded = new object();
		internal static object Targeted = new object();

		public override string Name {
			get { return "Reference Proxy Protection"; }
		}

		public override string Description {
			get { return "This protection encodes and hides references to type/method/fields."; }
		}

		public override string Id {
			get { return _Id; }
		}

		public override string FullId {
			get { return _FullId; }
		}

		public override ProtectionPreset Preset {
			get { return ProtectionPreset.Normal; }
		}

		public void ExcludeMethod(ConfuserContext context, MethodDef method) {
			ProtectionParameters.GetParameters(context, method).Remove(this);
		}

		public void ExcludeTarget(ConfuserContext context, MethodDef method) {
			context.Annotations.Set(method, TargetExcluded, TargetExcluded);
		}

		public bool IsTargeted(ConfuserContext context, MethodDef method) {
			return context.Annotations.Get<object>(method, Targeted) != null;
		}

		protected override void Initialize(ConfuserContext context) {
			context.Registry.RegisterService(_ServiceId, typeof(IReferenceProxyService), this);
		}

		protected override void PopulatePipeline(ProtectionPipeline pipeline) {
			pipeline.InsertPreStage(PipelineStage.ProcessModule, new ReferenceProxyPhase(this));
		}
	}
}


================================================
File: Confuser.Protections/ReferenceProxy/StrongMode.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using Confuser.Core;
using Confuser.Core.Helpers;
using Confuser.Core.Services;
using Confuser.DynCipher;
using Confuser.DynCipher.AST;
using Confuser.DynCipher.Generation;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using dnlib.DotNet.Writer;

namespace Confuser.Protections.ReferenceProxy {
	internal class StrongMode : RPMode {
		// { invoke opCode, invoke target, encoding}, { proxy field, bridge method }
		readonly List<FieldDesc> fieldDescs = new List<FieldDesc>();
		readonly Dictionary<Tuple<Code, IMethod, IRPEncoding>, Tuple<FieldDef, MethodDef>> fields = new Dictionary<Tuple<Code, IMethod, IRPEncoding>, Tuple<FieldDef, MethodDef>>();

		readonly Dictionary<IRPEncoding, InitMethodDesc[]> inits = new Dictionary<IRPEncoding, InitMethodDesc[]>();
		RPContext encodeCtx;
		Tuple<TypeDef, Func<int, int>>[] keyAttrs;

		static int? TraceBeginning(RPContext ctx, int index, int argCount) {
			if (ctx.BranchTargets.Contains(ctx.Body.Instructions[index]))
				return null;

			int currentStack = argCount;
			int currentIndex = index;
			while (currentStack > 0) {
				currentIndex--;
				Instruction currentInstr = ctx.Body.Instructions[currentIndex];

				// Disrupt stack analysis :/ Used by array initializer
				if (currentInstr.OpCode == OpCodes.Pop || currentInstr.OpCode == OpCodes.Dup)
					return null;

				// No branch instr.
				switch (currentInstr.OpCode.FlowControl) {
					case FlowControl.Call:
					case FlowControl.Break:
					case FlowControl.Meta:
					case FlowControl.Next:
						break;
					default:
						return null;
				}

				int push, pop;
				currentInstr.CalculateStackUsage(out push, out pop);
				currentStack += pop;
				currentStack -= push;

				// No branch target
				if (ctx.BranchTargets.Contains(currentInstr) && currentStack != 0)
					return null;
			}
			if (currentStack < 0)
				return null;
			return currentIndex;
		}

		public override void ProcessCall(RPContext ctx, int instrIndex) {
			Instruction invoke = ctx.Body.Instructions[instrIndex];

			TypeDef declType = ((IMethod)invoke.Operand).DeclaringType.ResolveTypeDefThrow();
			if (!declType.Module.IsILOnly) // Reflection doesn't like mixed mode modules.
				return;
			if (declType.IsGlobalModuleType) // Reflection doesn't like global methods too.
				return;

			int push, pop;
			invoke.CalculateStackUsage(out push, out pop);
			int? begin = TraceBeginning(ctx, instrIndex, pop);
			// Fail to trace the arguments => fall back to bridge method
			bool fallBack = begin == null;

			if (fallBack) {
				ProcessBridge(ctx, instrIndex);
			}
			else {
				ProcessInvoke(ctx, instrIndex, begin.Value);
			}
		}

		void ProcessBridge(RPContext ctx, int instrIndex) {
			Instruction instr = ctx.Body.Instructions[instrIndex];
			var target = (IMethod)instr.Operand;

			TypeDef declType = target.DeclaringType.ResolveTypeDefThrow();
			if (!declType.Module.IsILOnly) // Reflection doesn't like mixed mode modules.
				return;
			if (declType.IsGlobalModuleType) // Reflection doesn't like global methods too.
				return;

			Tuple<Code, IMethod, IRPEncoding> key = Tuple.Create(instr.OpCode.Code, target, ctx.EncodingHandler);
			Tuple<FieldDef, MethodDef> proxy;
			if (fields.TryGetValue(key, out proxy)) {
				if (proxy.Item2 != null) {
					instr.OpCode = OpCodes.Call;
					instr.Operand = proxy.Item2;
					return;
				}
			}
			else
				proxy = new Tuple<FieldDef, MethodDef>(null, null);

			MethodSig sig = CreateProxySignature(ctx, target, instr.OpCode.Code == Code.Newobj);
			TypeDef delegateType = GetDelegateType(ctx, sig);

			// Create proxy field
			if (proxy.Item1 == null)
				proxy = new Tuple<FieldDef, MethodDef>(
					CreateField(ctx, delegateType),
					proxy.Item2);

			// Create proxy bridge
			Debug.Assert(proxy.Item2 == null);

			proxy = new Tuple<FieldDef, MethodDef>(
				proxy.Item1,
				CreateBridge(ctx, delegateType, proxy.Item1, sig));

			fields[key] = proxy;

			// Replace instruction
			instr.OpCode = OpCodes.Call;
			instr.Operand = proxy.Item2;

			var targetDef = target.ResolveMethodDef();
			if (targetDef != null)
				ctx.Context.Annotations.Set(targetDef, ReferenceProxyProtection.Targeted, ReferenceProxyProtection.Targeted);
		}

		void ProcessInvoke(RPContext ctx, int instrIndex, int argBeginIndex) {
			Instruction instr = ctx.Body.Instructions[instrIndex];
			var target = (IMethod)instr.Operand;

			MethodSig sig = CreateProxySignature(ctx, target, instr.OpCode.Code == Code.Newobj);
			TypeDef delegateType = GetDelegateType(ctx, sig);

			Tuple<Code, IMethod, IRPEncoding> key = Tuple.Create(instr.OpCode.Code, target, ctx.EncodingHandler);
			Tuple<FieldDef, MethodDef> proxy;
			if (!fields.TryGetValue(key, out proxy)) {
				// Create proxy field
				proxy = new Tuple<FieldDef, MethodDef>(CreateField(ctx, delegateType), null);
				fields[key] = proxy;
			}

			// Insert field load & replace instruction
			if (argBeginIndex == instrIndex) {
				ctx.Body.Instructions.Insert(instrIndex + 1,
				                             new Instruction(OpCodes.Call, delegateType.FindMethod("Invoke")));
				instr.OpCode = OpCodes.Ldsfld;
				instr.Operand = proxy.Item1;
			}
			else {
				Instruction argBegin = ctx.Body.Instructions[argBeginIndex];
				ctx.Body.Instructions.Insert(argBeginIndex + 1,
				                             new Instruction(argBegin.OpCode, argBegin.Operand));
				argBegin.OpCode = OpCodes.Ldsfld;
				argBegin.Operand = proxy.Item1;

				instr.OpCode = OpCodes.Call;
				instr.Operand = delegateType.FindMethod("Invoke");
			}

			var targetDef = target.ResolveMethodDef();
			if (targetDef != null)
				ctx.Context.Annotations.Set(targetDef, ReferenceProxyProtection.Targeted, ReferenceProxyProtection.Targeted);
		}

		MethodDef CreateBridge(RPContext ctx, TypeDef delegateType, FieldDef field, MethodSig sig) {
			var method = new MethodDefUser(ctx.Name.RandomName(), sig);
			method.Attributes = MethodAttributes.PrivateScope | MethodAttributes.Static;
			method.ImplAttributes = MethodImplAttributes.Managed | MethodImplAttributes.IL;

			method.Body = new CilBody();
			method.Body.Instructions.Add(Instruction.Create(OpCodes.Ldsfld, field));
			for (int i = 0; i < method.Parameters.Count; i++)
				method.Body.Instructions.Add(Instruction.Create(OpCodes.Ldarg, method.Parameters[i]));
			method.Body.Instructions.Add(Instruction.Create(OpCodes.Call, delegateType.FindMethod("Invoke")));
			method.Body.Instructions.Add(Instruction.Create(OpCodes.Ret));

			delegateType.Methods.Add(method);

			ctx.Context.Registry.GetService<IMarkerService>().Mark(method, ctx.Protection);
			ctx.Name.SetCanRename(method, false);

			return method;
		}

		FieldDef CreateField(RPContext ctx, TypeDef delegateType) {
			// Details will be filled in during metadata writing
			TypeDef randomType;
			do {
				randomType = ctx.Module.Types[ctx.Random.NextInt32(ctx.Module.Types.Count)];
			} while (randomType.HasGenericParameters || randomType.IsGlobalModuleType || randomType.IsDelegate());

			TypeSig fieldType = new CModOptSig(randomType, delegateType.ToTypeSig());

			var field = new FieldDefUser("", new FieldSig(fieldType), FieldAttributes.Static | FieldAttributes.Assembly);
			field.CustomAttributes.Add(new CustomAttribute(GetKeyAttr(ctx).FindInstanceConstructors().First()));
			delegateType.Fields.Add(field);

			ctx.Marker.Mark(field, ctx.Protection);
			ctx.Name.SetCanRename(field, false);

			return field;
		}

		TypeDef GetKeyAttr(RPContext ctx) {
			if (keyAttrs == null)
				keyAttrs = new Tuple<TypeDef, Func<int, int>>[0x10];

			int index = ctx.Random.NextInt32(keyAttrs.Length);
			if (keyAttrs[index] == null) {
				TypeDef rtType = ctx.Context.Registry.GetService<IRuntimeService>().GetRuntimeType("Confuser.Runtime.RefProxyKey");
				TypeDef injectedAttr = InjectHelper.Inject(rtType, ctx.Module);
				injectedAttr.Name = ctx.Name.RandomName();
				injectedAttr.Namespace = string.Empty;

				Expression expression, inverse;
				var var = new Variable("{VAR}");
				var result = new Variable("{RESULT}");

				ctx.DynCipher.GenerateExpressionPair(
					ctx.Random,
					new VariableExpression { Variable = var }, new VariableExpression { Variable = result },
					ctx.Depth, out expression, out inverse);

				var expCompiled = new DMCodeGen(typeof(int), new[] { Tuple.Create("{VAR}", typeof(int)) })
					.GenerateCIL(expression)
					.Compile<Func<int, int>>();

				MethodDef ctor = injectedAttr.FindMethod(".ctor");
				MutationHelper.ReplacePlaceholder(ctor, arg => {
					var invCompiled = new List<Instruction>();
					new CodeGen(arg, ctor, invCompiled).GenerateCIL(inverse);
					return invCompiled.ToArray();
				});
				keyAttrs[index] = Tuple.Create(injectedAttr, expCompiled);

				ctx.Module.AddAsNonNestedType(injectedAttr);

				foreach (IDnlibDef def in injectedAttr.FindDefinitions()) {
					if (def.Name == "GetHashCode") {
						ctx.Name.MarkHelper(def, ctx.Marker, ctx.Protection);
						((MethodDef)def).Access = MethodAttributes.Public;
					}
					else
						ctx.Name.MarkHelper(def, ctx.Marker, ctx.Protection);
				}
			}
			return keyAttrs[index].Item1;
		}

		InitMethodDesc GetInitMethod(RPContext ctx, IRPEncoding encoding) {
			InitMethodDesc[] initDescs;
			if (!inits.TryGetValue(encoding, out initDescs))
				inits[encoding] = initDescs = new InitMethodDesc[ctx.InitCount];

			int index = ctx.Random.NextInt32(initDescs.Length);
			if (initDescs[index] == null) {
				TypeDef rtType = ctx.Context.Registry.GetService<IRuntimeService>().GetRuntimeType("Confuser.Runtime.RefProxyStrong");
				MethodDef injectedMethod = InjectHelper.Inject(rtType.FindMethod("Initialize"), ctx.Module);
				ctx.Module.GlobalType.Methods.Add(injectedMethod);

				injectedMethod.Access = MethodAttributes.PrivateScope;
				injectedMethod.Name = ctx.Name.RandomName();
				ctx.Name.SetCanRename(injectedMethod, false);
				ctx.Marker.Mark(injectedMethod, ctx.Protection);

				var desc = new InitMethodDesc { Method = injectedMethod };

				// Field name has five bytes, each bytes has different order & meaning
				int[] order = Enumerable.Range(0, 5).ToArray();
				ctx.Random.Shuffle(order);
				desc.OpCodeIndex = order[4];

				desc.TokenNameOrder = new int[4];
				Array.Copy(order, 0, desc.TokenNameOrder, 0, 4);
				desc.TokenByteOrder = Enumerable.Range(0, 4).Select(x => x * 8).ToArray();
				ctx.Random.Shuffle(desc.TokenByteOrder);

				var keyInjection = new int[9];
				Array.Copy(desc.TokenNameOrder, 0, keyInjection, 0, 4);
				Array.Copy(desc.TokenByteOrder, 0, keyInjection, 4, 4);
				keyInjection[8] = desc.OpCodeIndex;
				MutationHelper.InjectKeys(injectedMethod, Enumerable.Range(0, 9).ToArray(), keyInjection);

				// Encoding
				MutationHelper.ReplacePlaceholder(injectedMethod, arg => { return encoding.EmitDecode(injectedMethod, ctx, arg); });
				desc.Encoding = encoding;

				initDescs[index] = desc;
			}
			return initDescs[index];
		}

		public override void Finalize(RPContext ctx) {
			foreach (var field in fields) {
				InitMethodDesc init = GetInitMethod(ctx, field.Key.Item3);
				byte opKey;
				do {
					// No zero bytes
					opKey = ctx.Random.NextByte();
				} while (opKey == (byte)field.Key.Item1);

				TypeDef delegateType = field.Value.Item1.DeclaringType;

				MethodDef cctor = delegateType.FindOrCreateStaticConstructor();
				cctor.Body.Instructions.Insert(0, Instruction.Create(OpCodes.Call, init.Method));
				cctor.Body.Instructions.Insert(0, Instruction.CreateLdcI4(opKey));
				cctor.Body.Instructions.Insert(0, Instruction.Create(OpCodes.Ldtoken, field.Value.Item1));

				fieldDescs.Add(new FieldDesc {
					Field = field.Value.Item1,
					OpCode = field.Key.Item1,
					Method = field.Key.Item2,
					OpKey = opKey,
					InitDesc = init
				});
			}

			foreach (TypeDef delegateType in ctx.Delegates.Values) {
				MethodDef cctor = delegateType.FindOrCreateStaticConstructor();
				ctx.Marker.Mark(cctor, ctx.Protection);
				ctx.Name.SetCanRename(cctor, false);
			}

			ctx.Context.CurrentModuleWriterOptions.MetaDataOptions.Flags |= MetaDataFlags.PreserveExtraSignatureData;
			ctx.Context.CurrentModuleWriterListener.OnWriterEvent += EncodeField;
			encodeCtx = ctx;
		}

		void EncodeField(object sender, ModuleWriterListenerEventArgs e) {
			var writer = (ModuleWriterBase)sender;
			if (e.WriterEvent == ModuleWriterEvent.MDMemberDefRidsAllocated && keyAttrs != null) {
				Dictionary<TypeDef, Func<int, int>> keyFuncs = keyAttrs
					.Where(entry => entry != null)
					.ToDictionary(entry => entry.Item1, entry => entry.Item2);
				foreach (FieldDesc desc in fieldDescs) {
					uint token = writer.MetaData.GetToken(desc.Method).Raw;
					uint key = encodeCtx.Random.NextUInt32() | 1;

					// CA
					CustomAttribute ca = desc.Field.CustomAttributes[0];
					int encodedKey = keyFuncs[(TypeDef)ca.AttributeType]((int)MathsUtils.modInv(key));
					ca.ConstructorArguments.Add(new CAArgument(encodeCtx.Module.CorLibTypes.Int32, encodedKey));
					token *= key;

					// Encoding
					token = (uint)desc.InitDesc.Encoding.Encode(desc.InitDesc.Method, encodeCtx, (int)token);

					// Field name
					var name = new char[5];
					name[desc.InitDesc.OpCodeIndex] = (char)((byte)desc.OpCode ^ desc.OpKey);

					byte[] nameKey = encodeCtx.Random.NextBytes(4);
					uint encodedNameKey = 0;
					for (int i = 0; i < 4; i++) {
						// No zero bytes
						while (nameKey[i] == 0)
							nameKey[i] = encodeCtx.Random.NextByte();
						name[desc.InitDesc.TokenNameOrder[i]] = (char)nameKey[i];
						encodedNameKey |= (uint)nameKey[i] << desc.InitDesc.TokenByteOrder[i];
					}
					desc.Field.Name = new string(name);

					// Field sig
					FieldSig sig = desc.Field.FieldSig;
					uint encodedToken = (token - writer.MetaData.GetToken(((CModOptSig)sig.Type).Modifier).Raw) ^ encodedNameKey;


					var extra = new byte[8];
					extra[0] = 0xc0;
					extra[3] = (byte)(encodedToken >> desc.InitDesc.TokenByteOrder[3]);
					extra[4] = 0xc0;
					extra[5] = (byte)(encodedToken >> desc.InitDesc.TokenByteOrder[2]);
					extra[6] = (byte)(encodedToken >> desc.InitDesc.TokenByteOrder[1]);
					extra[7] = (byte)(encodedToken >> desc.InitDesc.TokenByteOrder[0]);
					sig.ExtraData = extra;
				}
			}
		}

		class CodeGen : CILCodeGen {
			readonly Instruction[] arg;

			public CodeGen(Instruction[] arg, MethodDef method, IList<Instruction> instrs)
				: base(method, instrs) {
				this.arg = arg;
			}

			protected override void LoadVar(Variable var) {
				if (var.Name == "{RESULT}") {
					foreach (Instruction instr in arg)
						Emit(instr);
				}
				else
					base.LoadVar(var);
			}
		}

		class FieldDesc {
			public FieldDef Field;
			public InitMethodDesc InitDesc;
			public IMethod Method;
			public Code OpCode;
			public byte OpKey;
		}

		class InitMethodDesc {
			public IRPEncoding Encoding;
			public MethodDef Method;
			public int OpCodeIndex;
			public int[] TokenByteOrder;
			public int[] TokenNameOrder;
		}
	}
}


================================================
File: Confuser.Protections/ReferenceProxy/x86Encoding.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using Confuser.Core;
using Confuser.Core.Services;
using Confuser.DynCipher;
using Confuser.DynCipher.AST;
using Confuser.DynCipher.Generation;
using Confuser.Renamer;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using dnlib.DotNet.Writer;
using MethodBody = dnlib.DotNet.Writer.MethodBody;

namespace Confuser.Protections.ReferenceProxy {
	internal class x86Encoding : IRPEncoding {
		readonly Dictionary<MethodDef, Tuple<MethodDef, Func<int, int>>> keys = new Dictionary<MethodDef, Tuple<MethodDef, Func<int, int>>>();
		readonly List<Tuple<MethodDef, byte[], MethodBody>> nativeCodes = new List<Tuple<MethodDef, byte[], MethodBody>>();
		bool addedHandler;

		public Instruction[] EmitDecode(MethodDef init, RPContext ctx, Instruction[] arg) {
			Tuple<MethodDef, Func<int, int>> key = GetKey(ctx, init);

			var repl = new List<Instruction>();
			repl.AddRange(arg);
			repl.Add(Instruction.Create(OpCodes.Call, key.Item1));
			return repl.ToArray();
		}

		public int Encode(MethodDef init, RPContext ctx, int value) {
			Tuple<MethodDef, Func<int, int>> key = GetKey(ctx, init);
			return key.Item2(value);
		}

		void Compile(RPContext ctx, out Func<int, int> expCompiled, out MethodDef native) {
			var var = new Variable("{VAR}");
			var result = new Variable("{RESULT}");

			CorLibTypeSig int32 = ctx.Module.CorLibTypes.Int32;
			native = new MethodDefUser(ctx.Context.Registry.GetService<INameService>().RandomName(), MethodSig.CreateStatic(int32, int32), MethodAttributes.PinvokeImpl | MethodAttributes.PrivateScope | MethodAttributes.Static);
			native.ImplAttributes = MethodImplAttributes.Native | MethodImplAttributes.Unmanaged | MethodImplAttributes.PreserveSig;
			ctx.Module.GlobalType.Methods.Add(native);

			ctx.Context.Registry.GetService<IMarkerService>().Mark(native, ctx.Protection);
			ctx.Context.Registry.GetService<INameService>().SetCanRename(native, false);

			x86Register? reg;
			var codeGen = new x86CodeGen();
			Expression expression, inverse;
			do {
				ctx.DynCipher.GenerateExpressionPair(
					ctx.Random,
					new VariableExpression { Variable = var }, new VariableExpression { Variable = result },
					ctx.Depth, out expression, out inverse);

				reg = codeGen.GenerateX86(inverse, (v, r) => { return new[] { x86Instruction.Create(x86OpCode.POP, new x86RegisterOperand(r)) }; });
			} while (reg == null);

			byte[] code = CodeGenUtils.AssembleCode(codeGen, reg.Value);

			expCompiled = new DMCodeGen(typeof(int), new[] { Tuple.Create("{VAR}", typeof(int)) })
				.GenerateCIL(expression)
				.Compile<Func<int, int>>();

			nativeCodes.Add(Tuple.Create(native, code, (MethodBody)null));
			if (!addedHandler) {
				ctx.Context.CurrentModuleWriterListener.OnWriterEvent += InjectNativeCode;
				addedHandler = true;
			}
		}

		void InjectNativeCode(object sender, ModuleWriterListenerEventArgs e) {
			var writer = (ModuleWriterBase)sender;
			if (e.WriterEvent == ModuleWriterEvent.MDEndWriteMethodBodies) {
				for (int n = 0; n < nativeCodes.Count; n++)
					nativeCodes[n] = new Tuple<MethodDef, byte[], MethodBody>(
						nativeCodes[n].Item1,
						nativeCodes[n].Item2,
						writer.MethodBodies.Add(new MethodBody(nativeCodes[n].Item2)));
			}
			else if (e.WriterEvent == ModuleWriterEvent.EndCalculateRvasAndFileOffsets) {
				foreach (var native in nativeCodes) {
					uint rid = writer.MetaData.GetRid(native.Item1);
					writer.MetaData.TablesHeap.MethodTable[rid].RVA = (uint)native.Item3.RVA;
				}
			}
		}

		Tuple<MethodDef, Func<int, int>> GetKey(RPContext ctx, MethodDef init) {
			Tuple<MethodDef, Func<int, int>> ret;
			if (!keys.TryGetValue(init, out ret)) {
				Func<int, int> keyFunc;
				MethodDef native;
				Compile(ctx, out keyFunc, out native);
				keys[init] = ret = Tuple.Create(native, keyFunc);
			}
			return ret;
		}

		class CodeGen : CILCodeGen {
			readonly Instruction[] arg;

			public CodeGen(Instruction[] arg, MethodDef method, IList<Instruction> instrs)
				: base(method, instrs) {
				this.arg = arg;
			}

			protected override void LoadVar(Variable var) {
				if (var.Name == "{RESULT}") {
					foreach (Instruction instr in arg)
						Emit(instr);
				}
				else
					base.LoadVar(var);
			}
		}
	}
}


================================================
File: Confuser.Protections/Resources/DynamicMode.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using Confuser.DynCipher.AST;
using Confuser.DynCipher.Generation;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.Resources {
	internal class DynamicMode : IEncodeMode {
		Action<uint[], uint[]> encryptFunc;

		public IEnumerable<Instruction> EmitDecrypt(MethodDef init, REContext ctx, Local block, Local key) {
			StatementBlock encrypt, decrypt;
			ctx.DynCipher.GenerateCipherPair(ctx.Random, out encrypt, out decrypt);
			var ret = new List<Instruction>();

			var codeGen = new CodeGen(block, key, init, ret);
			codeGen.GenerateCIL(decrypt);
			codeGen.Commit(init.Body);

			var dmCodeGen = new DMCodeGen(typeof(void), new[] {
				Tuple.Create("{BUFFER}", typeof(uint[])),
				Tuple.Create("{KEY}", typeof(uint[]))
			});
			dmCodeGen.GenerateCIL(encrypt);
			encryptFunc = dmCodeGen.Compile<Action<uint[], uint[]>>();

			return ret;
		}

		public uint[] Encrypt(uint[] data, int offset, uint[] key) {
			var ret = new uint[key.Length];
			Buffer.BlockCopy(data, offset * sizeof(uint), ret, 0, key.Length * sizeof(uint));
			encryptFunc(ret, key);
			return ret;
		}

		class CodeGen : CILCodeGen {
			readonly Local block;
			readonly Local key;

			public CodeGen(Local block, Local key, MethodDef init, IList<Instruction> instrs)
				: base(init, instrs) {
				this.block = block;
				this.key = key;
			}

			protected override Local Var(Variable var) {
				if (var.Name == "{BUFFER}")
					return block;
				if (var.Name == "{KEY}")
					return key;
				return base.Var(var);
			}
		}
	}
}


================================================
File: Confuser.Protections/Resources/IEncodeMode.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.Resources {
	internal interface IEncodeMode {
		IEnumerable<Instruction> EmitDecrypt(MethodDef init, REContext ctx, Local block, Local key);
		uint[] Encrypt(uint[] data, int offset, uint[] key);
	}
}


================================================
File: Confuser.Protections/Resources/InjectPhase.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Runtime.CompilerServices;
using Confuser.Core;
using Confuser.Core.Helpers;
using Confuser.Core.Services;
using Confuser.DynCipher;
using Confuser.Renamer;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.Resources {
	internal class InjectPhase : ProtectionPhase {
		public InjectPhase(ResourceProtection parent)
			: base(parent) { }

		public override ProtectionTargets Targets {
			get { return ProtectionTargets.Methods; }
		}

		public override string Name {
			get { return "Resource encryption helpers injection"; }
		}

		protected override void Execute(ConfuserContext context, ProtectionParameters parameters) {
			if (parameters.Targets.Any()) {
				if (!UTF8String.IsNullOrEmpty(context.CurrentModule.Assembly.Culture)) {
					context.Logger.DebugFormat("Skipping resource encryption for satellite assembly '{0}'.",
					                           context.CurrentModule.Assembly.FullName);
					return;
				}
				var compression = context.Registry.GetService<ICompressionService>();
				var name = context.Registry.GetService<INameService>();
				var marker = context.Registry.GetService<IMarkerService>();
				var rt = context.Registry.GetService<IRuntimeService>();
				var moduleCtx = new REContext {
					Random = context.Registry.GetService<IRandomService>().GetRandomGenerator(Parent.Id),
					Context = context,
					Module = context.CurrentModule,
					Marker = marker,
					DynCipher = context.Registry.GetService<IDynCipherService>(),
					Name = name
				};

				// Extract parameters
				moduleCtx.Mode = parameters.GetParameter(context, context.CurrentModule, "mode", Mode.Normal);

				switch (moduleCtx.Mode) {
					case Mode.Normal:
						moduleCtx.ModeHandler = new NormalMode();
						break;
					case Mode.Dynamic:
						moduleCtx.ModeHandler = new DynamicMode();
						break;
					default:
						throw new UnreachableException();
				}

				// Inject helpers
				MethodDef decomp = compression.GetRuntimeDecompressor(context.CurrentModule, member => {
					name.MarkHelper(member, marker, (Protection)Parent);
					if (member is MethodDef)
						ProtectionParameters.GetParameters(context, member).Remove(Parent);
				});
				InjectHelpers(context, compression, rt, moduleCtx);

				// Mutate codes
				MutateInitializer(moduleCtx, decomp);

				MethodDef cctor = context.CurrentModule.GlobalType.FindStaticConstructor();
				cctor.Body.Instructions.Insert(0, Instruction.Create(OpCodes.Call, moduleCtx.InitMethod));

				new MDPhase(moduleCtx).Hook();
			}
		}

		void InjectHelpers(ConfuserContext context, ICompressionService compression, IRuntimeService rt, REContext moduleCtx) {
			var rtName = context.Packer != null ? "Confuser.Runtime.Resource_Packer" : "Confuser.Runtime.Resource";
			IEnumerable<IDnlibDef> members = InjectHelper.Inject(rt.GetRuntimeType(rtName), context.CurrentModule.GlobalType, context.CurrentModule);
			foreach (IDnlibDef member in members) {
				if (member.Name == "Initialize")
					moduleCtx.InitMethod = (MethodDef)member;
				moduleCtx.Name.MarkHelper(member, moduleCtx.Marker, (Protection)Parent);
			}

			var dataType = new TypeDefUser("", moduleCtx.Name.RandomName(), context.CurrentModule.CorLibTypes.GetTypeRef("System", "ValueType"));
			dataType.Layout = TypeAttributes.ExplicitLayout;
			dataType.Visibility = TypeAttributes.NestedPrivate;
			dataType.IsSealed = true;
			dataType.ClassLayout = new ClassLayoutUser(1, 0);
			moduleCtx.DataType = dataType;
			context.CurrentModule.GlobalType.NestedTypes.Add(dataType);
			moduleCtx.Name.MarkHelper(dataType, moduleCtx.Marker, (Protection)Parent);

			moduleCtx.DataField = new FieldDefUser(moduleCtx.Name.RandomName(), new FieldSig(dataType.ToTypeSig())) {
				IsStatic = true,
				HasFieldRVA = true,
				InitialValue = new byte[0],
				Access = FieldAttributes.CompilerControlled
			};
			context.CurrentModule.GlobalType.Fields.Add(moduleCtx.DataField);
			moduleCtx.Name.MarkHelper(moduleCtx.DataField, moduleCtx.Marker, (Protection)Parent);
		}

		void MutateInitializer(REContext moduleCtx, MethodDef decomp) {
			moduleCtx.InitMethod.Body.SimplifyMacros(moduleCtx.InitMethod.Parameters);
			List<Instruction> instrs = moduleCtx.InitMethod.Body.Instructions.ToList();
			for (int i = 0; i < instrs.Count; i++) {
				Instruction instr = instrs[i];
				var method = instr.Operand as IMethod;
				if (instr.OpCode == OpCodes.Call) {
					if (method.DeclaringType.Name == "Mutation" &&
					    method.Name == "Crypt") {
						Instruction ldBlock = instrs[i - 2];
						Instruction ldKey = instrs[i - 1];
						Debug.Assert(ldBlock.OpCode == OpCodes.Ldloc && ldKey.OpCode == OpCodes.Ldloc);
						instrs.RemoveAt(i);
						instrs.RemoveAt(i - 1);
						instrs.RemoveAt(i - 2);
						instrs.InsertRange(i - 2, moduleCtx.ModeHandler.EmitDecrypt(moduleCtx.InitMethod, moduleCtx, (Local)ldBlock.Operand, (Local)ldKey.Operand));
					}
					else if (method.DeclaringType.Name == "Lzma" &&
					         method.Name == "Decompress") {
						instr.Operand = decomp;
					}
				}
			}
			moduleCtx.InitMethod.Body.Instructions.Clear();
			foreach (Instruction instr in instrs)
				moduleCtx.InitMethod.Body.Instructions.Add(instr);

			MutationHelper.ReplacePlaceholder(moduleCtx.InitMethod, arg => {
				var repl = new List<Instruction>();
				repl.AddRange(arg);
				repl.Add(Instruction.Create(OpCodes.Dup));
				repl.Add(Instruction.Create(OpCodes.Ldtoken, moduleCtx.DataField));
				repl.Add(Instruction.Create(OpCodes.Call, moduleCtx.Module.Import(
					typeof(RuntimeHelpers).GetMethod("InitializeArray"))));
				return repl.ToArray();
			});
			moduleCtx.Context.Registry.GetService<IConstantService>().ExcludeMethod(moduleCtx.Context, moduleCtx.InitMethod);
		}
	}
}


================================================
File: Confuser.Protections/Resources/MDPhase.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using Confuser.Core;
using Confuser.Core.Helpers;
using Confuser.Core.Services;
using Confuser.Renamer;
using dnlib.DotNet;
using dnlib.DotNet.Writer;

namespace Confuser.Protections.Resources {
	internal class MDPhase {
		readonly REContext ctx;
		ByteArrayChunk encryptedResource;

		public MDPhase(REContext ctx) {
			this.ctx = ctx;
		}

		public void Hook() {
			ctx.Context.CurrentModuleWriterListener.OnWriterEvent += OnWriterEvent;
		}

		void OnWriterEvent(object sender, ModuleWriterListenerEventArgs e) {
			var writer = (ModuleWriterBase)sender;
			if (e.WriterEvent == ModuleWriterEvent.MDBeginAddResources) {
				ctx.Context.CheckCancellation();
				ctx.Context.Logger.Debug("Encrypting resources...");
				bool hasPacker = ctx.Context.Packer != null;

				List<EmbeddedResource> resources = ctx.Module.Resources.OfType<EmbeddedResource>().ToList();
				if (!hasPacker)
					ctx.Module.Resources.RemoveWhere(res => res is EmbeddedResource);

				// move resources
				string asmName = ctx.Name.RandomName(RenameMode.Letters);
				PublicKey pubKey = null;
				if (writer.TheOptions.StrongNameKey != null)
					pubKey = PublicKeyBase.CreatePublicKey(writer.TheOptions.StrongNameKey.PublicKey);
				var assembly = new AssemblyDefUser(asmName, new Version(0, 0), pubKey);
				assembly.Modules.Add(new ModuleDefUser(asmName + ".dll"));
				ModuleDef module = assembly.ManifestModule;
				assembly.ManifestModule.Kind = ModuleKind.Dll;
				var asmRef = new AssemblyRefUser(module.Assembly);
				if (!hasPacker) {
					foreach (EmbeddedResource res in resources) {
						res.Attributes = ManifestResourceAttributes.Public;
						module.Resources.Add(res);
						ctx.Module.Resources.Add(new AssemblyLinkedResource(res.Name, asmRef, res.Attributes));
					}
				}
				byte[] moduleBuff;
				using (var ms = new MemoryStream()) {
					module.Write(ms, new ModuleWriterOptions { StrongNameKey = writer.TheOptions.StrongNameKey });
					moduleBuff = ms.ToArray();
				}

				// compress
				moduleBuff = ctx.Context.Registry.GetService<ICompressionService>().Compress(
					moduleBuff,
					progress => ctx.Context.Logger.Progress((int)(progress * 10000), 10000));
				ctx.Context.Logger.EndProgress();
				ctx.Context.CheckCancellation();

				uint compressedLen = (uint)(moduleBuff.Length + 3) / 4;
				compressedLen = (compressedLen + 0xfu) & ~0xfu;
				var compressedBuff = new uint[compressedLen];
				Buffer.BlockCopy(moduleBuff, 0, compressedBuff, 0, moduleBuff.Length);
				Debug.Assert(compressedLen % 0x10 == 0);

				// encrypt
				uint keySeed = ctx.Random.NextUInt32() | 0x10;
				var key = new uint[0x10];
				uint state = keySeed;
				for (int i = 0; i < 0x10; i++) {
					state ^= state >> 13;
					state ^= state << 25;
					state ^= state >> 27;
					key[i] = state;
				}

				var encryptedBuffer = new byte[compressedBuff.Length * 4];
				int buffIndex = 0;
				while (buffIndex < compressedBuff.Length) {
					uint[] enc = ctx.ModeHandler.Encrypt(compressedBuff, buffIndex, key);
					for (int j = 0; j < 0x10; j++)
						key[j] ^= compressedBuff[buffIndex + j];
					Buffer.BlockCopy(enc, 0, encryptedBuffer, buffIndex * 4, 0x40);
					buffIndex += 0x10;
				}
				Debug.Assert(buffIndex == compressedBuff.Length);
				var size = (uint)encryptedBuffer.Length;

				TablesHeap tblHeap = writer.MetaData.TablesHeap;
				tblHeap.ClassLayoutTable[writer.MetaData.GetClassLayoutRid(ctx.DataType)].ClassSize = size;
				tblHeap.FieldTable[writer.MetaData.GetRid(ctx.DataField)].Flags |= (ushort)FieldAttributes.HasFieldRVA;
				encryptedResource = writer.Constants.Add(new ByteArrayChunk(encryptedBuffer), 8);

				// inject key values
				MutationHelper.InjectKeys(ctx.InitMethod,
				                          new[] { 0, 1 },
				                          new[] { (int)(size / 4), (int)(keySeed) });
			}
			else if (e.WriterEvent == ModuleWriterEvent.EndCalculateRvasAndFileOffsets) {
				TablesHeap tblHeap = writer.MetaData.TablesHeap;
				tblHeap.FieldRVATable[writer.MetaData.GetFieldRVARid(ctx.DataField)].RVA = (uint)encryptedResource.RVA;
			}
		}
	}
}


================================================
File: Confuser.Protections/Resources/Mode.cs
================================================
ï»¿using System;

namespace Confuser.Protections.Resources {
	internal enum Mode {
		Normal,
		Dynamic
	}
}


================================================
File: Confuser.Protections/Resources/NormalMode.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.Resources {
	internal class NormalMode : IEncodeMode {
		public IEnumerable<Instruction> EmitDecrypt(MethodDef init, REContext ctx, Local block, Local key) {
			for (int i = 0; i < 0x10; i++) {
				yield return Instruction.Create(OpCodes.Ldloc, block);
				yield return Instruction.Create(OpCodes.Ldc_I4, i);
				yield return Instruction.Create(OpCodes.Ldloc, block);
				yield return Instruction.Create(OpCodes.Ldc_I4, i);
				yield return Instruction.Create(OpCodes.Ldelem_U4);
				yield return Instruction.Create(OpCodes.Ldloc, key);
				yield return Instruction.Create(OpCodes.Ldc_I4, i);
				yield return Instruction.Create(OpCodes.Ldelem_U4);
				yield return Instruction.Create(OpCodes.Xor);
				yield return Instruction.Create(OpCodes.Stelem_I4);
			}
		}

		public uint[] Encrypt(uint[] data, int offset, uint[] key) {
			var ret = new uint[key.Length];
			for (int i = 0; i < key.Length; i++)
				ret[i] = data[i + offset] ^ key[i];
			return ret;
		}
	}
}


================================================
File: Confuser.Protections/Resources/REContext.cs
================================================
ï»¿using System;
using Confuser.Core;
using Confuser.Core.Services;
using Confuser.DynCipher;
using Confuser.Renamer;
using dnlib.DotNet;

namespace Confuser.Protections.Resources {
	internal class REContext {
		public ConfuserContext Context;

		public FieldDef DataField;
		public TypeDef DataType;
		public IDynCipherService DynCipher;
		public MethodDef InitMethod;
		public IMarkerService Marker;

		public Mode Mode;

		public IEncodeMode ModeHandler;
		public ModuleDef Module;
		public INameService Name;
		public RandomGenerator Random;
	}
}


================================================
File: Confuser.Protections/Resources/ResourceProtection.cs
================================================
ï»¿using System;
using Confuser.Core;
using Confuser.Protections.Resources;

namespace Confuser.Protections {
	[BeforeProtection("Ki.ControlFlow"), AfterProtection("Ki.Constants")]
	internal class ResourceProtection : Protection {
		public const string _Id = "resources";
		public const string _FullId = "Ki.Resources";
		public const string _ServiceId = "Ki.Resources";

		public override string Name {
			get { return "Resources Protection"; }
		}

		public override string Description {
			get { return "This protection encodes and compresses the embedded resources."; }
		}

		public override string Id {
			get { return _Id; }
		}

		public override string FullId {
			get { return _FullId; }
		}

		public override ProtectionPreset Preset {
			get { return ProtectionPreset.Normal; }
		}

		protected override void Initialize(ConfuserContext context) { }

		protected override void PopulatePipeline(ProtectionPipeline pipeline) {
			pipeline.InsertPreStage(PipelineStage.ProcessModule, new InjectPhase(this));
		}
	}
}


================================================
File: Confuser.Renamer/AnalyzePhase.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using Confuser.Core;
using Confuser.Renamer.Analyzers;
using dnlib.DotNet;

namespace Confuser.Renamer {
	internal class AnalyzePhase : ProtectionPhase {
		public AnalyzePhase(NameProtection parent)
			: base(parent) { }

		public override bool ProcessAll {
			get { return true; }
		}

		public override ProtectionTargets Targets {
			get { return ProtectionTargets.AllDefinitions; }
		}

		public override string Name {
			get { return "Name analysis"; }
		}

		void ParseParameters(IDnlibDef def, ConfuserContext context, NameService service, ProtectionParameters parameters) {
			var mode = parameters.GetParameter<RenameMode?>(context, def, "mode", null);
			if (mode != null)
				service.SetRenameMode(def, mode.Value);
		}

		protected override void Execute(ConfuserContext context, ProtectionParameters parameters) {
			var service = (NameService)context.Registry.GetService<INameService>();
			context.Logger.Debug("Building VTables & identifier list...");
			foreach (IDnlibDef def in parameters.Targets.WithProgress(context.Logger)) {
				ParseParameters(def, context, service, parameters);

				if (def is ModuleDef) {
					var module = (ModuleDef)def;
					foreach (Resource res in module.Resources)
						service.SetOriginalName(res, res.Name);
				}
				else
					service.SetOriginalName(def, def.Name);

				if (def is TypeDef) {
					service.GetVTables().GetVTable((TypeDef)def);
					service.SetOriginalNamespace(def, ((TypeDef)def).Namespace);
				}
				context.CheckCancellation();
			}

			context.Logger.Debug("Analyzing...");
			RegisterRenamers(context, service);
			IList<IRenamer> renamers = service.Renamers;
			foreach (IDnlibDef def in parameters.Targets.WithProgress(context.Logger)) {
				Analyze(service, context, parameters, def, true);
				context.CheckCancellation();
			}
		}

		void RegisterRenamers(ConfuserContext context, NameService service) {
			bool wpf = false,
			     caliburn = false,
			     winforms = false,
			     json = false;

			foreach (var module in context.Modules)
				foreach (var asmRef in module.GetAssemblyRefs()) {
					if (asmRef.Name == "WindowsBase" || asmRef.Name == "PresentationCore" ||
					    asmRef.Name == "PresentationFramework" || asmRef.Name == "System.Xaml") {
						wpf = true;
					}
					else if (asmRef.Name == "Caliburn.Micro") {
						caliburn = true;
					}
					else if (asmRef.Name == "System.Windows.Forms") {
						winforms = true;
					}
					else if (asmRef.Name == "Newtonsoft.Json") {
						json = true;
					}
				}

			if (wpf) {
				var wpfAnalyzer = new WPFAnalyzer();
				context.Logger.Debug("WPF found, enabling compatibility.");
				service.Renamers.Add(wpfAnalyzer);
				if (caliburn) {
					context.Logger.Debug("Caliburn.Micro found, enabling compatibility.");
					service.Renamers.Add(new CaliburnAnalyzer(wpfAnalyzer));
				}
			}

			if (winforms) {
				var winformsAnalyzer = new WinFormsAnalyzer();
				context.Logger.Debug("WinForms found, enabling compatibility.");
				service.Renamers.Add(winformsAnalyzer);
			}

			if (json) {
				var jsonAnalyzer = new JsonAnalyzer();
				context.Logger.Debug("Newtonsoft.Json found, enabling compatibility.");
				service.Renamers.Add(jsonAnalyzer);
			}
		}

		internal void Analyze(NameService service, ConfuserContext context, ProtectionParameters parameters, IDnlibDef def, bool runAnalyzer) {
			if (def is TypeDef)
				Analyze(service, context, parameters, (TypeDef)def);
			else if (def is MethodDef)
				Analyze(service, context, parameters, (MethodDef)def);
			else if (def is FieldDef)
				Analyze(service, context, parameters, (FieldDef)def);
			else if (def is PropertyDef)
				Analyze(service, context, parameters, (PropertyDef)def);
			else if (def is EventDef)
				Analyze(service, context, parameters, (EventDef)def);
			else if (def is ModuleDef) {
				var pass = parameters.GetParameter<string>(context, def, "password", null);
				if (pass != null)
					service.reversibleRenamer = new ReversibleRenamer(pass);

				var idOffset = parameters.GetParameter<uint>(context, def, "idOffset", 0);
				if (idOffset != 0)
					service.SetNameId(idOffset);

				service.SetCanRename(def, false);
			}

			if (!runAnalyzer || parameters.GetParameter(context, def, "forceRen", false))
				return;

			foreach (IRenamer renamer in service.Renamers)
				renamer.Analyze(context, service, parameters, def);
		}

		static bool IsVisibleOutside(ConfuserContext context, ProtectionParameters parameters, IMemberDef def) {
			var type = def as TypeDef;
			if (type == null)
				type = def.DeclaringType;

			var renPublic = parameters.GetParameter<bool?>(context, def, "renPublic", null);
			if (renPublic == null)
				return type.IsVisibleOutside();
			else
				return type.IsVisibleOutside(false) && !renPublic.Value;
		}

		void Analyze(NameService service, ConfuserContext context, ProtectionParameters parameters, TypeDef type) {
			if (IsVisibleOutside(context, parameters, type)) {
				service.SetCanRename(type, false);
			}
			else if (type.IsRuntimeSpecialName || type.IsGlobalModuleType) {
				service.SetCanRename(type, false);
			}
			else if (type.FullName == "ConfusedByAttribute") {
				// Courtesy
				service.SetCanRename(type, false);
			}

			if (parameters.GetParameter(context, type, "forceRen", false))
				return;

			if (type.InheritsFromCorlib("System.Attribute")) {
				service.ReduceRenameMode(type, RenameMode.ASCII);
			}

			if (type.InheritsFrom("System.Configuration.SettingsBase")) {
				service.SetCanRename(type, false);
			}
		}

		void Analyze(NameService service, ConfuserContext context, ProtectionParameters parameters, MethodDef method) {
			if (IsVisibleOutside(context, parameters, method.DeclaringType) &&
			    (method.IsFamily || method.IsFamilyOrAssembly || method.IsPublic) &&
			    IsVisibleOutside(context, parameters, method))
				service.SetCanRename(method, false);

			else if (method.IsRuntimeSpecialName)
				service.SetCanRename(method, false);

			else if (parameters.GetParameter(context, method, "forceRen", false))
				return;

			else if (method.DeclaringType.IsComImport() && !method.HasAttribute("System.Runtime.InteropServices.DispIdAttribute"))
				service.SetCanRename(method, false);

			else if (method.DeclaringType.IsDelegate())
				service.SetCanRename(method, false);
		}

		void Analyze(NameService service, ConfuserContext context, ProtectionParameters parameters, FieldDef field) {
			if (IsVisibleOutside(context, parameters, field.DeclaringType) &&
			    (field.IsFamily || field.IsFamilyOrAssembly || field.IsPublic) &&
			    IsVisibleOutside(context, parameters, field))
				service.SetCanRename(field, false);

			else if (field.IsRuntimeSpecialName)
				service.SetCanRename(field, false);

			else if (parameters.GetParameter(context, field, "forceRen", false))
				return;

			else if (field.DeclaringType.IsSerializable && !field.IsNotSerialized)
				service.SetCanRename(field, false);

			else if (field.IsLiteral && field.DeclaringType.IsEnum &&
				!parameters.GetParameter(context, field, "renEnum", false))
				service.SetCanRename(field, false);
		}

		void Analyze(NameService service, ConfuserContext context, ProtectionParameters parameters, PropertyDef property) {
			if (IsVisibleOutside(context, parameters, property.DeclaringType) &&
			    IsVisibleOutside(context, parameters, property))
				service.SetCanRename(property, false);

			else if (property.IsRuntimeSpecialName)
				service.SetCanRename(property, false);

			else if (parameters.GetParameter(context, property, "forceRen", false))
				return;

			else if (property.DeclaringType.Implements("System.ComponentModel.INotifyPropertyChanged"))
				service.SetCanRename(property, false);

			else if (property.DeclaringType.Name.String.Contains("AnonymousType"))
				service.SetCanRename(property, false);
		}

		void Analyze(NameService service, ConfuserContext context, ProtectionParameters parameters, EventDef evt) {
			if (IsVisibleOutside(context, parameters, evt.DeclaringType) &&
			    IsVisibleOutside(context, parameters, evt))
				service.SetCanRename(evt, false);

			else if (evt.IsRuntimeSpecialName)
				service.SetCanRename(evt, false);
		}
	}
}


================================================
File: Confuser.Renamer/Confuser.Renamer.csproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProductVersion>8.0.30703</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{862DA0DA-52E1-47CD-B9C2-46B106031B28}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>Confuser.Renamer</RootNamespace>
    <AssemblyName>Confuser.Renamer</AssemblyName>
    <TargetFrameworkVersion Condition=" !$(DefineConstants.Contains('NET45')) ">v4.0</TargetFrameworkVersion>
    <TargetFrameworkVersion Condition=" $(DefineConstants.Contains('NET45')) ">v4.5</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <TargetFrameworkProfile />
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>..\Debug\bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>..\Release\bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup>
    <SignAssembly>true</SignAssembly>
  </PropertyGroup>
  <PropertyGroup>
    <AssemblyOriginatorKeyFile>..\ConfuserEx.snk</AssemblyOriginatorKeyFile>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml" />
    <Reference Include="WindowsBase" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="..\GlobalAssemblyInfo.cs">
      <Link>Properties\GlobalAssemblyInfo.cs</Link>
    </Compile>
    <Compile Include="AnalyzePhase.cs" />
    <Compile Include="Analyzers\CaliburnAnalyzer.cs" />
    <Compile Include="Analyzers\InterReferenceAnalyzer.cs" />
    <Compile Include="Analyzers\JsonAnalyzer.cs" />
    <Compile Include="Analyzers\LdtokenEnumAnalyzer.cs" />
    <Compile Include="Analyzers\ResourceAnalyzer.cs" />
    <Compile Include="Analyzers\TypeBlobAnalyzer.cs" />
    <Compile Include="Analyzers\VTableAnalyzer.cs" />
    <Compile Include="Analyzers\WinFormsAnalyzer.cs" />
    <Compile Include="Analyzers\WPFAnalyzer.cs" />
    <Compile Include="BAML\BAMLAnalyzer.cs" />
    <Compile Include="BAML\BamlDocument.cs" />
    <Compile Include="BAML\BamlElement.cs" />
    <Compile Include="BAML\BAMLPropertyReference.cs" />
    <Compile Include="BAML\BamlRecords.cs" />
    <Compile Include="BAML\BamlRW.cs" />
    <Compile Include="BAML\BAMLStringReference.cs" />
    <Compile Include="BAML\IBAMLReference.cs" />
    <Compile Include="BAML\KnownThingsv4.cs" />
    <Compile Include="BAML\IKnownThings.cs" />
    <Compile Include="BAML\KnownThingsv3.cs" />
    <Compile Include="BAML\PropertyPath.cs" />
    <Compile Include="GenericArgumentResolver.cs" />
    <Compile Include="PostRenamePhase.cs" />
    <Compile Include="IRenamer.cs" />
    <Compile Include="NameProtection.cs" />
    <Compile Include="INameReference.cs" />
    <Compile Include="NameService.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="References\BAMLEnumReference.cs" />
    <Compile Include="References\BAMLPathTypeReference.cs" />
    <Compile Include="References\BAMLTypeReference.cs" />
    <Compile Include="References\CAMemberReference.cs" />
    <Compile Include="References\BAMLAttributeReference.cs" />
    <Compile Include="References\BAMLConverterTypeReference.cs" />
    <Compile Include="References\BAMLConverterMemberReference.cs" />
    <Compile Include="References\StringTypeReference.cs" />
    <Compile Include="References\TypeRefReference.cs" />
    <Compile Include="References\OverrideDirectiveReference.cs" />
    <Compile Include="References\MemberRefReference.cs" />
    <Compile Include="References\ResourceReference.cs" />
    <Compile Include="RenameMode.cs" />
    <Compile Include="RenamePhase.cs" />
    <Compile Include="ReversibleRenamer.cs" />
    <Compile Include="RickRoller.cs" />
    <Compile Include="VTable.cs" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\Confuser.Core\Confuser.Core.csproj">
      <Project>{BEB67A6E-4C54-4DE5-8C6B-2C12F44A7B92}</Project>
      <Name>Confuser.Core</Name>
    </ProjectReference>
    <ProjectReference Include="..\dnlib\src\dnlib.csproj">
      <Project>{FDFC1237-143F-4919-8318-4926901F4639}</Project>
      <Name>dnlib</Name>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup>
    <None Include="..\ConfuserEx.snk">
      <Link>Properties\ConfuserEx.snk</Link>
    </None>
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>


================================================
File: Confuser.Renamer/GenericArgumentResolver.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using dnlib.DotNet;

namespace Confuser.Renamer {
	/// <summary>
	///     Resolves generic arguments
	/// </summary>
	public struct GenericArgumentResolver {
		GenericArguments genericArguments;
		RecursionCounter recursionCounter;

		/// <summary>
		///     Resolves the type signature with the specified generic arguments.
		/// </summary>
		/// <param name="typeSig">The type signature.</param>
		/// <param name="typeGenArgs">The type generic arguments.</param>
		/// <returns>Resolved type signature.</returns>
		/// <exception cref="System.ArgumentException">No generic arguments to resolve.</exception>
		public static TypeSig Resolve(TypeSig typeSig, IList<TypeSig> typeGenArgs) {
			if (typeGenArgs == null)
				throw new ArgumentException("No generic arguments to resolve.");

			var resolver = new GenericArgumentResolver();
			resolver.genericArguments = new GenericArguments();
			resolver.recursionCounter = new RecursionCounter();

			if (typeGenArgs != null)
				resolver.genericArguments.PushTypeArgs(typeGenArgs);

			return resolver.ResolveGenericArgs(typeSig);
		}

		/// <summary>
		///     Resolves the method signature with the specified generic arguments.
		/// </summary>
		/// <param name="methodSig">The method signature.</param>
		/// <param name="typeGenArgs">The type generic arguments.</param>
		/// <returns>Resolved method signature.</returns>
		/// <exception cref="System.ArgumentException">No generic arguments to resolve.</exception>
		public static MethodSig Resolve(MethodSig methodSig, IList<TypeSig> typeGenArgs) {
			if (typeGenArgs == null)
				throw new ArgumentException("No generic arguments to resolve.");

			var resolver = new GenericArgumentResolver();
			resolver.genericArguments = new GenericArguments();
			resolver.recursionCounter = new RecursionCounter();

			if (typeGenArgs != null)
				resolver.genericArguments.PushTypeArgs(typeGenArgs);

			return resolver.ResolveGenericArgs(methodSig);
		}

		bool ReplaceGenericArg(ref TypeSig typeSig) {
			if (genericArguments == null)
				return false;
			TypeSig newTypeSig = genericArguments.Resolve(typeSig);
			if (newTypeSig != typeSig) {
				typeSig = newTypeSig;
				return true;
			}
			return false;
		}

		MethodSig ResolveGenericArgs(MethodSig sig) {
			if (sig == null)
				return null;
			if (!recursionCounter.Increment())
				return null;

			MethodSig result = ResolveGenericArgs(new MethodSig(sig.GetCallingConvention()), sig);

			recursionCounter.Decrement();
			return result;
		}

		MethodSig ResolveGenericArgs(MethodSig sig, MethodSig old) {
			sig.RetType = ResolveGenericArgs(old.RetType);
			foreach (TypeSig p in old.Params)
				sig.Params.Add(ResolveGenericArgs(p));
			sig.GenParamCount = old.GenParamCount;
			if (sig.ParamsAfterSentinel != null) {
				foreach (TypeSig p in old.ParamsAfterSentinel)
					sig.ParamsAfterSentinel.Add(ResolveGenericArgs(p));
			}
			return sig;
		}

		TypeSig ResolveGenericArgs(TypeSig typeSig) {
			if (!recursionCounter.Increment())
				return null;

			if (ReplaceGenericArg(ref typeSig)) {
				recursionCounter.Decrement();
				return typeSig;
			}

			TypeSig result;
			switch (typeSig.ElementType) {
				case ElementType.Ptr:
					result = new PtrSig(ResolveGenericArgs(typeSig.Next));
					break;
				case ElementType.ByRef:
					result = new ByRefSig(ResolveGenericArgs(typeSig.Next));
					break;
				case ElementType.Var:
					result = new GenericVar((typeSig as GenericVar).Number);
					break;
				case ElementType.ValueArray:
					result = new ValueArraySig(ResolveGenericArgs(typeSig.Next), (typeSig as ValueArraySig).Size);
					break;
				case ElementType.SZArray:
					result = new SZArraySig(ResolveGenericArgs(typeSig.Next));
					break;
				case ElementType.MVar:
					result = new GenericMVar((typeSig as GenericMVar).Number);
					break;
				case ElementType.CModReqd:
					result = new CModReqdSig((typeSig as ModifierSig).Modifier, ResolveGenericArgs(typeSig.Next));
					break;
				case ElementType.CModOpt:
					result = new CModOptSig((typeSig as ModifierSig).Modifier, ResolveGenericArgs(typeSig.Next));
					break;
				case ElementType.Module:
					result = new ModuleSig((typeSig as ModuleSig).Index, ResolveGenericArgs(typeSig.Next));
					break;
				case ElementType.Pinned:
					result = new PinnedSig(ResolveGenericArgs(typeSig.Next));
					break;
				case ElementType.FnPtr:
					throw new NotSupportedException("FnPtr is not supported.");

				case ElementType.Array:
					var arraySig = (ArraySig)typeSig;
					var sizes = new List<uint>(arraySig.Sizes);
					var lbounds = new List<int>(arraySig.LowerBounds);
					result = new ArraySig(ResolveGenericArgs(typeSig.Next), arraySig.Rank, sizes, lbounds);
					break;
				case ElementType.GenericInst:
					var gis = (GenericInstSig)typeSig;
					var genArgs = new List<TypeSig>(gis.GenericArguments.Count);
					foreach (TypeSig ga in gis.GenericArguments) {
						genArgs.Add(ResolveGenericArgs(ga));
					}
					result = new GenericInstSig(ResolveGenericArgs(gis.GenericType) as ClassOrValueTypeSig, genArgs);
					break;

				default:
					result = typeSig;
					break;
			}

			recursionCounter.Decrement();

			return result;
		}
	}
}


================================================
File: Confuser.Renamer/INameReference.cs
================================================
ï»¿using System;
using Confuser.Core;

namespace Confuser.Renamer {
	public interface INameReference {
		bool UpdateNameReference(ConfuserContext context, INameService service);

		bool ShouldCancelRename();
	}

	public interface INameReference<out T> : INameReference { }
}


================================================
File: Confuser.Renamer/IRenamer.cs
================================================
ï»¿using System;
using Confuser.Core;
using dnlib.DotNet;

namespace Confuser.Renamer {
	public interface IRenamer {
		void Analyze(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def);
		void PreRename(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def);
		void PostRename(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def);
	}
}


================================================
File: Confuser.Renamer/NameProtection.cs
================================================
ï»¿using System;
using System.IO;
using Confuser.Core;

namespace Confuser.Renamer {
	internal class NameProtection : Protection {
		public const string _Id = "rename";
		public const string _FullId = "Ki.Rename";
		public const string _ServiceId = "Ki.Rename";

		public override string Name {
			get { return "Name Protection"; }
		}

		public override string Description {
			get { return "This protection obfuscate the symbols' name so the decompiled source code can neither be compiled nor read."; }
		}

		public override string Id {
			get { return _Id; }
		}

		public override string FullId {
			get { return _FullId; }
		}

		public override ProtectionPreset Preset {
			get { return ProtectionPreset.Minimum; }
		}

		protected override void Initialize(ConfuserContext context) {
			context.Registry.RegisterService(_ServiceId, typeof(INameService), new NameService(context));
		}

		protected override void PopulatePipeline(ProtectionPipeline pipeline) {
			pipeline.InsertPostStage(PipelineStage.Inspection, new AnalyzePhase(this));
			pipeline.InsertPostStage(PipelineStage.BeginModule, new RenamePhase(this));
			pipeline.InsertPreStage(PipelineStage.EndModule, new PostRenamePhase(this));
			pipeline.InsertPostStage(PipelineStage.SaveModules, new ExportMapPhase(this));
		}

		class ExportMapPhase : ProtectionPhase {
			public ExportMapPhase(NameProtection parent)
				: base(parent) { }

			public override ProtectionTargets Targets {
				get { return ProtectionTargets.Modules; }
			}

			public override string Name {
				get { return "Export symbol map"; }
			}

			public override bool ProcessAll {
				get { return true; }
			}

			protected override void Execute(ConfuserContext context, ProtectionParameters parameters) {
				var srv = (NameService)context.Registry.GetService<INameService>();
				var map = srv.GetNameMap();
				if (map.Count == 0)
					return;

				string path = Path.GetFullPath(Path.Combine(context.OutputDirectory, "symbols.map"));
				string dir = Path.GetDirectoryName(path);
				if (!Directory.Exists(dir))
					Directory.CreateDirectory(dir);

				using (var writer = new StreamWriter(File.OpenWrite(path))) {
					foreach (var entry in map)
						writer.WriteLine("{0}\t{1}", entry.Key, entry.Value);
				}
			}
		}
	}
}


================================================
File: Confuser.Renamer/NameService.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Confuser.Core;
using Confuser.Core.Services;
using Confuser.Renamer.Analyzers;
using dnlib.DotNet;

namespace Confuser.Renamer {
	public interface INameService {
		VTableStorage GetVTables();

		void Analyze(IDnlibDef def);

		bool CanRename(object obj);
		void SetCanRename(object obj, bool val);

		void SetParam(IDnlibDef def, string name, string value);
		string GetParam(IDnlibDef def, string name);

		RenameMode GetRenameMode(object obj);
		void SetRenameMode(object obj, RenameMode val);
		void ReduceRenameMode(object obj, RenameMode val);

		string ObfuscateName(string name, RenameMode mode);
		string RandomName();
		string RandomName(RenameMode mode);

		void RegisterRenamer(IRenamer renamer);
		T FindRenamer<T>();
		void AddReference<T>(T obj, INameReference<T> reference);

		void SetOriginalName(object obj, string name);
		void SetOriginalNamespace(object obj, string ns);

		void MarkHelper(IDnlibDef def, IMarkerService marker, ConfuserComponent parentComp);
	}

	internal class NameService : INameService {
		static readonly object CanRenameKey = new object();
		static readonly object RenameModeKey = new object();
		static readonly object ReferencesKey = new object();
		static readonly object OriginalNameKey = new object();
		static readonly object OriginalNamespaceKey = new object();

		readonly ConfuserContext context;
		readonly byte[] nameSeed;
		readonly RandomGenerator random;
		readonly VTableStorage storage;
		AnalyzePhase analyze;

		readonly HashSet<string> identifiers = new HashSet<string>();
		readonly byte[] nameId = new byte[8];
		readonly Dictionary<string, string> nameMap1 = new Dictionary<string, string>();
		readonly Dictionary<string, string> nameMap2 = new Dictionary<string, string>();
		internal ReversibleRenamer reversibleRenamer;

		public NameService(ConfuserContext context) {
			this.context = context;
			storage = new VTableStorage(context.Logger);
			random = context.Registry.GetService<IRandomService>().GetRandomGenerator(NameProtection._FullId);
			nameSeed = random.NextBytes(20);

			Renamers = new List<IRenamer> {
				new InterReferenceAnalyzer(),
				new VTableAnalyzer(),
				new TypeBlobAnalyzer(),
				new ResourceAnalyzer(),
				new LdtokenEnumAnalyzer()
			};
		}

		public IList<IRenamer> Renamers { get; private set; }

		public VTableStorage GetVTables() {
			return storage;
		}

		public bool CanRename(object obj) {
			if (obj is IDnlibDef) {
				if (analyze == null)
					analyze = context.Pipeline.FindPhase<AnalyzePhase>();

				var prot = (NameProtection)analyze.Parent;
				ProtectionSettings parameters = ProtectionParameters.GetParameters(context, (IDnlibDef)obj);
				if (parameters == null || !parameters.ContainsKey(prot))
					return false;
				return context.Annotations.Get(obj, CanRenameKey, true);
			}
			return false;
		}

		public void SetCanRename(object obj, bool val) {
			context.Annotations.Set(obj, CanRenameKey, val);
		}

		public void SetParam(IDnlibDef def, string name, string value) {
			var param = ProtectionParameters.GetParameters(context, def);
			if (param == null)
				ProtectionParameters.SetParameters(context, def, param = new ProtectionSettings());
			Dictionary<string, string> nameParam;
			if (!param.TryGetValue(analyze.Parent, out nameParam))
				param[analyze.Parent] = nameParam = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
			nameParam[name] = value;
		}

		public string GetParam(IDnlibDef def, string name) {
			var param = ProtectionParameters.GetParameters(context, def);
			if (param == null)
				return null;
			Dictionary<string, string> nameParam;
			if (!param.TryGetValue(analyze.Parent, out nameParam))
				return null;
			return nameParam.GetValueOrDefault(name);
		}

		public RenameMode GetRenameMode(object obj) {
			return context.Annotations.Get(obj, RenameModeKey, RenameMode.Unicode);
		}

		public void SetRenameMode(object obj, RenameMode val) {
			context.Annotations.Set(obj, RenameModeKey, val);
		}

		public void ReduceRenameMode(object obj, RenameMode val) {
			RenameMode original = GetRenameMode(obj);
			if (original < val)
				context.Annotations.Set(obj, RenameModeKey, val);
		}

		public void AddReference<T>(T obj, INameReference<T> reference) {
			context.Annotations.GetOrCreate(obj, ReferencesKey, key => new List<INameReference>()).Add(reference);
		}

		public void Analyze(IDnlibDef def) {
			if (analyze == null)
				analyze = context.Pipeline.FindPhase<AnalyzePhase>();

			SetOriginalName(def, def.Name);
			if (def is TypeDef) {
				GetVTables().GetVTable((TypeDef)def);
				SetOriginalNamespace(def, ((TypeDef)def).Namespace);
			}
			analyze.Analyze(this, context, ProtectionParameters.Empty, def, true);
		}

		public void SetNameId(uint id) {
			for (int i = nameId.Length - 1; i >= 0; i--) {
				nameId[i] = (byte)(id & 0xff);
				id >>= 8;
			}
		}

		void IncrementNameId() {
			for (int i = nameId.Length - 1; i >= 0; i--) {
				nameId[i]++;
				if (nameId[i] != 0)
					break;
			}
		}

		string ObfuscateNameInternal(byte[] hash, RenameMode mode) {
			switch (mode) {
				case RenameMode.Empty:
					return "";
				case RenameMode.Unicode:
					return Utils.EncodeString(hash, unicodeCharset) + "\u202e";
				case RenameMode.Letters:
					return Utils.EncodeString(hash, letterCharset);
				case RenameMode.ASCII:
					return Utils.EncodeString(hash, asciiCharset);
				case RenameMode.Decodable:
					IncrementNameId();
					return "_" + Utils.EncodeString(hash, alphaNumCharset);
				case RenameMode.Sequential:
					IncrementNameId();
					return "_" + Utils.EncodeString(nameId, alphaNumCharset);
				default:

					throw new NotSupportedException("Rename mode '" + mode + "' is not supported.");
			}
		}

		string ParseGenericName(string name, out int? count) {
			if (name.LastIndexOf('`') != -1) {
				int index = name.LastIndexOf('`');
				int c;
				if (int.TryParse(name.Substring(index + 1), out c)) {
					count = c;
					return name.Substring(0, index);
				}
			}
			count = null;
			return name;
		}

		string MakeGenericName(string name, int? count) {
			if (count == null)
				return name;
			else
				return string.Format("{0}`{1}", name, count.Value);
		}

		public string ObfuscateName(string name, RenameMode mode) {
			string newName = null;
			int? count;
			name = ParseGenericName(name, out count);

			if (string.IsNullOrEmpty(name))
				return string.Empty;

			if (mode == RenameMode.Empty)
				return "";
			if (mode == RenameMode.Debug)
				return "_" + name;
			if (mode == RenameMode.Reversible) {
				if (reversibleRenamer == null)
					throw new ArgumentException("Password not provided for reversible renaming.");
				newName = reversibleRenamer.Encrypt(name);
				return MakeGenericName(newName, count);
			}

			if (nameMap1.ContainsKey(name))
				return nameMap1[name];

			byte[] hash = Utils.Xor(Utils.SHA1(Encoding.UTF8.GetBytes(name)), nameSeed);
			for (int i = 0; i < 100; i++) {
				newName = ObfuscateNameInternal(hash, mode);
				if (!identifiers.Contains(MakeGenericName(newName, count)))
					break;
				hash = Utils.SHA1(hash);
			}

			if ((mode & RenameMode.Decodable) != 0) {
				nameMap2[newName] = name;
				nameMap1[name] = newName;
			}

			return MakeGenericName(newName, count);
		}

		public string RandomName() {
			return RandomName(RenameMode.Unicode);
		}

		public string RandomName(RenameMode mode) {
			return ObfuscateName(Utils.ToHexString(random.NextBytes(16)), mode);
		}

		public void SetOriginalName(object obj, string name) {
			identifiers.Add(name);
			context.Annotations.Set(obj, OriginalNameKey, name);
		}

		public void SetOriginalNamespace(object obj, string ns) {
			identifiers.Add(ns);
			context.Annotations.Set(obj, OriginalNamespaceKey, ns);
		}

		public void RegisterRenamer(IRenamer renamer) {
			Renamers.Add(renamer);
		}

		public T FindRenamer<T>() {
			return Renamers.OfType<T>().Single();
		}

		public void MarkHelper(IDnlibDef def, IMarkerService marker, ConfuserComponent parentComp) {
			if (marker.IsMarked(def))
				return;
			if (def is MethodDef) {
				var method = (MethodDef)def;
				method.Access = MethodAttributes.Assembly;
				if (!method.IsSpecialName && !method.IsRuntimeSpecialName && !method.DeclaringType.IsDelegate())
					method.Name = RandomName();
			}
			else if (def is FieldDef) {
				var field = (FieldDef)def;
				field.Access = FieldAttributes.Assembly;
				if (!field.IsSpecialName && !field.IsRuntimeSpecialName)
					field.Name = RandomName();
			}
			else if (def is TypeDef) {
				var type = (TypeDef)def;
				type.Visibility = type.DeclaringType == null ? TypeAttributes.NotPublic : TypeAttributes.NestedAssembly;
				type.Namespace = "";
				if (!type.IsSpecialName && !type.IsRuntimeSpecialName)
					type.Name = RandomName();
			}
			SetCanRename(def, false);
			Analyze(def);
			marker.Mark(def, parentComp);
		}

		#region Charsets

		static readonly char[] asciiCharset = Enumerable.Range(32, 95)
		                                                .Select(ord => (char)ord)
		                                                .Except(new[] { '.' })
		                                                .ToArray();

		static readonly char[] letterCharset = Enumerable.Range(0, 26)
		                                                 .SelectMany(ord => new[] { (char)('a' + ord), (char)('A' + ord) })
		                                                 .ToArray();

		static readonly char[] alphaNumCharset = Enumerable.Range(0, 26)
		                                                   .SelectMany(ord => new[] { (char)('a' + ord), (char)('A' + ord) })
		                                                   .Concat(Enumerable.Range(0, 10).Select(ord => (char)('0' + ord)))
		                                                   .ToArray();

		// Especially chosen, just to mess with people.
		// Inspired by: http://xkcd.com/1137/ :D
		static readonly char[] unicodeCharset = new char[] { }
			.Concat(Enumerable.Range(0x200b, 5).Select(ord => (char)ord))
			.Concat(Enumerable.Range(0x2029, 6).Select(ord => (char)ord))
			.Concat(Enumerable.Range(0x206a, 6).Select(ord => (char)ord))
			.Except(new[] { '\u2029' })
			.ToArray();

		#endregion

		public RandomGenerator GetRandom() {
			return random;
		}

		public IList<INameReference> GetReferences(object obj) {
			return context.Annotations.GetLazy(obj, ReferencesKey, key => new List<INameReference>());
		}

		public string GetOriginalName(object obj) {
			return context.Annotations.Get(obj, OriginalNameKey, "");
		}

		public string GetOriginalNamespace(object obj) {
			return context.Annotations.Get(obj, OriginalNamespaceKey, "");
		}

		public ICollection<KeyValuePair<string, string>> GetNameMap() {
			return nameMap2;
		}
	}
}


================================================
File: Confuser.Renamer/PostRenamePhase.cs
================================================
ï»¿using System;
using Confuser.Core;
using dnlib.DotNet;

namespace Confuser.Renamer {
	internal class PostRenamePhase : ProtectionPhase {
		public PostRenamePhase(NameProtection parent)
			: base(parent) { }

		public override bool ProcessAll {
			get { return true; }
		}

		public override ProtectionTargets Targets {
			get { return ProtectionTargets.AllDefinitions; }
		}

		public override string Name {
			get { return "Post-renaming"; }
		}

		protected override void Execute(ConfuserContext context, ProtectionParameters parameters) {
			var service = (NameService)context.Registry.GetService<INameService>();

			foreach (IRenamer renamer in service.Renamers) {
				foreach (IDnlibDef def in parameters.Targets)
					renamer.PostRename(context, service, parameters, def);
				context.CheckCancellation();
			}
		}
	}
}


================================================
File: Confuser.Renamer/RenameMode.cs
================================================
ï»¿using System;

namespace Confuser.Renamer {
	public enum RenameMode {
		Empty = 0x0,
		Unicode = 0x1,
		ASCII = 0x2,
		Letters = 0x3,

		Decodable = 0x10,
		Sequential = 0x11,
		Reversible = 0x12,

		Debug = 0x20
	}
}


================================================
File: Confuser.Renamer/RenamePhase.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using Confuser.Core;
using dnlib.DotNet;

namespace Confuser.Renamer {
	internal class RenamePhase : ProtectionPhase {
		public RenamePhase(NameProtection parent)
			: base(parent) { }

		public override ProtectionTargets Targets {
			get { return ProtectionTargets.AllDefinitions; }
		}

		public override string Name {
			get { return "Renaming"; }
		}

		protected override void Execute(ConfuserContext context, ProtectionParameters parameters) {
			var service = (NameService)context.Registry.GetService<INameService>();

			context.Logger.Debug("Renaming...");
			foreach (IRenamer renamer in service.Renamers) {
				foreach (IDnlibDef def in parameters.Targets)
					renamer.PreRename(context, service, parameters, def);
				context.CheckCancellation();
			}

			var targets = parameters.Targets.ToList();
			service.GetRandom().Shuffle(targets);
			var pdbDocs = new HashSet<string>();
			foreach (IDnlibDef def in targets.WithProgress(context.Logger)) {
				if (def is ModuleDef && parameters.GetParameter(context, def, "rickroll", false))
					RickRoller.CommenceRickroll(context, (ModuleDef)def);

				bool canRename = service.CanRename(def);
				RenameMode mode = service.GetRenameMode(def);

				if (def is MethodDef) {
					var method = (MethodDef)def;
					if ((canRename || method.IsConstructor) && parameters.GetParameter(context, def, "renameArgs", true)) {
						foreach (ParamDef param in ((MethodDef)def).ParamDefs)
							param.Name = null;
					}

					if (parameters.GetParameter(context, def, "renPdb", false) && method.HasBody) {
						foreach (var instr in method.Body.Instructions) {
							if (instr.SequencePoint != null && !pdbDocs.Contains(instr.SequencePoint.Document.Url)) {
								instr.SequencePoint.Document.Url = service.ObfuscateName(instr.SequencePoint.Document.Url, mode);
								pdbDocs.Add(instr.SequencePoint.Document.Url);
							}
						}
						foreach (var local in method.Body.Variables) {
							if (!string.IsNullOrEmpty(local.Name))
								local.Name = service.ObfuscateName(local.Name, mode);
						}
						method.Body.Scope = null;
					}
				}

				if (!canRename)
					continue;

				IList<INameReference> references = service.GetReferences(def);
				bool cancel = false;
				foreach (INameReference refer in references) {
					cancel |= refer.ShouldCancelRename();
					if (cancel) break;
				}
				if (cancel)
					continue;

				if (def is TypeDef) {
					var typeDef = (TypeDef)def;
					if (parameters.GetParameter(context, def, "flatten", true)) {
						typeDef.Name = service.ObfuscateName(typeDef.FullName, mode);
						typeDef.Namespace = "";
					}
					else {
						typeDef.Namespace = service.ObfuscateName(typeDef.Namespace, mode);
						typeDef.Name = service.ObfuscateName(typeDef.Name, mode);
					}
					foreach (var param in typeDef.GenericParameters)
						param.Name = ((char)(param.Number + 1)).ToString();
				}
				else if (def is MethodDef) {
					foreach (var param in ((MethodDef)def).GenericParameters)
						param.Name = ((char)(param.Number + 1)).ToString();

					def.Name = service.ObfuscateName(def.Name, mode);
				}
				else
					def.Name = service.ObfuscateName(def.Name, mode);

				foreach (INameReference refer in references.ToList()) {
					if (!refer.UpdateNameReference(context, service)) {
						context.Logger.ErrorFormat("Failed to update name reference on '{0}'.", def);
						throw new ConfuserException(null);
					}
				}
				context.CheckCancellation();
			}
		}
	}
}


================================================
File: Confuser.Renamer/ReversibleRenamer.cs
================================================
ï»¿using System;
using System.IO;
using System.Security.Cryptography;
using System.Text;

namespace Confuser.Renamer {
	public class ReversibleRenamer {
		RijndaelManaged cipher;
		byte[] key;

		public ReversibleRenamer(string password) {
			cipher = new RijndaelManaged();
			using (var sha = SHA256.Create())
				cipher.Key = key = sha.ComputeHash(Encoding.UTF8.GetBytes(password));
		}

		static string Base64Encode(byte[] buf) {
			return Convert.ToBase64String(buf).Trim('=').Replace('+', '$').Replace('/', '_');
		}

		static byte[] Base64Decode(string str) {
			str = str.Replace('$', '+').Replace('_', '/').PadRight((str.Length + 3) & ~3, '=');
			return Convert.FromBase64String(str);
		}

		byte[] GetIV(byte ivId) {
			byte[] iv = new byte[cipher.BlockSize / 8];
			for (int i = 0; i < iv.Length; i++)
				iv[i] = (byte)(ivId ^ key[i]);
			return iv;
		}

		byte GetIVId(string str) {
			byte x = (byte)str[0];
			for (int i = 1; i < str.Length; i++)
				x = (byte)(x * 3 + (byte)str[i]);
			return x;
		}

		public string Encrypt(string name) {
			byte ivId = GetIVId(name);
			cipher.IV = GetIV(ivId);
			var buf = Encoding.UTF8.GetBytes(name);

			using (var ms = new MemoryStream()) {
				ms.WriteByte(ivId);
				using (var stream = new CryptoStream(ms, cipher.CreateEncryptor(), CryptoStreamMode.Write))
					stream.Write(buf, 0, buf.Length);

				buf = ms.ToArray();
				return Base64Encode(buf);
			}
		}

		public string Decrypt(string name) {
			using (var ms = new MemoryStream(Base64Decode(name))) {
				byte ivId = (byte)ms.ReadByte();
				cipher.IV = GetIV(ivId);

				var result = new MemoryStream();
				using (var stream = new CryptoStream(ms, cipher.CreateDecryptor(), CryptoStreamMode.Read))
					stream.CopyTo(result);

				return Encoding.UTF8.GetString(result.ToArray());
			}
		}
	}
}


================================================
File: Confuser.Renamer/RickRoller.cs
================================================
ï»¿using System;
using System.Linq;
using Confuser.Core;
using Confuser.Core.Services;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Renamer {
	// For my dearest Reflector devs, this is my Christmas present.
	public static class RickRoller {
		const string Injection = "\"onclick=\"return(false);\"style=\"background:#ffffff;cursor:default;position:absolute;display:block;width:10000px;height:10000px;top:0px;left:0px\"><IMG/src=\"#\"onerror=\"REPL\"></A></TABLE><!--";
		const string JS = "window.open(\"http://goo.gl/YroZm\",\"\",\"fullscreen=yes\")";

		static string EscapeScript(string script) {
			return script
				.Replace("&", "&amp;")
				.Replace(" ", "&nbsp;")
				.Replace("\"", "&quot;")
				.Replace("<", "&lt;")
				.Replace("\r", "")
				.Replace("\n", "");
		}


		public static void CommenceRickroll(ConfuserContext context, ModuleDef module) {
			var marker = context.Registry.GetService<IMarkerService>();
			var nameService = context.Registry.GetService<INameService>();
			var injection = Injection.Replace("REPL", EscapeScript(JS));

			var globalType = module.GlobalType;
			var newType = new TypeDefUser(" ", module.CorLibTypes.Object.ToTypeDefOrRef());
			newType.Attributes |= TypeAttributes.NestedPublic;
			globalType.NestedTypes.Add(newType);

			var trap = new MethodDefUser(
				injection,
				MethodSig.CreateStatic(module.CorLibTypes.Void),
				MethodAttributes.Public | MethodAttributes.Static);
			trap.Body = new CilBody();
			trap.Body.Instructions.Add(Instruction.Create(OpCodes.Ret));
			newType.Methods.Add(trap);

			marker.Mark(newType, null);
			marker.Mark(trap, null);
			nameService.SetCanRename(trap, false);

			foreach (var method in module.GetTypes().SelectMany(type => type.Methods)) {
				if (method != trap && method.HasBody)
					method.Body.Instructions.Insert(0, Instruction.Create(OpCodes.Call, trap));
			}
		}
	}
}


================================================
File: Confuser.Renamer/VTable.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using Confuser.Core;
using dnlib.DotNet;
using ILogger = Confuser.Core.ILogger;

namespace Confuser.Renamer {
	public class VTableSignature {
		internal VTableSignature(MethodSig sig, string name) {
			MethodSig = sig;
			Name = name;
		}

		public MethodSig MethodSig { get; private set; }
		public string Name { get; private set; }

		public static VTableSignature FromMethod(IMethod method) {
			MethodSig sig = method.MethodSig;
			TypeSig declType = method.DeclaringType.ToTypeSig();
			if (declType is GenericInstSig) {
				sig = GenericArgumentResolver.Resolve(sig, ((GenericInstSig)declType).GenericArguments);
			}
			return new VTableSignature(sig, method.Name);
		}

		public override bool Equals(object obj) {
			var other = obj as VTableSignature;
			if (other == null)
				return false;
			return new SigComparer().Equals(MethodSig, other.MethodSig) &&
			       Name.Equals(other.Name, StringComparison.Ordinal);
		}

		public override int GetHashCode() {
			int hash = 17;
			hash = hash * 7 + new SigComparer().GetHashCode(MethodSig);
			return hash * 7 + Name.GetHashCode();
		}

		public static bool operator ==(VTableSignature a, VTableSignature b) {
			if (ReferenceEquals(a, b))
				return true;
			if (!Equals(a, null) && Equals(b, null))
				return false;

			return a.Equals(b);
		}

		public static bool operator !=(VTableSignature a, VTableSignature b) {
			return !(a == b);
		}

		public override string ToString() {
			return FullNameCreator.MethodFullName("", Name, MethodSig);
		}
	}

	public class VTableSlot {
		internal VTableSlot(MethodDef def, TypeSig decl, VTableSignature signature)
			: this(def.DeclaringType.ToTypeSig(), def, decl, signature, null) { }

		internal VTableSlot(TypeSig defDeclType, MethodDef def, TypeSig decl, VTableSignature signature, VTableSlot overrides) {
			MethodDefDeclType = defDeclType;
			MethodDef = def;
			DeclaringType = decl;
			Signature = signature;
			Overrides = overrides;
		}

		// This is the type in which this slot is defined.
		public TypeSig DeclaringType { get; internal set; }
		// This is the signature of this slot.
		public VTableSignature Signature { get; internal set; }

		// This is the method that is currently in the slot.
		public TypeSig MethodDefDeclType { get; private set; }
		public MethodDef MethodDef { get; private set; }

		// This is the 'parent slot' that this slot overrides.
		public VTableSlot Overrides { get; private set; }

		public VTableSlot OverridedBy(MethodDef method) {
			return new VTableSlot(method.DeclaringType.ToTypeSig(), method, DeclaringType, Signature, this);
		}

		internal VTableSlot Clone() {
			return new VTableSlot(MethodDefDeclType, MethodDef, DeclaringType, Signature, Overrides);
		}

		public override string ToString() {
			return MethodDef.ToString();
		}
	}

	public class VTable {
		internal VTable(TypeSig type) {
			Type = type;
			Slots = new List<VTableSlot>();
			InterfaceSlots = new Dictionary<TypeSig, IList<VTableSlot>>();
		}

		public TypeSig Type { get; private set; }

		public IList<VTableSlot> Slots { get; private set; }
		public IDictionary<TypeSig, IList<VTableSlot>> InterfaceSlots { get; private set; }

		class VTableConstruction {
			class TypeSigComparer : IEqualityComparer<TypeSig> {
				public bool Equals(TypeSig x, TypeSig y) {
					return new SigComparer().Equals(x, y);
				}

				public int GetHashCode(TypeSig obj) {
					return new SigComparer().GetHashCode(obj);
				}

				public static readonly TypeSigComparer Instance = new TypeSigComparer();
			}

			// All virtual method slots, excluding interfaces
			public List<VTableSlot> AllSlots = new List<VTableSlot>();
			// All visible virtual method slots (i.e. excluded those being shadowed)
			public Dictionary<VTableSignature, VTableSlot> SlotsMap = new Dictionary<VTableSignature, VTableSlot>();
			public Dictionary<TypeSig, Dictionary<VTableSignature, VTableSlot>> InterfaceSlots = new Dictionary<TypeSig, Dictionary<VTableSignature, VTableSlot>>(TypeSigComparer.Instance);
		}

		public IEnumerable<VTableSlot> FindSlots(IMethod method) {
			return Slots
				.Concat(InterfaceSlots.SelectMany(iface => iface.Value))
				.Where(slot => slot.MethodDef == method);
		}

		public static VTable ConstructVTable(TypeDef typeDef, VTableStorage storage) {
			var ret = new VTable(typeDef.ToTypeSig());

			var virtualMethods = typeDef.Methods
			                            .Where(method => method.IsVirtual)
			                            .ToDictionary(
				                            method => VTableSignature.FromMethod(method),
				                            method => method
				);

			// See Partition II 12.2 for implementation algorithm
			VTableConstruction vTbl = new VTableConstruction();

			// Inherits base type's slots
			VTable baseVTbl = storage.GetVTable(typeDef.GetBaseTypeThrow());
			if (baseVTbl != null) {
				Inherits(vTbl, baseVTbl);
			}

			// Explicit interface implementation
			foreach (InterfaceImpl iface in typeDef.Interfaces) {
				VTable ifaceVTbl = storage.GetVTable(iface.Interface);
				if (ifaceVTbl != null) {
					Implements(vTbl, virtualMethods, ifaceVTbl, iface.Interface.ToTypeSig());
				}
			}

			// Normal interface implementation
			if (!typeDef.IsInterface) {
				// Interface methods cannot implements base interface methods.
				foreach (var iface in vTbl.InterfaceSlots.Values) {
					foreach (var entry in iface.ToList()) {
						if (!entry.Value.MethodDef.DeclaringType.IsInterface)
							continue;
						// This is the step 1 of 12.2 algorithm -- find implementation for still empty slots.
						// Note that it seems we should include newslot methods as well, despite what the standard said.
						MethodDef impl;
						VTableSlot implSlot;
						if (virtualMethods.TryGetValue(entry.Key, out impl))
							iface[entry.Key] = entry.Value.OverridedBy(impl);
						else if (vTbl.SlotsMap.TryGetValue(entry.Key, out implSlot))
							iface[entry.Key] = entry.Value.OverridedBy(implSlot.MethodDef);
					}
				}
			}

			// Normal overrides
			foreach (var method in virtualMethods) {
				VTableSlot slot;
				if (method.Value.IsNewSlot) {
					slot = new VTableSlot(method.Value, typeDef.ToTypeSig(), method.Key);
				}
				else {
					if (vTbl.SlotsMap.TryGetValue(method.Key, out slot)) {
						Debug.Assert(!slot.MethodDef.IsFinal);
						slot = slot.OverridedBy(method.Value);
					}
					else
						slot = new VTableSlot(method.Value, typeDef.ToTypeSig(), method.Key);
				}
				vTbl.SlotsMap[method.Key] = slot;
				vTbl.AllSlots.Add(slot);
			}

			// MethodImpls
			foreach (var method in virtualMethods) {
				foreach (var impl in method.Value.Overrides) {
					Debug.Assert(impl.MethodBody == method.Value);

					MethodDef targetMethod = impl.MethodDeclaration.ResolveThrow();
					if (targetMethod.DeclaringType.IsInterface) {
						var iface = impl.MethodDeclaration.DeclaringType.ToTypeSig();
						CheckKeyExist(storage, vTbl.InterfaceSlots, iface, "MethodImpl Iface");
						var ifaceVTbl = vTbl.InterfaceSlots[iface];

						var signature = VTableSignature.FromMethod(impl.MethodDeclaration);
						CheckKeyExist(storage, ifaceVTbl, signature, "MethodImpl Iface Sig");
						var targetSlot = ifaceVTbl[signature];

						// The Overrides of interface slots should directly points to the root interface slot
						while (targetSlot.Overrides != null)
							targetSlot = targetSlot.Overrides;
						Debug.Assert(targetSlot.MethodDef.DeclaringType.IsInterface);
						ifaceVTbl[targetSlot.Signature] = targetSlot.OverridedBy(method.Value);
					}
					else {
						var targetSlot = vTbl.AllSlots.Single(slot => slot.MethodDef == targetMethod);
						CheckKeyExist(storage, vTbl.SlotsMap, targetSlot.Signature, "MethodImpl Normal Sig");
						targetSlot = vTbl.SlotsMap[targetSlot.Signature]; // Use the most derived slot
						// Maybe implemented by above processes --- this process should take priority
						while (targetSlot.MethodDef.DeclaringType == typeDef)
							targetSlot = targetSlot.Overrides;
						vTbl.SlotsMap[targetSlot.Signature] = targetSlot.OverridedBy(method.Value);
					}
				}
			}

			// Populate result V-table
			ret.InterfaceSlots = vTbl.InterfaceSlots.ToDictionary(
				kvp => kvp.Key, kvp => (IList<VTableSlot>)kvp.Value.Values.ToList());

			foreach (var slot in vTbl.AllSlots) {
				ret.Slots.Add(slot);
			}

			return ret;
		}

		static void Implements(VTableConstruction vTbl, Dictionary<VTableSignature, MethodDef> virtualMethods, VTable ifaceVTbl, TypeSig iface) {
			// This is the step 2 of 12.2 algorithm -- use virtual newslot methods for explicit implementation.

			Func<VTableSlot, VTableSlot> implLookup = slot => {
				MethodDef impl;
				if (virtualMethods.TryGetValue(slot.Signature, out impl) &&
				    impl.IsNewSlot && !impl.DeclaringType.IsInterface) {
					// Interface methods cannot implements base interface methods.
					// The Overrides of interface slots should directly points to the root interface slot
					var targetSlot = slot;
					while (targetSlot.Overrides != null && !targetSlot.MethodDef.DeclaringType.IsInterface)
						targetSlot = targetSlot.Overrides;
					Debug.Assert(targetSlot.MethodDef.DeclaringType.IsInterface);
					return targetSlot.OverridedBy(impl);
				}
				return slot;
			};

			if (vTbl.InterfaceSlots.ContainsKey(iface)) {
				vTbl.InterfaceSlots[iface] = vTbl.InterfaceSlots[iface].Values.ToDictionary(
					slot => slot.Signature, implLookup);
			}
			else {
				vTbl.InterfaceSlots.Add(iface, ifaceVTbl.Slots.ToDictionary(
					slot => slot.Signature, implLookup));
			}

			foreach (var baseIface in ifaceVTbl.InterfaceSlots) {
				if (vTbl.InterfaceSlots.ContainsKey(baseIface.Key)) {
					vTbl.InterfaceSlots[baseIface.Key] = vTbl.InterfaceSlots[baseIface.Key].Values.ToDictionary(
						slot => slot.Signature, implLookup);
				}
				else {
					vTbl.InterfaceSlots.Add(baseIface.Key, baseIface.Value.ToDictionary(
						slot => slot.Signature, implLookup));
				}
			}
		}

		static void Inherits(VTableConstruction vTbl, VTable baseVTbl) {
			foreach (VTableSlot slot in baseVTbl.Slots) {
				vTbl.AllSlots.Add(slot);
				// It's possible to have same signature in multiple slots,
				// when a derived type shadow the base type using newslot.
				// In this case, use the derived type's slot in SlotsMap.

				// The derived type's slots are always at a later position 
				// than the base type, so it would naturally 'override'
				// their position in SlotsMap.
				vTbl.SlotsMap[slot.Signature] = slot;
			}

			// This is the step 1 of 12.2 algorithm -- copy the base interface implementation.
			foreach (var iface in baseVTbl.InterfaceSlots) {
				Debug.Assert(!vTbl.InterfaceSlots.ContainsKey(iface.Key));
				vTbl.InterfaceSlots.Add(iface.Key, iface.Value.ToDictionary(slot => slot.Signature, slot => slot));
			}
		}

		[Conditional("DEBUG")]
		static void CheckKeyExist<TKey, TValue>(VTableStorage storage, IDictionary<TKey, TValue> dictionary, TKey key, string name) {
			if (!dictionary.ContainsKey(key)) {
				storage.GetLogger().ErrorFormat("{0} not found: {1}", name, key);
				foreach (var k in dictionary.Keys)
					storage.GetLogger().ErrorFormat("    {0}", k);
			}
		}
	}

	public class VTableStorage {
		Dictionary<TypeDef, VTable> storage = new Dictionary<TypeDef, VTable>();
		ILogger logger;

		public VTableStorage(ILogger logger) {
			this.logger = logger;
		}

		public ILogger GetLogger() {
			return logger;
		}

		public VTable this[TypeDef type] {
			get { return storage.GetValueOrDefault(type, null); }
			internal set { storage[type] = value; }
		}

		VTable GetOrConstruct(TypeDef type) {
			VTable ret;
			if (!storage.TryGetValue(type, out ret))
				ret = storage[type] = VTable.ConstructVTable(type, this);
			return ret;
		}

		public VTable GetVTable(ITypeDefOrRef type) {
			if (type == null)
				return null;
			if (type is TypeDef)
				return GetOrConstruct((TypeDef)type);
			if (type is TypeRef)
				return GetOrConstruct(((TypeRef)type).ResolveThrow());
			if (type is TypeSpec) {
				TypeSig sig = ((TypeSpec)type).TypeSig;
				if (sig is TypeDefOrRefSig) {
					TypeDef typeDef = ((TypeDefOrRefSig)sig).TypeDefOrRef.ResolveTypeDefThrow();
					return GetOrConstruct(typeDef);
				}
				if (sig is GenericInstSig) {
					var genInst = (GenericInstSig)sig;
					TypeDef openType = genInst.GenericType.TypeDefOrRef.ResolveTypeDefThrow();
					VTable vTable = GetOrConstruct(openType);

					return ResolveGenericArgument(openType, genInst, vTable);
				}
				throw new NotSupportedException("Unexpected type: " + type);
			}
			throw new UnreachableException();
		}

		static VTableSlot ResolveSlot(TypeDef openType, VTableSlot slot, IList<TypeSig> genArgs) {
			var newSig = GenericArgumentResolver.Resolve(slot.Signature.MethodSig, genArgs);
			TypeSig newDecl = slot.MethodDefDeclType;
			if (new SigComparer().Equals(newDecl, openType))
				newDecl = new GenericInstSig((ClassOrValueTypeSig)openType.ToTypeSig(), genArgs.ToArray());
			else
				newDecl = GenericArgumentResolver.Resolve(newDecl, genArgs);
			return new VTableSlot(newDecl, slot.MethodDef, slot.DeclaringType, new VTableSignature(newSig, slot.Signature.Name), slot.Overrides);
		}

		static VTable ResolveGenericArgument(TypeDef openType, GenericInstSig genInst, VTable vTable) {
			Debug.Assert(new SigComparer().Equals(openType, vTable.Type));
			var ret = new VTable(genInst);
			foreach (VTableSlot slot in vTable.Slots) {
				ret.Slots.Add(ResolveSlot(openType, slot, genInst.GenericArguments));
			}
			foreach (var iface in vTable.InterfaceSlots) {
				ret.InterfaceSlots.Add(GenericArgumentResolver.Resolve(iface.Key, genInst.GenericArguments),
				                       iface.Value.Select(slot => ResolveSlot(openType, slot, genInst.GenericArguments)).ToList());
			}
			return ret;
		}
	}
}


================================================
File: Confuser.Renamer/Analyzers/CaliburnAnalyzer.cs
================================================
ï»¿using System;
using Confuser.Core;
using Confuser.Renamer.BAML;
using dnlib.DotNet;

namespace Confuser.Renamer.Analyzers {
	internal class CaliburnAnalyzer : IRenamer {
		public CaliburnAnalyzer(WPFAnalyzer wpfAnalyzer) {
			wpfAnalyzer.AnalyzeBAMLElement += AnalyzeBAMLElement;
		}

		public void Analyze(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			var type = def as TypeDef;
			if (type == null || type.DeclaringType != null)
				return;
			if (type.Name.Contains("ViewModel")) {
				string viewNs = type.Namespace.Replace("ViewModels", "Views");
				string viewName = type.Name.Replace("PageViewModel", "Page").Replace("ViewModel", "View");
				TypeDef view = type.Module.Find(viewNs + "." + viewName, true);
				if (view != null) {
					service.SetCanRename(type, false);
					service.SetCanRename(view, false);
				}

				// Test for Multi-view
				string multiViewNs = type.Namespace + "." + type.Name.Replace("ViewModel", "");
				foreach (var t in type.Module.Types)
					if (t.Namespace == multiViewNs) {
						service.SetCanRename(type, false);
						service.SetCanRename(t, false);
					}
			}
		}

		void AnalyzeBAMLElement(BAMLAnalyzer analyzer, BamlElement elem) {
			foreach (var rec in elem.Body) {
				var prop = rec as PropertyWithConverterRecord;
				if (prop == null)
					continue;

				var attr = analyzer.ResolveAttribute(prop.AttributeId);
				string attrName = null;
				if (attr.Item2 != null)
					attrName = attr.Item2.Name;
				else if (attr.Item1 != null)
					attrName = attr.Item1.Name;

				if (attrName == "Attach")
					AnalyzeMessageAttach(analyzer, attr, prop.Value);

				if (attrName == "Name")
					AnalyzeAutoBind(analyzer, attr, prop.Value);

				if (attrName == "MethodName")
					AnalyzeActionMessage(analyzer, attr, prop.Value);
			}
		}

		void AnalyzeMessageAttach(BAMLAnalyzer analyzer, Tuple<IDnlibDef, AttributeInfoRecord, TypeDef> attr, string value) {
			if (attr.Item2 == null)
				return;
			var attrDeclType = analyzer.ResolveType(attr.Item2.OwnerTypeId);
			if (attrDeclType.FullName != "Caliburn.Micro.Message")
				return;

			foreach (var msg in value.Split(';')) {
				string msgStr;
				if (msg.Contains("=")) {
					msgStr = msg.Split('=')[1].Trim('[', ']', ' ');
				}
				else {
					msgStr = msg.Trim('[', ']', ' ');
				}
				if (msgStr.StartsWith("Action"))
					msgStr = msgStr.Substring(6);
				int parenIndex = msgStr.IndexOf('(');
				if (parenIndex != -1)
					msgStr = msgStr.Substring(0, parenIndex);

				string actName = msgStr.Trim();
				foreach (var method in analyzer.LookupMethod(actName))
					analyzer.NameService.SetCanRename(method, false);
			}
		}

		void AnalyzeAutoBind(BAMLAnalyzer analyzer, Tuple<IDnlibDef, AttributeInfoRecord, TypeDef> attr, string value) {
			if (!(attr.Item1 is PropertyDef) || ((PropertyDef)attr.Item1).DeclaringType.FullName != "System.Windows.FrameworkElement")
				return;

			foreach (var method in analyzer.LookupMethod(value))
				analyzer.NameService.SetCanRename(method, false);
			foreach (var method in analyzer.LookupProperty(value))
				analyzer.NameService.SetCanRename(method, false);
		}

		void AnalyzeActionMessage(BAMLAnalyzer analyzer, Tuple<IDnlibDef, AttributeInfoRecord, TypeDef> attr, string value) {
			if (attr.Item2 == null)
				return;
			var attrDeclType = analyzer.ResolveType(attr.Item2.OwnerTypeId);
			if (attrDeclType.FullName != "Caliburn.Micro.ActionMessage")
				return;

			foreach (var method in analyzer.LookupMethod(value))
				analyzer.NameService.SetCanRename(method, false);
		}


		public void PreRename(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			//
		}

		public void PostRename(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			//
		}
	}
}


================================================
File: Confuser.Renamer/Analyzers/InterReferenceAnalyzer.cs
================================================
ï»¿using System;
using System.Linq;
using Confuser.Core;
using Confuser.Renamer.References;
using dnlib.DotNet;
using dnlib.DotNet.MD;

namespace Confuser.Renamer.Analyzers {
	internal class InterReferenceAnalyzer : IRenamer {
		// i.e. Inter-Assembly References, e.g. InternalVisibleToAttributes

		public void Analyze(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			var module = def as ModuleDefMD;
			if (module == null) return;

			// MemberRef/MethodSpec
			var methods = module.GetTypes().SelectMany(type => type.Methods);
			foreach(var methodDef in methods) {
				foreach (var ov in methodDef.Overrides) {
					ProcessMemberRef(context, service, module, ov.MethodBody);
					ProcessMemberRef(context, service, module, ov.MethodDeclaration);
				}

				if (!methodDef.HasBody)
					continue;
				foreach (var instr in methodDef.Body.Instructions) {
					if (instr.Operand is MemberRef || instr.Operand is MethodSpec)
						ProcessMemberRef(context, service, module, (IMemberRef)instr.Operand);
				}
			}

			// TypeRef
			var table = module.TablesStream.Get(Table.TypeRef);
			uint len = table.Rows;
			for (uint i = 1; i <= len; i++) {
				TypeRef typeRef = module.ResolveTypeRef(i);

				TypeDef typeDef = typeRef.ResolveTypeDefThrow();
				if (typeDef.Module != module && context.Modules.Contains((ModuleDefMD)typeDef.Module)) {
					service.AddReference(typeDef, new TypeRefReference(typeRef, typeDef));
				}
			}
		}

		void ProcessMemberRef(ConfuserContext context, INameService service, ModuleDefMD module, IMemberRef r) {
			var memberRef = r as MemberRef;
			if (r is MethodSpec)
				memberRef = ((MethodSpec)r).Method as MemberRef;

			if (memberRef != null) {
				if (memberRef.DeclaringType.TryGetArraySig() != null)
					return;

				TypeDef declType = memberRef.DeclaringType.ResolveTypeDefThrow();
				if (declType.Module != module && context.Modules.Contains((ModuleDefMD)declType.Module)) {
					var memberDef = (IDnlibDef)declType.ResolveThrow(memberRef);
					service.AddReference(memberDef, new MemberRefReference(memberRef, memberDef));
				}
			}
		}

		public void PreRename(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			//
		}

		public void PostRename(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			//
		}
	}
}


================================================
File: Confuser.Renamer/Analyzers/JsonAnalyzer.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using Confuser.Core;
using Confuser.Renamer.BAML;
using dnlib.DotNet;

namespace Confuser.Renamer.Analyzers {
	internal class JsonAnalyzer : IRenamer {
		public JsonAnalyzer() {
		}

		const string JsonProperty = "Newtonsoft.Json.JsonPropertyAttribute";
		const string JsonIgnore = "Newtonsoft.Json.JsonIgnoreAttribute";
		const string JsonObject = "Newtonsoft.Json.JsonObjectAttribute";
		static readonly HashSet<string> JsonContainers = new HashSet<string> {
			"Newtonsoft.Json.JsonArrayAttribute",
			"Newtonsoft.Json.JsonContainerAttribute",
			"Newtonsoft.Json.JsonDictionaryAttribute",
			"Newtonsoft.Json.JsonObjectAttribute"
		};

		static CustomAttribute GetJsonContainerAttribute(IHasCustomAttribute attrs) {
			foreach (var attr in attrs.CustomAttributes) {
				if (JsonContainers.Contains(attr.TypeFullName))
					return attr;
			}
			return null;
		}

		static bool ShouldExclude(TypeDef type, IDnlibDef def) {
			CustomAttribute attr;

			if (def.CustomAttributes.IsDefined(JsonProperty)) {
				attr = def.CustomAttributes.Find(JsonProperty);
				if (attr.HasConstructorArguments || attr.GetProperty("PropertyName") != null)
					return false;
			}

			attr = GetJsonContainerAttribute(type);
			if (attr == null || attr.TypeFullName != JsonObject)
				return false;

			if (def.CustomAttributes.IsDefined(JsonIgnore))
				return false;

			int serialization = 0;
			if (attr.HasConstructorArguments && attr.ConstructorArguments[0].Type.FullName == "Newtonsoft.Json.MemberSerialization")
				serialization = (int)attr.ConstructorArguments[0].Value;
			else {
				foreach (var property in attr.Properties) {
					if (property.Name == "MemberSerialization")
						serialization = (int)property.Value;
				}
			}

			if (serialization == 0) { // OptOut
				return (def is PropertyDef && ((PropertyDef)def).IsPublic()) ||
					(def is FieldDef && ((FieldDef)def).IsPublic);
			}
			else if (serialization == 1) // OptIn
				return false;
			else if (serialization == 2) // Fields
				return def is FieldDef;
			else  // Unknown
				return false;
		}

		public void Analyze(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			if (def is TypeDef)
				Analyze(context, service, (TypeDef)def, parameters);
			else if (def is MethodDef)
				Analyze(context, service, (MethodDef)def, parameters);
			else if (def is PropertyDef)
				Analyze(context, service, (PropertyDef)def, parameters);
			else if (def is FieldDef)
				Analyze(context, service, (FieldDef)def, parameters);
		}

		void Analyze(ConfuserContext context, INameService service, TypeDef type, ProtectionParameters parameters) {
			var attr = GetJsonContainerAttribute(type);
			if (attr == null)
				return;

			bool hasId = false;
			if (attr.HasConstructorArguments && attr.ConstructorArguments[0].Type.FullName == "System.String")
				hasId = true;
			else {
				foreach (var property in attr.Properties) {
					if (property.Name == "Id")
						hasId = true;
				}
			}
			if (!hasId)
				service.SetCanRename(type, false);
		}

		void Analyze(ConfuserContext context, INameService service, MethodDef method, ProtectionParameters parameters) {
			if (GetJsonContainerAttribute(method.DeclaringType) != null && method.IsConstructor) {
				service.SetParam(method, "renameArgs", "false");
			}
		}

		void Analyze(ConfuserContext context, INameService service, PropertyDef property, ProtectionParameters parameters) {
			if (ShouldExclude(property.DeclaringType, property)) {
				service.SetCanRename(property, false);
			}
		}

		void Analyze(ConfuserContext context, INameService service, FieldDef field, ProtectionParameters parameters) {
			if (ShouldExclude(field.DeclaringType, field)) {
				service.SetCanRename(field, false);
			}
		}

		public void PreRename(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			//
		}

		public void PostRename(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			//
		}
	}
}


================================================
File: Confuser.Renamer/Analyzers/LdtokenEnumAnalyzer.cs
================================================
ï»¿using System;
using Confuser.Core;
using Confuser.Renamer.References;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Renamer.Analyzers {
	internal class LdtokenEnumAnalyzer : IRenamer {
		public void Analyze(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			var method = def as MethodDef;
			if (method == null || !method.HasBody)
				return;

			// When a ldtoken instruction reference a definition,
			// most likely it would be used in reflection and thus probably should not be renamed.
			// Also, when ToString is invoked on enum,
			// the enum should not be renamed.
			for (int i = 0; i < method.Body.Instructions.Count; i++) {
				Instruction instr = method.Body.Instructions[i];
				if (instr.OpCode.Code == Code.Ldtoken) {
					if (instr.Operand is MemberRef) {
						IMemberForwarded member = ((MemberRef)instr.Operand).ResolveThrow();
						if (context.Modules.Contains((ModuleDefMD)member.Module))
							service.SetCanRename(member, false);
					}
					else if (instr.Operand is IField) {
						FieldDef field = ((IField)instr.Operand).ResolveThrow();
						if (context.Modules.Contains((ModuleDefMD)field.Module))
							service.SetCanRename(field, false);
					}
					else if (instr.Operand is IMethod) {
						var im = (IMethod)instr.Operand;
						if (!im.IsArrayAccessors()) {
							MethodDef m = im.ResolveThrow();
							if (context.Modules.Contains((ModuleDefMD)m.Module))
								service.SetCanRename(method, false);
						}
					}
					else if (instr.Operand is ITypeDefOrRef) {
						if (!(instr.Operand is TypeSpec)) {
							TypeDef type = ((ITypeDefOrRef)instr.Operand).ResolveTypeDefThrow();
							if (context.Modules.Contains((ModuleDefMD)type.Module) &&
							    HandleTypeOf(context, service, method, i)) {
								var t = type;
								do {
									DisableRename(service, t, false);
									t = t.DeclaringType;
								} while (t != null);
							}
						}
					}
					else
						throw new UnreachableException();
				}
				else if ((instr.OpCode.Code == Code.Call || instr.OpCode.Code == Code.Callvirt) &&
				         ((IMethod)instr.Operand).Name == "ToString") {
					HandleEnum(context, service, method, i);
				}
				else if (instr.OpCode.Code == Code.Ldstr) {
					TypeDef typeDef = method.Module.FindReflection((string)instr.Operand);
					if (typeDef != null)
						service.AddReference(typeDef, new StringTypeReference(instr, typeDef));
				}
			}
		}

		public void PreRename(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			//
		}

		public void PostRename(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			//
		}

		void HandleEnum(ConfuserContext context, INameService service, MethodDef method, int index) {
			var target = (IMethod)method.Body.Instructions[index].Operand;
			if (target.FullName == "System.String System.Object::ToString()" ||
			    target.FullName == "System.String System.Enum::ToString(System.String)") {
				int prevIndex = index - 1;
				while (prevIndex >= 0 && method.Body.Instructions[prevIndex].OpCode.Code == Code.Nop)
					prevIndex--;

				if (prevIndex < 0)
					return;

				Instruction prevInstr = method.Body.Instructions[prevIndex];
				TypeSig targetType;

				if (prevInstr.Operand is MemberRef) {
					var memberRef = (MemberRef)prevInstr.Operand;
					targetType = memberRef.IsFieldRef ? memberRef.FieldSig.Type : memberRef.MethodSig.RetType;
				}
				else if (prevInstr.Operand is IField)
					targetType = ((IField)prevInstr.Operand).FieldSig.Type;

				else if (prevInstr.Operand is IMethod)
					targetType = ((IMethod)prevInstr.Operand).MethodSig.RetType;

				else if (prevInstr.Operand is ITypeDefOrRef)
					targetType = ((ITypeDefOrRef)prevInstr.Operand).ToTypeSig();

				else if (prevInstr.GetParameter(method.Parameters) != null)
					targetType = prevInstr.GetParameter(method.Parameters).Type;

				else if (prevInstr.GetLocal(method.Body.Variables) != null)
					targetType = prevInstr.GetLocal(method.Body.Variables).Type;

				else
					return;

				ITypeDefOrRef targetTypeRef = targetType.ToBasicTypeDefOrRef();
				if (targetTypeRef == null)
					return;

				TypeDef targetTypeDef = targetTypeRef.ResolveTypeDefThrow();
				if (targetTypeDef != null && targetTypeDef.IsEnum && context.Modules.Contains((ModuleDefMD)targetTypeDef.Module))
					DisableRename(service, targetTypeDef);
			}
		}

		bool HandleTypeOf(ConfuserContext context, INameService service, MethodDef method, int index) {
			if (index + 1 >= method.Body.Instructions.Count)
				return true;

			var gtfh = method.Body.Instructions[index + 1].Operand as IMethod;
			if (gtfh == null || gtfh.FullName != "System.Type System.Type::GetTypeFromHandle(System.RuntimeTypeHandle)")
				return true;

			if (index + 2 < method.Body.Instructions.Count) {
				Instruction instr = method.Body.Instructions[index + 2];
				var operand = instr.Operand as IMethod;
				if (instr.OpCode == OpCodes.Newobj && operand.FullName == "System.Void System.ComponentModel.ComponentResourceManager::.ctor(System.Type)")
					return false;
				if (instr.OpCode == OpCodes.Call || instr.OpCode == OpCodes.Callvirt) {
					switch (operand.DeclaringType.FullName) {
						case "System.Runtime.InteropServices.Marshal":
							return false;
						case "System.Type":
							if (operand.Name.StartsWith("Get") || operand.Name == "InvokeMember")
								return true;
							if (operand.Name == "get_AssemblyQualifiedName" ||
							    operand.Name == "get_FullName" ||
							    operand.Name == "get_Namespace")
								return true;
							return false;
						case "System.Reflection.MemberInfo":
							return operand.Name == "get_Name";
						case "System.Object":
							return operand.Name == "ToString";
					}
				}
			}
			if (index + 3 < method.Body.Instructions.Count) {
				Instruction instr = method.Body.Instructions[index + 3];
				var operand = instr.Operand as IMethod;
				if (instr.OpCode == OpCodes.Call || instr.OpCode == OpCodes.Callvirt) {
					switch (operand.DeclaringType.FullName) {
						case "System.Runtime.InteropServices.Marshal":
							return false;
					}
				}
			}

			return false;
		}

		void DisableRename(INameService service, TypeDef typeDef, bool memberOnly = true) {
			service.SetCanRename(typeDef, false);

			foreach (MethodDef m in typeDef.Methods)
				service.SetCanRename(m, false);

			foreach (FieldDef field in typeDef.Fields)
				service.SetCanRename(field, false);

			foreach (PropertyDef prop in typeDef.Properties)
				service.SetCanRename(prop, false);

			foreach (EventDef evt in typeDef.Events)
				service.SetCanRename(evt, false);

			foreach (TypeDef nested in typeDef.NestedTypes)
				DisableRename(service, nested, false);
		}
	}
}


================================================
File: Confuser.Renamer/Analyzers/ResourceAnalyzer.cs
================================================
ï»¿using System;
using System.Linq;
using System.Text.RegularExpressions;
using Confuser.Core;
using Confuser.Renamer.References;
using dnlib.DotNet;

namespace Confuser.Renamer.Analyzers {
	internal class ResourceAnalyzer : IRenamer {
		static readonly Regex ResourceNamePattern = new Regex("^(.*)\\.resources$");

		public void Analyze(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			var module = def as ModuleDef;
			if (module == null) return;

			string asmName = module.Assembly.Name.String;
			if (!string.IsNullOrEmpty(module.Assembly.Culture) &&
			    asmName.EndsWith(".resources")) {
				// Satellite assembly
				var satellitePattern = new Regex(string.Format("^(.*)\\.{0}\\.resources$", module.Assembly.Culture));
				string nameAsmName = asmName.Substring(0, asmName.Length - ".resources".Length);
				ModuleDef mainModule = context.Modules.SingleOrDefault(mod => mod.Assembly.Name == nameAsmName);
				if (mainModule == null) {
					context.Logger.ErrorFormat("Could not find main assembly of satellite assembly '{0}'.", module.Assembly.FullName);
					throw new ConfuserException(null);
				}

				string format = "{0}." + module.Assembly.Culture + ".resources";
				foreach (Resource res in module.Resources) {
					Match match = satellitePattern.Match(res.Name);
					if (!match.Success)
						continue;
					string typeName = match.Groups[1].Value;
					TypeDef type = mainModule.FindReflectionThrow(typeName);
					if (type == null) {
						context.Logger.WarnFormat("Could not find resource type '{0}'.", typeName);
						continue;
					}
					service.ReduceRenameMode(type, RenameMode.ASCII);
					service.AddReference(type, new ResourceReference(res, type, format));
				}
			}
			else {
				string format = "{0}.resources";
				foreach (Resource res in module.Resources) {
					Match match = ResourceNamePattern.Match(res.Name);
					if (!match.Success || res.ResourceType != ResourceType.Embedded)
						continue;
					string typeName = match.Groups[1].Value;

					if (typeName.EndsWith(".g")) // WPF resources, ignore
						continue;

					TypeDef type = module.FindReflection(typeName);
					if (type == null) {
						context.Logger.WarnFormat("Could not find resource type '{0}'.", typeName);
						continue;
					}
					service.ReduceRenameMode(type, RenameMode.ASCII);
					service.AddReference(type, new ResourceReference(res, type, format));
				}
			}
		}

		public void PreRename(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			//
		}

		public void PostRename(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			//
		}
	}
}


================================================
File: Confuser.Renamer/Analyzers/TypeBlobAnalyzer.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using Confuser.Core;
using Confuser.Renamer.References;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using dnlib.DotNet.MD;

namespace Confuser.Renamer.Analyzers {
	internal class TypeBlobAnalyzer : IRenamer {
		public void Analyze(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			var module = def as ModuleDefMD;
			if (module == null) return;

			MDTable table;
			uint len;

			// MemberRef
			table = module.TablesStream.Get(Table.Method);
			len = table.Rows;
			IEnumerable<MethodDef> methods = module.GetTypes().SelectMany(type => type.Methods);
			foreach (MethodDef method in methods) {
				foreach (MethodOverride methodImpl in method.Overrides) {
					if (methodImpl.MethodBody is MemberRef)
						AnalyzeMemberRef(context, service, (MemberRef)methodImpl.MethodBody);
					if (methodImpl.MethodDeclaration is MemberRef)
						AnalyzeMemberRef(context, service, (MemberRef)methodImpl.MethodDeclaration);
				}
				if (!method.HasBody)
					continue;
				foreach (Instruction instr in method.Body.Instructions) {
					if (instr.Operand is MemberRef)
						AnalyzeMemberRef(context, service, (MemberRef)instr.Operand);
					else if (instr.Operand is MethodSpec) {
						var spec = (MethodSpec)instr.Operand;
						if (spec.Method is MemberRef)
							AnalyzeMemberRef(context, service, (MemberRef)spec.Method);
					}
				}
			}


			// CustomAttribute
			table = module.TablesStream.Get(Table.CustomAttribute);
			len = table.Rows;
			IEnumerable<CustomAttribute> attrs = Enumerable.Range(1, (int)len)
			                                               .Select(rid => module.ResolveHasCustomAttribute(module.TablesStream.ReadCustomAttributeRow((uint)rid).Parent))
			                                               .Distinct()
			                                               .SelectMany(owner => owner.CustomAttributes);
			foreach (CustomAttribute attr in attrs) {
				if (attr.Constructor is MemberRef)
					AnalyzeMemberRef(context, service, (MemberRef)attr.Constructor);

				foreach (CAArgument arg in attr.ConstructorArguments)
					AnalyzeCAArgument(context, service, arg);

				foreach (CANamedArgument arg in attr.Fields)
					AnalyzeCAArgument(context, service, arg.Argument);

				foreach (CANamedArgument arg in attr.Properties)
					AnalyzeCAArgument(context, service, arg.Argument);

				TypeDef attrType = attr.AttributeType.ResolveTypeDefThrow();
				if (!context.Modules.Contains((ModuleDefMD)attrType.Module))
					continue;

				foreach (CANamedArgument fieldArg in attr.Fields) {
					FieldDef field = attrType.FindField(fieldArg.Name, new FieldSig(fieldArg.Type));
					if (field == null)
						context.Logger.WarnFormat("Failed to resolve CA field '{0}::{1} : {2}'.", attrType, fieldArg.Name, fieldArg.Type);
					else
						service.AddReference(field, new CAMemberReference(fieldArg, field));
				}
				foreach (CANamedArgument propertyArg in attr.Properties) {
					PropertyDef property = attrType.FindProperty(propertyArg.Name, new PropertySig(true, propertyArg.Type));
					if (property == null)
						context.Logger.WarnFormat("Failed to resolve CA property '{0}::{1} : {2}'.", attrType, propertyArg.Name, propertyArg.Type);
					else
						service.AddReference(property, new CAMemberReference(propertyArg, property));
				}
			}
		}

		public void PreRename(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			//
		}

		public void PostRename(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			//
		}

		void AnalyzeCAArgument(ConfuserContext context, INameService service, CAArgument arg) {
			if (arg.Type.DefinitionAssembly.IsCorLib() && arg.Type.FullName == "System.Type") {
				var typeSig = (TypeSig)arg.Value;
				foreach (ITypeDefOrRef typeRef in typeSig.FindTypeRefs()) {
					TypeDef typeDef = typeRef.ResolveTypeDefThrow();
					if (context.Modules.Contains((ModuleDefMD)typeDef.Module)) {
						if (typeRef is TypeRef)
							service.AddReference(typeDef, new TypeRefReference((TypeRef)typeRef, typeDef));
						service.ReduceRenameMode(typeDef, RenameMode.ASCII);
					}
				}
			}
			else if (arg.Value is CAArgument[]) {
				foreach (CAArgument elem in (CAArgument[])arg.Value)
					AnalyzeCAArgument(context, service, elem);
			}
		}

		void AnalyzeMemberRef(ConfuserContext context, INameService service, MemberRef memberRef) {
			ITypeDefOrRef declType = memberRef.DeclaringType;
			var typeSpec = declType as TypeSpec;
			if (typeSpec == null || typeSpec.TypeSig.IsArray || typeSpec.TypeSig.IsSZArray)
				return;

			TypeSig sig = typeSpec.TypeSig;
			while (sig.Next != null)
				sig = sig.Next;


			Debug.Assert(sig is TypeDefOrRefSig || sig is GenericInstSig || sig is GenericSig);
			if (sig is GenericInstSig) {
				var inst = (GenericInstSig)sig;
				Debug.Assert(!(inst.GenericType.TypeDefOrRef is TypeSpec));
				TypeDef openType = inst.GenericType.TypeDefOrRef.ResolveTypeDefThrow();
				if (!context.Modules.Contains((ModuleDefMD)openType.Module) ||
				    memberRef.IsArrayAccessors())
					return;

				IDnlibDef member;
				if (memberRef.IsFieldRef) member = memberRef.ResolveFieldThrow();
				else if (memberRef.IsMethodRef) member = memberRef.ResolveMethodThrow();
				else throw new UnreachableException();

				service.AddReference(member, new MemberRefReference(memberRef, member));
			}
		}
	}
}


================================================
File: Confuser.Renamer/Analyzers/VTableAnalyzer.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Diagnostics;
using Confuser.Core;
using Confuser.Renamer.References;
using dnlib.DotNet;

namespace Confuser.Renamer.Analyzers {
	internal class VTableAnalyzer : IRenamer {
		public void Analyze(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			VTable vTbl;

			if (def is TypeDef) {
				var type = (TypeDef)def;
				if (type.IsInterface)
					return;

				vTbl = service.GetVTables()[type];
				foreach (var ifaceVTbl in vTbl.InterfaceSlots.Values) {
					foreach (var slot in ifaceVTbl) {
						if (slot.Overrides == null)
							continue;
						Debug.Assert(slot.Overrides.MethodDef.DeclaringType.IsInterface);
						// A method in base type can implements an interface method for a
						// derived type. If the base type/interface is not in our control, we should
						// not rename the methods.
						bool baseUnderCtrl = context.Modules.Contains(slot.MethodDef.DeclaringType.Module as ModuleDefMD);
						bool ifaceUnderCtrl = context.Modules.Contains(slot.Overrides.MethodDef.DeclaringType.Module as ModuleDefMD);
						if ((!baseUnderCtrl && ifaceUnderCtrl) || !service.CanRename(slot.MethodDef)) {
							service.SetCanRename(slot.Overrides.MethodDef, false);
						}
						else if (baseUnderCtrl && !ifaceUnderCtrl || !service.CanRename(slot.Overrides.MethodDef)) {
							service.SetCanRename(slot.MethodDef, false);
						}
					}
				}
			}
			else if (def is MethodDef) {
				var method = (MethodDef)def;
				if (!method.IsVirtual)
					return;

				vTbl = service.GetVTables()[method.DeclaringType];
				VTableSignature sig = VTableSignature.FromMethod(method);
				var slots = vTbl.FindSlots(method);

				if (!method.IsAbstract) {
					foreach (var slot in slots) {
						if (slot.Overrides == null)
							continue;
						// Better on safe side, add references to both methods.
						service.AddReference(method, new OverrideDirectiveReference(slot, slot.Overrides));
						service.AddReference(slot.Overrides.MethodDef, new OverrideDirectiveReference(slot, slot.Overrides));
					}
				}
				else {
					foreach (var slot in slots) {
						if (slot.Overrides == null)
							continue;
						service.SetCanRename(method, false);
						service.SetCanRename(slot.Overrides.MethodDef, false);
					}
				}
			}
		}

		public void PreRename(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			//
		}

		public void PostRename(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			var method = def as MethodDef;
			if (method == null || !method.IsVirtual || method.Overrides.Count == 0)
				return;

			var methods = new HashSet<IMethodDefOrRef>(MethodDefOrRefComparer.Instance);
			method.Overrides
			      .RemoveWhere(impl => MethodDefOrRefComparer.Instance.Equals(impl.MethodDeclaration, method));
		}

		class MethodDefOrRefComparer : IEqualityComparer<IMethodDefOrRef> {
			public static readonly MethodDefOrRefComparer Instance = new MethodDefOrRefComparer();
			MethodDefOrRefComparer() { }

			public bool Equals(IMethodDefOrRef x, IMethodDefOrRef y) {
				return new SigComparer().Equals(x, y) && new SigComparer().Equals(x.DeclaringType, y.DeclaringType);
			}

			public int GetHashCode(IMethodDefOrRef obj) {
				return new SigComparer().GetHashCode(obj) * 5 + new SigComparer().GetHashCode(obj.DeclaringType);
			}
		}
	}
}


================================================
File: Confuser.Renamer/Analyzers/WPFAnalyzer.cs
================================================
ï»¿using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Resources;
using System.Text.RegularExpressions;
using Confuser.Core;
using Confuser.Core.Services;
using Confuser.Renamer.BAML;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using dnlib.IO;

namespace Confuser.Renamer.Analyzers {
	internal class WPFAnalyzer : IRenamer {
		static readonly object BAMLKey = new object();

		static readonly Regex ResourceNamePattern = new Regex("^.*\\.g\\.resources$");
		internal static readonly Regex UriPattern = new Regex("(?:;COMPONENT|APPLICATION\\:,,,)(/.+\\.[BX]AML)$");
		BAMLAnalyzer analyzer;

		internal Dictionary<string, List<IBAMLReference>> bamlRefs = new Dictionary<string, List<IBAMLReference>>(StringComparer.OrdinalIgnoreCase);
		public event Action<BAMLAnalyzer, BamlElement> AnalyzeBAMLElement;

		public void Analyze(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			var method = def as MethodDef;
			if (method != null) {
				if (!method.HasBody)
					return;
				AnalyzeMethod(context, service, method);
			}

			var module = def as ModuleDefMD;
			if (module != null) {
				AnalyzeResources(context, service, module);
			}
		}

		public void PreRename(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			var module = def as ModuleDefMD;
			if (module == null || !parameters.GetParameter<bool>(context, def, "renXaml", true))
				return;

			var wpfResInfo = context.Annotations.Get<Dictionary<string, Dictionary<string, BamlDocument>>>(module, BAMLKey);
			if (wpfResInfo == null)
				return;

			foreach (var res in wpfResInfo.Values)
				foreach (var doc in res.Values) {
					List<IBAMLReference> references;
					if (bamlRefs.TryGetValue(doc.DocumentName, out references)) {
						var newName = doc.DocumentName.ToUpperInvariant();

						#region old code

						//if (newName.EndsWith(".BAML"))
						//    newName = service.RandomName(RenameMode.Letters).ToLowerInvariant() + ".baml";
						//else if (newName.EndsWith(".XAML"))
						//    newName = service.RandomName(RenameMode.Letters).ToLowerInvariant() + ".xaml";

						#endregion

						#region Niks patch fix

						/*
                         * Nik's patch for maintaining relative paths. If the xaml file is referenced in this manner
                         * "/some.namespace;component/somefolder/somecontrol.xaml"
                         * then we want to keep the relative path and namespace intact. We should be obfuscating it like this - /some.namespace;component/somefolder/asjdjh2398498dswk.xaml
                        * */

						string[] completePath = newName.Split(new string[] { "/" }, StringSplitOptions.RemoveEmptyEntries);
						string newShinyName = string.Empty;
						for (int i = 0; i <= completePath.Length - 2; i++) {
							newShinyName += completePath[i].ToLowerInvariant() + "/";
						}
						if (newName.EndsWith(".BAML"))
							newName = newShinyName + service.RandomName(RenameMode.Letters).ToLowerInvariant() + ".baml";
						else if (newName.EndsWith(".XAML"))
							newName = newShinyName + service.RandomName(RenameMode.Letters).ToLowerInvariant() + ".xaml";

						context.Logger.Debug(String.Format("Preserving virtual paths. Replaced {0} with {1}", doc.DocumentName, newName));

						#endregion

						bool renameOk = true;
						foreach (var bamlRef in references)
							if (!bamlRef.CanRename(doc.DocumentName, newName)) {
								renameOk = false;
								break;
							}

						if (renameOk) {
							foreach (var bamlRef in references)
								bamlRef.Rename(doc.DocumentName, newName);
							doc.DocumentName = newName;
						}
					}
				}
		}

		public void PostRename(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			var module = def as ModuleDefMD;
			if (module == null)
				return;

			var wpfResInfo = context.Annotations.Get<Dictionary<string, Dictionary<string, BamlDocument>>>(module, BAMLKey);
			if (wpfResInfo == null)
				return;

			foreach (EmbeddedResource res in module.Resources.OfType<EmbeddedResource>()) {
				Dictionary<string, BamlDocument> resInfo;

				if (!wpfResInfo.TryGetValue(res.Name, out resInfo))
					continue;

				var stream = new MemoryStream();
				var writer = new ResourceWriter(stream);

				res.Data.Position = 0;
				var reader = new ResourceReader(new ImageStream(res.Data));
				IDictionaryEnumerator enumerator = reader.GetEnumerator();
				while (enumerator.MoveNext()) {
					var name = (string)enumerator.Key;
					string typeName;
					byte[] data;
					reader.GetResourceData(name, out typeName, out data);

					BamlDocument document;
					if (resInfo.TryGetValue(name, out document)) {
						var docStream = new MemoryStream();
						docStream.Position = 4;
						BamlWriter.WriteDocument(document, docStream);
						docStream.Position = 0;
						docStream.Write(BitConverter.GetBytes((int)docStream.Length - 4), 0, 4);
						data = docStream.ToArray();
						name = document.DocumentName;
					}

					writer.AddResourceData(name, typeName, data);
				}
				writer.Generate();
				res.Data = MemoryImageStream.Create(stream.ToArray());
			}
		}

		void AnalyzeMethod(ConfuserContext context, INameService service, MethodDef method) {
			var dpRegInstrs = new List<Tuple<bool, Instruction>>();
			var routedEvtRegInstrs = new List<Instruction>();
			for (int i = 0; i < method.Body.Instructions.Count; i++) {
				Instruction instr = method.Body.Instructions[i];
				if ((instr.OpCode.Code == Code.Call || instr.OpCode.Code == Code.Callvirt)) {
					var regMethod = (IMethod)instr.Operand;

					if (regMethod.DeclaringType.FullName == "System.Windows.DependencyProperty" &&
					    regMethod.Name.String.StartsWith("Register")) {
						dpRegInstrs.Add(Tuple.Create(regMethod.Name.String.StartsWith("RegisterAttached"), instr));
					}
					else if (regMethod.DeclaringType.FullName == "System.Windows.EventManager" &&
					         regMethod.Name.String == "RegisterRoutedEvent") {
						routedEvtRegInstrs.Add(instr);
					}
				}
				else if (instr.OpCode.Code == Code.Newobj) {
					var methodRef = (IMethod)instr.Operand;

					if (methodRef.DeclaringType.FullName == "System.Windows.Data.PropertyGroupDescription" &&
					    methodRef.Name == ".ctor" && i - 1 >= 0 && method.Body.Instructions[i - 1].OpCode.Code == Code.Ldstr) {
						foreach (var property in analyzer.LookupProperty((string)method.Body.Instructions[i - 1].Operand))
							service.SetCanRename(property, false);
					}
				}
				else if (instr.OpCode == OpCodes.Ldstr) {
					var operand = ((string)instr.Operand).ToUpperInvariant();
					if (operand.EndsWith(".BAML") || operand.EndsWith(".XAML")) {
						var match = UriPattern.Match(operand);
						if (match.Success)
							operand = match.Groups[1].Value;
						else if (operand.Contains("/"))
							context.Logger.WarnFormat("Fail to extract XAML name from '{0}'.", instr.Operand);

						var reference = new BAMLStringReference(instr);
						operand = operand.TrimStart('/');
						var baml = operand.Substring(0, operand.Length - 5) + ".BAML";
						var xaml = operand.Substring(0, operand.Length - 5) + ".XAML";
						bamlRefs.AddListEntry(baml, reference);
						bamlRefs.AddListEntry(xaml, reference);
					}
				}
			}

			if (dpRegInstrs.Count == 0)
				return;

			var traceSrv = context.Registry.GetService<ITraceService>();
			MethodTrace trace = traceSrv.Trace(method);

			bool erred = false;
			foreach (var instrInfo in dpRegInstrs) {
				int[] args = trace.TraceArguments(instrInfo.Item2);
				if (args == null) {
					if (!erred)
						context.Logger.WarnFormat("Failed to extract dependency property name in '{0}'.", method.FullName);
					erred = true;
					continue;
				}
				Instruction ldstr = method.Body.Instructions[args[0]];
				if (ldstr.OpCode.Code != Code.Ldstr) {
					if (!erred)
						context.Logger.WarnFormat("Failed to extract dependency property name in '{0}'.", method.FullName);
					erred = true;
					continue;
				}

				var name = (string)ldstr.Operand;
				TypeDef declType = method.DeclaringType;
				bool found = false;
				if (instrInfo.Item1) // Attached DP
				{
					MethodDef accessor;
					if ((accessor = declType.FindMethod("Get" + name)) != null && accessor.IsStatic) {
						service.SetCanRename(accessor, false);
						found = true;
					}
					if ((accessor = declType.FindMethod("Set" + name)) != null && accessor.IsStatic) {
						service.SetCanRename(accessor, false);
						found = true;
					}
				}

				// Normal DP
				// Find CLR property for attached DP as well, because it seems attached DP can be use as normal DP as well.
				PropertyDef property = null;
				if ((property = declType.FindProperty(name)) != null) {
					service.SetCanRename(property, false);

					found = true;
					if (property.GetMethod != null)
						service.SetCanRename(property.GetMethod, false);

					if (property.SetMethod != null)
						service.SetCanRename(property.SetMethod, false);

					if (property.HasOtherMethods) {
						foreach (MethodDef accessor in property.OtherMethods)
							service.SetCanRename(accessor, false);
					}
				}
				if (!found) {
					if (instrInfo.Item1)
						context.Logger.WarnFormat("Failed to find the accessors of attached dependency property '{0}' in type '{1}'.",
						                          name, declType.FullName);
					else
						context.Logger.WarnFormat("Failed to find the CLR property of normal dependency property '{0}' in type '{1}'.",
						                          name, declType.FullName);
				}
			}

			erred = false;
			foreach (Instruction instr in routedEvtRegInstrs) {
				int[] args = trace.TraceArguments(instr);
				if (args == null) {
					if (!erred)
						context.Logger.WarnFormat("Failed to extract routed event name in '{0}'.", method.FullName);
					erred = true;
					continue;
				}
				Instruction ldstr = method.Body.Instructions[args[0]];
				if (ldstr.OpCode.Code != Code.Ldstr) {
					if (!erred)
						context.Logger.WarnFormat("Failed to extract routed event name in '{0}'.", method.FullName);
					erred = true;
					continue;
				}

				var name = (string)ldstr.Operand;
				TypeDef declType = method.DeclaringType;

				EventDef eventDef = null;
				if ((eventDef = declType.FindEvent(name)) == null) {
					context.Logger.WarnFormat("Failed to find the CLR event of routed event '{0}' in type '{1}'.",
					                          name, declType.FullName);
					continue;
				}
				service.SetCanRename(eventDef, false);

				if (eventDef.AddMethod != null)
					service.SetCanRename(eventDef.AddMethod, false);

				if (eventDef.RemoveMethod != null)
					service.SetCanRename(eventDef.RemoveMethod, false);

				if (eventDef.InvokeMethod != null)
					service.SetCanRename(eventDef.InvokeMethod, false);

				if (eventDef.HasOtherMethods) {
					foreach (MethodDef accessor in eventDef.OtherMethods)
						service.SetCanRename(accessor, false);
				}
			}
		}

		void AnalyzeResources(ConfuserContext context, INameService service, ModuleDefMD module) {
			if (analyzer == null) {
				analyzer = new BAMLAnalyzer(context, service);
				analyzer.AnalyzeElement += AnalyzeBAMLElement;
			}

			var wpfResInfo = new Dictionary<string, Dictionary<string, BamlDocument>>();

			foreach (EmbeddedResource res in module.Resources.OfType<EmbeddedResource>()) {
				Match match = ResourceNamePattern.Match(res.Name);
				if (!match.Success)
					continue;

				var resInfo = new Dictionary<string, BamlDocument>();

				res.Data.Position = 0;
				var reader = new ResourceReader(new ImageStream(res.Data));
				IDictionaryEnumerator enumerator = reader.GetEnumerator();
				while (enumerator.MoveNext()) {
					var name = (string)enumerator.Key;
					if (!name.EndsWith(".baml"))
						continue;

					string typeName;
					byte[] data;
					reader.GetResourceData(name, out typeName, out data);
					BamlDocument document = analyzer.Analyze(module, name, data);
					document.DocumentName = name;
					resInfo.Add(name, document);
				}

				if (resInfo.Count > 0)
					wpfResInfo.Add(res.Name, resInfo);
			}
			if (wpfResInfo.Count > 0)
				context.Annotations.Set(module, BAMLKey, wpfResInfo);
		}
	}
}


================================================
File: Confuser.Renamer/Analyzers/WinFormsAnalyzer.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using Confuser.Core;
using Confuser.Core.Services;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Renamer.Analyzers {
	public class WinFormsAnalyzer : IRenamer {
		Dictionary<string, List<PropertyDef>> properties = new Dictionary<string, List<PropertyDef>>();

		public void Analyze(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			if (def is ModuleDef) {
				foreach (var type in ((ModuleDef)def).GetTypes())
					foreach (var prop in type.Properties)
						properties.AddListEntry(prop.Name, prop);
				return;
			}

			var method = def as MethodDef;
			if (method == null || !method.HasBody)
				return;

			AnalyzeMethod(context, service, method);
		}

		void AnalyzeMethod(ConfuserContext context, INameService service, MethodDef method) {
			var binding = new List<Tuple<bool, Instruction>>();
			foreach (Instruction instr in method.Body.Instructions) {
				if ((instr.OpCode.Code == Code.Call || instr.OpCode.Code == Code.Callvirt)) {
					var target = (IMethod)instr.Operand;

					if ((target.DeclaringType.FullName == "System.Windows.Forms.ControlBindingsCollection" ||
					     target.DeclaringType.FullName == "System.Windows.Forms.BindingsCollection") &&
					    target.Name == "Add" && target.MethodSig.Params.Count != 1) {
						binding.Add(Tuple.Create(true, instr));
					}
					else if (target.DeclaringType.FullName == "System.Windows.Forms.Binding" &&
					         target.Name.String == ".ctor") {
						binding.Add(Tuple.Create(false, instr));
					}
				}
			}

			if (binding.Count == 0)
				return;

			var traceSrv = context.Registry.GetService<ITraceService>();
			MethodTrace trace = traceSrv.Trace(method);

			bool erred = false;
			foreach (var instrInfo in binding) {
				int[] args = trace.TraceArguments(instrInfo.Item2);
				if (args == null) {
					if (!erred)
						context.Logger.WarnFormat("Failed to extract binding property name in '{0}'.", method.FullName);
					erred = true;
					continue;
				}

				Instruction propertyName = method.Body.Instructions[args[0 + (instrInfo.Item1 ? 1 : 0)]];
				if (propertyName.OpCode.Code != Code.Ldstr) {
					if (!erred)
						context.Logger.WarnFormat("Failed to extract binding property name in '{0}'.", method.FullName);
					erred = true;
				}
				else {
					List<PropertyDef> props;
					if (!properties.TryGetValue((string)propertyName.Operand, out props)) {
						if (!erred)
							context.Logger.WarnFormat("Failed to extract target property in '{0}'.", method.FullName);
						erred = true;
					}
					else {
						foreach (var property in props)
							service.SetCanRename(property, false);
					}
				}

				Instruction dataMember = method.Body.Instructions[args[2 + (instrInfo.Item1 ? 1 : 0)]];
				if (dataMember.OpCode.Code != Code.Ldstr) {
					if (!erred)
						context.Logger.WarnFormat("Failed to extract binding property name in '{0}'.", method.FullName);
					erred = true;
				}
				else {
					List<PropertyDef> props;
					if (!properties.TryGetValue((string)dataMember.Operand, out props)) {
						if (!erred)
							context.Logger.WarnFormat("Failed to extract target property in '{0}'.", method.FullName);
						erred = true;
					}
					else {
						foreach (var property in props)
							service.SetCanRename(property, false);
					}
				}
			}
		}


		public void PreRename(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			//
		}

		public void PostRename(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			//
		}
	}
}


================================================
File: Confuser.Renamer/BAML/BAMLAnalyzer.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.IO.Packaging;
using System.Linq;
using Confuser.Core;
using Confuser.Renamer.Analyzers;
using Confuser.Renamer.References;
using dnlib.DotNet;

namespace Confuser.Renamer.BAML {
	internal class BAMLAnalyzer {
		readonly ConfuserContext context;
		readonly INameService service;

		readonly Dictionary<string, List<MethodDef>> methods = new Dictionary<string, List<MethodDef>>();
		readonly Dictionary<string, List<EventDef>> events = new Dictionary<string, List<EventDef>>();
		readonly Dictionary<string, List<PropertyDef>> properties = new Dictionary<string, List<PropertyDef>>();

		readonly Dictionary<ushort, AssemblyDef> assemblyRefs = new Dictionary<ushort, AssemblyDef>();
		readonly Dictionary<ushort, Tuple<IDnlibDef, AttributeInfoRecord, TypeDef>> attrRefs = new Dictionary<ushort, Tuple<IDnlibDef, AttributeInfoRecord, TypeDef>>();

		readonly Dictionary<ushort, StringInfoRecord> strings = new Dictionary<ushort, StringInfoRecord>();
		readonly Dictionary<ushort, TypeSig> typeRefs = new Dictionary<ushort, TypeSig>();
		readonly Dictionary<string, List<Tuple<AssemblyDef, string>>> xmlns = new Dictionary<string, List<Tuple<AssemblyDef, string>>>();

		readonly string packScheme = PackUriHelper.UriSchemePack + "://";

		IKnownThings things;

		KnownThingsv3 thingsv3;
		KnownThingsv4 thingsv4;
		XmlNsContext xmlnsCtx;

		public event Action<BAMLAnalyzer, BamlElement> AnalyzeElement;

		public ConfuserContext Context {
			get { return context; }
		}

		public INameService NameService {
			get { return service; }
		}

		public string CurrentBAMLName { get; set; }
		public ModuleDefMD Module { get; set; }

		public BAMLAnalyzer(ConfuserContext context, INameService service) {
			this.context = context;
			this.service = service;
			PreInit();
		}

		void PreInit() {
			// WPF will only look for public instance members
			foreach (TypeDef type in context.Modules.SelectMany(m => m.GetTypes())) {
				foreach (PropertyDef property in type.Properties) {
					if (property.IsPublic() && !property.IsStatic())
						properties.AddListEntry(property.Name, property);
				}

				foreach (EventDef evt in type.Events) {
					if (evt.IsPublic() && !evt.IsStatic())
						events.AddListEntry(evt.Name, evt);
				}

				foreach (MethodDef method in type.Methods) {
					if (method.IsPublic && !method.IsStatic)
						methods.AddListEntry(method.Name, method);
				}
			}
		}

		public IEnumerable<PropertyDef> LookupProperty(string name) {
			List<PropertyDef> ret;
			if (!properties.TryGetValue(name, out ret))
				return Enumerable.Empty<PropertyDef>();
			return ret;
		}

		public IEnumerable<EventDef> LookupEvent(string name) {
			List<EventDef> ret;
			if (!events.TryGetValue(name, out ret))
				return Enumerable.Empty<EventDef>();
			return ret;
		}

		public IEnumerable<MethodDef> LookupMethod(string name) {
			List<MethodDef> ret;
			if (!methods.TryGetValue(name, out ret))
				return Enumerable.Empty<MethodDef>();
			return ret;
		}

		public BamlDocument Analyze(ModuleDefMD module, string bamlName, byte[] data) {
			Module = module;
			CurrentBAMLName = bamlName;
			if (module.IsClr40) {
				things = thingsv4 ?? (thingsv4 = new KnownThingsv4(context, module));
			}
			else {
				things = thingsv3 ?? (thingsv3 = new KnownThingsv3(context, module));
			}

			Debug.Assert(BitConverter.ToInt32(data, 0) == data.Length - 4);

			BamlDocument document = BamlReader.ReadDocument(new MemoryStream(data, 4, data.Length - 4));

			// Remove debug infos
			document.RemoveWhere(rec => rec is LineNumberAndPositionRecord || rec is LinePositionRecord);

			// Populate references
			PopulateReferences(document);

			// Process elements
			BamlElement rootElem = BamlElement.Read(document);
			BamlElement trueRoot = rootElem.Children.Single();
			var stack = new Stack<BamlElement>();
			stack.Push(rootElem);
			while (stack.Count > 0) {
				BamlElement elem = stack.Pop();
				ProcessBAMLElement(trueRoot, elem);
				foreach (BamlElement child in elem.Children)
					stack.Push(child);
			}

			return document;
		}

		void PopulateReferences(BamlDocument document) {
			var clrNs = new Dictionary<string, List<Tuple<AssemblyDef, string>>>();

			assemblyRefs.Clear();
			foreach (AssemblyInfoRecord rec in document.OfType<AssemblyInfoRecord>()) {
				AssemblyDef assembly = context.Resolver.ResolveThrow(rec.AssemblyFullName, Module);
				assemblyRefs.Add(rec.AssemblyId, assembly);

				if (!context.Modules.Any(m => m.Assembly == assembly))
					continue;

				foreach (CustomAttribute attr in assembly.CustomAttributes.FindAll("System.Windows.Markup.XmlnsDefinitionAttribute")) {
					clrNs.AddListEntry(
						(UTF8String)attr.ConstructorArguments[0].Value,
						Tuple.Create(assembly, (string)(UTF8String)attr.ConstructorArguments[1].Value));
				}
			}

			xmlnsCtx = new XmlNsContext(document, assemblyRefs);

			typeRefs.Clear();
			foreach (TypeInfoRecord rec in document.OfType<TypeInfoRecord>()) {
				AssemblyDef assembly;
				var asmId = (short)(rec.AssemblyId & 0xfff);
				if (asmId == -1)
					assembly = things.FrameworkAssembly;
				else
					assembly = assemblyRefs[(ushort)asmId];

				AssemblyDef assemblyRef = Module.Assembly == assembly ? null : assembly;

				TypeSig typeSig = TypeNameParser.ParseAsTypeSigReflectionThrow(Module, rec.TypeFullName, new DummyAssemblyRefFinder(assemblyRef));
				typeRefs[rec.TypeId] = typeSig;

				AddTypeSigReference(typeSig, new BAMLTypeReference(typeSig, rec));
			}

			attrRefs.Clear();
			foreach (AttributeInfoRecord rec in document.OfType<AttributeInfoRecord>()) {
				TypeSig declType;
				if (typeRefs.TryGetValue(rec.OwnerTypeId, out declType)) {
					TypeDef type = declType.ToBasicTypeDefOrRef().ResolveTypeDefThrow();
					attrRefs[rec.AttributeId] = AnalyzeAttributeReference(type, rec);
				}
				else {
					Debug.Assert((short)rec.OwnerTypeId < 0);
					TypeDef declTypeDef = things.Types((KnownTypes)(-(short)rec.OwnerTypeId));
					attrRefs[rec.AttributeId] = AnalyzeAttributeReference(declTypeDef, rec);
				}
			}

			strings.Clear();
			foreach (StringInfoRecord rec in document.OfType<StringInfoRecord>()) {
				strings[rec.StringId] = rec;
			}

			foreach (PIMappingRecord rec in document.OfType<PIMappingRecord>()) {
				var asmId = (short)(rec.AssemblyId & 0xfff);
				AssemblyDef assembly;
				if (asmId == -1)
					assembly = things.FrameworkAssembly;
				else
					assembly = assemblyRefs[(ushort)asmId];

				Tuple<AssemblyDef, string> scope = Tuple.Create(assembly, rec.ClrNamespace);
				clrNs.AddListEntry(rec.XmlNamespace, scope);
			}

			xmlns.Clear();
			foreach (XmlnsPropertyRecord rec in document.OfType<XmlnsPropertyRecord>()) {
				List<Tuple<AssemblyDef, string>> clrMap;
				if (clrNs.TryGetValue(rec.XmlNamespace, out clrMap)) {
					xmlns[rec.Prefix] = clrMap;
					foreach (var scope in clrMap)
						xmlnsCtx.AddNsMap(scope, rec.Prefix);
				}
			}
		}

		public TypeDef ResolveType(ushort typeId) {
			if ((short)typeId < 0)
				return things.Types((KnownTypes)(-(short)typeId));
			return typeRefs[typeId].ToBasicTypeDefOrRef().ResolveTypeDefThrow();
		}

		TypeSig ResolveType(string typeName, out string prefix) {
			List<Tuple<AssemblyDef, string>> clrNs;

			int index = typeName.IndexOf(':');
			if (index == -1) {
				prefix = "";
				if (!xmlns.TryGetValue(prefix, out clrNs))
					return null;
			}
			else {
				prefix = typeName.Substring(0, index);
				if (!xmlns.TryGetValue(prefix, out clrNs))
					return null;

				typeName = typeName.Substring(index + 1);
			}

			foreach (var ns in clrNs) {
				TypeSig sig = TypeNameParser.ParseAsTypeSigReflectionThrow(Module, ns.Item2 + "." + typeName, new DummyAssemblyRefFinder(ns.Item1));
				if (sig.ToBasicTypeDefOrRef().ResolveTypeDef() != null)
					return sig;
			}
			return null;
		}

		public Tuple<IDnlibDef, AttributeInfoRecord, TypeDef> ResolveAttribute(ushort attrId) {
			if ((short)attrId < 0) {
				Tuple<KnownTypes, PropertyDef, TypeDef> info = things.Properties((KnownProperties)(-(short)attrId));
				return Tuple.Create<IDnlibDef, AttributeInfoRecord, TypeDef>(info.Item2, null, info.Item3);
			}
			return attrRefs[attrId];
		}

		void AddTypeSigReference(TypeSig typeSig, INameReference<IDnlibDef> reference) {
			foreach (ITypeDefOrRef type in typeSig.FindTypeRefs()) {
				TypeDef typeDef = type.ResolveTypeDefThrow();
				if (context.Modules.Contains((ModuleDefMD)typeDef.Module)) {
					service.ReduceRenameMode(typeDef, RenameMode.Letters);
					if (type is TypeRef)
						service.AddReference(typeDef, new TypeRefReference((TypeRef)type, typeDef));
					service.AddReference(typeDef, reference);
				}
			}
		}

		void ProcessBAMLElement(BamlElement root, BamlElement elem) {
			ProcessElementHeader(elem);
			ProcessElementBody(root, elem);

			if (AnalyzeElement != null)
				AnalyzeElement(this, elem);
		}

		void ProcessElementHeader(BamlElement elem) {
			// Resolve type & properties of the element.
			switch (elem.Header.Type) {
				case BamlRecordType.ConstructorParametersStart:
					elem.Type = elem.Parent.Type;
					elem.Attribute = elem.Parent.Attribute;
					break;

				case BamlRecordType.DocumentStart:
					break;

				case BamlRecordType.ElementStart:
				case BamlRecordType.NamedElementStart:
					elem.Type = ResolveType(((ElementStartRecord)elem.Header).TypeId);
					elem.Attribute = elem.Parent.Attribute;
					if (elem.Attribute != null)
						elem.Type = GetAttributeType(elem.Attribute);
					break;

				case BamlRecordType.PropertyArrayStart:
				case BamlRecordType.PropertyComplexStart:
				case BamlRecordType.PropertyDictionaryStart:
				case BamlRecordType.PropertyListStart:
					var attrInfo = ResolveAttribute(((PropertyComplexStartRecord)elem.Header).AttributeId);
					elem.Type = attrInfo.Item3;
					elem.Attribute = attrInfo.Item1;
					if (elem.Attribute != null)
						elem.Type = GetAttributeType(elem.Attribute);
					break;

				case BamlRecordType.KeyElementStart:
				case BamlRecordType.StaticResourceStart:
					// i.e. <x:Key></x:Key>
					elem.Type = Module.CorLibTypes.Object.TypeDefOrRef.ResolveTypeDef();
					elem.Attribute = null;
					break;
			}
		}

		TypeDef GetAttributeType(IDnlibDef attr) {
			ITypeDefOrRef retType = null;
			if (attr is PropertyDef)
				retType = ((PropertyDef)attr).PropertySig.RetType.ToBasicTypeDefOrRef();
			else if (attr is EventDef)
				retType = ((EventDef)attr).EventType;
			return (retType == null) ? null : retType.ResolveTypeDefThrow();
			throw new UnreachableException();
		}

		void ProcessElementBody(BamlElement root, BamlElement elem) {
			foreach (BamlRecord rec in elem.Body) {
				// Resolve the type & property for simple property record too.
				TypeDef type = null;
				IDnlibDef attr = null;
				if (rec is PropertyRecord) {
					var propRec = (PropertyRecord)rec;
					var attrInfo = ResolveAttribute(propRec.AttributeId);
					type = attrInfo.Item3;
					attr = attrInfo.Item1;
					if (attr != null)
						type = GetAttributeType(attr);

					if (attrInfo.Item1 is EventDef) {
						MethodDef method = root.Type.FindMethod(propRec.Value);
						if (method == null)
							context.Logger.WarnFormat("Cannot resolve method '{0}' in '{1}'.", root.Type.FullName, propRec.Value);
						else {
							var reference = new BAMLAttributeReference(method, propRec);
							service.AddReference(method, reference);
						}
					}

					if (rec is PropertyWithConverterRecord) {
						ProcessConverter((PropertyWithConverterRecord)rec, type);
					}
				}
				else if (rec is PropertyComplexStartRecord) {
					var attrInfo = ResolveAttribute(((PropertyComplexStartRecord)rec).AttributeId);
					type = attrInfo.Item3;
					attr = attrInfo.Item1;
					if (attr != null)
						type = GetAttributeType(attr);
				}
				else if (rec is ContentPropertyRecord) {
					var attrInfo = ResolveAttribute(((ContentPropertyRecord)rec).AttributeId);
					type = attrInfo.Item3;
					attr = attrInfo.Item1;
					if (elem.Attribute != null && attr != null)
						type = GetAttributeType(attr);
					foreach (BamlElement child in elem.Children) {
						child.Type = type;
						child.Attribute = attr;
					}
				}
				else if (rec is PropertyCustomRecord) {
					var customRec = (PropertyCustomRecord)rec;
					var attrInfo = ResolveAttribute(customRec.AttributeId);
					type = attrInfo.Item3;
					attr = attrInfo.Item1;
					if (elem.Attribute != null && attr != null)
						type = GetAttributeType(attr);

					if ((customRec.SerializerTypeId & ~0x4000) != 0 && (customRec.SerializerTypeId & ~0x4000) == 0x89) {
						// See BamlRecordReader.GetCustomDependencyPropertyValue.
						// Umm... Well, actually nothing to do, since this record only describe DP, which already won't be renamed.
					}
				}
				else if (rec is PropertyWithExtensionRecord) {
					var extRec = (PropertyWithExtensionRecord)rec;
					var attrInfo = ResolveAttribute(extRec.AttributeId);
					type = attrInfo.Item3;
					attr = attrInfo.Item1;
					if (elem.Attribute != null && attr != null)
						type = GetAttributeType(attr);

					if (extRec.Flags == 602) {
						// Static Extension
						// We only care about the references in user-defined assemblies, so skip built-in attributes
						// Also, ValueId is a resource ID, which is not implemented, so just skip it.
						if ((short)extRec.ValueId >= 0) {
							attrInfo = ResolveAttribute(extRec.ValueId);

							var attrTarget = attrInfo.Item1;
							if (attrTarget == null) {
								TypeSig declType;
								TypeDef declTypeDef;
								if (typeRefs.TryGetValue(attrInfo.Item2.OwnerTypeId, out declType))
									declTypeDef = declType.ToBasicTypeDefOrRef().ResolveTypeDefThrow();
								else {
									Debug.Assert((short)attrInfo.Item2.OwnerTypeId < 0);
									declTypeDef = things.Types((KnownTypes)(-(short)attrInfo.Item2.OwnerTypeId));
								}
								attrTarget = declTypeDef.FindField(attrInfo.Item2.Name);
							}

							if (attrTarget != null)
								service.AddReference(attrTarget, new BAMLAttributeReference(attrTarget, attrInfo.Item2));
						}
					}
				}
				else if (rec is TextRecord) {
					var txt = (TextRecord)rec;
					string value = txt.Value;
					if (txt is TextWithIdRecord)
						value = strings[((TextWithIdRecord)txt).ValueId].Value;

					string prefix;
					TypeSig sig = ResolveType(value.Trim(), out prefix);
					if (sig != null && context.Modules.Contains((ModuleDefMD)sig.ToBasicTypeDefOrRef().ResolveTypeDefThrow().Module)) {
						var reference = new BAMLConverterTypeReference(xmlnsCtx, sig, txt);
						AddTypeSigReference(sig, reference);
					}
					else
						AnalyzePropertyPath(value);
				}
			}
		}

		void ProcessConverter(PropertyWithConverterRecord rec, TypeDef type) {
			TypeDef converter = ResolveType(rec.ConverterTypeId);

			if (converter.FullName == "System.ComponentModel.EnumConverter") {
				if (type != null && context.Modules.Contains((ModuleDefMD)type.Module)) {
					FieldDef enumField = type.FindField(rec.Value);
					if (enumField != null)
						service.AddReference(enumField, new BAMLEnumReference(enumField, rec));
				}
			}
			else if (converter.FullName == "System.Windows.Input.CommandConverter") {
				string cmd = rec.Value.Trim();
				int index = cmd.IndexOf('.');
				if (index != -1) {
					string typeName = cmd.Substring(0, index);
					string prefix;
					TypeSig sig = ResolveType(typeName, out prefix);
					if (sig != null) {
						string cmdName = cmd.Substring(index + 1);

						TypeDef typeDef = sig.ToBasicTypeDefOrRef().ResolveTypeDefThrow();
						if (context.Modules.Contains((ModuleDefMD)typeDef.Module)) {
							PropertyDef property = typeDef.FindProperty(cmdName);
							if (property != null) {
								var reference = new BAMLConverterMemberReference(xmlnsCtx, sig, property, rec);
								AddTypeSigReference(sig, reference);
								service.ReduceRenameMode(property, RenameMode.Letters);
								service.AddReference(property, reference);
							}
							FieldDef field = typeDef.FindField(cmdName);
							if (field != null) {
								var reference = new BAMLConverterMemberReference(xmlnsCtx, sig, field, rec);
								AddTypeSigReference(sig, reference);
								service.ReduceRenameMode(field, RenameMode.Letters);
								service.AddReference(field, reference);
							}
							if (property == null && field == null)
								context.Logger.WarnFormat("Could not resolve command '{0}' in '{1}'.", cmd, CurrentBAMLName);
						}
					}
				}
			}
			else if (converter.FullName == "System.Windows.Markup.DependencyPropertyConverter") {
				// Umm... Again nothing to do, DP already won't be renamed.
			}
			else if (converter.FullName == "System.Windows.PropertyPathConverter") {
				AnalyzePropertyPath(rec.Value);
			}
			else if (converter.FullName == "System.Windows.Markup.RoutedEventConverter") {
				;
			}
			else if (converter.FullName == "System.Windows.Markup.TypeTypeConverter") {
				string prefix;
				TypeSig sig = ResolveType(rec.Value.Trim(), out prefix);
				if (sig != null && context.Modules.Contains((ModuleDefMD)sig.ToBasicTypeDefOrRef().ResolveTypeDefThrow().Module)) {
					var reference = new BAMLConverterTypeReference(xmlnsCtx, sig, rec);
					AddTypeSigReference(sig, reference);
				}
			}

			var attrInfo = ResolveAttribute(rec.AttributeId);
			string attrName = null;
			if (attrInfo.Item1 != null)
				attrName = attrInfo.Item1.Name;
			else if (attrInfo.Item2 != null)
				attrName = attrInfo.Item2.Name;

			if (attrName == "DisplayMemberPath") {
				AnalyzePropertyPath(rec.Value);
			}
			else if (attrName == "Source") {
				string declType = null;
				if (attrInfo.Item1 is IMemberDef)
					declType = ((IMemberDef)attrInfo.Item1).DeclaringType.FullName;
				else if (attrInfo.Item2 != null)
					declType = ResolveType(attrInfo.Item2.OwnerTypeId).FullName;
				if (declType == "System.Windows.ResourceDictionary") {
					var src = rec.Value.ToUpperInvariant();
					if (src.EndsWith(".BAML") || src.EndsWith(".XAML")) {
						var match = WPFAnalyzer.UriPattern.Match(src);
						if (match.Success)
							src = match.Groups[1].Value;
						else if (rec.Value.Contains("/"))
							context.Logger.WarnFormat("Fail to extract XAML name from '{0}'.", rec.Value);

						if (!src.Contains("//")) {
							var rel = new Uri(new Uri(packScheme + "application:,,,/" + CurrentBAMLName), src);
							src = rel.LocalPath;
						}
						var reference = new BAMLPropertyReference(rec);
						src = src.TrimStart('/');
						var baml = src.Substring(0, src.Length - 5) + ".BAML";
						var xaml = src.Substring(0, src.Length - 5) + ".XAML";
						var bamlRefs = service.FindRenamer<WPFAnalyzer>().bamlRefs;
						bamlRefs.AddListEntry(baml, reference);
						bamlRefs.AddListEntry(xaml, reference);
						bamlRefs.AddListEntry(Uri.EscapeUriString(baml), reference);
						bamlRefs.AddListEntry(Uri.EscapeUriString(xaml), reference);
					}
				}
			}
		}

		Tuple<IDnlibDef, AttributeInfoRecord, TypeDef> AnalyzeAttributeReference(TypeDef declType, AttributeInfoRecord rec) {
			IDnlibDef retDef = null;
			ITypeDefOrRef retType = null;
			while (declType != null) {
				PropertyDef property = declType.FindProperty(rec.Name);
				if (property != null) {
					retDef = property;
					retType = property.PropertySig.RetType.ToBasicTypeDefOrRef();
					if (context.Modules.Contains((ModuleDefMD)declType.Module))
						service.AddReference(property, new BAMLAttributeReference(property, rec));
					break;
				}

				EventDef evt = declType.FindEvent(rec.Name);
				if (evt != null) {
					retDef = evt;
					retType = evt.EventType;
					if (context.Modules.Contains((ModuleDefMD)declType.Module))
						service.AddReference(evt, new BAMLAttributeReference(evt, rec));
					break;
				}

				if (declType.BaseType == null)
					break;
				declType = declType.BaseType.ResolveTypeDefThrow();
			}
			return Tuple.Create(retDef, rec, retType == null ? null : retType.ResolveTypeDefThrow());
		}

		void AnalyzePropertyPath(string path) {
			var propertyPath = new PropertyPath(path);
			foreach (PropertyPathPart part in propertyPath.Parts) {
				if (part.IsAttachedDP()) {
					string type, property;
					part.ExtractAttachedDP(out type, out property);
					if (type != null) {
						string prefix;
						TypeSig sig = ResolveType(type, out prefix);
						if (sig != null && context.Modules.Contains((ModuleDefMD)sig.ToBasicTypeDefOrRef().ResolveTypeDefThrow().Module)) {
							var reference = new BAMLPathTypeReference(xmlnsCtx, sig, part);
							AddTypeSigReference(sig, reference);
						}
					}
				}
				else {
					List<PropertyDef> candidates;
					if (properties.TryGetValue(part.Name, out candidates))
						foreach (PropertyDef property in candidates) {
							service.SetCanRename(property, false);
						}
				}

				if (part.IndexerArguments != null) {
					foreach (PropertyPathIndexer indexer in part.IndexerArguments)
						if (!string.IsNullOrEmpty(indexer.Type)) {
							string prefix;
							TypeSig sig = ResolveType(indexer.Type, out prefix);
							if (sig != null && context.Modules.Contains((ModuleDefMD)sig.ToBasicTypeDefOrRef().ResolveTypeDefThrow().Module)) {
								var reference = new BAMLPathTypeReference(xmlnsCtx, sig, part);
								AddTypeSigReference(sig, reference);
							}
						}
				}
			}
		}

		class DummyAssemblyRefFinder : IAssemblyRefFinder {
			readonly AssemblyDef assemblyDef;

			public DummyAssemblyRefFinder(AssemblyDef assemblyDef) {
				this.assemblyDef = assemblyDef;
			}

			public AssemblyRef FindAssemblyRef(TypeRef nonNestedTypeRef) {
				return assemblyDef.ToAssemblyRef();
			}
		}

		internal class XmlNsContext {
			readonly Dictionary<AssemblyDef, ushort> assemblyRefs;
			readonly BamlDocument doc;
			readonly Dictionary<Tuple<AssemblyDef, string>, string> xmlNsMap = new Dictionary<Tuple<AssemblyDef, string>, string>();
			int rootIndex = -1;
			int x;

			public XmlNsContext(BamlDocument doc, Dictionary<ushort, AssemblyDef> assemblyRefs) {
				this.doc = doc;

				this.assemblyRefs = new Dictionary<AssemblyDef, ushort>();
				foreach (var entry in assemblyRefs)
					this.assemblyRefs[entry.Value] = entry.Key;

				for (int i = 0; i < doc.Count; i++)
					if (doc[i] is ElementStartRecord) {
						rootIndex = i + 1;
						break;
					}
				Debug.Assert(rootIndex != -1);
			}

			public void AddNsMap(Tuple<AssemblyDef, string> scope, string prefix) {
				xmlNsMap[scope] = prefix;
			}

			public string GetPrefix(string clrNs, AssemblyDef assembly) {
				string prefix;
				if (!xmlNsMap.TryGetValue(Tuple.Create(assembly, clrNs), out prefix)) {
					prefix = "_" + x++;
					ushort assemblyId = assemblyRefs[assembly];
					doc.Insert(rootIndex, new XmlnsPropertyRecord {
						AssemblyIds = new[] { assemblyId },
						Prefix = prefix,
						XmlNamespace = "clr-namespace:" + clrNs
					});
					doc.Insert(rootIndex - 1, new PIMappingRecord {
						AssemblyId = assemblyId,
						ClrNamespace = clrNs,
						XmlNamespace = "clr-namespace:" + clrNs
					});
					rootIndex++;
				}
				return prefix;
			}
		}
	}
}


================================================
File: Confuser.Renamer/BAML/BAMLPropertyReference.cs
================================================
ï»¿using System;
using System.Diagnostics;
using Confuser.Core;

namespace Confuser.Renamer.BAML {
	internal class BAMLPropertyReference : IBAMLReference {
		PropertyRecord rec;

		public BAMLPropertyReference(PropertyRecord rec) {
			this.rec = rec;
		}

		public bool CanRename(string oldName, string newName) {
			return true;
		}

		public void Rename(string oldName, string newName) {
			var value = rec.Value;
			if (value.IndexOf(oldName, StringComparison.OrdinalIgnoreCase) != -1)
				value = newName;
			else if (oldName.EndsWith(".baml")) {
				Debug.Assert(newName.EndsWith(".baml"));
				value = newName.Substring(0, newName.Length - 5) + ".xaml";
			}
			else
				throw new UnreachableException();
			rec.Value = "pack://application:,,,/" + value;
		}
	}
}


================================================
File: Confuser.Renamer/BAML/BAMLStringReference.cs
================================================
ï»¿using System;
using System.Diagnostics;
using Confuser.Core;
using dnlib.DotNet.Emit;

namespace Confuser.Renamer.BAML {
	public class BAMLStringReference : IBAMLReference {
		Instruction instr;

		public BAMLStringReference(Instruction instr) {
			this.instr = instr;
		}

		public bool CanRename(string oldName, string newName) {
			// TODO: Other protection interfering
			return instr.OpCode.Code == Code.Ldstr;
		}

		public void Rename(string oldName, string newName) {
			var value = (string)instr.Operand;
			if (value.IndexOf(oldName, StringComparison.OrdinalIgnoreCase) != -1)
				value = newName;
			else if (oldName.EndsWith(".baml")) {
				Debug.Assert(newName.EndsWith(".baml"));
				/*
                 * Nik's patch for maintaining relative paths. If the xaml file is referenced in this manner
                 * "/some.namespace;component/somefolder/somecontrol.xaml"
                 * then we want to keep the relative path and namespace intact. We should be obfuscating it like this - /some.namespace;component/somefolder/asjdjh2398498dswk.xaml
                 * */
				//value = newName.Substring(0, newName.Length - 5) + ".xaml";
				value = value.Replace(oldName.Replace(".baml", string.Empty, StringComparison.InvariantCultureIgnoreCase),
				                      newName.Replace(".baml", String.Empty, StringComparison.InvariantCultureIgnoreCase),
				                      StringComparison.InvariantCultureIgnoreCase);
			}
			else
				throw new UnreachableException();
			instr.Operand = value;
		}
	}
}


================================================
File: Confuser.Renamer/BAML/BamlDocument.cs
================================================
ï»¿using System;
using System.Collections.Generic;

namespace Confuser.Renamer.BAML {
	internal class BamlDocument : List<BamlRecord> {
		public string DocumentName { get; set; }

		public string Signature { get; set; }
		public BamlVersion ReaderVersion { get; set; }
		public BamlVersion UpdaterVersion { get; set; }
		public BamlVersion WriterVersion { get; set; }

		public struct BamlVersion {
			public ushort Major;
			public ushort Minor;
		}
	}
}


================================================
File: Confuser.Renamer/BAML/BamlElement.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Diagnostics;
using dnlib.DotNet;

namespace Confuser.Renamer.BAML {
	internal class BamlElement {
		public BamlElement Parent { get; private set; }
		public BamlRecord Header { get; private set; }
		public IList<BamlRecord> Body { get; private set; }
		public IList<BamlElement> Children { get; private set; }
		public BamlRecord Footer { get; private set; }

		// Type of this element
		public TypeDef Type { get; set; }
		// Attribute this element will be assigned to.
		public IDnlibDef Attribute { get; set; }

		static bool IsHeader(BamlRecord rec) {
			switch (rec.Type) {
				case BamlRecordType.ConstructorParametersStart:
				case BamlRecordType.DocumentStart:
				case BamlRecordType.ElementStart:
				case BamlRecordType.KeyElementStart:
				case BamlRecordType.NamedElementStart:
				case BamlRecordType.PropertyArrayStart:
				case BamlRecordType.PropertyComplexStart:
				case BamlRecordType.PropertyDictionaryStart:
				case BamlRecordType.PropertyListStart:
				case BamlRecordType.StaticResourceStart:
					return true;
			}
			return false;
		}

		static bool IsFooter(BamlRecord rec) {
			switch (rec.Type) {
				case BamlRecordType.ConstructorParametersEnd:
				case BamlRecordType.DocumentEnd:
				case BamlRecordType.ElementEnd:
				case BamlRecordType.KeyElementEnd:
				case BamlRecordType.PropertyArrayEnd:
				case BamlRecordType.PropertyComplexEnd:
				case BamlRecordType.PropertyDictionaryEnd:
				case BamlRecordType.PropertyListEnd:
				case BamlRecordType.StaticResourceEnd:
					return true;
			}
			return false;
		}

		static bool IsMatch(BamlRecord header, BamlRecord footer) {
			switch (header.Type) {
				case BamlRecordType.ConstructorParametersStart:
					return footer.Type == BamlRecordType.ConstructorParametersEnd;

				case BamlRecordType.DocumentStart:
					return footer.Type == BamlRecordType.DocumentEnd;

				case BamlRecordType.KeyElementStart:
					return footer.Type == BamlRecordType.KeyElementEnd;

				case BamlRecordType.PropertyArrayStart:
					return footer.Type == BamlRecordType.PropertyArrayEnd;

				case BamlRecordType.PropertyComplexStart:
					return footer.Type == BamlRecordType.PropertyComplexEnd;

				case BamlRecordType.PropertyDictionaryStart:
					return footer.Type == BamlRecordType.PropertyDictionaryEnd;

				case BamlRecordType.PropertyListStart:
					return footer.Type == BamlRecordType.PropertyListEnd;

				case BamlRecordType.StaticResourceStart:
					return footer.Type == BamlRecordType.StaticResourceEnd;

				case BamlRecordType.ElementStart:
				case BamlRecordType.NamedElementStart:
					return footer.Type == BamlRecordType.ElementEnd;
			}
			return false;
		}

		public static BamlElement Read(BamlDocument document) {
			Debug.Assert(document.Count > 0 && document[0].Type == BamlRecordType.DocumentStart);

			BamlElement current = null;
			var stack = new Stack<BamlElement>();

			for (int i = 0; i < document.Count; i++) {
				if (IsHeader(document[i])) {
					BamlElement prev = current;

					current = new BamlElement();
					current.Header = document[i];
					current.Body = new List<BamlRecord>();
					current.Children = new List<BamlElement>();

					if (prev != null) {
						prev.Children.Add(current);
						current.Parent = prev;
						stack.Push(prev);
					}
				}
				else if (IsFooter(document[i])) {
					if (current == null)
						throw new Exception("Unexpected footer.");

					while (!IsMatch(current.Header, document[i])) {
						// End record can be omited (sometimes).
						if (stack.Count > 0)
							current = stack.Pop();
					}
					current.Footer = document[i];
					if (stack.Count > 0)
						current = stack.Pop();
				}
				else
					current.Body.Add(document[i]);
			}
			Debug.Assert(stack.Count == 0);
			return current;
		}
	}
}


================================================
File: Confuser.Renamer/BAML/BamlRW.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

namespace Confuser.Renamer.BAML {
	internal class BamlBinaryReader : BinaryReader {
		public BamlBinaryReader(Stream stream)
			: base(stream) { }

		public int ReadEncodedInt() {
			return Read7BitEncodedInt();
		}
	}

	internal class BamlBinaryWriter : BinaryWriter {
		public BamlBinaryWriter(Stream stream)
			: base(stream) { }

		public void WriteEncodedInt(int val) {
			Write7BitEncodedInt(val);
		}
	}

	internal class BamlReader {
		public static BamlDocument ReadDocument(Stream str) {
			var ret = new BamlDocument();
			var reader = new BamlBinaryReader(str);
			{
				var rdr = new BinaryReader(str, Encoding.Unicode);
				uint len = rdr.ReadUInt32();
				ret.Signature = new string(rdr.ReadChars((int)(len >> 1)));
				rdr.ReadBytes((int)(((len + 3) & ~3) - len));
			}
			if (ret.Signature != "MSBAML") throw new NotSupportedException();
			ret.ReaderVersion = new BamlDocument.BamlVersion { Major = reader.ReadUInt16(), Minor = reader.ReadUInt16() };
			ret.UpdaterVersion = new BamlDocument.BamlVersion { Major = reader.ReadUInt16(), Minor = reader.ReadUInt16() };
			ret.WriterVersion = new BamlDocument.BamlVersion { Major = reader.ReadUInt16(), Minor = reader.ReadUInt16() };
			if (ret.ReaderVersion.Major != 0 || ret.ReaderVersion.Minor != 0x60 ||
			    ret.UpdaterVersion.Major != 0 || ret.UpdaterVersion.Minor != 0x60 ||
			    ret.WriterVersion.Major != 0 || ret.WriterVersion.Minor != 0x60)
				throw new NotSupportedException();

			var recs = new Dictionary<long, BamlRecord>();
			while (str.Position < str.Length) {
				long pos = str.Position;
				var type = (BamlRecordType)reader.ReadByte();
				BamlRecord rec = null;
				switch (type) {
					case BamlRecordType.AssemblyInfo:
						rec = new AssemblyInfoRecord();
						break;
					case BamlRecordType.AttributeInfo:
						rec = new AttributeInfoRecord();
						break;
					case BamlRecordType.ConstructorParametersStart:
						rec = new ConstructorParametersStartRecord();
						break;
					case BamlRecordType.ConstructorParametersEnd:
						rec = new ConstructorParametersEndRecord();
						break;
					case BamlRecordType.ConstructorParameterType:
						rec = new ConstructorParameterTypeRecord();
						break;
					case BamlRecordType.ConnectionId:
						rec = new ConnectionIdRecord();
						break;
					case BamlRecordType.ContentProperty:
						rec = new ContentPropertyRecord();
						break;
					case BamlRecordType.DefAttribute:
						rec = new DefAttributeRecord();
						break;
					case BamlRecordType.DefAttributeKeyString:
						rec = new DefAttributeKeyStringRecord();
						break;
					case BamlRecordType.DefAttributeKeyType:
						rec = new DefAttributeKeyTypeRecord();
						break;
					case BamlRecordType.DeferableContentStart:
						rec = new DeferableContentStartRecord();
						break;
					case BamlRecordType.DocumentEnd:
						rec = new DocumentEndRecord();
						break;
					case BamlRecordType.DocumentStart:
						rec = new DocumentStartRecord();
						break;
					case BamlRecordType.ElementEnd:
						rec = new ElementEndRecord();
						break;
					case BamlRecordType.ElementStart:
						rec = new ElementStartRecord();
						break;
					case BamlRecordType.KeyElementEnd:
						rec = new KeyElementEndRecord();
						break;
					case BamlRecordType.KeyElementStart:
						rec = new KeyElementStartRecord();
						break;
					case BamlRecordType.LineNumberAndPosition:
						rec = new LineNumberAndPositionRecord();
						break;
					case BamlRecordType.LinePosition:
						rec = new LinePositionRecord();
						break;
					case BamlRecordType.LiteralContent:
						rec = new LiteralContentRecord();
						break;
					case BamlRecordType.NamedElementStart:
						rec = new NamedElementStartRecord();
						break;
					case BamlRecordType.OptimizedStaticResource:
						rec = new OptimizedStaticResourceRecord();
						break;
					case BamlRecordType.PIMapping:
						rec = new PIMappingRecord();
						break;
					case BamlRecordType.PresentationOptionsAttribute:
						rec = new PresentationOptionsAttributeRecord();
						break;
					case BamlRecordType.Property:
						rec = new PropertyRecord();
						break;
					case BamlRecordType.PropertyArrayEnd:
						rec = new PropertyArrayEndRecord();
						break;
					case BamlRecordType.PropertyArrayStart:
						rec = new PropertyArrayStartRecord();
						break;
					case BamlRecordType.PropertyComplexEnd:
						rec = new PropertyComplexEndRecord();
						break;
					case BamlRecordType.PropertyComplexStart:
						rec = new PropertyComplexStartRecord();
						break;
					case BamlRecordType.PropertyCustom:
						rec = new PropertyCustomRecord();
						break;
					case BamlRecordType.PropertyDictionaryEnd:
						rec = new PropertyDictionaryEndRecord();
						break;
					case BamlRecordType.PropertyDictionaryStart:
						rec = new PropertyDictionaryStartRecord();
						break;
					case BamlRecordType.PropertyListEnd:
						rec = new PropertyListEndRecord();
						break;
					case BamlRecordType.PropertyListStart:
						rec = new PropertyListStartRecord();
						break;
					case BamlRecordType.PropertyStringReference:
						rec = new PropertyStringReferenceRecord();
						break;
					case BamlRecordType.PropertyTypeReference:
						rec = new PropertyTypeReferenceRecord();
						break;
					case BamlRecordType.PropertyWithConverter:
						rec = new PropertyWithConverterRecord();
						break;
					case BamlRecordType.PropertyWithExtension:
						rec = new PropertyWithExtensionRecord();
						break;
					case BamlRecordType.PropertyWithStaticResourceId:
						rec = new PropertyWithStaticResourceIdRecord();
						break;
					case BamlRecordType.RoutedEvent:
						rec = new RoutedEventRecord();
						break;
					case BamlRecordType.StaticResourceEnd:
						rec = new StaticResourceEndRecord();
						break;
					case BamlRecordType.StaticResourceId:
						rec = new StaticResourceIdRecord();
						break;
					case BamlRecordType.StaticResourceStart:
						rec = new StaticResourceStartRecord();
						break;
					case BamlRecordType.StringInfo:
						rec = new StringInfoRecord();
						break;
					case BamlRecordType.Text:
						rec = new TextRecord();
						break;
					case BamlRecordType.TextWithConverter:
						rec = new TextWithConverterRecord();
						break;
					case BamlRecordType.TextWithId:
						rec = new TextWithIdRecord();
						break;
					case BamlRecordType.TypeInfo:
						rec = new TypeInfoRecord();
						break;
					case BamlRecordType.TypeSerializerInfo:
						rec = new TypeSerializerInfoRecord();
						break;
					case BamlRecordType.XmlnsProperty:
						rec = new XmlnsPropertyRecord();
						break;
					case BamlRecordType.XmlAttribute:
					case BamlRecordType.ProcessingInstruction:
					case BamlRecordType.LastRecordType:
					case BamlRecordType.EndAttributes:
					case BamlRecordType.DefTag:
					case BamlRecordType.ClrEvent:
					case BamlRecordType.Comment:
					default:
						throw new NotSupportedException();
				}
				rec.Position = pos;

				rec.Read(reader);
				ret.Add(rec);
				recs.Add(pos, rec);
			}
			for (int i = 0; i < ret.Count; i++) {
				var defer = ret[i] as IBamlDeferRecord;
				if (defer != null)
					defer.ReadDefer(ret, i, _ => recs[_]);
			}

			return ret;
		}
	}

	internal class BamlWriter {
		public static void WriteDocument(BamlDocument doc, Stream str) {
			var writer = new BamlBinaryWriter(str);
			{
				var wtr = new BinaryWriter(str, Encoding.Unicode);
				int len = doc.Signature.Length * 2;
				wtr.Write(len);
				wtr.Write(doc.Signature.ToCharArray());
				wtr.Write(new byte[((len + 3) & ~3) - len]);
			}
			writer.Write(doc.ReaderVersion.Major);
			writer.Write(doc.ReaderVersion.Minor);
			writer.Write(doc.UpdaterVersion.Major);
			writer.Write(doc.UpdaterVersion.Minor);
			writer.Write(doc.WriterVersion.Major);
			writer.Write(doc.WriterVersion.Minor);

			var defers = new List<int>();
			for (int i = 0; i < doc.Count; i++) {
				BamlRecord rec = doc[i];
				rec.Position = str.Position;
				writer.Write((byte)rec.Type);
				rec.Write(writer);
				if (rec is IBamlDeferRecord) defers.Add(i);
			}
			foreach (int i in defers)
				(doc[i] as IBamlDeferRecord).WriteDefer(doc, i, writer);
		}
	}
}


================================================
File: Confuser.Renamer/BAML/BamlRecords.cs
================================================
ï»¿using System;
using System.Diagnostics;
using System.IO;

namespace Confuser.Renamer.BAML {
	internal enum BamlRecordType : byte {
		ClrEvent = 0x13,
		Comment = 0x17,
		AssemblyInfo = 0x1c,
		AttributeInfo = 0x1f,
		ConstructorParametersStart = 0x2a,
		ConstructorParametersEnd = 0x2b,
		ConstructorParameterType = 0x2c,
		ConnectionId = 0x2d,
		ContentProperty = 0x2e,
		DefAttribute = 0x19,
		DefAttributeKeyString = 0x26,
		DefAttributeKeyType = 0x27,
		DeferableContentStart = 0x25,
		DefTag = 0x18,
		DocumentEnd = 0x2,
		DocumentStart = 0x1,
		ElementEnd = 0x4,
		ElementStart = 0x3,
		EndAttributes = 0x1a,
		KeyElementEnd = 0x29,
		KeyElementStart = 0x28,
		LastRecordType = 0x39,
		LineNumberAndPosition = 0x35,
		LinePosition = 0x36,
		LiteralContent = 0xf,
		NamedElementStart = 0x2f,
		OptimizedStaticResource = 0x37,
		PIMapping = 0x1b,
		PresentationOptionsAttribute = 0x34,
		ProcessingInstruction = 0x16,
		Property = 0x5,
		PropertyArrayEnd = 0xa,
		PropertyArrayStart = 0x9,
		PropertyComplexEnd = 0x8,
		PropertyComplexStart = 0x7,
		PropertyCustom = 0x6,
		PropertyDictionaryEnd = 0xe,
		PropertyDictionaryStart = 0xd,
		PropertyListEnd = 0xc,
		PropertyListStart = 0xb,
		PropertyStringReference = 0x21,
		PropertyTypeReference = 0x22,
		PropertyWithConverter = 0x24,
		PropertyWithExtension = 0x23,
		PropertyWithStaticResourceId = 0x38,
		RoutedEvent = 0x12,
		StaticResourceEnd = 0x31,
		StaticResourceId = 0x32,
		StaticResourceStart = 0x30,
		StringInfo = 0x20,
		Text = 0x10,
		TextWithConverter = 0x11,
		TextWithId = 0x33,
		TypeInfo = 0x1d,
		TypeSerializerInfo = 0x1e,
		XmlAttribute = 0x15,
		XmlnsProperty = 0x14
	}

	internal abstract class BamlRecord {
		public abstract BamlRecordType Type { get; }
		public long Position { get; internal set; }
		public abstract void Read(BamlBinaryReader reader);
		public abstract void Write(BamlBinaryWriter writer);
	}

	internal abstract class SizedBamlRecord : BamlRecord {
		public override void Read(BamlBinaryReader reader) {
			long pos = reader.BaseStream.Position;
			int size = reader.ReadEncodedInt();

			ReadData(reader, size - (int)(reader.BaseStream.Position - pos));
			Debug.Assert(reader.BaseStream.Position - pos == size);
		}

		int SizeofEncodedInt(int val) {
			if ((val & ~0x7F) == 0) {
				return 1;
			}
			if ((val & ~0x3FFF) == 0) {
				return 2;
			}
			if ((val & ~0x1FFFFF) == 0) {
				return 3;
			}
			if ((val & ~0xFFFFFFF) == 0) {
				return 4;
			}
			return 5;
		}

		public override void Write(BamlBinaryWriter writer) {
			long pos = writer.BaseStream.Position;
			WriteData(writer);
			var size = (int)(writer.BaseStream.Position - pos);
			size = SizeofEncodedInt(SizeofEncodedInt(size) + size) + size;
			writer.BaseStream.Position = pos;
			writer.WriteEncodedInt(size);
			WriteData(writer);
		}

		protected abstract void ReadData(BamlBinaryReader reader, int size);
		protected abstract void WriteData(BamlBinaryWriter writer);
	}

	internal interface IBamlDeferRecord {
		BamlRecord Record { get; set; }
		void ReadDefer(BamlDocument doc, int index, Func<long, BamlRecord> resolve);
		void WriteDefer(BamlDocument doc, int index, BinaryWriter wtr);
	}

	internal class XmlnsPropertyRecord : SizedBamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.XmlnsProperty; }
		}

		public string Prefix { get; set; }
		public string XmlNamespace { get; set; }
		public ushort[] AssemblyIds { get; set; }

		protected override void ReadData(BamlBinaryReader reader, int size) {
			Prefix = reader.ReadString();
			XmlNamespace = reader.ReadString();
			AssemblyIds = new ushort[reader.ReadUInt16()];
			for (int i = 0; i < AssemblyIds.Length; i++)
				AssemblyIds[i] = reader.ReadUInt16();
		}

		protected override void WriteData(BamlBinaryWriter writer) {
			writer.Write(Prefix);
			writer.Write(XmlNamespace);
			writer.Write((ushort)AssemblyIds.Length);
			foreach (ushort i in AssemblyIds)
				writer.Write(i);
		}
	}

	internal class PresentationOptionsAttributeRecord : SizedBamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.PresentationOptionsAttribute; }
		}

		public string Value { get; set; }
		public ushort NameId { get; set; }

		protected override void ReadData(BamlBinaryReader reader, int size) {
			Value = reader.ReadString();
			NameId = reader.ReadUInt16();
		}

		protected override void WriteData(BamlBinaryWriter writer) {
			writer.Write(Value);
			writer.Write(NameId);
		}
	}

	internal class PIMappingRecord : SizedBamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.PIMapping; }
		}

		public string XmlNamespace { get; set; }
		public string ClrNamespace { get; set; }
		public ushort AssemblyId { get; set; }

		protected override void ReadData(BamlBinaryReader reader, int size) {
			XmlNamespace = reader.ReadString();
			ClrNamespace = reader.ReadString();
			AssemblyId = reader.ReadUInt16();
		}

		protected override void WriteData(BamlBinaryWriter writer) {
			writer.Write(XmlNamespace);
			writer.Write(ClrNamespace);
			writer.Write(AssemblyId);
		}
	}

	internal class AssemblyInfoRecord : SizedBamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.AssemblyInfo; }
		}

		public ushort AssemblyId { get; set; }
		public string AssemblyFullName { get; set; }

		protected override void ReadData(BamlBinaryReader reader, int size) {
			AssemblyId = reader.ReadUInt16();
			AssemblyFullName = reader.ReadString();
		}

		protected override void WriteData(BamlBinaryWriter writer) {
			writer.Write(AssemblyId);
			writer.Write(AssemblyFullName);
		}
	}

	internal class PropertyRecord : SizedBamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.Property; }
		}

		public ushort AttributeId { get; set; }
		public string Value { get; set; }

		protected override void ReadData(BamlBinaryReader reader, int size) {
			AttributeId = reader.ReadUInt16();
			Value = reader.ReadString();
		}

		protected override void WriteData(BamlBinaryWriter writer) {
			writer.Write(AttributeId);
			writer.Write(Value);
		}
	}

	internal class PropertyWithConverterRecord : PropertyRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.PropertyWithConverter; }
		}

		public ushort ConverterTypeId { get; set; }

		protected override void ReadData(BamlBinaryReader reader, int size) {
			base.ReadData(reader, size);
			ConverterTypeId = reader.ReadUInt16();
		}

		protected override void WriteData(BamlBinaryWriter writer) {
			base.WriteData(writer);
			writer.Write(ConverterTypeId);
		}
	}

	internal class PropertyCustomRecord : SizedBamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.PropertyCustom; }
		}

		public ushort AttributeId { get; set; }
		public ushort SerializerTypeId { get; set; }
		public byte[] Data { get; set; }

		protected override void ReadData(BamlBinaryReader reader, int size) {
			long pos = reader.BaseStream.Position;
			AttributeId = reader.ReadUInt16();
			SerializerTypeId = reader.ReadUInt16();
			Data = reader.ReadBytes(size - (int)(reader.BaseStream.Position - pos));
		}

		protected override void WriteData(BamlBinaryWriter writer) {
			writer.Write(AttributeId);
			writer.Write(SerializerTypeId);
			writer.Write(Data);
		}
	}

	internal class DefAttributeRecord : SizedBamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.DefAttribute; }
		}

		public string Value { get; set; }
		public ushort NameId { get; set; }

		protected override void ReadData(BamlBinaryReader reader, int size) {
			Value = reader.ReadString();
			NameId = reader.ReadUInt16();
		}

		protected override void WriteData(BamlBinaryWriter writer) {
			writer.Write(Value);
			writer.Write(NameId);
		}
	}

	internal class DefAttributeKeyStringRecord : SizedBamlRecord, IBamlDeferRecord {
		internal uint pos = 0xffffffff;

		public override BamlRecordType Type {
			get { return BamlRecordType.DefAttributeKeyString; }
		}

		public ushort ValueId { get; set; }
		public bool Shared { get; set; }
		public bool SharedSet { get; set; }

		public BamlRecord Record { get; set; }

		public void ReadDefer(BamlDocument doc, int index, Func<long, BamlRecord> resolve) {
			bool keys = true;
			do {
				switch (doc[index].Type) {
					case BamlRecordType.DefAttributeKeyString:
					case BamlRecordType.DefAttributeKeyType:
					case BamlRecordType.OptimizedStaticResource:
						keys = true;
						break;
					case BamlRecordType.StaticResourceStart:
						NavigateTree(doc, BamlRecordType.StaticResourceStart, BamlRecordType.StaticResourceEnd, ref index);
						keys = true;
						break;
					case BamlRecordType.KeyElementStart:
						NavigateTree(doc, BamlRecordType.KeyElementStart, BamlRecordType.KeyElementEnd, ref index);
						keys = true;
						break;
					default:
						keys = false;
						index--;
						break;
				}
				index++;
			} while (keys);
			Record = resolve(doc[index].Position + pos);
		}

		public void WriteDefer(BamlDocument doc, int index, BinaryWriter wtr) {
			bool keys = true;
			do {
				switch (doc[index].Type) {
					case BamlRecordType.DefAttributeKeyString:
					case BamlRecordType.DefAttributeKeyType:
					case BamlRecordType.OptimizedStaticResource:
						keys = true;
						break;
					case BamlRecordType.StaticResourceStart:
						NavigateTree(doc, BamlRecordType.StaticResourceStart, BamlRecordType.StaticResourceEnd, ref index);
						keys = true;
						break;
					case BamlRecordType.KeyElementStart:
						NavigateTree(doc, BamlRecordType.KeyElementStart, BamlRecordType.KeyElementEnd, ref index);
						keys = true;
						break;
					default:
						keys = false;
						index--;
						break;
				}
				index++;
			} while (keys);
			wtr.BaseStream.Seek(pos, SeekOrigin.Begin);
			wtr.Write((uint)(Record.Position - doc[index].Position));
		}

		protected override void ReadData(BamlBinaryReader reader, int size) {
			ValueId = reader.ReadUInt16();
			pos = reader.ReadUInt32();
			Shared = reader.ReadBoolean();
			SharedSet = reader.ReadBoolean();
		}

		protected override void WriteData(BamlBinaryWriter writer) {
			writer.Write(ValueId);
			pos = (uint)writer.BaseStream.Position;
			writer.Write((uint)0);
			writer.Write(Shared);
			writer.Write(SharedSet);
		}

		static void NavigateTree(BamlDocument doc, BamlRecordType start, BamlRecordType end, ref int index) {
			index++;
			while (true) //Assume there alway is a end
			{
				if (doc[index].Type == start)
					NavigateTree(doc, start, end, ref index);
				else if (doc[index].Type == end)
					return;
				index++;
			}
		}
	}

	internal class TypeInfoRecord : SizedBamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.TypeInfo; }
		}

		public ushort TypeId { get; set; }
		public ushort AssemblyId { get; set; }
		public string TypeFullName { get; set; }

		protected override void ReadData(BamlBinaryReader reader, int size) {
			TypeId = reader.ReadUInt16();
			AssemblyId = reader.ReadUInt16();
			TypeFullName = reader.ReadString();
		}

		protected override void WriteData(BamlBinaryWriter writer) {
			writer.Write(TypeId);
			writer.Write(AssemblyId);
			writer.Write(TypeFullName);
		}
	}

	internal class TypeSerializerInfoRecord : TypeInfoRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.TypeSerializerInfo; }
		}

		public ushort SerializerTypeId { get; set; }

		protected override void ReadData(BamlBinaryReader reader, int size) {
			base.ReadData(reader, size);
			SerializerTypeId = reader.ReadUInt16();
		}

		protected override void WriteData(BamlBinaryWriter writer) {
			base.WriteData(writer);
			writer.Write(SerializerTypeId);
		}
	}

	internal class AttributeInfoRecord : SizedBamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.AttributeInfo; }
		}

		public ushort AttributeId { get; set; }
		public ushort OwnerTypeId { get; set; }
		public byte AttributeUsage { get; set; }
		public string Name { get; set; }

		protected override void ReadData(BamlBinaryReader reader, int size) {
			AttributeId = reader.ReadUInt16();
			OwnerTypeId = reader.ReadUInt16();
			AttributeUsage = reader.ReadByte();
			Name = reader.ReadString();
		}

		protected override void WriteData(BamlBinaryWriter writer) {
			writer.Write(AttributeId);
			writer.Write(OwnerTypeId);
			writer.Write(AttributeUsage);
			writer.Write(Name);
		}
	}

	internal class StringInfoRecord : SizedBamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.StringInfo; }
		}

		public ushort StringId { get; set; }
		public string Value { get; set; }

		protected override void ReadData(BamlBinaryReader reader, int size) {
			StringId = reader.ReadUInt16();
			Value = reader.ReadString();
		}

		protected override void WriteData(BamlBinaryWriter writer) {
			writer.Write(StringId);
			writer.Write(Value);
		}
	}

	internal class TextRecord : SizedBamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.Text; }
		}

		public string Value { get; set; }

		protected override void ReadData(BamlBinaryReader reader, int size) {
			Value = reader.ReadString();
		}

		protected override void WriteData(BamlBinaryWriter writer) {
			writer.Write(Value);
		}
	}

	internal class TextWithConverterRecord : TextRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.TextWithConverter; }
		}

		public ushort ConverterTypeId { get; set; }

		protected override void ReadData(BamlBinaryReader reader, int size) {
			base.ReadData(reader, size);
			ConverterTypeId = reader.ReadUInt16();
		}

		protected override void WriteData(BamlBinaryWriter writer) {
			base.WriteData(writer);
			writer.Write(ConverterTypeId);
		}
	}

	internal class TextWithIdRecord : TextRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.TextWithId; }
		}

		public ushort ValueId { get; set; }

		protected override void ReadData(BamlBinaryReader reader, int size) {
			ValueId = reader.ReadUInt16();
		}

		protected override void WriteData(BamlBinaryWriter writer) {
			writer.Write(ValueId);
		}
	}

	internal class LiteralContentRecord : SizedBamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.LiteralContent; }
		}

		public string Value { get; set; }
		public uint Reserved0 { get; set; }
		public uint Reserved1 { get; set; }

		protected override void ReadData(BamlBinaryReader reader, int size) {
			Value = reader.ReadString();
			Reserved0 = reader.ReadUInt32();
			Reserved1 = reader.ReadUInt32();
		}

		protected override void WriteData(BamlBinaryWriter writer) {
			writer.Write(Value);
			writer.Write(Reserved0);
			writer.Write(Reserved1);
		}
	}

	internal class RoutedEventRecord : SizedBamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.RoutedEvent; }
		}

		public string Value { get; set; }
		public ushort AttributeId { get; set; }
		public uint Reserved1 { get; set; }

		protected override void ReadData(BamlBinaryReader reader, int size) {
			AttributeId = reader.ReadUInt16();
			Value = reader.ReadString();
		}

		protected override void WriteData(BamlBinaryWriter writer) {
			writer.Write(Value);
			writer.Write(AttributeId);
		}
	}

	internal class DocumentStartRecord : BamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.DocumentStart; }
		}

		public bool LoadAsync { get; set; }
		public uint MaxAsyncRecords { get; set; }
		public bool DebugBaml { get; set; }

		public override void Read(BamlBinaryReader reader) {
			LoadAsync = reader.ReadBoolean();
			MaxAsyncRecords = reader.ReadUInt32();
			DebugBaml = reader.ReadBoolean();
		}

		public override void Write(BamlBinaryWriter writer) {
			writer.Write(LoadAsync);
			writer.Write(MaxAsyncRecords);
			writer.Write(DebugBaml);
		}
	}

	internal class DocumentEndRecord : BamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.DocumentEnd; }
		}

		public override void Read(BamlBinaryReader reader) { }
		public override void Write(BamlBinaryWriter writer) { }
	}

	internal class ElementStartRecord : BamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.ElementStart; }
		}

		public ushort TypeId { get; set; }
		public byte Flags { get; set; }

		public override void Read(BamlBinaryReader reader) {
			TypeId = reader.ReadUInt16();
			Flags = reader.ReadByte();
		}

		public override void Write(BamlBinaryWriter writer) {
			writer.Write(TypeId);
			writer.Write(Flags);
		}
	}

	internal class ElementEndRecord : BamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.ElementEnd; }
		}

		public override void Read(BamlBinaryReader reader) { }
		public override void Write(BamlBinaryWriter writer) { }
	}

	internal class KeyElementStartRecord : DefAttributeKeyTypeRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.KeyElementStart; }
		}
	}

	internal class KeyElementEndRecord : BamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.KeyElementEnd; }
		}

		public override void Read(BamlBinaryReader reader) { }
		public override void Write(BamlBinaryWriter writer) { }
	}

	internal class ConnectionIdRecord : BamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.ConnectionId; }
		}

		public uint ConnectionId { get; set; }

		public override void Read(BamlBinaryReader reader) {
			ConnectionId = reader.ReadUInt32();
		}

		public override void Write(BamlBinaryWriter writer) {
			writer.Write(ConnectionId);
		}
	}

	internal class PropertyWithExtensionRecord : BamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.PropertyWithExtension; }
		}

		public ushort AttributeId { get; set; }
		public ushort Flags { get; set; }
		public ushort ValueId { get; set; }

		public override void Read(BamlBinaryReader reader) {
			AttributeId = reader.ReadUInt16();
			Flags = reader.ReadUInt16();
			ValueId = reader.ReadUInt16();
		}

		public override void Write(BamlBinaryWriter writer) {
			writer.Write(AttributeId);
			writer.Write(Flags);
			writer.Write(ValueId);
		}
	}

	internal class PropertyTypeReferenceRecord : PropertyComplexStartRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.PropertyTypeReference; }
		}

		public ushort TypeId { get; set; }

		public override void Read(BamlBinaryReader reader) {
			base.Read(reader);
			TypeId = reader.ReadUInt16();
		}

		public override void Write(BamlBinaryWriter writer) {
			base.Write(writer);
			writer.Write(TypeId);
		}
	}

	internal class PropertyStringReferenceRecord : PropertyComplexStartRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.PropertyStringReference; }
		}

		public ushort StringId { get; set; }

		public override void Read(BamlBinaryReader reader) {
			base.Read(reader);
			StringId = reader.ReadUInt16();
		}

		public override void Write(BamlBinaryWriter writer) {
			base.Write(writer);
			writer.Write(StringId);
		}
	}

	internal class PropertyWithStaticResourceIdRecord : StaticResourceIdRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.PropertyWithStaticResourceId; }
		}

		public ushort AttributeId { get; set; }

		public override void Read(BamlBinaryReader reader) {
			AttributeId = reader.ReadUInt16();
			base.Read(reader);
		}

		public override void Write(BamlBinaryWriter writer) {
			writer.Write(AttributeId);
			base.Write(writer);
		}
	}

	internal class ContentPropertyRecord : BamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.ContentProperty; }
		}

		public ushort AttributeId { get; set; }

		public override void Read(BamlBinaryReader reader) {
			AttributeId = reader.ReadUInt16();
		}

		public override void Write(BamlBinaryWriter writer) {
			writer.Write(AttributeId);
		}
	}

	internal class DefAttributeKeyTypeRecord : ElementStartRecord, IBamlDeferRecord {
		internal uint pos = 0xffffffff;

		public override BamlRecordType Type {
			get { return BamlRecordType.DefAttributeKeyType; }
		}

		public bool Shared { get; set; }
		public bool SharedSet { get; set; }

		public BamlRecord Record { get; set; }

		public void ReadDefer(BamlDocument doc, int index, Func<long, BamlRecord> resolve) {
			bool keys = true;
			do {
				switch (doc[index].Type) {
					case BamlRecordType.DefAttributeKeyString:
					case BamlRecordType.DefAttributeKeyType:
					case BamlRecordType.OptimizedStaticResource:
						keys = true;
						break;
					case BamlRecordType.StaticResourceStart:
						NavigateTree(doc, BamlRecordType.StaticResourceStart, BamlRecordType.StaticResourceEnd, ref index);
						keys = true;
						break;
					case BamlRecordType.KeyElementStart:
						NavigateTree(doc, BamlRecordType.KeyElementStart, BamlRecordType.KeyElementEnd, ref index);
						keys = true;
						break;
					default:
						keys = false;
						index--;
						break;
				}
				index++;
			} while (keys);
			Record = resolve(doc[index].Position + pos);
		}

		public void WriteDefer(BamlDocument doc, int index, BinaryWriter wtr) {
			bool keys = true;
			do {
				switch (doc[index].Type) {
					case BamlRecordType.DefAttributeKeyString:
					case BamlRecordType.DefAttributeKeyType:
					case BamlRecordType.OptimizedStaticResource:
						keys = true;
						break;
					case BamlRecordType.StaticResourceStart:
						NavigateTree(doc, BamlRecordType.StaticResourceStart, BamlRecordType.StaticResourceEnd, ref index);
						keys = true;
						break;
					case BamlRecordType.KeyElementStart:
						NavigateTree(doc, BamlRecordType.KeyElementStart, BamlRecordType.KeyElementEnd, ref index);
						keys = true;
						break;
					default:
						keys = false;
						index--;
						break;
				}
				index++;
			} while (keys);
			wtr.BaseStream.Seek(pos, SeekOrigin.Begin);
			wtr.Write((uint)(Record.Position - doc[index].Position));
		}

		public override void Read(BamlBinaryReader reader) {
			base.Read(reader);
			pos = reader.ReadUInt32();
			Shared = reader.ReadBoolean();
			SharedSet = reader.ReadBoolean();
		}

		public override void Write(BamlBinaryWriter writer) {
			base.Write(writer);
			pos = (uint)writer.BaseStream.Position;
			writer.Write((uint)0);
			writer.Write(Shared);
			writer.Write(SharedSet);
		}

		static void NavigateTree(BamlDocument doc, BamlRecordType start, BamlRecordType end, ref int index) {
			index++;
			while (true) {
				if (doc[index].Type == start)
					NavigateTree(doc, start, end, ref index);
				else if (doc[index].Type == end)
					return;
				index++;
			}
		}
	}

	internal class PropertyListStartRecord : PropertyComplexStartRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.PropertyListStart; }
		}
	}

	internal class PropertyListEndRecord : BamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.PropertyListEnd; }
		}

		public override void Read(BamlBinaryReader reader) { }
		public override void Write(BamlBinaryWriter writer) { }
	}

	internal class PropertyDictionaryStartRecord : PropertyComplexStartRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.PropertyDictionaryStart; }
		}
	}

	internal class PropertyDictionaryEndRecord : BamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.PropertyDictionaryEnd; }
		}

		public override void Read(BamlBinaryReader reader) { }
		public override void Write(BamlBinaryWriter writer) { }
	}

	internal class PropertyArrayStartRecord : PropertyComplexStartRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.PropertyArrayStart; }
		}
	}

	internal class PropertyArrayEndRecord : BamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.PropertyArrayEnd; }
		}

		public override void Read(BamlBinaryReader reader) { }
		public override void Write(BamlBinaryWriter writer) { }
	}

	internal class PropertyComplexStartRecord : BamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.PropertyComplexStart; }
		}

		public ushort AttributeId { get; set; }

		public override void Read(BamlBinaryReader reader) {
			AttributeId = reader.ReadUInt16();
		}

		public override void Write(BamlBinaryWriter writer) {
			writer.Write(AttributeId);
		}
	}

	internal class PropertyComplexEndRecord : BamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.PropertyComplexEnd; }
		}

		public override void Read(BamlBinaryReader reader) { }
		public override void Write(BamlBinaryWriter writer) { }
	}

	internal class ConstructorParametersStartRecord : BamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.ConstructorParametersStart; }
		}

		public override void Read(BamlBinaryReader reader) { }
		public override void Write(BamlBinaryWriter writer) { }
	}

	internal class ConstructorParametersEndRecord : BamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.ConstructorParametersEnd; }
		}

		public override void Read(BamlBinaryReader reader) { }
		public override void Write(BamlBinaryWriter writer) { }
	}

	internal class ConstructorParameterTypeRecord : BamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.ConstructorParameterType; }
		}

		public ushort TypeId { get; set; }

		public override void Read(BamlBinaryReader reader) {
			TypeId = reader.ReadUInt16();
		}

		public override void Write(BamlBinaryWriter writer) {
			writer.Write(TypeId);
		}
	}

	internal class DeferableContentStartRecord : BamlRecord, IBamlDeferRecord {
		long pos;
		internal uint size = 0xffffffff;

		public override BamlRecordType Type {
			get { return BamlRecordType.DeferableContentStart; }
		}

		public BamlRecord Record { get; set; }

		public void ReadDefer(BamlDocument doc, int index, Func<long, BamlRecord> resolve) {
			Record = resolve(pos + size);
		}

		public void WriteDefer(BamlDocument doc, int index, BinaryWriter wtr) {
			wtr.BaseStream.Seek(pos, SeekOrigin.Begin);
			wtr.Write((uint)(Record.Position - (pos + 4)));
		}

		public override void Read(BamlBinaryReader reader) {
			size = reader.ReadUInt32();
			pos = reader.BaseStream.Position;
		}

		public override void Write(BamlBinaryWriter writer) {
			pos = writer.BaseStream.Position;
			writer.Write((uint)0);
		}
	}

	internal class StaticResourceStartRecord : ElementStartRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.StaticResourceStart; }
		}
	}

	internal class StaticResourceEndRecord : BamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.StaticResourceEnd; }
		}

		public override void Read(BamlBinaryReader reader) { }
		public override void Write(BamlBinaryWriter writer) { }
	}

	internal class StaticResourceIdRecord : BamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.StaticResourceId; }
		}

		public ushort StaticResourceId { get; set; }

		public override void Read(BamlBinaryReader reader) {
			StaticResourceId = reader.ReadUInt16();
		}

		public override void Write(BamlBinaryWriter writer) {
			writer.Write(StaticResourceId);
		}
	}

	internal class OptimizedStaticResourceRecord : BamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.OptimizedStaticResource; }
		}

		public byte Flags { get; set; }
		public ushort ValueId { get; set; }

		public override void Read(BamlBinaryReader reader) {
			Flags = reader.ReadByte();
			ValueId = reader.ReadUInt16();
		}

		public override void Write(BamlBinaryWriter writer) {
			writer.Write(Flags);
			writer.Write(ValueId);
		}
	}

	internal class LineNumberAndPositionRecord : BamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.LineNumberAndPosition; }
		}

		public uint LineNumber { get; set; }
		public uint LinePosition { get; set; }

		public override void Read(BamlBinaryReader reader) {
			LineNumber = reader.ReadUInt32();
			LinePosition = reader.ReadUInt32();
		}

		public override void Write(BamlBinaryWriter writer) {
			writer.Write(LineNumber);
			writer.Write(LinePosition);
		}
	}

	internal class LinePositionRecord : BamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.LinePosition; }
		}

		public uint LinePosition { get; set; }

		public override void Read(BamlBinaryReader reader) {
			LinePosition = reader.ReadUInt32();
		}

		public override void Write(BamlBinaryWriter writer) {
			writer.Write(LinePosition);
		}
	}

	internal class NamedElementStartRecord : ElementStartRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.NamedElementStart; }
		}

		public string RuntimeName { get; set; }

		public override void Read(BamlBinaryReader reader) {
			TypeId = reader.ReadUInt16();
			RuntimeName = reader.ReadString();
		}

		public override void Write(BamlBinaryWriter writer) {
			writer.Write(TypeId);
			if (RuntimeName != null) {
				writer.Write(RuntimeName);
			}
		}
	}
}


================================================
File: Confuser.Renamer/BAML/IBAMLReference.cs
================================================
ï»¿using System;

namespace Confuser.Renamer.BAML {
	internal interface IBAMLReference {
		bool CanRename(string oldName, string newName);
		void Rename(string oldName, string newName);
	}
}


================================================
File: Confuser.Renamer/BAML/IKnownThings.cs
================================================
ï»¿using System;
using dnlib.DotNet;

namespace Confuser.Renamer.BAML {
	internal enum KnownTypes : short {
		Unknown = 0,
		AccessText,
		AdornedElementPlaceholder,
		Adorner,
		AdornerDecorator,
		AdornerLayer,
		AffineTransform3D,
		AmbientLight,
		AnchoredBlock,
		Animatable,
		AnimationClock,
		AnimationTimeline,
		Application,
		ArcSegment,
		ArrayExtension,
		AxisAngleRotation3D,
		BaseIListConverter,
		BeginStoryboard,
		BevelBitmapEffect,
		BezierSegment,
		Binding,
		BindingBase,
		BindingExpression,
		BindingExpressionBase,
		BindingListCollectionView,
		BitmapDecoder,
		BitmapEffect,
		BitmapEffectCollection,
		BitmapEffectGroup,
		BitmapEffectInput,
		BitmapEncoder,
		BitmapFrame,
		BitmapImage,
		BitmapMetadata,
		BitmapPalette,
		BitmapSource,
		Block,
		BlockUIContainer,
		BlurBitmapEffect,
		BmpBitmapDecoder,
		BmpBitmapEncoder,
		Bold,
		BoolIListConverter,
		Boolean,
		BooleanAnimationBase,
		BooleanAnimationUsingKeyFrames,
		BooleanConverter,
		BooleanKeyFrame,
		BooleanKeyFrameCollection,
		BooleanToVisibilityConverter,
		Border,
		BorderGapMaskConverter,
		Brush,
		BrushConverter,
		BulletDecorator,
		Button,
		ButtonBase,
		Byte,
		ByteAnimation,
		ByteAnimationBase,
		ByteAnimationUsingKeyFrames,
		ByteConverter,
		ByteKeyFrame,
		ByteKeyFrameCollection,
		CachedBitmap,
		Camera,
		Canvas,
		Char,
		CharAnimationBase,
		CharAnimationUsingKeyFrames,
		CharConverter,
		CharIListConverter,
		CharKeyFrame,
		CharKeyFrameCollection,
		CheckBox,
		Clock,
		ClockController,
		ClockGroup,
		CollectionContainer,
		CollectionView,
		CollectionViewSource,
		Color,
		ColorAnimation,
		ColorAnimationBase,
		ColorAnimationUsingKeyFrames,
		ColorConvertedBitmap,
		ColorConvertedBitmapExtension,
		ColorConverter,
		ColorKeyFrame,
		ColorKeyFrameCollection,
		ColumnDefinition,
		CombinedGeometry,
		ComboBox,
		ComboBoxItem,
		CommandConverter,
		ComponentResourceKey,
		ComponentResourceKeyConverter,
		CompositionTarget,
		Condition,
		ContainerVisual,
		ContentControl,
		ContentElement,
		ContentPresenter,
		ContentPropertyAttribute,
		ContentWrapperAttribute,
		ContextMenu,
		ContextMenuService,
		Control,
		ControlTemplate,
		ControllableStoryboardAction,
		CornerRadius,
		CornerRadiusConverter,
		CroppedBitmap,
		CultureInfo,
		CultureInfoConverter,
		CultureInfoIetfLanguageTagConverter,
		Cursor,
		CursorConverter,
		DashStyle,
		DataChangedEventManager,
		DataTemplate,
		DataTemplateKey,
		DataTrigger,
		DateTime,
		DateTimeConverter,
		DateTimeConverter2,
		Decimal,
		DecimalAnimation,
		DecimalAnimationBase,
		DecimalAnimationUsingKeyFrames,
		DecimalConverter,
		DecimalKeyFrame,
		DecimalKeyFrameCollection,
		Decorator,
		DefinitionBase,
		DependencyObject,
		DependencyProperty,
		DependencyPropertyConverter,
		DialogResultConverter,
		DiffuseMaterial,
		DirectionalLight,
		DiscreteBooleanKeyFrame,
		DiscreteByteKeyFrame,
		DiscreteCharKeyFrame,
		DiscreteColorKeyFrame,
		DiscreteDecimalKeyFrame,
		DiscreteDoubleKeyFrame,
		DiscreteInt16KeyFrame,
		DiscreteInt32KeyFrame,
		DiscreteInt64KeyFrame,
		DiscreteMatrixKeyFrame,
		DiscreteObjectKeyFrame,
		DiscretePoint3DKeyFrame,
		DiscretePointKeyFrame,
		DiscreteQuaternionKeyFrame,
		DiscreteRectKeyFrame,
		DiscreteRotation3DKeyFrame,
		DiscreteSingleKeyFrame,
		DiscreteSizeKeyFrame,
		DiscreteStringKeyFrame,
		DiscreteThicknessKeyFrame,
		DiscreteVector3DKeyFrame,
		DiscreteVectorKeyFrame,
		DockPanel,
		DocumentPageView,
		DocumentReference,
		DocumentViewer,
		DocumentViewerBase,
		Double,
		DoubleAnimation,
		DoubleAnimationBase,
		DoubleAnimationUsingKeyFrames,
		DoubleAnimationUsingPath,
		DoubleCollection,
		DoubleCollectionConverter,
		DoubleConverter,
		DoubleIListConverter,
		DoubleKeyFrame,
		DoubleKeyFrameCollection,
		Drawing,
		DrawingBrush,
		DrawingCollection,
		DrawingContext,
		DrawingGroup,
		DrawingImage,
		DrawingVisual,
		DropShadowBitmapEffect,
		Duration,
		DurationConverter,
		DynamicResourceExtension,
		DynamicResourceExtensionConverter,
		Ellipse,
		EllipseGeometry,
		EmbossBitmapEffect,
		EmissiveMaterial,
		EnumConverter,
		EventManager,
		EventSetter,
		EventTrigger,
		Expander,
		Expression,
		ExpressionConverter,
		Figure,
		FigureLength,
		FigureLengthConverter,
		FixedDocument,
		FixedDocumentSequence,
		FixedPage,
		Floater,
		FlowDocument,
		FlowDocumentPageViewer,
		FlowDocumentReader,
		FlowDocumentScrollViewer,
		FocusManager,
		FontFamily,
		FontFamilyConverter,
		FontSizeConverter,
		FontStretch,
		FontStretchConverter,
		FontStyle,
		FontStyleConverter,
		FontWeight,
		FontWeightConverter,
		FormatConvertedBitmap,
		Frame,
		FrameworkContentElement,
		FrameworkElement,
		FrameworkElementFactory,
		FrameworkPropertyMetadata,
		FrameworkPropertyMetadataOptions,
		FrameworkRichTextComposition,
		FrameworkTemplate,
		FrameworkTextComposition,
		Freezable,
		GeneralTransform,
		GeneralTransformCollection,
		GeneralTransformGroup,
		Geometry,
		Geometry3D,
		GeometryCollection,
		GeometryConverter,
		GeometryDrawing,
		GeometryGroup,
		GeometryModel3D,
		GestureRecognizer,
		GifBitmapDecoder,
		GifBitmapEncoder,
		GlyphRun,
		GlyphRunDrawing,
		GlyphTypeface,
		Glyphs,
		GradientBrush,
		GradientStop,
		GradientStopCollection,
		Grid,
		GridLength,
		GridLengthConverter,
		GridSplitter,
		GridView,
		GridViewColumn,
		GridViewColumnHeader,
		GridViewHeaderRowPresenter,
		GridViewRowPresenter,
		GridViewRowPresenterBase,
		GroupBox,
		GroupItem,
		Guid,
		GuidConverter,
		GuidelineSet,
		HeaderedContentControl,
		HeaderedItemsControl,
		HierarchicalDataTemplate,
		HostVisual,
		Hyperlink,
		IAddChild,
		IAddChildInternal,
		ICommand,
		IComponentConnector,
		INameScope,
		IStyleConnector,
		IconBitmapDecoder,
		Image,
		ImageBrush,
		ImageDrawing,
		ImageMetadata,
		ImageSource,
		ImageSourceConverter,
		InPlaceBitmapMetadataWriter,
		InkCanvas,
		InkPresenter,
		Inline,
		InlineCollection,
		InlineUIContainer,
		InputBinding,
		InputDevice,
		InputLanguageManager,
		InputManager,
		InputMethod,
		InputScope,
		InputScopeConverter,
		InputScopeName,
		InputScopeNameConverter,
		Int16,
		Int16Animation,
		Int16AnimationBase,
		Int16AnimationUsingKeyFrames,
		Int16Converter,
		Int16KeyFrame,
		Int16KeyFrameCollection,
		Int32,
		Int32Animation,
		Int32AnimationBase,
		Int32AnimationUsingKeyFrames,
		Int32Collection,
		Int32CollectionConverter,
		Int32Converter,
		Int32KeyFrame,
		Int32KeyFrameCollection,
		Int32Rect,
		Int32RectConverter,
		Int64,
		Int64Animation,
		Int64AnimationBase,
		Int64AnimationUsingKeyFrames,
		Int64Converter,
		Int64KeyFrame,
		Int64KeyFrameCollection,
		Italic,
		ItemCollection,
		ItemsControl,
		ItemsPanelTemplate,
		ItemsPresenter,
		JournalEntry,
		JournalEntryListConverter,
		JournalEntryUnifiedViewConverter,
		JpegBitmapDecoder,
		JpegBitmapEncoder,
		KeyBinding,
		KeyConverter,
		KeyGesture,
		KeyGestureConverter,
		KeySpline,
		KeySplineConverter,
		KeyTime,
		KeyTimeConverter,
		KeyboardDevice,
		Label,
		LateBoundBitmapDecoder,
		LengthConverter,
		Light,
		Line,
		LineBreak,
		LineGeometry,
		LineSegment,
		LinearByteKeyFrame,
		LinearColorKeyFrame,
		LinearDecimalKeyFrame,
		LinearDoubleKeyFrame,
		LinearGradientBrush,
		LinearInt16KeyFrame,
		LinearInt32KeyFrame,
		LinearInt64KeyFrame,
		LinearPoint3DKeyFrame,
		LinearPointKeyFrame,
		LinearQuaternionKeyFrame,
		LinearRectKeyFrame,
		LinearRotation3DKeyFrame,
		LinearSingleKeyFrame,
		LinearSizeKeyFrame,
		LinearThicknessKeyFrame,
		LinearVector3DKeyFrame,
		LinearVectorKeyFrame,
		List,
		ListBox,
		ListBoxItem,
		ListCollectionView,
		ListItem,
		ListView,
		ListViewItem,
		Localization,
		LostFocusEventManager,
		MarkupExtension,
		Material,
		MaterialCollection,
		MaterialGroup,
		Matrix,
		Matrix3D,
		Matrix3DConverter,
		MatrixAnimationBase,
		MatrixAnimationUsingKeyFrames,
		MatrixAnimationUsingPath,
		MatrixCamera,
		MatrixConverter,
		MatrixKeyFrame,
		MatrixKeyFrameCollection,
		MatrixTransform,
		MatrixTransform3D,
		MediaClock,
		MediaElement,
		MediaPlayer,
		MediaTimeline,
		Menu,
		MenuBase,
		MenuItem,
		MenuScrollingVisibilityConverter,
		MeshGeometry3D,
		Model3D,
		Model3DCollection,
		Model3DGroup,
		ModelVisual3D,
		ModifierKeysConverter,
		MouseActionConverter,
		MouseBinding,
		MouseDevice,
		MouseGesture,
		MouseGestureConverter,
		MultiBinding,
		MultiBindingExpression,
		MultiDataTrigger,
		MultiTrigger,
		NameScope,
		NavigationWindow,
		NullExtension,
		NullableBoolConverter,
		NullableConverter,
		NumberSubstitution,
		Object,
		ObjectAnimationBase,
		ObjectAnimationUsingKeyFrames,
		ObjectDataProvider,
		ObjectKeyFrame,
		ObjectKeyFrameCollection,
		OrthographicCamera,
		OuterGlowBitmapEffect,
		Page,
		PageContent,
		PageFunctionBase,
		Panel,
		Paragraph,
		ParallelTimeline,
		ParserContext,
		PasswordBox,
		Path,
		PathFigure,
		PathFigureCollection,
		PathFigureCollectionConverter,
		PathGeometry,
		PathSegment,
		PathSegmentCollection,
		PauseStoryboard,
		Pen,
		PerspectiveCamera,
		PixelFormat,
		PixelFormatConverter,
		PngBitmapDecoder,
		PngBitmapEncoder,
		Point,
		Point3D,
		Point3DAnimation,
		Point3DAnimationBase,
		Point3DAnimationUsingKeyFrames,
		Point3DCollection,
		Point3DCollectionConverter,
		Point3DConverter,
		Point3DKeyFrame,
		Point3DKeyFrameCollection,
		Point4D,
		Point4DConverter,
		PointAnimation,
		PointAnimationBase,
		PointAnimationUsingKeyFrames,
		PointAnimationUsingPath,
		PointCollection,
		PointCollectionConverter,
		PointConverter,
		PointIListConverter,
		PointKeyFrame,
		PointKeyFrameCollection,
		PointLight,
		PointLightBase,
		PolyBezierSegment,
		PolyLineSegment,
		PolyQuadraticBezierSegment,
		Polygon,
		Polyline,
		Popup,
		PresentationSource,
		PriorityBinding,
		PriorityBindingExpression,
		ProgressBar,
		ProjectionCamera,
		PropertyPath,
		PropertyPathConverter,
		QuadraticBezierSegment,
		Quaternion,
		QuaternionAnimation,
		QuaternionAnimationBase,
		QuaternionAnimationUsingKeyFrames,
		QuaternionConverter,
		QuaternionKeyFrame,
		QuaternionKeyFrameCollection,
		QuaternionRotation3D,
		RadialGradientBrush,
		RadioButton,
		RangeBase,
		Rect,
		Rect3D,
		Rect3DConverter,
		RectAnimation,
		RectAnimationBase,
		RectAnimationUsingKeyFrames,
		RectConverter,
		RectKeyFrame,
		RectKeyFrameCollection,
		Rectangle,
		RectangleGeometry,
		RelativeSource,
		RemoveStoryboard,
		RenderOptions,
		RenderTargetBitmap,
		RepeatBehavior,
		RepeatBehaviorConverter,
		RepeatButton,
		ResizeGrip,
		ResourceDictionary,
		ResourceKey,
		ResumeStoryboard,
		RichTextBox,
		RotateTransform,
		RotateTransform3D,
		Rotation3D,
		Rotation3DAnimation,
		Rotation3DAnimationBase,
		Rotation3DAnimationUsingKeyFrames,
		Rotation3DKeyFrame,
		Rotation3DKeyFrameCollection,
		RoutedCommand,
		RoutedEvent,
		RoutedEventConverter,
		RoutedUICommand,
		RoutingStrategy,
		RowDefinition,
		Run,
		RuntimeNamePropertyAttribute,
		SByte,
		SByteConverter,
		ScaleTransform,
		ScaleTransform3D,
		ScrollBar,
		ScrollContentPresenter,
		ScrollViewer,
		Section,
		SeekStoryboard,
		Selector,
		Separator,
		SetStoryboardSpeedRatio,
		Setter,
		SetterBase,
		Shape,
		Single,
		SingleAnimation,
		SingleAnimationBase,
		SingleAnimationUsingKeyFrames,
		SingleConverter,
		SingleKeyFrame,
		SingleKeyFrameCollection,
		Size,
		Size3D,
		Size3DConverter,
		SizeAnimation,
		SizeAnimationBase,
		SizeAnimationUsingKeyFrames,
		SizeConverter,
		SizeKeyFrame,
		SizeKeyFrameCollection,
		SkewTransform,
		SkipStoryboardToFill,
		Slider,
		SolidColorBrush,
		SoundPlayerAction,
		Span,
		SpecularMaterial,
		SpellCheck,
		SplineByteKeyFrame,
		SplineColorKeyFrame,
		SplineDecimalKeyFrame,
		SplineDoubleKeyFrame,
		SplineInt16KeyFrame,
		SplineInt32KeyFrame,
		SplineInt64KeyFrame,
		SplinePoint3DKeyFrame,
		SplinePointKeyFrame,
		SplineQuaternionKeyFrame,
		SplineRectKeyFrame,
		SplineRotation3DKeyFrame,
		SplineSingleKeyFrame,
		SplineSizeKeyFrame,
		SplineThicknessKeyFrame,
		SplineVector3DKeyFrame,
		SplineVectorKeyFrame,
		SpotLight,
		StackPanel,
		StaticExtension,
		StaticResourceExtension,
		StatusBar,
		StatusBarItem,
		StickyNoteControl,
		StopStoryboard,
		Storyboard,
		StreamGeometry,
		StreamGeometryContext,
		StreamResourceInfo,
		String,
		StringAnimationBase,
		StringAnimationUsingKeyFrames,
		StringConverter,
		StringKeyFrame,
		StringKeyFrameCollection,
		StrokeCollection,
		StrokeCollectionConverter,
		Style,
		Stylus,
		StylusDevice,
		TabControl,
		TabItem,
		TabPanel,
		Table,
		TableCell,
		TableColumn,
		TableRow,
		TableRowGroup,
		TabletDevice,
		TemplateBindingExpression,
		TemplateBindingExpressionConverter,
		TemplateBindingExtension,
		TemplateBindingExtensionConverter,
		TemplateKey,
		TemplateKeyConverter,
		TextBlock,
		TextBox,
		TextBoxBase,
		TextComposition,
		TextCompositionManager,
		TextDecoration,
		TextDecorationCollection,
		TextDecorationCollectionConverter,
		TextEffect,
		TextEffectCollection,
		TextElement,
		TextSearch,
		ThemeDictionaryExtension,
		Thickness,
		ThicknessAnimation,
		ThicknessAnimationBase,
		ThicknessAnimationUsingKeyFrames,
		ThicknessConverter,
		ThicknessKeyFrame,
		ThicknessKeyFrameCollection,
		Thumb,
		TickBar,
		TiffBitmapDecoder,
		TiffBitmapEncoder,
		TileBrush,
		TimeSpan,
		TimeSpanConverter,
		Timeline,
		TimelineCollection,
		TimelineGroup,
		ToggleButton,
		ToolBar,
		ToolBarOverflowPanel,
		ToolBarPanel,
		ToolBarTray,
		ToolTip,
		ToolTipService,
		Track,
		Transform,
		Transform3D,
		Transform3DCollection,
		Transform3DGroup,
		TransformCollection,
		TransformConverter,
		TransformGroup,
		TransformedBitmap,
		TranslateTransform,
		TranslateTransform3D,
		TreeView,
		TreeViewItem,
		Trigger,
		TriggerAction,
		TriggerBase,
		TypeExtension,
		TypeTypeConverter,
		Typography,
		UIElement,
		UInt16,
		UInt16Converter,
		UInt32,
		UInt32Converter,
		UInt64,
		UInt64Converter,
		UShortIListConverter,
		Underline,
		UniformGrid,
		Uri,
		UriTypeConverter,
		UserControl,
		Validation,
		Vector,
		Vector3D,
		Vector3DAnimation,
		Vector3DAnimationBase,
		Vector3DAnimationUsingKeyFrames,
		Vector3DCollection,
		Vector3DCollectionConverter,
		Vector3DConverter,
		Vector3DKeyFrame,
		Vector3DKeyFrameCollection,
		VectorAnimation,
		VectorAnimationBase,
		VectorAnimationUsingKeyFrames,
		VectorCollection,
		VectorCollectionConverter,
		VectorConverter,
		VectorKeyFrame,
		VectorKeyFrameCollection,
		VideoDrawing,
		ViewBase,
		Viewbox,
		Viewport3D,
		Viewport3DVisual,
		VirtualizingPanel,
		VirtualizingStackPanel,
		Visual,
		Visual3D,
		VisualBrush,
		VisualTarget,
		WeakEventManager,
		WhitespaceSignificantCollectionAttribute,
		Window,
		WmpBitmapDecoder,
		WmpBitmapEncoder,
		WrapPanel,
		WriteableBitmap,
		XamlBrushSerializer,
		XamlInt32CollectionSerializer,
		XamlPathDataSerializer,
		XamlPoint3DCollectionSerializer,
		XamlPointCollectionSerializer,
		XamlReader,
		XamlStyleSerializer,
		XamlTemplateSerializer,
		XamlVector3DCollectionSerializer,
		XamlWriter,
		XmlDataProvider,
		XmlLangPropertyAttribute,
		XmlLanguage,
		XmlLanguageConverter,
		XmlNamespaceMapping,
		ZoomPercentageConverter
	}

	internal enum KnownProperties : short {
		Unknown = 0,
		AccessText_Text,
		BeginStoryboard_Storyboard,
		BitmapEffectGroup_Children,
		Border_Background,
		Border_BorderBrush,
		Border_BorderThickness,
		ButtonBase_Command,
		ButtonBase_CommandParameter,
		ButtonBase_CommandTarget,
		ButtonBase_IsPressed,
		ColumnDefinition_MaxWidth,
		ColumnDefinition_MinWidth,
		ColumnDefinition_Width,
		ContentControl_Content,
		ContentControl_ContentTemplate,
		ContentControl_ContentTemplateSelector,
		ContentControl_HasContent,
		ContentElement_Focusable,
		ContentPresenter_Content,
		ContentPresenter_ContentSource,
		ContentPresenter_ContentTemplate,
		ContentPresenter_ContentTemplateSelector,
		ContentPresenter_RecognizesAccessKey,
		Control_Background,
		Control_BorderBrush,
		Control_BorderThickness,
		Control_FontFamily,
		Control_FontSize,
		Control_FontStretch,
		Control_FontStyle,
		Control_FontWeight,
		Control_Foreground,
		Control_HorizontalContentAlignment,
		Control_IsTabStop,
		Control_Padding,
		Control_TabIndex,
		Control_Template,
		Control_VerticalContentAlignment,
		DockPanel_Dock,
		DockPanel_LastChildFill,
		DocumentViewerBase_Document,
		DrawingGroup_Children,
		FlowDocumentReader_Document,
		FlowDocumentScrollViewer_Document,
		FrameworkContentElement_Style,
		FrameworkElement_FlowDirection,
		FrameworkElement_Height,
		FrameworkElement_HorizontalAlignment,
		FrameworkElement_Margin,
		FrameworkElement_MaxHeight,
		FrameworkElement_MaxWidth,
		FrameworkElement_MinHeight,
		FrameworkElement_MinWidth,
		FrameworkElement_Name,
		FrameworkElement_Style,
		FrameworkElement_VerticalAlignment,
		FrameworkElement_Width,
		GeneralTransformGroup_Children,
		GeometryGroup_Children,
		GradientBrush_GradientStops,
		Grid_Column,
		Grid_ColumnSpan,
		Grid_Row,
		Grid_RowSpan,
		GridViewColumn_Header,
		HeaderedContentControl_HasHeader,
		HeaderedContentControl_Header,
		HeaderedContentControl_HeaderTemplate,
		HeaderedContentControl_HeaderTemplateSelector,
		HeaderedItemsControl_HasHeader,
		HeaderedItemsControl_Header,
		HeaderedItemsControl_HeaderTemplate,
		HeaderedItemsControl_HeaderTemplateSelector,
		Hyperlink_NavigateUri,
		Image_Source,
		Image_Stretch,
		ItemsControl_ItemContainerStyle,
		ItemsControl_ItemContainerStyleSelector,
		ItemsControl_ItemTemplate,
		ItemsControl_ItemTemplateSelector,
		ItemsControl_ItemsPanel,
		ItemsControl_ItemsSource,
		MaterialGroup_Children,
		Model3DGroup_Children,
		Page_Content,
		Panel_Background,
		Path_Data,
		PathFigure_Segments,
		PathGeometry_Figures,
		Popup_Child,
		Popup_IsOpen,
		Popup_Placement,
		Popup_PopupAnimation,
		RowDefinition_Height,
		RowDefinition_MaxHeight,
		RowDefinition_MinHeight,
		ScrollViewer_CanContentScroll,
		ScrollViewer_HorizontalScrollBarVisibility,
		ScrollViewer_VerticalScrollBarVisibility,
		Shape_Fill,
		Shape_Stroke,
		Shape_StrokeThickness,
		TextBlock_Background,
		TextBlock_FontFamily,
		TextBlock_FontSize,
		TextBlock_FontStretch,
		TextBlock_FontStyle,
		TextBlock_FontWeight,
		TextBlock_Foreground,
		TextBlock_Text,
		TextBlock_TextDecorations,
		TextBlock_TextTrimming,
		TextBlock_TextWrapping,
		TextBox_Text,
		TextElement_Background,
		TextElement_FontFamily,
		TextElement_FontSize,
		TextElement_FontStretch,
		TextElement_FontStyle,
		TextElement_FontWeight,
		TextElement_Foreground,
		TimelineGroup_Children,
		Track_IsDirectionReversed,
		Track_Maximum,
		Track_Minimum,
		Track_Orientation,
		Track_Value,
		Track_ViewportSize,
		Transform3DGroup_Children,
		TransformGroup_Children,
		UIElement_ClipToBounds,
		UIElement_Focusable,
		UIElement_IsEnabled,
		UIElement_RenderTransform,
		UIElement_Visibility,
		Viewport3D_Children,
		MaxDependencyProperty,
		AdornedElementPlaceholder_Child,
		AdornerDecorator_Child,
		AnchoredBlock_Blocks,
		ArrayExtension_Items,
		BlockUIContainer_Child,
		Bold_Inlines,
		BooleanAnimationUsingKeyFrames_KeyFrames,
		Border_Child,
		BulletDecorator_Child,
		Button_Content,
		ButtonBase_Content,
		ByteAnimationUsingKeyFrames_KeyFrames,
		Canvas_Children,
		CharAnimationUsingKeyFrames_KeyFrames,
		CheckBox_Content,
		ColorAnimationUsingKeyFrames_KeyFrames,
		ComboBox_Items,
		ComboBoxItem_Content,
		ContextMenu_Items,
		ControlTemplate_VisualTree,
		DataTemplate_VisualTree,
		DataTrigger_Setters,
		DecimalAnimationUsingKeyFrames_KeyFrames,
		Decorator_Child,
		DockPanel_Children,
		DocumentViewer_Document,
		DoubleAnimationUsingKeyFrames_KeyFrames,
		EventTrigger_Actions,
		Expander_Content,
		Figure_Blocks,
		FixedDocument_Pages,
		FixedDocumentSequence_References,
		FixedPage_Children,
		Floater_Blocks,
		FlowDocument_Blocks,
		FlowDocumentPageViewer_Document,
		FrameworkTemplate_VisualTree,
		Grid_Children,
		GridView_Columns,
		GridViewColumnHeader_Content,
		GroupBox_Content,
		GroupItem_Content,
		HeaderedContentControl_Content,
		HeaderedItemsControl_Items,
		HierarchicalDataTemplate_VisualTree,
		Hyperlink_Inlines,
		InkCanvas_Children,
		InkPresenter_Child,
		InlineUIContainer_Child,
		InputScopeName_NameValue,
		Int16AnimationUsingKeyFrames_KeyFrames,
		Int32AnimationUsingKeyFrames_KeyFrames,
		Int64AnimationUsingKeyFrames_KeyFrames,
		Italic_Inlines,
		ItemsControl_Items,
		ItemsPanelTemplate_VisualTree,
		Label_Content,
		LinearGradientBrush_GradientStops,
		List_ListItems,
		ListBox_Items,
		ListBoxItem_Content,
		ListItem_Blocks,
		ListView_Items,
		ListViewItem_Content,
		MatrixAnimationUsingKeyFrames_KeyFrames,
		Menu_Items,
		MenuBase_Items,
		MenuItem_Items,
		ModelVisual3D_Children,
		MultiBinding_Bindings,
		MultiDataTrigger_Setters,
		MultiTrigger_Setters,
		ObjectAnimationUsingKeyFrames_KeyFrames,
		PageContent_Child,
		PageFunctionBase_Content,
		Panel_Children,
		Paragraph_Inlines,
		ParallelTimeline_Children,
		Point3DAnimationUsingKeyFrames_KeyFrames,
		PointAnimationUsingKeyFrames_KeyFrames,
		PriorityBinding_Bindings,
		QuaternionAnimationUsingKeyFrames_KeyFrames,
		RadialGradientBrush_GradientStops,
		RadioButton_Content,
		RectAnimationUsingKeyFrames_KeyFrames,
		RepeatButton_Content,
		RichTextBox_Document,
		Rotation3DAnimationUsingKeyFrames_KeyFrames,
		Run_Text,
		ScrollViewer_Content,
		Section_Blocks,
		Selector_Items,
		SingleAnimationUsingKeyFrames_KeyFrames,
		SizeAnimationUsingKeyFrames_KeyFrames,
		Span_Inlines,
		StackPanel_Children,
		StatusBar_Items,
		StatusBarItem_Content,
		Storyboard_Children,
		StringAnimationUsingKeyFrames_KeyFrames,
		Style_Setters,
		TabControl_Items,
		TabItem_Content,
		TabPanel_Children,
		Table_RowGroups,
		TableCell_Blocks,
		TableRow_Cells,
		TableRowGroup_Rows,
		TextBlock_Inlines,
		ThicknessAnimationUsingKeyFrames_KeyFrames,
		ToggleButton_Content,
		ToolBar_Items,
		ToolBarOverflowPanel_Children,
		ToolBarPanel_Children,
		ToolBarTray_ToolBars,
		ToolTip_Content,
		TreeView_Items,
		TreeViewItem_Items,
		Trigger_Setters,
		Underline_Inlines,
		UniformGrid_Children,
		UserControl_Content,
		Vector3DAnimationUsingKeyFrames_KeyFrames,
		VectorAnimationUsingKeyFrames_KeyFrames,
		Viewbox_Child,
		Viewport3DVisual_Children,
		VirtualizingPanel_Children,
		VirtualizingStackPanel_Children,
		Window_Content,
		WrapPanel_Children,
		XmlDataProvider_XmlSerializer
	}

	internal interface IKnownThings {
		Func<KnownTypes, TypeDef> Types { get; }
		Func<KnownProperties, Tuple<KnownTypes, PropertyDef, TypeDef>> Properties { get; }
		AssemblyDef FrameworkAssembly { get; }
	}
}


================================================
File: Confuser.Renamer/BAML/KnownThingsv3.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using Confuser.Core;
using dnlib.DotNet;

namespace Confuser.Renamer.BAML {
	internal class KnownThingsv3 : IKnownThings {
		readonly Dictionary<int, AssemblyDef> assemblies;
		readonly ConfuserContext context;
		readonly Dictionary<KnownProperties, Tuple<KnownTypes, PropertyDef, TypeDef>> properties;
		readonly Dictionary<KnownTypes, TypeDef> types;

		public KnownThingsv3(ConfuserContext context, ModuleDefMD initMod) {
			this.context = context;

			assemblies = new Dictionary<int, AssemblyDef>();
			types = new Dictionary<KnownTypes, TypeDef>();
			properties = new Dictionary<KnownProperties, Tuple<KnownTypes, PropertyDef, TypeDef>>();

			InitAssemblies(initMod);
			InitTypes();
			InitProperties();
		}

		public Func<KnownTypes, TypeDef> Types {
			get { return type => types[type]; }
		}

		public Func<KnownProperties, Tuple<KnownTypes, PropertyDef, TypeDef>> Properties {
			get { return property => properties[property]; }
		}

		public AssemblyDef FrameworkAssembly {
			get { return assemblies[0]; }
		}

		Tuple<KnownTypes, PropertyDef, TypeDef> InitProperty(KnownTypes parent, string propertyName, TypeDef propertyType) {
			if (propertyName != null)
				return Tuple.Create(parent, types[parent].FindProperty(propertyName), propertyType);
			return Tuple.Create(parent, (PropertyDef)null, propertyType);
		}

		// Following codes are auto-generated, do not modify.

		void InitAssemblies(ModuleDefMD initMod) {
			assemblies[0] = context.Resolver.ResolveThrow("PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35", initMod);
			assemblies[1] = context.Resolver.ResolveThrow("PresentationCore, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35", initMod);
			assemblies[2] = context.Resolver.ResolveThrow("mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089", initMod);
			assemblies[3] = context.Resolver.ResolveThrow("System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089", initMod);
			assemblies[4] = context.Resolver.ResolveThrow("WindowsBase, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35", initMod);
			assemblies[5] = context.Resolver.ResolveThrow("System.Xml, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089", initMod);
		}

		void InitTypes() {
			types[KnownTypes.AccessText] = assemblies[0].Find("System.Windows.Controls.AccessText", true);
			types[KnownTypes.AdornedElementPlaceholder] = assemblies[0].Find("System.Windows.Controls.AdornedElementPlaceholder", true);
			types[KnownTypes.Adorner] = assemblies[0].Find("System.Windows.Documents.Adorner", true);
			types[KnownTypes.AdornerDecorator] = assemblies[0].Find("System.Windows.Documents.AdornerDecorator", true);
			types[KnownTypes.AdornerLayer] = assemblies[0].Find("System.Windows.Documents.AdornerLayer", true);
			types[KnownTypes.AffineTransform3D] = assemblies[1].Find("System.Windows.Media.Media3D.AffineTransform3D", true);
			types[KnownTypes.AmbientLight] = assemblies[1].Find("System.Windows.Media.Media3D.AmbientLight", true);
			types[KnownTypes.AnchoredBlock] = assemblies[0].Find("System.Windows.Documents.AnchoredBlock", true);
			types[KnownTypes.Animatable] = assemblies[1].Find("System.Windows.Media.Animation.Animatable", true);
			types[KnownTypes.AnimationClock] = assemblies[1].Find("System.Windows.Media.Animation.AnimationClock", true);
			types[KnownTypes.AnimationTimeline] = assemblies[1].Find("System.Windows.Media.Animation.AnimationTimeline", true);
			types[KnownTypes.Application] = assemblies[0].Find("System.Windows.Application", true);
			types[KnownTypes.ArcSegment] = assemblies[1].Find("System.Windows.Media.ArcSegment", true);
			types[KnownTypes.ArrayExtension] = assemblies[0].Find("System.Windows.Markup.ArrayExtension", true);
			types[KnownTypes.AxisAngleRotation3D] = assemblies[1].Find("System.Windows.Media.Media3D.AxisAngleRotation3D", true);
			types[KnownTypes.BaseIListConverter] = assemblies[1].Find("System.Windows.Media.Converters.BaseIListConverter", true);
			types[KnownTypes.BeginStoryboard] = assemblies[0].Find("System.Windows.Media.Animation.BeginStoryboard", true);
			types[KnownTypes.BevelBitmapEffect] = assemblies[1].Find("System.Windows.Media.Effects.BevelBitmapEffect", true);
			types[KnownTypes.BezierSegment] = assemblies[1].Find("System.Windows.Media.BezierSegment", true);
			types[KnownTypes.Binding] = assemblies[0].Find("System.Windows.Data.Binding", true);
			types[KnownTypes.BindingBase] = assemblies[0].Find("System.Windows.Data.BindingBase", true);
			types[KnownTypes.BindingExpression] = assemblies[0].Find("System.Windows.Data.BindingExpression", true);
			types[KnownTypes.BindingExpressionBase] = assemblies[0].Find("System.Windows.Data.BindingExpressionBase", true);
			types[KnownTypes.BindingListCollectionView] = assemblies[0].Find("System.Windows.Data.BindingListCollectionView", true);
			types[KnownTypes.BitmapDecoder] = assemblies[1].Find("System.Windows.Media.Imaging.BitmapDecoder", true);
			types[KnownTypes.BitmapEffect] = assemblies[1].Find("System.Windows.Media.Effects.BitmapEffect", true);
			types[KnownTypes.BitmapEffectCollection] = assemblies[1].Find("System.Windows.Media.Effects.BitmapEffectCollection", true);
			types[KnownTypes.BitmapEffectGroup] = assemblies[1].Find("System.Windows.Media.Effects.BitmapEffectGroup", true);
			types[KnownTypes.BitmapEffectInput] = assemblies[1].Find("System.Windows.Media.Effects.BitmapEffectInput", true);
			types[KnownTypes.BitmapEncoder] = assemblies[1].Find("System.Windows.Media.Imaging.BitmapEncoder", true);
			types[KnownTypes.BitmapFrame] = assemblies[1].Find("System.Windows.Media.Imaging.BitmapFrame", true);
			types[KnownTypes.BitmapImage] = assemblies[1].Find("System.Windows.Media.Imaging.BitmapImage", true);
			types[KnownTypes.BitmapMetadata] = assemblies[1].Find("System.Windows.Media.Imaging.BitmapMetadata", true);
			types[KnownTypes.BitmapPalette] = assemblies[1].Find("System.Windows.Media.Imaging.BitmapPalette", true);
			types[KnownTypes.BitmapSource] = assemblies[1].Find("System.Windows.Media.Imaging.BitmapSource", true);
			types[KnownTypes.Block] = assemblies[0].Find("System.Windows.Documents.Block", true);
			types[KnownTypes.BlockUIContainer] = assemblies[0].Find("System.Windows.Documents.BlockUIContainer", true);
			types[KnownTypes.BlurBitmapEffect] = assemblies[1].Find("System.Windows.Media.Effects.BlurBitmapEffect", true);
			types[KnownTypes.BmpBitmapDecoder] = assemblies[1].Find("System.Windows.Media.Imaging.BmpBitmapDecoder", true);
			types[KnownTypes.BmpBitmapEncoder] = assemblies[1].Find("System.Windows.Media.Imaging.BmpBitmapEncoder", true);
			types[KnownTypes.Bold] = assemblies[0].Find("System.Windows.Documents.Bold", true);
			types[KnownTypes.BoolIListConverter] = assemblies[1].Find("System.Windows.Media.Converters.BoolIListConverter", true);
			types[KnownTypes.Boolean] = assemblies[2].Find("System.Boolean", true);
			types[KnownTypes.BooleanAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.BooleanAnimationBase", true);
			types[KnownTypes.BooleanAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.BooleanAnimationUsingKeyFrames", true);
			types[KnownTypes.BooleanConverter] = assemblies[3].Find("System.ComponentModel.BooleanConverter", true);
			types[KnownTypes.BooleanKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.BooleanKeyFrame", true);
			types[KnownTypes.BooleanKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.BooleanKeyFrameCollection", true);
			types[KnownTypes.BooleanToVisibilityConverter] = assemblies[0].Find("System.Windows.Controls.BooleanToVisibilityConverter", true);
			types[KnownTypes.Border] = assemblies[0].Find("System.Windows.Controls.Border", true);
			types[KnownTypes.BorderGapMaskConverter] = assemblies[0].Find("System.Windows.Controls.BorderGapMaskConverter", true);
			types[KnownTypes.Brush] = assemblies[1].Find("System.Windows.Media.Brush", true);
			types[KnownTypes.BrushConverter] = assemblies[1].Find("System.Windows.Media.BrushConverter", true);
			types[KnownTypes.BulletDecorator] = assemblies[0].Find("System.Windows.Controls.Primitives.BulletDecorator", true);
			types[KnownTypes.Button] = assemblies[0].Find("System.Windows.Controls.Button", true);
			types[KnownTypes.ButtonBase] = assemblies[0].Find("System.Windows.Controls.Primitives.ButtonBase", true);
			types[KnownTypes.Byte] = assemblies[2].Find("System.Byte", true);
			types[KnownTypes.ByteAnimation] = assemblies[1].Find("System.Windows.Media.Animation.ByteAnimation", true);
			types[KnownTypes.ByteAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.ByteAnimationBase", true);
			types[KnownTypes.ByteAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.ByteAnimationUsingKeyFrames", true);
			types[KnownTypes.ByteConverter] = assemblies[3].Find("System.ComponentModel.ByteConverter", true);
			types[KnownTypes.ByteKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.ByteKeyFrame", true);
			types[KnownTypes.ByteKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.ByteKeyFrameCollection", true);
			types[KnownTypes.CachedBitmap] = assemblies[1].Find("System.Windows.Media.Imaging.CachedBitmap", true);
			types[KnownTypes.Camera] = assemblies[1].Find("System.Windows.Media.Media3D.Camera", true);
			types[KnownTypes.Canvas] = assemblies[0].Find("System.Windows.Controls.Canvas", true);
			types[KnownTypes.Char] = assemblies[2].Find("System.Char", true);
			types[KnownTypes.CharAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.CharAnimationBase", true);
			types[KnownTypes.CharAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.CharAnimationUsingKeyFrames", true);
			types[KnownTypes.CharConverter] = assemblies[3].Find("System.ComponentModel.CharConverter", true);
			types[KnownTypes.CharIListConverter] = assemblies[1].Find("System.Windows.Media.Converters.CharIListConverter", true);
			types[KnownTypes.CharKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.CharKeyFrame", true);
			types[KnownTypes.CharKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.CharKeyFrameCollection", true);
			types[KnownTypes.CheckBox] = assemblies[0].Find("System.Windows.Controls.CheckBox", true);
			types[KnownTypes.Clock] = assemblies[1].Find("System.Windows.Media.Animation.Clock", true);
			types[KnownTypes.ClockController] = assemblies[1].Find("System.Windows.Media.Animation.ClockController", true);
			types[KnownTypes.ClockGroup] = assemblies[1].Find("System.Windows.Media.Animation.ClockGroup", true);
			types[KnownTypes.CollectionContainer] = assemblies[0].Find("System.Windows.Data.CollectionContainer", true);
			types[KnownTypes.CollectionView] = assemblies[0].Find("System.Windows.Data.CollectionView", true);
			types[KnownTypes.CollectionViewSource] = assemblies[0].Find("System.Windows.Data.CollectionViewSource", true);
			types[KnownTypes.Color] = assemblies[1].Find("System.Windows.Media.Color", true);
			types[KnownTypes.ColorAnimation] = assemblies[1].Find("System.Windows.Media.Animation.ColorAnimation", true);
			types[KnownTypes.ColorAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.ColorAnimationBase", true);
			types[KnownTypes.ColorAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.ColorAnimationUsingKeyFrames", true);
			types[KnownTypes.ColorConvertedBitmap] = assemblies[1].Find("System.Windows.Media.Imaging.ColorConvertedBitmap", true);
			types[KnownTypes.ColorConvertedBitmapExtension] = assemblies[0].Find("System.Windows.ColorConvertedBitmapExtension", true);
			types[KnownTypes.ColorConverter] = assemblies[1].Find("System.Windows.Media.ColorConverter", true);
			types[KnownTypes.ColorKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.ColorKeyFrame", true);
			types[KnownTypes.ColorKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.ColorKeyFrameCollection", true);
			types[KnownTypes.ColumnDefinition] = assemblies[0].Find("System.Windows.Controls.ColumnDefinition", true);
			types[KnownTypes.CombinedGeometry] = assemblies[1].Find("System.Windows.Media.CombinedGeometry", true);
			types[KnownTypes.ComboBox] = assemblies[0].Find("System.Windows.Controls.ComboBox", true);
			types[KnownTypes.ComboBoxItem] = assemblies[0].Find("System.Windows.Controls.ComboBoxItem", true);
			types[KnownTypes.CommandConverter] = assemblies[0].Find("System.Windows.Input.CommandConverter", true);
			types[KnownTypes.ComponentResourceKey] = assemblies[0].Find("System.Windows.ComponentResourceKey", true);
			types[KnownTypes.ComponentResourceKeyConverter] = assemblies[0].Find("System.Windows.Markup.ComponentResourceKeyConverter", true);
			types[KnownTypes.CompositionTarget] = assemblies[1].Find("System.Windows.Media.CompositionTarget", true);
			types[KnownTypes.Condition] = assemblies[0].Find("System.Windows.Condition", true);
			types[KnownTypes.ContainerVisual] = assemblies[1].Find("System.Windows.Media.ContainerVisual", true);
			types[KnownTypes.ContentControl] = assemblies[0].Find("System.Windows.Controls.ContentControl", true);
			types[KnownTypes.ContentElement] = assemblies[1].Find("System.Windows.ContentElement", true);
			types[KnownTypes.ContentPresenter] = assemblies[0].Find("System.Windows.Controls.ContentPresenter", true);
			types[KnownTypes.ContentPropertyAttribute] = assemblies[4].Find("System.Windows.Markup.ContentPropertyAttribute", true);
			types[KnownTypes.ContentWrapperAttribute] = assemblies[4].Find("System.Windows.Markup.ContentWrapperAttribute", true);
			types[KnownTypes.ContextMenu] = assemblies[0].Find("System.Windows.Controls.ContextMenu", true);
			types[KnownTypes.ContextMenuService] = assemblies[0].Find("System.Windows.Controls.ContextMenuService", true);
			types[KnownTypes.Control] = assemblies[0].Find("System.Windows.Controls.Control", true);
			types[KnownTypes.ControlTemplate] = assemblies[0].Find("System.Windows.Controls.ControlTemplate", true);
			types[KnownTypes.ControllableStoryboardAction] = assemblies[0].Find("System.Windows.Media.Animation.ControllableStoryboardAction", true);
			types[KnownTypes.CornerRadius] = assemblies[0].Find("System.Windows.CornerRadius", true);
			types[KnownTypes.CornerRadiusConverter] = assemblies[0].Find("System.Windows.CornerRadiusConverter", true);
			types[KnownTypes.CroppedBitmap] = assemblies[1].Find("System.Windows.Media.Imaging.CroppedBitmap", true);
			types[KnownTypes.CultureInfo] = assemblies[2].Find("System.Globalization.CultureInfo", true);
			types[KnownTypes.CultureInfoConverter] = assemblies[3].Find("System.ComponentModel.CultureInfoConverter", true);
			types[KnownTypes.CultureInfoIetfLanguageTagConverter] = assemblies[1].Find("System.Windows.CultureInfoIetfLanguageTagConverter", true);
			types[KnownTypes.Cursor] = assemblies[1].Find("System.Windows.Input.Cursor", true);
			types[KnownTypes.CursorConverter] = assemblies[1].Find("System.Windows.Input.CursorConverter", true);
			types[KnownTypes.DashStyle] = assemblies[1].Find("System.Windows.Media.DashStyle", true);
			types[KnownTypes.DataChangedEventManager] = assemblies[0].Find("System.Windows.Data.DataChangedEventManager", true);
			types[KnownTypes.DataTemplate] = assemblies[0].Find("System.Windows.DataTemplate", true);
			types[KnownTypes.DataTemplateKey] = assemblies[0].Find("System.Windows.DataTemplateKey", true);
			types[KnownTypes.DataTrigger] = assemblies[0].Find("System.Windows.DataTrigger", true);
			types[KnownTypes.DateTime] = assemblies[2].Find("System.DateTime", true);
			types[KnownTypes.DateTimeConverter] = assemblies[3].Find("System.ComponentModel.DateTimeConverter", true);
			types[KnownTypes.DateTimeConverter2] = assemblies[4].Find("System.Windows.Markup.DateTimeConverter2", true);
			types[KnownTypes.Decimal] = assemblies[2].Find("System.Decimal", true);
			types[KnownTypes.DecimalAnimation] = assemblies[1].Find("System.Windows.Media.Animation.DecimalAnimation", true);
			types[KnownTypes.DecimalAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.DecimalAnimationBase", true);
			types[KnownTypes.DecimalAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.DecimalAnimationUsingKeyFrames", true);
			types[KnownTypes.DecimalConverter] = assemblies[3].Find("System.ComponentModel.DecimalConverter", true);
			types[KnownTypes.DecimalKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DecimalKeyFrame", true);
			types[KnownTypes.DecimalKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.DecimalKeyFrameCollection", true);
			types[KnownTypes.Decorator] = assemblies[0].Find("System.Windows.Controls.Decorator", true);
			types[KnownTypes.DefinitionBase] = assemblies[0].Find("System.Windows.Controls.DefinitionBase", true);
			types[KnownTypes.DependencyObject] = assemblies[4].Find("System.Windows.DependencyObject", true);
			types[KnownTypes.DependencyProperty] = assemblies[4].Find("System.Windows.DependencyProperty", true);
			types[KnownTypes.DependencyPropertyConverter] = assemblies[0].Find("System.Windows.Markup.DependencyPropertyConverter", true);
			types[KnownTypes.DialogResultConverter] = assemblies[0].Find("System.Windows.DialogResultConverter", true);
			types[KnownTypes.DiffuseMaterial] = assemblies[1].Find("System.Windows.Media.Media3D.DiffuseMaterial", true);
			types[KnownTypes.DirectionalLight] = assemblies[1].Find("System.Windows.Media.Media3D.DirectionalLight", true);
			types[KnownTypes.DiscreteBooleanKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteBooleanKeyFrame", true);
			types[KnownTypes.DiscreteByteKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteByteKeyFrame", true);
			types[KnownTypes.DiscreteCharKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteCharKeyFrame", true);
			types[KnownTypes.DiscreteColorKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteColorKeyFrame", true);
			types[KnownTypes.DiscreteDecimalKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteDecimalKeyFrame", true);
			types[KnownTypes.DiscreteDoubleKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteDoubleKeyFrame", true);
			types[KnownTypes.DiscreteInt16KeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteInt16KeyFrame", true);
			types[KnownTypes.DiscreteInt32KeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteInt32KeyFrame", true);
			types[KnownTypes.DiscreteInt64KeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteInt64KeyFrame", true);
			types[KnownTypes.DiscreteMatrixKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteMatrixKeyFrame", true);
			types[KnownTypes.DiscreteObjectKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteObjectKeyFrame", true);
			types[KnownTypes.DiscretePoint3DKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscretePoint3DKeyFrame", true);
			types[KnownTypes.DiscretePointKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscretePointKeyFrame", true);
			types[KnownTypes.DiscreteQuaternionKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteQuaternionKeyFrame", true);
			types[KnownTypes.DiscreteRectKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteRectKeyFrame", true);
			types[KnownTypes.DiscreteRotation3DKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteRotation3DKeyFrame", true);
			types[KnownTypes.DiscreteSingleKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteSingleKeyFrame", true);
			types[KnownTypes.DiscreteSizeKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteSizeKeyFrame", true);
			types[KnownTypes.DiscreteStringKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteStringKeyFrame", true);
			types[KnownTypes.DiscreteThicknessKeyFrame] = assemblies[0].Find("System.Windows.Media.Animation.DiscreteThicknessKeyFrame", true);
			types[KnownTypes.DiscreteVector3DKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteVector3DKeyFrame", true);
			types[KnownTypes.DiscreteVectorKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteVectorKeyFrame", true);
			types[KnownTypes.DockPanel] = assemblies[0].Find("System.Windows.Controls.DockPanel", true);
			types[KnownTypes.DocumentPageView] = assemblies[0].Find("System.Windows.Controls.Primitives.DocumentPageView", true);
			types[KnownTypes.DocumentReference] = assemblies[0].Find("System.Windows.Documents.DocumentReference", true);
			types[KnownTypes.DocumentViewer] = assemblies[0].Find("System.Windows.Controls.DocumentViewer", true);
			types[KnownTypes.DocumentViewerBase] = assemblies[0].Find("System.Windows.Controls.Primitives.DocumentViewerBase", true);
			types[KnownTypes.Double] = assemblies[2].Find("System.Double", true);
			types[KnownTypes.DoubleAnimation] = assemblies[1].Find("System.Windows.Media.Animation.DoubleAnimation", true);
			types[KnownTypes.DoubleAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.DoubleAnimationBase", true);
			types[KnownTypes.DoubleAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.DoubleAnimationUsingKeyFrames", true);
			types[KnownTypes.DoubleAnimationUsingPath] = assemblies[1].Find("System.Windows.Media.Animation.DoubleAnimationUsingPath", true);
			types[KnownTypes.DoubleCollection] = assemblies[1].Find("System.Windows.Media.DoubleCollection", true);
			types[KnownTypes.DoubleCollectionConverter] = assemblies[1].Find("System.Windows.Media.DoubleCollectionConverter", true);
			types[KnownTypes.DoubleConverter] = assemblies[3].Find("System.ComponentModel.DoubleConverter", true);
			types[KnownTypes.DoubleIListConverter] = assemblies[1].Find("System.Windows.Media.Converters.DoubleIListConverter", true);
			types[KnownTypes.DoubleKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DoubleKeyFrame", true);
			types[KnownTypes.DoubleKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.DoubleKeyFrameCollection", true);
			types[KnownTypes.Drawing] = assemblies[1].Find("System.Windows.Media.Drawing", true);
			types[KnownTypes.DrawingBrush] = assemblies[1].Find("System.Windows.Media.DrawingBrush", true);
			types[KnownTypes.DrawingCollection] = assemblies[1].Find("System.Windows.Media.DrawingCollection", true);
			types[KnownTypes.DrawingContext] = assemblies[1].Find("System.Windows.Media.DrawingContext", true);
			types[KnownTypes.DrawingGroup] = assemblies[1].Find("System.Windows.Media.DrawingGroup", true);
			types[KnownTypes.DrawingImage] = assemblies[1].Find("System.Windows.Media.DrawingImage", true);
			types[KnownTypes.DrawingVisual] = assemblies[1].Find("System.Windows.Media.DrawingVisual", true);
			types[KnownTypes.DropShadowBitmapEffect] = assemblies[1].Find("System.Windows.Media.Effects.DropShadowBitmapEffect", true);
			types[KnownTypes.Duration] = assemblies[1].Find("System.Windows.Duration", true);
			types[KnownTypes.DurationConverter] = assemblies[1].Find("System.Windows.DurationConverter", true);
			types[KnownTypes.DynamicResourceExtension] = assemblies[0].Find("System.Windows.DynamicResourceExtension", true);
			types[KnownTypes.DynamicResourceExtensionConverter] = assemblies[0].Find("System.Windows.DynamicResourceExtensionConverter", true);
			types[KnownTypes.Ellipse] = assemblies[0].Find("System.Windows.Shapes.Ellipse", true);
			types[KnownTypes.EllipseGeometry] = assemblies[1].Find("System.Windows.Media.EllipseGeometry", true);
			types[KnownTypes.EmbossBitmapEffect] = assemblies[1].Find("System.Windows.Media.Effects.EmbossBitmapEffect", true);
			types[KnownTypes.EmissiveMaterial] = assemblies[1].Find("System.Windows.Media.Media3D.EmissiveMaterial", true);
			types[KnownTypes.EnumConverter] = assemblies[3].Find("System.ComponentModel.EnumConverter", true);
			types[KnownTypes.EventManager] = assemblies[1].Find("System.Windows.EventManager", true);
			types[KnownTypes.EventSetter] = assemblies[0].Find("System.Windows.EventSetter", true);
			types[KnownTypes.EventTrigger] = assemblies[0].Find("System.Windows.EventTrigger", true);
			types[KnownTypes.Expander] = assemblies[0].Find("System.Windows.Controls.Expander", true);
			types[KnownTypes.Expression] = assemblies[4].Find("System.Windows.Expression", true);
			types[KnownTypes.ExpressionConverter] = assemblies[4].Find("System.Windows.ExpressionConverter", true);
			types[KnownTypes.Figure] = assemblies[0].Find("System.Windows.Documents.Figure", true);
			types[KnownTypes.FigureLength] = assemblies[0].Find("System.Windows.FigureLength", true);
			types[KnownTypes.FigureLengthConverter] = assemblies[0].Find("System.Windows.FigureLengthConverter", true);
			types[KnownTypes.FixedDocument] = assemblies[0].Find("System.Windows.Documents.FixedDocument", true);
			types[KnownTypes.FixedDocumentSequence] = assemblies[0].Find("System.Windows.Documents.FixedDocumentSequence", true);
			types[KnownTypes.FixedPage] = assemblies[0].Find("System.Windows.Documents.FixedPage", true);
			types[KnownTypes.Floater] = assemblies[0].Find("System.Windows.Documents.Floater", true);
			types[KnownTypes.FlowDocument] = assemblies[0].Find("System.Windows.Documents.FlowDocument", true);
			types[KnownTypes.FlowDocumentPageViewer] = assemblies[0].Find("System.Windows.Controls.FlowDocumentPageViewer", true);
			types[KnownTypes.FlowDocumentReader] = assemblies[0].Find("System.Windows.Controls.FlowDocumentReader", true);
			types[KnownTypes.FlowDocumentScrollViewer] = assemblies[0].Find("System.Windows.Controls.FlowDocumentScrollViewer", true);
			types[KnownTypes.FocusManager] = assemblies[1].Find("System.Windows.Input.FocusManager", true);
			types[KnownTypes.FontFamily] = assemblies[1].Find("System.Windows.Media.FontFamily", true);
			types[KnownTypes.FontFamilyConverter] = assemblies[1].Find("System.Windows.Media.FontFamilyConverter", true);
			types[KnownTypes.FontSizeConverter] = assemblies[0].Find("System.Windows.FontSizeConverter", true);
			types[KnownTypes.FontStretch] = assemblies[1].Find("System.Windows.FontStretch", true);
			types[KnownTypes.FontStretchConverter] = assemblies[1].Find("System.Windows.FontStretchConverter", true);
			types[KnownTypes.FontStyle] = assemblies[1].Find("System.Windows.FontStyle", true);
			types[KnownTypes.FontStyleConverter] = assemblies[1].Find("System.Windows.FontStyleConverter", true);
			types[KnownTypes.FontWeight] = assemblies[1].Find("System.Windows.FontWeight", true);
			types[KnownTypes.FontWeightConverter] = assemblies[1].Find("System.Windows.FontWeightConverter", true);
			types[KnownTypes.FormatConvertedBitmap] = assemblies[1].Find("System.Windows.Media.Imaging.FormatConvertedBitmap", true);
			types[KnownTypes.Frame] = assemblies[0].Find("System.Windows.Controls.Frame", true);
			types[KnownTypes.FrameworkContentElement] = assemblies[0].Find("System.Windows.FrameworkContentElement", true);
			types[KnownTypes.FrameworkElement] = assemblies[0].Find("System.Windows.FrameworkElement", true);
			types[KnownTypes.FrameworkElementFactory] = assemblies[0].Find("System.Windows.FrameworkElementFactory", true);
			types[KnownTypes.FrameworkPropertyMetadata] = assemblies[0].Find("System.Windows.FrameworkPropertyMetadata", true);
			types[KnownTypes.FrameworkPropertyMetadataOptions] = assemblies[0].Find("System.Windows.FrameworkPropertyMetadataOptions", true);
			types[KnownTypes.FrameworkRichTextComposition] = assemblies[0].Find("System.Windows.Documents.FrameworkRichTextComposition", true);
			types[KnownTypes.FrameworkTemplate] = assemblies[0].Find("System.Windows.FrameworkTemplate", true);
			types[KnownTypes.FrameworkTextComposition] = assemblies[0].Find("System.Windows.Documents.FrameworkTextComposition", true);
			types[KnownTypes.Freezable] = assemblies[4].Find("System.Windows.Freezable", true);
			types[KnownTypes.GeneralTransform] = assemblies[1].Find("System.Windows.Media.GeneralTransform", true);
			types[KnownTypes.GeneralTransformCollection] = assemblies[1].Find("System.Windows.Media.GeneralTransformCollection", true);
			types[KnownTypes.GeneralTransformGroup] = assemblies[1].Find("System.Windows.Media.GeneralTransformGroup", true);
			types[KnownTypes.Geometry] = assemblies[1].Find("System.Windows.Media.Geometry", true);
			types[KnownTypes.Geometry3D] = assemblies[1].Find("System.Windows.Media.Media3D.Geometry3D", true);
			types[KnownTypes.GeometryCollection] = assemblies[1].Find("System.Windows.Media.GeometryCollection", true);
			types[KnownTypes.GeometryConverter] = assemblies[1].Find("System.Windows.Media.GeometryConverter", true);
			types[KnownTypes.GeometryDrawing] = assemblies[1].Find("System.Windows.Media.GeometryDrawing", true);
			types[KnownTypes.GeometryGroup] = assemblies[1].Find("System.Windows.Media.GeometryGroup", true);
			types[KnownTypes.GeometryModel3D] = assemblies[1].Find("System.Windows.Media.Media3D.GeometryModel3D", true);
			types[KnownTypes.GestureRecognizer] = assemblies[1].Find("System.Windows.Ink.GestureRecognizer", true);
			types[KnownTypes.GifBitmapDecoder] = assemblies[1].Find("System.Windows.Media.Imaging.GifBitmapDecoder", true);
			types[KnownTypes.GifBitmapEncoder] = assemblies[1].Find("System.Windows.Media.Imaging.GifBitmapEncoder", true);
			types[KnownTypes.GlyphRun] = assemblies[1].Find("System.Windows.Media.GlyphRun", true);
			types[KnownTypes.GlyphRunDrawing] = assemblies[1].Find("System.Windows.Media.GlyphRunDrawing", true);
			types[KnownTypes.GlyphTypeface] = assemblies[1].Find("System.Windows.Media.GlyphTypeface", true);
			types[KnownTypes.Glyphs] = assemblies[0].Find("System.Windows.Documents.Glyphs", true);
			types[KnownTypes.GradientBrush] = assemblies[1].Find("System.Windows.Media.GradientBrush", true);
			types[KnownTypes.GradientStop] = assemblies[1].Find("System.Windows.Media.GradientStop", true);
			types[KnownTypes.GradientStopCollection] = assemblies[1].Find("System.Windows.Media.GradientStopCollection", true);
			types[KnownTypes.Grid] = assemblies[0].Find("System.Windows.Controls.Grid", true);
			types[KnownTypes.GridLength] = assemblies[0].Find("System.Windows.GridLength", true);
			types[KnownTypes.GridLengthConverter] = assemblies[0].Find("System.Windows.GridLengthConverter", true);
			types[KnownTypes.GridSplitter] = assemblies[0].Find("System.Windows.Controls.GridSplitter", true);
			types[KnownTypes.GridView] = assemblies[0].Find("System.Windows.Controls.GridView", true);
			types[KnownTypes.GridViewColumn] = assemblies[0].Find("System.Windows.Controls.GridViewColumn", true);
			types[KnownTypes.GridViewColumnHeader] = assemblies[0].Find("System.Windows.Controls.GridViewColumnHeader", true);
			types[KnownTypes.GridViewHeaderRowPresenter] = assemblies[0].Find("System.Windows.Controls.GridViewHeaderRowPresenter", true);
			types[KnownTypes.GridViewRowPresenter] = assemblies[0].Find("System.Windows.Controls.GridViewRowPresenter", true);
			types[KnownTypes.GridViewRowPresenterBase] = assemblies[0].Find("System.Windows.Controls.Primitives.GridViewRowPresenterBase", true);
			types[KnownTypes.GroupBox] = assemblies[0].Find("System.Windows.Controls.GroupBox", true);
			types[KnownTypes.GroupItem] = assemblies[0].Find("System.Windows.Controls.GroupItem", true);
			types[KnownTypes.Guid] = assemblies[2].Find("System.Guid", true);
			types[KnownTypes.GuidConverter] = assemblies[3].Find("System.ComponentModel.GuidConverter", true);
			types[KnownTypes.GuidelineSet] = assemblies[1].Find("System.Windows.Media.GuidelineSet", true);
			types[KnownTypes.HeaderedContentControl] = assemblies[0].Find("System.Windows.Controls.HeaderedContentControl", true);
			types[KnownTypes.HeaderedItemsControl] = assemblies[0].Find("System.Windows.Controls.HeaderedItemsControl", true);
			types[KnownTypes.HierarchicalDataTemplate] = assemblies[0].Find("System.Windows.HierarchicalDataTemplate", true);
			types[KnownTypes.HostVisual] = assemblies[1].Find("System.Windows.Media.HostVisual", true);
			types[KnownTypes.Hyperlink] = assemblies[0].Find("System.Windows.Documents.Hyperlink", true);
			types[KnownTypes.IAddChild] = assemblies[1].Find("System.Windows.Markup.IAddChild", true);
			types[KnownTypes.IAddChildInternal] = assemblies[1].Find("System.Windows.Markup.IAddChildInternal", true);
			types[KnownTypes.ICommand] = assemblies[1].Find("System.Windows.Input.ICommand", true);
			types[KnownTypes.IComponentConnector] = assemblies[4].Find("System.Windows.Markup.IComponentConnector", true);
			types[KnownTypes.INameScope] = assemblies[4].Find("System.Windows.Markup.INameScope", true);
			types[KnownTypes.IStyleConnector] = assemblies[0].Find("System.Windows.Markup.IStyleConnector", true);
			types[KnownTypes.IconBitmapDecoder] = assemblies[1].Find("System.Windows.Media.Imaging.IconBitmapDecoder", true);
			types[KnownTypes.Image] = assemblies[0].Find("System.Windows.Controls.Image", true);
			types[KnownTypes.ImageBrush] = assemblies[1].Find("System.Windows.Media.ImageBrush", true);
			types[KnownTypes.ImageDrawing] = assemblies[1].Find("System.Windows.Media.ImageDrawing", true);
			types[KnownTypes.ImageMetadata] = assemblies[1].Find("System.Windows.Media.ImageMetadata", true);
			types[KnownTypes.ImageSource] = assemblies[1].Find("System.Windows.Media.ImageSource", true);
			types[KnownTypes.ImageSourceConverter] = assemblies[1].Find("System.Windows.Media.ImageSourceConverter", true);
			types[KnownTypes.InPlaceBitmapMetadataWriter] = assemblies[1].Find("System.Windows.Media.Imaging.InPlaceBitmapMetadataWriter", true);
			types[KnownTypes.InkCanvas] = assemblies[0].Find("System.Windows.Controls.InkCanvas", true);
			types[KnownTypes.InkPresenter] = assemblies[0].Find("System.Windows.Controls.InkPresenter", true);
			types[KnownTypes.Inline] = assemblies[0].Find("System.Windows.Documents.Inline", true);
			types[KnownTypes.InlineCollection] = assemblies[0].Find("System.Windows.Documents.InlineCollection", true);
			types[KnownTypes.InlineUIContainer] = assemblies[0].Find("System.Windows.Documents.InlineUIContainer", true);
			types[KnownTypes.InputBinding] = assemblies[1].Find("System.Windows.Input.InputBinding", true);
			types[KnownTypes.InputDevice] = assemblies[1].Find("System.Windows.Input.InputDevice", true);
			types[KnownTypes.InputLanguageManager] = assemblies[1].Find("System.Windows.Input.InputLanguageManager", true);
			types[KnownTypes.InputManager] = assemblies[1].Find("System.Windows.Input.InputManager", true);
			types[KnownTypes.InputMethod] = assemblies[1].Find("System.Windows.Input.InputMethod", true);
			types[KnownTypes.InputScope] = assemblies[1].Find("System.Windows.Input.InputScope", true);
			types[KnownTypes.InputScopeConverter] = assemblies[1].Find("System.Windows.Input.InputScopeConverter", true);
			types[KnownTypes.InputScopeName] = assemblies[1].Find("System.Windows.Input.InputScopeName", true);
			types[KnownTypes.InputScopeNameConverter] = assemblies[1].Find("System.Windows.Input.InputScopeNameConverter", true);
			types[KnownTypes.Int16] = assemblies[2].Find("System.Int16", true);
			types[KnownTypes.Int16Animation] = assemblies[1].Find("System.Windows.Media.Animation.Int16Animation", true);
			types[KnownTypes.Int16AnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.Int16AnimationBase", true);
			types[KnownTypes.Int16AnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.Int16AnimationUsingKeyFrames", true);
			types[KnownTypes.Int16Converter] = assemblies[3].Find("System.ComponentModel.Int16Converter", true);
			types[KnownTypes.Int16KeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.Int16KeyFrame", true);
			types[KnownTypes.Int16KeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.Int16KeyFrameCollection", true);
			types[KnownTypes.Int32] = assemblies[2].Find("System.Int32", true);
			types[KnownTypes.Int32Animation] = assemblies[1].Find("System.Windows.Media.Animation.Int32Animation", true);
			types[KnownTypes.Int32AnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.Int32AnimationBase", true);
			types[KnownTypes.Int32AnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.Int32AnimationUsingKeyFrames", true);
			types[KnownTypes.Int32Collection] = assemblies[1].Find("System.Windows.Media.Int32Collection", true);
			types[KnownTypes.Int32CollectionConverter] = assemblies[1].Find("System.Windows.Media.Int32CollectionConverter", true);
			types[KnownTypes.Int32Converter] = assemblies[3].Find("System.ComponentModel.Int32Converter", true);
			types[KnownTypes.Int32KeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.Int32KeyFrame", true);
			types[KnownTypes.Int32KeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.Int32KeyFrameCollection", true);
			types[KnownTypes.Int32Rect] = assemblies[4].Find("System.Windows.Int32Rect", true);
			types[KnownTypes.Int32RectConverter] = assemblies[4].Find("System.Windows.Int32RectConverter", true);
			types[KnownTypes.Int64] = assemblies[2].Find("System.Int64", true);
			types[KnownTypes.Int64Animation] = assemblies[1].Find("System.Windows.Media.Animation.Int64Animation", true);
			types[KnownTypes.Int64AnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.Int64AnimationBase", true);
			types[KnownTypes.Int64AnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.Int64AnimationUsingKeyFrames", true);
			types[KnownTypes.Int64Converter] = assemblies[3].Find("System.ComponentModel.Int64Converter", true);
			types[KnownTypes.Int64KeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.Int64KeyFrame", true);
			types[KnownTypes.Int64KeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.Int64KeyFrameCollection", true);
			types[KnownTypes.Italic] = assemblies[0].Find("System.Windows.Documents.Italic", true);
			types[KnownTypes.ItemCollection] = assemblies[0].Find("System.Windows.Controls.ItemCollection", true);
			types[KnownTypes.ItemsControl] = assemblies[0].Find("System.Windows.Controls.ItemsControl", true);
			types[KnownTypes.ItemsPanelTemplate] = assemblies[0].Find("System.Windows.Controls.ItemsPanelTemplate", true);
			types[KnownTypes.ItemsPresenter] = assemblies[0].Find("System.Windows.Controls.ItemsPresenter", true);
			types[KnownTypes.JournalEntry] = assemblies[0].Find("System.Windows.Navigation.JournalEntry", true);
			types[KnownTypes.JournalEntryListConverter] = assemblies[0].Find("System.Windows.Navigation.JournalEntryListConverter", true);
			types[KnownTypes.JournalEntryUnifiedViewConverter] = assemblies[0].Find("System.Windows.Navigation.JournalEntryUnifiedViewConverter", true);
			types[KnownTypes.JpegBitmapDecoder] = assemblies[1].Find("System.Windows.Media.Imaging.JpegBitmapDecoder", true);
			types[KnownTypes.JpegBitmapEncoder] = assemblies[1].Find("System.Windows.Media.Imaging.JpegBitmapEncoder", true);
			types[KnownTypes.KeyBinding] = assemblies[1].Find("System.Windows.Input.KeyBinding", true);
			types[KnownTypes.KeyConverter] = assemblies[4].Find("System.Windows.Input.KeyConverter", true);
			types[KnownTypes.KeyGesture] = assemblies[1].Find("System.Windows.Input.KeyGesture", true);
			types[KnownTypes.KeyGestureConverter] = assemblies[1].Find("System.Windows.Input.KeyGestureConverter", true);
			types[KnownTypes.KeySpline] = assemblies[1].Find("System.Windows.Media.Animation.KeySpline", true);
			types[KnownTypes.KeySplineConverter] = assemblies[1].Find("System.Windows.KeySplineConverter", true);
			types[KnownTypes.KeyTime] = assemblies[1].Find("System.Windows.Media.Animation.KeyTime", true);
			types[KnownTypes.KeyTimeConverter] = assemblies[1].Find("System.Windows.KeyTimeConverter", true);
			types[KnownTypes.KeyboardDevice] = assemblies[1].Find("System.Windows.Input.KeyboardDevice", true);
			types[KnownTypes.Label] = assemblies[0].Find("System.Windows.Controls.Label", true);
			types[KnownTypes.LateBoundBitmapDecoder] = assemblies[1].Find("System.Windows.Media.Imaging.LateBoundBitmapDecoder", true);
			types[KnownTypes.LengthConverter] = assemblies[0].Find("System.Windows.LengthConverter", true);
			types[KnownTypes.Light] = assemblies[1].Find("System.Windows.Media.Media3D.Light", true);
			types[KnownTypes.Line] = assemblies[0].Find("System.Windows.Shapes.Line", true);
			types[KnownTypes.LineBreak] = assemblies[0].Find("System.Windows.Documents.LineBreak", true);
			types[KnownTypes.LineGeometry] = assemblies[1].Find("System.Windows.Media.LineGeometry", true);
			types[KnownTypes.LineSegment] = assemblies[1].Find("System.Windows.Media.LineSegment", true);
			types[KnownTypes.LinearByteKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearByteKeyFrame", true);
			types[KnownTypes.LinearColorKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearColorKeyFrame", true);
			types[KnownTypes.LinearDecimalKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearDecimalKeyFrame", true);
			types[KnownTypes.LinearDoubleKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearDoubleKeyFrame", true);
			types[KnownTypes.LinearGradientBrush] = assemblies[1].Find("System.Windows.Media.LinearGradientBrush", true);
			types[KnownTypes.LinearInt16KeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearInt16KeyFrame", true);
			types[KnownTypes.LinearInt32KeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearInt32KeyFrame", true);
			types[KnownTypes.LinearInt64KeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearInt64KeyFrame", true);
			types[KnownTypes.LinearPoint3DKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearPoint3DKeyFrame", true);
			types[KnownTypes.LinearPointKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearPointKeyFrame", true);
			types[KnownTypes.LinearQuaternionKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearQuaternionKeyFrame", true);
			types[KnownTypes.LinearRectKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearRectKeyFrame", true);
			types[KnownTypes.LinearRotation3DKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearRotation3DKeyFrame", true);
			types[KnownTypes.LinearSingleKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearSingleKeyFrame", true);
			types[KnownTypes.LinearSizeKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearSizeKeyFrame", true);
			types[KnownTypes.LinearThicknessKeyFrame] = assemblies[0].Find("System.Windows.Media.Animation.LinearThicknessKeyFrame", true);
			types[KnownTypes.LinearVector3DKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearVector3DKeyFrame", true);
			types[KnownTypes.LinearVectorKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearVectorKeyFrame", true);
			types[KnownTypes.List] = assemblies[0].Find("System.Windows.Documents.List", true);
			types[KnownTypes.ListBox] = assemblies[0].Find("System.Windows.Controls.ListBox", true);
			types[KnownTypes.ListBoxItem] = assemblies[0].Find("System.Windows.Controls.ListBoxItem", true);
			types[KnownTypes.ListCollectionView] = assemblies[0].Find("System.Windows.Data.ListCollectionView", true);
			types[KnownTypes.ListItem] = assemblies[0].Find("System.Windows.Documents.ListItem", true);
			types[KnownTypes.ListView] = assemblies[0].Find("System.Windows.Controls.ListView", true);
			types[KnownTypes.ListViewItem] = assemblies[0].Find("System.Windows.Controls.ListViewItem", true);
			types[KnownTypes.Localization] = assemblies[0].Find("System.Windows.Localization", true);
			types[KnownTypes.LostFocusEventManager] = assemblies[0].Find("System.Windows.LostFocusEventManager", true);
			types[KnownTypes.MarkupExtension] = assemblies[4].Find("System.Windows.Markup.MarkupExtension", true);
			types[KnownTypes.Material] = assemblies[1].Find("System.Windows.Media.Media3D.Material", true);
			types[KnownTypes.MaterialCollection] = assemblies[1].Find("System.Windows.Media.Media3D.MaterialCollection", true);
			types[KnownTypes.MaterialGroup] = assemblies[1].Find("System.Windows.Media.Media3D.MaterialGroup", true);
			types[KnownTypes.Matrix] = assemblies[4].Find("System.Windows.Media.Matrix", true);
			types[KnownTypes.Matrix3D] = assemblies[1].Find("System.Windows.Media.Media3D.Matrix3D", true);
			types[KnownTypes.Matrix3DConverter] = assemblies[1].Find("System.Windows.Media.Media3D.Matrix3DConverter", true);
			types[KnownTypes.MatrixAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.MatrixAnimationBase", true);
			types[KnownTypes.MatrixAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.MatrixAnimationUsingKeyFrames", true);
			types[KnownTypes.MatrixAnimationUsingPath] = assemblies[1].Find("System.Windows.Media.Animation.MatrixAnimationUsingPath", true);
			types[KnownTypes.MatrixCamera] = assemblies[1].Find("System.Windows.Media.Media3D.MatrixCamera", true);
			types[KnownTypes.MatrixConverter] = assemblies[4].Find("System.Windows.Media.MatrixConverter", true);
			types[KnownTypes.MatrixKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.MatrixKeyFrame", true);
			types[KnownTypes.MatrixKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.MatrixKeyFrameCollection", true);
			types[KnownTypes.MatrixTransform] = assemblies[1].Find("System.Windows.Media.MatrixTransform", true);
			types[KnownTypes.MatrixTransform3D] = assemblies[1].Find("System.Windows.Media.Media3D.MatrixTransform3D", true);
			types[KnownTypes.MediaClock] = assemblies[1].Find("System.Windows.Media.MediaClock", true);
			types[KnownTypes.MediaElement] = assemblies[0].Find("System.Windows.Controls.MediaElement", true);
			types[KnownTypes.MediaPlayer] = assemblies[1].Find("System.Windows.Media.MediaPlayer", true);
			types[KnownTypes.MediaTimeline] = assemblies[1].Find("System.Windows.Media.MediaTimeline", true);
			types[KnownTypes.Menu] = assemblies[0].Find("System.Windows.Controls.Menu", true);
			types[KnownTypes.MenuBase] = assemblies[0].Find("System.Windows.Controls.Primitives.MenuBase", true);
			types[KnownTypes.MenuItem] = assemblies[0].Find("System.Windows.Controls.MenuItem", true);
			types[KnownTypes.MenuScrollingVisibilityConverter] = assemblies[0].Find("System.Windows.Controls.MenuScrollingVisibilityConverter", true);
			types[KnownTypes.MeshGeometry3D] = assemblies[1].Find("System.Windows.Media.Media3D.MeshGeometry3D", true);
			types[KnownTypes.Model3D] = assemblies[1].Find("System.Windows.Media.Media3D.Model3D", true);
			types[KnownTypes.Model3DCollection] = assemblies[1].Find("System.Windows.Media.Media3D.Model3DCollection", true);
			types[KnownTypes.Model3DGroup] = assemblies[1].Find("System.Windows.Media.Media3D.Model3DGroup", true);
			types[KnownTypes.ModelVisual3D] = assemblies[1].Find("System.Windows.Media.Media3D.ModelVisual3D", true);
			types[KnownTypes.ModifierKeysConverter] = assemblies[4].Find("System.Windows.Input.ModifierKeysConverter", true);
			types[KnownTypes.MouseActionConverter] = assemblies[1].Find("System.Windows.Input.MouseActionConverter", true);
			types[KnownTypes.MouseBinding] = assemblies[1].Find("System.Windows.Input.MouseBinding", true);
			types[KnownTypes.MouseDevice] = assemblies[1].Find("System.Windows.Input.MouseDevice", true);
			types[KnownTypes.MouseGesture] = assemblies[1].Find("System.Windows.Input.MouseGesture", true);
			types[KnownTypes.MouseGestureConverter] = assemblies[1].Find("System.Windows.Input.MouseGestureConverter", true);
			types[KnownTypes.MultiBinding] = assemblies[0].Find("System.Windows.Data.MultiBinding", true);
			types[KnownTypes.MultiBindingExpression] = assemblies[0].Find("System.Windows.Data.MultiBindingExpression", true);
			types[KnownTypes.MultiDataTrigger] = assemblies[0].Find("System.Windows.MultiDataTrigger", true);
			types[KnownTypes.MultiTrigger] = assemblies[0].Find("System.Windows.MultiTrigger", true);
			types[KnownTypes.NameScope] = assemblies[0].Find("System.Windows.NameScope", true);
			types[KnownTypes.NavigationWindow] = assemblies[0].Find("System.Windows.Navigation.NavigationWindow", true);
			types[KnownTypes.NullExtension] = assemblies[0].Find("System.Windows.Markup.NullExtension", true);
			types[KnownTypes.NullableBoolConverter] = assemblies[0].Find("System.Windows.NullableBoolConverter", true);
			types[KnownTypes.NullableConverter] = assemblies[3].Find("System.ComponentModel.NullableConverter", true);
			types[KnownTypes.NumberSubstitution] = assemblies[1].Find("System.Windows.Media.NumberSubstitution", true);
			types[KnownTypes.Object] = assemblies[2].Find("System.Object", true);
			types[KnownTypes.ObjectAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.ObjectAnimationBase", true);
			types[KnownTypes.ObjectAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.ObjectAnimationUsingKeyFrames", true);
			types[KnownTypes.ObjectDataProvider] = assemblies[0].Find("System.Windows.Data.ObjectDataProvider", true);
			types[KnownTypes.ObjectKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.ObjectKeyFrame", true);
			types[KnownTypes.ObjectKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.ObjectKeyFrameCollection", true);
			types[KnownTypes.OrthographicCamera] = assemblies[1].Find("System.Windows.Media.Media3D.OrthographicCamera", true);
			types[KnownTypes.OuterGlowBitmapEffect] = assemblies[1].Find("System.Windows.Media.Effects.OuterGlowBitmapEffect", true);
			types[KnownTypes.Page] = assemblies[0].Find("System.Windows.Controls.Page", true);
			types[KnownTypes.PageContent] = assemblies[0].Find("System.Windows.Documents.PageContent", true);
			types[KnownTypes.PageFunctionBase] = assemblies[0].Find("System.Windows.Navigation.PageFunctionBase", true);
			types[KnownTypes.Panel] = assemblies[0].Find("System.Windows.Controls.Panel", true);
			types[KnownTypes.Paragraph] = assemblies[0].Find("System.Windows.Documents.Paragraph", true);
			types[KnownTypes.ParallelTimeline] = assemblies[1].Find("System.Windows.Media.Animation.ParallelTimeline", true);
			types[KnownTypes.ParserContext] = assemblies[0].Find("System.Windows.Markup.ParserContext", true);
			types[KnownTypes.PasswordBox] = assemblies[0].Find("System.Windows.Controls.PasswordBox", true);
			types[KnownTypes.Path] = assemblies[0].Find("System.Windows.Shapes.Path", true);
			types[KnownTypes.PathFigure] = assemblies[1].Find("System.Windows.Media.PathFigure", true);
			types[KnownTypes.PathFigureCollection] = assemblies[1].Find("System.Windows.Media.PathFigureCollection", true);
			types[KnownTypes.PathFigureCollectionConverter] = assemblies[1].Find("System.Windows.Media.PathFigureCollectionConverter", true);
			types[KnownTypes.PathGeometry] = assemblies[1].Find("System.Windows.Media.PathGeometry", true);
			types[KnownTypes.PathSegment] = assemblies[1].Find("System.Windows.Media.PathSegment", true);
			types[KnownTypes.PathSegmentCollection] = assemblies[1].Find("System.Windows.Media.PathSegmentCollection", true);
			types[KnownTypes.PauseStoryboard] = assemblies[0].Find("System.Windows.Media.Animation.PauseStoryboard", true);
			types[KnownTypes.Pen] = assemblies[1].Find("System.Windows.Media.Pen", true);
			types[KnownTypes.PerspectiveCamera] = assemblies[1].Find("System.Windows.Media.Media3D.PerspectiveCamera", true);
			types[KnownTypes.PixelFormat] = assemblies[1].Find("System.Windows.Media.PixelFormat", true);
			types[KnownTypes.PixelFormatConverter] = assemblies[1].Find("System.Windows.Media.PixelFormatConverter", true);
			types[KnownTypes.PngBitmapDecoder] = assemblies[1].Find("System.Windows.Media.Imaging.PngBitmapDecoder", true);
			types[KnownTypes.PngBitmapEncoder] = assemblies[1].Find("System.Windows.Media.Imaging.PngBitmapEncoder", true);
			types[KnownTypes.Point] = assemblies[4].Find("System.Windows.Point", true);
			types[KnownTypes.Point3D] = assemblies[1].Find("System.Windows.Media.Media3D.Point3D", true);
			types[KnownTypes.Point3DAnimation] = assemblies[1].Find("System.Windows.Media.Animation.Point3DAnimation", true);
			types[KnownTypes.Point3DAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.Point3DAnimationBase", true);
			types[KnownTypes.Point3DAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.Point3DAnimationUsingKeyFrames", true);
			types[KnownTypes.Point3DCollection] = assemblies[1].Find("System.Windows.Media.Media3D.Point3DCollection", true);
			types[KnownTypes.Point3DCollectionConverter] = assemblies[1].Find("System.Windows.Media.Media3D.Point3DCollectionConverter", true);
			types[KnownTypes.Point3DConverter] = assemblies[1].Find("System.Windows.Media.Media3D.Point3DConverter", true);
			types[KnownTypes.Point3DKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.Point3DKeyFrame", true);
			types[KnownTypes.Point3DKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.Point3DKeyFrameCollection", true);
			types[KnownTypes.Point4D] = assemblies[1].Find("System.Windows.Media.Media3D.Point4D", true);
			types[KnownTypes.Point4DConverter] = assemblies[1].Find("System.Windows.Media.Media3D.Point4DConverter", true);
			types[KnownTypes.PointAnimation] = assemblies[1].Find("System.Windows.Media.Animation.PointAnimation", true);
			types[KnownTypes.PointAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.PointAnimationBase", true);
			types[KnownTypes.PointAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.PointAnimationUsingKeyFrames", true);
			types[KnownTypes.PointAnimationUsingPath] = assemblies[1].Find("System.Windows.Media.Animation.PointAnimationUsingPath", true);
			types[KnownTypes.PointCollection] = assemblies[1].Find("System.Windows.Media.PointCollection", true);
			types[KnownTypes.PointCollectionConverter] = assemblies[1].Find("System.Windows.Media.PointCollectionConverter", true);
			types[KnownTypes.PointConverter] = assemblies[4].Find("System.Windows.PointConverter", true);
			types[KnownTypes.PointIListConverter] = assemblies[1].Find("System.Windows.Media.Converters.PointIListConverter", true);
			types[KnownTypes.PointKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.PointKeyFrame", true);
			types[KnownTypes.PointKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.PointKeyFrameCollection", true);
			types[KnownTypes.PointLight] = assemblies[1].Find("System.Windows.Media.Media3D.PointLight", true);
			types[KnownTypes.PointLightBase] = assemblies[1].Find("System.Windows.Media.Media3D.PointLightBase", true);
			types[KnownTypes.PolyBezierSegment] = assemblies[1].Find("System.Windows.Media.PolyBezierSegment", true);
			types[KnownTypes.PolyLineSegment] = assemblies[1].Find("System.Windows.Media.PolyLineSegment", true);
			types[KnownTypes.PolyQuadraticBezierSegment] = assemblies[1].Find("System.Windows.Media.PolyQuadraticBezierSegment", true);
			types[KnownTypes.Polygon] = assemblies[0].Find("System.Windows.Shapes.Polygon", true);
			types[KnownTypes.Polyline] = assemblies[0].Find("System.Windows.Shapes.Polyline", true);
			types[KnownTypes.Popup] = assemblies[0].Find("System.Windows.Controls.Primitives.Popup", true);
			types[KnownTypes.PresentationSource] = assemblies[1].Find("System.Windows.PresentationSource", true);
			types[KnownTypes.PriorityBinding] = assemblies[0].Find("System.Windows.Data.PriorityBinding", true);
			types[KnownTypes.PriorityBindingExpression] = assemblies[0].Find("System.Windows.Data.PriorityBindingExpression", true);
			types[KnownTypes.ProgressBar] = assemblies[0].Find("System.Windows.Controls.ProgressBar", true);
			types[KnownTypes.ProjectionCamera] = assemblies[1].Find("System.Windows.Media.Media3D.ProjectionCamera", true);
			types[KnownTypes.PropertyPath] = assemblies[0].Find("System.Windows.PropertyPath", true);
			types[KnownTypes.PropertyPathConverter] = assemblies[0].Find("System.Windows.PropertyPathConverter", true);
			types[KnownTypes.QuadraticBezierSegment] = assemblies[1].Find("System.Windows.Media.QuadraticBezierSegment", true);
			types[KnownTypes.Quaternion] = assemblies[1].Find("System.Windows.Media.Media3D.Quaternion", true);
			types[KnownTypes.QuaternionAnimation] = assemblies[1].Find("System.Windows.Media.Animation.QuaternionAnimation", true);
			types[KnownTypes.QuaternionAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.QuaternionAnimationBase", true);
			types[KnownTypes.QuaternionAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.QuaternionAnimationUsingKeyFrames", true);
			types[KnownTypes.QuaternionConverter] = assemblies[1].Find("System.Windows.Media.Media3D.QuaternionConverter", true);
			types[KnownTypes.QuaternionKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.QuaternionKeyFrame", true);
			types[KnownTypes.QuaternionKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.QuaternionKeyFrameCollection", true);
			types[KnownTypes.QuaternionRotation3D] = assemblies[1].Find("System.Windows.Media.Media3D.QuaternionRotation3D", true);
			types[KnownTypes.RadialGradientBrush] = assemblies[1].Find("System.Windows.Media.RadialGradientBrush", true);
			types[KnownTypes.RadioButton] = assemblies[0].Find("System.Windows.Controls.RadioButton", true);
			types[KnownTypes.RangeBase] = assemblies[0].Find("System.Windows.Controls.Primitives.RangeBase", true);
			types[KnownTypes.Rect] = assemblies[4].Find("System.Windows.Rect", true);
			types[KnownTypes.Rect3D] = assemblies[1].Find("System.Windows.Media.Media3D.Rect3D", true);
			types[KnownTypes.Rect3DConverter] = assemblies[1].Find("System.Windows.Media.Media3D.Rect3DConverter", true);
			types[KnownTypes.RectAnimation] = assemblies[1].Find("System.Windows.Media.Animation.RectAnimation", true);
			types[KnownTypes.RectAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.RectAnimationBase", true);
			types[KnownTypes.RectAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.RectAnimationUsingKeyFrames", true);
			types[KnownTypes.RectConverter] = assemblies[4].Find("System.Windows.RectConverter", true);
			types[KnownTypes.RectKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.RectKeyFrame", true);
			types[KnownTypes.RectKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.RectKeyFrameCollection", true);
			types[KnownTypes.Rectangle] = assemblies[0].Find("System.Windows.Shapes.Rectangle", true);
			types[KnownTypes.RectangleGeometry] = assemblies[1].Find("System.Windows.Media.RectangleGeometry", true);
			types[KnownTypes.RelativeSource] = assemblies[0].Find("System.Windows.Data.RelativeSource", true);
			types[KnownTypes.RemoveStoryboard] = assemblies[0].Find("System.Windows.Media.Animation.RemoveStoryboard", true);
			types[KnownTypes.RenderOptions] = assemblies[1].Find("System.Windows.Media.RenderOptions", true);
			types[KnownTypes.RenderTargetBitmap] = assemblies[1].Find("System.Windows.Media.Imaging.RenderTargetBitmap", true);
			types[KnownTypes.RepeatBehavior] = assemblies[1].Find("System.Windows.Media.Animation.RepeatBehavior", true);
			types[KnownTypes.RepeatBehaviorConverter] = assemblies[1].Find("System.Windows.Media.Animation.RepeatBehaviorConverter", true);
			types[KnownTypes.RepeatButton] = assemblies[0].Find("System.Windows.Controls.Primitives.RepeatButton", true);
			types[KnownTypes.ResizeGrip] = assemblies[0].Find("System.Windows.Controls.Primitives.ResizeGrip", true);
			types[KnownTypes.ResourceDictionary] = assemblies[0].Find("System.Windows.ResourceDictionary", true);
			types[KnownTypes.ResourceKey] = assemblies[0].Find("System.Windows.ResourceKey", true);
			types[KnownTypes.ResumeStoryboard] = assemblies[0].Find("System.Windows.Media.Animation.ResumeStoryboard", true);
			types[KnownTypes.RichTextBox] = assemblies[0].Find("System.Windows.Controls.RichTextBox", true);
			types[KnownTypes.RotateTransform] = assemblies[1].Find("System.Windows.Media.RotateTransform", true);
			types[KnownTypes.RotateTransform3D] = assemblies[1].Find("System.Windows.Media.Media3D.RotateTransform3D", true);
			types[KnownTypes.Rotation3D] = assemblies[1].Find("System.Windows.Media.Media3D.Rotation3D", true);
			types[KnownTypes.Rotation3DAnimation] = assemblies[1].Find("System.Windows.Media.Animation.Rotation3DAnimation", true);
			types[KnownTypes.Rotation3DAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.Rotation3DAnimationBase", true);
			types[KnownTypes.Rotation3DAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.Rotation3DAnimationUsingKeyFrames", true);
			types[KnownTypes.Rotation3DKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.Rotation3DKeyFrame", true);
			types[KnownTypes.Rotation3DKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.Rotation3DKeyFrameCollection", true);
			types[KnownTypes.RoutedCommand] = assemblies[1].Find("System.Windows.Input.RoutedCommand", true);
			types[KnownTypes.RoutedEvent] = assemblies[1].Find("System.Windows.RoutedEvent", true);
			types[KnownTypes.RoutedEventConverter] = assemblies[0].Find("System.Windows.Markup.RoutedEventConverter", true);
			types[KnownTypes.RoutedUICommand] = assemblies[1].Find("System.Windows.Input.RoutedUICommand", true);
			types[KnownTypes.RoutingStrategy] = assemblies[1].Find("System.Windows.RoutingStrategy", true);
			types[KnownTypes.RowDefinition] = assemblies[0].Find("System.Windows.Controls.RowDefinition", true);
			types[KnownTypes.Run] = assemblies[0].Find("System.Windows.Documents.Run", true);
			types[KnownTypes.RuntimeNamePropertyAttribute] = assemblies[4].Find("System.Windows.Markup.RuntimeNamePropertyAttribute", true);
			types[KnownTypes.SByte] = assemblies[2].Find("System.SByte", true);
			types[KnownTypes.SByteConverter] = assemblies[3].Find("System.ComponentModel.SByteConverter", true);
			types[KnownTypes.ScaleTransform] = assemblies[1].Find("System.Windows.Media.ScaleTransform", true);
			types[KnownTypes.ScaleTransform3D] = assemblies[1].Find("System.Windows.Media.Media3D.ScaleTransform3D", true);
			types[KnownTypes.ScrollBar] = assemblies[0].Find("System.Windows.Controls.Primitives.ScrollBar", true);
			types[KnownTypes.ScrollContentPresenter] = assemblies[0].Find("System.Windows.Controls.ScrollContentPresenter", true);
			types[KnownTypes.ScrollViewer] = assemblies[0].Find("System.Windows.Controls.ScrollViewer", true);
			types[KnownTypes.Section] = assemblies[0].Find("System.Windows.Documents.Section", true);
			types[KnownTypes.SeekStoryboard] = assemblies[0].Find("System.Windows.Media.Animation.SeekStoryboard", true);
			types[KnownTypes.Selector] = assemblies[0].Find("System.Windows.Controls.Primitives.Selector", true);
			types[KnownTypes.Separator] = assemblies[0].Find("System.Windows.Controls.Separator", true);
			types[KnownTypes.SetStoryboardSpeedRatio] = assemblies[0].Find("System.Windows.Media.Animation.SetStoryboardSpeedRatio", true);
			types[KnownTypes.Setter] = assemblies[0].Find("System.Windows.Setter", true);
			types[KnownTypes.SetterBase] = assemblies[0].Find("System.Windows.SetterBase", true);
			types[KnownTypes.Shape] = assemblies[0].Find("System.Windows.Shapes.Shape", true);
			types[KnownTypes.Single] = assemblies[2].Find("System.Single", true);
			types[KnownTypes.SingleAnimation] = assemblies[1].Find("System.Windows.Media.Animation.SingleAnimation", true);
			types[KnownTypes.SingleAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.SingleAnimationBase", true);
			types[KnownTypes.SingleAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.SingleAnimationUsingKeyFrames", true);
			types[KnownTypes.SingleConverter] = assemblies[3].Find("System.ComponentModel.SingleConverter", true);
			types[KnownTypes.SingleKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SingleKeyFrame", true);
			types[KnownTypes.SingleKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.SingleKeyFrameCollection", true);
			types[KnownTypes.Size] = assemblies[4].Find("System.Windows.Size", true);
			types[KnownTypes.Size3D] = assemblies[1].Find("System.Windows.Media.Media3D.Size3D", true);
			types[KnownTypes.Size3DConverter] = assemblies[1].Find("System.Windows.Media.Media3D.Size3DConverter", true);
			types[KnownTypes.SizeAnimation] = assemblies[1].Find("System.Windows.Media.Animation.SizeAnimation", true);
			types[KnownTypes.SizeAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.SizeAnimationBase", true);
			types[KnownTypes.SizeAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.SizeAnimationUsingKeyFrames", true);
			types[KnownTypes.SizeConverter] = assemblies[4].Find("System.Windows.SizeConverter", true);
			types[KnownTypes.SizeKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SizeKeyFrame", true);
			types[KnownTypes.SizeKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.SizeKeyFrameCollection", true);
			types[KnownTypes.SkewTransform] = assemblies[1].Find("System.Windows.Media.SkewTransform", true);
			types[KnownTypes.SkipStoryboardToFill] = assemblies[0].Find("System.Windows.Media.Animation.SkipStoryboardToFill", true);
			types[KnownTypes.Slider] = assemblies[0].Find("System.Windows.Controls.Slider", true);
			types[KnownTypes.SolidColorBrush] = assemblies[1].Find("System.Windows.Media.SolidColorBrush", true);
			types[KnownTypes.SoundPlayerAction] = assemblies[0].Find("System.Windows.Controls.SoundPlayerAction", true);
			types[KnownTypes.Span] = assemblies[0].Find("System.Windows.Documents.Span", true);
			types[KnownTypes.SpecularMaterial] = assemblies[1].Find("System.Windows.Media.Media3D.SpecularMaterial", true);
			types[KnownTypes.SpellCheck] = assemblies[0].Find("System.Windows.Controls.SpellCheck", true);
			types[KnownTypes.SplineByteKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineByteKeyFrame", true);
			types[KnownTypes.SplineColorKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineColorKeyFrame", true);
			types[KnownTypes.SplineDecimalKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineDecimalKeyFrame", true);
			types[KnownTypes.SplineDoubleKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineDoubleKeyFrame", true);
			types[KnownTypes.SplineInt16KeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineInt16KeyFrame", true);
			types[KnownTypes.SplineInt32KeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineInt32KeyFrame", true);
			types[KnownTypes.SplineInt64KeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineInt64KeyFrame", true);
			types[KnownTypes.SplinePoint3DKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplinePoint3DKeyFrame", true);
			types[KnownTypes.SplinePointKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplinePointKeyFrame", true);
			types[KnownTypes.SplineQuaternionKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineQuaternionKeyFrame", true);
			types[KnownTypes.SplineRectKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineRectKeyFrame", true);
			types[KnownTypes.SplineRotation3DKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineRotation3DKeyFrame", true);
			types[KnownTypes.SplineSingleKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineSingleKeyFrame", true);
			types[KnownTypes.SplineSizeKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineSizeKeyFrame", true);
			types[KnownTypes.SplineThicknessKeyFrame] = assemblies[0].Find("System.Windows.Media.Animation.SplineThicknessKeyFrame", true);
			types[KnownTypes.SplineVector3DKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineVector3DKeyFrame", true);
			types[KnownTypes.SplineVectorKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineVectorKeyFrame", true);
			types[KnownTypes.SpotLight] = assemblies[1].Find("System.Windows.Media.Media3D.SpotLight", true);
			types[KnownTypes.StackPanel] = assemblies[0].Find("System.Windows.Controls.StackPanel", true);
			types[KnownTypes.StaticExtension] = assemblies[0].Find("System.Windows.Markup.StaticExtension", true);
			types[KnownTypes.StaticResourceExtension] = assemblies[0].Find("System.Windows.StaticResourceExtension", true);
			types[KnownTypes.StatusBar] = assemblies[0].Find("System.Windows.Controls.Primitives.StatusBar", true);
			types[KnownTypes.StatusBarItem] = assemblies[0].Find("System.Windows.Controls.Primitives.StatusBarItem", true);
			types[KnownTypes.StickyNoteControl] = assemblies[0].Find("System.Windows.Controls.StickyNoteControl", true);
			types[KnownTypes.StopStoryboard] = assemblies[0].Find("System.Windows.Media.Animation.StopStoryboard", true);
			types[KnownTypes.Storyboard] = assemblies[0].Find("System.Windows.Media.Animation.Storyboard", true);
			types[KnownTypes.StreamGeometry] = assemblies[1].Find("System.Windows.Media.StreamGeometry", true);
			types[KnownTypes.StreamGeometryContext] = assemblies[1].Find("System.Windows.Media.StreamGeometryContext", true);
			types[KnownTypes.StreamResourceInfo] = assemblies[0].Find("System.Windows.Resources.StreamResourceInfo", true);
			types[KnownTypes.String] = assemblies[2].Find("System.String", true);
			types[KnownTypes.StringAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.StringAnimationBase", true);
			types[KnownTypes.StringAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.StringAnimationUsingKeyFrames", true);
			types[KnownTypes.StringConverter] = assemblies[3].Find("System.ComponentModel.StringConverter", true);
			types[KnownTypes.StringKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.StringKeyFrame", true);
			types[KnownTypes.StringKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.StringKeyFrameCollection", true);
			types[KnownTypes.StrokeCollection] = assemblies[1].Find("System.Windows.Ink.StrokeCollection", true);
			types[KnownTypes.StrokeCollectionConverter] = assemblies[1].Find("System.Windows.StrokeCollectionConverter", true);
			types[KnownTypes.Style] = assemblies[0].Find("System.Windows.Style", true);
			types[KnownTypes.Stylus] = assemblies[1].Find("System.Windows.Input.Stylus", true);
			types[KnownTypes.StylusDevice] = assemblies[1].Find("System.Windows.Input.StylusDevice", true);
			types[KnownTypes.TabControl] = assemblies[0].Find("System.Windows.Controls.TabControl", true);
			types[KnownTypes.TabItem] = assemblies[0].Find("System.Windows.Controls.TabItem", true);
			types[KnownTypes.TabPanel] = assemblies[0].Find("System.Windows.Controls.Primitives.TabPanel", true);
			types[KnownTypes.Table] = assemblies[0].Find("System.Windows.Documents.Table", true);
			types[KnownTypes.TableCell] = assemblies[0].Find("System.Windows.Documents.TableCell", true);
			types[KnownTypes.TableColumn] = assemblies[0].Find("System.Windows.Documents.TableColumn", true);
			types[KnownTypes.TableRow] = assemblies[0].Find("System.Windows.Documents.TableRow", true);
			types[KnownTypes.TableRowGroup] = assemblies[0].Find("System.Windows.Documents.TableRowGroup", true);
			types[KnownTypes.TabletDevice] = assemblies[1].Find("System.Windows.Input.TabletDevice", true);
			types[KnownTypes.TemplateBindingExpression] = assemblies[0].Find("System.Windows.TemplateBindingExpression", true);
			types[KnownTypes.TemplateBindingExpressionConverter] = assemblies[0].Find("System.Windows.TemplateBindingExpressionConverter", true);
			types[KnownTypes.TemplateBindingExtension] = assemblies[0].Find("System.Windows.TemplateBindingExtension", true);
			types[KnownTypes.TemplateBindingExtensionConverter] = assemblies[0].Find("System.Windows.TemplateBindingExtensionConverter", true);
			types[KnownTypes.TemplateKey] = assemblies[0].Find("System.Windows.TemplateKey", true);
			types[KnownTypes.TemplateKeyConverter] = assemblies[0].Find("System.Windows.Markup.TemplateKeyConverter", true);
			types[KnownTypes.TextBlock] = assemblies[0].Find("System.Windows.Controls.TextBlock", true);
			types[KnownTypes.TextBox] = assemblies[0].Find("System.Windows.Controls.TextBox", true);
			types[KnownTypes.TextBoxBase] = assemblies[0].Find("System.Windows.Controls.Primitives.TextBoxBase", true);
			types[KnownTypes.TextComposition] = assemblies[1].Find("System.Windows.Input.TextComposition", true);
			types[KnownTypes.TextCompositionManager] = assemblies[1].Find("System.Windows.Input.TextCompositionManager", true);
			types[KnownTypes.TextDecoration] = assemblies[1].Find("System.Windows.TextDecoration", true);
			types[KnownTypes.TextDecorationCollection] = assemblies[1].Find("System.Windows.TextDecorationCollection", true);
			types[KnownTypes.TextDecorationCollectionConverter] = assemblies[1].Find("System.Windows.TextDecorationCollectionConverter", true);
			types[KnownTypes.TextEffect] = assemblies[1].Find("System.Windows.Media.TextEffect", true);
			types[KnownTypes.TextEffectCollection] = assemblies[1].Find("System.Windows.Media.TextEffectCollection", true);
			types[KnownTypes.TextElement] = assemblies[0].Find("System.Windows.Documents.TextElement", true);
			types[KnownTypes.TextSearch] = assemblies[0].Find("System.Windows.Controls.TextSearch", true);
			types[KnownTypes.ThemeDictionaryExtension] = assemblies[0].Find("System.Windows.ThemeDictionaryExtension", true);
			types[KnownTypes.Thickness] = assemblies[0].Find("System.Windows.Thickness", true);
			types[KnownTypes.ThicknessAnimation] = assemblies[0].Find("System.Windows.Media.Animation.ThicknessAnimation", true);
			types[KnownTypes.ThicknessAnimationBase] = assemblies[0].Find("System.Windows.Media.Animation.ThicknessAnimationBase", true);
			types[KnownTypes.ThicknessAnimationUsingKeyFrames] = assemblies[0].Find("System.Windows.Media.Animation.ThicknessAnimationUsingKeyFrames", true);
			types[KnownTypes.ThicknessConverter] = assemblies[0].Find("System.Windows.ThicknessConverter", true);
			types[KnownTypes.ThicknessKeyFrame] = assemblies[0].Find("System.Windows.Media.Animation.ThicknessKeyFrame", true);
			types[KnownTypes.ThicknessKeyFrameCollection] = assemblies[0].Find("System.Windows.Media.Animation.ThicknessKeyFrameCollection", true);
			types[KnownTypes.Thumb] = assemblies[0].Find("System.Windows.Controls.Primitives.Thumb", true);
			types[KnownTypes.TickBar] = assemblies[0].Find("System.Windows.Controls.Primitives.TickBar", true);
			types[KnownTypes.TiffBitmapDecoder] = assemblies[1].Find("System.Windows.Media.Imaging.TiffBitmapDecoder", true);
			types[KnownTypes.TiffBitmapEncoder] = assemblies[1].Find("System.Windows.Media.Imaging.TiffBitmapEncoder", true);
			types[KnownTypes.TileBrush] = assemblies[1].Find("System.Windows.Media.TileBrush", true);
			types[KnownTypes.TimeSpan] = assemblies[2].Find("System.TimeSpan", true);
			types[KnownTypes.TimeSpanConverter] = assemblies[3].Find("System.ComponentModel.TimeSpanConverter", true);
			types[KnownTypes.Timeline] = assemblies[1].Find("System.Windows.Media.Animation.Timeline", true);
			types[KnownTypes.TimelineCollection] = assemblies[1].Find("System.Windows.Media.Animation.TimelineCollection", true);
			types[KnownTypes.TimelineGroup] = assemblies[1].Find("System.Windows.Media.Animation.TimelineGroup", true);
			types[KnownTypes.ToggleButton] = assemblies[0].Find("System.Windows.Controls.Primitives.ToggleButton", true);
			types[KnownTypes.ToolBar] = assemblies[0].Find("System.Windows.Controls.ToolBar", true);
			types[KnownTypes.ToolBarOverflowPanel] = assemblies[0].Find("System.Windows.Controls.Primitives.ToolBarOverflowPanel", true);
			types[KnownTypes.ToolBarPanel] = assemblies[0].Find("System.Windows.Controls.Primitives.ToolBarPanel", true);
			types[KnownTypes.ToolBarTray] = assemblies[0].Find("System.Windows.Controls.ToolBarTray", true);
			types[KnownTypes.ToolTip] = assemblies[0].Find("System.Windows.Controls.ToolTip", true);
			types[KnownTypes.ToolTipService] = assemblies[0].Find("System.Windows.Controls.ToolTipService", true);
			types[KnownTypes.Track] = assemblies[0].Find("System.Windows.Controls.Primitives.Track", true);
			types[KnownTypes.Transform] = assemblies[1].Find("System.Windows.Media.Transform", true);
			types[KnownTypes.Transform3D] = assemblies[1].Find("System.Windows.Media.Media3D.Transform3D", true);
			types[KnownTypes.Transform3DCollection] = assemblies[1].Find("System.Windows.Media.Media3D.Transform3DCollection", true);
			types[KnownTypes.Transform3DGroup] = assemblies[1].Find("System.Windows.Media.Media3D.Transform3DGroup", true);
			types[KnownTypes.TransformCollection] = assemblies[1].Find("System.Windows.Media.TransformCollection", true);
			types[KnownTypes.TransformConverter] = assemblies[1].Find("System.Windows.Media.TransformConverter", true);
			types[KnownTypes.TransformGroup] = assemblies[1].Find("System.Windows.Media.TransformGroup", true);
			types[KnownTypes.TransformedBitmap] = assemblies[1].Find("System.Windows.Media.Imaging.TransformedBitmap", true);
			types[KnownTypes.TranslateTransform] = assemblies[1].Find("System.Windows.Media.TranslateTransform", true);
			types[KnownTypes.TranslateTransform3D] = assemblies[1].Find("System.Windows.Media.Media3D.TranslateTransform3D", true);
			types[KnownTypes.TreeView] = assemblies[0].Find("System.Windows.Controls.TreeView", true);
			types[KnownTypes.TreeViewItem] = assemblies[0].Find("System.Windows.Controls.TreeViewItem", true);
			types[KnownTypes.Trigger] = assemblies[0].Find("System.Windows.Trigger", true);
			types[KnownTypes.TriggerAction] = assemblies[0].Find("System.Windows.TriggerAction", true);
			types[KnownTypes.TriggerBase] = assemblies[0].Find("System.Windows.TriggerBase", true);
			types[KnownTypes.TypeExtension] = assemblies[0].Find("System.Windows.Markup.TypeExtension", true);
			types[KnownTypes.TypeTypeConverter] = assemblies[4].Find("System.Windows.Markup.TypeTypeConverter", true);
			types[KnownTypes.Typography] = assemblies[0].Find("System.Windows.Documents.Typography", true);
			types[KnownTypes.UIElement] = assemblies[1].Find("System.Windows.UIElement", true);
			types[KnownTypes.UInt16] = assemblies[2].Find("System.UInt16", true);
			types[KnownTypes.UInt16Converter] = assemblies[3].Find("System.ComponentModel.UInt16Converter", true);
			types[KnownTypes.UInt32] = assemblies[2].Find("System.UInt32", true);
			types[KnownTypes.UInt32Converter] = assemblies[3].Find("System.ComponentModel.UInt32Converter", true);
			types[KnownTypes.UInt64] = assemblies[2].Find("System.UInt64", true);
			types[KnownTypes.UInt64Converter] = assemblies[3].Find("System.ComponentModel.UInt64Converter", true);
			types[KnownTypes.UShortIListConverter] = assemblies[1].Find("System.Windows.Media.Converters.UShortIListConverter", true);
			types[KnownTypes.Underline] = assemblies[0].Find("System.Windows.Documents.Underline", true);
			types[KnownTypes.UniformGrid] = assemblies[0].Find("System.Windows.Controls.Primitives.UniformGrid", true);
			types[KnownTypes.Uri] = assemblies[3].Find("System.Uri", true);
			types[KnownTypes.UriTypeConverter] = assemblies[3].Find("System.UriTypeConverter", true);
			types[KnownTypes.UserControl] = assemblies[0].Find("System.Windows.Controls.UserControl", true);
			types[KnownTypes.Validation] = assemblies[0].Find("System.Windows.Controls.Validation", true);
			types[KnownTypes.Vector] = assemblies[4].Find("System.Windows.Vector", true);
			types[KnownTypes.Vector3D] = assemblies[1].Find("System.Windows.Media.Media3D.Vector3D", true);
			types[KnownTypes.Vector3DAnimation] = assemblies[1].Find("System.Windows.Media.Animation.Vector3DAnimation", true);
			types[KnownTypes.Vector3DAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.Vector3DAnimationBase", true);
			types[KnownTypes.Vector3DAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.Vector3DAnimationUsingKeyFrames", true);
			types[KnownTypes.Vector3DCollection] = assemblies[1].Find("System.Windows.Media.Media3D.Vector3DCollection", true);
			types[KnownTypes.Vector3DCollectionConverter] = assemblies[1].Find("System.Windows.Media.Media3D.Vector3DCollectionConverter", true);
			types[KnownTypes.Vector3DConverter] = assemblies[1].Find("System.Windows.Media.Media3D.Vector3DConverter", true);
			types[KnownTypes.Vector3DKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.Vector3DKeyFrame", true);
			types[KnownTypes.Vector3DKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.Vector3DKeyFrameCollection", true);
			types[KnownTypes.VectorAnimation] = assemblies[1].Find("System.Windows.Media.Animation.VectorAnimation", true);
			types[KnownTypes.VectorAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.VectorAnimationBase", true);
			types[KnownTypes.VectorAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.VectorAnimationUsingKeyFrames", true);
			types[KnownTypes.VectorCollection] = assemblies[1].Find("System.Windows.Media.VectorCollection", true);
			types[KnownTypes.VectorCollectionConverter] = assemblies[1].Find("System.Windows.Media.VectorCollectionConverter", true);
			types[KnownTypes.VectorConverter] = assemblies[4].Find("System.Windows.VectorConverter", true);
			types[KnownTypes.VectorKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.VectorKeyFrame", true);
			types[KnownTypes.VectorKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.VectorKeyFrameCollection", true);
			types[KnownTypes.VideoDrawing] = assemblies[1].Find("System.Windows.Media.VideoDrawing", true);
			types[KnownTypes.ViewBase] = assemblies[0].Find("System.Windows.Controls.ViewBase", true);
			types[KnownTypes.Viewbox] = assemblies[0].Find("System.Windows.Controls.Viewbox", true);
			types[KnownTypes.Viewport3D] = assemblies[0].Find("System.Windows.Controls.Viewport3D", true);
			types[KnownTypes.Viewport3DVisual] = assemblies[1].Find("System.Windows.Media.Media3D.Viewport3DVisual", true);
			types[KnownTypes.VirtualizingPanel] = assemblies[0].Find("System.Windows.Controls.VirtualizingPanel", true);
			types[KnownTypes.VirtualizingStackPanel] = assemblies[0].Find("System.Windows.Controls.VirtualizingStackPanel", true);
			types[KnownTypes.Visual] = assemblies[1].Find("System.Windows.Media.Visual", true);
			types[KnownTypes.Visual3D] = assemblies[1].Find("System.Windows.Media.Media3D.Visual3D", true);
			types[KnownTypes.VisualBrush] = assemblies[1].Find("System.Windows.Media.VisualBrush", true);
			types[KnownTypes.VisualTarget] = assemblies[1].Find("System.Windows.Media.VisualTarget", true);
			types[KnownTypes.WeakEventManager] = assemblies[4].Find("System.Windows.WeakEventManager", true);
			types[KnownTypes.WhitespaceSignificantCollectionAttribute] = assemblies[4].Find("System.Windows.Markup.WhitespaceSignificantCollectionAttribute", true);
			types[KnownTypes.Window] = assemblies[0].Find("System.Windows.Window", true);
			types[KnownTypes.WmpBitmapDecoder] = assemblies[1].Find("System.Windows.Media.Imaging.WmpBitmapDecoder", true);
			types[KnownTypes.WmpBitmapEncoder] = assemblies[1].Find("System.Windows.Media.Imaging.WmpBitmapEncoder", true);
			types[KnownTypes.WrapPanel] = assemblies[0].Find("System.Windows.Controls.WrapPanel", true);
			types[KnownTypes.WriteableBitmap] = assemblies[1].Find("System.Windows.Media.Imaging.WriteableBitmap", true);
			types[KnownTypes.XamlBrushSerializer] = assemblies[0].Find("System.Windows.Markup.XamlBrushSerializer", true);
			types[KnownTypes.XamlInt32CollectionSerializer] = assemblies[0].Find("System.Windows.Markup.XamlInt32CollectionSerializer", true);
			types[KnownTypes.XamlPathDataSerializer] = assemblies[0].Find("System.Windows.Markup.XamlPathDataSerializer", true);
			types[KnownTypes.XamlPoint3DCollectionSerializer] = assemblies[0].Find("System.Windows.Markup.XamlPoint3DCollectionSerializer", true);
			types[KnownTypes.XamlPointCollectionSerializer] = assemblies[0].Find("System.Windows.Markup.XamlPointCollectionSerializer", true);
			types[KnownTypes.XamlReader] = assemblies[0].Find("System.Windows.Markup.XamlReader", true);
			types[KnownTypes.XamlStyleSerializer] = assemblies[0].Find("System.Windows.Markup.XamlStyleSerializer", true);
			types[KnownTypes.XamlTemplateSerializer] = assemblies[0].Find("System.Windows.Markup.XamlTemplateSerializer", true);
			types[KnownTypes.XamlVector3DCollectionSerializer] = assemblies[0].Find("System.Windows.Markup.XamlVector3DCollectionSerializer", true);
			types[KnownTypes.XamlWriter] = assemblies[0].Find("System.Windows.Markup.XamlWriter", true);
			types[KnownTypes.XmlDataProvider] = assemblies[0].Find("System.Windows.Data.XmlDataProvider", true);
			types[KnownTypes.XmlLangPropertyAttribute] = assemblies[4].Find("System.Windows.Markup.XmlLangPropertyAttribute", true);
			types[KnownTypes.XmlLanguage] = assemblies[1].Find("System.Windows.Markup.XmlLanguage", true);
			types[KnownTypes.XmlLanguageConverter] = assemblies[1].Find("System.Windows.Markup.XmlLanguageConverter", true);
			types[KnownTypes.XmlNamespaceMapping] = assemblies[0].Find("System.Windows.Data.XmlNamespaceMapping", true);
			types[KnownTypes.ZoomPercentageConverter] = assemblies[0].Find("System.Windows.Documents.ZoomPercentageConverter", true);
		}

		void InitProperties() {
			properties[KnownProperties.AccessText_Text] = InitProperty(KnownTypes.AccessText, "Text", assemblies[2].Find("System.Char", true));
			properties[KnownProperties.BeginStoryboard_Storyboard] = InitProperty(KnownTypes.BeginStoryboard, "Storyboard", assemblies[0].Find("System.Windows.Media.Animation.Storyboard", true));
			properties[KnownProperties.BitmapEffectGroup_Children] = InitProperty(KnownTypes.BitmapEffectGroup, "Children", assemblies[1].Find("System.Windows.Media.Effects.BitmapEffect", true));
			properties[KnownProperties.Border_Background] = InitProperty(KnownTypes.Border, "Background", assemblies[1].Find("System.Windows.Media.Brush", true));
			properties[KnownProperties.Border_BorderBrush] = InitProperty(KnownTypes.Border, "BorderBrush", assemblies[1].Find("System.Windows.Media.Brush", true));
			properties[KnownProperties.Border_BorderThickness] = InitProperty(KnownTypes.Border, "BorderThickness", assemblies[0].Find("System.Windows.Thickness", true));
			properties[KnownProperties.ButtonBase_Command] = InitProperty(KnownTypes.ButtonBase, "Command", assemblies[1].Find("System.Windows.Input.ICommand", true));
			properties[KnownProperties.ButtonBase_CommandParameter] = InitProperty(KnownTypes.ButtonBase, "CommandParameter", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.ButtonBase_CommandTarget] = InitProperty(KnownTypes.ButtonBase, "CommandTarget", assemblies[1].Find("System.Windows.IInputElement", true));
			properties[KnownProperties.ButtonBase_IsPressed] = InitProperty(KnownTypes.ButtonBase, "IsPressed", assemblies[2].Find("System.Boolean", true));
			properties[KnownProperties.ColumnDefinition_MaxWidth] = InitProperty(KnownTypes.ColumnDefinition, "MaxWidth", assemblies[2].Find("System.Double", true));
			properties[KnownProperties.ColumnDefinition_MinWidth] = InitProperty(KnownTypes.ColumnDefinition, "MinWidth", assemblies[2].Find("System.Double", true));
			properties[KnownProperties.ColumnDefinition_Width] = InitProperty(KnownTypes.ColumnDefinition, "Width", assemblies[0].Find("System.Windows.GridLength", true));
			properties[KnownProperties.ContentControl_Content] = InitProperty(KnownTypes.ContentControl, "Content", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.ContentControl_ContentTemplate] = InitProperty(KnownTypes.ContentControl, "ContentTemplate", assemblies[0].Find("System.Windows.DataTemplate", true));
			properties[KnownProperties.ContentControl_ContentTemplateSelector] = InitProperty(KnownTypes.ContentControl, "ContentTemplateSelector", assemblies[0].Find("System.Windows.Controls.DataTemplateSelector", true));
			properties[KnownProperties.ContentControl_HasContent] = InitProperty(KnownTypes.ContentControl, "HasContent", assemblies[2].Find("System.Boolean", true));
			properties[KnownProperties.ContentElement_Focusable] = InitProperty(KnownTypes.ContentElement, "Focusable", assemblies[2].Find("System.Boolean", true));
			properties[KnownProperties.ContentPresenter_Content] = InitProperty(KnownTypes.ContentPresenter, "Content", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.ContentPresenter_ContentSource] = InitProperty(KnownTypes.ContentPresenter, "ContentSource", assemblies[2].Find("System.Char", true));
			properties[KnownProperties.ContentPresenter_ContentTemplate] = InitProperty(KnownTypes.ContentPresenter, "ContentTemplate", assemblies[0].Find("System.Windows.DataTemplate", true));
			properties[KnownProperties.ContentPresenter_ContentTemplateSelector] = InitProperty(KnownTypes.ContentPresenter, "ContentTemplateSelector", assemblies[0].Find("System.Windows.Controls.DataTemplateSelector", true));
			properties[KnownProperties.ContentPresenter_RecognizesAccessKey] = InitProperty(KnownTypes.ContentPresenter, "RecognizesAccessKey", assemblies[2].Find("System.Boolean", true));
			properties[KnownProperties.Control_Background] = InitProperty(KnownTypes.Control, "Background", assemblies[1].Find("System.Windows.Media.Brush", true));
			properties[KnownProperties.Control_BorderBrush] = InitProperty(KnownTypes.Control, "BorderBrush", assemblies[1].Find("System.Windows.Media.Brush", true));
			properties[KnownProperties.Control_BorderThickness] = InitProperty(KnownTypes.Control, "BorderThickness", assemblies[0].Find("System.Windows.Thickness", true));
			properties[KnownProperties.Control_FontFamily] = InitProperty(KnownTypes.Control, "FontFamily", assemblies[1].Find("System.Windows.Media.FontFamily", true));
			properties[KnownProperties.Control_FontSize] = InitProperty(KnownTypes.Control, "FontSize", assemblies[2].Find("System.Double", true));
			properties[KnownProperties.Control_FontStretch] = InitProperty(KnownTypes.Control, "FontStretch", assemblies[1].Find("System.Windows.FontStretch", true));
			properties[KnownProperties.Control_FontStyle] = InitProperty(KnownTypes.Control, "FontStyle", assemblies[1].Find("System.Windows.FontStyle", true));
			properties[KnownProperties.Control_FontWeight] = InitProperty(KnownTypes.Control, "FontWeight", assemblies[1].Find("System.Windows.FontWeight", true));
			properties[KnownProperties.Control_Foreground] = InitProperty(KnownTypes.Control, "Foreground", assemblies[1].Find("System.Windows.Media.Brush", true));
			properties[KnownProperties.Control_HorizontalContentAlignment] = InitProperty(KnownTypes.Control, "HorizontalContentAlignment", assemblies[0].Find("System.Windows.HorizontalAlignment", true));
			properties[KnownProperties.Control_IsTabStop] = InitProperty(KnownTypes.Control, null, assemblies[2].Find("System.Boolean", true));
			properties[KnownProperties.Control_Padding] = InitProperty(KnownTypes.Control, "Padding", assemblies[0].Find("System.Windows.Thickness", true));
			properties[KnownProperties.Control_TabIndex] = InitProperty(KnownTypes.Control, null, assemblies[2].Find("System.Int32", true));
			properties[KnownProperties.Control_Template] = InitProperty(KnownTypes.Control, "Template", assemblies[0].Find("System.Windows.Controls.ControlTemplate", true));
			properties[KnownProperties.Control_VerticalContentAlignment] = InitProperty(KnownTypes.Control, "VerticalContentAlignment", assemblies[0].Find("System.Windows.VerticalAlignment", true));
			properties[KnownProperties.DockPanel_Dock] = InitProperty(KnownTypes.DockPanel, null, assemblies[0].Find("System.Windows.Controls.Dock", true));
			properties[KnownProperties.DockPanel_LastChildFill] = InitProperty(KnownTypes.DockPanel, "LastChildFill", assemblies[2].Find("System.Boolean", true));
			properties[KnownProperties.DocumentViewerBase_Document] = InitProperty(KnownTypes.DocumentViewerBase, "Document", assemblies[1].Find("System.Windows.Documents.IDocumentPaginatorSource", true));
			properties[KnownProperties.DrawingGroup_Children] = InitProperty(KnownTypes.DrawingGroup, "Children", assemblies[1].Find("System.Windows.Media.Drawing", true));
			properties[KnownProperties.FlowDocumentReader_Document] = InitProperty(KnownTypes.FlowDocumentReader, "Document", assemblies[0].Find("System.Windows.Documents.FlowDocument", true));
			properties[KnownProperties.FlowDocumentScrollViewer_Document] = InitProperty(KnownTypes.FlowDocumentScrollViewer, "Document", assemblies[0].Find("System.Windows.Documents.FlowDocument", true));
			properties[KnownProperties.FrameworkContentElement_Style] = InitProperty(KnownTypes.FrameworkContentElement, "Style", assemblies[0].Find("System.Windows.Style", true));
			properties[KnownProperties.FrameworkElement_FlowDirection] = InitProperty(KnownTypes.FrameworkElement, "FlowDirection", assemblies[1].Find("System.Windows.FlowDirection", true));
			properties[KnownProperties.FrameworkElement_Height] = InitProperty(KnownTypes.FrameworkElement, "Height", assemblies[2].Find("System.Double", true));
			properties[KnownProperties.FrameworkElement_HorizontalAlignment] = InitProperty(KnownTypes.FrameworkElement, "HorizontalAlignment", assemblies[0].Find("System.Windows.HorizontalAlignment", true));
			properties[KnownProperties.FrameworkElement_Margin] = InitProperty(KnownTypes.FrameworkElement, "Margin", assemblies[0].Find("System.Windows.Thickness", true));
			properties[KnownProperties.FrameworkElement_MaxHeight] = InitProperty(KnownTypes.FrameworkElement, "MaxHeight", assemblies[2].Find("System.Double", true));
			properties[KnownProperties.FrameworkElement_MaxWidth] = InitProperty(KnownTypes.FrameworkElement, "MaxWidth", assemblies[2].Find("System.Double", true));
			properties[KnownProperties.FrameworkElement_MinHeight] = InitProperty(KnownTypes.FrameworkElement, "MinHeight", assemblies[2].Find("System.Double", true));
			properties[KnownProperties.FrameworkElement_MinWidth] = InitProperty(KnownTypes.FrameworkElement, "MinWidth", assemblies[2].Find("System.Double", true));
			properties[KnownProperties.FrameworkElement_Name] = InitProperty(KnownTypes.FrameworkElement, "Name", assemblies[2].Find("System.Char", true));
			properties[KnownProperties.FrameworkElement_Style] = InitProperty(KnownTypes.FrameworkElement, "Style", assemblies[0].Find("System.Windows.Style", true));
			properties[KnownProperties.FrameworkElement_VerticalAlignment] = InitProperty(KnownTypes.FrameworkElement, "VerticalAlignment", assemblies[0].Find("System.Windows.VerticalAlignment", true));
			properties[KnownProperties.FrameworkElement_Width] = InitProperty(KnownTypes.FrameworkElement, "Width", assemblies[2].Find("System.Double", true));
			properties[KnownProperties.GeneralTransformGroup_Children] = InitProperty(KnownTypes.GeneralTransformGroup, "Children", assemblies[1].Find("System.Windows.Media.GeneralTransform", true));
			properties[KnownProperties.GeometryGroup_Children] = InitProperty(KnownTypes.GeometryGroup, "Children", assemblies[1].Find("System.Windows.Media.Geometry", true));
			properties[KnownProperties.GradientBrush_GradientStops] = InitProperty(KnownTypes.GradientBrush, "GradientStops", assemblies[1].Find("System.Windows.Media.GradientStop", true));
			properties[KnownProperties.Grid_Column] = InitProperty(KnownTypes.Grid, null, assemblies[2].Find("System.Int32", true));
			properties[KnownProperties.Grid_ColumnSpan] = InitProperty(KnownTypes.Grid, null, assemblies[2].Find("System.Int32", true));
			properties[KnownProperties.Grid_Row] = InitProperty(KnownTypes.Grid, null, assemblies[2].Find("System.Int32", true));
			properties[KnownProperties.Grid_RowSpan] = InitProperty(KnownTypes.Grid, null, assemblies[2].Find("System.Int32", true));
			properties[KnownProperties.GridViewColumn_Header] = InitProperty(KnownTypes.GridViewColumn, "Header", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.HeaderedContentControl_HasHeader] = InitProperty(KnownTypes.HeaderedContentControl, "HasHeader", assemblies[2].Find("System.Boolean", true));
			properties[KnownProperties.HeaderedContentControl_Header] = InitProperty(KnownTypes.HeaderedContentControl, "Header", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.HeaderedContentControl_HeaderTemplate] = InitProperty(KnownTypes.HeaderedContentControl, "HeaderTemplate", assemblies[0].Find("System.Windows.DataTemplate", true));
			properties[KnownProperties.HeaderedContentControl_HeaderTemplateSelector] = InitProperty(KnownTypes.HeaderedContentControl, "HeaderTemplateSelector", assemblies[0].Find("System.Windows.Controls.DataTemplateSelector", true));
			properties[KnownProperties.HeaderedItemsControl_HasHeader] = InitProperty(KnownTypes.HeaderedItemsControl, "HasHeader", assemblies[2].Find("System.Boolean", true));
			properties[KnownProperties.HeaderedItemsControl_Header] = InitProperty(KnownTypes.HeaderedItemsControl, "Header", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.HeaderedItemsControl_HeaderTemplate] = InitProperty(KnownTypes.HeaderedItemsControl, "HeaderTemplate", assemblies[0].Find("System.Windows.DataTemplate", true));
			properties[KnownProperties.HeaderedItemsControl_HeaderTemplateSelector] = InitProperty(KnownTypes.HeaderedItemsControl, "HeaderTemplateSelector", assemblies[0].Find("System.Windows.Controls.DataTemplateSelector", true));
			properties[KnownProperties.Hyperlink_NavigateUri] = InitProperty(KnownTypes.Hyperlink, "NavigateUri", assemblies[3].Find("System.Uri", true));
			properties[KnownProperties.Image_Source] = InitProperty(KnownTypes.Image, "Source", assemblies[1].Find("System.Windows.Media.ImageSource", true));
			properties[KnownProperties.Image_Stretch] = InitProperty(KnownTypes.Image, "Stretch", assemblies[1].Find("System.Windows.Media.Stretch", true));
			properties[KnownProperties.ItemsControl_ItemContainerStyle] = InitProperty(KnownTypes.ItemsControl, "ItemContainerStyle", assemblies[0].Find("System.Windows.Style", true));
			properties[KnownProperties.ItemsControl_ItemContainerStyleSelector] = InitProperty(KnownTypes.ItemsControl, "ItemContainerStyleSelector", assemblies[0].Find("System.Windows.Controls.StyleSelector", true));
			properties[KnownProperties.ItemsControl_ItemTemplate] = InitProperty(KnownTypes.ItemsControl, "ItemTemplate", assemblies[0].Find("System.Windows.DataTemplate", true));
			properties[KnownProperties.ItemsControl_ItemTemplateSelector] = InitProperty(KnownTypes.ItemsControl, "ItemTemplateSelector", assemblies[0].Find("System.Windows.Controls.DataTemplateSelector", true));
			properties[KnownProperties.ItemsControl_ItemsPanel] = InitProperty(KnownTypes.ItemsControl, "ItemsPanel", assemblies[0].Find("System.Windows.Controls.ItemsPanelTemplate", true));
			properties[KnownProperties.ItemsControl_ItemsSource] = InitProperty(KnownTypes.ItemsControl, "ItemsSource", assemblies[2].Find("System.Collections.IEnumerable", true));
			properties[KnownProperties.MaterialGroup_Children] = InitProperty(KnownTypes.MaterialGroup, "Children", assemblies[1].Find("System.Windows.Media.Media3D.Material", true));
			properties[KnownProperties.Model3DGroup_Children] = InitProperty(KnownTypes.Model3DGroup, "Children", assemblies[1].Find("System.Windows.Media.Media3D.Model3D", true));
			properties[KnownProperties.Page_Content] = InitProperty(KnownTypes.Page, "Content", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.Panel_Background] = InitProperty(KnownTypes.Panel, "Background", assemblies[1].Find("System.Windows.Media.Brush", true));
			properties[KnownProperties.Path_Data] = InitProperty(KnownTypes.Path, "Data", assemblies[1].Find("System.Windows.Media.Geometry", true));
			properties[KnownProperties.PathFigure_Segments] = InitProperty(KnownTypes.PathFigure, "Segments", assemblies[1].Find("System.Windows.Media.PathSegment", true));
			properties[KnownProperties.PathGeometry_Figures] = InitProperty(KnownTypes.PathGeometry, "Figures", assemblies[1].Find("System.Windows.Media.PathFigure", true));
			properties[KnownProperties.Popup_Child] = InitProperty(KnownTypes.Popup, "Child", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.Popup_IsOpen] = InitProperty(KnownTypes.Popup, "IsOpen", assemblies[2].Find("System.Boolean", true));
			properties[KnownProperties.Popup_Placement] = InitProperty(KnownTypes.Popup, "Placement", assemblies[0].Find("System.Windows.Controls.Primitives.PlacementMode", true));
			properties[KnownProperties.Popup_PopupAnimation] = InitProperty(KnownTypes.Popup, "PopupAnimation", assemblies[0].Find("System.Windows.Controls.Primitives.PopupAnimation", true));
			properties[KnownProperties.RowDefinition_Height] = InitProperty(KnownTypes.RowDefinition, "Height", assemblies[0].Find("System.Windows.GridLength", true));
			properties[KnownProperties.RowDefinition_MaxHeight] = InitProperty(KnownTypes.RowDefinition, "MaxHeight", assemblies[2].Find("System.Double", true));
			properties[KnownProperties.RowDefinition_MinHeight] = InitProperty(KnownTypes.RowDefinition, "MinHeight", assemblies[2].Find("System.Double", true));
			properties[KnownProperties.ScrollViewer_CanContentScroll] = InitProperty(KnownTypes.ScrollViewer, "CanContentScroll", assemblies[2].Find("System.Boolean", true));
			properties[KnownProperties.ScrollViewer_HorizontalScrollBarVisibility] = InitProperty(KnownTypes.ScrollViewer, "HorizontalScrollBarVisibility", assemblies[0].Find("System.Windows.Controls.ScrollBarVisibility", true));
			properties[KnownProperties.ScrollViewer_VerticalScrollBarVisibility] = InitProperty(KnownTypes.ScrollViewer, "VerticalScrollBarVisibility", assemblies[0].Find("System.Windows.Controls.ScrollBarVisibility", true));
			properties[KnownProperties.Shape_Fill] = InitProperty(KnownTypes.Shape, "Fill", assemblies[1].Find("System.Windows.Media.Brush", true));
			properties[KnownProperties.Shape_Stroke] = InitProperty(KnownTypes.Shape, "Stroke", assemblies[1].Find("System.Windows.Media.Brush", true));
			properties[KnownProperties.Shape_StrokeThickness] = InitProperty(KnownTypes.Shape, "StrokeThickness", assemblies[2].Find("System.Double", true));
			properties[KnownProperties.TextBlock_Background] = InitProperty(KnownTypes.TextBlock, "Background", assemblies[1].Find("System.Windows.Media.Brush", true));
			properties[KnownProperties.TextBlock_FontFamily] = InitProperty(KnownTypes.TextBlock, "FontFamily", assemblies[1].Find("System.Windows.Media.FontFamily", true));
			properties[KnownProperties.TextBlock_FontSize] = InitProperty(KnownTypes.TextBlock, "FontSize", assemblies[2].Find("System.Double", true));
			properties[KnownProperties.TextBlock_FontStretch] = InitProperty(KnownTypes.TextBlock, "FontStretch", assemblies[1].Find("System.Windows.FontStretch", true));
			properties[KnownProperties.TextBlock_FontStyle] = InitProperty(KnownTypes.TextBlock, "FontStyle", assemblies[1].Find("System.Windows.FontStyle", true));
			properties[KnownProperties.TextBlock_FontWeight] = InitProperty(KnownTypes.TextBlock, "FontWeight", assemblies[1].Find("System.Windows.FontWeight", true));
			properties[KnownProperties.TextBlock_Foreground] = InitProperty(KnownTypes.TextBlock, "Foreground", assemblies[1].Find("System.Windows.Media.Brush", true));
			properties[KnownProperties.TextBlock_Text] = InitProperty(KnownTypes.TextBlock, "Text", assemblies[2].Find("System.Char", true));
			properties[KnownProperties.TextBlock_TextDecorations] = InitProperty(KnownTypes.TextBlock, "TextDecorations", assemblies[1].Find("System.Windows.TextDecoration", true));
			properties[KnownProperties.TextBlock_TextTrimming] = InitProperty(KnownTypes.TextBlock, "TextTrimming", assemblies[1].Find("System.Windows.TextTrimming", true));
			properties[KnownProperties.TextBlock_TextWrapping] = InitProperty(KnownTypes.TextBlock, "TextWrapping", assemblies[1].Find("System.Windows.TextWrapping", true));
			properties[KnownProperties.TextBox_Text] = InitProperty(KnownTypes.TextBox, "Text", assemblies[2].Find("System.Char", true));
			properties[KnownProperties.TextElement_Background] = InitProperty(KnownTypes.TextElement, "Background", assemblies[1].Find("System.Windows.Media.Brush", true));
			properties[KnownProperties.TextElement_FontFamily] = InitProperty(KnownTypes.TextElement, "FontFamily", assemblies[1].Find("System.Windows.Media.FontFamily", true));
			properties[KnownProperties.TextElement_FontSize] = InitProperty(KnownTypes.TextElement, "FontSize", assemblies[2].Find("System.Double", true));
			properties[KnownProperties.TextElement_FontStretch] = InitProperty(KnownTypes.TextElement, "FontStretch", assemblies[1].Find("System.Windows.FontStretch", true));
			properties[KnownProperties.TextElement_FontStyle] = InitProperty(KnownTypes.TextElement, "FontStyle", assemblies[1].Find("System.Windows.FontStyle", true));
			properties[KnownProperties.TextElement_FontWeight] = InitProperty(KnownTypes.TextElement, "FontWeight", assemblies[1].Find("System.Windows.FontWeight", true));
			properties[KnownProperties.TextElement_Foreground] = InitProperty(KnownTypes.TextElement, "Foreground", assemblies[1].Find("System.Windows.Media.Brush", true));
			properties[KnownProperties.TimelineGroup_Children] = InitProperty(KnownTypes.TimelineGroup, "Children", assemblies[1].Find("System.Windows.Media.Animation.Timeline", true));
			properties[KnownProperties.Track_IsDirectionReversed] = InitProperty(KnownTypes.Track, "IsDirectionReversed", assemblies[2].Find("System.Boolean", true));
			properties[KnownProperties.Track_Maximum] = InitProperty(KnownTypes.Track, "Maximum", assemblies[2].Find("System.Double", true));
			properties[KnownProperties.Track_Minimum] = InitProperty(KnownTypes.Track, "Minimum", assemblies[2].Find("System.Double", true));
			properties[KnownProperties.Track_Orientation] = InitProperty(KnownTypes.Track, "Orientation", assemblies[0].Find("System.Windows.Controls.Orientation", true));
			properties[KnownProperties.Track_Value] = InitProperty(KnownTypes.Track, "Value", assemblies[2].Find("System.Double", true));
			properties[KnownProperties.Track_ViewportSize] = InitProperty(KnownTypes.Track, "ViewportSize", assemblies[2].Find("System.Double", true));
			properties[KnownProperties.Transform3DGroup_Children] = InitProperty(KnownTypes.Transform3DGroup, "Children", assemblies[1].Find("System.Windows.Media.Media3D.Transform3D", true));
			properties[KnownProperties.TransformGroup_Children] = InitProperty(KnownTypes.TransformGroup, "Children", assemblies[1].Find("System.Windows.Media.Transform", true));
			properties[KnownProperties.UIElement_ClipToBounds] = InitProperty(KnownTypes.UIElement, "ClipToBounds", assemblies[2].Find("System.Boolean", true));
			properties[KnownProperties.UIElement_Focusable] = InitProperty(KnownTypes.UIElement, "Focusable", assemblies[2].Find("System.Boolean", true));
			properties[KnownProperties.UIElement_IsEnabled] = InitProperty(KnownTypes.UIElement, "IsEnabled", assemblies[2].Find("System.Boolean", true));
			properties[KnownProperties.UIElement_RenderTransform] = InitProperty(KnownTypes.UIElement, "RenderTransform", assemblies[1].Find("System.Windows.Media.Transform", true));
			properties[KnownProperties.UIElement_Visibility] = InitProperty(KnownTypes.UIElement, "Visibility", assemblies[1].Find("System.Windows.Visibility", true));
			properties[KnownProperties.Viewport3D_Children] = InitProperty(KnownTypes.Viewport3D, "Children", assemblies[1].Find("System.Windows.Media.Media3D.Visual3D", true));
			properties[KnownProperties.AdornedElementPlaceholder_Child] = InitProperty(KnownTypes.AdornedElementPlaceholder, "Child", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.AdornerDecorator_Child] = InitProperty(KnownTypes.AdornerDecorator, "Child", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.AnchoredBlock_Blocks] = InitProperty(KnownTypes.AnchoredBlock, "Blocks", assemblies[0].Find("System.Windows.Documents.Block", true));
			properties[KnownProperties.ArrayExtension_Items] = InitProperty(KnownTypes.ArrayExtension, "Items", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.BlockUIContainer_Child] = InitProperty(KnownTypes.BlockUIContainer, "Child", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.Bold_Inlines] = InitProperty(KnownTypes.Bold, "Inlines", assemblies[0].Find("System.Windows.Documents.Inline", true));
			properties[KnownProperties.BooleanAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.BooleanAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.BooleanKeyFrame", true));
			properties[KnownProperties.Border_Child] = InitProperty(KnownTypes.Border, "Child", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.BulletDecorator_Child] = InitProperty(KnownTypes.BulletDecorator, "Child", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.Button_Content] = InitProperty(KnownTypes.Button, "Content", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.ButtonBase_Content] = InitProperty(KnownTypes.ButtonBase, "Content", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.ByteAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.ByteAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.ByteKeyFrame", true));
			properties[KnownProperties.Canvas_Children] = InitProperty(KnownTypes.Canvas, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.CharAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.CharAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.CharKeyFrame", true));
			properties[KnownProperties.CheckBox_Content] = InitProperty(KnownTypes.CheckBox, "Content", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.ColorAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.ColorAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.ColorKeyFrame", true));
			properties[KnownProperties.ComboBox_Items] = InitProperty(KnownTypes.ComboBox, "Items", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.ComboBoxItem_Content] = InitProperty(KnownTypes.ComboBoxItem, "Content", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.ContextMenu_Items] = InitProperty(KnownTypes.ContextMenu, "Items", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.ControlTemplate_VisualTree] = InitProperty(KnownTypes.ControlTemplate, "VisualTree", assemblies[0].Find("System.Windows.FrameworkElementFactory", true));
			properties[KnownProperties.DataTemplate_VisualTree] = InitProperty(KnownTypes.DataTemplate, "VisualTree", assemblies[0].Find("System.Windows.FrameworkElementFactory", true));
			properties[KnownProperties.DataTrigger_Setters] = InitProperty(KnownTypes.DataTrigger, "Setters", assemblies[0].Find("System.Windows.SetterBase", true));
			properties[KnownProperties.DecimalAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.DecimalAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.DecimalKeyFrame", true));
			properties[KnownProperties.Decorator_Child] = InitProperty(KnownTypes.Decorator, "Child", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.DockPanel_Children] = InitProperty(KnownTypes.DockPanel, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.DocumentViewer_Document] = InitProperty(KnownTypes.DocumentViewer, "Document", assemblies[1].Find("System.Windows.Documents.IDocumentPaginatorSource", true));
			properties[KnownProperties.DoubleAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.DoubleAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.DoubleKeyFrame", true));
			properties[KnownProperties.EventTrigger_Actions] = InitProperty(KnownTypes.EventTrigger, "Actions", assemblies[0].Find("System.Windows.TriggerAction", true));
			properties[KnownProperties.Expander_Content] = InitProperty(KnownTypes.Expander, "Content", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.Figure_Blocks] = InitProperty(KnownTypes.Figure, "Blocks", assemblies[0].Find("System.Windows.Documents.Block", true));
			properties[KnownProperties.FixedDocument_Pages] = InitProperty(KnownTypes.FixedDocument, "Pages", assemblies[0].Find("System.Windows.Documents.PageContent", true));
			properties[KnownProperties.FixedDocumentSequence_References] = InitProperty(KnownTypes.FixedDocumentSequence, "References", assemblies[0].Find("System.Windows.Documents.DocumentReference", true));
			properties[KnownProperties.FixedPage_Children] = InitProperty(KnownTypes.FixedPage, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.Floater_Blocks] = InitProperty(KnownTypes.Floater, "Blocks", assemblies[0].Find("System.Windows.Documents.Block", true));
			properties[KnownProperties.FlowDocument_Blocks] = InitProperty(KnownTypes.FlowDocument, "Blocks", assemblies[0].Find("System.Windows.Documents.Block", true));
			properties[KnownProperties.FlowDocumentPageViewer_Document] = InitProperty(KnownTypes.FlowDocumentPageViewer, "Document", assemblies[1].Find("System.Windows.Documents.IDocumentPaginatorSource", true));
			properties[KnownProperties.FrameworkTemplate_VisualTree] = InitProperty(KnownTypes.FrameworkTemplate, "VisualTree", assemblies[0].Find("System.Windows.FrameworkElementFactory", true));
			properties[KnownProperties.Grid_Children] = InitProperty(KnownTypes.Grid, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.GridView_Columns] = InitProperty(KnownTypes.GridView, "Columns", assemblies[0].Find("System.Windows.Controls.GridViewColumn", true));
			properties[KnownProperties.GridViewColumnHeader_Content] = InitProperty(KnownTypes.GridViewColumnHeader, "Content", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.GroupBox_Content] = InitProperty(KnownTypes.GroupBox, "Content", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.GroupItem_Content] = InitProperty(KnownTypes.GroupItem, "Content", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.HeaderedContentControl_Content] = InitProperty(KnownTypes.HeaderedContentControl, "Content", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.HeaderedItemsControl_Items] = InitProperty(KnownTypes.HeaderedItemsControl, "Items", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.HierarchicalDataTemplate_VisualTree] = InitProperty(KnownTypes.HierarchicalDataTemplate, "VisualTree", assemblies[0].Find("System.Windows.FrameworkElementFactory", true));
			properties[KnownProperties.Hyperlink_Inlines] = InitProperty(KnownTypes.Hyperlink, "Inlines", assemblies[0].Find("System.Windows.Documents.Inline", true));
			properties[KnownProperties.InkCanvas_Children] = InitProperty(KnownTypes.InkCanvas, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.InkPresenter_Child] = InitProperty(KnownTypes.InkPresenter, "Child", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.InlineUIContainer_Child] = InitProperty(KnownTypes.InlineUIContainer, "Child", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.InputScopeName_NameValue] = InitProperty(KnownTypes.InputScopeName, "NameValue", assemblies[1].Find("System.Windows.Input.InputScopeNameValue", true));
			properties[KnownProperties.Int16AnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.Int16AnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.Int16KeyFrame", true));
			properties[KnownProperties.Int32AnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.Int32AnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.Int32KeyFrame", true));
			properties[KnownProperties.Int64AnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.Int64AnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.Int64KeyFrame", true));
			properties[KnownProperties.Italic_Inlines] = InitProperty(KnownTypes.Italic, "Inlines", assemblies[0].Find("System.Windows.Documents.Inline", true));
			properties[KnownProperties.ItemsControl_Items] = InitProperty(KnownTypes.ItemsControl, "Items", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.ItemsPanelTemplate_VisualTree] = InitProperty(KnownTypes.ItemsPanelTemplate, "VisualTree", assemblies[0].Find("System.Windows.FrameworkElementFactory", true));
			properties[KnownProperties.Label_Content] = InitProperty(KnownTypes.Label, "Content", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.LinearGradientBrush_GradientStops] = InitProperty(KnownTypes.LinearGradientBrush, "GradientStops", assemblies[1].Find("System.Windows.Media.GradientStop", true));
			properties[KnownProperties.List_ListItems] = InitProperty(KnownTypes.List, "ListItems", assemblies[0].Find("System.Windows.Documents.ListItem", true));
			properties[KnownProperties.ListBox_Items] = InitProperty(KnownTypes.ListBox, "Items", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.ListBoxItem_Content] = InitProperty(KnownTypes.ListBoxItem, "Content", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.ListItem_Blocks] = InitProperty(KnownTypes.ListItem, "Blocks", assemblies[0].Find("System.Windows.Documents.Block", true));
			properties[KnownProperties.ListView_Items] = InitProperty(KnownTypes.ListView, "Items", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.ListViewItem_Content] = InitProperty(KnownTypes.ListViewItem, "Content", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.MatrixAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.MatrixAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.MatrixKeyFrame", true));
			properties[KnownProperties.Menu_Items] = InitProperty(KnownTypes.Menu, "Items", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.MenuBase_Items] = InitProperty(KnownTypes.MenuBase, "Items", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.MenuItem_Items] = InitProperty(KnownTypes.MenuItem, "Items", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.ModelVisual3D_Children] = InitProperty(KnownTypes.ModelVisual3D, "Children", assemblies[1].Find("System.Windows.Media.Media3D.Visual3D", true));
			properties[KnownProperties.MultiBinding_Bindings] = InitProperty(KnownTypes.MultiBinding, "Bindings", assemblies[0].Find("System.Windows.Data.BindingBase", true));
			properties[KnownProperties.MultiDataTrigger_Setters] = InitProperty(KnownTypes.MultiDataTrigger, "Setters", assemblies[0].Find("System.Windows.SetterBase", true));
			properties[KnownProperties.MultiTrigger_Setters] = InitProperty(KnownTypes.MultiTrigger, "Setters", assemblies[0].Find("System.Windows.SetterBase", true));
			properties[KnownProperties.ObjectAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.ObjectAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.ObjectKeyFrame", true));
			properties[KnownProperties.PageContent_Child] = InitProperty(KnownTypes.PageContent, "Child", assemblies[0].Find("System.Windows.Documents.FixedPage", true));
			properties[KnownProperties.PageFunctionBase_Content] = InitProperty(KnownTypes.PageFunctionBase, "Content", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.Panel_Children] = InitProperty(KnownTypes.Panel, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.Paragraph_Inlines] = InitProperty(KnownTypes.Paragraph, "Inlines", assemblies[0].Find("System.Windows.Documents.Inline", true));
			properties[KnownProperties.ParallelTimeline_Children] = InitProperty(KnownTypes.ParallelTimeline, "Children", assemblies[1].Find("System.Windows.Media.Animation.Timeline", true));
			properties[KnownProperties.Point3DAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.Point3DAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.Point3DKeyFrame", true));
			properties[KnownProperties.PointAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.PointAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.PointKeyFrame", true));
			properties[KnownProperties.PriorityBinding_Bindings] = InitProperty(KnownTypes.PriorityBinding, "Bindings", assemblies[0].Find("System.Windows.Data.BindingBase", true));
			properties[KnownProperties.QuaternionAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.QuaternionAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.QuaternionKeyFrame", true));
			properties[KnownProperties.RadialGradientBrush_GradientStops] = InitProperty(KnownTypes.RadialGradientBrush, "GradientStops", assemblies[1].Find("System.Windows.Media.GradientStop", true));
			properties[KnownProperties.RadioButton_Content] = InitProperty(KnownTypes.RadioButton, "Content", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.RectAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.RectAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.RectKeyFrame", true));
			properties[KnownProperties.RepeatButton_Content] = InitProperty(KnownTypes.RepeatButton, "Content", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.RichTextBox_Document] = InitProperty(KnownTypes.RichTextBox, "Document", assemblies[0].Find("System.Windows.Documents.FlowDocument", true));
			properties[KnownProperties.Rotation3DAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.Rotation3DAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.Rotation3DKeyFrame", true));
			properties[KnownProperties.Run_Text] = InitProperty(KnownTypes.Run, "Text", assemblies[2].Find("System.Char", true));
			properties[KnownProperties.ScrollViewer_Content] = InitProperty(KnownTypes.ScrollViewer, "Content", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.Section_Blocks] = InitProperty(KnownTypes.Section, "Blocks", assemblies[0].Find("System.Windows.Documents.Block", true));
			properties[KnownProperties.Selector_Items] = InitProperty(KnownTypes.Selector, "Items", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.SingleAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.SingleAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.SingleKeyFrame", true));
			properties[KnownProperties.SizeAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.SizeAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.SizeKeyFrame", true));
			properties[KnownProperties.Span_Inlines] = InitProperty(KnownTypes.Span, "Inlines", assemblies[0].Find("System.Windows.Documents.Inline", true));
			properties[KnownProperties.StackPanel_Children] = InitProperty(KnownTypes.StackPanel, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.StatusBar_Items] = InitProperty(KnownTypes.StatusBar, "Items", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.StatusBarItem_Content] = InitProperty(KnownTypes.StatusBarItem, "Content", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.Storyboard_Children] = InitProperty(KnownTypes.Storyboard, "Children", assemblies[1].Find("System.Windows.Media.Animation.Timeline", true));
			properties[KnownProperties.StringAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.StringAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.StringKeyFrame", true));
			properties[KnownProperties.Style_Setters] = InitProperty(KnownTypes.Style, "Setters", assemblies[0].Find("System.Windows.SetterBase", true));
			properties[KnownProperties.TabControl_Items] = InitProperty(KnownTypes.TabControl, "Items", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.TabItem_Content] = InitProperty(KnownTypes.TabItem, "Content", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.TabPanel_Children] = InitProperty(KnownTypes.TabPanel, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.Table_RowGroups] = InitProperty(KnownTypes.Table, "RowGroups", assemblies[0].Find("System.Windows.Documents.TableRowGroup", true));
			properties[KnownProperties.TableCell_Blocks] = InitProperty(KnownTypes.TableCell, "Blocks", assemblies[0].Find("System.Windows.Documents.Block", true));
			properties[KnownProperties.TableRow_Cells] = InitProperty(KnownTypes.TableRow, "Cells", assemblies[0].Find("System.Windows.Documents.TableCell", true));
			properties[KnownProperties.TableRowGroup_Rows] = InitProperty(KnownTypes.TableRowGroup, "Rows", assemblies[0].Find("System.Windows.Documents.TableRow", true));
			properties[KnownProperties.TextBlock_Inlines] = InitProperty(KnownTypes.TextBlock, "Inlines", assemblies[0].Find("System.Windows.Documents.Inline", true));
			properties[KnownProperties.ThicknessAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.ThicknessAnimationUsingKeyFrames, "KeyFrames", assemblies[0].Find("System.Windows.Media.Animation.ThicknessKeyFrame", true));
			properties[KnownProperties.ToggleButton_Content] = InitProperty(KnownTypes.ToggleButton, "Content", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.ToolBar_Items] = InitProperty(KnownTypes.ToolBar, "Items", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.ToolBarOverflowPanel_Children] = InitProperty(KnownTypes.ToolBarOverflowPanel, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.ToolBarPanel_Children] = InitProperty(KnownTypes.ToolBarPanel, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.ToolBarTray_ToolBars] = InitProperty(KnownTypes.ToolBarTray, "ToolBars", assemblies[0].Find("System.Windows.Controls.ToolBar", true));
			properties[KnownProperties.ToolTip_Content] = InitProperty(KnownTypes.ToolTip, "Content", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.TreeView_Items] = InitProperty(KnownTypes.TreeView, "Items", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.TreeViewItem_Items] = InitProperty(KnownTypes.TreeViewItem, "Items", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.Trigger_Setters] = InitProperty(KnownTypes.Trigger, "Setters", assemblies[0].Find("System.Windows.SetterBase", true));
			properties[KnownProperties.Underline_Inlines] = InitProperty(KnownTypes.Underline, "Inlines", assemblies[0].Find("System.Windows.Documents.Inline", true));
			properties[KnownProperties.UniformGrid_Children] = InitProperty(KnownTypes.UniformGrid, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.UserControl_Content] = InitProperty(KnownTypes.UserControl, "Content", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.Vector3DAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.Vector3DAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.Vector3DKeyFrame", true));
			properties[KnownProperties.VectorAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.VectorAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.VectorKeyFrame", true));
			properties[KnownProperties.Viewbox_Child] = InitProperty(KnownTypes.Viewbox, "Child", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.Viewport3DVisual_Children] = InitProperty(KnownTypes.Viewport3DVisual, "Children", assemblies[1].Find("System.Windows.Media.Media3D.Visual3D", true));
			properties[KnownProperties.VirtualizingPanel_Children] = InitProperty(KnownTypes.VirtualizingPanel, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.VirtualizingStackPanel_Children] = InitProperty(KnownTypes.VirtualizingStackPanel, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.Window_Content] = InitProperty(KnownTypes.Window, "Content", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.WrapPanel_Children] = InitProperty(KnownTypes.WrapPanel, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.XmlDataProvider_XmlSerializer] = InitProperty(KnownTypes.XmlDataProvider, "XmlSerializer", assemblies[5].Find("System.Xml.Serialization.IXmlSerializable", true));
		}
	}
}


================================================
File: Confuser.Renamer/BAML/KnownThingsv4.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using Confuser.Core;
using dnlib.DotNet;

namespace Confuser.Renamer.BAML {
	internal class KnownThingsv4 : IKnownThings {
		readonly Dictionary<int, AssemblyDef> assemblies;
		readonly ConfuserContext context;
		readonly Dictionary<KnownProperties, Tuple<KnownTypes, PropertyDef, TypeDef>> properties;
		readonly Dictionary<KnownTypes, TypeDef> types;

		public KnownThingsv4(ConfuserContext context, ModuleDefMD initMod) {
			this.context = context;

			assemblies = new Dictionary<int, AssemblyDef>();
			types = new Dictionary<KnownTypes, TypeDef>();
			properties = new Dictionary<KnownProperties, Tuple<KnownTypes, PropertyDef, TypeDef>>();

			InitAssemblies(initMod);
			InitTypes();
			InitProperties();
		}

		public Func<KnownTypes, TypeDef> Types {
			get { return type => types[type]; }
		}

		public Func<KnownProperties, Tuple<KnownTypes, PropertyDef, TypeDef>> Properties {
			get { return property => properties[property]; }
		}

		public AssemblyDef FrameworkAssembly {
			get { return assemblies[0]; }
		}

		Tuple<KnownTypes, PropertyDef, TypeDef> InitProperty(KnownTypes parent, string propertyName, TypeDef propertyType) {
			if (propertyName != null)
				return Tuple.Create(parent, types[parent].FindProperty(propertyName), propertyType);
			return Tuple.Create(parent, (PropertyDef)null, propertyType);
		}

		// Following codes are auto-generated, do not modify.

		void InitAssemblies(ModuleDefMD initMod) {
			assemblies[0] = context.Resolver.ResolveThrow("PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35", initMod);
			assemblies[1] = context.Resolver.ResolveThrow("PresentationCore, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35", initMod);
			assemblies[2] = context.Resolver.ResolveThrow("System.Xaml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089", initMod);
			assemblies[3] = context.Resolver.ResolveThrow("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089", initMod);
			assemblies[4] = context.Resolver.ResolveThrow("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089", initMod);
			assemblies[5] = context.Resolver.ResolveThrow("WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35", initMod);
			assemblies[6] = context.Resolver.ResolveThrow("System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089", initMod);
		}

		void InitTypes() {
			types[KnownTypes.AccessText] = assemblies[0].Find("System.Windows.Controls.AccessText", true);
			types[KnownTypes.AdornedElementPlaceholder] = assemblies[0].Find("System.Windows.Controls.AdornedElementPlaceholder", true);
			types[KnownTypes.Adorner] = assemblies[0].Find("System.Windows.Documents.Adorner", true);
			types[KnownTypes.AdornerDecorator] = assemblies[0].Find("System.Windows.Documents.AdornerDecorator", true);
			types[KnownTypes.AdornerLayer] = assemblies[0].Find("System.Windows.Documents.AdornerLayer", true);
			types[KnownTypes.AffineTransform3D] = assemblies[1].Find("System.Windows.Media.Media3D.AffineTransform3D", true);
			types[KnownTypes.AmbientLight] = assemblies[1].Find("System.Windows.Media.Media3D.AmbientLight", true);
			types[KnownTypes.AnchoredBlock] = assemblies[0].Find("System.Windows.Documents.AnchoredBlock", true);
			types[KnownTypes.Animatable] = assemblies[1].Find("System.Windows.Media.Animation.Animatable", true);
			types[KnownTypes.AnimationClock] = assemblies[1].Find("System.Windows.Media.Animation.AnimationClock", true);
			types[KnownTypes.AnimationTimeline] = assemblies[1].Find("System.Windows.Media.Animation.AnimationTimeline", true);
			types[KnownTypes.Application] = assemblies[0].Find("System.Windows.Application", true);
			types[KnownTypes.ArcSegment] = assemblies[1].Find("System.Windows.Media.ArcSegment", true);
			types[KnownTypes.ArrayExtension] = assemblies[2].Find("System.Windows.Markup.ArrayExtension", true);
			types[KnownTypes.AxisAngleRotation3D] = assemblies[1].Find("System.Windows.Media.Media3D.AxisAngleRotation3D", true);
			types[KnownTypes.BaseIListConverter] = assemblies[1].Find("System.Windows.Media.Converters.BaseIListConverter", true);
			types[KnownTypes.BeginStoryboard] = assemblies[0].Find("System.Windows.Media.Animation.BeginStoryboard", true);
			types[KnownTypes.BevelBitmapEffect] = assemblies[1].Find("System.Windows.Media.Effects.BevelBitmapEffect", true);
			types[KnownTypes.BezierSegment] = assemblies[1].Find("System.Windows.Media.BezierSegment", true);
			types[KnownTypes.Binding] = assemblies[0].Find("System.Windows.Data.Binding", true);
			types[KnownTypes.BindingBase] = assemblies[0].Find("System.Windows.Data.BindingBase", true);
			types[KnownTypes.BindingExpression] = assemblies[0].Find("System.Windows.Data.BindingExpression", true);
			types[KnownTypes.BindingExpressionBase] = assemblies[0].Find("System.Windows.Data.BindingExpressionBase", true);
			types[KnownTypes.BindingListCollectionView] = assemblies[0].Find("System.Windows.Data.BindingListCollectionView", true);
			types[KnownTypes.BitmapDecoder] = assemblies[1].Find("System.Windows.Media.Imaging.BitmapDecoder", true);
			types[KnownTypes.BitmapEffect] = assemblies[1].Find("System.Windows.Media.Effects.BitmapEffect", true);
			types[KnownTypes.BitmapEffectCollection] = assemblies[1].Find("System.Windows.Media.Effects.BitmapEffectCollection", true);
			types[KnownTypes.BitmapEffectGroup] = assemblies[1].Find("System.Windows.Media.Effects.BitmapEffectGroup", true);
			types[KnownTypes.BitmapEffectInput] = assemblies[1].Find("System.Windows.Media.Effects.BitmapEffectInput", true);
			types[KnownTypes.BitmapEncoder] = assemblies[1].Find("System.Windows.Media.Imaging.BitmapEncoder", true);
			types[KnownTypes.BitmapFrame] = assemblies[1].Find("System.Windows.Media.Imaging.BitmapFrame", true);
			types[KnownTypes.BitmapImage] = assemblies[1].Find("System.Windows.Media.Imaging.BitmapImage", true);
			types[KnownTypes.BitmapMetadata] = assemblies[1].Find("System.Windows.Media.Imaging.BitmapMetadata", true);
			types[KnownTypes.BitmapPalette] = assemblies[1].Find("System.Windows.Media.Imaging.BitmapPalette", true);
			types[KnownTypes.BitmapSource] = assemblies[1].Find("System.Windows.Media.Imaging.BitmapSource", true);
			types[KnownTypes.Block] = assemblies[0].Find("System.Windows.Documents.Block", true);
			types[KnownTypes.BlockUIContainer] = assemblies[0].Find("System.Windows.Documents.BlockUIContainer", true);
			types[KnownTypes.BlurBitmapEffect] = assemblies[1].Find("System.Windows.Media.Effects.BlurBitmapEffect", true);
			types[KnownTypes.BmpBitmapDecoder] = assemblies[1].Find("System.Windows.Media.Imaging.BmpBitmapDecoder", true);
			types[KnownTypes.BmpBitmapEncoder] = assemblies[1].Find("System.Windows.Media.Imaging.BmpBitmapEncoder", true);
			types[KnownTypes.Bold] = assemblies[0].Find("System.Windows.Documents.Bold", true);
			types[KnownTypes.BoolIListConverter] = assemblies[1].Find("System.Windows.Media.Converters.BoolIListConverter", true);
			types[KnownTypes.Boolean] = assemblies[3].Find("System.Boolean", true);
			types[KnownTypes.BooleanAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.BooleanAnimationBase", true);
			types[KnownTypes.BooleanAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.BooleanAnimationUsingKeyFrames", true);
			types[KnownTypes.BooleanConverter] = assemblies[4].Find("System.ComponentModel.BooleanConverter", true);
			types[KnownTypes.BooleanKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.BooleanKeyFrame", true);
			types[KnownTypes.BooleanKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.BooleanKeyFrameCollection", true);
			types[KnownTypes.BooleanToVisibilityConverter] = assemblies[0].Find("System.Windows.Controls.BooleanToVisibilityConverter", true);
			types[KnownTypes.Border] = assemblies[0].Find("System.Windows.Controls.Border", true);
			types[KnownTypes.BorderGapMaskConverter] = assemblies[0].Find("System.Windows.Controls.BorderGapMaskConverter", true);
			types[KnownTypes.Brush] = assemblies[1].Find("System.Windows.Media.Brush", true);
			types[KnownTypes.BrushConverter] = assemblies[1].Find("System.Windows.Media.BrushConverter", true);
			types[KnownTypes.BulletDecorator] = assemblies[0].Find("System.Windows.Controls.Primitives.BulletDecorator", true);
			types[KnownTypes.Button] = assemblies[0].Find("System.Windows.Controls.Button", true);
			types[KnownTypes.ButtonBase] = assemblies[0].Find("System.Windows.Controls.Primitives.ButtonBase", true);
			types[KnownTypes.Byte] = assemblies[3].Find("System.Byte", true);
			types[KnownTypes.ByteAnimation] = assemblies[1].Find("System.Windows.Media.Animation.ByteAnimation", true);
			types[KnownTypes.ByteAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.ByteAnimationBase", true);
			types[KnownTypes.ByteAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.ByteAnimationUsingKeyFrames", true);
			types[KnownTypes.ByteConverter] = assemblies[4].Find("System.ComponentModel.ByteConverter", true);
			types[KnownTypes.ByteKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.ByteKeyFrame", true);
			types[KnownTypes.ByteKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.ByteKeyFrameCollection", true);
			types[KnownTypes.CachedBitmap] = assemblies[1].Find("System.Windows.Media.Imaging.CachedBitmap", true);
			types[KnownTypes.Camera] = assemblies[1].Find("System.Windows.Media.Media3D.Camera", true);
			types[KnownTypes.Canvas] = assemblies[0].Find("System.Windows.Controls.Canvas", true);
			types[KnownTypes.Char] = assemblies[3].Find("System.Char", true);
			types[KnownTypes.CharAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.CharAnimationBase", true);
			types[KnownTypes.CharAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.CharAnimationUsingKeyFrames", true);
			types[KnownTypes.CharConverter] = assemblies[4].Find("System.ComponentModel.CharConverter", true);
			types[KnownTypes.CharIListConverter] = assemblies[1].Find("System.Windows.Media.Converters.CharIListConverter", true);
			types[KnownTypes.CharKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.CharKeyFrame", true);
			types[KnownTypes.CharKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.CharKeyFrameCollection", true);
			types[KnownTypes.CheckBox] = assemblies[0].Find("System.Windows.Controls.CheckBox", true);
			types[KnownTypes.Clock] = assemblies[1].Find("System.Windows.Media.Animation.Clock", true);
			types[KnownTypes.ClockController] = assemblies[1].Find("System.Windows.Media.Animation.ClockController", true);
			types[KnownTypes.ClockGroup] = assemblies[1].Find("System.Windows.Media.Animation.ClockGroup", true);
			types[KnownTypes.CollectionContainer] = assemblies[0].Find("System.Windows.Data.CollectionContainer", true);
			types[KnownTypes.CollectionView] = assemblies[0].Find("System.Windows.Data.CollectionView", true);
			types[KnownTypes.CollectionViewSource] = assemblies[0].Find("System.Windows.Data.CollectionViewSource", true);
			types[KnownTypes.Color] = assemblies[1].Find("System.Windows.Media.Color", true);
			types[KnownTypes.ColorAnimation] = assemblies[1].Find("System.Windows.Media.Animation.ColorAnimation", true);
			types[KnownTypes.ColorAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.ColorAnimationBase", true);
			types[KnownTypes.ColorAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.ColorAnimationUsingKeyFrames", true);
			types[KnownTypes.ColorConvertedBitmap] = assemblies[1].Find("System.Windows.Media.Imaging.ColorConvertedBitmap", true);
			types[KnownTypes.ColorConvertedBitmapExtension] = assemblies[0].Find("System.Windows.ColorConvertedBitmapExtension", true);
			types[KnownTypes.ColorConverter] = assemblies[1].Find("System.Windows.Media.ColorConverter", true);
			types[KnownTypes.ColorKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.ColorKeyFrame", true);
			types[KnownTypes.ColorKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.ColorKeyFrameCollection", true);
			types[KnownTypes.ColumnDefinition] = assemblies[0].Find("System.Windows.Controls.ColumnDefinition", true);
			types[KnownTypes.CombinedGeometry] = assemblies[1].Find("System.Windows.Media.CombinedGeometry", true);
			types[KnownTypes.ComboBox] = assemblies[0].Find("System.Windows.Controls.ComboBox", true);
			types[KnownTypes.ComboBoxItem] = assemblies[0].Find("System.Windows.Controls.ComboBoxItem", true);
			types[KnownTypes.CommandConverter] = assemblies[0].Find("System.Windows.Input.CommandConverter", true);
			types[KnownTypes.ComponentResourceKey] = assemblies[0].Find("System.Windows.ComponentResourceKey", true);
			types[KnownTypes.ComponentResourceKeyConverter] = assemblies[0].Find("System.Windows.Markup.ComponentResourceKeyConverter", true);
			types[KnownTypes.CompositionTarget] = assemblies[1].Find("System.Windows.Media.CompositionTarget", true);
			types[KnownTypes.Condition] = assemblies[0].Find("System.Windows.Condition", true);
			types[KnownTypes.ContainerVisual] = assemblies[1].Find("System.Windows.Media.ContainerVisual", true);
			types[KnownTypes.ContentControl] = assemblies[0].Find("System.Windows.Controls.ContentControl", true);
			types[KnownTypes.ContentElement] = assemblies[1].Find("System.Windows.ContentElement", true);
			types[KnownTypes.ContentPresenter] = assemblies[0].Find("System.Windows.Controls.ContentPresenter", true);
			types[KnownTypes.ContentPropertyAttribute] = assemblies[2].Find("System.Windows.Markup.ContentPropertyAttribute", true);
			types[KnownTypes.ContentWrapperAttribute] = assemblies[2].Find("System.Windows.Markup.ContentWrapperAttribute", true);
			types[KnownTypes.ContextMenu] = assemblies[0].Find("System.Windows.Controls.ContextMenu", true);
			types[KnownTypes.ContextMenuService] = assemblies[0].Find("System.Windows.Controls.ContextMenuService", true);
			types[KnownTypes.Control] = assemblies[0].Find("System.Windows.Controls.Control", true);
			types[KnownTypes.ControlTemplate] = assemblies[0].Find("System.Windows.Controls.ControlTemplate", true);
			types[KnownTypes.ControllableStoryboardAction] = assemblies[0].Find("System.Windows.Media.Animation.ControllableStoryboardAction", true);
			types[KnownTypes.CornerRadius] = assemblies[0].Find("System.Windows.CornerRadius", true);
			types[KnownTypes.CornerRadiusConverter] = assemblies[0].Find("System.Windows.CornerRadiusConverter", true);
			types[KnownTypes.CroppedBitmap] = assemblies[1].Find("System.Windows.Media.Imaging.CroppedBitmap", true);
			types[KnownTypes.CultureInfo] = assemblies[3].Find("System.Globalization.CultureInfo", true);
			types[KnownTypes.CultureInfoConverter] = assemblies[4].Find("System.ComponentModel.CultureInfoConverter", true);
			types[KnownTypes.CultureInfoIetfLanguageTagConverter] = assemblies[1].Find("System.Windows.CultureInfoIetfLanguageTagConverter", true);
			types[KnownTypes.Cursor] = assemblies[1].Find("System.Windows.Input.Cursor", true);
			types[KnownTypes.CursorConverter] = assemblies[1].Find("System.Windows.Input.CursorConverter", true);
			types[KnownTypes.DashStyle] = assemblies[1].Find("System.Windows.Media.DashStyle", true);
			types[KnownTypes.DataChangedEventManager] = assemblies[0].Find("System.Windows.Data.DataChangedEventManager", true);
			types[KnownTypes.DataTemplate] = assemblies[0].Find("System.Windows.DataTemplate", true);
			types[KnownTypes.DataTemplateKey] = assemblies[0].Find("System.Windows.DataTemplateKey", true);
			types[KnownTypes.DataTrigger] = assemblies[0].Find("System.Windows.DataTrigger", true);
			types[KnownTypes.DateTime] = assemblies[3].Find("System.DateTime", true);
			types[KnownTypes.DateTimeConverter] = assemblies[4].Find("System.ComponentModel.DateTimeConverter", true);
			types[KnownTypes.DateTimeConverter2] = assemblies[5].Find("System.Windows.Markup.DateTimeConverter2", true);
			types[KnownTypes.Decimal] = assemblies[3].Find("System.Decimal", true);
			types[KnownTypes.DecimalAnimation] = assemblies[1].Find("System.Windows.Media.Animation.DecimalAnimation", true);
			types[KnownTypes.DecimalAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.DecimalAnimationBase", true);
			types[KnownTypes.DecimalAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.DecimalAnimationUsingKeyFrames", true);
			types[KnownTypes.DecimalConverter] = assemblies[4].Find("System.ComponentModel.DecimalConverter", true);
			types[KnownTypes.DecimalKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DecimalKeyFrame", true);
			types[KnownTypes.DecimalKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.DecimalKeyFrameCollection", true);
			types[KnownTypes.Decorator] = assemblies[0].Find("System.Windows.Controls.Decorator", true);
			types[KnownTypes.DefinitionBase] = assemblies[0].Find("System.Windows.Controls.DefinitionBase", true);
			types[KnownTypes.DependencyObject] = assemblies[5].Find("System.Windows.DependencyObject", true);
			types[KnownTypes.DependencyProperty] = assemblies[5].Find("System.Windows.DependencyProperty", true);
			types[KnownTypes.DependencyPropertyConverter] = assemblies[0].Find("System.Windows.Markup.DependencyPropertyConverter", true);
			types[KnownTypes.DialogResultConverter] = assemblies[0].Find("System.Windows.DialogResultConverter", true);
			types[KnownTypes.DiffuseMaterial] = assemblies[1].Find("System.Windows.Media.Media3D.DiffuseMaterial", true);
			types[KnownTypes.DirectionalLight] = assemblies[1].Find("System.Windows.Media.Media3D.DirectionalLight", true);
			types[KnownTypes.DiscreteBooleanKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteBooleanKeyFrame", true);
			types[KnownTypes.DiscreteByteKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteByteKeyFrame", true);
			types[KnownTypes.DiscreteCharKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteCharKeyFrame", true);
			types[KnownTypes.DiscreteColorKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteColorKeyFrame", true);
			types[KnownTypes.DiscreteDecimalKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteDecimalKeyFrame", true);
			types[KnownTypes.DiscreteDoubleKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteDoubleKeyFrame", true);
			types[KnownTypes.DiscreteInt16KeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteInt16KeyFrame", true);
			types[KnownTypes.DiscreteInt32KeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteInt32KeyFrame", true);
			types[KnownTypes.DiscreteInt64KeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteInt64KeyFrame", true);
			types[KnownTypes.DiscreteMatrixKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteMatrixKeyFrame", true);
			types[KnownTypes.DiscreteObjectKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteObjectKeyFrame", true);
			types[KnownTypes.DiscretePoint3DKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscretePoint3DKeyFrame", true);
			types[KnownTypes.DiscretePointKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscretePointKeyFrame", true);
			types[KnownTypes.DiscreteQuaternionKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteQuaternionKeyFrame", true);
			types[KnownTypes.DiscreteRectKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteRectKeyFrame", true);
			types[KnownTypes.DiscreteRotation3DKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteRotation3DKeyFrame", true);
			types[KnownTypes.DiscreteSingleKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteSingleKeyFrame", true);
			types[KnownTypes.DiscreteSizeKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteSizeKeyFrame", true);
			types[KnownTypes.DiscreteStringKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteStringKeyFrame", true);
			types[KnownTypes.DiscreteThicknessKeyFrame] = assemblies[0].Find("System.Windows.Media.Animation.DiscreteThicknessKeyFrame", true);
			types[KnownTypes.DiscreteVector3DKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteVector3DKeyFrame", true);
			types[KnownTypes.DiscreteVectorKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteVectorKeyFrame", true);
			types[KnownTypes.DockPanel] = assemblies[0].Find("System.Windows.Controls.DockPanel", true);
			types[KnownTypes.DocumentPageView] = assemblies[0].Find("System.Windows.Controls.Primitives.DocumentPageView", true);
			types[KnownTypes.DocumentReference] = assemblies[0].Find("System.Windows.Documents.DocumentReference", true);
			types[KnownTypes.DocumentViewer] = assemblies[0].Find("System.Windows.Controls.DocumentViewer", true);
			types[KnownTypes.DocumentViewerBase] = assemblies[0].Find("System.Windows.Controls.Primitives.DocumentViewerBase", true);
			types[KnownTypes.Double] = assemblies[3].Find("System.Double", true);
			types[KnownTypes.DoubleAnimation] = assemblies[1].Find("System.Windows.Media.Animation.DoubleAnimation", true);
			types[KnownTypes.DoubleAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.DoubleAnimationBase", true);
			types[KnownTypes.DoubleAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.DoubleAnimationUsingKeyFrames", true);
			types[KnownTypes.DoubleAnimationUsingPath] = assemblies[1].Find("System.Windows.Media.Animation.DoubleAnimationUsingPath", true);
			types[KnownTypes.DoubleCollection] = assemblies[1].Find("System.Windows.Media.DoubleCollection", true);
			types[KnownTypes.DoubleCollectionConverter] = assemblies[1].Find("System.Windows.Media.DoubleCollectionConverter", true);
			types[KnownTypes.DoubleConverter] = assemblies[4].Find("System.ComponentModel.DoubleConverter", true);
			types[KnownTypes.DoubleIListConverter] = assemblies[1].Find("System.Windows.Media.Converters.DoubleIListConverter", true);
			types[KnownTypes.DoubleKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DoubleKeyFrame", true);
			types[KnownTypes.DoubleKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.DoubleKeyFrameCollection", true);
			types[KnownTypes.Drawing] = assemblies[1].Find("System.Windows.Media.Drawing", true);
			types[KnownTypes.DrawingBrush] = assemblies[1].Find("System.Windows.Media.DrawingBrush", true);
			types[KnownTypes.DrawingCollection] = assemblies[1].Find("System.Windows.Media.DrawingCollection", true);
			types[KnownTypes.DrawingContext] = assemblies[1].Find("System.Windows.Media.DrawingContext", true);
			types[KnownTypes.DrawingGroup] = assemblies[1].Find("System.Windows.Media.DrawingGroup", true);
			types[KnownTypes.DrawingImage] = assemblies[1].Find("System.Windows.Media.DrawingImage", true);
			types[KnownTypes.DrawingVisual] = assemblies[1].Find("System.Windows.Media.DrawingVisual", true);
			types[KnownTypes.DropShadowBitmapEffect] = assemblies[1].Find("System.Windows.Media.Effects.DropShadowBitmapEffect", true);
			types[KnownTypes.Duration] = assemblies[1].Find("System.Windows.Duration", true);
			types[KnownTypes.DurationConverter] = assemblies[1].Find("System.Windows.DurationConverter", true);
			types[KnownTypes.DynamicResourceExtension] = assemblies[0].Find("System.Windows.DynamicResourceExtension", true);
			types[KnownTypes.DynamicResourceExtensionConverter] = assemblies[0].Find("System.Windows.DynamicResourceExtensionConverter", true);
			types[KnownTypes.Ellipse] = assemblies[0].Find("System.Windows.Shapes.Ellipse", true);
			types[KnownTypes.EllipseGeometry] = assemblies[1].Find("System.Windows.Media.EllipseGeometry", true);
			types[KnownTypes.EmbossBitmapEffect] = assemblies[1].Find("System.Windows.Media.Effects.EmbossBitmapEffect", true);
			types[KnownTypes.EmissiveMaterial] = assemblies[1].Find("System.Windows.Media.Media3D.EmissiveMaterial", true);
			types[KnownTypes.EnumConverter] = assemblies[4].Find("System.ComponentModel.EnumConverter", true);
			types[KnownTypes.EventManager] = assemblies[1].Find("System.Windows.EventManager", true);
			types[KnownTypes.EventSetter] = assemblies[0].Find("System.Windows.EventSetter", true);
			types[KnownTypes.EventTrigger] = assemblies[0].Find("System.Windows.EventTrigger", true);
			types[KnownTypes.Expander] = assemblies[0].Find("System.Windows.Controls.Expander", true);
			types[KnownTypes.Expression] = assemblies[5].Find("System.Windows.Expression", true);
			types[KnownTypes.ExpressionConverter] = assemblies[5].Find("System.Windows.ExpressionConverter", true);
			types[KnownTypes.Figure] = assemblies[0].Find("System.Windows.Documents.Figure", true);
			types[KnownTypes.FigureLength] = assemblies[0].Find("System.Windows.FigureLength", true);
			types[KnownTypes.FigureLengthConverter] = assemblies[0].Find("System.Windows.FigureLengthConverter", true);
			types[KnownTypes.FixedDocument] = assemblies[0].Find("System.Windows.Documents.FixedDocument", true);
			types[KnownTypes.FixedDocumentSequence] = assemblies[0].Find("System.Windows.Documents.FixedDocumentSequence", true);
			types[KnownTypes.FixedPage] = assemblies[0].Find("System.Windows.Documents.FixedPage", true);
			types[KnownTypes.Floater] = assemblies[0].Find("System.Windows.Documents.Floater", true);
			types[KnownTypes.FlowDocument] = assemblies[0].Find("System.Windows.Documents.FlowDocument", true);
			types[KnownTypes.FlowDocumentPageViewer] = assemblies[0].Find("System.Windows.Controls.FlowDocumentPageViewer", true);
			types[KnownTypes.FlowDocumentReader] = assemblies[0].Find("System.Windows.Controls.FlowDocumentReader", true);
			types[KnownTypes.FlowDocumentScrollViewer] = assemblies[0].Find("System.Windows.Controls.FlowDocumentScrollViewer", true);
			types[KnownTypes.FocusManager] = assemblies[1].Find("System.Windows.Input.FocusManager", true);
			types[KnownTypes.FontFamily] = assemblies[1].Find("System.Windows.Media.FontFamily", true);
			types[KnownTypes.FontFamilyConverter] = assemblies[1].Find("System.Windows.Media.FontFamilyConverter", true);
			types[KnownTypes.FontSizeConverter] = assemblies[0].Find("System.Windows.FontSizeConverter", true);
			types[KnownTypes.FontStretch] = assemblies[1].Find("System.Windows.FontStretch", true);
			types[KnownTypes.FontStretchConverter] = assemblies[1].Find("System.Windows.FontStretchConverter", true);
			types[KnownTypes.FontStyle] = assemblies[1].Find("System.Windows.FontStyle", true);
			types[KnownTypes.FontStyleConverter] = assemblies[1].Find("System.Windows.FontStyleConverter", true);
			types[KnownTypes.FontWeight] = assemblies[1].Find("System.Windows.FontWeight", true);
			types[KnownTypes.FontWeightConverter] = assemblies[1].Find("System.Windows.FontWeightConverter", true);
			types[KnownTypes.FormatConvertedBitmap] = assemblies[1].Find("System.Windows.Media.Imaging.FormatConvertedBitmap", true);
			types[KnownTypes.Frame] = assemblies[0].Find("System.Windows.Controls.Frame", true);
			types[KnownTypes.FrameworkContentElement] = assemblies[0].Find("System.Windows.FrameworkContentElement", true);
			types[KnownTypes.FrameworkElement] = assemblies[0].Find("System.Windows.FrameworkElement", true);
			types[KnownTypes.FrameworkElementFactory] = assemblies[0].Find("System.Windows.FrameworkElementFactory", true);
			types[KnownTypes.FrameworkPropertyMetadata] = assemblies[0].Find("System.Windows.FrameworkPropertyMetadata", true);
			types[KnownTypes.FrameworkPropertyMetadataOptions] = assemblies[0].Find("System.Windows.FrameworkPropertyMetadataOptions", true);
			types[KnownTypes.FrameworkRichTextComposition] = assemblies[0].Find("System.Windows.Documents.FrameworkRichTextComposition", true);
			types[KnownTypes.FrameworkTemplate] = assemblies[0].Find("System.Windows.FrameworkTemplate", true);
			types[KnownTypes.FrameworkTextComposition] = assemblies[0].Find("System.Windows.Documents.FrameworkTextComposition", true);
			types[KnownTypes.Freezable] = assemblies[5].Find("System.Windows.Freezable", true);
			types[KnownTypes.GeneralTransform] = assemblies[1].Find("System.Windows.Media.GeneralTransform", true);
			types[KnownTypes.GeneralTransformCollection] = assemblies[1].Find("System.Windows.Media.GeneralTransformCollection", true);
			types[KnownTypes.GeneralTransformGroup] = assemblies[1].Find("System.Windows.Media.GeneralTransformGroup", true);
			types[KnownTypes.Geometry] = assemblies[1].Find("System.Windows.Media.Geometry", true);
			types[KnownTypes.Geometry3D] = assemblies[1].Find("System.Windows.Media.Media3D.Geometry3D", true);
			types[KnownTypes.GeometryCollection] = assemblies[1].Find("System.Windows.Media.GeometryCollection", true);
			types[KnownTypes.GeometryConverter] = assemblies[1].Find("System.Windows.Media.GeometryConverter", true);
			types[KnownTypes.GeometryDrawing] = assemblies[1].Find("System.Windows.Media.GeometryDrawing", true);
			types[KnownTypes.GeometryGroup] = assemblies[1].Find("System.Windows.Media.GeometryGroup", true);
			types[KnownTypes.GeometryModel3D] = assemblies[1].Find("System.Windows.Media.Media3D.GeometryModel3D", true);
			types[KnownTypes.GestureRecognizer] = assemblies[1].Find("System.Windows.Ink.GestureRecognizer", true);
			types[KnownTypes.GifBitmapDecoder] = assemblies[1].Find("System.Windows.Media.Imaging.GifBitmapDecoder", true);
			types[KnownTypes.GifBitmapEncoder] = assemblies[1].Find("System.Windows.Media.Imaging.GifBitmapEncoder", true);
			types[KnownTypes.GlyphRun] = assemblies[1].Find("System.Windows.Media.GlyphRun", true);
			types[KnownTypes.GlyphRunDrawing] = assemblies[1].Find("System.Windows.Media.GlyphRunDrawing", true);
			types[KnownTypes.GlyphTypeface] = assemblies[1].Find("System.Windows.Media.GlyphTypeface", true);
			types[KnownTypes.Glyphs] = assemblies[0].Find("System.Windows.Documents.Glyphs", true);
			types[KnownTypes.GradientBrush] = assemblies[1].Find("System.Windows.Media.GradientBrush", true);
			types[KnownTypes.GradientStop] = assemblies[1].Find("System.Windows.Media.GradientStop", true);
			types[KnownTypes.GradientStopCollection] = assemblies[1].Find("System.Windows.Media.GradientStopCollection", true);
			types[KnownTypes.Grid] = assemblies[0].Find("System.Windows.Controls.Grid", true);
			types[KnownTypes.GridLength] = assemblies[0].Find("System.Windows.GridLength", true);
			types[KnownTypes.GridLengthConverter] = assemblies[0].Find("System.Windows.GridLengthConverter", true);
			types[KnownTypes.GridSplitter] = assemblies[0].Find("System.Windows.Controls.GridSplitter", true);
			types[KnownTypes.GridView] = assemblies[0].Find("System.Windows.Controls.GridView", true);
			types[KnownTypes.GridViewColumn] = assemblies[0].Find("System.Windows.Controls.GridViewColumn", true);
			types[KnownTypes.GridViewColumnHeader] = assemblies[0].Find("System.Windows.Controls.GridViewColumnHeader", true);
			types[KnownTypes.GridViewHeaderRowPresenter] = assemblies[0].Find("System.Windows.Controls.GridViewHeaderRowPresenter", true);
			types[KnownTypes.GridViewRowPresenter] = assemblies[0].Find("System.Windows.Controls.GridViewRowPresenter", true);
			types[KnownTypes.GridViewRowPresenterBase] = assemblies[0].Find("System.Windows.Controls.Primitives.GridViewRowPresenterBase", true);
			types[KnownTypes.GroupBox] = assemblies[0].Find("System.Windows.Controls.GroupBox", true);
			types[KnownTypes.GroupItem] = assemblies[0].Find("System.Windows.Controls.GroupItem", true);
			types[KnownTypes.Guid] = assemblies[3].Find("System.Guid", true);
			types[KnownTypes.GuidConverter] = assemblies[4].Find("System.ComponentModel.GuidConverter", true);
			types[KnownTypes.GuidelineSet] = assemblies[1].Find("System.Windows.Media.GuidelineSet", true);
			types[KnownTypes.HeaderedContentControl] = assemblies[0].Find("System.Windows.Controls.HeaderedContentControl", true);
			types[KnownTypes.HeaderedItemsControl] = assemblies[0].Find("System.Windows.Controls.HeaderedItemsControl", true);
			types[KnownTypes.HierarchicalDataTemplate] = assemblies[0].Find("System.Windows.HierarchicalDataTemplate", true);
			types[KnownTypes.HostVisual] = assemblies[1].Find("System.Windows.Media.HostVisual", true);
			types[KnownTypes.Hyperlink] = assemblies[0].Find("System.Windows.Documents.Hyperlink", true);
			types[KnownTypes.IAddChild] = assemblies[1].Find("System.Windows.Markup.IAddChild", true);
			types[KnownTypes.IAddChildInternal] = assemblies[1].Find("System.Windows.Markup.IAddChildInternal", true);
			types[KnownTypes.ICommand] = assemblies[1].Find("System.Windows.Input.ICommand", true);
			types[KnownTypes.IComponentConnector] = assemblies[2].Find("System.Windows.Markup.IComponentConnector", true);
			types[KnownTypes.INameScope] = assemblies[2].Find("System.Windows.Markup.INameScope", true);
			types[KnownTypes.IStyleConnector] = assemblies[0].Find("System.Windows.Markup.IStyleConnector", true);
			types[KnownTypes.IconBitmapDecoder] = assemblies[1].Find("System.Windows.Media.Imaging.IconBitmapDecoder", true);
			types[KnownTypes.Image] = assemblies[0].Find("System.Windows.Controls.Image", true);
			types[KnownTypes.ImageBrush] = assemblies[1].Find("System.Windows.Media.ImageBrush", true);
			types[KnownTypes.ImageDrawing] = assemblies[1].Find("System.Windows.Media.ImageDrawing", true);
			types[KnownTypes.ImageMetadata] = assemblies[1].Find("System.Windows.Media.ImageMetadata", true);
			types[KnownTypes.ImageSource] = assemblies[1].Find("System.Windows.Media.ImageSource", true);
			types[KnownTypes.ImageSourceConverter] = assemblies[1].Find("System.Windows.Media.ImageSourceConverter", true);
			types[KnownTypes.InPlaceBitmapMetadataWriter] = assemblies[1].Find("System.Windows.Media.Imaging.InPlaceBitmapMetadataWriter", true);
			types[KnownTypes.InkCanvas] = assemblies[0].Find("System.Windows.Controls.InkCanvas", true);
			types[KnownTypes.InkPresenter] = assemblies[0].Find("System.Windows.Controls.InkPresenter", true);
			types[KnownTypes.Inline] = assemblies[0].Find("System.Windows.Documents.Inline", true);
			types[KnownTypes.InlineCollection] = assemblies[0].Find("System.Windows.Documents.InlineCollection", true);
			types[KnownTypes.InlineUIContainer] = assemblies[0].Find("System.Windows.Documents.InlineUIContainer", true);
			types[KnownTypes.InputBinding] = assemblies[1].Find("System.Windows.Input.InputBinding", true);
			types[KnownTypes.InputDevice] = assemblies[1].Find("System.Windows.Input.InputDevice", true);
			types[KnownTypes.InputLanguageManager] = assemblies[1].Find("System.Windows.Input.InputLanguageManager", true);
			types[KnownTypes.InputManager] = assemblies[1].Find("System.Windows.Input.InputManager", true);
			types[KnownTypes.InputMethod] = assemblies[1].Find("System.Windows.Input.InputMethod", true);
			types[KnownTypes.InputScope] = assemblies[1].Find("System.Windows.Input.InputScope", true);
			types[KnownTypes.InputScopeConverter] = assemblies[1].Find("System.Windows.Input.InputScopeConverter", true);
			types[KnownTypes.InputScopeName] = assemblies[1].Find("System.Windows.Input.InputScopeName", true);
			types[KnownTypes.InputScopeNameConverter] = assemblies[1].Find("System.Windows.Input.InputScopeNameConverter", true);
			types[KnownTypes.Int16] = assemblies[3].Find("System.Int16", true);
			types[KnownTypes.Int16Animation] = assemblies[1].Find("System.Windows.Media.Animation.Int16Animation", true);
			types[KnownTypes.Int16AnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.Int16AnimationBase", true);
			types[KnownTypes.Int16AnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.Int16AnimationUsingKeyFrames", true);
			types[KnownTypes.Int16Converter] = assemblies[4].Find("System.ComponentModel.Int16Converter", true);
			types[KnownTypes.Int16KeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.Int16KeyFrame", true);
			types[KnownTypes.Int16KeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.Int16KeyFrameCollection", true);
			types[KnownTypes.Int32] = assemblies[3].Find("System.Int32", true);
			types[KnownTypes.Int32Animation] = assemblies[1].Find("System.Windows.Media.Animation.Int32Animation", true);
			types[KnownTypes.Int32AnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.Int32AnimationBase", true);
			types[KnownTypes.Int32AnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.Int32AnimationUsingKeyFrames", true);
			types[KnownTypes.Int32Collection] = assemblies[1].Find("System.Windows.Media.Int32Collection", true);
			types[KnownTypes.Int32CollectionConverter] = assemblies[1].Find("System.Windows.Media.Int32CollectionConverter", true);
			types[KnownTypes.Int32Converter] = assemblies[4].Find("System.ComponentModel.Int32Converter", true);
			types[KnownTypes.Int32KeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.Int32KeyFrame", true);
			types[KnownTypes.Int32KeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.Int32KeyFrameCollection", true);
			types[KnownTypes.Int32Rect] = assemblies[5].Find("System.Windows.Int32Rect", true);
			types[KnownTypes.Int32RectConverter] = assemblies[5].Find("System.Windows.Int32RectConverter", true);
			types[KnownTypes.Int64] = assemblies[3].Find("System.Int64", true);
			types[KnownTypes.Int64Animation] = assemblies[1].Find("System.Windows.Media.Animation.Int64Animation", true);
			types[KnownTypes.Int64AnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.Int64AnimationBase", true);
			types[KnownTypes.Int64AnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.Int64AnimationUsingKeyFrames", true);
			types[KnownTypes.Int64Converter] = assemblies[4].Find("System.ComponentModel.Int64Converter", true);
			types[KnownTypes.Int64KeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.Int64KeyFrame", true);
			types[KnownTypes.Int64KeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.Int64KeyFrameCollection", true);
			types[KnownTypes.Italic] = assemblies[0].Find("System.Windows.Documents.Italic", true);
			types[KnownTypes.ItemCollection] = assemblies[0].Find("System.Windows.Controls.ItemCollection", true);
			types[KnownTypes.ItemsControl] = assemblies[0].Find("System.Windows.Controls.ItemsControl", true);
			types[KnownTypes.ItemsPanelTemplate] = assemblies[0].Find("System.Windows.Controls.ItemsPanelTemplate", true);
			types[KnownTypes.ItemsPresenter] = assemblies[0].Find("System.Windows.Controls.ItemsPresenter", true);
			types[KnownTypes.JournalEntry] = assemblies[0].Find("System.Windows.Navigation.JournalEntry", true);
			types[KnownTypes.JournalEntryListConverter] = assemblies[0].Find("System.Windows.Navigation.JournalEntryListConverter", true);
			types[KnownTypes.JournalEntryUnifiedViewConverter] = assemblies[0].Find("System.Windows.Navigation.JournalEntryUnifiedViewConverter", true);
			types[KnownTypes.JpegBitmapDecoder] = assemblies[1].Find("System.Windows.Media.Imaging.JpegBitmapDecoder", true);
			types[KnownTypes.JpegBitmapEncoder] = assemblies[1].Find("System.Windows.Media.Imaging.JpegBitmapEncoder", true);
			types[KnownTypes.KeyBinding] = assemblies[1].Find("System.Windows.Input.KeyBinding", true);
			types[KnownTypes.KeyConverter] = assemblies[5].Find("System.Windows.Input.KeyConverter", true);
			types[KnownTypes.KeyGesture] = assemblies[1].Find("System.Windows.Input.KeyGesture", true);
			types[KnownTypes.KeyGestureConverter] = assemblies[1].Find("System.Windows.Input.KeyGestureConverter", true);
			types[KnownTypes.KeySpline] = assemblies[1].Find("System.Windows.Media.Animation.KeySpline", true);
			types[KnownTypes.KeySplineConverter] = assemblies[1].Find("System.Windows.KeySplineConverter", true);
			types[KnownTypes.KeyTime] = assemblies[1].Find("System.Windows.Media.Animation.KeyTime", true);
			types[KnownTypes.KeyTimeConverter] = assemblies[1].Find("System.Windows.KeyTimeConverter", true);
			types[KnownTypes.KeyboardDevice] = assemblies[1].Find("System.Windows.Input.KeyboardDevice", true);
			types[KnownTypes.Label] = assemblies[0].Find("System.Windows.Controls.Label", true);
			types[KnownTypes.LateBoundBitmapDecoder] = assemblies[1].Find("System.Windows.Media.Imaging.LateBoundBitmapDecoder", true);
			types[KnownTypes.LengthConverter] = assemblies[0].Find("System.Windows.LengthConverter", true);
			types[KnownTypes.Light] = assemblies[1].Find("System.Windows.Media.Media3D.Light", true);
			types[KnownTypes.Line] = assemblies[0].Find("System.Windows.Shapes.Line", true);
			types[KnownTypes.LineBreak] = assemblies[0].Find("System.Windows.Documents.LineBreak", true);
			types[KnownTypes.LineGeometry] = assemblies[1].Find("System.Windows.Media.LineGeometry", true);
			types[KnownTypes.LineSegment] = assemblies[1].Find("System.Windows.Media.LineSegment", true);
			types[KnownTypes.LinearByteKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearByteKeyFrame", true);
			types[KnownTypes.LinearColorKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearColorKeyFrame", true);
			types[KnownTypes.LinearDecimalKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearDecimalKeyFrame", true);
			types[KnownTypes.LinearDoubleKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearDoubleKeyFrame", true);
			types[KnownTypes.LinearGradientBrush] = assemblies[1].Find("System.Windows.Media.LinearGradientBrush", true);
			types[KnownTypes.LinearInt16KeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearInt16KeyFrame", true);
			types[KnownTypes.LinearInt32KeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearInt32KeyFrame", true);
			types[KnownTypes.LinearInt64KeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearInt64KeyFrame", true);
			types[KnownTypes.LinearPoint3DKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearPoint3DKeyFrame", true);
			types[KnownTypes.LinearPointKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearPointKeyFrame", true);
			types[KnownTypes.LinearQuaternionKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearQuaternionKeyFrame", true);
			types[KnownTypes.LinearRectKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearRectKeyFrame", true);
			types[KnownTypes.LinearRotation3DKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearRotation3DKeyFrame", true);
			types[KnownTypes.LinearSingleKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearSingleKeyFrame", true);
			types[KnownTypes.LinearSizeKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearSizeKeyFrame", true);
			types[KnownTypes.LinearThicknessKeyFrame] = assemblies[0].Find("System.Windows.Media.Animation.LinearThicknessKeyFrame", true);
			types[KnownTypes.LinearVector3DKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearVector3DKeyFrame", true);
			types[KnownTypes.LinearVectorKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearVectorKeyFrame", true);
			types[KnownTypes.List] = assemblies[0].Find("System.Windows.Documents.List", true);
			types[KnownTypes.ListBox] = assemblies[0].Find("System.Windows.Controls.ListBox", true);
			types[KnownTypes.ListBoxItem] = assemblies[0].Find("System.Windows.Controls.ListBoxItem", true);
			types[KnownTypes.ListCollectionView] = assemblies[0].Find("System.Windows.Data.ListCollectionView", true);
			types[KnownTypes.ListItem] = assemblies[0].Find("System.Windows.Documents.ListItem", true);
			types[KnownTypes.ListView] = assemblies[0].Find("System.Windows.Controls.ListView", true);
			types[KnownTypes.ListViewItem] = assemblies[0].Find("System.Windows.Controls.ListViewItem", true);
			types[KnownTypes.Localization] = assemblies[0].Find("System.Windows.Localization", true);
			types[KnownTypes.LostFocusEventManager] = assemblies[0].Find("System.Windows.LostFocusEventManager", true);
			types[KnownTypes.MarkupExtension] = assemblies[2].Find("System.Windows.Markup.MarkupExtension", true);
			types[KnownTypes.Material] = assemblies[1].Find("System.Windows.Media.Media3D.Material", true);
			types[KnownTypes.MaterialCollection] = assemblies[1].Find("System.Windows.Media.Media3D.MaterialCollection", true);
			types[KnownTypes.MaterialGroup] = assemblies[1].Find("System.Windows.Media.Media3D.MaterialGroup", true);
			types[KnownTypes.Matrix] = assemblies[5].Find("System.Windows.Media.Matrix", true);
			types[KnownTypes.Matrix3D] = assemblies[1].Find("System.Windows.Media.Media3D.Matrix3D", true);
			types[KnownTypes.Matrix3DConverter] = assemblies[1].Find("System.Windows.Media.Media3D.Matrix3DConverter", true);
			types[KnownTypes.MatrixAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.MatrixAnimationBase", true);
			types[KnownTypes.MatrixAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.MatrixAnimationUsingKeyFrames", true);
			types[KnownTypes.MatrixAnimationUsingPath] = assemblies[1].Find("System.Windows.Media.Animation.MatrixAnimationUsingPath", true);
			types[KnownTypes.MatrixCamera] = assemblies[1].Find("System.Windows.Media.Media3D.MatrixCamera", true);
			types[KnownTypes.MatrixConverter] = assemblies[5].Find("System.Windows.Media.MatrixConverter", true);
			types[KnownTypes.MatrixKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.MatrixKeyFrame", true);
			types[KnownTypes.MatrixKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.MatrixKeyFrameCollection", true);
			types[KnownTypes.MatrixTransform] = assemblies[1].Find("System.Windows.Media.MatrixTransform", true);
			types[KnownTypes.MatrixTransform3D] = assemblies[1].Find("System.Windows.Media.Media3D.MatrixTransform3D", true);
			types[KnownTypes.MediaClock] = assemblies[1].Find("System.Windows.Media.MediaClock", true);
			types[KnownTypes.MediaElement] = assemblies[0].Find("System.Windows.Controls.MediaElement", true);
			types[KnownTypes.MediaPlayer] = assemblies[1].Find("System.Windows.Media.MediaPlayer", true);
			types[KnownTypes.MediaTimeline] = assemblies[1].Find("System.Windows.Media.MediaTimeline", true);
			types[KnownTypes.Menu] = assemblies[0].Find("System.Windows.Controls.Menu", true);
			types[KnownTypes.MenuBase] = assemblies[0].Find("System.Windows.Controls.Primitives.MenuBase", true);
			types[KnownTypes.MenuItem] = assemblies[0].Find("System.Windows.Controls.MenuItem", true);
			types[KnownTypes.MenuScrollingVisibilityConverter] = assemblies[0].Find("System.Windows.Controls.MenuScrollingVisibilityConverter", true);
			types[KnownTypes.MeshGeometry3D] = assemblies[1].Find("System.Windows.Media.Media3D.MeshGeometry3D", true);
			types[KnownTypes.Model3D] = assemblies[1].Find("System.Windows.Media.Media3D.Model3D", true);
			types[KnownTypes.Model3DCollection] = assemblies[1].Find("System.Windows.Media.Media3D.Model3DCollection", true);
			types[KnownTypes.Model3DGroup] = assemblies[1].Find("System.Windows.Media.Media3D.Model3DGroup", true);
			types[KnownTypes.ModelVisual3D] = assemblies[1].Find("System.Windows.Media.Media3D.ModelVisual3D", true);
			types[KnownTypes.ModifierKeysConverter] = assemblies[5].Find("System.Windows.Input.ModifierKeysConverter", true);
			types[KnownTypes.MouseActionConverter] = assemblies[1].Find("System.Windows.Input.MouseActionConverter", true);
			types[KnownTypes.MouseBinding] = assemblies[1].Find("System.Windows.Input.MouseBinding", true);
			types[KnownTypes.MouseDevice] = assemblies[1].Find("System.Windows.Input.MouseDevice", true);
			types[KnownTypes.MouseGesture] = assemblies[1].Find("System.Windows.Input.MouseGesture", true);
			types[KnownTypes.MouseGestureConverter] = assemblies[1].Find("System.Windows.Input.MouseGestureConverter", true);
			types[KnownTypes.MultiBinding] = assemblies[0].Find("System.Windows.Data.MultiBinding", true);
			types[KnownTypes.MultiBindingExpression] = assemblies[0].Find("System.Windows.Data.MultiBindingExpression", true);
			types[KnownTypes.MultiDataTrigger] = assemblies[0].Find("System.Windows.MultiDataTrigger", true);
			types[KnownTypes.MultiTrigger] = assemblies[0].Find("System.Windows.MultiTrigger", true);
			types[KnownTypes.NameScope] = assemblies[5].Find("System.Windows.NameScope", true);
			types[KnownTypes.NavigationWindow] = assemblies[0].Find("System.Windows.Navigation.NavigationWindow", true);
			types[KnownTypes.NullExtension] = assemblies[2].Find("System.Windows.Markup.NullExtension", true);
			types[KnownTypes.NullableBoolConverter] = assemblies[0].Find("System.Windows.NullableBoolConverter", true);
			types[KnownTypes.NullableConverter] = assemblies[4].Find("System.ComponentModel.NullableConverter", true);
			types[KnownTypes.NumberSubstitution] = assemblies[1].Find("System.Windows.Media.NumberSubstitution", true);
			types[KnownTypes.Object] = assemblies[3].Find("System.Object", true);
			types[KnownTypes.ObjectAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.ObjectAnimationBase", true);
			types[KnownTypes.ObjectAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.ObjectAnimationUsingKeyFrames", true);
			types[KnownTypes.ObjectDataProvider] = assemblies[0].Find("System.Windows.Data.ObjectDataProvider", true);
			types[KnownTypes.ObjectKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.ObjectKeyFrame", true);
			types[KnownTypes.ObjectKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.ObjectKeyFrameCollection", true);
			types[KnownTypes.OrthographicCamera] = assemblies[1].Find("System.Windows.Media.Media3D.OrthographicCamera", true);
			types[KnownTypes.OuterGlowBitmapEffect] = assemblies[1].Find("System.Windows.Media.Effects.OuterGlowBitmapEffect", true);
			types[KnownTypes.Page] = assemblies[0].Find("System.Windows.Controls.Page", true);
			types[KnownTypes.PageContent] = assemblies[0].Find("System.Windows.Documents.PageContent", true);
			types[KnownTypes.PageFunctionBase] = assemblies[0].Find("System.Windows.Navigation.PageFunctionBase", true);
			types[KnownTypes.Panel] = assemblies[0].Find("System.Windows.Controls.Panel", true);
			types[KnownTypes.Paragraph] = assemblies[0].Find("System.Windows.Documents.Paragraph", true);
			types[KnownTypes.ParallelTimeline] = assemblies[1].Find("System.Windows.Media.Animation.ParallelTimeline", true);
			types[KnownTypes.ParserContext] = assemblies[0].Find("System.Windows.Markup.ParserContext", true);
			types[KnownTypes.PasswordBox] = assemblies[0].Find("System.Windows.Controls.PasswordBox", true);
			types[KnownTypes.Path] = assemblies[0].Find("System.Windows.Shapes.Path", true);
			types[KnownTypes.PathFigure] = assemblies[1].Find("System.Windows.Media.PathFigure", true);
			types[KnownTypes.PathFigureCollection] = assemblies[1].Find("System.Windows.Media.PathFigureCollection", true);
			types[KnownTypes.PathFigureCollectionConverter] = assemblies[1].Find("System.Windows.Media.PathFigureCollectionConverter", true);
			types[KnownTypes.PathGeometry] = assemblies[1].Find("System.Windows.Media.PathGeometry", true);
			types[KnownTypes.PathSegment] = assemblies[1].Find("System.Windows.Media.PathSegment", true);
			types[KnownTypes.PathSegmentCollection] = assemblies[1].Find("System.Windows.Media.PathSegmentCollection", true);
			types[KnownTypes.PauseStoryboard] = assemblies[0].Find("System.Windows.Media.Animation.PauseStoryboard", true);
			types[KnownTypes.Pen] = assemblies[1].Find("System.Windows.Media.Pen", true);
			types[KnownTypes.PerspectiveCamera] = assemblies[1].Find("System.Windows.Media.Media3D.PerspectiveCamera", true);
			types[KnownTypes.PixelFormat] = assemblies[1].Find("System.Windows.Media.PixelFormat", true);
			types[KnownTypes.PixelFormatConverter] = assemblies[1].Find("System.Windows.Media.PixelFormatConverter", true);
			types[KnownTypes.PngBitmapDecoder] = assemblies[1].Find("System.Windows.Media.Imaging.PngBitmapDecoder", true);
			types[KnownTypes.PngBitmapEncoder] = assemblies[1].Find("System.Windows.Media.Imaging.PngBitmapEncoder", true);
			types[KnownTypes.Point] = assemblies[5].Find("System.Windows.Point", true);
			types[KnownTypes.Point3D] = assemblies[1].Find("System.Windows.Media.Media3D.Point3D", true);
			types[KnownTypes.Point3DAnimation] = assemblies[1].Find("System.Windows.Media.Animation.Point3DAnimation", true);
			types[KnownTypes.Point3DAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.Point3DAnimationBase", true);
			types[KnownTypes.Point3DAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.Point3DAnimationUsingKeyFrames", true);
			types[KnownTypes.Point3DCollection] = assemblies[1].Find("System.Windows.Media.Media3D.Point3DCollection", true);
			types[KnownTypes.Point3DCollectionConverter] = assemblies[1].Find("System.Windows.Media.Media3D.Point3DCollectionConverter", true);
			types[KnownTypes.Point3DConverter] = assemblies[1].Find("System.Windows.Media.Media3D.Point3DConverter", true);
			types[KnownTypes.Point3DKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.Point3DKeyFrame", true);
			types[KnownTypes.Point3DKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.Point3DKeyFrameCollection", true);
			types[KnownTypes.Point4D] = assemblies[1].Find("System.Windows.Media.Media3D.Point4D", true);
			types[KnownTypes.Point4DConverter] = assemblies[1].Find("System.Windows.Media.Media3D.Point4DConverter", true);
			types[KnownTypes.PointAnimation] = assemblies[1].Find("System.Windows.Media.Animation.PointAnimation", true);
			types[KnownTypes.PointAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.PointAnimationBase", true);
			types[KnownTypes.PointAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.PointAnimationUsingKeyFrames", true);
			types[KnownTypes.PointAnimationUsingPath] = assemblies[1].Find("System.Windows.Media.Animation.PointAnimationUsingPath", true);
			types[KnownTypes.PointCollection] = assemblies[1].Find("System.Windows.Media.PointCollection", true);
			types[KnownTypes.PointCollectionConverter] = assemblies[1].Find("System.Windows.Media.PointCollectionConverter", true);
			types[KnownTypes.PointConverter] = assemblies[5].Find("System.Windows.PointConverter", true);
			types[KnownTypes.PointIListConverter] = assemblies[1].Find("System.Windows.Media.Converters.PointIListConverter", true);
			types[KnownTypes.PointKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.PointKeyFrame", true);
			types[KnownTypes.PointKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.PointKeyFrameCollection", true);
			types[KnownTypes.PointLight] = assemblies[1].Find("System.Windows.Media.Media3D.PointLight", true);
			types[KnownTypes.PointLightBase] = assemblies[1].Find("System.Windows.Media.Media3D.PointLightBase", true);
			types[KnownTypes.PolyBezierSegment] = assemblies[1].Find("System.Windows.Media.PolyBezierSegment", true);
			types[KnownTypes.PolyLineSegment] = assemblies[1].Find("System.Windows.Media.PolyLineSegment", true);
			types[KnownTypes.PolyQuadraticBezierSegment] = assemblies[1].Find("System.Windows.Media.PolyQuadraticBezierSegment", true);
			types[KnownTypes.Polygon] = assemblies[0].Find("System.Windows.Shapes.Polygon", true);
			types[KnownTypes.Polyline] = assemblies[0].Find("System.Windows.Shapes.Polyline", true);
			types[KnownTypes.Popup] = assemblies[0].Find("System.Windows.Controls.Primitives.Popup", true);
			types[KnownTypes.PresentationSource] = assemblies[1].Find("System.Windows.PresentationSource", true);
			types[KnownTypes.PriorityBinding] = assemblies[0].Find("System.Windows.Data.PriorityBinding", true);
			types[KnownTypes.PriorityBindingExpression] = assemblies[0].Find("System.Windows.Data.PriorityBindingExpression", true);
			types[KnownTypes.ProgressBar] = assemblies[0].Find("System.Windows.Controls.ProgressBar", true);
			types[KnownTypes.ProjectionCamera] = assemblies[1].Find("System.Windows.Media.Media3D.ProjectionCamera", true);
			types[KnownTypes.PropertyPath] = assemblies[0].Find("System.Windows.PropertyPath", true);
			types[KnownTypes.PropertyPathConverter] = assemblies[0].Find("System.Windows.PropertyPathConverter", true);
			types[KnownTypes.QuadraticBezierSegment] = assemblies[1].Find("System.Windows.Media.QuadraticBezierSegment", true);
			types[KnownTypes.Quaternion] = assemblies[1].Find("System.Windows.Media.Media3D.Quaternion", true);
			types[KnownTypes.QuaternionAnimation] = assemblies[1].Find("System.Windows.Media.Animation.QuaternionAnimation", true);
			types[KnownTypes.QuaternionAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.QuaternionAnimationBase", true);
			types[KnownTypes.QuaternionAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.QuaternionAnimationUsingKeyFrames", true);
			types[KnownTypes.QuaternionConverter] = assemblies[1].Find("System.Windows.Media.Media3D.QuaternionConverter", true);
			types[KnownTypes.QuaternionKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.QuaternionKeyFrame", true);
			types[KnownTypes.QuaternionKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.QuaternionKeyFrameCollection", true);
			types[KnownTypes.QuaternionRotation3D] = assemblies[1].Find("System.Windows.Media.Media3D.QuaternionRotation3D", true);
			types[KnownTypes.RadialGradientBrush] = assemblies[1].Find("System.Windows.Media.RadialGradientBrush", true);
			types[KnownTypes.RadioButton] = assemblies[0].Find("System.Windows.Controls.RadioButton", true);
			types[KnownTypes.RangeBase] = assemblies[0].Find("System.Windows.Controls.Primitives.RangeBase", true);
			types[KnownTypes.Rect] = assemblies[5].Find("System.Windows.Rect", true);
			types[KnownTypes.Rect3D] = assemblies[1].Find("System.Windows.Media.Media3D.Rect3D", true);
			types[KnownTypes.Rect3DConverter] = assemblies[1].Find("System.Windows.Media.Media3D.Rect3DConverter", true);
			types[KnownTypes.RectAnimation] = assemblies[1].Find("System.Windows.Media.Animation.RectAnimation", true);
			types[KnownTypes.RectAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.RectAnimationBase", true);
			types[KnownTypes.RectAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.RectAnimationUsingKeyFrames", true);
			types[KnownTypes.RectConverter] = assemblies[5].Find("System.Windows.RectConverter", true);
			types[KnownTypes.RectKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.RectKeyFrame", true);
			types[KnownTypes.RectKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.RectKeyFrameCollection", true);
			types[KnownTypes.Rectangle] = assemblies[0].Find("System.Windows.Shapes.Rectangle", true);
			types[KnownTypes.RectangleGeometry] = assemblies[1].Find("System.Windows.Media.RectangleGeometry", true);
			types[KnownTypes.RelativeSource] = assemblies[0].Find("System.Windows.Data.RelativeSource", true);
			types[KnownTypes.RemoveStoryboard] = assemblies[0].Find("System.Windows.Media.Animation.RemoveStoryboard", true);
			types[KnownTypes.RenderOptions] = assemblies[1].Find("System.Windows.Media.RenderOptions", true);
			types[KnownTypes.RenderTargetBitmap] = assemblies[1].Find("System.Windows.Media.Imaging.RenderTargetBitmap", true);
			types[KnownTypes.RepeatBehavior] = assemblies[1].Find("System.Windows.Media.Animation.RepeatBehavior", true);
			types[KnownTypes.RepeatBehaviorConverter] = assemblies[1].Find("System.Windows.Media.Animation.RepeatBehaviorConverter", true);
			types[KnownTypes.RepeatButton] = assemblies[0].Find("System.Windows.Controls.Primitives.RepeatButton", true);
			types[KnownTypes.ResizeGrip] = assemblies[0].Find("System.Windows.Controls.Primitives.ResizeGrip", true);
			types[KnownTypes.ResourceDictionary] = assemblies[0].Find("System.Windows.ResourceDictionary", true);
			types[KnownTypes.ResourceKey] = assemblies[0].Find("System.Windows.ResourceKey", true);
			types[KnownTypes.ResumeStoryboard] = assemblies[0].Find("System.Windows.Media.Animation.ResumeStoryboard", true);
			types[KnownTypes.RichTextBox] = assemblies[0].Find("System.Windows.Controls.RichTextBox", true);
			types[KnownTypes.RotateTransform] = assemblies[1].Find("System.Windows.Media.RotateTransform", true);
			types[KnownTypes.RotateTransform3D] = assemblies[1].Find("System.Windows.Media.Media3D.RotateTransform3D", true);
			types[KnownTypes.Rotation3D] = assemblies[1].Find("System.Windows.Media.Media3D.Rotation3D", true);
			types[KnownTypes.Rotation3DAnimation] = assemblies[1].Find("System.Windows.Media.Animation.Rotation3DAnimation", true);
			types[KnownTypes.Rotation3DAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.Rotation3DAnimationBase", true);
			types[KnownTypes.Rotation3DAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.Rotation3DAnimationUsingKeyFrames", true);
			types[KnownTypes.Rotation3DKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.Rotation3DKeyFrame", true);
			types[KnownTypes.Rotation3DKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.Rotation3DKeyFrameCollection", true);
			types[KnownTypes.RoutedCommand] = assemblies[1].Find("System.Windows.Input.RoutedCommand", true);
			types[KnownTypes.RoutedEvent] = assemblies[1].Find("System.Windows.RoutedEvent", true);
			types[KnownTypes.RoutedEventConverter] = assemblies[0].Find("System.Windows.Markup.RoutedEventConverter", true);
			types[KnownTypes.RoutedUICommand] = assemblies[1].Find("System.Windows.Input.RoutedUICommand", true);
			types[KnownTypes.RoutingStrategy] = assemblies[1].Find("System.Windows.RoutingStrategy", true);
			types[KnownTypes.RowDefinition] = assemblies[0].Find("System.Windows.Controls.RowDefinition", true);
			types[KnownTypes.Run] = assemblies[0].Find("System.Windows.Documents.Run", true);
			types[KnownTypes.RuntimeNamePropertyAttribute] = assemblies[2].Find("System.Windows.Markup.RuntimeNamePropertyAttribute", true);
			types[KnownTypes.SByte] = assemblies[3].Find("System.SByte", true);
			types[KnownTypes.SByteConverter] = assemblies[4].Find("System.ComponentModel.SByteConverter", true);
			types[KnownTypes.ScaleTransform] = assemblies[1].Find("System.Windows.Media.ScaleTransform", true);
			types[KnownTypes.ScaleTransform3D] = assemblies[1].Find("System.Windows.Media.Media3D.ScaleTransform3D", true);
			types[KnownTypes.ScrollBar] = assemblies[0].Find("System.Windows.Controls.Primitives.ScrollBar", true);
			types[KnownTypes.ScrollContentPresenter] = assemblies[0].Find("System.Windows.Controls.ScrollContentPresenter", true);
			types[KnownTypes.ScrollViewer] = assemblies[0].Find("System.Windows.Controls.ScrollViewer", true);
			types[KnownTypes.Section] = assemblies[0].Find("System.Windows.Documents.Section", true);
			types[KnownTypes.SeekStoryboard] = assemblies[0].Find("System.Windows.Media.Animation.SeekStoryboard", true);
			types[KnownTypes.Selector] = assemblies[0].Find("System.Windows.Controls.Primitives.Selector", true);
			types[KnownTypes.Separator] = assemblies[0].Find("System.Windows.Controls.Separator", true);
			types[KnownTypes.SetStoryboardSpeedRatio] = assemblies[0].Find("System.Windows.Media.Animation.SetStoryboardSpeedRatio", true);
			types[KnownTypes.Setter] = assemblies[0].Find("System.Windows.Setter", true);
			types[KnownTypes.SetterBase] = assemblies[0].Find("System.Windows.SetterBase", true);
			types[KnownTypes.Shape] = assemblies[0].Find("System.Windows.Shapes.Shape", true);
			types[KnownTypes.Single] = assemblies[3].Find("System.Single", true);
			types[KnownTypes.SingleAnimation] = assemblies[1].Find("System.Windows.Media.Animation.SingleAnimation", true);
			types[KnownTypes.SingleAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.SingleAnimationBase", true);
			types[KnownTypes.SingleAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.SingleAnimationUsingKeyFrames", true);
			types[KnownTypes.SingleConverter] = assemblies[4].Find("System.ComponentModel.SingleConverter", true);
			types[KnownTypes.SingleKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SingleKeyFrame", true);
			types[KnownTypes.SingleKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.SingleKeyFrameCollection", true);
			types[KnownTypes.Size] = assemblies[5].Find("System.Windows.Size", true);
			types[KnownTypes.Size3D] = assemblies[1].Find("System.Windows.Media.Media3D.Size3D", true);
			types[KnownTypes.Size3DConverter] = assemblies[1].Find("System.Windows.Media.Media3D.Size3DConverter", true);
			types[KnownTypes.SizeAnimation] = assemblies[1].Find("System.Windows.Media.Animation.SizeAnimation", true);
			types[KnownTypes.SizeAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.SizeAnimationBase", true);
			types[KnownTypes.SizeAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.SizeAnimationUsingKeyFrames", true);
			types[KnownTypes.SizeConverter] = assemblies[5].Find("System.Windows.SizeConverter", true);
			types[KnownTypes.SizeKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SizeKeyFrame", true);
			types[KnownTypes.SizeKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.SizeKeyFrameCollection", true);
			types[KnownTypes.SkewTransform] = assemblies[1].Find("System.Windows.Media.SkewTransform", true);
			types[KnownTypes.SkipStoryboardToFill] = assemblies[0].Find("System.Windows.Media.Animation.SkipStoryboardToFill", true);
			types[KnownTypes.Slider] = assemblies[0].Find("System.Windows.Controls.Slider", true);
			types[KnownTypes.SolidColorBrush] = assemblies[1].Find("System.Windows.Media.SolidColorBrush", true);
			types[KnownTypes.SoundPlayerAction] = assemblies[0].Find("System.Windows.Controls.SoundPlayerAction", true);
			types[KnownTypes.Span] = assemblies[0].Find("System.Windows.Documents.Span", true);
			types[KnownTypes.SpecularMaterial] = assemblies[1].Find("System.Windows.Media.Media3D.SpecularMaterial", true);
			types[KnownTypes.SpellCheck] = assemblies[0].Find("System.Windows.Controls.SpellCheck", true);
			types[KnownTypes.SplineByteKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineByteKeyFrame", true);
			types[KnownTypes.SplineColorKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineColorKeyFrame", true);
			types[KnownTypes.SplineDecimalKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineDecimalKeyFrame", true);
			types[KnownTypes.SplineDoubleKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineDoubleKeyFrame", true);
			types[KnownTypes.SplineInt16KeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineInt16KeyFrame", true);
			types[KnownTypes.SplineInt32KeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineInt32KeyFrame", true);
			types[KnownTypes.SplineInt64KeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineInt64KeyFrame", true);
			types[KnownTypes.SplinePoint3DKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplinePoint3DKeyFrame", true);
			types[KnownTypes.SplinePointKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplinePointKeyFrame", true);
			types[KnownTypes.SplineQuaternionKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineQuaternionKeyFrame", true);
			types[KnownTypes.SplineRectKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineRectKeyFrame", true);
			types[KnownTypes.SplineRotation3DKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineRotation3DKeyFrame", true);
			types[KnownTypes.SplineSingleKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineSingleKeyFrame", true);
			types[KnownTypes.SplineSizeKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineSizeKeyFrame", true);
			types[KnownTypes.SplineThicknessKeyFrame] = assemblies[0].Find("System.Windows.Media.Animation.SplineThicknessKeyFrame", true);
			types[KnownTypes.SplineVector3DKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineVector3DKeyFrame", true);
			types[KnownTypes.SplineVectorKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineVectorKeyFrame", true);
			types[KnownTypes.SpotLight] = assemblies[1].Find("System.Windows.Media.Media3D.SpotLight", true);
			types[KnownTypes.StackPanel] = assemblies[0].Find("System.Windows.Controls.StackPanel", true);
			types[KnownTypes.StaticExtension] = assemblies[2].Find("System.Windows.Markup.StaticExtension", true);
			types[KnownTypes.StaticResourceExtension] = assemblies[0].Find("System.Windows.StaticResourceExtension", true);
			types[KnownTypes.StatusBar] = assemblies[0].Find("System.Windows.Controls.Primitives.StatusBar", true);
			types[KnownTypes.StatusBarItem] = assemblies[0].Find("System.Windows.Controls.Primitives.StatusBarItem", true);
			types[KnownTypes.StickyNoteControl] = assemblies[0].Find("System.Windows.Controls.StickyNoteControl", true);
			types[KnownTypes.StopStoryboard] = assemblies[0].Find("System.Windows.Media.Animation.StopStoryboard", true);
			types[KnownTypes.Storyboard] = assemblies[0].Find("System.Windows.Media.Animation.Storyboard", true);
			types[KnownTypes.StreamGeometry] = assemblies[1].Find("System.Windows.Media.StreamGeometry", true);
			types[KnownTypes.StreamGeometryContext] = assemblies[1].Find("System.Windows.Media.StreamGeometryContext", true);
			types[KnownTypes.StreamResourceInfo] = assemblies[0].Find("System.Windows.Resources.StreamResourceInfo", true);
			types[KnownTypes.String] = assemblies[3].Find("System.String", true);
			types[KnownTypes.StringAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.StringAnimationBase", true);
			types[KnownTypes.StringAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.StringAnimationUsingKeyFrames", true);
			types[KnownTypes.StringConverter] = assemblies[4].Find("System.ComponentModel.StringConverter", true);
			types[KnownTypes.StringKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.StringKeyFrame", true);
			types[KnownTypes.StringKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.StringKeyFrameCollection", true);
			types[KnownTypes.StrokeCollection] = assemblies[1].Find("System.Windows.Ink.StrokeCollection", true);
			types[KnownTypes.StrokeCollectionConverter] = assemblies[1].Find("System.Windows.StrokeCollectionConverter", true);
			types[KnownTypes.Style] = assemblies[0].Find("System.Windows.Style", true);
			types[KnownTypes.Stylus] = assemblies[1].Find("System.Windows.Input.Stylus", true);
			types[KnownTypes.StylusDevice] = assemblies[1].Find("System.Windows.Input.StylusDevice", true);
			types[KnownTypes.TabControl] = assemblies[0].Find("System.Windows.Controls.TabControl", true);
			types[KnownTypes.TabItem] = assemblies[0].Find("System.Windows.Controls.TabItem", true);
			types[KnownTypes.TabPanel] = assemblies[0].Find("System.Windows.Controls.Primitives.TabPanel", true);
			types[KnownTypes.Table] = assemblies[0].Find("System.Windows.Documents.Table", true);
			types[KnownTypes.TableCell] = assemblies[0].Find("System.Windows.Documents.TableCell", true);
			types[KnownTypes.TableColumn] = assemblies[0].Find("System.Windows.Documents.TableColumn", true);
			types[KnownTypes.TableRow] = assemblies[0].Find("System.Windows.Documents.TableRow", true);
			types[KnownTypes.TableRowGroup] = assemblies[0].Find("System.Windows.Documents.TableRowGroup", true);
			types[KnownTypes.TabletDevice] = assemblies[1].Find("System.Windows.Input.TabletDevice", true);
			types[KnownTypes.TemplateBindingExpression] = assemblies[0].Find("System.Windows.TemplateBindingExpression", true);
			types[KnownTypes.TemplateBindingExpressionConverter] = assemblies[0].Find("System.Windows.TemplateBindingExpressionConverter", true);
			types[KnownTypes.TemplateBindingExtension] = assemblies[0].Find("System.Windows.TemplateBindingExtension", true);
			types[KnownTypes.TemplateBindingExtensionConverter] = assemblies[0].Find("System.Windows.TemplateBindingExtensionConverter", true);
			types[KnownTypes.TemplateKey] = assemblies[0].Find("System.Windows.TemplateKey", true);
			types[KnownTypes.TemplateKeyConverter] = assemblies[0].Find("System.Windows.Markup.TemplateKeyConverter", true);
			types[KnownTypes.TextBlock] = assemblies[0].Find("System.Windows.Controls.TextBlock", true);
			types[KnownTypes.TextBox] = assemblies[0].Find("System.Windows.Controls.TextBox", true);
			types[KnownTypes.TextBoxBase] = assemblies[0].Find("System.Windows.Controls.Primitives.TextBoxBase", true);
			types[KnownTypes.TextComposition] = assemblies[1].Find("System.Windows.Input.TextComposition", true);
			types[KnownTypes.TextCompositionManager] = assemblies[1].Find("System.Windows.Input.TextCompositionManager", true);
			types[KnownTypes.TextDecoration] = assemblies[1].Find("System.Windows.TextDecoration", true);
			types[KnownTypes.TextDecorationCollection] = assemblies[1].Find("System.Windows.TextDecorationCollection", true);
			types[KnownTypes.TextDecorationCollectionConverter] = assemblies[1].Find("System.Windows.TextDecorationCollectionConverter", true);
			types[KnownTypes.TextEffect] = assemblies[1].Find("System.Windows.Media.TextEffect", true);
			types[KnownTypes.TextEffectCollection] = assemblies[1].Find("System.Windows.Media.TextEffectCollection", true);
			types[KnownTypes.TextElement] = assemblies[0].Find("System.Windows.Documents.TextElement", true);
			types[KnownTypes.TextSearch] = assemblies[0].Find("System.Windows.Controls.TextSearch", true);
			types[KnownTypes.ThemeDictionaryExtension] = assemblies[0].Find("System.Windows.ThemeDictionaryExtension", true);
			types[KnownTypes.Thickness] = assemblies[0].Find("System.Windows.Thickness", true);
			types[KnownTypes.ThicknessAnimation] = assemblies[0].Find("System.Windows.Media.Animation.ThicknessAnimation", true);
			types[KnownTypes.ThicknessAnimationBase] = assemblies[0].Find("System.Windows.Media.Animation.ThicknessAnimationBase", true);
			types[KnownTypes.ThicknessAnimationUsingKeyFrames] = assemblies[0].Find("System.Windows.Media.Animation.ThicknessAnimationUsingKeyFrames", true);
			types[KnownTypes.ThicknessConverter] = assemblies[0].Find("System.Windows.ThicknessConverter", true);
			types[KnownTypes.ThicknessKeyFrame] = assemblies[0].Find("System.Windows.Media.Animation.ThicknessKeyFrame", true);
			types[KnownTypes.ThicknessKeyFrameCollection] = assemblies[0].Find("System.Windows.Media.Animation.ThicknessKeyFrameCollection", true);
			types[KnownTypes.Thumb] = assemblies[0].Find("System.Windows.Controls.Primitives.Thumb", true);
			types[KnownTypes.TickBar] = assemblies[0].Find("System.Windows.Controls.Primitives.TickBar", true);
			types[KnownTypes.TiffBitmapDecoder] = assemblies[1].Find("System.Windows.Media.Imaging.TiffBitmapDecoder", true);
			types[KnownTypes.TiffBitmapEncoder] = assemblies[1].Find("System.Windows.Media.Imaging.TiffBitmapEncoder", true);
			types[KnownTypes.TileBrush] = assemblies[1].Find("System.Windows.Media.TileBrush", true);
			types[KnownTypes.TimeSpan] = assemblies[3].Find("System.TimeSpan", true);
			types[KnownTypes.TimeSpanConverter] = assemblies[4].Find("System.ComponentModel.TimeSpanConverter", true);
			types[KnownTypes.Timeline] = assemblies[1].Find("System.Windows.Media.Animation.Timeline", true);
			types[KnownTypes.TimelineCollection] = assemblies[1].Find("System.Windows.Media.Animation.TimelineCollection", true);
			types[KnownTypes.TimelineGroup] = assemblies[1].Find("System.Windows.Media.Animation.TimelineGroup", true);
			types[KnownTypes.ToggleButton] = assemblies[0].Find("System.Windows.Controls.Primitives.ToggleButton", true);
			types[KnownTypes.ToolBar] = assemblies[0].Find("System.Windows.Controls.ToolBar", true);
			types[KnownTypes.ToolBarOverflowPanel] = assemblies[0].Find("System.Windows.Controls.Primitives.ToolBarOverflowPanel", true);
			types[KnownTypes.ToolBarPanel] = assemblies[0].Find("System.Windows.Controls.Primitives.ToolBarPanel", true);
			types[KnownTypes.ToolBarTray] = assemblies[0].Find("System.Windows.Controls.ToolBarTray", true);
			types[KnownTypes.ToolTip] = assemblies[0].Find("System.Windows.Controls.ToolTip", true);
			types[KnownTypes.ToolTipService] = assemblies[0].Find("System.Windows.Controls.ToolTipService", true);
			types[KnownTypes.Track] = assemblies[0].Find("System.Windows.Controls.Primitives.Track", true);
			types[KnownTypes.Transform] = assemblies[1].Find("System.Windows.Media.Transform", true);
			types[KnownTypes.Transform3D] = assemblies[1].Find("System.Windows.Media.Media3D.Transform3D", true);
			types[KnownTypes.Transform3DCollection] = assemblies[1].Find("System.Windows.Media.Media3D.Transform3DCollection", true);
			types[KnownTypes.Transform3DGroup] = assemblies[1].Find("System.Windows.Media.Media3D.Transform3DGroup", true);
			types[KnownTypes.TransformCollection] = assemblies[1].Find("System.Windows.Media.TransformCollection", true);
			types[KnownTypes.TransformConverter] = assemblies[1].Find("System.Windows.Media.TransformConverter", true);
			types[KnownTypes.TransformGroup] = assemblies[1].Find("System.Windows.Media.TransformGroup", true);
			types[KnownTypes.TransformedBitmap] = assemblies[1].Find("System.Windows.Media.Imaging.TransformedBitmap", true);
			types[KnownTypes.TranslateTransform] = assemblies[1].Find("System.Windows.Media.TranslateTransform", true);
			types[KnownTypes.TranslateTransform3D] = assemblies[1].Find("System.Windows.Media.Media3D.TranslateTransform3D", true);
			types[KnownTypes.TreeView] = assemblies[0].Find("System.Windows.Controls.TreeView", true);
			types[KnownTypes.TreeViewItem] = assemblies[0].Find("System.Windows.Controls.TreeViewItem", true);
			types[KnownTypes.Trigger] = assemblies[0].Find("System.Windows.Trigger", true);
			types[KnownTypes.TriggerAction] = assemblies[0].Find("System.Windows.TriggerAction", true);
			types[KnownTypes.TriggerBase] = assemblies[0].Find("System.Windows.TriggerBase", true);
			types[KnownTypes.TypeExtension] = assemblies[2].Find("System.Windows.Markup.TypeExtension", true);
			types[KnownTypes.TypeTypeConverter] = assemblies[5].Find("System.Windows.Markup.TypeTypeConverter", true);
			types[KnownTypes.Typography] = assemblies[0].Find("System.Windows.Documents.Typography", true);
			types[KnownTypes.UIElement] = assemblies[1].Find("System.Windows.UIElement", true);
			types[KnownTypes.UInt16] = assemblies[3].Find("System.UInt16", true);
			types[KnownTypes.UInt16Converter] = assemblies[4].Find("System.ComponentModel.UInt16Converter", true);
			types[KnownTypes.UInt32] = assemblies[3].Find("System.UInt32", true);
			types[KnownTypes.UInt32Converter] = assemblies[4].Find("System.ComponentModel.UInt32Converter", true);
			types[KnownTypes.UInt64] = assemblies[3].Find("System.UInt64", true);
			types[KnownTypes.UInt64Converter] = assemblies[4].Find("System.ComponentModel.UInt64Converter", true);
			types[KnownTypes.UShortIListConverter] = assemblies[1].Find("System.Windows.Media.Converters.UShortIListConverter", true);
			types[KnownTypes.Underline] = assemblies[0].Find("System.Windows.Documents.Underline", true);
			types[KnownTypes.UniformGrid] = assemblies[0].Find("System.Windows.Controls.Primitives.UniformGrid", true);
			types[KnownTypes.Uri] = assemblies[4].Find("System.Uri", true);
			types[KnownTypes.UriTypeConverter] = assemblies[4].Find("System.UriTypeConverter", true);
			types[KnownTypes.UserControl] = assemblies[0].Find("System.Windows.Controls.UserControl", true);
			types[KnownTypes.Validation] = assemblies[0].Find("System.Windows.Controls.Validation", true);
			types[KnownTypes.Vector] = assemblies[5].Find("System.Windows.Vector", true);
			types[KnownTypes.Vector3D] = assemblies[1].Find("System.Windows.Media.Media3D.Vector3D", true);
			types[KnownTypes.Vector3DAnimation] = assemblies[1].Find("System.Windows.Media.Animation.Vector3DAnimation", true);
			types[KnownTypes.Vector3DAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.Vector3DAnimationBase", true);
			types[KnownTypes.Vector3DAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.Vector3DAnimationUsingKeyFrames", true);
			types[KnownTypes.Vector3DCollection] = assemblies[1].Find("System.Windows.Media.Media3D.Vector3DCollection", true);
			types[KnownTypes.Vector3DCollectionConverter] = assemblies[1].Find("System.Windows.Media.Media3D.Vector3DCollectionConverter", true);
			types[KnownTypes.Vector3DConverter] = assemblies[1].Find("System.Windows.Media.Media3D.Vector3DConverter", true);
			types[KnownTypes.Vector3DKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.Vector3DKeyFrame", true);
			types[KnownTypes.Vector3DKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.Vector3DKeyFrameCollection", true);
			types[KnownTypes.VectorAnimation] = assemblies[1].Find("System.Windows.Media.Animation.VectorAnimation", true);
			types[KnownTypes.VectorAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.VectorAnimationBase", true);
			types[KnownTypes.VectorAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.VectorAnimationUsingKeyFrames", true);
			types[KnownTypes.VectorCollection] = assemblies[1].Find("System.Windows.Media.VectorCollection", true);
			types[KnownTypes.VectorCollectionConverter] = assemblies[1].Find("System.Windows.Media.VectorCollectionConverter", true);
			types[KnownTypes.VectorConverter] = assemblies[5].Find("System.Windows.VectorConverter", true);
			types[KnownTypes.VectorKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.VectorKeyFrame", true);
			types[KnownTypes.VectorKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.VectorKeyFrameCollection", true);
			types[KnownTypes.VideoDrawing] = assemblies[1].Find("System.Windows.Media.VideoDrawing", true);
			types[KnownTypes.ViewBase] = assemblies[0].Find("System.Windows.Controls.ViewBase", true);
			types[KnownTypes.Viewbox] = assemblies[0].Find("System.Windows.Controls.Viewbox", true);
			types[KnownTypes.Viewport3D] = assemblies[0].Find("System.Windows.Controls.Viewport3D", true);
			types[KnownTypes.Viewport3DVisual] = assemblies[1].Find("System.Windows.Media.Media3D.Viewport3DVisual", true);
			types[KnownTypes.VirtualizingPanel] = assemblies[0].Find("System.Windows.Controls.VirtualizingPanel", true);
			types[KnownTypes.VirtualizingStackPanel] = assemblies[0].Find("System.Windows.Controls.VirtualizingStackPanel", true);
			types[KnownTypes.Visual] = assemblies[1].Find("System.Windows.Media.Visual", true);
			types[KnownTypes.Visual3D] = assemblies[1].Find("System.Windows.Media.Media3D.Visual3D", true);
			types[KnownTypes.VisualBrush] = assemblies[1].Find("System.Windows.Media.VisualBrush", true);
			types[KnownTypes.VisualTarget] = assemblies[1].Find("System.Windows.Media.VisualTarget", true);
			types[KnownTypes.WeakEventManager] = assemblies[5].Find("System.Windows.WeakEventManager", true);
			types[KnownTypes.WhitespaceSignificantCollectionAttribute] = assemblies[2].Find("System.Windows.Markup.WhitespaceSignificantCollectionAttribute", true);
			types[KnownTypes.Window] = assemblies[0].Find("System.Windows.Window", true);
			types[KnownTypes.WmpBitmapDecoder] = assemblies[1].Find("System.Windows.Media.Imaging.WmpBitmapDecoder", true);
			types[KnownTypes.WmpBitmapEncoder] = assemblies[1].Find("System.Windows.Media.Imaging.WmpBitmapEncoder", true);
			types[KnownTypes.WrapPanel] = assemblies[0].Find("System.Windows.Controls.WrapPanel", true);
			types[KnownTypes.WriteableBitmap] = assemblies[1].Find("System.Windows.Media.Imaging.WriteableBitmap", true);
			types[KnownTypes.XamlBrushSerializer] = assemblies[0].Find("System.Windows.Markup.XamlBrushSerializer", true);
			types[KnownTypes.XamlInt32CollectionSerializer] = assemblies[0].Find("System.Windows.Markup.XamlInt32CollectionSerializer", true);
			types[KnownTypes.XamlPathDataSerializer] = assemblies[0].Find("System.Windows.Markup.XamlPathDataSerializer", true);
			types[KnownTypes.XamlPoint3DCollectionSerializer] = assemblies[0].Find("System.Windows.Markup.XamlPoint3DCollectionSerializer", true);
			types[KnownTypes.XamlPointCollectionSerializer] = assemblies[0].Find("System.Windows.Markup.XamlPointCollectionSerializer", true);
			types[KnownTypes.XamlReader] = assemblies[0].Find("System.Windows.Markup.XamlReader", true);
			types[KnownTypes.XamlStyleSerializer] = assemblies[0].Find("System.Windows.Markup.XamlStyleSerializer", true);
			types[KnownTypes.XamlTemplateSerializer] = assemblies[0].Find("System.Windows.Markup.XamlTemplateSerializer", true);
			types[KnownTypes.XamlVector3DCollectionSerializer] = assemblies[0].Find("System.Windows.Markup.XamlVector3DCollectionSerializer", true);
			types[KnownTypes.XamlWriter] = assemblies[0].Find("System.Windows.Markup.XamlWriter", true);
			types[KnownTypes.XmlDataProvider] = assemblies[0].Find("System.Windows.Data.XmlDataProvider", true);
			types[KnownTypes.XmlLangPropertyAttribute] = assemblies[2].Find("System.Windows.Markup.XmlLangPropertyAttribute", true);
			types[KnownTypes.XmlLanguage] = assemblies[1].Find("System.Windows.Markup.XmlLanguage", true);
			types[KnownTypes.XmlLanguageConverter] = assemblies[1].Find("System.Windows.Markup.XmlLanguageConverter", true);
			types[KnownTypes.XmlNamespaceMapping] = assemblies[0].Find("System.Windows.Data.XmlNamespaceMapping", true);
			types[KnownTypes.ZoomPercentageConverter] = assemblies[0].Find("System.Windows.Documents.ZoomPercentageConverter", true);
		}

		void InitProperties() {
			properties[KnownProperties.AccessText_Text] = InitProperty(KnownTypes.AccessText, "Text", assemblies[3].Find("System.Char", true));
			properties[KnownProperties.BeginStoryboard_Storyboard] = InitProperty(KnownTypes.BeginStoryboard, "Storyboard", assemblies[0].Find("System.Windows.Media.Animation.Storyboard", true));
			properties[KnownProperties.BitmapEffectGroup_Children] = InitProperty(KnownTypes.BitmapEffectGroup, "Children", assemblies[1].Find("System.Windows.Media.Effects.BitmapEffect", true));
			properties[KnownProperties.Border_Background] = InitProperty(KnownTypes.Border, "Background", assemblies[1].Find("System.Windows.Media.Brush", true));
			properties[KnownProperties.Border_BorderBrush] = InitProperty(KnownTypes.Border, "BorderBrush", assemblies[1].Find("System.Windows.Media.Brush", true));
			properties[KnownProperties.Border_BorderThickness] = InitProperty(KnownTypes.Border, "BorderThickness", assemblies[0].Find("System.Windows.Thickness", true));
			properties[KnownProperties.ButtonBase_Command] = InitProperty(KnownTypes.ButtonBase, "Command", assemblies[1].Find("System.Windows.Input.ICommand", true));
			properties[KnownProperties.ButtonBase_CommandParameter] = InitProperty(KnownTypes.ButtonBase, "CommandParameter", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.ButtonBase_CommandTarget] = InitProperty(KnownTypes.ButtonBase, "CommandTarget", assemblies[1].Find("System.Windows.IInputElement", true));
			properties[KnownProperties.ButtonBase_IsPressed] = InitProperty(KnownTypes.ButtonBase, "IsPressed", assemblies[3].Find("System.Boolean", true));
			properties[KnownProperties.ColumnDefinition_MaxWidth] = InitProperty(KnownTypes.ColumnDefinition, "MaxWidth", assemblies[3].Find("System.Double", true));
			properties[KnownProperties.ColumnDefinition_MinWidth] = InitProperty(KnownTypes.ColumnDefinition, "MinWidth", assemblies[3].Find("System.Double", true));
			properties[KnownProperties.ColumnDefinition_Width] = InitProperty(KnownTypes.ColumnDefinition, "Width", assemblies[0].Find("System.Windows.GridLength", true));
			properties[KnownProperties.ContentControl_Content] = InitProperty(KnownTypes.ContentControl, "Content", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.ContentControl_ContentTemplate] = InitProperty(KnownTypes.ContentControl, "ContentTemplate", assemblies[0].Find("System.Windows.DataTemplate", true));
			properties[KnownProperties.ContentControl_ContentTemplateSelector] = InitProperty(KnownTypes.ContentControl, "ContentTemplateSelector", assemblies[0].Find("System.Windows.Controls.DataTemplateSelector", true));
			properties[KnownProperties.ContentControl_HasContent] = InitProperty(KnownTypes.ContentControl, "HasContent", assemblies[3].Find("System.Boolean", true));
			properties[KnownProperties.ContentElement_Focusable] = InitProperty(KnownTypes.ContentElement, "Focusable", assemblies[3].Find("System.Boolean", true));
			properties[KnownProperties.ContentPresenter_Content] = InitProperty(KnownTypes.ContentPresenter, "Content", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.ContentPresenter_ContentSource] = InitProperty(KnownTypes.ContentPresenter, "ContentSource", assemblies[3].Find("System.Char", true));
			properties[KnownProperties.ContentPresenter_ContentTemplate] = InitProperty(KnownTypes.ContentPresenter, "ContentTemplate", assemblies[0].Find("System.Windows.DataTemplate", true));
			properties[KnownProperties.ContentPresenter_ContentTemplateSelector] = InitProperty(KnownTypes.ContentPresenter, "ContentTemplateSelector", assemblies[0].Find("System.Windows.Controls.DataTemplateSelector", true));
			properties[KnownProperties.ContentPresenter_RecognizesAccessKey] = InitProperty(KnownTypes.ContentPresenter, "RecognizesAccessKey", assemblies[3].Find("System.Boolean", true));
			properties[KnownProperties.Control_Background] = InitProperty(KnownTypes.Control, "Background", assemblies[1].Find("System.Windows.Media.Brush", true));
			properties[KnownProperties.Control_BorderBrush] = InitProperty(KnownTypes.Control, "BorderBrush", assemblies[1].Find("System.Windows.Media.Brush", true));
			properties[KnownProperties.Control_BorderThickness] = InitProperty(KnownTypes.Control, "BorderThickness", assemblies[0].Find("System.Windows.Thickness", true));
			properties[KnownProperties.Control_FontFamily] = InitProperty(KnownTypes.Control, "FontFamily", assemblies[1].Find("System.Windows.Media.FontFamily", true));
			properties[KnownProperties.Control_FontSize] = InitProperty(KnownTypes.Control, "FontSize", assemblies[3].Find("System.Double", true));
			properties[KnownProperties.Control_FontStretch] = InitProperty(KnownTypes.Control, "FontStretch", assemblies[1].Find("System.Windows.FontStretch", true));
			properties[KnownProperties.Control_FontStyle] = InitProperty(KnownTypes.Control, "FontStyle", assemblies[1].Find("System.Windows.FontStyle", true));
			properties[KnownProperties.Control_FontWeight] = InitProperty(KnownTypes.Control, "FontWeight", assemblies[1].Find("System.Windows.FontWeight", true));
			properties[KnownProperties.Control_Foreground] = InitProperty(KnownTypes.Control, "Foreground", assemblies[1].Find("System.Windows.Media.Brush", true));
			properties[KnownProperties.Control_HorizontalContentAlignment] = InitProperty(KnownTypes.Control, "HorizontalContentAlignment", assemblies[0].Find("System.Windows.HorizontalAlignment", true));
			properties[KnownProperties.Control_IsTabStop] = InitProperty(KnownTypes.Control, null, assemblies[3].Find("System.Boolean", true));
			properties[KnownProperties.Control_Padding] = InitProperty(KnownTypes.Control, "Padding", assemblies[0].Find("System.Windows.Thickness", true));
			properties[KnownProperties.Control_TabIndex] = InitProperty(KnownTypes.Control, null, assemblies[3].Find("System.Int32", true));
			properties[KnownProperties.Control_Template] = InitProperty(KnownTypes.Control, "Template", assemblies[0].Find("System.Windows.Controls.ControlTemplate", true));
			properties[KnownProperties.Control_VerticalContentAlignment] = InitProperty(KnownTypes.Control, "VerticalContentAlignment", assemblies[0].Find("System.Windows.VerticalAlignment", true));
			properties[KnownProperties.DockPanel_Dock] = InitProperty(KnownTypes.DockPanel, null, assemblies[0].Find("System.Windows.Controls.Dock", true));
			properties[KnownProperties.DockPanel_LastChildFill] = InitProperty(KnownTypes.DockPanel, "LastChildFill", assemblies[3].Find("System.Boolean", true));
			properties[KnownProperties.DocumentViewerBase_Document] = InitProperty(KnownTypes.DocumentViewerBase, "Document", assemblies[1].Find("System.Windows.Documents.IDocumentPaginatorSource", true));
			properties[KnownProperties.DrawingGroup_Children] = InitProperty(KnownTypes.DrawingGroup, "Children", assemblies[1].Find("System.Windows.Media.Drawing", true));
			properties[KnownProperties.FlowDocumentReader_Document] = InitProperty(KnownTypes.FlowDocumentReader, "Document", assemblies[0].Find("System.Windows.Documents.FlowDocument", true));
			properties[KnownProperties.FlowDocumentScrollViewer_Document] = InitProperty(KnownTypes.FlowDocumentScrollViewer, "Document", assemblies[0].Find("System.Windows.Documents.FlowDocument", true));
			properties[KnownProperties.FrameworkContentElement_Style] = InitProperty(KnownTypes.FrameworkContentElement, "Style", assemblies[0].Find("System.Windows.Style", true));
			properties[KnownProperties.FrameworkElement_FlowDirection] = InitProperty(KnownTypes.FrameworkElement, "FlowDirection", assemblies[1].Find("System.Windows.FlowDirection", true));
			properties[KnownProperties.FrameworkElement_Height] = InitProperty(KnownTypes.FrameworkElement, "Height", assemblies[3].Find("System.Double", true));
			properties[KnownProperties.FrameworkElement_HorizontalAlignment] = InitProperty(KnownTypes.FrameworkElement, "HorizontalAlignment", assemblies[0].Find("System.Windows.HorizontalAlignment", true));
			properties[KnownProperties.FrameworkElement_Margin] = InitProperty(KnownTypes.FrameworkElement, "Margin", assemblies[0].Find("System.Windows.Thickness", true));
			properties[KnownProperties.FrameworkElement_MaxHeight] = InitProperty(KnownTypes.FrameworkElement, "MaxHeight", assemblies[3].Find("System.Double", true));
			properties[KnownProperties.FrameworkElement_MaxWidth] = InitProperty(KnownTypes.FrameworkElement, "MaxWidth", assemblies[3].Find("System.Double", true));
			properties[KnownProperties.FrameworkElement_MinHeight] = InitProperty(KnownTypes.FrameworkElement, "MinHeight", assemblies[3].Find("System.Double", true));
			properties[KnownProperties.FrameworkElement_MinWidth] = InitProperty(KnownTypes.FrameworkElement, "MinWidth", assemblies[3].Find("System.Double", true));
			properties[KnownProperties.FrameworkElement_Name] = InitProperty(KnownTypes.FrameworkElement, "Name", assemblies[3].Find("System.Char", true));
			properties[KnownProperties.FrameworkElement_Style] = InitProperty(KnownTypes.FrameworkElement, "Style", assemblies[0].Find("System.Windows.Style", true));
			properties[KnownProperties.FrameworkElement_VerticalAlignment] = InitProperty(KnownTypes.FrameworkElement, "VerticalAlignment", assemblies[0].Find("System.Windows.VerticalAlignment", true));
			properties[KnownProperties.FrameworkElement_Width] = InitProperty(KnownTypes.FrameworkElement, "Width", assemblies[3].Find("System.Double", true));
			properties[KnownProperties.GeneralTransformGroup_Children] = InitProperty(KnownTypes.GeneralTransformGroup, "Children", assemblies[1].Find("System.Windows.Media.GeneralTransform", true));
			properties[KnownProperties.GeometryGroup_Children] = InitProperty(KnownTypes.GeometryGroup, "Children", assemblies[1].Find("System.Windows.Media.Geometry", true));
			properties[KnownProperties.GradientBrush_GradientStops] = InitProperty(KnownTypes.GradientBrush, "GradientStops", assemblies[1].Find("System.Windows.Media.GradientStop", true));
			properties[KnownProperties.Grid_Column] = InitProperty(KnownTypes.Grid, null, assemblies[3].Find("System.Int32", true));
			properties[KnownProperties.Grid_ColumnSpan] = InitProperty(KnownTypes.Grid, null, assemblies[3].Find("System.Int32", true));
			properties[KnownProperties.Grid_Row] = InitProperty(KnownTypes.Grid, null, assemblies[3].Find("System.Int32", true));
			properties[KnownProperties.Grid_RowSpan] = InitProperty(KnownTypes.Grid, null, assemblies[3].Find("System.Int32", true));
			properties[KnownProperties.GridViewColumn_Header] = InitProperty(KnownTypes.GridViewColumn, "Header", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.HeaderedContentControl_HasHeader] = InitProperty(KnownTypes.HeaderedContentControl, "HasHeader", assemblies[3].Find("System.Boolean", true));
			properties[KnownProperties.HeaderedContentControl_Header] = InitProperty(KnownTypes.HeaderedContentControl, "Header", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.HeaderedContentControl_HeaderTemplate] = InitProperty(KnownTypes.HeaderedContentControl, "HeaderTemplate", assemblies[0].Find("System.Windows.DataTemplate", true));
			properties[KnownProperties.HeaderedContentControl_HeaderTemplateSelector] = InitProperty(KnownTypes.HeaderedContentControl, "HeaderTemplateSelector", assemblies[0].Find("System.Windows.Controls.DataTemplateSelector", true));
			properties[KnownProperties.HeaderedItemsControl_HasHeader] = InitProperty(KnownTypes.HeaderedItemsControl, "HasHeader", assemblies[3].Find("System.Boolean", true));
			properties[KnownProperties.HeaderedItemsControl_Header] = InitProperty(KnownTypes.HeaderedItemsControl, "Header", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.HeaderedItemsControl_HeaderTemplate] = InitProperty(KnownTypes.HeaderedItemsControl, "HeaderTemplate", assemblies[0].Find("System.Windows.DataTemplate", true));
			properties[KnownProperties.HeaderedItemsControl_HeaderTemplateSelector] = InitProperty(KnownTypes.HeaderedItemsControl, "HeaderTemplateSelector", assemblies[0].Find("System.Windows.Controls.DataTemplateSelector", true));
			properties[KnownProperties.Hyperlink_NavigateUri] = InitProperty(KnownTypes.Hyperlink, "NavigateUri", assemblies[4].Find("System.Uri", true));
			properties[KnownProperties.Image_Source] = InitProperty(KnownTypes.Image, "Source", assemblies[1].Find("System.Windows.Media.ImageSource", true));
			properties[KnownProperties.Image_Stretch] = InitProperty(KnownTypes.Image, "Stretch", assemblies[1].Find("System.Windows.Media.Stretch", true));
			properties[KnownProperties.ItemsControl_ItemContainerStyle] = InitProperty(KnownTypes.ItemsControl, "ItemContainerStyle", assemblies[0].Find("System.Windows.Style", true));
			properties[KnownProperties.ItemsControl_ItemContainerStyleSelector] = InitProperty(KnownTypes.ItemsControl, "ItemContainerStyleSelector", assemblies[0].Find("System.Windows.Controls.StyleSelector", true));
			properties[KnownProperties.ItemsControl_ItemTemplate] = InitProperty(KnownTypes.ItemsControl, "ItemTemplate", assemblies[0].Find("System.Windows.DataTemplate", true));
			properties[KnownProperties.ItemsControl_ItemTemplateSelector] = InitProperty(KnownTypes.ItemsControl, "ItemTemplateSelector", assemblies[0].Find("System.Windows.Controls.DataTemplateSelector", true));
			properties[KnownProperties.ItemsControl_ItemsPanel] = InitProperty(KnownTypes.ItemsControl, "ItemsPanel", assemblies[0].Find("System.Windows.Controls.ItemsPanelTemplate", true));
			properties[KnownProperties.ItemsControl_ItemsSource] = InitProperty(KnownTypes.ItemsControl, "ItemsSource", assemblies[3].Find("System.Collections.IEnumerable", true));
			properties[KnownProperties.MaterialGroup_Children] = InitProperty(KnownTypes.MaterialGroup, "Children", assemblies[1].Find("System.Windows.Media.Media3D.Material", true));
			properties[KnownProperties.Model3DGroup_Children] = InitProperty(KnownTypes.Model3DGroup, "Children", assemblies[1].Find("System.Windows.Media.Media3D.Model3D", true));
			properties[KnownProperties.Page_Content] = InitProperty(KnownTypes.Page, "Content", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.Panel_Background] = InitProperty(KnownTypes.Panel, "Background", assemblies[1].Find("System.Windows.Media.Brush", true));
			properties[KnownProperties.Path_Data] = InitProperty(KnownTypes.Path, "Data", assemblies[1].Find("System.Windows.Media.Geometry", true));
			properties[KnownProperties.PathFigure_Segments] = InitProperty(KnownTypes.PathFigure, "Segments", assemblies[1].Find("System.Windows.Media.PathSegment", true));
			properties[KnownProperties.PathGeometry_Figures] = InitProperty(KnownTypes.PathGeometry, "Figures", assemblies[1].Find("System.Windows.Media.PathFigure", true));
			properties[KnownProperties.Popup_Child] = InitProperty(KnownTypes.Popup, "Child", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.Popup_IsOpen] = InitProperty(KnownTypes.Popup, "IsOpen", assemblies[3].Find("System.Boolean", true));
			properties[KnownProperties.Popup_Placement] = InitProperty(KnownTypes.Popup, "Placement", assemblies[0].Find("System.Windows.Controls.Primitives.PlacementMode", true));
			properties[KnownProperties.Popup_PopupAnimation] = InitProperty(KnownTypes.Popup, "PopupAnimation", assemblies[0].Find("System.Windows.Controls.Primitives.PopupAnimation", true));
			properties[KnownProperties.RowDefinition_Height] = InitProperty(KnownTypes.RowDefinition, "Height", assemblies[0].Find("System.Windows.GridLength", true));
			properties[KnownProperties.RowDefinition_MaxHeight] = InitProperty(KnownTypes.RowDefinition, "MaxHeight", assemblies[3].Find("System.Double", true));
			properties[KnownProperties.RowDefinition_MinHeight] = InitProperty(KnownTypes.RowDefinition, "MinHeight", assemblies[3].Find("System.Double", true));
			properties[KnownProperties.ScrollViewer_CanContentScroll] = InitProperty(KnownTypes.ScrollViewer, "CanContentScroll", assemblies[3].Find("System.Boolean", true));
			properties[KnownProperties.ScrollViewer_HorizontalScrollBarVisibility] = InitProperty(KnownTypes.ScrollViewer, "HorizontalScrollBarVisibility", assemblies[0].Find("System.Windows.Controls.ScrollBarVisibility", true));
			properties[KnownProperties.ScrollViewer_VerticalScrollBarVisibility] = InitProperty(KnownTypes.ScrollViewer, "VerticalScrollBarVisibility", assemblies[0].Find("System.Windows.Controls.ScrollBarVisibility", true));
			properties[KnownProperties.Shape_Fill] = InitProperty(KnownTypes.Shape, "Fill", assemblies[1].Find("System.Windows.Media.Brush", true));
			properties[KnownProperties.Shape_Stroke] = InitProperty(KnownTypes.Shape, "Stroke", assemblies[1].Find("System.Windows.Media.Brush", true));
			properties[KnownProperties.Shape_StrokeThickness] = InitProperty(KnownTypes.Shape, "StrokeThickness", assemblies[3].Find("System.Double", true));
			properties[KnownProperties.TextBlock_Background] = InitProperty(KnownTypes.TextBlock, "Background", assemblies[1].Find("System.Windows.Media.Brush", true));
			properties[KnownProperties.TextBlock_FontFamily] = InitProperty(KnownTypes.TextBlock, "FontFamily", assemblies[1].Find("System.Windows.Media.FontFamily", true));
			properties[KnownProperties.TextBlock_FontSize] = InitProperty(KnownTypes.TextBlock, "FontSize", assemblies[3].Find("System.Double", true));
			properties[KnownProperties.TextBlock_FontStretch] = InitProperty(KnownTypes.TextBlock, "FontStretch", assemblies[1].Find("System.Windows.FontStretch", true));
			properties[KnownProperties.TextBlock_FontStyle] = InitProperty(KnownTypes.TextBlock, "FontStyle", assemblies[1].Find("System.Windows.FontStyle", true));
			properties[KnownProperties.TextBlock_FontWeight] = InitProperty(KnownTypes.TextBlock, "FontWeight", assemblies[1].Find("System.Windows.FontWeight", true));
			properties[KnownProperties.TextBlock_Foreground] = InitProperty(KnownTypes.TextBlock, "Foreground", assemblies[1].Find("System.Windows.Media.Brush", true));
			properties[KnownProperties.TextBlock_Text] = InitProperty(KnownTypes.TextBlock, "Text", assemblies[3].Find("System.Char", true));
			properties[KnownProperties.TextBlock_TextDecorations] = InitProperty(KnownTypes.TextBlock, "TextDecorations", assemblies[1].Find("System.Windows.TextDecoration", true));
			properties[KnownProperties.TextBlock_TextTrimming] = InitProperty(KnownTypes.TextBlock, "TextTrimming", assemblies[1].Find("System.Windows.TextTrimming", true));
			properties[KnownProperties.TextBlock_TextWrapping] = InitProperty(KnownTypes.TextBlock, "TextWrapping", assemblies[1].Find("System.Windows.TextWrapping", true));
			properties[KnownProperties.TextBox_Text] = InitProperty(KnownTypes.TextBox, "Text", assemblies[3].Find("System.Char", true));
			properties[KnownProperties.TextElement_Background] = InitProperty(KnownTypes.TextElement, "Background", assemblies[1].Find("System.Windows.Media.Brush", true));
			properties[KnownProperties.TextElement_FontFamily] = InitProperty(KnownTypes.TextElement, "FontFamily", assemblies[1].Find("System.Windows.Media.FontFamily", true));
			properties[KnownProperties.TextElement_FontSize] = InitProperty(KnownTypes.TextElement, "FontSize", assemblies[3].Find("System.Double", true));
			properties[KnownProperties.TextElement_FontStretch] = InitProperty(KnownTypes.TextElement, "FontStretch", assemblies[1].Find("System.Windows.FontStretch", true));
			properties[KnownProperties.TextElement_FontStyle] = InitProperty(KnownTypes.TextElement, "FontStyle", assemblies[1].Find("System.Windows.FontStyle", true));
			properties[KnownProperties.TextElement_FontWeight] = InitProperty(KnownTypes.TextElement, "FontWeight", assemblies[1].Find("System.Windows.FontWeight", true));
			properties[KnownProperties.TextElement_Foreground] = InitProperty(KnownTypes.TextElement, "Foreground", assemblies[1].Find("System.Windows.Media.Brush", true));
			properties[KnownProperties.TimelineGroup_Children] = InitProperty(KnownTypes.TimelineGroup, "Children", assemblies[1].Find("System.Windows.Media.Animation.Timeline", true));
			properties[KnownProperties.Track_IsDirectionReversed] = InitProperty(KnownTypes.Track, "IsDirectionReversed", assemblies[3].Find("System.Boolean", true));
			properties[KnownProperties.Track_Maximum] = InitProperty(KnownTypes.Track, "Maximum", assemblies[3].Find("System.Double", true));
			properties[KnownProperties.Track_Minimum] = InitProperty(KnownTypes.Track, "Minimum", assemblies[3].Find("System.Double", true));
			properties[KnownProperties.Track_Orientation] = InitProperty(KnownTypes.Track, "Orientation", assemblies[0].Find("System.Windows.Controls.Orientation", true));
			properties[KnownProperties.Track_Value] = InitProperty(KnownTypes.Track, "Value", assemblies[3].Find("System.Double", true));
			properties[KnownProperties.Track_ViewportSize] = InitProperty(KnownTypes.Track, "ViewportSize", assemblies[3].Find("System.Double", true));
			properties[KnownProperties.Transform3DGroup_Children] = InitProperty(KnownTypes.Transform3DGroup, "Children", assemblies[1].Find("System.Windows.Media.Media3D.Transform3D", true));
			properties[KnownProperties.TransformGroup_Children] = InitProperty(KnownTypes.TransformGroup, "Children", assemblies[1].Find("System.Windows.Media.Transform", true));
			properties[KnownProperties.UIElement_ClipToBounds] = InitProperty(KnownTypes.UIElement, "ClipToBounds", assemblies[3].Find("System.Boolean", true));
			properties[KnownProperties.UIElement_Focusable] = InitProperty(KnownTypes.UIElement, "Focusable", assemblies[3].Find("System.Boolean", true));
			properties[KnownProperties.UIElement_IsEnabled] = InitProperty(KnownTypes.UIElement, "IsEnabled", assemblies[3].Find("System.Boolean", true));
			properties[KnownProperties.UIElement_RenderTransform] = InitProperty(KnownTypes.UIElement, "RenderTransform", assemblies[1].Find("System.Windows.Media.Transform", true));
			properties[KnownProperties.UIElement_Visibility] = InitProperty(KnownTypes.UIElement, "Visibility", assemblies[1].Find("System.Windows.Visibility", true));
			properties[KnownProperties.Viewport3D_Children] = InitProperty(KnownTypes.Viewport3D, "Children", assemblies[1].Find("System.Windows.Media.Media3D.Visual3D", true));
			properties[KnownProperties.AdornedElementPlaceholder_Child] = InitProperty(KnownTypes.AdornedElementPlaceholder, "Child", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.AdornerDecorator_Child] = InitProperty(KnownTypes.AdornerDecorator, "Child", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.AnchoredBlock_Blocks] = InitProperty(KnownTypes.AnchoredBlock, "Blocks", assemblies[0].Find("System.Windows.Documents.Block", true));
			properties[KnownProperties.ArrayExtension_Items] = InitProperty(KnownTypes.ArrayExtension, "Items", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.BlockUIContainer_Child] = InitProperty(KnownTypes.BlockUIContainer, "Child", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.Bold_Inlines] = InitProperty(KnownTypes.Bold, "Inlines", assemblies[0].Find("System.Windows.Documents.Inline", true));
			properties[KnownProperties.BooleanAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.BooleanAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.BooleanKeyFrame", true));
			properties[KnownProperties.Border_Child] = InitProperty(KnownTypes.Border, "Child", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.BulletDecorator_Child] = InitProperty(KnownTypes.BulletDecorator, "Child", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.Button_Content] = InitProperty(KnownTypes.Button, "Content", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.ButtonBase_Content] = InitProperty(KnownTypes.ButtonBase, "Content", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.ByteAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.ByteAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.ByteKeyFrame", true));
			properties[KnownProperties.Canvas_Children] = InitProperty(KnownTypes.Canvas, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.CharAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.CharAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.CharKeyFrame", true));
			properties[KnownProperties.CheckBox_Content] = InitProperty(KnownTypes.CheckBox, "Content", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.ColorAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.ColorAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.ColorKeyFrame", true));
			properties[KnownProperties.ComboBox_Items] = InitProperty(KnownTypes.ComboBox, "Items", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.ComboBoxItem_Content] = InitProperty(KnownTypes.ComboBoxItem, "Content", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.ContextMenu_Items] = InitProperty(KnownTypes.ContextMenu, "Items", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.ControlTemplate_VisualTree] = InitProperty(KnownTypes.ControlTemplate, "VisualTree", assemblies[0].Find("System.Windows.FrameworkElementFactory", true));
			properties[KnownProperties.DataTemplate_VisualTree] = InitProperty(KnownTypes.DataTemplate, "VisualTree", assemblies[0].Find("System.Windows.FrameworkElementFactory", true));
			properties[KnownProperties.DataTrigger_Setters] = InitProperty(KnownTypes.DataTrigger, "Setters", assemblies[0].Find("System.Windows.SetterBase", true));
			properties[KnownProperties.DecimalAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.DecimalAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.DecimalKeyFrame", true));
			properties[KnownProperties.Decorator_Child] = InitProperty(KnownTypes.Decorator, "Child", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.DockPanel_Children] = InitProperty(KnownTypes.DockPanel, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.DocumentViewer_Document] = InitProperty(KnownTypes.DocumentViewer, "Document", assemblies[1].Find("System.Windows.Documents.IDocumentPaginatorSource", true));
			properties[KnownProperties.DoubleAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.DoubleAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.DoubleKeyFrame", true));
			properties[KnownProperties.EventTrigger_Actions] = InitProperty(KnownTypes.EventTrigger, "Actions", assemblies[0].Find("System.Windows.TriggerAction", true));
			properties[KnownProperties.Expander_Content] = InitProperty(KnownTypes.Expander, "Content", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.Figure_Blocks] = InitProperty(KnownTypes.Figure, "Blocks", assemblies[0].Find("System.Windows.Documents.Block", true));
			properties[KnownProperties.FixedDocument_Pages] = InitProperty(KnownTypes.FixedDocument, "Pages", assemblies[0].Find("System.Windows.Documents.PageContent", true));
			properties[KnownProperties.FixedDocumentSequence_References] = InitProperty(KnownTypes.FixedDocumentSequence, "References", assemblies[0].Find("System.Windows.Documents.DocumentReference", true));
			properties[KnownProperties.FixedPage_Children] = InitProperty(KnownTypes.FixedPage, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.Floater_Blocks] = InitProperty(KnownTypes.Floater, "Blocks", assemblies[0].Find("System.Windows.Documents.Block", true));
			properties[KnownProperties.FlowDocument_Blocks] = InitProperty(KnownTypes.FlowDocument, "Blocks", assemblies[0].Find("System.Windows.Documents.Block", true));
			properties[KnownProperties.FlowDocumentPageViewer_Document] = InitProperty(KnownTypes.FlowDocumentPageViewer, "Document", assemblies[1].Find("System.Windows.Documents.IDocumentPaginatorSource", true));
			properties[KnownProperties.FrameworkTemplate_VisualTree] = InitProperty(KnownTypes.FrameworkTemplate, "VisualTree", assemblies[0].Find("System.Windows.FrameworkElementFactory", true));
			properties[KnownProperties.Grid_Children] = InitProperty(KnownTypes.Grid, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.GridView_Columns] = InitProperty(KnownTypes.GridView, "Columns", assemblies[0].Find("System.Windows.Controls.GridViewColumn", true));
			properties[KnownProperties.GridViewColumnHeader_Content] = InitProperty(KnownTypes.GridViewColumnHeader, "Content", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.GroupBox_Content] = InitProperty(KnownTypes.GroupBox, "Content", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.GroupItem_Content] = InitProperty(KnownTypes.GroupItem, "Content", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.HeaderedContentControl_Content] = InitProperty(KnownTypes.HeaderedContentControl, "Content", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.HeaderedItemsControl_Items] = InitProperty(KnownTypes.HeaderedItemsControl, "Items", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.HierarchicalDataTemplate_VisualTree] = InitProperty(KnownTypes.HierarchicalDataTemplate, "VisualTree", assemblies[0].Find("System.Windows.FrameworkElementFactory", true));
			properties[KnownProperties.Hyperlink_Inlines] = InitProperty(KnownTypes.Hyperlink, "Inlines", assemblies[0].Find("System.Windows.Documents.Inline", true));
			properties[KnownProperties.InkCanvas_Children] = InitProperty(KnownTypes.InkCanvas, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.InkPresenter_Child] = InitProperty(KnownTypes.InkPresenter, "Child", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.InlineUIContainer_Child] = InitProperty(KnownTypes.InlineUIContainer, "Child", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.InputScopeName_NameValue] = InitProperty(KnownTypes.InputScopeName, "NameValue", assemblies[1].Find("System.Windows.Input.InputScopeNameValue", true));
			properties[KnownProperties.Int16AnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.Int16AnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.Int16KeyFrame", true));
			properties[KnownProperties.Int32AnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.Int32AnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.Int32KeyFrame", true));
			properties[KnownProperties.Int64AnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.Int64AnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.Int64KeyFrame", true));
			properties[KnownProperties.Italic_Inlines] = InitProperty(KnownTypes.Italic, "Inlines", assemblies[0].Find("System.Windows.Documents.Inline", true));
			properties[KnownProperties.ItemsControl_Items] = InitProperty(KnownTypes.ItemsControl, "Items", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.ItemsPanelTemplate_VisualTree] = InitProperty(KnownTypes.ItemsPanelTemplate, "VisualTree", assemblies[0].Find("System.Windows.FrameworkElementFactory", true));
			properties[KnownProperties.Label_Content] = InitProperty(KnownTypes.Label, "Content", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.LinearGradientBrush_GradientStops] = InitProperty(KnownTypes.LinearGradientBrush, "GradientStops", assemblies[1].Find("System.Windows.Media.GradientStop", true));
			properties[KnownProperties.List_ListItems] = InitProperty(KnownTypes.List, "ListItems", assemblies[0].Find("System.Windows.Documents.ListItem", true));
			properties[KnownProperties.ListBox_Items] = InitProperty(KnownTypes.ListBox, "Items", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.ListBoxItem_Content] = InitProperty(KnownTypes.ListBoxItem, "Content", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.ListItem_Blocks] = InitProperty(KnownTypes.ListItem, "Blocks", assemblies[0].Find("System.Windows.Documents.Block", true));
			properties[KnownProperties.ListView_Items] = InitProperty(KnownTypes.ListView, "Items", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.ListViewItem_Content] = InitProperty(KnownTypes.ListViewItem, "Content", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.MatrixAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.MatrixAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.MatrixKeyFrame", true));
			properties[KnownProperties.Menu_Items] = InitProperty(KnownTypes.Menu, "Items", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.MenuBase_Items] = InitProperty(KnownTypes.MenuBase, "Items", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.MenuItem_Items] = InitProperty(KnownTypes.MenuItem, "Items", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.ModelVisual3D_Children] = InitProperty(KnownTypes.ModelVisual3D, "Children", assemblies[1].Find("System.Windows.Media.Media3D.Visual3D", true));
			properties[KnownProperties.MultiBinding_Bindings] = InitProperty(KnownTypes.MultiBinding, "Bindings", assemblies[0].Find("System.Windows.Data.BindingBase", true));
			properties[KnownProperties.MultiDataTrigger_Setters] = InitProperty(KnownTypes.MultiDataTrigger, "Setters", assemblies[0].Find("System.Windows.SetterBase", true));
			properties[KnownProperties.MultiTrigger_Setters] = InitProperty(KnownTypes.MultiTrigger, "Setters", assemblies[0].Find("System.Windows.SetterBase", true));
			properties[KnownProperties.ObjectAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.ObjectAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.ObjectKeyFrame", true));
			properties[KnownProperties.PageContent_Child] = InitProperty(KnownTypes.PageContent, "Child", assemblies[0].Find("System.Windows.Documents.FixedPage", true));
			properties[KnownProperties.PageFunctionBase_Content] = InitProperty(KnownTypes.PageFunctionBase, "Content", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.Panel_Children] = InitProperty(KnownTypes.Panel, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.Paragraph_Inlines] = InitProperty(KnownTypes.Paragraph, "Inlines", assemblies[0].Find("System.Windows.Documents.Inline", true));
			properties[KnownProperties.ParallelTimeline_Children] = InitProperty(KnownTypes.ParallelTimeline, "Children", assemblies[1].Find("System.Windows.Media.Animation.Timeline", true));
			properties[KnownProperties.Point3DAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.Point3DAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.Point3DKeyFrame", true));
			properties[KnownProperties.PointAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.PointAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.PointKeyFrame", true));
			properties[KnownProperties.PriorityBinding_Bindings] = InitProperty(KnownTypes.PriorityBinding, "Bindings", assemblies[0].Find("System.Windows.Data.BindingBase", true));
			properties[KnownProperties.QuaternionAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.QuaternionAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.QuaternionKeyFrame", true));
			properties[KnownProperties.RadialGradientBrush_GradientStops] = InitProperty(KnownTypes.RadialGradientBrush, "GradientStops", assemblies[1].Find("System.Windows.Media.GradientStop", true));
			properties[KnownProperties.RadioButton_Content] = InitProperty(KnownTypes.RadioButton, "Content", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.RectAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.RectAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.RectKeyFrame", true));
			properties[KnownProperties.RepeatButton_Content] = InitProperty(KnownTypes.RepeatButton, "Content", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.RichTextBox_Document] = InitProperty(KnownTypes.RichTextBox, "Document", assemblies[0].Find("System.Windows.Documents.FlowDocument", true));
			properties[KnownProperties.Rotation3DAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.Rotation3DAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.Rotation3DKeyFrame", true));
			properties[KnownProperties.Run_Text] = InitProperty(KnownTypes.Run, "Text", assemblies[3].Find("System.Char", true));
			properties[KnownProperties.ScrollViewer_Content] = InitProperty(KnownTypes.ScrollViewer, "Content", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.Section_Blocks] = InitProperty(KnownTypes.Section, "Blocks", assemblies[0].Find("System.Windows.Documents.Block", true));
			properties[KnownProperties.Selector_Items] = InitProperty(KnownTypes.Selector, "Items", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.SingleAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.SingleAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.SingleKeyFrame", true));
			properties[KnownProperties.SizeAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.SizeAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.SizeKeyFrame", true));
			properties[KnownProperties.Span_Inlines] = InitProperty(KnownTypes.Span, "Inlines", assemblies[0].Find("System.Windows.Documents.Inline", true));
			properties[KnownProperties.StackPanel_Children] = InitProperty(KnownTypes.StackPanel, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.StatusBar_Items] = InitProperty(KnownTypes.StatusBar, "Items", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.StatusBarItem_Content] = InitProperty(KnownTypes.StatusBarItem, "Content", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.Storyboard_Children] = InitProperty(KnownTypes.Storyboard, "Children", assemblies[1].Find("System.Windows.Media.Animation.Timeline", true));
			properties[KnownProperties.StringAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.StringAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.StringKeyFrame", true));
			properties[KnownProperties.Style_Setters] = InitProperty(KnownTypes.Style, "Setters", assemblies[0].Find("System.Windows.SetterBase", true));
			properties[KnownProperties.TabControl_Items] = InitProperty(KnownTypes.TabControl, "Items", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.TabItem_Content] = InitProperty(KnownTypes.TabItem, "Content", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.TabPanel_Children] = InitProperty(KnownTypes.TabPanel, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.Table_RowGroups] = InitProperty(KnownTypes.Table, "RowGroups", assemblies[0].Find("System.Windows.Documents.TableRowGroup", true));
			properties[KnownProperties.TableCell_Blocks] = InitProperty(KnownTypes.TableCell, "Blocks", assemblies[0].Find("System.Windows.Documents.Block", true));
			properties[KnownProperties.TableRow_Cells] = InitProperty(KnownTypes.TableRow, "Cells", assemblies[0].Find("System.Windows.Documents.TableCell", true));
			properties[KnownProperties.TableRowGroup_Rows] = InitProperty(KnownTypes.TableRowGroup, "Rows", assemblies[0].Find("System.Windows.Documents.TableRow", true));
			properties[KnownProperties.TextBlock_Inlines] = InitProperty(KnownTypes.TextBlock, "Inlines", assemblies[0].Find("System.Windows.Documents.Inline", true));
			properties[KnownProperties.ThicknessAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.ThicknessAnimationUsingKeyFrames, "KeyFrames", assemblies[0].Find("System.Windows.Media.Animation.ThicknessKeyFrame", true));
			properties[KnownProperties.ToggleButton_Content] = InitProperty(KnownTypes.ToggleButton, "Content", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.ToolBar_Items] = InitProperty(KnownTypes.ToolBar, "Items", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.ToolBarOverflowPanel_Children] = InitProperty(KnownTypes.ToolBarOverflowPanel, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.ToolBarPanel_Children] = InitProperty(KnownTypes.ToolBarPanel, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.ToolBarTray_ToolBars] = InitProperty(KnownTypes.ToolBarTray, "ToolBars", assemblies[0].Find("System.Windows.Controls.ToolBar", true));
			properties[KnownProperties.ToolTip_Content] = InitProperty(KnownTypes.ToolTip, "Content", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.TreeView_Items] = InitProperty(KnownTypes.TreeView, "Items", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.TreeViewItem_Items] = InitProperty(KnownTypes.TreeViewItem, "Items", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.Trigger_Setters] = InitProperty(KnownTypes.Trigger, "Setters", assemblies[0].Find("System.Windows.SetterBase", true));
			properties[KnownProperties.Underline_Inlines] = InitProperty(KnownTypes.Underline, "Inlines", assemblies[0].Find("System.Windows.Documents.Inline", true));
			properties[KnownProperties.UniformGrid_Children] = InitProperty(KnownTypes.UniformGrid, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.UserControl_Content] = InitProperty(KnownTypes.UserControl, "Content", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.Vector3DAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.Vector3DAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.Vector3DKeyFrame", true));
			properties[KnownProperties.VectorAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.VectorAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.VectorKeyFrame", true));
			properties[KnownProperties.Viewbox_Child] = InitProperty(KnownTypes.Viewbox, "Child", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.Viewport3DVisual_Children] = InitProperty(KnownTypes.Viewport3DVisual, "Children", assemblies[1].Find("System.Windows.Media.Media3D.Visual3D", true));
			properties[KnownProperties.VirtualizingPanel_Children] = InitProperty(KnownTypes.VirtualizingPanel, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.VirtualizingStackPanel_Children] = InitProperty(KnownTypes.VirtualizingStackPanel, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.Window_Content] = InitProperty(KnownTypes.Window, "Content", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.WrapPanel_Children] = InitProperty(KnownTypes.WrapPanel, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.XmlDataProvider_XmlSerializer] = InitProperty(KnownTypes.XmlDataProvider, "XmlSerializer", assemblies[6].Find("System.Xml.Serialization.IXmlSerializable", true));
		}
	}
}


================================================
File: Confuser.Renamer/BAML/PropertyPath.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Confuser.Renamer.BAML {
	internal class PropertyPathIndexer {
		public string Type { get; set; }
		public string Value { get; set; }
	}

	internal class PropertyPathPart {
		public PropertyPathPart(bool isIndexer, bool? isHiera, string name) {
			IsIndexer = isIndexer;
			IsHierarchical = isHiera;
			Name = name;
			IndexerArguments = null;
		}

		// Property or Indexer
		public bool IsIndexer { get; set; }
		public bool? IsHierarchical { get; set; }
		public string Name { get; set; }
		public PropertyPathIndexer[] IndexerArguments { get; set; }

		public bool IsAttachedDP() {
			return !IsIndexer && Name.Length >= 2 && Name[0] == '(' && Name[Name.Length - 1] == ')';
		}

		public void ExtractAttachedDP(out string type, out string property) {
			string name = Name.Substring(1, Name.Length - 2);
			if (!name.Contains('.')) {
				// type = null means the property is on the same type
				type = null;
				property = name.Trim();
			}
			else {
				int dot = name.LastIndexOf('.');
				type = name.Substring(0, dot).Trim();
				property = name.Substring(dot + 1).Trim();
			}
		}
	}

	internal class PropertyPath {
		// See: MS.Internal.Data.PathParser

		static readonly char[] SpecialChars = {
			'.',
			'/',
			'[',
			']'
		};

		readonly PropertyPathPart[] parts;

		public PropertyPath(string path) {
			parts = Parse(path);
		}

		public PropertyPathPart[] Parts {
			get { return parts; }
		}

		static PropertyPathPart ReadIndexer(string path, ref int index, bool? isHiera) {
			index++;

			var args = new List<PropertyPathIndexer>();
			var typeString = new StringBuilder();
			var valueString = new StringBuilder();
			bool trim = false;
			int level = 0;

			const int STATE_WAIT = 0;
			const int STATE_TYPE = 1;
			const int STATE_VALUE = 2;
			const int STATE_DONE = 3;
			int state = STATE_WAIT;

			while (state != STATE_DONE) {
				char c = path[index];
				switch (state) {
					case STATE_WAIT:
						if (c == '(') {
							index++;
							state = STATE_TYPE;
						}
						else if (c == '^') {
							valueString.Append(path[++index]);
							index++;
							state = STATE_VALUE;
						}
						else if (char.IsWhiteSpace(c)) {
							index++;
						}
						else {
							valueString.Append(path[index++]);
							state = STATE_VALUE;
						}
						break;
					case STATE_TYPE:
						if (c == ')') {
							index++;
							state = STATE_VALUE;
						}
						else if (c == '^') {
							typeString.Append(path[++index]);
							index++;
						}
						else {
							typeString.Append(path[index++]);
						}
						break;
					case STATE_VALUE:
						if (c == '[') {
							valueString.Append(path[index++]);
							level++;
							trim = false;
						}
						else if (c == '^') {
							valueString.Append(path[++index]);
							index++;
							trim = false;
						}
						else if (level > 0 && c == ']') {
							level--;
							valueString.Append(path[index++]);
							trim = false;
						}
						else if (c == ']' || c == ',') {
							string value = valueString.ToString();
							// Note: it may be a WPF bug that if the value is "^  " (2 spaces after caret), all spaces will be trimmed.
							// According to http://msdn.microsoft.com/en-us/library/ms742451.aspx, the result should have one space.
							if (trim)
								value.TrimEnd();
							args.Add(new PropertyPathIndexer {
								Type = typeString.ToString(),
								Value = value
							});

							valueString.Length = 0;
							typeString.Length = 0;
							trim = false;

							index++;
							if (c == ',')
								state = STATE_WAIT;
							else
								state = STATE_DONE;
						}
						else {
							valueString.Append(path[index++]);
							if (c == ' ' && level == 0)
								trim = true;
							else
								trim = false;
						}
						break;
				}
			}

			return new PropertyPathPart(true, isHiera, "Item") {
				IndexerArguments = args.ToArray()
			};
		}

		static PropertyPathPart ReadProperty(string path, ref int index, bool? isHiera) {
			int begin = index;
			while (index < path.Length && path[index] == '.')
				index++;

			int level = 0;
			// If in brackets, read until not in bracket, ignoring special chars.
			while (index < path.Length && (level > 0 || Array.IndexOf(SpecialChars, path[index]) == -1)) {
				if (path[index] == '(')
					level++;
				else if (path[index] == ')')
					level--;

				index++;
			}

			string name = path.Substring(begin, index - begin).Trim();

			return new PropertyPathPart(false, isHiera, name);
		}

		static PropertyPathPart[] Parse(string path) {
			if (string.IsNullOrEmpty(path))
				return new[] { new PropertyPathPart(true, null, "") };

			var ret = new List<PropertyPathPart>();
			bool? isHiera = null;
			int index = 0;
			while (index < path.Length) {
				if (char.IsWhiteSpace(path[index])) {
					index++;
					continue;
				}

				char c = path[index];
				switch (c) {
					case '.':
						isHiera = false;
						index++;
						break;
					case '/':
						isHiera = true;
						index++;
						break;
					case '[':
						ret.Add(ReadIndexer(path, ref index, isHiera));
						isHiera = null;
						break;
					default:
						ret.Add(ReadProperty(path, ref index, isHiera));
						isHiera = null;
						break;
				}
			}
			return ret.ToArray();
		}

		public override string ToString() {
			var ret = new StringBuilder();
			foreach (PropertyPathPart part in parts) {
				if (part.IsHierarchical.HasValue) {
					if (part.IsHierarchical.Value)
						ret.Append("/");
					else
						ret.Append(".");
				}

				ret.Append(part.Name);

				if (part.IsIndexer) {
					PropertyPathIndexer[] args = part.IndexerArguments;
					for (int i = 0; i < args.Length; i++) {
						if (i == 0)
							ret.Append("[");
						else
							ret.Append(",");

						if (!string.IsNullOrEmpty(args[i].Type))
							ret.AppendFormat("({0})", args[i].Type);

						if (!string.IsNullOrEmpty(args[i].Value))
							foreach (char c in args[i].Value) {
								// Too lazy to write all the level detection, just be safe, and escape all special chars.
								if (c == '[' || c == ']' || c == ' ')
									ret.Append("^");
								ret.Append(c);
							}
					}
					ret.Append("]");
				}
			}
			return ret.ToString();
		}
	}
}


================================================
File: Confuser.Renamer/Properties/AssemblyInfo.cs
================================================
ï»¿using System;
using System.Reflection;

[assembly: AssemblyTitle("ConfuserEx Renamer")]
[assembly: AssemblyDescription("Renaming analysis of ConfuserEx")]


================================================
File: Confuser.Renamer/References/BAMLAttributeReference.cs
================================================
ï»¿using System;
using Confuser.Core;
using Confuser.Renamer.BAML;
using dnlib.DotNet;

namespace Confuser.Renamer.References {
	internal class BAMLAttributeReference : INameReference<IDnlibDef> {
		readonly AttributeInfoRecord attrRec;
		readonly IDnlibDef member;
		readonly PropertyRecord propRec;

		public BAMLAttributeReference(IDnlibDef member, AttributeInfoRecord rec) {
			this.member = member;
			attrRec = rec;
		}

		public BAMLAttributeReference(IDnlibDef member, PropertyRecord rec) {
			this.member = member;
			propRec = rec;
		}

		public bool UpdateNameReference(ConfuserContext context, INameService service) {
			if (attrRec != null)
				attrRec.Name = member.Name;
			else
				propRec.Value = member.Name;
			return true;
		}

		public bool ShouldCancelRename() {
			return false;
		}
	}
}


================================================
File: Confuser.Renamer/References/BAMLConverterMemberReference.cs
================================================
ï»¿using System;
using Confuser.Core;
using Confuser.Renamer.BAML;
using dnlib.DotNet;

namespace Confuser.Renamer.References {
	internal class BAMLConverterMemberReference : INameReference<IDnlibDef> {
		readonly IDnlibDef member;
		readonly PropertyRecord rec;
		readonly TypeSig sig;
		readonly BAMLAnalyzer.XmlNsContext xmlnsCtx;

		public BAMLConverterMemberReference(BAMLAnalyzer.XmlNsContext xmlnsCtx, TypeSig sig, IDnlibDef member, PropertyRecord rec) {
			this.xmlnsCtx = xmlnsCtx;
			this.sig = sig;
			this.member = member;
			this.rec = rec;
		}

		public bool UpdateNameReference(ConfuserContext context, INameService service) {
			string typeName = sig.ReflectionName;
			string prefix = xmlnsCtx.GetPrefix(sig.ReflectionNamespace, sig.ToBasicTypeDefOrRef().ResolveTypeDefThrow().Module.Assembly);
			if (!string.IsNullOrEmpty(prefix))
				typeName = prefix + ":" + typeName;
			rec.Value = typeName + "." + member.Name;
			return true;
		}

		public bool ShouldCancelRename() {
			return false;
		}
	}
}


================================================
File: Confuser.Renamer/References/BAMLConverterTypeReference.cs
================================================
ï»¿using System;
using Confuser.Core;
using Confuser.Renamer.BAML;
using dnlib.DotNet;

namespace Confuser.Renamer.References {
	internal class BAMLConverterTypeReference : INameReference<TypeDef> {
		readonly PropertyRecord propRec;
		readonly TypeSig sig;
		readonly TextRecord textRec;
		readonly BAMLAnalyzer.XmlNsContext xmlnsCtx;

		public BAMLConverterTypeReference(BAMLAnalyzer.XmlNsContext xmlnsCtx, TypeSig sig, PropertyRecord rec) {
			this.xmlnsCtx = xmlnsCtx;
			this.sig = sig;
			propRec = rec;
		}

		public BAMLConverterTypeReference(BAMLAnalyzer.XmlNsContext xmlnsCtx, TypeSig sig, TextRecord rec) {
			this.xmlnsCtx = xmlnsCtx;
			this.sig = sig;
			textRec = rec;
		}

		public bool UpdateNameReference(ConfuserContext context, INameService service) {
			string name = sig.ReflectionName;
			string prefix = xmlnsCtx.GetPrefix(sig.ReflectionNamespace, sig.ToBasicTypeDefOrRef().ResolveTypeDefThrow().Module.Assembly);
			if (!string.IsNullOrEmpty(prefix))
				name = prefix + ":" + name;
			if (propRec != null)
				propRec.Value = name;
			else
				textRec.Value = name;
			return true;
		}

		public bool ShouldCancelRename() {
			return false;
		}
	}
}


================================================
File: Confuser.Renamer/References/BAMLEnumReference.cs
================================================
ï»¿using System;
using Confuser.Core;
using Confuser.Renamer.BAML;
using dnlib.DotNet;

namespace Confuser.Renamer.References {
	internal class BAMLEnumReference : INameReference<FieldDef> {
		readonly FieldDef enumField;
		readonly PropertyRecord rec;

		public BAMLEnumReference(FieldDef enumField, PropertyRecord rec) {
			this.enumField = enumField;
			this.rec = rec;
		}

		public bool UpdateNameReference(ConfuserContext context, INameService service) {
			rec.Value = enumField.Name;
			return true;
		}

		public bool ShouldCancelRename() {
			return false;
		}
	}
}


================================================
File: Confuser.Renamer/References/BAMLPathTypeReference.cs
================================================
ï»¿using System;
using Confuser.Core;
using Confuser.Renamer.BAML;
using dnlib.DotNet;

namespace Confuser.Renamer.References {
	internal class BAMLPathTypeReference : INameReference<TypeDef> {
		readonly PropertyPathPart attachedDP;
		readonly PropertyPathIndexer indexer;
		readonly TypeSig sig;
		readonly BAMLAnalyzer.XmlNsContext xmlnsCtx;

		public BAMLPathTypeReference(BAMLAnalyzer.XmlNsContext xmlnsCtx, TypeSig sig, PropertyPathIndexer indexer) {
			this.xmlnsCtx = xmlnsCtx;
			this.sig = sig;
			this.indexer = indexer;
			attachedDP = null;
		}

		public BAMLPathTypeReference(BAMLAnalyzer.XmlNsContext xmlnsCtx, TypeSig sig, PropertyPathPart attachedDP) {
			this.xmlnsCtx = xmlnsCtx;
			this.sig = sig;
			indexer = null;
			this.attachedDP = attachedDP;
		}

		public bool UpdateNameReference(ConfuserContext context, INameService service) {
			string name = sig.ReflectionName;
			string prefix = xmlnsCtx.GetPrefix(sig.ReflectionNamespace, sig.ToBasicTypeDefOrRef().ResolveTypeDefThrow().Module.Assembly);
			if (!string.IsNullOrEmpty(prefix))
				name = prefix + ":" + name;
			if (indexer != null) {
				indexer.Type = name;
			}
			else {
				string oldType, property;
				attachedDP.ExtractAttachedDP(out oldType, out property);
				attachedDP.Name = string.Format("({0}.{1})", name, property);
			}
			return true;
		}

		public bool ShouldCancelRename() {
			return false;
		}
	}
}


================================================
File: Confuser.Renamer/References/BAMLTypeReference.cs
================================================
ï»¿using System;
using Confuser.Core;
using Confuser.Renamer.BAML;
using dnlib.DotNet;

namespace Confuser.Renamer.References {
	internal class BAMLTypeReference : INameReference<TypeDef> {
		readonly TypeInfoRecord rec;
		readonly TypeSig sig;

		public BAMLTypeReference(TypeSig sig, TypeInfoRecord rec) {
			this.sig = sig;
			this.rec = rec;
		}

		public bool UpdateNameReference(ConfuserContext context, INameService service) {
			rec.TypeFullName = sig.ReflectionFullName;
			return true;
		}

		public bool ShouldCancelRename() {
			return false;
		}
	}
}


================================================
File: Confuser.Renamer/References/CAMemberReference.cs
================================================
ï»¿using System;
using Confuser.Core;
using dnlib.DotNet;

namespace Confuser.Renamer.References {
	internal class CAMemberReference : INameReference<IDnlibDef> {
		readonly IDnlibDef definition;
		readonly CANamedArgument namedArg;

		public CAMemberReference(CANamedArgument namedArg, IDnlibDef definition) {
			this.namedArg = namedArg;
			this.definition = definition;
		}

		public bool UpdateNameReference(ConfuserContext context, INameService service) {
			namedArg.Name = definition.Name;
			return true;
		}

		public bool ShouldCancelRename() {
			return false;
		}
	}
}


================================================
File: Confuser.Renamer/References/MemberRefReference.cs
================================================
ï»¿using System;
using Confuser.Core;
using dnlib.DotNet;

namespace Confuser.Renamer.References {
	public class MemberRefReference : INameReference<IDnlibDef> {
		readonly IDnlibDef memberDef;
		readonly MemberRef memberRef;

		public MemberRefReference(MemberRef memberRef, IDnlibDef memberDef) {
			this.memberRef = memberRef;
			this.memberDef = memberDef;
		}

		public bool UpdateNameReference(ConfuserContext context, INameService service) {
			memberRef.Name = memberDef.Name;
			return true;
		}

		public bool ShouldCancelRename() {
			return false;
		}
	}
}


================================================
File: Confuser.Renamer/References/OverrideDirectiveReference.cs
================================================
ï»¿using System;
using System.Linq;
using Confuser.Core;
using dnlib.DotNet;

namespace Confuser.Renamer.References {
	internal class OverrideDirectiveReference : INameReference<MethodDef> {
		readonly VTableSlot baseSlot;
		readonly VTableSlot thisSlot;

		public OverrideDirectiveReference(VTableSlot thisSlot, VTableSlot baseSlot) {
			this.thisSlot = thisSlot;
			this.baseSlot = baseSlot;
		}

		void AddImportReference(ConfuserContext context, INameService service, ModuleDef module, MethodDef method, MemberRef methodRef) {
			if (method.Module != module && context.Modules.Contains((ModuleDefMD)method.Module)) {
				var declType = (TypeRef)methodRef.DeclaringType.ScopeType;
				service.AddReference(method.DeclaringType, new TypeRefReference(declType, method.DeclaringType));
				service.AddReference(method, new MemberRefReference(methodRef, method));

				var typeRefs = methodRef.MethodSig.Params.SelectMany(param => param.FindTypeRefs()).ToList();
				typeRefs.AddRange(methodRef.MethodSig.RetType.FindTypeRefs());
				foreach (var typeRef in typeRefs) {
					var def = typeRef.ResolveTypeDefThrow();
					if (def.Module != module && context.Modules.Contains((ModuleDefMD)def.Module))
						service.AddReference(def, new TypeRefReference((TypeRef)typeRef, def));
				}
			}
		}

		public bool UpdateNameReference(ConfuserContext context, INameService service) {
			MethodDef method = thisSlot.MethodDef;

			IMethod target;
			if (baseSlot.MethodDefDeclType is GenericInstSig) {
				var declType = (GenericInstSig)baseSlot.MethodDefDeclType;

				MemberRef targetRef = new MemberRefUser(method.Module, baseSlot.MethodDef.Name, baseSlot.MethodDef.MethodSig, declType.ToTypeDefOrRef());
				targetRef = new Importer(method.Module, ImporterOptions.TryToUseTypeDefs).Import(targetRef);
				service.AddReference(baseSlot.MethodDef, new MemberRefReference(targetRef, baseSlot.MethodDef));

				target = targetRef;
			}
			else {
				target = baseSlot.MethodDef;
				if (target.Module != method.Module) {
					target = (IMethod)new Importer(method.Module, ImporterOptions.TryToUseTypeDefs).Import(baseSlot.MethodDef);
					if (target is MemberRef)
						service.AddReference(baseSlot.MethodDef, new MemberRefReference((MemberRef)target, baseSlot.MethodDef));
				}
			}

			target.MethodSig = new Importer(method.Module, ImporterOptions.TryToUseTypeDefs).Import(method.MethodSig);
			if (target is MemberRef)
				AddImportReference(context, service, method.Module, baseSlot.MethodDef, (MemberRef)target);

			if (method.Overrides.Any(impl =>
			                         new SigComparer().Equals(impl.MethodDeclaration.MethodSig, target.MethodSig) &&
			                         new SigComparer().Equals(impl.MethodDeclaration.DeclaringType.ResolveTypeDef(), target.DeclaringType.ResolveTypeDef())))
				return true;

			method.Overrides.Add(new MethodOverride(method, (IMethodDefOrRef)target));

			return true;
		}

		public bool ShouldCancelRename() {
			return baseSlot.MethodDefDeclType is GenericInstSig && thisSlot.MethodDef.Module.IsClr20;
		}
	}
}


================================================
File: Confuser.Renamer/References/ResourceReference.cs
================================================
ï»¿using System;
using Confuser.Core;
using dnlib.DotNet;

namespace Confuser.Renamer.References {
	internal class ResourceReference : INameReference<TypeDef> {
		readonly string format;
		readonly Resource resource;
		readonly TypeDef typeDef;

		public ResourceReference(Resource resource, TypeDef typeDef, string format) {
			this.resource = resource;
			this.typeDef = typeDef;
			this.format = format;
		}

		public bool UpdateNameReference(ConfuserContext context, INameService service) {
			resource.Name = string.Format(format, typeDef.ReflectionFullName);
			return true;
		}

		public bool ShouldCancelRename() {
			return false;
		}
	}
}


================================================
File: Confuser.Renamer/References/StringTypeReference.cs
================================================
ï»¿using System;
using Confuser.Core;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Renamer.References {
	public class StringTypeReference : INameReference<TypeDef> {
		readonly Instruction reference;
		readonly TypeDef typeDef;

		public StringTypeReference(Instruction reference, TypeDef typeDef) {
			this.reference = reference;
			this.typeDef = typeDef;
		}

		public bool UpdateNameReference(ConfuserContext context, INameService service) {
			reference.Operand = typeDef.ReflectionFullName;
			return true;
		}

		public bool ShouldCancelRename() {
			return false;
		}
	}
}


================================================
File: Confuser.Renamer/References/TypeRefReference.cs
================================================
ï»¿using System;
using Confuser.Core;
using dnlib.DotNet;

namespace Confuser.Renamer.References {
	public class TypeRefReference : INameReference<TypeDef> {
		readonly TypeDef typeDef;
		readonly TypeRef typeRef;

		public TypeRefReference(TypeRef typeRef, TypeDef typeDef) {
			this.typeRef = typeRef;
			this.typeDef = typeDef;
		}

		public bool UpdateNameReference(ConfuserContext context, INameService service) {
			typeRef.Namespace = typeDef.Namespace;
			typeRef.Name = typeDef.Name;
			return true;
		}

		public bool ShouldCancelRename() {
			return false;
		}
	}
}


================================================
File: Confuser.Runtime/AntiDebug.Antinet.cs
================================================
ï»¿using System;

namespace Confuser.Runtime {
	static partial class AntiDebugAntinet {
		static void Initialize() {
			if (!InitializeAntiDebugger())
				Environment.FailFast(null);
			InitializeAntiProfiler();
			if (IsProfilerAttached) {
				Environment.FailFast(null);
				PreventActiveProfilerFromReceivingProfilingMessages();
			}
		}
	}
}


================================================
File: Confuser.Runtime/AntiDebug.Safe.cs
================================================
ï»¿using System;
using System.Diagnostics;
using System.Threading;

namespace Confuser.Runtime {
	internal static class AntiDebugSafe {
		static void Initialize() {
			string x = "COR";
			var env = typeof(Environment);
			var method = env.GetMethod("GetEnvironmentVariable", new[] { typeof(string) });
			if (method != null &&
			    "1".Equals(method.Invoke(null, new object[] { x + "_ENABLE_PROFILING" })))
				Environment.FailFast(null);

			var thread = new Thread(Worker);
			thread.IsBackground = true;
			thread.Start(null);
		}

		static void Worker(object thread) {
			var th = thread as Thread;
			if (th == null) {
				th = new Thread(Worker);
				th.IsBackground = true;
				th.Start(Thread.CurrentThread);
				Thread.Sleep(500);
			}
			while (true) {
				if (Debugger.IsAttached || Debugger.IsLogging())
					Environment.FailFast(null);

				if (!th.IsAlive)
					Environment.FailFast(null);

				Thread.Sleep(1000);
			}
		}
	}
}


================================================
File: Confuser.Runtime/AntiDebug.Win32.cs
================================================
ï»¿using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Threading;

namespace Confuser.Runtime {
	internal static class AntiDebugWin32 {
		static void Initialize() {
			string x = "COR";
			if (Environment.GetEnvironmentVariable(x + "_PROFILER") != null ||
			    Environment.GetEnvironmentVariable(x + "_ENABLE_PROFILING") != null)
				Environment.FailFast(null);

			var thread = new Thread(Worker);
			thread.IsBackground = true;
			thread.Start(null);
		}

		[DllImport("kernel32.dll")]
		static extern bool CloseHandle(IntPtr hObject);

		[DllImport("kernel32.dll")]
		static extern bool IsDebuggerPresent();

		[DllImport("kernel32.dll", CharSet = CharSet.Auto)]
		static extern int OutputDebugString(string str);

		static void Worker(object thread) {
			var th = thread as Thread;
			if (th == null) {
				th = new Thread(Worker);
				th.IsBackground = true;
				th.Start(Thread.CurrentThread);
				Thread.Sleep(500);
			}
			while (true) {
				// Managed
				if (Debugger.IsAttached || Debugger.IsLogging())
					Environment.FailFast("");

				// IsDebuggerPresent
				if (IsDebuggerPresent())
					Environment.FailFast("");

				// OpenProcess
				Process ps = Process.GetCurrentProcess();
				if (ps.Handle == IntPtr.Zero)
					Environment.FailFast("");
				ps.Close();

				// OutputDebugString
				if (OutputDebugString("") > IntPtr.Size)
					Environment.FailFast("");

				// CloseHandle
				try {
					CloseHandle(IntPtr.Zero);
				}
				catch {
					Environment.FailFast("");
				}

				if (!th.IsAlive)
					Environment.FailFast("");

				Thread.Sleep(1000);
			}
		}
	}
}



================================================
File: Confuser.Runtime/AntiDump.cs
================================================
ï»¿using System;
using System.Reflection;
using System.Runtime.InteropServices;

namespace Confuser.Runtime {
	internal static class AntiDump {
		[DllImport("kernel32.dll")]
		static extern unsafe bool VirtualProtect(byte* lpAddress, int dwSize, uint flNewProtect, out uint lpflOldProtect);

		static unsafe void Initialize() {
			uint old;
			Module module = typeof(AntiDump).Module;
			var bas = (byte*)Marshal.GetHINSTANCE(module);
			byte* ptr = bas + 0x3c;
			byte* ptr2;
			ptr = ptr2 = bas + *(uint*)ptr;
			ptr += 0x6;
			ushort sectNum = *(ushort*)ptr;
			ptr += 14;
			ushort optSize = *(ushort*)ptr;
			ptr = ptr2 = ptr + 0x4 + optSize;

			byte* @new = stackalloc byte[11];
			if (module.FullyQualifiedName[0] != '<') //Mapped
			{
				//VirtualProtect(ptr - 16, 8, 0x40, out old);
				//*(uint*)(ptr - 12) = 0;
				byte* mdDir = bas + *(uint*)(ptr - 16);
				//*(uint*)(ptr - 16) = 0;

				if (*(uint*)(ptr - 0x78) != 0) {
					byte* importDir = bas + *(uint*)(ptr - 0x78);
					byte* oftMod = bas + *(uint*)importDir;
					byte* modName = bas + *(uint*)(importDir + 12);
					byte* funcName = bas + *(uint*)oftMod + 2;
					VirtualProtect(modName, 11, 0x40, out old);

					*(uint*)@new = 0x6c64746e;
					*((uint*)@new + 1) = 0x6c642e6c;
					*((ushort*)@new + 4) = 0x006c;
					*(@new + 10) = 0;

					for (int i = 0; i < 11; i++)
						*(modName + i) = *(@new + i);

					VirtualProtect(funcName, 11, 0x40, out old);

					*(uint*)@new = 0x6f43744e;
					*((uint*)@new + 1) = 0x6e69746e;
					*((ushort*)@new + 4) = 0x6575;
					*(@new + 10) = 0;

					for (int i = 0; i < 11; i++)
						*(funcName + i) = *(@new + i);
				}

				for (int i = 0; i < sectNum; i++) {
					VirtualProtect(ptr, 8, 0x40, out old);
					Marshal.Copy(new byte[8], 0, (IntPtr)ptr, 8);
					ptr += 0x28;
				}
				VirtualProtect(mdDir, 0x48, 0x40, out old);
				byte* mdHdr = bas + *(uint*)(mdDir + 8);
				*(uint*)mdDir = 0;
				*((uint*)mdDir + 1) = 0;
				*((uint*)mdDir + 2) = 0;
				*((uint*)mdDir + 3) = 0;

				VirtualProtect(mdHdr, 4, 0x40, out old);
				*(uint*)mdHdr = 0;
				mdHdr += 12;
				mdHdr += *(uint*)mdHdr;
				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);
				mdHdr += 2;
				ushort numOfStream = *mdHdr;
				mdHdr += 2;
				for (int i = 0; i < numOfStream; i++) {
					VirtualProtect(mdHdr, 8, 0x40, out old);
					//*(uint*)mdHdr = 0;
					mdHdr += 4;
					//*(uint*)mdHdr = 0;
					mdHdr += 4;
					for (int ii = 0; ii < 8; ii++) {
						VirtualProtect(mdHdr, 4, 0x40, out old);
						*mdHdr = 0;
						mdHdr++;
						if (*mdHdr == 0) {
							mdHdr += 3;
							break;
						}
						*mdHdr = 0;
						mdHdr++;
						if (*mdHdr == 0) {
							mdHdr += 2;
							break;
						}
						*mdHdr = 0;
						mdHdr++;
						if (*mdHdr == 0) {
							mdHdr += 1;
							break;
						}
						*mdHdr = 0;
						mdHdr++;
					}
				}
			}
			else //Flat
			{
				//VirtualProtect(ptr - 16, 8, 0x40, out old);
				//*(uint*)(ptr - 12) = 0;
				uint mdDir = *(uint*)(ptr - 16);
				//*(uint*)(ptr - 16) = 0;
				uint importDir = *(uint*)(ptr - 0x78);

				var vAdrs = new uint[sectNum];
				var vSizes = new uint[sectNum];
				var rAdrs = new uint[sectNum];
				for (int i = 0; i < sectNum; i++) {
					VirtualProtect(ptr, 8, 0x40, out old);
					Marshal.Copy(new byte[8], 0, (IntPtr)ptr, 8);
					vAdrs[i] = *(uint*)(ptr + 12);
					vSizes[i] = *(uint*)(ptr + 8);
					rAdrs[i] = *(uint*)(ptr + 20);
					ptr += 0x28;
				}


				if (importDir != 0) {
					for (int i = 0; i < sectNum; i++)
						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {
							importDir = importDir - vAdrs[i] + rAdrs[i];
							break;
						}
					byte* importDirPtr = bas + importDir;
					uint oftMod = *(uint*)importDirPtr;
					for (int i = 0; i < sectNum; i++)
						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {
							oftMod = oftMod - vAdrs[i] + rAdrs[i];
							break;
						}
					byte* oftModPtr = bas + oftMod;
					uint modName = *(uint*)(importDirPtr + 12);
					for (int i = 0; i < sectNum; i++)
						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {
							modName = modName - vAdrs[i] + rAdrs[i];
							break;
						}
					uint funcName = *(uint*)oftModPtr + 2;
					for (int i = 0; i < sectNum; i++)
						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {
							funcName = funcName - vAdrs[i] + rAdrs[i];
							break;
						}
					VirtualProtect(bas + modName, 11, 0x40, out old);

					*(uint*)@new = 0x6c64746e;
					*((uint*)@new + 1) = 0x6c642e6c;
					*((ushort*)@new + 4) = 0x006c;
					*(@new + 10) = 0;

					for (int i = 0; i < 11; i++)
						*(bas + modName + i) = *(@new + i);

					VirtualProtect(bas + funcName, 11, 0x40, out old);

					*(uint*)@new = 0x6f43744e;
					*((uint*)@new + 1) = 0x6e69746e;
					*((ushort*)@new + 4) = 0x6575;
					*(@new + 10) = 0;

					for (int i = 0; i < 11; i++)
						*(bas + funcName + i) = *(@new + i);
				}


				for (int i = 0; i < sectNum; i++)
					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {
						mdDir = mdDir - vAdrs[i] + rAdrs[i];
						break;
					}
				byte* mdDirPtr = bas + mdDir;
				VirtualProtect(mdDirPtr, 0x48, 0x40, out old);
				uint mdHdr = *(uint*)(mdDirPtr + 8);
				for (int i = 0; i < sectNum; i++)
					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {
						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];
						break;
					}
				*(uint*)mdDirPtr = 0;
				*((uint*)mdDirPtr + 1) = 0;
				*((uint*)mdDirPtr + 2) = 0;
				*((uint*)mdDirPtr + 3) = 0;


				byte* mdHdrPtr = bas + mdHdr;
				VirtualProtect(mdHdrPtr, 4, 0x40, out old);
				*(uint*)mdHdrPtr = 0;
				mdHdrPtr += 12;
				mdHdrPtr += *(uint*)mdHdrPtr;
				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);
				mdHdrPtr += 2;
				ushort numOfStream = *mdHdrPtr;
				mdHdrPtr += 2;
				for (int i = 0; i < numOfStream; i++) {
					VirtualProtect(mdHdrPtr, 8, 0x40, out old);
					//*(uint*)mdHdrPtr = 0;
					mdHdrPtr += 4;
					//*(uint*)mdHdrPtr = 0;
					mdHdrPtr += 4;
					for (int ii = 0; ii < 8; ii++) {
						VirtualProtect(mdHdrPtr, 4, 0x40, out old);
						*mdHdrPtr = 0;
						mdHdrPtr++;
						if (*mdHdrPtr == 0) {
							mdHdrPtr += 3;
							break;
						}
						*mdHdrPtr = 0;
						mdHdrPtr++;
						if (*mdHdrPtr == 0) {
							mdHdrPtr += 2;
							break;
						}
						*mdHdrPtr = 0;
						mdHdrPtr++;
						if (*mdHdrPtr == 0) {
							mdHdrPtr += 1;
							break;
						}
						*mdHdrPtr = 0;
						mdHdrPtr++;
					}
				}
			}
		}
	}
}


================================================
File: Confuser.Runtime/AntiTamper.JIT.cs
================================================
ï»¿using System;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace Confuser.Runtime {
	internal static unsafe class AntiTamperJIT {
		static uint* ptr;
		static uint len;
		static IntPtr moduleHnd;
		static compileMethod originalDelegate;

		static bool ver4;
		static bool ver5;

		static compileMethod handler;

		public static void Initialize() {
			Module m = typeof(AntiTamperNormal).Module;
			string n = m.FullyQualifiedName;
			bool f = n.Length > 0 && n[0] == '<';
			var b = (byte*)Marshal.GetHINSTANCE(m);
			byte* p = b + *(uint*)(b + 0x3c);
			ushort s = *(ushort*)(p + 0x6);
			ushort o = *(ushort*)(p + 0x14);

			uint* e = null;
			uint l = 0;
			var r = (uint*)(p + 0x18 + o);
			uint z = (uint)Mutation.KeyI1, x = (uint)Mutation.KeyI2, c = (uint)Mutation.KeyI3, v = (uint)Mutation.KeyI4;
			for (int i = 0; i < s; i++) {
				uint g = (*r++) * (*r++);
				if (g == (uint)Mutation.KeyI0) {
					e = (uint*)(b + (f ? *(r + 3) : *(r + 1)));
					l = (f ? *(r + 2) : *(r + 0)) >> 2;
				}
				else if (g != 0) {
					var q = (uint*)(b + (f ? *(r + 3) : *(r + 1)));
					uint j = *(r + 2) >> 2;
					for (uint k = 0; k < j; k++) {
						uint t = (z ^ (*q++)) + x + c * v;
						z = x;
						x = c;
						x = v;
						v = t;
					}
				}
				r += 8;
			}

			uint[] y = new uint[0x10], d = new uint[0x10];
			for (int i = 0; i < 0x10; i++) {
				y[i] = v;
				d[i] = x;
				z = (x >> 5) | (x << 27);
				x = (c >> 3) | (c << 29);
				c = (v >> 7) | (v << 25);
				v = (z >> 11) | (z << 21);
			}
			Mutation.Crypt(y, d);

			uint h = 0;
			uint* u = e;
			VirtualProtect((IntPtr)e, l << 2, 0x40, out z);
			for (uint i = 0; i < l; i++) {
				*e ^= y[h & 0xf];
				y[h & 0xf] = (y[h & 0xf] ^ (*e++)) + 0x3dbb2819;
				h++;
			}

			ptr = u + 4;
			len = *ptr++;

			ver4 = Environment.Version.Major == 4;
			ModuleHandle hnd = m.ModuleHandle;
			if (ver4) {
				ulong* str = stackalloc ulong[1];
				str[0] = 0x0061746144705f6d; //m_pData.
				moduleHnd = (IntPtr)m.GetType().GetField(new string((sbyte*)str), BindingFlags.NonPublic | BindingFlags.Instance).GetValue(m);
				ver5 = Environment.Version.Revision > 17020;
			}
			else
				moduleHnd = *(IntPtr*)(&hnd);

			Hook();
		}

		[DllImport("kernel32.dll")]
		static extern IntPtr LoadLibrary(string lib);

		[DllImport("kernel32.dll")]
		static extern IntPtr GetProcAddress(IntPtr lib, string proc);

		[DllImport("kernel32.dll")]
		static extern bool VirtualProtect(IntPtr lpAddress, uint dwSize, uint flNewProtect, out uint lpflOldProtect);

		static void Hook() {
			ulong* ptr = stackalloc ulong[2];
			if (ver4) {
				ptr[0] = 0x642e74696a726c63; //clrjit.d
				ptr[1] = 0x0000000000006c6c; //ll......
			}
			else {
				ptr[0] = 0x74696a726f63736d; //mscorjit
				ptr[1] = 0x000000006c6c642e; //.dll....
			}
			IntPtr jit = LoadLibrary(new string((sbyte*)ptr));
			ptr[0] = 0x000074694a746567; //getJit
			var get = (getJit)Marshal.GetDelegateForFunctionPointer(GetProcAddress(jit, new string((sbyte*)ptr)), typeof(getJit));
			IntPtr hookPosition = *get();
			IntPtr original = *(IntPtr*)hookPosition;

			IntPtr trampoline;
			uint oldPl;
			if (IntPtr.Size == 8) {
				trampoline = Marshal.AllocHGlobal(16);
				var tptr = (ulong*)trampoline;
				tptr[0] = 0xffffffffffffb848;
				tptr[1] = 0x90909090e0ffffff;

				VirtualProtect(trampoline, 12, 0x40, out oldPl);
				Marshal.WriteIntPtr(trampoline, 2, original);
			}
			else {
				trampoline = Marshal.AllocHGlobal(8);
				var tptr = (ulong*)trampoline;
				tptr[0] = 0x90e0ffffffffffb8;

				VirtualProtect(trampoline, 7, 0x40, out oldPl);
				Marshal.WriteIntPtr(trampoline, 1, original);
			}

			originalDelegate = (compileMethod)Marshal.GetDelegateForFunctionPointer(trampoline, typeof(compileMethod));
			handler = HookHandler;

			RuntimeHelpers.PrepareDelegate(originalDelegate);
			RuntimeHelpers.PrepareDelegate(handler);

			VirtualProtect(hookPosition, (uint)IntPtr.Size, 0x40, out oldPl);
			Marshal.WriteIntPtr(hookPosition, Marshal.GetFunctionPointerForDelegate(handler));
			VirtualProtect(hookPosition, (uint)IntPtr.Size, oldPl, out oldPl);
		}

		static void ExtractLocalVars(CORINFO_METHOD_INFO* info, uint len, byte* localVar) {
			void* sigInfo;
			if (ver4) {
				if (IntPtr.Size == 8)
					sigInfo = (CORINFO_SIG_INFO_x64*)((uint*)(info + 1) + (ver5 ? 7 : 5)) + 1;
				else
					sigInfo = (CORINFO_SIG_INFO_x86*)((uint*)(info + 1) + (ver5 ? 5 : 4)) + 1;
			}
			else {
				if (IntPtr.Size == 8)
					sigInfo = (CORINFO_SIG_INFO_x64*)((uint*)(info + 1) + 3) + 1;
				else
					sigInfo = (CORINFO_SIG_INFO_x86*)((uint*)(info + 1) + 3) + 1;
			}

			if (IntPtr.Size == 8)
				((CORINFO_SIG_INFO_x64*)sigInfo)->sig = (IntPtr)localVar;
			else
				((CORINFO_SIG_INFO_x86*)sigInfo)->sig = (IntPtr)localVar;
			localVar++;
			byte b = *localVar;
			ushort numArgs;
			IntPtr args;
			if ((b & 0x80) == 0) {
				numArgs = b;
				args = (IntPtr)(localVar + 1);
			}
			else {
				numArgs = (ushort)(((uint)(b & ~0x80) << 8) | *(localVar + 1));
				args = (IntPtr)(localVar + 2);
			}

			if (IntPtr.Size == 8) {
				var sigInfox64 = (CORINFO_SIG_INFO_x64*)sigInfo;
				sigInfox64->callConv = 0;
				sigInfox64->retType = 1;
				sigInfox64->flags = 1;
				sigInfox64->numArgs = numArgs;
				sigInfox64->args = args;
			}
			else {
				var sigInfox86 = (CORINFO_SIG_INFO_x86*)sigInfo;
				sigInfox86->callConv = 0;
				sigInfox86->retType = 1;
				sigInfox86->flags = 1;
				sigInfox86->numArgs = numArgs;
				sigInfox86->args = args;
			}
		}

		static uint HookHandler(IntPtr self, ICorJitInfo* comp, CORINFO_METHOD_INFO* info, uint flags, byte** nativeEntry, uint* nativeSizeOfCode) {
			if (info != null && info->scope == moduleHnd && info->ILCode[0] == 0x14) {
				uint token;
				if (ver5) {
					var getMethodDef = (getMethodDefFromMethod)Marshal.GetDelegateForFunctionPointer(comp->vfptr[0x64], typeof(getMethodDefFromMethod));
					token = getMethodDef((IntPtr)comp, info->ftn);
				}
				else {
					ICorClassInfo* clsInfo = ICorStaticInfo.ICorClassInfo(ICorDynamicInfo.ICorStaticInfo(ICorJitInfo.ICorDynamicInfo(comp)));
					int gmdSlot = 12 + (ver4 ? 2 : 1);
					var getMethodDef = (getMethodDefFromMethod)Marshal.GetDelegateForFunctionPointer(clsInfo->vfptr[gmdSlot], typeof(getMethodDefFromMethod));
					token = getMethodDef((IntPtr)clsInfo, info->ftn);
				}

				uint lo = 0, hi = len;
				uint? offset = null;
				while (hi >= lo) {
					uint mid = lo + ((hi - lo) >> 1);
					uint midTok = *(ptr + (mid << 1));
					if (midTok == token) {
						offset = *(ptr + (mid << 1) + 1);
						break;
					}
					if (midTok < token)
						lo = mid + 1;
					else
						hi = mid - 1;
				}
				if (offset == null)
					return originalDelegate(self, comp, info, flags, nativeEntry, nativeSizeOfCode);

				uint* dataPtr = ptr + (uint)offset;
				uint dataLen = *dataPtr++;
				var newPtr = (uint*)Marshal.AllocHGlobal((int)dataLen << 2);
				try {
					var data = (MethodData*)newPtr;
					uint* copyData = newPtr;

					uint state = token * (uint)Mutation.KeyI0;
					uint counter = state;
					for (uint i = 0; i < dataLen; i++) {
						*copyData = *dataPtr++ ^ state;
						state += (*copyData++) ^ counter;
						counter ^= (state >> 5) | (state << 27);
					}

					info->ILCodeSize = data->ILCodeSize;
					if (ver4) {
						*((uint*)(info + 1) + 0) = data->MaxStack;
						*((uint*)(info + 1) + 1) = data->EHCount;
						*((uint*)(info + 1) + 2) = data->Options;
					}
					else {
						*((ushort*)(info + 1) + 0) = (ushort)data->MaxStack;
						*((ushort*)(info + 1) + 1) = (ushort)data->EHCount;
						*((uint*)(info + 1) + 1) = data->Options;
					}

					var body = (byte*)(data + 1);

					info->ILCode = body;
					body += info->ILCodeSize;

					if (data->LocalVars != 0) {
						ExtractLocalVars(info, data->LocalVars, body);
						body += data->LocalVars;
					}

					var ehPtr = (CORINFO_EH_CLAUSE*)body;

					uint ret;
					if (ver5) {
						CorJitInfoHook hook = CorJitInfoHook.Hook(comp, info->ftn, ehPtr);
						ret = originalDelegate(self, comp, info, flags, nativeEntry, nativeSizeOfCode);
						hook.Dispose();
					}
					else {
						CorMethodInfoHook hook = CorMethodInfoHook.Hook(comp, info->ftn, ehPtr);
						ret = originalDelegate(self, comp, info, flags, nativeEntry, nativeSizeOfCode);
						hook.Dispose();
					}

					return ret;
				}
				finally {
					Marshal.FreeHGlobal((IntPtr)newPtr);
				}
			}
			return originalDelegate(self, comp, info, flags, nativeEntry, nativeSizeOfCode);
		}

		#region JIT internal

		static bool hasLinkInfo;

		[StructLayout(LayoutKind.Sequential, Size = 0x18)]
		struct CORINFO_EH_CLAUSE { }

		[StructLayout(LayoutKind.Sequential, Pack = 1)]
		struct CORINFO_METHOD_INFO {
			public IntPtr ftn;
			public IntPtr scope;
			public byte* ILCode;
			public uint ILCodeSize;
		}

		[StructLayout(LayoutKind.Sequential)]
		struct CORINFO_SIG_INFO_x64 {
			public uint callConv;
			uint pad1;
			public IntPtr retTypeClass;
			public IntPtr retTypeSigClass;
			public byte retType;
			public byte flags;
			public ushort numArgs;
			uint pad2;
			public CORINFO_SIG_INST_x64 sigInst;
			public IntPtr args;
			public IntPtr sig;
			public IntPtr scope;
			public uint token;
			uint pad3;
		}

		[StructLayout(LayoutKind.Sequential)]
		struct CORINFO_SIG_INFO_x86 {
			public uint callConv;
			public IntPtr retTypeClass;
			public IntPtr retTypeSigClass;
			public byte retType;
			public byte flags;
			public ushort numArgs;
			public CORINFO_SIG_INST_x86 sigInst;
			public IntPtr args;
			public IntPtr sig;
			public IntPtr scope;
			public uint token;
		}

		[StructLayout(LayoutKind.Sequential, Size = 32)]
		struct CORINFO_SIG_INST_x64 { }

		[StructLayout(LayoutKind.Sequential, Size = 16)]
		struct CORINFO_SIG_INST_x86 { }

		[StructLayout(LayoutKind.Sequential)]
		struct ICorClassInfo {
			public readonly IntPtr* vfptr;
		}

		[StructLayout(LayoutKind.Sequential)]
		struct ICorDynamicInfo {
			public IntPtr* vfptr;
			public int* vbptr;

			public static ICorStaticInfo* ICorStaticInfo(ICorDynamicInfo* ptr) {
				return (ICorStaticInfo*)((byte*)&ptr->vbptr + ptr->vbptr[hasLinkInfo ? 9 : 8]);
			}
		}

		[StructLayout(LayoutKind.Sequential)]
		struct ICorJitInfo {
			public IntPtr* vfptr;
			public int* vbptr;

			public static ICorDynamicInfo* ICorDynamicInfo(ICorJitInfo* ptr) {
				hasLinkInfo = ptr->vbptr[10] > 0 && ptr->vbptr[10] >> 16 == 0; // != 0 and hiword byte == 0
				return (ICorDynamicInfo*)((byte*)&ptr->vbptr + ptr->vbptr[hasLinkInfo ? 10 : 9]);
			}
		}

		[StructLayout(LayoutKind.Sequential)]
		struct ICorMethodInfo {
			public IntPtr* vfptr;
		}

		[StructLayout(LayoutKind.Sequential)]
		struct ICorModuleInfo {
			public IntPtr* vfptr;
		}

		[StructLayout(LayoutKind.Sequential)]
		struct ICorStaticInfo {
			public IntPtr* vfptr;
			public int* vbptr;

			public static ICorMethodInfo* ICorMethodInfo(ICorStaticInfo* ptr) {
				return (ICorMethodInfo*)((byte*)&ptr->vbptr + ptr->vbptr[1]);
			}

			public static ICorModuleInfo* ICorModuleInfo(ICorStaticInfo* ptr) {
				return (ICorModuleInfo*)((byte*)&ptr->vbptr + ptr->vbptr[2]);
			}

			public static ICorClassInfo* ICorClassInfo(ICorStaticInfo* ptr) {
				return (ICorClassInfo*)((byte*)&ptr->vbptr + ptr->vbptr[3]);
			}
		}

		#endregion

		class CorMethodInfoHook {
			static int ehNum = -1;
			public CORINFO_EH_CLAUSE* clauses;
			public IntPtr ftn;
			public ICorMethodInfo* info;
			public getEHinfo n_getEHinfo;
			public IntPtr* newVfTbl;

			public getEHinfo o_getEHinfo;
			public IntPtr* oldVfTbl;

			void hookEHInfo(IntPtr self, IntPtr ftn, uint EHnumber, CORINFO_EH_CLAUSE* clause) {
				if (ftn == this.ftn) {
					*clause = clauses[EHnumber];
				}
				else {
					o_getEHinfo(self, ftn, EHnumber, clause);
				}
			}

			public void Dispose() {
				Marshal.FreeHGlobal((IntPtr)newVfTbl);
				info->vfptr = oldVfTbl;
			}

			public static CorMethodInfoHook Hook(ICorJitInfo* comp, IntPtr ftn, CORINFO_EH_CLAUSE* clauses) {
				ICorMethodInfo* mtdInfo = ICorStaticInfo.ICorMethodInfo(ICorDynamicInfo.ICorStaticInfo(ICorJitInfo.ICorDynamicInfo(comp)));
				IntPtr* vfTbl = mtdInfo->vfptr;
				const int SLOT_NUM = 0x1B;
				var newVfTbl = (IntPtr*)Marshal.AllocHGlobal(SLOT_NUM * IntPtr.Size);
				for (int i = 0; i < SLOT_NUM; i++)
					newVfTbl[i] = vfTbl[i];
				if (ehNum == -1)
					for (int i = 0; i < SLOT_NUM; i++) {
						bool isEh = true;
						for (var func = (byte*)vfTbl[i]; *func != 0xe9; func++)
							if (IntPtr.Size == 8 ?
								    (*func == 0x48 && *(func + 1) == 0x81 && *(func + 2) == 0xe9) :
								    (*func == 0x83 && *(func + 1) == 0xe9)) {
								isEh = false;
								break;
							}
						if (isEh) {
							ehNum = i;
							break;
						}
					}

				var ret = new CorMethodInfoHook {
					ftn = ftn,
					info = mtdInfo,
					clauses = clauses,
					newVfTbl = newVfTbl,
					oldVfTbl = vfTbl
				};

				ret.n_getEHinfo = ret.hookEHInfo;
				ret.o_getEHinfo = (getEHinfo)Marshal.GetDelegateForFunctionPointer(vfTbl[ehNum], typeof(getEHinfo));
				newVfTbl[ehNum] = Marshal.GetFunctionPointerForDelegate(ret.n_getEHinfo);

				mtdInfo->vfptr = newVfTbl;
				return ret;
			}
		}

		class CorJitInfoHook {
			public CORINFO_EH_CLAUSE* clauses;
			public IntPtr ftn;
			public ICorJitInfo* info;
			public getEHinfo n_getEHinfo;
			public IntPtr* newVfTbl;

			public getEHinfo o_getEHinfo;
			public IntPtr* oldVfTbl;

			void hookEHInfo(IntPtr self, IntPtr ftn, uint EHnumber, CORINFO_EH_CLAUSE* clause) {
				if (ftn == this.ftn) {
					*clause = clauses[EHnumber];
				}
				else {
					o_getEHinfo(self, ftn, EHnumber, clause);
				}
			}

			public void Dispose() {
				Marshal.FreeHGlobal((IntPtr)newVfTbl);
				info->vfptr = oldVfTbl;
			}

			public static CorJitInfoHook Hook(ICorJitInfo* comp, IntPtr ftn, CORINFO_EH_CLAUSE* clauses) {
				const int slotNum = 8;

				IntPtr* vfTbl = comp->vfptr;
				const int SLOT_NUM = 0x9E;
				var newVfTbl = (IntPtr*)Marshal.AllocHGlobal(SLOT_NUM * IntPtr.Size);
				for (int i = 0; i < SLOT_NUM; i++)
					newVfTbl[i] = vfTbl[i];

				var ret = new CorJitInfoHook {
					ftn = ftn,
					info = comp,
					clauses = clauses,
					newVfTbl = newVfTbl,
					oldVfTbl = vfTbl
				};

				ret.n_getEHinfo = ret.hookEHInfo;
				ret.o_getEHinfo = (getEHinfo)Marshal.GetDelegateForFunctionPointer(vfTbl[slotNum], typeof(getEHinfo));
				newVfTbl[slotNum] = Marshal.GetFunctionPointerForDelegate(ret.n_getEHinfo);

				comp->vfptr = newVfTbl;
				return ret;
			}
		}

		[StructLayout(LayoutKind.Sequential)]
		struct MethodData {
			public readonly uint ILCodeSize;
			public readonly uint MaxStack;
			public readonly uint EHCount;
			public readonly uint LocalVars;
			public readonly uint Options;
			public readonly uint MulSeed;
		}

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		delegate uint compileMethod(IntPtr self, ICorJitInfo* comp, CORINFO_METHOD_INFO* info, uint flags, byte** nativeEntry, uint* nativeSizeOfCode);

		[UnmanagedFunctionPointer(CallingConvention.ThisCall)]
		delegate void getEHinfo(IntPtr self, IntPtr ftn, uint EHnumber, CORINFO_EH_CLAUSE* clause);

		delegate IntPtr* getJit();

		[UnmanagedFunctionPointer(CallingConvention.ThisCall)]
		delegate uint getMethodDefFromMethod(IntPtr self, IntPtr ftn);
	}
}


================================================
File: Confuser.Runtime/AntiTamper.Normal.cs
================================================
ï»¿using System;
using System.Reflection;
using System.Runtime.InteropServices;

namespace Confuser.Runtime {
	internal static class AntiTamperNormal {
		[DllImport("kernel32.dll")]
		static extern bool VirtualProtect(IntPtr lpAddress, uint dwSize, uint flNewProtect, out uint lpflOldProtect);

		static unsafe void Initialize() {
			Module m = typeof(AntiTamperNormal).Module;
			string n = m.FullyQualifiedName;
			bool f = n.Length > 0 && n[0] == '<';
			var b = (byte*)Marshal.GetHINSTANCE(m);
			byte* p = b + *(uint*)(b + 0x3c);
			ushort s = *(ushort*)(p + 0x6);
			ushort o = *(ushort*)(p + 0x14);

			uint* e = null;
			uint l = 0;
			var r = (uint*)(p + 0x18 + o);
			uint z = (uint)Mutation.KeyI1, x = (uint)Mutation.KeyI2, c = (uint)Mutation.KeyI3, v = (uint)Mutation.KeyI4;
			for (int i = 0; i < s; i++) {
				uint g = (*r++) * (*r++);
				if (g == (uint)Mutation.KeyI0) {
					e = (uint*)(b + (f ? *(r + 3) : *(r + 1)));
					l = (f ? *(r + 2) : *(r + 0)) >> 2;
				}
				else if (g != 0) {
					var q = (uint*)(b + (f ? *(r + 3) : *(r + 1)));
					uint j = *(r + 2) >> 2;
					for (uint k = 0; k < j; k++) {
						uint t = (z ^ (*q++)) + x + c * v;
						z = x;
						x = c;
						x = v;
						v = t;
					}
				}
				r += 8;
			}

			uint[] y = new uint[0x10], d = new uint[0x10];
			for (int i = 0; i < 0x10; i++) {
				y[i] = v;
				d[i] = x;
				z = (x >> 5) | (x << 27);
				x = (c >> 3) | (c << 29);
				c = (v >> 7) | (v << 25);
				v = (z >> 11) | (z << 21);
			}
			Mutation.Crypt(y, d);

			uint w = 0x40;
			VirtualProtect((IntPtr)e, l << 2, w, out w);

			if (w == 0x40)
				return;

			uint h = 0;
			for (uint i = 0; i < l; i++) {
				*e ^= y[h & 0xf];
				y[h & 0xf] = (y[h & 0xf] ^ (*e++)) + 0x3dbb2819;
				h++;
			}
		}
	}
}


================================================
File: Confuser.Runtime/Compressor.Compat.cs
================================================
ï»¿using System;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;

namespace Confuser.Runtime {
	internal static class CompressorCompat {
		static byte[] key;

		static GCHandle Decrypt(uint[] data, uint seed) {
			var w = new uint[0x10];
			var k = new uint[0x10];
			ulong s = seed;
			for (int i = 0; i < 0x10; i++) {
				s = (s * s) % 0x143fc089;
				k[i] = (uint)s;
				w[i] = (uint)((s * s) % 0x444d56fb);
			}
			Mutation.Crypt(w, k);
			Array.Clear(k, 0, 0x10);

			var b = new byte[data.Length << 2];
			uint h = 0;
			for (int i = 0; i < data.Length; i++) {
				uint d = data[i] ^ w[i & 0xf];
				w[i & 0xf] = (w[i & 0xf] ^ d) + 0x3ddb2819;
				b[h + 0] = (byte)(d >> 0);
				b[h + 1] = (byte)(d >> 8);
				b[h + 2] = (byte)(d >> 16);
				b[h + 3] = (byte)(d >> 24);
				h += 4;
			}
			Array.Clear(w, 0, 0x10);
			byte[] j = Lzma.Decompress(b);
			Array.Clear(b, 0, b.Length);

			GCHandle g = GCHandle.Alloc(j, GCHandleType.Pinned);
			var z = (uint)(s % 0x8a5cb7);
			for (int i = 0; i < j.Length; i++) {
				j[i] ^= (byte)s;
				if ((i & 0xff) == 0)
					s = (s * s) % 0x8a5cb7;
			}
			return g;
		}

		[STAThread]
		static int Main(string[] args) {
			var l = (uint)Mutation.KeyI0;
			uint[] q = Mutation.Placeholder(new uint[Mutation.KeyI0]);

			GCHandle h = Decrypt(q, (uint)Mutation.KeyI1);
			var b = (byte[])h.Target;
			Assembly a = Assembly.Load(b);
			Array.Clear(b, 0, b.Length);
			h.Free();
			Array.Clear(q, 0, q.Length);

			var m = typeof(CompressorCompat).Module;
			key = m.ResolveSignature(Mutation.KeyI2);
			AppDomain.CurrentDomain.AssemblyResolve += Resolve;

			MethodBase e = a.ManifestModule.ResolveMethod(key[0] | (key[1] << 8) | (key[2] << 16) | (key[3] << 24));
			var g = new object[e.GetParameters().Length];
			if (g.Length != 0)
				g[0] = args;
			object r = e.Invoke(null, g);
			if (r is int)
				return (int)r;
			return 0;
		}

		static Assembly Resolve(object sender, ResolveEventArgs e) {
			byte[] b = Encoding.UTF8.GetBytes(new AssemblyName(e.Name).FullName.ToUpperInvariant());

			Stream m = null;
			if (b.Length + 4 <= key.Length) {
				for (int i = 0; i < b.Length; i++)
					b[i] *= key[i + 4];
				string n = Convert.ToBase64String(b);
				m = Assembly.GetEntryAssembly().GetManifestResourceStream(n);
			}
			if (m != null) {
				var d = new uint[m.Length >> 2];
				var t = new byte[0x100];
				int r;
				int o = 0;
				while ((r = m.Read(t, 0, 0x100)) > 0) {
					Buffer.BlockCopy(t, 0, d, o, r);
					o += r;
				}
				uint s = 0x6fff61;
				foreach (byte c in b)
					s = s * 0x5e3f1f + c;
				GCHandle h = Decrypt(d, s);

				var f = (byte[])h.Target;
				Assembly a = Assembly.Load(f);
				Array.Clear(f, 0, f.Length);
				h.Free();
				Array.Clear(d, 0, d.Length);

				return a;
			}
			return null;
		}
	}
}


================================================
File: Confuser.Runtime/Compressor.cs
================================================
ï»¿using System;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;

namespace Confuser.Runtime {
	internal static class Compressor {
		static byte[] key;

		static GCHandle Decrypt(uint[] data, uint seed) {
			var w = new uint[0x10];
			var k = new uint[0x10];
			ulong s = seed;
			for (int i = 0; i < 0x10; i++) {
				s = (s * s) % 0x143fc089;
				k[i] = (uint)s;
				w[i] = (uint)((s * s) % 0x444d56fb);
			}
			Mutation.Crypt(w, k);
			Array.Clear(k, 0, 0x10);

			var b = new byte[data.Length << 2];
			uint h = 0;
			for (int i = 0; i < data.Length; i++) {
				uint d = data[i] ^ w[i & 0xf];
				w[i & 0xf] = (w[i & 0xf] ^ d) + 0x3ddb2819;
				b[h + 0] = (byte)(d >> 0);
				b[h + 1] = (byte)(d >> 8);
				b[h + 2] = (byte)(d >> 16);
				b[h + 3] = (byte)(d >> 24);
				h += 4;
			}
			Array.Clear(w, 0, 0x10);
			byte[] j = Lzma.Decompress(b);
			Array.Clear(b, 0, b.Length);

			GCHandle g = GCHandle.Alloc(j, GCHandleType.Pinned);
			var z = (uint)(s % 0x8a5cb7);
			for (int i = 0; i < j.Length; i++) {
				j[i] ^= (byte)s;
				if ((i & 0xff) == 0)
					s = (s * s) % 0x8a5cb7;
			}
			return g;
		}

		[STAThread]
		static int Main(string[] args) {
			var l = (uint)Mutation.KeyI0;
			uint[] q = Mutation.Placeholder(new uint[Mutation.KeyI0]);

			Assembly a = Assembly.GetExecutingAssembly();
			Module n = a.ManifestModule;
			GCHandle h = Decrypt(q, (uint)Mutation.KeyI1);
			var b = (byte[])h.Target;
			Module m = a.LoadModule("koi", b);
			Array.Clear(b, 0, b.Length);
			h.Free();
			Array.Clear(q, 0, q.Length);

			key = n.ResolveSignature(Mutation.KeyI2);
			AppDomain.CurrentDomain.AssemblyResolve += Resolve;

			// For some reasons, reflection on Assembly would not discover the types unless GetTypes is called.
			m.GetTypes();

			MethodBase e = m.ResolveMethod(key[0] | (key[1] << 8) | (key[2] << 16) | (key[3] << 24));
			var g = new object[e.GetParameters().Length];
			if (g.Length != 0)
				g[0] = args;
			object r = e.Invoke(null, g);
			if (r is int)
				return (int)r;
			return 0;
		}

		static Assembly Resolve(object sender, ResolveEventArgs e) {
			byte[] b = Encoding.UTF8.GetBytes(new AssemblyName(e.Name).FullName.ToUpperInvariant());

			Stream m = null;
			if (b.Length + 4 <= key.Length) {
				for (int i = 0; i < b.Length; i++)
					b[i] *= key[i + 4];
				string n = Convert.ToBase64String(b);
				m = Assembly.GetEntryAssembly().GetManifestResourceStream(n);
			}
			if (m != null) {
				var d = new uint[m.Length >> 2];
				var t = new byte[0x100];
				int r;
				int o = 0;
				while ((r = m.Read(t, 0, 0x100)) > 0) {
					Buffer.BlockCopy(t, 0, d, o, r);
					o += r;
				}
				uint s = 0x6fff61;
				foreach (byte c in b)
					s = s * 0x5e3f1f + c;
				GCHandle h = Decrypt(d, s);

				var f = (byte[])h.Target;
				Assembly a = Assembly.Load(f);
				Array.Clear(f, 0, f.Length);
				h.Free();
				Array.Clear(d, 0, d.Length);

				return a;
			}
			return null;
		}
	}
}


================================================
File: Confuser.Runtime/Confuser.Runtime.csproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProductVersion>8.0.30703</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{A45C184F-F98F-4258-A928-BFF437034791}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>Confuser.Runtime</RootNamespace>
    <AssemblyName>Confuser.Runtime</AssemblyName>
    <TargetFrameworkVersion>v2.0</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <TargetFrameworkProfile />
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>..\Debug\bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>..\Release\bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>
  <PropertyGroup>
    <SignAssembly>true</SignAssembly>
  </PropertyGroup>
  <PropertyGroup>
    <AssemblyOriginatorKeyFile>..\ConfuserEx.snk</AssemblyOriginatorKeyFile>
  </PropertyGroup>
  <ItemGroup>
    <Compile Include="..\GlobalAssemblyInfo.cs">
      <Link>Properties\GlobalAssemblyInfo.cs</Link>
    </Compile>
    <Compile Include="AntiDump.cs" />
    <Compile Include="AntiDebug.Win32.cs" />
    <Compile Include="AntiDebug.Antinet.cs" />
    <Compile Include="antinet\AntiManagedDebugger.cs" />
    <Compile Include="antinet\AntiManagedProfiler.cs" />
    <Compile Include="antinet\HandleProcessCorruptedStateExceptionsAttribute.cs" />
    <Compile Include="antinet\PEInfo.cs" />
    <Compile Include="Compressor.cs" />
    <Compile Include="Constant.cs" />
    <Compile Include="AntiTamper.JIT.cs" />
    <Compile Include="Compressor.Compat.cs" />
    <Compile Include="Lzma.cs" />
    <Compile Include="Mutation.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="RefProxy.Strong.cs" />
    <Compile Include="AntiDebug.Safe.cs" />
    <Compile Include="Resource.cs" />
    <Compile Include="AntiTamper.Normal.cs" />
  </ItemGroup>
  <ItemGroup>
    <Reference Include="System" />
  </ItemGroup>
  <ItemGroup>
    <None Include="..\ConfuserEx.snk">
      <Link>Properties\ConfuserEx.snk</Link>
    </None>
    <None Include="antinet\ABOUT" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>


================================================
File: Confuser.Runtime/Constant.cs
================================================
ï»¿using System;
using System.Text;

namespace Confuser.Runtime {
	internal static class Constant {
		static byte[] b;

		static void Initialize() {
			var l = (uint)Mutation.KeyI0;
			uint[] q = Mutation.Placeholder(new uint[Mutation.KeyI0]);

			var k = new uint[0x10];
			var n = (uint)Mutation.KeyI1;
			for (int i = 0; i < 0x10; i++) {
				n ^= n >> 12;
				n ^= n << 25;
				n ^= n >> 27;
				k[i] = n;
			}

			int s = 0, d = 0;
			var w = new uint[0x10];
			var o = new byte[l * 4];
			while (s < l) {
				for (int j = 0; j < 0x10; j++)
					w[j] = q[s + j];
				Mutation.Crypt(w, k);
				for (int j = 0; j < 0x10; j++) {
					uint e = w[j];
					o[d++] = (byte)e;
					o[d++] = (byte)(e >> 8);
					o[d++] = (byte)(e >> 16);
					o[d++] = (byte)(e >> 24);
					k[j] ^= e;
				}
				s += 0x10;
			}

			b = Lzma.Decompress(o);
		}

		static T Get<T>(uint id) {
			id = (uint)Mutation.Placeholder((int)id);
			uint t = id >> 30;

			T ret = default(T);
			id &= 0x3fffffff;
			id <<= 2;

			if (t == Mutation.KeyI0) {
				int l = b[id++] | (b[id++] << 8) | (b[id++] << 16) | (b[id++] << 24);
				ret = (T)(object)string.Intern(Encoding.UTF8.GetString(b, (int)id, l));
			}
			// NOTE: Assume little-endian
			else if (t == Mutation.KeyI1) {
				var v = new T[1];
				Buffer.BlockCopy(b, (int)id, v, 0, Mutation.Value<int>());
				ret = v[0];
			}
			else if (t == Mutation.KeyI2) {
				int s = b[id++] | (b[id++] << 8) | (b[id++] << 16) | (b[id++] << 24);
				int l = b[id++] | (b[id++] << 8) | (b[id++] << 16) | (b[id++] << 24);
				Array v = Array.CreateInstance(typeof(T).GetElementType(), l);
				Buffer.BlockCopy(b, (int)id, v, 0, s - 4);
				ret = (T)(object)v;
			}
			return ret;
		}
	}

	internal struct CFGCtx {
		uint A;
		uint B;
		uint C;
		uint D;

		public CFGCtx(uint seed) {
			A = seed *= 0x21412321;
			B = seed *= 0x21412321;
			C = seed *= 0x21412321;
			D = seed *= 0x21412321;
		}

		public uint Next(byte f, uint q) {
			if ((f & 0x80) != 0) {
				switch (f & 0x3) {
					case 0:
						A = q;
						break;
					case 1:
						B = q;
						break;
					case 2:
						C = q;
						break;
					case 3:
						D = q;
						break;
				}
			}
			else {
				switch (f & 0x3) {
					case 0:
						A ^= q;
						break;
					case 1:
						B += q;
						break;
					case 2:
						C ^= q;
						break;
					case 3:
						D -= q;
						break;
				}
			}

			switch ((f >> 2) & 0x3) {
				case 0:
					return A;
				case 1:
					return B;
				case 2:
					return C;
			}
			return D;
		}
	}
}


================================================
File: Confuser.Runtime/Lzma.cs
================================================
ï»¿using System;
using System.IO;

namespace Confuser.Runtime {
	internal static class Lzma {
		const uint kNumStates = 12;

		const int kNumPosSlotBits = 6;

		const uint kNumLenToPosStates = 4;

		const uint kMatchMinLen = 2;

		const int kNumAlignBits = 4;
		const uint kAlignTableSize = 1 << kNumAlignBits;

		const uint kStartPosModelIndex = 4;
		const uint kEndPosModelIndex = 14;

		const uint kNumFullDistances = 1 << ((int)kEndPosModelIndex / 2);

		const int kNumPosStatesBitsMax = 4;
		const uint kNumPosStatesMax = (1 << kNumPosStatesBitsMax);

		const int kNumLowLenBits = 3;
		const int kNumMidLenBits = 3;
		const int kNumHighLenBits = 8;
		const uint kNumLowLenSymbols = 1 << kNumLowLenBits;
		const uint kNumMidLenSymbols = 1 << kNumMidLenBits;

		public static byte[] Decompress(byte[] data) {
			var s = new MemoryStream(data);
			var decoder = new LzmaDecoder();
			var prop = new byte[5];
			s.Read(prop, 0, 5);
			decoder.SetDecoderProperties(prop);
			long outSize = 0;
			for (int i = 0; i < 8; i++) {
				int v = s.ReadByte();
				outSize |= ((long)(byte)v) << (8 * i);
			}
			var b = new byte[(int)outSize];
			var z = new MemoryStream(b, true);
			long compressedSize = s.Length - 13;
			decoder.Code(s, z, compressedSize, outSize);
			return b;
		}

		struct BitDecoder {
			public const int kNumBitModelTotalBits = 11;
			public const uint kBitModelTotal = (1 << kNumBitModelTotalBits);
			const int kNumMoveBits = 5;

			uint Prob;

			public void Init() {
				Prob = kBitModelTotal >> 1;
			}

			public uint Decode(Decoder rangeDecoder) {
				uint newBound = (rangeDecoder.Range >> kNumBitModelTotalBits) * Prob;
				if (rangeDecoder.Code < newBound) {
					rangeDecoder.Range = newBound;
					Prob += (kBitModelTotal - Prob) >> kNumMoveBits;
					if (rangeDecoder.Range < Decoder.kTopValue) {
						rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();
						rangeDecoder.Range <<= 8;
					}
					return 0;
				}
				rangeDecoder.Range -= newBound;
				rangeDecoder.Code -= newBound;
				Prob -= (Prob) >> kNumMoveBits;
				if (rangeDecoder.Range < Decoder.kTopValue) {
					rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();
					rangeDecoder.Range <<= 8;
				}
				return 1;
			}
		}

		struct BitTreeDecoder {
			readonly BitDecoder[] Models;
			readonly int NumBitLevels;

			public BitTreeDecoder(int numBitLevels) {
				NumBitLevels = numBitLevels;
				Models = new BitDecoder[1 << numBitLevels];
			}

			public void Init() {
				for (uint i = 1; i < (1 << NumBitLevels); i++)
					Models[i].Init();
			}

			public uint Decode(Decoder rangeDecoder) {
				uint m = 1;
				for (int bitIndex = NumBitLevels; bitIndex > 0; bitIndex--)
					m = (m << 1) + Models[m].Decode(rangeDecoder);
				return m - ((uint)1 << NumBitLevels);
			}

			public uint ReverseDecode(Decoder rangeDecoder) {
				uint m = 1;
				uint symbol = 0;
				for (int bitIndex = 0; bitIndex < NumBitLevels; bitIndex++) {
					uint bit = Models[m].Decode(rangeDecoder);
					m <<= 1;
					m += bit;
					symbol |= (bit << bitIndex);
				}
				return symbol;
			}

			public static uint ReverseDecode(BitDecoder[] Models, UInt32 startIndex,
			                                 Decoder rangeDecoder, int NumBitLevels) {
				uint m = 1;
				uint symbol = 0;
				for (int bitIndex = 0; bitIndex < NumBitLevels; bitIndex++) {
					uint bit = Models[startIndex + m].Decode(rangeDecoder);
					m <<= 1;
					m += bit;
					symbol |= (bit << bitIndex);
				}
				return symbol;
			}
		}

		class Decoder {
			public const uint kTopValue = (1 << 24);
			public uint Code;
			public uint Range;
			public Stream Stream;

			public void Init(Stream stream) {
				// Stream.Init(stream);
				Stream = stream;

				Code = 0;
				Range = 0xFFFFFFFF;
				for (int i = 0; i < 5; i++)
					Code = (Code << 8) | (byte)Stream.ReadByte();
			}

			public void ReleaseStream() {
				Stream = null;
			}

			public void Normalize() {
				while (Range < kTopValue) {
					Code = (Code << 8) | (byte)Stream.ReadByte();
					Range <<= 8;
				}
			}

			public uint DecodeDirectBits(int numTotalBits) {
				uint range = Range;
				uint code = Code;
				uint result = 0;
				for (int i = numTotalBits; i > 0; i--) {
					range >>= 1;
					/*
                    result <<= 1;
                    if (code >= range)
                    {
                        code -= range;
                        result |= 1;
                    }
                    */
					uint t = (code - range) >> 31;
					code -= range & (t - 1);
					result = (result << 1) | (1 - t);

					if (range < kTopValue) {
						code = (code << 8) | (byte)Stream.ReadByte();
						range <<= 8;
					}
				}
				Range = range;
				Code = code;
				return result;
			}
		}

		class LzmaDecoder {
			readonly BitDecoder[] m_IsMatchDecoders = new BitDecoder[kNumStates << kNumPosStatesBitsMax];
			readonly BitDecoder[] m_IsRep0LongDecoders = new BitDecoder[kNumStates << kNumPosStatesBitsMax];
			readonly BitDecoder[] m_IsRepDecoders = new BitDecoder[kNumStates];
			readonly BitDecoder[] m_IsRepG0Decoders = new BitDecoder[kNumStates];
			readonly BitDecoder[] m_IsRepG1Decoders = new BitDecoder[kNumStates];
			readonly BitDecoder[] m_IsRepG2Decoders = new BitDecoder[kNumStates];

			readonly LenDecoder m_LenDecoder = new LenDecoder();

			readonly LiteralDecoder m_LiteralDecoder = new LiteralDecoder();
			readonly OutWindow m_OutWindow = new OutWindow();
			readonly BitDecoder[] m_PosDecoders = new BitDecoder[kNumFullDistances - kEndPosModelIndex];
			readonly BitTreeDecoder[] m_PosSlotDecoder = new BitTreeDecoder[kNumLenToPosStates];
			readonly Decoder m_RangeDecoder = new Decoder();
			readonly LenDecoder m_RepLenDecoder = new LenDecoder();
			bool _solid = false;

			uint m_DictionarySize;
			uint m_DictionarySizeCheck;
			BitTreeDecoder m_PosAlignDecoder = new BitTreeDecoder(kNumAlignBits);

			uint m_PosStateMask;

			public LzmaDecoder() {
				m_DictionarySize = 0xFFFFFFFF;
				for (int i = 0; i < kNumLenToPosStates; i++)
					m_PosSlotDecoder[i] = new BitTreeDecoder(kNumPosSlotBits);
			}

			void SetDictionarySize(uint dictionarySize) {
				if (m_DictionarySize != dictionarySize) {
					m_DictionarySize = dictionarySize;
					m_DictionarySizeCheck = Math.Max(m_DictionarySize, 1);
					uint blockSize = Math.Max(m_DictionarySizeCheck, (1 << 12));
					m_OutWindow.Create(blockSize);
				}
			}

			void SetLiteralProperties(int lp, int lc) {
				m_LiteralDecoder.Create(lp, lc);
			}

			void SetPosBitsProperties(int pb) {
				uint numPosStates = (uint)1 << pb;
				m_LenDecoder.Create(numPosStates);
				m_RepLenDecoder.Create(numPosStates);
				m_PosStateMask = numPosStates - 1;
			}

			void Init(Stream inStream, Stream outStream) {
				m_RangeDecoder.Init(inStream);
				m_OutWindow.Init(outStream, _solid);

				uint i;
				for (i = 0; i < kNumStates; i++) {
					for (uint j = 0; j <= m_PosStateMask; j++) {
						uint index = (i << kNumPosStatesBitsMax) + j;
						m_IsMatchDecoders[index].Init();
						m_IsRep0LongDecoders[index].Init();
					}
					m_IsRepDecoders[i].Init();
					m_IsRepG0Decoders[i].Init();
					m_IsRepG1Decoders[i].Init();
					m_IsRepG2Decoders[i].Init();
				}

				m_LiteralDecoder.Init();
				for (i = 0; i < kNumLenToPosStates; i++)
					m_PosSlotDecoder[i].Init();
				// m_PosSpecDecoder.Init();
				for (i = 0; i < kNumFullDistances - kEndPosModelIndex; i++)
					m_PosDecoders[i].Init();

				m_LenDecoder.Init();
				m_RepLenDecoder.Init();
				m_PosAlignDecoder.Init();
			}

			public void Code(Stream inStream, Stream outStream,
			                 Int64 inSize, Int64 outSize) {
				Init(inStream, outStream);

				var state = new State();
				state.Init();
				uint rep0 = 0, rep1 = 0, rep2 = 0, rep3 = 0;

				UInt64 nowPos64 = 0;
				var outSize64 = (UInt64)outSize;
				if (nowPos64 < outSize64) {
					m_IsMatchDecoders[state.Index << kNumPosStatesBitsMax].Decode(m_RangeDecoder);
					state.UpdateChar();
					byte b = m_LiteralDecoder.DecodeNormal(m_RangeDecoder, 0, 0);
					m_OutWindow.PutByte(b);
					nowPos64++;
				}
				while (nowPos64 < outSize64) {
					// UInt64 next = Math.Min(nowPos64 + (1 << 18), outSize64);
					// while(nowPos64 < next)
					{
						uint posState = (uint)nowPos64 & m_PosStateMask;
						if (m_IsMatchDecoders[(state.Index << kNumPosStatesBitsMax) + posState].Decode(m_RangeDecoder) == 0) {
							byte b;
							byte prevByte = m_OutWindow.GetByte(0);
							if (!state.IsCharState())
								b = m_LiteralDecoder.DecodeWithMatchByte(m_RangeDecoder,
								                                         (uint)nowPos64, prevByte, m_OutWindow.GetByte(rep0));
							else
								b = m_LiteralDecoder.DecodeNormal(m_RangeDecoder, (uint)nowPos64, prevByte);
							m_OutWindow.PutByte(b);
							state.UpdateChar();
							nowPos64++;
						}
						else {
							uint len;
							if (m_IsRepDecoders[state.Index].Decode(m_RangeDecoder) == 1) {
								if (m_IsRepG0Decoders[state.Index].Decode(m_RangeDecoder) == 0) {
									if (m_IsRep0LongDecoders[(state.Index << kNumPosStatesBitsMax) + posState].Decode(m_RangeDecoder) == 0) {
										state.UpdateShortRep();
										m_OutWindow.PutByte(m_OutWindow.GetByte(rep0));
										nowPos64++;
										continue;
									}
								}
								else {
									UInt32 distance;
									if (m_IsRepG1Decoders[state.Index].Decode(m_RangeDecoder) == 0) {
										distance = rep1;
									}
									else {
										if (m_IsRepG2Decoders[state.Index].Decode(m_RangeDecoder) == 0)
											distance = rep2;
										else {
											distance = rep3;
											rep3 = rep2;
										}
										rep2 = rep1;
									}
									rep1 = rep0;
									rep0 = distance;
								}
								len = m_RepLenDecoder.Decode(m_RangeDecoder, posState) + kMatchMinLen;
								state.UpdateRep();
							}
							else {
								rep3 = rep2;
								rep2 = rep1;
								rep1 = rep0;
								len = kMatchMinLen + m_LenDecoder.Decode(m_RangeDecoder, posState);
								state.UpdateMatch();
								uint posSlot = m_PosSlotDecoder[GetLenToPosState(len)].Decode(m_RangeDecoder);
								if (posSlot >= kStartPosModelIndex) {
									var numDirectBits = (int)((posSlot >> 1) - 1);
									rep0 = ((2 | (posSlot & 1)) << numDirectBits);
									if (posSlot < kEndPosModelIndex)
										rep0 += BitTreeDecoder.ReverseDecode(m_PosDecoders,
										                                     rep0 - posSlot - 1, m_RangeDecoder, numDirectBits);
									else {
										rep0 += (m_RangeDecoder.DecodeDirectBits(
											numDirectBits - kNumAlignBits) << kNumAlignBits);
										rep0 += m_PosAlignDecoder.ReverseDecode(m_RangeDecoder);
									}
								}
								else
									rep0 = posSlot;
							}
							if (rep0 >= nowPos64 || rep0 >= m_DictionarySizeCheck) {
								if (rep0 == 0xFFFFFFFF)
									break;
							}
							m_OutWindow.CopyBlock(rep0, len);
							nowPos64 += len;
						}
					}
				}
				m_OutWindow.Flush();
				m_OutWindow.ReleaseStream();
				m_RangeDecoder.ReleaseStream();
			}

			public void SetDecoderProperties(byte[] properties) {
				int lc = properties[0] % 9;
				int remainder = properties[0] / 9;
				int lp = remainder % 5;
				int pb = remainder / 5;
				UInt32 dictionarySize = 0;
				for (int i = 0; i < 4; i++)
					dictionarySize += ((UInt32)(properties[1 + i])) << (i * 8);
				SetDictionarySize(dictionarySize);
				SetLiteralProperties(lp, lc);
				SetPosBitsProperties(pb);
			}

			static uint GetLenToPosState(uint len) {
				len -= kMatchMinLen;
				if (len < kNumLenToPosStates)
					return len;
				return unchecked((kNumLenToPosStates - 1));
			}

			class LenDecoder {
				readonly BitTreeDecoder[] m_LowCoder = new BitTreeDecoder[kNumPosStatesMax];
				readonly BitTreeDecoder[] m_MidCoder = new BitTreeDecoder[kNumPosStatesMax];
				BitDecoder m_Choice = new BitDecoder();
				BitDecoder m_Choice2 = new BitDecoder();
				BitTreeDecoder m_HighCoder = new BitTreeDecoder(kNumHighLenBits);
				uint m_NumPosStates;

				public void Create(uint numPosStates) {
					for (uint posState = m_NumPosStates; posState < numPosStates; posState++) {
						m_LowCoder[posState] = new BitTreeDecoder(kNumLowLenBits);
						m_MidCoder[posState] = new BitTreeDecoder(kNumMidLenBits);
					}
					m_NumPosStates = numPosStates;
				}

				public void Init() {
					m_Choice.Init();
					for (uint posState = 0; posState < m_NumPosStates; posState++) {
						m_LowCoder[posState].Init();
						m_MidCoder[posState].Init();
					}
					m_Choice2.Init();
					m_HighCoder.Init();
				}

				public uint Decode(Decoder rangeDecoder, uint posState) {
					if (m_Choice.Decode(rangeDecoder) == 0)
						return m_LowCoder[posState].Decode(rangeDecoder);
					uint symbol = kNumLowLenSymbols;
					if (m_Choice2.Decode(rangeDecoder) == 0)
						symbol += m_MidCoder[posState].Decode(rangeDecoder);
					else {
						symbol += kNumMidLenSymbols;
						symbol += m_HighCoder.Decode(rangeDecoder);
					}
					return symbol;
				}
			}

			class LiteralDecoder {
				Decoder2[] m_Coders;
				int m_NumPosBits;
				int m_NumPrevBits;
				uint m_PosMask;

				public void Create(int numPosBits, int numPrevBits) {
					if (m_Coders != null && m_NumPrevBits == numPrevBits &&
					    m_NumPosBits == numPosBits)
						return;
					m_NumPosBits = numPosBits;
					m_PosMask = ((uint)1 << numPosBits) - 1;
					m_NumPrevBits = numPrevBits;
					uint numStates = (uint)1 << (m_NumPrevBits + m_NumPosBits);
					m_Coders = new Decoder2[numStates];
					for (uint i = 0; i < numStates; i++)
						m_Coders[i].Create();
				}

				public void Init() {
					uint numStates = (uint)1 << (m_NumPrevBits + m_NumPosBits);
					for (uint i = 0; i < numStates; i++)
						m_Coders[i].Init();
				}

				uint GetState(uint pos, byte prevByte) {
					return ((pos & m_PosMask) << m_NumPrevBits) + (uint)(prevByte >> (8 - m_NumPrevBits));
				}

				public byte DecodeNormal(Decoder rangeDecoder, uint pos, byte prevByte) {
					return m_Coders[GetState(pos, prevByte)].DecodeNormal(rangeDecoder);
				}

				public byte DecodeWithMatchByte(Decoder rangeDecoder, uint pos, byte prevByte, byte matchByte) {
					return m_Coders[GetState(pos, prevByte)].DecodeWithMatchByte(rangeDecoder, matchByte);
				}

				struct Decoder2 {
					BitDecoder[] m_Decoders;

					public void Create() {
						m_Decoders = new BitDecoder[0x300];
					}

					public void Init() {
						for (int i = 0; i < 0x300; i++) m_Decoders[i].Init();
					}

					public byte DecodeNormal(Decoder rangeDecoder) {
						uint symbol = 1;
						do
							symbol = (symbol << 1) | m_Decoders[symbol].Decode(rangeDecoder); while (symbol < 0x100);
						return (byte)symbol;
					}

					public byte DecodeWithMatchByte(Decoder rangeDecoder, byte matchByte) {
						uint symbol = 1;
						do {
							uint matchBit = (uint)(matchByte >> 7) & 1;
							matchByte <<= 1;
							uint bit = m_Decoders[((1 + matchBit) << 8) + symbol].Decode(rangeDecoder);
							symbol = (symbol << 1) | bit;
							if (matchBit != bit) {
								while (symbol < 0x100)
									symbol = (symbol << 1) | m_Decoders[symbol].Decode(rangeDecoder);
								break;
							}
						} while (symbol < 0x100);
						return (byte)symbol;
					}
				}
			};
		}

		class OutWindow {
			byte[] _buffer;
			uint _pos;
			Stream _stream;
			uint _streamPos;
			uint _windowSize;

			public void Create(uint windowSize) {
				if (_windowSize != windowSize) {
					_buffer = new byte[windowSize];
				}
				_windowSize = windowSize;
				_pos = 0;
				_streamPos = 0;
			}

			public void Init(Stream stream, bool solid) {
				ReleaseStream();
				_stream = stream;
				if (!solid) {
					_streamPos = 0;
					_pos = 0;
				}
			}

			public void ReleaseStream() {
				Flush();
				_stream = null;
				Buffer.BlockCopy(new byte[_buffer.Length], 0, _buffer, 0, _buffer.Length);
			}

			public void Flush() {
				uint size = _pos - _streamPos;
				if (size == 0)
					return;
				_stream.Write(_buffer, (int)_streamPos, (int)size);
				if (_pos >= _windowSize)
					_pos = 0;
				_streamPos = _pos;
			}

			public void CopyBlock(uint distance, uint len) {
				uint pos = _pos - distance - 1;
				if (pos >= _windowSize)
					pos += _windowSize;
				for (; len > 0; len--) {
					if (pos >= _windowSize)
						pos = 0;
					_buffer[_pos++] = _buffer[pos++];
					if (_pos >= _windowSize)
						Flush();
				}
			}

			public void PutByte(byte b) {
				_buffer[_pos++] = b;
				if (_pos >= _windowSize)
					Flush();
			}

			public byte GetByte(uint distance) {
				uint pos = _pos - distance - 1;
				if (pos >= _windowSize)
					pos += _windowSize;
				return _buffer[pos];
			}
		}

		struct State {
			public uint Index;

			public void Init() {
				Index = 0;
			}

			public void UpdateChar() {
				if (Index < 4) Index = 0;
				else if (Index < 10) Index -= 3;
				else Index -= 6;
			}

			public void UpdateMatch() {
				Index = (uint)(Index < 7 ? 7 : 10);
			}

			public void UpdateRep() {
				Index = (uint)(Index < 7 ? 8 : 11);
			}

			public void UpdateShortRep() {
				Index = (uint)(Index < 7 ? 9 : 11);
			}

			public bool IsCharState() {
				return Index < 7;
			}
		}
	}
}


================================================
File: Confuser.Runtime/Mutation.cs
================================================
ï»¿using System;

internal class Mutation {
	public static readonly int KeyI0 = 0;
	public static readonly int KeyI1 = 1;
	public static readonly int KeyI2 = 2;
	public static readonly int KeyI3 = 3;
	public static readonly int KeyI4 = 4;
	public static readonly int KeyI5 = 5;
	public static readonly int KeyI6 = 6;
	public static readonly int KeyI7 = 7;
	public static readonly int KeyI8 = 8;
	public static readonly int KeyI9 = 9;
	public static readonly int KeyI10 = 10;
	public static readonly int KeyI11 = 11;
	public static readonly int KeyI12 = 12;
	public static readonly int KeyI13 = 13;
	public static readonly int KeyI14 = 14;
	public static readonly int KeyI15 = 15;

	public static T Placeholder<T>(T val) {
		return val;
	}

	public static T Value<T>() {
		return default(T);
	}

	public static T Value<T, Arg0>(Arg0 arg0) {
		return default(T);
	}

	public static void Crypt(uint[] data, uint[] key) { }
}


================================================
File: Confuser.Runtime/RefProxy.Strong.cs
================================================
ï»¿using System;
using System.Reflection;
using System.Reflection.Emit;

namespace Confuser.Runtime {
	internal class RefProxyKey : Attribute {
		readonly int key;

		public RefProxyKey(int key) {
			this.key = Mutation.Placeholder(key);
		}

		public override int GetHashCode() {
			return key;
		}
	}

	internal static class RefProxyStrong {
		internal static void Initialize(RuntimeFieldHandle field, byte opKey) {
			FieldInfo fieldInfo = FieldInfo.GetFieldFromHandle(field);
			byte[] sig = fieldInfo.Module.ResolveSignature(fieldInfo.MetadataToken);
			int len = sig.Length;
			int key = fieldInfo.GetOptionalCustomModifiers()[0].MetadataToken;

			key += (fieldInfo.Name[Mutation.KeyI0] ^ sig[--len]) << Mutation.KeyI4;
			key += (fieldInfo.Name[Mutation.KeyI1] ^ sig[--len]) << Mutation.KeyI5;
			key += (fieldInfo.Name[Mutation.KeyI2] ^ sig[--len]) << Mutation.KeyI6;
			len--;
			key += (fieldInfo.Name[Mutation.KeyI3] ^ sig[--len]) << Mutation.KeyI7;

			int token = Mutation.Placeholder(key);
			token *= fieldInfo.GetCustomAttributes(false)[0].GetHashCode();

			MethodBase method = fieldInfo.Module.ResolveMethod(token);
			Type delegateType = fieldInfo.FieldType;
			if (method.IsStatic)
				fieldInfo.SetValue(null, Delegate.CreateDelegate(delegateType, (MethodInfo)method));

			else {
				DynamicMethod dm = null;
				Type[] argTypes = null;

				foreach (MethodInfo invoke in fieldInfo.FieldType.GetMethods(BindingFlags.NonPublic | BindingFlags.Instance))
					if (invoke.DeclaringType == delegateType) {
						ParameterInfo[] paramTypes = invoke.GetParameters();
						argTypes = new Type[paramTypes.Length];
						for (int i = 0; i < argTypes.Length; i++)
							argTypes[i] = paramTypes[i].ParameterType;

						Type declType = method.DeclaringType;
						dm = new DynamicMethod("", invoke.ReturnType, argTypes, (declType.IsInterface || declType.IsArray) ? delegateType : declType, true);
						break;
					}

				DynamicILInfo info = dm.GetDynamicILInfo();
				info.SetLocalSignature(new byte[] { 0x7, 0x0 });
				var code = new byte[(2 + 5) * argTypes.Length + 6];
				int index = 0;
				var mParams = method.GetParameters();
				int mIndex = method.IsConstructor ? 0 : -1;
				for (int i = 0; i < argTypes.Length; i++) {
					code[index++] = 0x0e;
					code[index++] = (byte)i;

					var mType = mIndex == -1 ? method.DeclaringType : mParams[mIndex].ParameterType;
					if (mType.IsClass && !(mType.IsPointer || mType.IsByRef)) {
						var cToken = info.GetTokenFor(mType.TypeHandle);
						code[index++] = 0x74;
						code[index++] = (byte)cToken;
						code[index++] = (byte)(cToken >> 8);
						code[index++] = (byte)(cToken >> 16);
						code[index++] = (byte)(cToken >> 24);
					}
					else
						index += 5;
					mIndex++;
				}
				code[index++] = (byte)((byte)fieldInfo.Name[Mutation.KeyI8] ^ opKey);
				int dmToken = info.GetTokenFor(method.MethodHandle);
				code[index++] = (byte)dmToken;
				code[index++] = (byte)(dmToken >> 8);
				code[index++] = (byte)(dmToken >> 16);
				code[index++] = (byte)(dmToken >> 24);
				code[index] = 0x2a;
				info.SetCode(code, argTypes.Length + 1);

				fieldInfo.SetValue(null, dm.CreateDelegate(delegateType));
			}
		}
	}
}


================================================
File: Confuser.Runtime/Resource.cs
================================================
ï»¿using System;
using System.Reflection;

namespace Confuser.Runtime {
	internal static class Resource {
		static Assembly c;

		// Hmm... Too lazy.
		static void Initialize() {
			var l = (uint)Mutation.KeyI0;
			uint[] q = Mutation.Placeholder(new uint[Mutation.KeyI0]);

			var k = new uint[0x10];
			var n = (uint)Mutation.KeyI1;
			for (int i = 0; i < 0x10; i++) {
				n ^= n >> 13;
				n ^= n << 25;
				n ^= n >> 27;
				k[i] = n;
			}

			int s = 0, d = 0;
			var w = new uint[0x10];
			var o = new byte[l * 4];
			while (s < l) {
				for (int j = 0; j < 0x10; j++)
					w[j] = q[s + j];
				Mutation.Crypt(w, k);
				for (int j = 0; j < 0x10; j++) {
					uint e = w[j];
					o[d++] = (byte)e;
					o[d++] = (byte)(e >> 8);
					o[d++] = (byte)(e >> 16);
					o[d++] = (byte)(e >> 24);
					k[j] ^= e;
				}
				s += 0x10;
			}

			c = Assembly.Load(Lzma.Decompress(o));
			AppDomain.CurrentDomain.AssemblyResolve += Handler;
		}

		static Assembly Handler(object sender, ResolveEventArgs args) {
			if (c.FullName == args.Name)
				return c;
			return null;
		}
	}

	internal static class Resource_Packer {
		static Assembly c;

		// Hmm... Too lazy.
		static void Initialize() {
			var l = (uint)Mutation.KeyI0;
			uint[] q = Mutation.Placeholder(new uint[Mutation.KeyI0]);

			var k = new uint[0x10];
			var n = (uint)Mutation.KeyI1;
			for (int i = 0; i < 0x10; i++) {
				n ^= n >> 13;
				n ^= n << 25;
				n ^= n >> 27;
				k[i] = n;
			}

			int s = 0, d = 0;
			var w = new uint[0x10];
			var o = new byte[l * 4];
			while (s < l) {
				for (int j = 0; j < 0x10; j++)
					w[j] = q[s + j];
				Mutation.Crypt(w, k);
				for (int j = 0; j < 0x10; j++) {
					uint e = w[j];
					o[d++] = (byte)e;
					o[d++] = (byte)(e >> 8);
					o[d++] = (byte)(e >> 16);
					o[d++] = (byte)(e >> 24);
					k[j] ^= e;
				}
				s += 0x10;
			}

			c = Assembly.Load(Lzma.Decompress(o));
			AppDomain.CurrentDomain.ResourceResolve += Handler;
		}

		static Assembly Handler(object sender, ResolveEventArgs args) {
			var n = c.GetManifestResourceNames();
			if (Array.IndexOf(n, args.Name) != -1)
				return c;
			return null;
		}
	}
}


================================================
File: Confuser.Runtime/Properties/AssemblyInfo.cs
================================================
ï»¿using System;
using System.Reflection;

[assembly: AssemblyTitle("ConfuserEx Runtime")]
[assembly: AssemblyDescription("Runtime library of ConfuserEx")]


================================================
File: Confuser.Runtime/antinet/ABOUT
================================================
ï»¿antinet --- Code to prevent a managed .NET debugger/profiler from working
Official site: https://bitbucket.org/0xd4d/antinet

Written by de4dot@gmail.com
Modified by Ki for use in ConfuserEx

The source code in this folder is in the public domain.


================================================
File: Confuser.Runtime/antinet/AntiManagedDebugger.cs
================================================
ï»¿/*
 * Anti managed debugger code. Written by de4dot@gmail.com
 * This code is in the public domain.
 * Official site: https://github.com/0xd4d/antinet
 */

using System;
using System.Runtime.ExceptionServices;
using System.Runtime.InteropServices;
using System.Security;

namespace Confuser.Runtime {
	// This class will make sure that no managed .NET debugger can attach and
	// debug this .NET process. This code assumes that it's Microsoft's .NET
	// implementation (for the desktop) that is used. The only currently supported
	// versions are .NET Framework 2.0 - 4.5 (CLR 2.0 and CLR 4.0).
	// It prevents debugging by killing the .NET debugger thread. When it's killed,
	// any attached managed debugger, or any managed debugger that attaches, will
	// fail to send and receive any .NET debug messages. If a debugger is attached,
	// <c>Debugger.IsAttached</c> will still return <c>true</c> but that doesn't mean
	// the debugger is working. It's just that the debugger flag isn't reset by our code.
	// If a debugger is attached before this code is executed, the process could hang at
	// some later time when this process is trying to send a debug message to the debugger.
	// Clearing the debug flag could possibly solve this if you don't want it to hang.
	static partial class AntiDebugAntinet {

		[DllImport("kernel32", CharSet = CharSet.Auto)]
		private static extern uint GetCurrentProcessId();

		[DllImport("kernel32")]
		private static extern bool SetEvent(IntPtr hEvent);

		/// <summary>
		///     Must be called to initialize anti-managed debugger code
		/// </summary>
		/// <returns><c>true</c> if successful, <c>false</c> otherwise</returns>
		private static unsafe bool InitializeAntiDebugger() {
			Info info = GetInfo();
			IntPtr pDebuggerRCThread = FindDebuggerRCThreadAddress(info);
			if (pDebuggerRCThread == IntPtr.Zero)
				return false;

			// This isn't needed but it will at least stop debuggers from attaching.
			// Even if they did attach, they wouldn't get any messages since the debugger
			// thread has exited. A user who tries to attach will be greeted with an
			// "unable to attach due to different versions etc" message. This will not stop
			// already attached debuggers. Killing the debugger thread will.
			var pDebuggerIPCControlBlock = (byte*)*(IntPtr*)((byte*)pDebuggerRCThread + info.DebuggerRCThread_pDebuggerIPCControlBlock);
			if (Environment.Version.Major == 2)
				pDebuggerIPCControlBlock = (byte*)*(IntPtr*)pDebuggerIPCControlBlock;
			// Set size field to 0. mscordbi!CordbProcess::VerifyControlBlock() will fail
			// when it detects an unknown size.
			*(uint*)pDebuggerIPCControlBlock = 0;

			// Signal debugger thread to exit
			*((byte*)pDebuggerRCThread + info.DebuggerRCThread_shouldKeepLooping) = 0;
			IntPtr hEvent = *(IntPtr*)((byte*)pDebuggerRCThread + info.DebuggerRCThread_hEvent1);
			SetEvent(hEvent);

			return true;
		}

		/// <summary>
		///     Returns the correct <see cref="Info" /> instance
		/// </summary>
		private static Info GetInfo() {
			switch (Environment.Version.Major) {
				case 2:
					return IntPtr.Size == 4 ? Infos.info_CLR20_x86 : Infos.info_CLR20_x64;
				case 4:
					if (Environment.Version.Revision <= 17020)
						return IntPtr.Size == 4 ? Infos.info_CLR40_x86_1 : Infos.info_CLR40_x64;
					return IntPtr.Size == 4 ? Infos.info_CLR40_x86_2 : Infos.info_CLR40_x64;
				default:
					goto case 4; // Assume CLR 4.0
			}
		}

		/// <summary>
		///     Tries to find the address of the <c>DebuggerRCThread</c> instance in memory
		/// </summary>
		/// <param name="info">The debugger info we need</param>
		[HandleProcessCorruptedStateExceptions, SecurityCritical] // Req'd on .NET 4.0
		private static unsafe IntPtr FindDebuggerRCThreadAddress(Info info) {
			uint pid = GetCurrentProcessId();

			try {
				PEInfo peInfo = PEInfo.GetCLR();
				if (peInfo == null)
					return IntPtr.Zero;

				IntPtr sectionAddr;
				uint sectionSize;
				if (!peInfo.FindSection(".data", out sectionAddr, out sectionSize))
					return IntPtr.Zero;

				// Try to find the Debugger instance location in the data section
				var p = (byte*)sectionAddr;
				byte* end = (byte*)sectionAddr + sectionSize;
				for (; p + IntPtr.Size <= end; p += IntPtr.Size) {
					IntPtr pDebugger = *(IntPtr*)p;
					if (pDebugger == IntPtr.Zero)
						continue;

					try {
						// All allocations are pointer-size aligned
						if (!PEInfo.IsAlignedPointer(pDebugger))
							continue;

						// Make sure pid is correct
						uint pid2 = *(uint*)((byte*)pDebugger + info.Debugger_pid);
						if (pid != pid2)
							continue;

						IntPtr pDebuggerRCThread = *(IntPtr*)((byte*)pDebugger + info.Debugger_pDebuggerRCThread);

						// All allocations are pointer-size aligned
						if (!PEInfo.IsAlignedPointer(pDebuggerRCThread))
							continue;

						// Make sure it points back to Debugger
						IntPtr pDebugger2 = *(IntPtr*)((byte*)pDebuggerRCThread + info.DebuggerRCThread_pDebugger);
						if (pDebugger != pDebugger2)
							continue;

						return pDebuggerRCThread;
					}
					catch { }
				}
			}
			catch { }

			return IntPtr.Zero;
		}

		private class Info {

			/// <summary>
			///     Offset in <c>DebuggerRCThread</c> of event to signal to wake it up.
			///     See <c>Debugger::StopDebugger()</c> or one of the first methods it calls.
			/// </summary>
			public int DebuggerRCThread_hEvent1;

			/// <summary>
			///     Offset in <c>DebuggerRCThread</c> of pointer to <c>Debugger</c>.
			///     See <c>DebuggerRCThread::DebuggerRCThread()</c>.
			/// </summary>
			public int DebuggerRCThread_pDebugger;

			/// <summary>
			///     Offset in <c>DebuggerRCThread</c> of pointer to <c>DebuggerIPCControlBlock</c>.
			///     See <c>DebuggerRCThread::Start() after it creates the thread.</c>.
			/// </summary>
			public int DebuggerRCThread_pDebuggerIPCControlBlock;

			/// <summary>
			///     Offset in <c>DebuggerRCThread</c> of keep-looping boolean (1 byte).
			///     See <c>Debugger::StopDebugger()</c> or one of the first methods it calls.
			/// </summary>
			public int DebuggerRCThread_shouldKeepLooping;

			/// <summary>
			///     Offset in <c>Debugger</c> of pointer to <c>DebuggerRCThread</c>.
			///     See <c>Debugger::Startup()</c> (after creating DebuggerRCThread).
			/// </summary>
			public int Debugger_pDebuggerRCThread;

			/// <summary>
			///     Offset in <c>Debugger</c> of the <c>pid</c>.
			///     See <c>Debugger::Debugger()</c>.
			/// </summary>
			public int Debugger_pid;

		}

		private static class Infos {

			/// <summary>
			///     CLR 2.0 x86 offsets
			/// </summary>
			public static readonly Info info_CLR20_x86 = new Info {
				Debugger_pDebuggerRCThread = 4,
				Debugger_pid = 8,
				DebuggerRCThread_pDebugger = 0x30,
				DebuggerRCThread_pDebuggerIPCControlBlock = 0x34,
				DebuggerRCThread_shouldKeepLooping = 0x3C,
				DebuggerRCThread_hEvent1 = 0x40,
			};

			/// <summary>
			///     CLR 2.0 x64 offsets
			/// </summary>
			public static readonly Info info_CLR20_x64 = new Info {
				Debugger_pDebuggerRCThread = 8,
				Debugger_pid = 0x10,
				DebuggerRCThread_pDebugger = 0x58,
				DebuggerRCThread_pDebuggerIPCControlBlock = 0x60,
				DebuggerRCThread_shouldKeepLooping = 0x70,
				DebuggerRCThread_hEvent1 = 0x78,
			};

			/// <summary>
			///     CLR 4.0 x86 offsets
			/// </summary>
			public static readonly Info info_CLR40_x86_1 = new Info {
				Debugger_pDebuggerRCThread = 8,
				Debugger_pid = 0xC,
				DebuggerRCThread_pDebugger = 0x34,
				DebuggerRCThread_pDebuggerIPCControlBlock = 0x38,
				DebuggerRCThread_shouldKeepLooping = 0x40,
				DebuggerRCThread_hEvent1 = 0x44,
			};

			/// <summary>
			///     CLR 4.0 x86 offsets (rev >= 17379 (.NET 4.5 Beta, but not .NET 4.5 Dev Preview))
			/// </summary>
			public static readonly Info info_CLR40_x86_2 = new Info {
				Debugger_pDebuggerRCThread = 8,
				Debugger_pid = 0xC,
				DebuggerRCThread_pDebugger = 0x30,
				DebuggerRCThread_pDebuggerIPCControlBlock = 0x34,
				DebuggerRCThread_shouldKeepLooping = 0x3C,
				DebuggerRCThread_hEvent1 = 0x40,
			};

			/// <summary>
			///     CLR 4.0 x64 offsets (this is the same in all CLR 4.0 versions, even in .NET 4.5 RTM)
			/// </summary>
			public static readonly Info info_CLR40_x64 = new Info {
				Debugger_pDebuggerRCThread = 0x10,
				Debugger_pid = 0x18,
				DebuggerRCThread_pDebugger = 0x58,
				DebuggerRCThread_pDebuggerIPCControlBlock = 0x60,
				DebuggerRCThread_shouldKeepLooping = 0x70,
				DebuggerRCThread_hEvent1 = 0x78,
			};

		}

	}
}


================================================
File: Confuser.Runtime/antinet/AntiManagedProfiler.cs
================================================
ï»¿/*
 * Anti managed profiler code. Written by de4dot@gmail.com
 * This code is in the public domain.
 * Official site: https://github.com/0xd4d/antinet
 */

using System;
using System.Collections.Generic;
using System.Runtime.ExceptionServices;
using System.Runtime.InteropServices;
using System.Security;
using Microsoft.Win32.SafeHandles;

namespace Confuser.Runtime {
	//  This class will make sure that no managed .NET profiler is working.

	//  To detect profilers that are loaded when the CLR is loaded, this code will find
	//  the CLR profiler status flag in the data section. If CLR 4.0 is used, the code
	//  will find instructions in clr.dll that compares a dword location with the value 4.
	//  4 is the value that is stored when a profiler has successfully attached to the
	//  CLR. If CLR 2.0 is used, then it will look for code that tests bits 1 and 2 of
	//  some dword location.

	//  CLR 4.0 allows a profiler to attach at any time. For this to work, it will create
	//  a named event, called "Global\CPFATE_PID_vCLRVERSION" where PID is the pid
	//  of the process the CLR is in and CLRVERSION is the first 3 version numbers
	//  (eg. 4.0.30319). It's actually the Finalizer thread that waits on this event. :)

	//  When a profiler tries to attach, it will try to connect to a named pipe. This pipe's
	//  name is called "\\.\pipe\CPFATP_PID_vCLRVERSION". It will then signal the above event to
	//  wake up the Finalizer thread. If the event can't be created, then no profiler can ever
	//  attach. Any code that runs before the CLR has a chance to "steal" this event from it
	//  to prevent the CLR from allowing profilers to attach at runtime. We can't do it. But
	//  we can create the named pipe. If we own the named pipe, then no profiler can ever send
	//  the attach message and they'll never be able to attach.

	//  Most of the time, the named pipe isn't created. All we do is create the named pipe
	//  and we've prevented profilers from attaching at runtime. If the pipe has already been
	//  created, we must make sure the CLR closes the pipe and exits the "profiler attacher"
	//  thread. By default, it will wait up to 5 mins (300,000ms) before exiting the wait loop.
	//  You can change this value with the ProfAPIMaxWaitForTriggerMs option (dword in registry)
	//  or COMPlus_ProfAPIMaxWaitForTriggerMs environment value. If the AttachThreadAlwaysOn
	//  option (COMPlus_AttachThreadAlwaysOn env value) is enabled, the attach thread will
	//  never exit and the named pipe is never closed. It's possible to close the thread and
	//  the named pipe, but it requires more memory patching. See the code for details.

	//  A user could close the named pipe handle, so we must also patch the thread proc so
	//  it always returns immediately. Only patching the thread proc and not taking ownership
	//  of the named pipe isn't good enough. If we own the named pipe, we know that the attacher
	//  thread has exited. Once we've patched the thread proc, we don't really need the named
	//  pipe anymore.
	static partial class AntiDebugAntinet {

		private static ProfilerDetector profilerDetector;

		/// <summary>
		///     Returns <c>true</c> if a profiler was attached, is attaching or detaching.
		/// </summary>
		private static bool IsProfilerAttached {
			[HandleProcessCorruptedStateExceptions, SecurityCritical] // Req'd on .NET 4.0
			get {
				try {
					if (profilerDetector == null)
						return false;
					return profilerDetector.IsProfilerAttached();
				}
				catch { }
				return false;
			}
		}

		/// <summary>
		///     Returns <c>true</c> if a profiler was attached, is attaching or detaching.
		/// </summary>
		private static bool WasProfilerAttached {
			[HandleProcessCorruptedStateExceptions, SecurityCritical] // Req'd on .NET 4.0
			get {
				try {
					if (profilerDetector == null)
						return false;
					return profilerDetector.WasProfilerAttached();
				}
				catch { }
				return false;
			}
		}

		/// <summary>
		///     Must be called to initialize anti-managed profiler code. This method should only
		///     be called once per process. I.e., don't call it from every loaded .NET DLL.
		/// </summary>
		/// <returns><c>true</c> if successful, <c>false</c> otherwise</returns>
		private static bool InitializeAntiProfiler() {
			profilerDetector = CreateProfilerDetector();
			return profilerDetector.Init();
		}

		private static ProfilerDetector CreateProfilerDetector() {
			if (Environment.Version.Major == 2)
				return new ProfilerDetectorCLR20();
			return new ProfilerDetectorCLR40();
		}

		/// <summary>
		///     Prevents any active profiler from receiving any profiling messages. Since the
		///     profiler is still in memory, it can call into the CLR even if it doesn't receive
		///     any messages. It's better to terminate the application than call this method.
		/// </summary>
		private static void PreventActiveProfilerFromReceivingProfilingMessages() {
			if (profilerDetector == null)
				return;
			profilerDetector.PreventActiveProfilerFromReceivingProfilingMessages();
		}

		private static IntPtr GetMax(Dictionary<IntPtr, int> addresses, int minCount) {
			IntPtr foundAddr = IntPtr.Zero;
			int maxCount = 0;

			foreach (var kv in addresses) {
				if (foundAddr == IntPtr.Zero || maxCount < kv.Value) {
					foundAddr = kv.Key;
					maxCount = kv.Value;
				}
			}

			return maxCount >= minCount ? foundAddr : IntPtr.Zero;
		}

		private abstract class ProfilerDetector {

			public abstract bool IsProfilerAttached();
			public abstract bool WasProfilerAttached();
			public abstract bool Init();
			public abstract void PreventActiveProfilerFromReceivingProfilingMessages();

		}

		private class ProfilerDetectorCLR20 : ProfilerDetector {

			/// <summary>
			///     Address of CLR 2.0's profiler status flag. If one or both of bits 1 or 2 is set,
			///     a profiler is attached.
			/// </summary>
			private IntPtr profilerStatusFlag;

			private bool wasAttached;

			public override bool IsProfilerAttached() {
				unsafe {
					if (profilerStatusFlag == IntPtr.Zero)
						return false;
					return (*(uint*)profilerStatusFlag & 6) != 0;
				}
			}

			public override bool WasProfilerAttached() {
				return wasAttached;
			}

			public override bool Init() {
				bool result = FindProfilerStatus();
				wasAttached = IsProfilerAttached();
				return result;
			}

			/// <summary>
			///     This code tries to find the CLR 2.0 profiler status flag. It searches the whole
			///     .text section for a certain instruction.
			/// </summary>
			/// <returns><c>true</c> if it was found, <c>false</c> otherwise</returns>
			private unsafe bool FindProfilerStatus() {
				// Record each hit here and pick the one with the most hits
				var addrCounts = new Dictionary<IntPtr, int>();
				try {
					PEInfo peInfo = PEInfo.GetCLR();
					if (peInfo == null)
						return false;

					IntPtr sectionAddr;
					uint sectionSize;
					if (!peInfo.FindSection(".text", out sectionAddr, out sectionSize))
						return false;

					const int MAX_COUNTS = 50;
					var p = (byte*)sectionAddr;
					byte* end = (byte*)sectionAddr + sectionSize;
					for (; p < end; p++) {
						IntPtr addr;

						// F6 05 XX XX XX XX 06	test byte ptr [mem],6
						if (*p == 0xF6 && p[1] == 0x05 && p[6] == 0x06) {
							if (IntPtr.Size == 4)
								addr = new IntPtr((void*)*(uint*)(p + 2));
							else
								addr = new IntPtr(p + 7 + *(int*)(p + 2));
						}
						else
							continue;

						if (!PEInfo.IsAligned(addr, 4))
							continue;
						if (!peInfo.IsValidImageAddress(addr, 4))
							continue;

						try {
							*(uint*)addr = *(uint*)addr;
						}
						catch {
							continue;
						}

						int count = 0;
						addrCounts.TryGetValue(addr, out count);
						count++;
						addrCounts[addr] = count;
						if (count >= MAX_COUNTS)
							break;
					}
				}
				catch { }
				IntPtr foundAddr = GetMax(addrCounts, 5);
				if (foundAddr == IntPtr.Zero)
					return false;

				profilerStatusFlag = foundAddr;
				return true;
			}

			public override unsafe void PreventActiveProfilerFromReceivingProfilingMessages() {
				if (profilerStatusFlag == IntPtr.Zero)
					return;
				*(uint*)profilerStatusFlag &= ~6U;
			}

		}

		private class ProfilerDetectorCLR40 : ProfilerDetector {

			private const uint PIPE_ACCESS_DUPLEX = 3;
			private const uint PIPE_TYPE_MESSAGE = 4;
			private const uint PIPE_READMODE_MESSAGE = 2;
			private const uint FILE_FLAG_OVERLAPPED = 0x40000000;
			private const uint GENERIC_READ = 0x80000000;
			private const uint GENERIC_WRITE = 0x40000000;
			private const uint OPEN_EXISTING = 3;
			private const uint PAGE_EXECUTE_READWRITE = 0x40;

			private const uint ConfigDWORDInfo_name = 0;
			private const string ProfAPIMaxWaitForTriggerMs_name = "ProfAPIMaxWaitForTriggerMs";
			private static readonly uint ConfigDWORDInfo_defValue = (uint)IntPtr.Size;

			/// <summary>
			///     Address of the profiler control block. Only some fields are interesting and
			///     here they are in order:
			///     <code>
			/// EEToProfInterfaceImpl*
			/// uint profilerEventMask
			/// uint profilerStatus
			/// </code>
			///     <c>profilerStatus</c> is <c>0</c> when no profiler is attached. Any other value
			///     indicates that a profiler is attached, attaching, or detaching. It's <c>4</c>
			///     when a profiler is attached. When it's attached, it will receive messages from
			///     the CLR.
			/// </summary>
			private IntPtr profilerControlBlock;

			private SafeFileHandle profilerPipe;

			private bool wasAttached;

			[DllImport("kernel32", CharSet = CharSet.Auto)]
			private static extern uint GetCurrentProcessId();

			[DllImport("kernel32", CharSet = CharSet.Auto)]
			private static extern void Sleep(uint dwMilliseconds);

			[DllImport("kernel32", SetLastError = true)]
			private static extern SafeFileHandle CreateNamedPipe(string lpName, uint dwOpenMode,
			                                                     uint dwPipeMode, uint nMaxInstances, uint nOutBufferSize, uint nInBufferSize,
			                                                     uint nDefaultTimeOut, IntPtr lpSecurityAttributes);

			[DllImport("kernel32", SetLastError = true, CharSet = CharSet.Auto)]
			private static extern SafeFileHandle CreateFile(string lpFileName, uint dwDesiredAccess,
			                                                uint dwShareMode, IntPtr lpSecurityAttributes, uint dwCreationDisposition,
			                                                uint dwFlagsAndAttributes, IntPtr hTemplateFile);

			[DllImport("kernel32")]
			private static extern bool VirtualProtect(IntPtr lpAddress, int dwSize, uint flNewProtect, out uint lpflOldProtect);

			public override bool IsProfilerAttached() {
				unsafe {
					if (profilerControlBlock == IntPtr.Zero)
						return false;
					return *(uint*)((byte*)profilerControlBlock + IntPtr.Size + 4) != 0;
				}
			}

			public override bool WasProfilerAttached() {
				return wasAttached;
			}

			public override bool Init() {
				bool result = FindProfilerControlBlock();
				result &= TakeOwnershipOfNamedPipe() || CreateNamedPipe();
				result &= PatchAttacherThreadProc();
				wasAttached = IsProfilerAttached();
				return result;
			}

			[HandleProcessCorruptedStateExceptions, SecurityCritical] // Req'd on .NET 4.0
			private unsafe bool TakeOwnershipOfNamedPipe() {
				try {
					if (CreateNamedPipe())
						return true;

					// The CLR has already created the named pipe. Either the AttachThreadAlwaysOn
					// CLR option is enabled or some profiler has just attached or is attaching.
					// We must force it to exit its loop. There are two options that can prevent
					// it from exiting the thread, AttachThreadAlwaysOn and
					// ProfAPIMaxWaitForTriggerMs. If AttachThreadAlwaysOn is enabled, the thread
					// is started immediately when the CLR is loaded and it never exits.
					// ProfAPIMaxWaitForTriggerMs is the timeout in ms to use when waiting on
					// client attach messages. A user could set this to FFFFFFFF which is equal
					// to the INFINITE constant.
					//
					// To force it to exit, we must do this:
					//	- Find clr!ProfilingAPIAttachDetach::s_attachThreadingMode and make sure
					//	  it's not 2 (AttachThreadAlwaysOn is enabled).
					//	- Find clr!EXTERNAL_ProfAPIMaxWaitForTriggerMs and:
					//		- Set its default value to 0
					//		- Rename the option so the user can't override it
					//	- Open the named pipe to wake it up and then close the file to force a
					//	  timeout error.
					//	- Wait a little while until the thread has exited

					IntPtr threadingModeAddr = FindThreadingModeAddress();
					IntPtr timeOutOptionAddr = FindTimeOutOptionAddress();

					if (timeOutOptionAddr == IntPtr.Zero)
						return false;

					// Make sure the thread can exit. If this value is 2, it will never exit.
					if (threadingModeAddr != IntPtr.Zero && *(uint*)threadingModeAddr == 2)
						*(uint*)threadingModeAddr = 1;

					// Set default timeout to 0 and rename timeout option
					FixTimeOutOption(timeOutOptionAddr);

					// Wake up clr!ProfilingAPIAttachServer::ConnectToClient(). We immediately
					// close the pipe so it will fail to read any data. It will then start over
					// again but this time, its timeout value will be 0, and it will fail. Since
					// the thread can now exit, it will exit and close its named pipe.
					using (SafeFileHandle hPipe = CreatePipeFileHandleWait()) {
						if (hPipe == null)
							return false;
						if (hPipe.IsInvalid)
							return false;
					}

					return CreateNamedPipeWait();
				}
				catch { }
				return false;
			}

			private bool CreateNamedPipeWait() {
				int timeLeft = 100;
				const int waitTime = 5;
				while (timeLeft > 0) {
					if (CreateNamedPipe())
						return true;
					Sleep(waitTime);
					timeLeft -= waitTime;
				}
				return CreateNamedPipe();
			}

			[HandleProcessCorruptedStateExceptions, SecurityCritical] // Req'd on .NET 4.0
			private static unsafe void FixTimeOutOption(IntPtr timeOutOptionAddr) {
				if (timeOutOptionAddr == IntPtr.Zero)
					return;

				uint oldProtect;
				VirtualProtect(timeOutOptionAddr, (int)ConfigDWORDInfo_defValue + 4, PAGE_EXECUTE_READWRITE, out oldProtect);
				try {
					// Set default timeout to 0 to make sure it fails immediately
					*(uint*)((byte*)timeOutOptionAddr + ConfigDWORDInfo_defValue) = 0;
				}
				finally {
					VirtualProtect(timeOutOptionAddr, (int)ConfigDWORDInfo_defValue + 4, oldProtect, out oldProtect);
				}

				// Rename the option to make sure the user can't override the value
				char* name = *(char**)((byte*)timeOutOptionAddr + ConfigDWORDInfo_name);
				var nameAddr = new IntPtr(name);
				VirtualProtect(nameAddr, ProfAPIMaxWaitForTriggerMs_name.Length * 2, PAGE_EXECUTE_READWRITE, out oldProtect);
				try {
					var rand = new Random();
					for (int i = 0; i < ProfAPIMaxWaitForTriggerMs_name.Length; i++)
						name[i] = (char)rand.Next(1, ushort.MaxValue);
				}
				finally {
					VirtualProtect(nameAddr, IntPtr.Size, oldProtect, out oldProtect);
				}
			}

			private SafeFileHandle CreatePipeFileHandleWait() {
				int timeLeft = 100;
				const int waitTime = 5;
				while (timeLeft > 0) {
					if (CreateNamedPipe())
						return null;
					SafeFileHandle hFile = CreatePipeFileHandle();
					if (!hFile.IsInvalid)
						return hFile;
					Sleep(waitTime);
					timeLeft -= waitTime;
				}
				return CreatePipeFileHandle();
			}

			private static SafeFileHandle CreatePipeFileHandle() {
				return CreateFile(GetPipeName(), GENERIC_READ | GENERIC_WRITE, 0, IntPtr.Zero, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, IntPtr.Zero);
			}

			private static string GetPipeName() {
				return string.Format(@"\\.\pipe\CPFATP_{0}_v{1}.{2}.{3}",
				                     GetCurrentProcessId(), Environment.Version.Major,
				                     Environment.Version.Minor, Environment.Version.Build);
			}

			private bool CreateNamedPipe() {
				if (profilerPipe != null && !profilerPipe.IsInvalid)
					return true;

				profilerPipe = CreateNamedPipe(GetPipeName(),
				                               FILE_FLAG_OVERLAPPED | PIPE_ACCESS_DUPLEX,
				                               PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE,
				                               1, // nMaxInstances
				                               0x24, // nOutBufferSize
				                               0x338, // nInBufferSize
				                               1000, // nDefaultTimeOut
				                               IntPtr.Zero); // lpSecurityAttributes

				return !profilerPipe.IsInvalid;
			}

			/// <summary>
			///     Finds the address of clr!ProfilingAPIAttachDetach::s_attachThreadingMode
			/// </summary>
			/// <returns>The address or <c>null</c> if none was found</returns>
			[HandleProcessCorruptedStateExceptions, SecurityCritical] // Req'd on .NET 4.0
			private static unsafe IntPtr FindThreadingModeAddress() {
				try {
					// Find this code in clr!ProfilingAPIAttachServer::ExecutePipeRequests()
					//	83 3D XX XX XX XX 02	cmp dword ptr [mem],2
					//	74 / 0F 84 XX			je there
					//	83 E8+r 00 / 85 C0+rr	sub reg,0 / test reg,reg
					//	74 / 0F 84 XX			je there
					//	48+r / FF C8+r			dec reg
					//	74 / 0F 84 XX			je there
					//	48+r / FF C8+r			dec reg

					PEInfo peInfo = PEInfo.GetCLR();
					if (peInfo == null)
						return IntPtr.Zero;

					IntPtr sectionAddr;
					uint sectionSize;
					if (!peInfo.FindSection(".text", out sectionAddr, out sectionSize))
						return IntPtr.Zero;

					var ptr = (byte*)sectionAddr;
					byte* end = (byte*)sectionAddr + sectionSize;
					for (; ptr < end; ptr++) {
						IntPtr addr;

						try {
							//	83 3D XX XX XX XX 02	cmp dword ptr [mem],2
							byte* p = ptr;
							if (*p != 0x83 || p[1] != 0x3D || p[6] != 2)
								continue;
							if (IntPtr.Size == 4)
								addr = new IntPtr((void*)*(uint*)(p + 2));
							else
								addr = new IntPtr(p + 7 + *(int*)(p + 2));
							if (!PEInfo.IsAligned(addr, 4))
								continue;
							if (!peInfo.IsValidImageAddress(addr))
								continue;
							p += 7;

							// 1 = normal lazy thread creation. 2 = thread is always present
							if (*(uint*)addr < 1 || *(uint*)addr > 2)
								continue;
							*(uint*)addr = *(uint*)addr;

							//	74 / 0F 84 XX			je there
							if (!NextJz(ref p))
								continue;

							//	83 E8+r 00 / 85 C0+rr	sub reg,0 / test reg,reg
							SkipRex(ref p);
							if (*p == 0x83 && p[2] == 0) {
								if ((uint)(p[1] - 0xE8) > 7)
									continue;
								p += 3;
							}
							else if (*p == 0x85) {
								int reg = (p[1] >> 3) & 7;
								int rm = p[1] & 7;
								if (reg != rm)
									continue;
								p += 2;
							}
							else
								continue;

							//	74 / 0F 84 XX			je there
							if (!NextJz(ref p))
								continue;

							//	48+r / FF C8+r			dec reg
							if (!SkipDecReg(ref p))
								continue;

							//	74 / 0F 84 XX			je there
							if (!NextJz(ref p))
								continue;

							//	48+r / FF C8+r			dec reg
							if (!SkipDecReg(ref p))
								continue;

							return addr;
						}
						catch { }
					}
				}
				catch { }
				return IntPtr.Zero;
			}

			/// <summary>
			///     Finds the address of clr!EXTERNAL_ProfAPIMaxWaitForTriggerMs
			/// </summary>
			/// <returns>The address or <c>null</c> if none was found</returns>
			[HandleProcessCorruptedStateExceptions, SecurityCritical] // Req'd on .NET 4.0
			private static unsafe IntPtr FindTimeOutOptionAddress() {
				try {
					PEInfo peInfo = PEInfo.GetCLR();
					if (peInfo == null)
						return IntPtr.Zero;

					IntPtr sectionAddr;
					uint sectionSize;
					if (!peInfo.FindSection(".rdata", out sectionAddr, out sectionSize) &&
					    !peInfo.FindSection(".text", out sectionAddr, out sectionSize))
						return IntPtr.Zero;

					var p = (byte*)sectionAddr;
					byte* end = (byte*)sectionAddr + sectionSize;
					for (; p < end; p++) {
						try {
							char* name = *(char**)(p + ConfigDWORDInfo_name);
							if (!PEInfo.IsAligned(new IntPtr(name), 2))
								continue;
							if (!peInfo.IsValidImageAddress(name))
								continue;

							if (!Equals(name, ProfAPIMaxWaitForTriggerMs_name))
								continue;

							return new IntPtr(p);
						}
						catch { }
					}
				}
				catch { }
				return IntPtr.Zero;
			}

			private static unsafe bool Equals(char* s1, string s2) {
				for (int i = 0; i < s2.Length; i++) {
					if (char.ToUpperInvariant(s1[i]) != char.ToUpperInvariant(s2[i]))
						return false;
				}
				return s1[s2.Length] == 0;
			}

			private static unsafe void SkipRex(ref byte* p) {
				if (IntPtr.Size != 8)
					return;
				if (*p >= 0x48 && *p <= 0x4F)
					p++;
			}

			private static unsafe bool SkipDecReg(ref byte* p) {
				SkipRex(ref p);
				if (IntPtr.Size == 4 && *p >= 0x48 && *p <= 0x4F)
					p++;
				else if (*p == 0xFF && p[1] >= 0xC8 && p[1] <= 0xCF)
					p += 2;
				else
					return false;
				return true;
			}

			private static unsafe bool NextJz(ref byte* p) {
				if (*p == 0x74) {
					p += 2;
					return true;
				}

				if (*p == 0x0F && p[1] == 0x84) {
					p += 6;
					return true;
				}

				return false;
			}

			/// <summary>
			///     Finds the attacher thread's thread proc and patches it so it returns immediately.
			/// </summary>
			/// <returns><c>true</c> if it was patched, <c>false</c> otherwise</returns>
			[HandleProcessCorruptedStateExceptions, SecurityCritical] // Req'd on .NET 4.0
			private unsafe bool PatchAttacherThreadProc() {
				IntPtr threadProc = FindAttacherThreadProc();
				if (threadProc == IntPtr.Zero)
					return false;

				var p = (byte*)threadProc;
				uint oldProtect;
				VirtualProtect(new IntPtr(p), 5, PAGE_EXECUTE_READWRITE, out oldProtect);
				try {
					if (IntPtr.Size == 4) {
						// xor eax,eax
						p[0] = 0x33;
						p[1] = 0xC0;
						// retn 4
						p[2] = 0xC2;
						p[3] = 0x04;
						p[4] = 0x00;
					}
					else {
						// xor eax,eax
						p[0] = 0x33;
						p[1] = 0xC0;
						// retn
						p[2] = 0xC3;
					}
				}
				finally {
					VirtualProtect(new IntPtr(p), 5, oldProtect, out oldProtect);
				}
				return true;
			}

			[HandleProcessCorruptedStateExceptions, SecurityCritical] // Req'd on .NET 4.0
			private unsafe IntPtr FindAttacherThreadProc() {
				try {
					PEInfo peInfo = PEInfo.GetCLR();
					if (peInfo == null)
						return IntPtr.Zero;

					IntPtr sectionAddr;
					uint sectionSize;
					if (!peInfo.FindSection(".text", out sectionAddr, out sectionSize))
						return IntPtr.Zero;

					var p = (byte*)sectionAddr;
					byte* start = p;
					byte* end = (byte*)sectionAddr + sectionSize;

					if (IntPtr.Size == 4) {
						for (; p < end; p++) {
							// Find this code:
							//	50+r				push reg
							//	50+r				push reg
							//	50+r				push reg
							//	68 XX XX XX XX		push offset ThreadProc
							//	50+r				push reg
							//	50+r				push reg
							//	FF 15 XX XX XX XX	call dword ptr [mem] // CreateThread()

							byte push = *p;
							if (push < 0x50 || push > 0x57)
								continue;
							if (p[1] != push || p[2] != push || p[8] != push || p[9] != push)
								continue;
							if (p[3] != 0x68)
								continue;
							if (p[10] != 0xFF || p[11] != 0x15)
								continue;

							var threadProc = new IntPtr((void*)*(uint*)(p + 4));
							if (!CheckThreadProc(start, end, threadProc))
								continue;

							return threadProc;
						}
					}
					else {
						for (; p < end; p++) {
							// Find this code:
							//	45 33 C9				xor r9d,r9d
							//	4C 8D 05 XX XX XX XX	lea r8,ThreadProc
							//	33 D2					xor edx,edx
							//	33 C9					xor ecx,ecx
							//	FF 15 XX XX XX XX		call dword ptr [mem] // CreateThread()

							if (*p != 0x45 && p[1] != 0x33 && p[2] != 0xC9)
								continue;
							if (p[3] != 0x4C && p[4] != 0x8D && p[5] != 0x05)
								continue;
							if (p[10] != 0x33 && p[11] != 0xD2)
								continue;
							if (p[12] != 0x33 && p[13] != 0xC9)
								continue;
							if (p[14] != 0xFF && p[15] != 0x15)
								continue;

							var threadProc = new IntPtr(p + 10 + *(int*)(p + 6));
							if (!CheckThreadProc(start, end, threadProc))
								continue;

							return threadProc;
						}
					}
				}
				catch { }

				return IntPtr.Zero;
			}

			/// <summary>
			///     Checks whether it appears to be the profiler attacher thread proc
			/// </summary>
			/// <param name="codeStart">Start of code</param>
			/// <param name="codeEnd">End of code</param>
			/// <param name="threadProc">Possible thread proc</param>
			/// <returns><c>true</c> if it's probably the thread proc, <c>false</c> otherwise</returns>
			[HandleProcessCorruptedStateExceptions, SecurityCritical] // Req'd on .NET 4.0
			private static unsafe bool CheckThreadProc(byte* codeStart, byte* codeEnd, IntPtr threadProc) {
				try {
					var p = (byte*)threadProc;

					// Must be in .text section
					if (p < codeStart || p >= codeEnd)
						return false;

					// It has a constant that is present in the first N bytes
					for (int i = 0; i < 0x20; i++) {
						if (*(uint*)(p + i) == 0x4000)
							return true;
					}
				}
				catch { }
				return false;
			}

			/// <summary>
			///     This code tries to find the CLR 4.0 profiler control block address. It does this
			///     by searching for the code that accesses the profiler status field.
			/// </summary>
			/// <returns><c>true</c> if it was found, <c>false</c> otherwise</returns>
			[HandleProcessCorruptedStateExceptions, SecurityCritical] // Req'd on .NET 4.0
			private unsafe bool FindProfilerControlBlock() {
				// Record each hit here and pick the one with the most hits
				var addrCounts = new Dictionary<IntPtr, int>();
				try {
					PEInfo peInfo = PEInfo.GetCLR();
					if (peInfo == null)
						return false;

					IntPtr sectionAddr;
					uint sectionSize;
					if (!peInfo.FindSection(".text", out sectionAddr, out sectionSize))
						return false;

					const int MAX_COUNTS = 50;
					var p = (byte*)sectionAddr;
					byte* end = (byte*)sectionAddr + sectionSize;
					for (; p < end; p++) {
						IntPtr addr;

						// A1 xx xx xx xx		mov eax,[mem]
						// 83 F8 04				cmp eax,4
						if (*p == 0xA1 && p[5] == 0x83 && p[6] == 0xF8 && p[7] == 0x04) {
							if (IntPtr.Size == 4)
								addr = new IntPtr((void*)*(uint*)(p + 1));
							else
								addr = new IntPtr(p + 5 + *(int*)(p + 1));
						}
							// 8B 05 xx xx xx xx	mov eax,[mem]
							// 83 F8 04				cmp eax,4
						else if (*p == 0x8B && p[1] == 0x05 && p[6] == 0x83 && p[7] == 0xF8 && p[8] == 0x04) {
							if (IntPtr.Size == 4)
								addr = new IntPtr((void*)*(uint*)(p + 2));
							else
								addr = new IntPtr(p + 6 + *(int*)(p + 2));
						}
							// 83 3D XX XX XX XX 04	cmp dword ptr [mem],4
						else if (*p == 0x83 && p[1] == 0x3D && p[6] == 0x04) {
							if (IntPtr.Size == 4)
								addr = new IntPtr((void*)*(uint*)(p + 2));
							else
								addr = new IntPtr(p + 7 + *(int*)(p + 2));
						}
						else
							continue;

						if (!PEInfo.IsAligned(addr, 4))
							continue;
						if (!peInfo.IsValidImageAddress(addr, 4))
							continue;

						// Valid values are 0-4. 4 being attached.
						try {
							if (*(uint*)addr > 4)
								continue;
							*(uint*)addr = *(uint*)addr;
						}
						catch {
							continue;
						}

						int count = 0;
						addrCounts.TryGetValue(addr, out count);
						count++;
						addrCounts[addr] = count;
						if (count >= MAX_COUNTS)
							break;
					}
				}
				catch { }
				IntPtr foundAddr = GetMax(addrCounts, 5);
				if (foundAddr == IntPtr.Zero)
					return false;

				profilerControlBlock = new IntPtr((byte*)foundAddr - (IntPtr.Size + 4));
				return true;
			}

			public override unsafe void PreventActiveProfilerFromReceivingProfilingMessages() {
				if (profilerControlBlock == IntPtr.Zero)
					return;
				*(uint*)((byte*)profilerControlBlock + IntPtr.Size + 4) = 0;
			}

		}

	}
}


================================================
File: Confuser.Runtime/antinet/HandleProcessCorruptedStateExceptionsAttribute.cs
================================================
ï»¿using System;

namespace System.Runtime.ExceptionServices {
	[AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
	internal class HandleProcessCorruptedStateExceptionsAttribute : Attribute {

	}
}


================================================
File: Confuser.Runtime/antinet/PEInfo.cs
================================================
ï»¿/*
 * PE helper code. Written by de4dot@gmail.com
 * This code is in the public domain.
 * Official site: https://github.com/0xd4d/antinet
 */

using System;
using System.Runtime.InteropServices;
using System.Text;

namespace Confuser.Runtime {
	static partial class AntiDebugAntinet {

		private class PEInfo {

			private readonly IntPtr imageBase;
			private IntPtr imageEnd;
			private int numSects;
			private IntPtr sectionsAddr;

			/// <summary>
			///     Constructor
			/// </summary>
			/// <param name="addr">Address of a PE image</param>
			public PEInfo(IntPtr addr) {
				imageBase = addr;
				Init();
			}

			[DllImport("kernel32", CharSet = CharSet.Auto)]
			private static extern IntPtr GetModuleHandle(string name);

			/// <summary>
			///     Creates a <see cref="PEInfo" /> instance loaded from the CLR (clr.dll / mscorwks.dll)
			/// </summary>
			/// <returns>The new instance or <c>null</c> if we failed</returns>
			public static PEInfo GetCLR() {
				IntPtr clrAddr = GetCLRAddress();
				if (clrAddr == IntPtr.Zero)
					return null;
				return new PEInfo(clrAddr);
			}

			private static IntPtr GetCLRAddress() {
				if (Environment.Version.Major == 2)
					return GetModuleHandle("mscorwks");
				return GetModuleHandle("clr");
			}

			private unsafe void Init() {
				var p = (byte*)imageBase;
				p += *(uint*)(p + 0x3C); // Get NT headers
				p += 4 + 2; // Skip magic + machine
				numSects = *(ushort*)p;
				p += 2 + 0x10; // Skip the rest of file header
				bool is32 = *(ushort*)p == 0x010B;
				uint sizeOfImage = *(uint*)(p + 0x38);
				imageEnd = new IntPtr((byte*)imageBase + sizeOfImage);
				p += is32 ? 0x60 : 0x70; // Skip optional header
				p += 0x10 * 8; // Skip data dirs
				sectionsAddr = new IntPtr(p);
			}

			/// <summary>
			///     Checks whether the address is within the image
			/// </summary>
			/// <param name="addr">Address</param>
			public unsafe bool IsValidImageAddress(IntPtr addr) {
				return IsValidImageAddress((void*)addr, 0);
			}

			/// <summary>
			///     Checks whether the address is within the image
			/// </summary>
			/// <param name="addr">Address</param>
			/// <param name="size">Number of bytes</param>
			public unsafe bool IsValidImageAddress(IntPtr addr, uint size) {
				return IsValidImageAddress((void*)addr, size);
			}

			/// <summary>
			///     Checks whether the address is within the image
			/// </summary>
			/// <param name="addr">Address</param>
			public unsafe bool IsValidImageAddress(void* addr) {
				return IsValidImageAddress(addr, 0);
			}

			/// <summary>
			///     Checks whether the address is within the image
			/// </summary>
			/// <param name="addr">Address</param>
			/// <param name="size">Number of bytes</param>
			public unsafe bool IsValidImageAddress(void* addr, uint size) {
				if (addr < (void*)imageBase)
					return false;
				if (addr >= (void*)imageEnd)
					return false;

				if (size != 0) {
					if ((byte*)addr + size < addr)
						return false;
					if ((byte*)addr + size > (void*)imageEnd)
						return false;
				}

				return true;
			}

			/// <summary>
			///     Finds a section
			/// </summary>
			/// <param name="name">Name of section</param>
			/// <param name="sectionStart">Updated with start address of section</param>
			/// <param name="sectionSize">Updated with size of section</param>
			/// <returns><c>true</c> on success, <c>false</c> on failure</returns>
			public unsafe bool FindSection(string name, out IntPtr sectionStart, out uint sectionSize) {
				byte[] nameBytes = Encoding.UTF8.GetBytes(name + "\0\0\0\0\0\0\0\0");
				for (int i = 0; i < numSects; i++) {
					byte* p = (byte*)sectionsAddr + i * 0x28;
					if (!CompareSectionName(p, nameBytes))
						continue;

					sectionStart = new IntPtr((byte*)imageBase + *(uint*)(p + 12));
					sectionSize = Math.Max(*(uint*)(p + 8), *(uint*)(p + 16));
					return true;
				}

				sectionStart = IntPtr.Zero;
				sectionSize = 0;
				return false;
			}

			private static unsafe bool CompareSectionName(byte* sectionName, byte[] nameBytes) {
				for (int i = 0; i < 8; i++) {
					if (*sectionName != nameBytes[i])
						return false;
					sectionName++;
				}
				return true;
			}

			/// <summary>
			///     Checks whether a pointer is aligned
			/// </summary>
			/// <param name="addr">Address</param>
			public static bool IsAlignedPointer(IntPtr addr) {
				return ((int)addr.ToInt64() & (IntPtr.Size - 1)) == 0;
			}

			/// <summary>
			///     Checks whether a pointer is aligned
			/// </summary>
			/// <param name="addr">Address</param>
			/// <param name="alignment">Alignment</param>
			public static bool IsAligned(IntPtr addr, uint alignment) {
				return ((uint)addr.ToInt64() & (alignment - 1)) == 0;
			}

		}

	}
}


================================================
File: ConfuserEx/App.xaml
================================================
<Application x:Class="ConfuserEx.App" xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" StartupUri="MainWindow.xaml">
    <Application.Resources>
        <ResourceDictionary>
            <ResourceDictionary.MergedDictionaries>
                <ResourceDictionary Source="Skin.xaml" />
                <ResourceDictionary Source="Views.xaml" />
            </ResourceDictionary.MergedDictionaries>
            <BitmapImage x:Key="New" UriSource="Resources/New.png" />
            <BitmapImage x:Key="Open" UriSource="Resources/Open.png" />
            <BitmapImage x:Key="Save" UriSource="Resources/Save.png" />
            <BitmapImage x:Key="Tools" UriSource="Resources/Tools.png" />
            <BitmapImage x:Key="Decode" UriSource="Resources/Decode.png" />
            <BitmapImage x:Key="Error" UriSource="Resources/Error.png" />
            <BitmapImage x:Key="TeamLogo" UriSource="Resources/TeamLogo.png" />
            <FontFamily x:Key="FontAwesome">Resources/#FontAwesome</FontFamily>
        </ResourceDictionary>
    </Application.Resources>
</Application>


================================================
File: ConfuserEx/App.xaml.cs
================================================
ï»¿using System;
using System.Windows;

namespace ConfuserEx {
	public partial class App : Application { }
}


================================================
File: ConfuserEx/BoolToVisibilityConverter.cs
================================================
ï»¿using System;
using System.Diagnostics;
using System.Globalization;
using System.Windows;
using System.Windows.Data;

namespace ConfuserEx {
	internal class BoolToVisibilityConverter : IValueConverter {
		public static readonly BoolToVisibilityConverter Instance = new BoolToVisibilityConverter();
		BoolToVisibilityConverter() { }

		public object Convert(object value, Type targetType, object parameter, CultureInfo culture) {
			Debug.Assert(value is bool);
			Debug.Assert(targetType == typeof(Visibility));
			return (bool)value ? Visibility.Visible : Visibility.Collapsed;
		}

		public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture) {
			throw new NotSupportedException();
		}
	}
}


================================================
File: ConfuserEx/BrushToColorConverter.cs
================================================
ï»¿using System;
using System.Globalization;
using System.Windows.Data;
using System.Windows.Media;

namespace ConfuserEx {
	public class BrushToColorConverter : IValueConverter {
		public static readonly BrushToColorConverter Instance = new BrushToColorConverter();
		BrushToColorConverter() { }

		public object Convert(object value, Type targetType, object parameter, CultureInfo culture) {
			var brush = value as SolidColorBrush;
			if (brush != null)
				return brush.Color;
			return null;
		}

		public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture) {
			throw new NotImplementedException();
		}
	}
}


================================================
File: ConfuserEx/CompComboBox.xaml
================================================
ï»¿<UserControl x:Class="ConfuserEx.CompComboBox"
             x:Name="Root"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:core="clr-namespace:Confuser.Core;assembly=Confuser.Core">
    <ComboBox ItemsSource="{Binding Components, ElementName=Root}"
              SelectedItem="{Binding SelectedComponent, ElementName=Root}"
              DisplayMemberPath="Id" FontFamily="Consolas"
              ScrollViewer.CanContentScroll="False">
        <ComboBox.ItemContainerStyle>
            <Style TargetType="{x:Type ComboBoxItem}">
                <Setter Property="OverridesDefaultStyle" Value="True" />
                <Setter Property="Template">
                    <Setter.Value>
                        <ControlTemplate TargetType="{x:Type ComboBoxItem}">
                            <Border Width="350" BorderBrush="{StaticResource Foreground}"
                                    Background="{TemplateBinding Background}" BorderThickness="1" Margin="5">
                                <Grid Background="Transparent">
                                    <Grid.RowDefinitions>
                                        <RowDefinition />
                                        <RowDefinition />
                                    </Grid.RowDefinitions>
                                    <Label Grid.Row="0" Content="{Binding Name}" HorizontalAlignment="Left" />
                                    <Label Grid.Row="0" Content="{Binding Id}" HorizontalAlignment="Right" />
                                    <Label Grid.Row="1">
                                        <TextBlock Text="{Binding Description}" TextTrimming="WordEllipsis"
                                                   FontSize="10" Foreground="Gray" />
                                    </Label>
                                </Grid>
                            </Border>
                            <ControlTemplate.Triggers>
                                <Trigger Property="IsMouseOver" Value="True">
                                    <Setter Property="Background" Value="{StaticResource HighlightBackground}" />
                                    <Setter Property="Foreground" Value="{StaticResource SelectedForeground}" />
                                </Trigger>
                            </ControlTemplate.Triggers>
                        </ControlTemplate>
                    </Setter.Value>
                </Setter>
            </Style>
        </ComboBox.ItemContainerStyle>
    </ComboBox>
</UserControl>


================================================
File: ConfuserEx/CompComboBox.xaml.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Windows;
using System.Windows.Controls;
using Confuser.Core;

namespace ConfuserEx {
	public partial class CompComboBox : UserControl {
		public static readonly DependencyProperty ComponentsProperty = DependencyProperty.Register("Components", typeof(IEnumerable<ConfuserComponent>), typeof(CompComboBox), new UIPropertyMetadata(null));
		public static readonly DependencyProperty SelectedComponentProperty = DependencyProperty.Register("SelectedComponent", typeof(ConfuserComponent), typeof(CompComboBox), new UIPropertyMetadata(null));
		public static readonly DependencyProperty ArgumentsProperty = DependencyProperty.Register("Arguments", typeof(Dictionary<string, string>), typeof(CompComboBox), new UIPropertyMetadata(null));

		public CompComboBox() {
			InitializeComponent();
		}

		public IEnumerable<ConfuserComponent> Components {
			get { return (IEnumerable<ConfuserComponent>)GetValue(ComponentsProperty); }
			set { SetValue(ComponentsProperty, value); }
		}

		public ConfuserComponent SelectedComponent {
			get { return (ConfuserComponent)GetValue(SelectedComponentProperty); }
			set { SetValue(SelectedComponentProperty, value); }
		}

		public Dictionary<string, string> Arguments {
			get { return (Dictionary<string, string>)GetValue(ArgumentsProperty); }
			set { SetValue(ArgumentsProperty, value); }
		}
	}
}


================================================
File: ConfuserEx/ComponentConverter.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Windows;
using System.Windows.Data;
using Confuser.Core;

namespace ConfuserEx {
	internal class ComponentConverter : Freezable, IValueConverter {
		public static readonly DependencyProperty ComponentsProperty = DependencyProperty.Register("Components", typeof(IList<ConfuserComponent>), typeof(ComponentConverter), new UIPropertyMetadata(null));

		public IList<ConfuserComponent> Components {
			get { return (IList<ConfuserComponent>)GetValue(ComponentsProperty); }
			set { SetValue(ComponentsProperty, value); }
		}

		public object Convert(object value, Type targetType, object parameter, CultureInfo culture) {
			Debug.Assert(value is string || value == null);
			Debug.Assert(targetType == typeof(ConfuserComponent));
			Debug.Assert(Components != null);

			if (value == null) return null;
			return Components.Single(comp => comp.Id == (string)value);
		}

		public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture) {
			Debug.Assert(value is ConfuserComponent || value == null);
			Debug.Assert(targetType == typeof(string));

			if (value == null) return null;
			return ((ConfuserComponent)value).Id;
		}

		protected override Freezable CreateInstanceCore() {
			return new ComponentConverter();
		}
	}
}


================================================
File: ConfuserEx/ComponentDiscovery.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Reflection;
using Confuser.Core;

namespace ConfuserEx {
	internal class ComponentDiscovery {
		static void CrossDomainLoadComponents() {
			var ctx = (CrossDomainContext)AppDomain.CurrentDomain.GetData("ctx");
			// Initialize the version resolver callback
			ConfuserEngine.Version.ToString();

			Assembly assembly = Assembly.LoadFile(ctx.PluginPath);
			foreach (var module in assembly.GetLoadedModules())
				foreach (var i in module.GetTypes()) {
					if (i.IsAbstract || !PluginDiscovery.HasAccessibleDefConstructor(i))
						continue;

					if (typeof(Protection).IsAssignableFrom(i)) {
						var prot = (Protection)Activator.CreateInstance(i);
						ctx.AddProtection(Info.FromComponent(prot, ctx.PluginPath));
					}
					else if (typeof(Packer).IsAssignableFrom(i)) {
						var packer = (Packer)Activator.CreateInstance(i);
						ctx.AddPacker(Info.FromComponent(packer, ctx.PluginPath));
					}
				}
		}

		public static void LoadComponents(IList<ConfuserComponent> protections, IList<ConfuserComponent> packers, string pluginPath) {
			var ctx = new CrossDomainContext(protections, packers, pluginPath);
			AppDomain appDomain = AppDomain.CreateDomain("");
			appDomain.SetData("ctx", ctx);
			appDomain.DoCallBack(CrossDomainLoadComponents);
			AppDomain.Unload(appDomain);
		}

		public static void RemoveComponents(IList<ConfuserComponent> protections, IList<ConfuserComponent> packers, string pluginPath) {
			protections.RemoveWhere(comp => comp is InfoComponent && ((InfoComponent)comp).info.path == pluginPath);
			packers.RemoveWhere(comp => comp is InfoComponent && ((InfoComponent)comp).info.path == pluginPath);
		}

		class CrossDomainContext : MarshalByRefObject {
			readonly IList<ConfuserComponent> packers;
			readonly string pluginPath;
			readonly IList<ConfuserComponent> protections;

			public CrossDomainContext(IList<ConfuserComponent> protections, IList<ConfuserComponent> packers, string pluginPath) {
				this.protections = protections;
				this.packers = packers;
				this.pluginPath = pluginPath;
			}

			public string PluginPath {
				get { return pluginPath; }
			}

			public void AddProtection(Info info) {
				foreach (var comp in protections) {
					if (comp.Id == info.id)
						return;
				}
				protections.Add(new InfoComponent(info));
			}

			public void AddPacker(Info info) {
				foreach (var comp in packers) {
					if (comp.Id == info.id)
						return;
				}
				packers.Add(new InfoComponent(info));
			}
		}

		[Serializable]
		class Info {
			public string desc;
			public string fullId;
			public string id;
			public string name;
			public string path;

			public static Info FromComponent(ConfuserComponent component, string pluginPath) {
				var ret = new Info();
				ret.name = component.Name;
				ret.desc = component.Description;
				ret.id = component.Id;
				ret.fullId = component.FullId;
				ret.path = pluginPath;
				return ret;
			}
		}

		class InfoComponent : ConfuserComponent {
			public readonly Info info;

			public InfoComponent(Info info) {
				this.info = info;
			}

			public override string Name {
				get { return info.name; }
			}

			public override string Description {
				get { return info.desc; }
			}

			public override string Id {
				get { return info.id; }
			}

			public override string FullId {
				get { return info.fullId; }
			}

			protected override void Initialize(ConfuserContext context) {
				throw new NotSupportedException();
			}

			protected override void PopulatePipeline(ProtectionPipeline pipeline) {
				throw new NotSupportedException();
			}
		}
	}
}


================================================
File: ConfuserEx/ConfuserEx.csproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProductVersion>8.0.30703</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{B5205EBA-EC32-4C53-86A0-FAEEE7393EC0}</ProjectGuid>
    <OutputType>WinExe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>ConfuserEx</RootNamespace>
    <AssemblyName>ConfuserEx</AssemblyName>
    <FileAlignment>512</FileAlignment>
    <ProjectTypeGuids>{60dc8134-eba5-43b8-bcc9-bb4bc16c2548};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}</ProjectTypeGuids>
    <WarningLevel>4</WarningLevel>
    <Utf8Output>true</Utf8Output>
    <SolutionDir Condition="$(SolutionDir) == '' Or $(SolutionDir) == '*Undefined*'">..\</SolutionDir>
    <RestorePackages>true</RestorePackages>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|AnyCPU'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>..\Debug\bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>AnyCPU</PlatformTarget>
    <ErrorReport>prompt</ErrorReport>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|AnyCPU'">
    <OutputPath>..\Release\bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>AnyCPU</PlatformTarget>
    <ErrorReport>prompt</ErrorReport>
  </PropertyGroup>
  <PropertyGroup>
    <ApplicationIcon>ConfuserEx.ico</ApplicationIcon>
  </PropertyGroup>
  <PropertyGroup>
    <SignAssembly>true</SignAssembly>
  </PropertyGroup>
  <PropertyGroup>
    <AssemblyOriginatorKeyFile>..\ConfuserEx.snk</AssemblyOriginatorKeyFile>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="GalaSoft.MvvmLight.Extras.WPF4">
      <HintPath>..\packages\MvvmLightLibs.4.3.31.1\lib\net40\GalaSoft.MvvmLight.Extras.WPF4.dll</HintPath>
    </Reference>
    <Reference Include="GalaSoft.MvvmLight.WPF4">
      <HintPath>..\packages\MvvmLightLibs.4.3.31.1\lib\net40\GalaSoft.MvvmLight.WPF4.dll</HintPath>
    </Reference>
    <Reference Include="Microsoft.Practices.ServiceLocation">
      <HintPath>..\packages\CommonServiceLocator.1.2\lib\portable-windows8+net40+sl5+windowsphone8\Microsoft.Practices.ServiceLocation.dll</HintPath>
    </Reference>
    <Reference Include="Ookii.Dialogs.Wpf">
      <HintPath>..\deps\Ookii.Dialogs.Wpf.dll</HintPath>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Windows.Interactivity, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">
      <HintPath>..\packages\MvvmLightLibs.4.3.31.1\lib\net40\System.Windows.Interactivity.dll</HintPath>
    </Reference>
    <Reference Include="System.Xaml" />
    <Reference Include="System.Xml" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="WindowsBase" />
    <Reference Include="PresentationCore" />
    <Reference Include="PresentationFramework" />
  </ItemGroup>
  <ItemGroup>
    <ApplicationDefinition Include="App.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </ApplicationDefinition>
    <Compile Include="..\GlobalAssemblyInfo.cs">
      <Link>Properties\GlobalAssemblyInfo.cs</Link>
    </Compile>
    <Compile Include="BrushToColorConverter.cs" />
    <Compile Include="CompComboBox.xaml.cs">
      <DependentUpon>CompComboBox.xaml</DependentUpon>
    </Compile>
    <Compile Include="ComponentConverter.cs" />
    <Compile Include="ComponentDiscovery.cs" />
    <Compile Include="BoolToVisibilityConverter.cs" />
    <Compile Include="EnumValuesExtension.cs" />
    <Compile Include="FileDragDrop.cs" />
    <Compile Include="InvertBoolConverter.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="Skin.cs" />
    <Compile Include="StackTraceDecoder.xaml.cs">
      <DependentUpon>StackTraceDecoder.xaml</DependentUpon>
    </Compile>
    <Compile Include="ViewModel\Project\ProjectRuleVM.cs" />
    <Compile Include="ViewModel\Project\ProjectSettingVM.cs" />
    <Compile Include="ViewModel\StringItem.cs" />
    <Compile Include="ViewModel\UI\AboutTabVM.cs" />
    <Compile Include="ViewModel\UI\AppVM.cs" />
    <Compile Include="ViewModel\IViewModel.cs" />
    <Compile Include="ViewModel\Project\ProjectModuleVM.cs" />
    <Compile Include="ViewModel\UI\ProjectTabVM.cs" />
    <Compile Include="ViewModel\Project\ProjectVM.cs" />
    <Compile Include="ViewModel\UI\ProtectTabVM.cs" />
    <Compile Include="ViewModel\UI\SettingsTabVM.cs" />
    <Compile Include="ViewModel\UI\TabViewModel.cs" />
    <Compile Include="ViewModel\Utils.cs" />
    <Compile Include="ViewModel\ViewModelBase.cs" />
    <Compile Include="Views\ProjectModuleView.xaml.cs">
      <DependentUpon>ProjectModuleView.xaml</DependentUpon>
    </Compile>
    <Compile Include="Views\ProjectRuleView.xaml.cs">
      <DependentUpon>ProjectRuleView.xaml</DependentUpon>
    </Compile>
    <Compile Include="Views\ProjectTabAdvancedView.xaml.cs">
      <DependentUpon>ProjectTabAdvancedView.xaml</DependentUpon>
    </Compile>
    <Page Include="CompComboBox.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="MainWindow.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </Page>
    <Compile Include="App.xaml.cs">
      <DependentUpon>App.xaml</DependentUpon>
      <SubType>Code</SubType>
    </Compile>
    <Compile Include="MainWindow.xaml.cs">
      <DependentUpon>MainWindow.xaml</DependentUpon>
      <SubType>Code</SubType>
    </Compile>
    <Page Include="Skin.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </Page>
    <Page Include="StackTraceDecoder.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Views.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </Page>
    <Page Include="Views\AboutTabView.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </Page>
    <Page Include="Views\ProtectTabView.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </Page>
    <Page Include="Views\ProjectRuleView.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Views\SettingsTabView.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </Page>
    <Page Include="Views\ProjectModuleView.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Views\ProjectTabAdvancedView.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Views\ProjectTabView.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </Page>
  </ItemGroup>
  <ItemGroup>
    <AppDesigner Include="Properties\" />
  </ItemGroup>
  <ItemGroup>
    <Resource Include="ConfuserEx.ico" />
  </ItemGroup>
  <ItemGroup>
    <None Include="..\ConfuserEx.snk">
      <Link>Properties\ConfuserEx.snk</Link>
    </None>
    <None Include="app.config">
      <SubType>Designer</SubType>
    </None>
    <None Include="packages.config" />
    <None Include="Resources\CREDITS" />
    <Resource Include="Resources\FontAwesome.otf" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\Confuser.Core\Confuser.Core.csproj">
      <Project>{BEB67A6E-4C54-4DE5-8C6B-2C12F44A7B92}</Project>
      <Name>Confuser.Core</Name>
    </ProjectReference>
    <ProjectReference Include="..\Confuser.DynCipher\Confuser.DynCipher.csproj">
      <Project>{E832E9B8-2158-4FC0-89A1-56C6ECC10F6B}</Project>
      <Name>Confuser.DynCipher</Name>
    </ProjectReference>
    <ProjectReference Include="..\Confuser.Protections\Confuser.Protections.csproj">
      <Project>{3EAB01B5-9B49-48D8-BFA1-5493B26CCB71}</Project>
      <Name>Confuser.Protections</Name>
    </ProjectReference>
    <ProjectReference Include="..\Confuser.Renamer\Confuser.Renamer.csproj">
      <Project>{862DA0DA-52E1-47CD-B9C2-46B106031B28}</Project>
      <Name>Confuser.Renamer</Name>
    </ProjectReference>
    <ProjectReference Include="..\Confuser.Runtime\Confuser.Runtime.csproj">
      <Project>{A45C184F-F98F-4258-A928-BFF437034791}</Project>
      <Name>Confuser.Runtime</Name>
    </ProjectReference>
    <ProjectReference Include="..\dnlib\src\dnlib.csproj">
      <Project>{FDFC1237-143F-4919-8318-4926901F4639}</Project>
      <Name>dnlib</Name>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup>
    <Resource Include="Resources\Decode.png" />
    <Resource Include="Resources\New.png" />
    <Resource Include="Resources\Open.png" />
    <Resource Include="Resources\Save.png" />
    <Resource Include="Resources\Tools.png" />
  </ItemGroup>
  <ItemGroup>
    <Resource Include="Resources\Error.png" />
  </ItemGroup>
  <ItemGroup>
    <Resource Include="Resources\TeamLogo.png" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <Import Project="$(SolutionDir)\.nuget\NuGet.targets" Condition="Exists('$(SolutionDir)\.nuget\NuGet.targets')" />
  <Target Name="EnsureNuGetPackageBuildImports" BeforeTargets="PrepareForBuild">
    <PropertyGroup>
      <ErrorText>This project references NuGet package(s) that are missing on this computer. Enable NuGet Package Restore to download them.  For more information, see http://go.microsoft.com/fwlink/?LinkID=322105. The missing file is {0}.</ErrorText>
    </PropertyGroup>
    <Error Condition="!Exists('$(SolutionDir)\.nuget\NuGet.targets')" Text="$([System.String]::Format('$(ErrorText)', '$(SolutionDir)\.nuget\NuGet.targets'))" />
  </Target>
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>


================================================
File: ConfuserEx/EnumValuesExtension.cs
================================================
ï»¿using System;
using System.Windows.Markup;

namespace ConfuserEx {
	public class EnumValuesExtension : MarkupExtension {
		readonly Type enumType;

		public EnumValuesExtension(Type enumType) {
			this.enumType = enumType;
		}

		public override object ProvideValue(IServiceProvider serviceProvider) {
			return Enum.GetValues(enumType);
		}
	}
}


================================================
File: ConfuserEx/FileDragDrop.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using ConfuserEx.ViewModel;
using GalaSoft.MvvmLight.Command;

namespace ConfuserEx {
	public class FileDragDrop {
		public static readonly DependencyProperty CommandProperty =
			DependencyProperty.RegisterAttached("Command", typeof(ICommand), typeof(FileDragDrop), new UIPropertyMetadata(null, OnCommandChanged));

		public static ICommand FileCmd = new DragDropCommand(
			data => {
				Debug.Assert(data.Item2.GetDataPresent(DataFormats.FileDrop));
				if (data.Item1 is TextBox) {
					string file = ((string[])data.Item2.GetData(DataFormats.FileDrop))[0];
					Debug.Assert(File.Exists(file));
					((TextBox)data.Item1).Text = file;
				}
				else if (data.Item1 is ListBox) {
					var files = (string[])data.Item2.GetData(DataFormats.FileDrop);
					Debug.Assert(files.All(file => File.Exists(file)));
					var list = (IList<StringItem>)((ListBox)data.Item1).ItemsSource;
					foreach (string file in files)
						list.Add(new StringItem(file));
				}
				else
					throw new NotSupportedException();
			}, data => {
				if (!data.Item2.GetDataPresent(DataFormats.FileDrop))
					return false;
				return ((string[])data.Item2.GetData(DataFormats.FileDrop)).All(file => File.Exists(file));
			});


		public static ICommand DirectoryCmd = new DragDropCommand(
			data => {
				Debug.Assert(data.Item2.GetDataPresent(DataFormats.FileDrop));
				if (data.Item1 is TextBox) {
					string dir = ((string[])data.Item2.GetData(DataFormats.FileDrop))[0];
					Debug.Assert(Directory.Exists(dir));
					((TextBox)data.Item1).Text = dir;
				}
				else if (data.Item1 is ListBox) {
					var dirs = (string[])data.Item2.GetData(DataFormats.FileDrop);
					Debug.Assert(dirs.All(dir => Directory.Exists(dir)));
					var list = (IList<StringItem>)((ListBox)data.Item1).ItemsSource;
					foreach (string dir in dirs)
						list.Add(new StringItem(dir));
				}
				else
					throw new NotSupportedException();
			}, data => {
				if (!data.Item2.GetDataPresent(DataFormats.FileDrop))
					return false;
				return ((string[])data.Item2.GetData(DataFormats.FileDrop)).All(dir => Directory.Exists(dir));
			});

		public static ICommand GetCommand(DependencyObject obj) {
			return (ICommand)obj.GetValue(CommandProperty);
		}

		public static void SetCommand(DependencyObject obj, ICommand value) {
			obj.SetValue(CommandProperty, value);
		}

		static void OnCommandChanged(DependencyObject d, DependencyPropertyChangedEventArgs e) {
			var elem = (UIElement)d;
			if (e.NewValue != null) {
				elem.AllowDrop = true;
				elem.PreviewDragOver += OnDragOver;
				elem.PreviewDrop += OnDrop;
			}
			else {
				elem.AllowDrop = false;
				elem.PreviewDragOver -= OnDragOver;
				elem.PreviewDrop -= OnDrop;
			}
		}

		static void OnDragOver(object sender, DragEventArgs e) {
			ICommand cmd = GetCommand((DependencyObject)sender);
			e.Effects = DragDropEffects.None;
			if (cmd is DragDropCommand) {
				if (cmd.CanExecute(Tuple.Create((UIElement)sender, e.Data)))
					e.Effects = DragDropEffects.Link;
			}
			else {
				if (cmd.CanExecute(e.Data))
					e.Effects = DragDropEffects.Link;
			}
			e.Handled = true;
		}

		static void OnDrop(object sender, DragEventArgs e) {
			ICommand cmd = GetCommand((DependencyObject)sender);
			if (cmd is DragDropCommand) {
				if (cmd.CanExecute(Tuple.Create((UIElement)sender, e.Data)))
					cmd.Execute(Tuple.Create((UIElement)sender, e.Data));
			}
			else {
				if (cmd.CanExecute(e.Data))
					cmd.Execute(e.Data);
			}
			e.Handled = true;
		}


		class DragDropCommand : RelayCommand<Tuple<UIElement, IDataObject>> {
			public DragDropCommand(Action<Tuple<UIElement, IDataObject>> execute, Func<Tuple<UIElement, IDataObject>, bool> canExecute)
				: base(execute, canExecute) { }
		}
	}
}


================================================
File: ConfuserEx/InvertBoolConverter.cs
================================================
ï»¿using System;
using System.Diagnostics;
using System.Globalization;
using System.Windows.Data;

namespace ConfuserEx {
	internal class InvertBoolConverter : IValueConverter {
		public static readonly InvertBoolConverter Instance = new InvertBoolConverter();
		InvertBoolConverter() { }

		public object Convert(object value, Type targetType, object parameter, CultureInfo culture) {
			Debug.Assert(value is bool);
			Debug.Assert(targetType == typeof(bool));
			return !(bool)value;
		}

		public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture) {
			throw new NotSupportedException();
		}
	}
}


================================================
File: ConfuserEx/MainWindow.xaml
================================================
ï»¿<Window x:Class="ConfuserEx.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:local="clr-namespace:ConfuserEx"
        Title="{Binding Title}" Width="800" Height="600" Style="{StaticResource DarkWindow}">
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto" />
            <RowDefinition Height="*" />
        </Grid.RowDefinitions>
        <ToolBar Grid.Row="0" Grid.ColumnSpan="2" ToolBarTray.IsLocked="True" ToolBar.OverflowMode="Never"
                 KeyboardNavigation.TabNavigation="Continue">
            <Button Command="{Binding NewProject}">
                <StackPanel Orientation="Horizontal">
                    <Image Source="{StaticResource New}" Margin="0,0,4,0" />
                    <TextBlock Text="New project" VerticalAlignment="Center" />
                </StackPanel>
            </Button>
            <Button Command="{Binding OpenProject}">
                <StackPanel Orientation="Horizontal">
                    <Image Source="{StaticResource Open}" Margin="0,0,4,0" />
                    <TextBlock Text="Open project" VerticalAlignment="Center" />
                </StackPanel>
            </Button>
            <Button Command="{Binding SaveProject}">
                <StackPanel Orientation="Horizontal">
                    <Image Source="{StaticResource Save}" Margin="0,0,4,0" />
                    <TextBlock Text="Save project" VerticalAlignment="Center" />
                </StackPanel>
            </Button>
            <Button ContextMenuService.IsEnabled="False" Click="OpenMenu">
                <StackPanel Orientation="Horizontal">
                    <Image Source="{StaticResource Tools}" Margin="0,0,4,0" />
                    <TextBlock Text="Tools" VerticalAlignment="Center" />
                    <Path Data="M 0.5 4 L 6.5 4 L 3.5 9 Z" Fill="{StaticResource Foreground}" Margin="4,0,0,0"
                          VerticalAlignment="Center" />
                </StackPanel>
                <Button.ContextMenu>
                    <ContextMenu
                        DataContext="{Binding PlacementTarget.DataContext, RelativeSource={RelativeSource Self}}">
                        <MenuItem Header="Stack Trace Decoder" Command="{Binding Decode}">
                            <MenuItem.Icon>
                                <Image Source="{StaticResource Decode}" />
                            </MenuItem.Icon>
                        </MenuItem>
                    </ContextMenu>
                </Button.ContextMenu>
            </Button>
        </ToolBar>
        <TabControl Grid.Row="1" Grid.ColumnSpan="2" Margin="10" ItemsSource="{Binding Tabs}" Padding="5"
                    SelectedIndex="0" local:Skin.TabsDisabled="{Binding NavigationDisabled}">
            <TabControl.ItemContainerStyle>
                <Style TargetType="{x:Type TabItem}" BasedOn="{StaticResource {x:Type TabItem}}">
                    <Setter Property="Width" Value="80" />
                    <Setter Property="Header" Value="{Binding Header}" />
                </Style>
            </TabControl.ItemContainerStyle>
        </TabControl>
    </Grid>
</Window>


================================================
File: ConfuserEx/MainWindow.xaml.cs
================================================
ï»¿using System;
using System.ComponentModel;
using System.IO;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Controls.Primitives;
using System.Xml;
using Confuser.Core.Project;
using ConfuserEx.ViewModel;

namespace ConfuserEx {
	public partial class MainWindow : Window {
		public MainWindow() {
			InitializeComponent();

			var app = new AppVM();
			app.Project = new ProjectVM(new ConfuserProject(), null);
			app.FileName = "Unnamed.crproj";

			app.Tabs.Add(new ProjectTabVM(app));
			app.Tabs.Add(new SettingsTabVM(app));
			app.Tabs.Add(new ProtectTabVM(app));
			app.Tabs.Add(new AboutTabVM(app));

			LoadProj(app);

			DataContext = app;
		}

		void OpenMenu(object sender, RoutedEventArgs e) {
			var btn = (Button)sender;
			ContextMenu menu = btn.ContextMenu;
			menu.PlacementTarget = btn;
			menu.Placement = PlacementMode.MousePoint;
			menu.IsOpen = true;
		}

		void LoadProj(AppVM app) {
			var args = Environment.GetCommandLineArgs();
			if (args.Length != 2 || !File.Exists(args[1]))
				return;

			string fileName = Path.GetFullPath(args[1]);
			try {
				var xmlDoc = new XmlDocument();
				xmlDoc.Load(fileName);
				var proj = new ConfuserProject();
				proj.Load(xmlDoc);
				app.Project = new ProjectVM(proj, fileName);
				app.FileName = fileName;
			}
			catch {
				MessageBox.Show("Invalid project!", "ConfuserEx", MessageBoxButton.OK, MessageBoxImage.Error);
			}
		}

		protected override void OnClosing(CancelEventArgs e) {
			base.OnClosing(e);
			e.Cancel = !((AppVM)DataContext).OnWindowClosing();
		}
	}
}


================================================
File: ConfuserEx/Skin.cs
================================================
ï»¿using System;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Documents;

namespace ConfuserEx {
	public class Skin {
		public static readonly DependencyProperty EmptyPromptProperty =
			DependencyProperty.RegisterAttached("EmptyPrompt", typeof(string), typeof(Skin), new UIPropertyMetadata(null));

		public static readonly DependencyProperty TabsDisabledProperty =
			DependencyProperty.RegisterAttached("TabsDisabled", typeof(bool), typeof(Skin), new UIPropertyMetadata(false));

		public static readonly DependencyProperty FocusOverlayProperty =
			DependencyProperty.RegisterAttached("FocusOverlay", typeof(bool), typeof(Skin), new UIPropertyMetadata(true));

		public static readonly DependencyProperty RTBDocumentProperty =
			DependencyProperty.RegisterAttached("RTBDocument", typeof(FlowDocument), typeof(Skin), new FrameworkPropertyMetadata(null, OnRTBDocumentChanged));

		public static string GetEmptyPrompt(DependencyObject obj) {
			return (string)obj.GetValue(EmptyPromptProperty);
		}

		public static void SetEmptyPrompt(DependencyObject obj, string value) {
			obj.SetValue(EmptyPromptProperty, value);
		}

		public static bool GetFocusOverlay(DependencyObject obj) {
			return (bool)obj.GetValue(FocusOverlayProperty);
		}

		public static void SetFocusOverlay(DependencyObject obj, bool value) {
			obj.SetValue(FocusOverlayProperty, value);
		}

		public static bool GetTabsDisabled(DependencyObject obj) {
			return (bool)obj.GetValue(TabsDisabledProperty);
		}

		public static void SetTabsDisabled(DependencyObject obj, bool value) {
			obj.SetValue(TabsDisabledProperty, value);
		}

		public static void OnRTBDocumentChanged(DependencyObject d, DependencyPropertyChangedEventArgs dpe) {
			var rtb = (RichTextBox)d;
			if (dpe.NewValue != null) {
				rtb.Document = (FlowDocument)dpe.NewValue;
				rtb.TextChanged += (sender, e) => rtb.ScrollToEnd();
			}
			else
				rtb.Document = new FlowDocument();
		}

		public static FlowDocument GetRTBDocument(DependencyObject obj) {
			return (FlowDocument)obj.GetValue(RTBDocumentProperty);
		}

		public static void SetRTBDocument(DependencyObject obj, FlowDocument value) {
			obj.SetValue(RTBDocumentProperty, value);
		}
	}
}


================================================
File: ConfuserEx/Skin.xaml
================================================
ï»¿<ResourceDictionary
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:local="clr-namespace:ConfuserEx">

    <DrawingBrush x:Key="WindowBackground" TileMode="Tile" Viewport="0,0,10,10" ViewportUnits="Absolute">
        <DrawingBrush.Drawing>
            <GeometryDrawing>
                <GeometryDrawing.Brush>
                    <LinearGradientBrush SpreadMethod="Repeat" StartPoint="0,0" EndPoint="1,1">
                        <LinearGradientBrush.RelativeTransform>
                            <ScaleTransform ScaleX="0.5" ScaleY="0.5" />
                        </LinearGradientBrush.RelativeTransform>
                        <GradientStop Offset="0" Color="#101010" />
                        <GradientStop Offset="0.5" Color="#101010" />
                        <GradientStop Offset="0.5" Color="#202020" />
                        <GradientStop Offset="1" Color="#202020" />
                    </LinearGradientBrush>
                </GeometryDrawing.Brush>
                <GeometryDrawing.Geometry>
                    <RectangleGeometry Rect="0,0,10,10" />
                </GeometryDrawing.Geometry>
            </GeometryDrawing>
        </DrawingBrush.Drawing>
    </DrawingBrush>

    <SolidColorBrush x:Key="ControlBackground" Color="#ff202020" />
    <SolidColorBrush x:Key="LightBackground" Color="#ff282828" />
    <SolidColorBrush x:Key="Border" Color="#ffa0a0a0" />
    <SolidColorBrush x:Key="Foreground" Color="#fff0f0f0" />

    <SolidColorBrush x:Key="DisabledBackground" Color="#ff505050" />
    <SolidColorBrush x:Key="DisabledForeground" Color="#ff808080" />

    <SolidColorBrush x:Key="SelectedBackground" Color="#ffa0a0a0" />
    <SolidColorBrush x:Key="SelectedForeground" Color="#ff202020" />

    <SolidColorBrush x:Key="HighlightBackground" Color="#ff404040" />
    <SolidColorBrush x:Key="DownBackground" Color="#ff303030" />

    <SolidColorBrush x:Key="HighlightOverlay" Color="#20ffffff" />

    <ControlTemplate x:Key="WindowTemplateKey" TargetType="{x:Type Window}">
        <Border BorderBrush="{TemplateBinding BorderBrush}" BorderThickness="{TemplateBinding BorderThickness}"
                Background="{TemplateBinding Background}">
            <Grid>
                <AdornerDecorator>
                    <ContentPresenter />
                </AdornerDecorator>
                <ResizeGrip x:Name="WindowResizeGrip" HorizontalAlignment="Right" IsTabStop="false"
                            Visibility="Collapsed" VerticalAlignment="Bottom" />
            </Grid>
        </Border>
        <ControlTemplate.Triggers>
            <MultiTrigger>
                <MultiTrigger.Conditions>
                    <Condition Property="ResizeMode" Value="CanResizeWithGrip" />
                    <Condition Property="WindowState" Value="Normal" />
                </MultiTrigger.Conditions>
                <Setter Property="Visibility" TargetName="WindowResizeGrip" Value="Visible" />
            </MultiTrigger>
        </ControlTemplate.Triggers>
    </ControlTemplate>

    <Style x:Key="DarkWindow" TargetType="{x:Type Window}">
        <Setter Property="Background" Value="{StaticResource WindowBackground}" />
        <Setter Property="Foreground" Value="{StaticResource Foreground}" />
        <Setter Property="FontFamily" Value="Open Sans" />
        <Setter Property="FontSize" Value="12" />
        <Setter Property="UseLayoutRounding" Value="True" />
        <Setter Property="TextOptions.TextFormattingMode" Value="Ideal" />
        <Setter Property="TextOptions.TextRenderingMode" Value="Grayscale" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type Window}">
                    <Border BorderBrush="{TemplateBinding BorderBrush}"
                            BorderThickness="{TemplateBinding BorderThickness}"
                            Background="{TemplateBinding Background}">
                        <AdornerDecorator>
                            <ContentPresenter />
                        </AdornerDecorator>
                    </Border>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
        <Style.Triggers>
            <Trigger Property="ResizeMode" Value="CanResizeWithGrip">
                <Setter Property="Template" Value="{StaticResource WindowTemplateKey}" />
            </Trigger>
        </Style.Triggers>
    </Style>

    <Style TargetType="{x:Type Label}">
        <Setter Property="Foreground" Value="{StaticResource Foreground}" />
        <Setter Property="HorizontalContentAlignment" Value="Left" />
        <Setter Property="VerticalContentAlignment" Value="Top" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type Label}">
                    <Border Padding="{TemplateBinding Padding}">
                        <ContentPresenter HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}"
                                          VerticalAlignment="{TemplateBinding VerticalContentAlignment}"
                                          RecognizesAccessKey="True" />
                    </Border>
                    <ControlTemplate.Triggers>
                        <Trigger Property="IsEnabled" Value="false">
                            <Setter Property="Foreground" Value="{StaticResource DisabledForeground}" />
                        </Trigger>
                    </ControlTemplate.Triggers>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>

    <Style x:Key="ToolBarVerticalOverflowButtonStyle" TargetType="{x:Type ToggleButton}">
        <Setter Property="Background" Value="Transparent" />
        <Setter Property="MinHeight" Value="0" />
        <Setter Property="MinWidth" Value="0" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type ToggleButton}">
                    <Border x:Name="Bd" Background="{TemplateBinding Background}" SnapsToDevicePixels="true"
                            BorderThickness="1">
                        <Canvas HorizontalAlignment="Right" Height="6" Margin="2,7,2,2" SnapsToDevicePixels="true"
                                VerticalAlignment="Bottom" Width="7">
                            <Path Data="M 1.5 1 L 1.5 6" Stroke="White" />
                            <Path Data="M 0.5 0 L 0.5 5" Stroke="{TemplateBinding Foreground}" />
                            <Path Data="M 3.5 0.5 L 7 3.5 L 4 6.5 Z" Fill="White" />
                            <Path Data="M 3 -0.5 L 6 2.5 L 3 5.5 Z" Fill="{TemplateBinding Foreground}" />
                        </Canvas>
                    </Border>
                    <ControlTemplate.Triggers>
                        <Trigger Property="IsMouseOver" Value="true">
                            <Setter Property="Background" TargetName="Bd" Value="{StaticResource HighlightBackground}" />
                            <Setter Property="BorderBrush" TargetName="Bd" Value="{StaticResource Border}" />
                        </Trigger>
                        <Trigger Property="IsKeyboardFocused" Value="true">
                            <Setter Property="Background" TargetName="Bd" Value="{StaticResource HighlightBackground}" />
                            <Setter Property="BorderBrush" TargetName="Bd" Value="{StaticResource Border}" />
                        </Trigger>
                        <Trigger Property="IsEnabled" Value="false">
                            <Setter Property="Foreground" Value="{StaticResource DisabledForeground}" />
                        </Trigger>
                    </ControlTemplate.Triggers>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>
    <Style x:Key="ToolBarHorizontalOverflowButtonStyle" TargetType="{x:Type ToggleButton}">
        <Setter Property="Background" Value="Transparent" />
        <Setter Property="MinHeight" Value="0" />
        <Setter Property="MinWidth" Value="0" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type ToggleButton}">
                    <Border x:Name="Bd" Background="{TemplateBinding Background}" CornerRadius="0,3,3,0"
                            SnapsToDevicePixels="true">
                        <Canvas HorizontalAlignment="Right" Height="7" Margin="7,2,2,2" SnapsToDevicePixels="true"
                                VerticalAlignment="Bottom" Width="6">
                            <Path Data="M 1.5 1.5 L 6 1.5" Stroke="{TemplateBinding Foreground}" />
                            <Path Data="M 0.5 4 L 6.5 4 L 3.5 7 Z" Fill="{TemplateBinding Foreground}" />
                        </Canvas>
                    </Border>
                    <ControlTemplate.Triggers>
                        <Trigger Property="IsMouseOver" Value="true">
                            <Setter Property="Background" TargetName="Bd" Value="{StaticResource HighlightBackground}" />
                            <Setter Property="BorderBrush" TargetName="Bd" Value="{StaticResource Border}" />
                        </Trigger>
                        <Trigger Property="IsKeyboardFocused" Value="true">
                            <Setter Property="Background" TargetName="Bd" Value="{StaticResource HighlightBackground}" />
                            <Setter Property="BorderBrush" TargetName="Bd" Value="{StaticResource Border}" />
                        </Trigger>
                        <Trigger Property="IsEnabled" Value="false">
                            <Setter Property="Foreground" Value="{StaticResource DisabledForeground}" />
                        </Trigger>
                    </ControlTemplate.Triggers>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>
    <Style x:Key="ToolBarThumbStyle" TargetType="{x:Type Thumb}">
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type Thumb}">
                    <Border Background="Transparent" Padding="{TemplateBinding Padding}" SnapsToDevicePixels="True">
                        <Rectangle>
                            <Rectangle.Fill>
                                <DrawingBrush TileMode="Tile" Viewbox="0,0,4,4" Viewport="0,0,4,4"
                                              ViewportUnits="Absolute" ViewboxUnits="Absolute">
                                    <DrawingBrush.Drawing>
                                        <DrawingGroup>
                                            <GeometryDrawing Brush="{StaticResource Foreground}"
                                                             Geometry="M 0 0 L 0 2 L 2 2 L 2 0 z" />
                                        </DrawingGroup>
                                    </DrawingBrush.Drawing>
                                </DrawingBrush>
                            </Rectangle.Fill>
                        </Rectangle>
                    </Border>
                    <ControlTemplate.Triggers>
                        <Trigger Property="IsMouseOver" Value="true">
                            <Setter Property="Cursor" Value="SizeAll" />
                        </Trigger>
                    </ControlTemplate.Triggers>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>
    <Style TargetType="{x:Type ToolBar}">
        <Setter Property="Background" Value="{StaticResource ControlBackground}" />
        <Setter Property="Foreground" Value="{StaticResource Foreground}" />
        <Setter Property="BorderBrush" Value="{StaticResource Border}" />
        <Setter Property="BorderThickness" Value="0,0,0,1" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type ToolBar}">
                    <Grid x:Name="Grid" SnapsToDevicePixels="true">
                        <Border x:Name="MainPanelBorder" BorderBrush="{TemplateBinding BorderBrush}"
                                BorderThickness="{TemplateBinding BorderThickness}"
                                Background="{TemplateBinding Background}" Padding="{TemplateBinding Padding}">
                            <DockPanel KeyboardNavigation.TabIndex="1" KeyboardNavigation.TabNavigation="Local">
                                <Thumb x:Name="ToolBarThumb" Margin="-3,-1,0,0" Padding="6,5,1,6"
                                       Style="{StaticResource ToolBarThumbStyle}" Width="10" />
                                <ContentPresenter x:Name="ToolBarHeader" ContentSource="Header"
                                                  HorizontalAlignment="Center" Margin="4,0,4,0"
                                                  SnapsToDevicePixels="{TemplateBinding SnapsToDevicePixels}"
                                                  VerticalAlignment="Center" />
                                <ToolBarPanel x:Name="PART_ToolBarPanel" IsItemsHost="true" Margin="2"
                                              SnapsToDevicePixels="{TemplateBinding SnapsToDevicePixels}" />
                                <Grid x:Name="OverflowGrid" DockPanel.Dock="Right" Margin="2,2,3,2">
                                    <ToggleButton x:Name="OverflowButton" ClickMode="Press" FocusVisualStyle="{x:Null}"
                                                  IsChecked="{Binding IsOverflowOpen, Mode=TwoWay, RelativeSource={RelativeSource TemplatedParent}}"
                                                  IsEnabled="{TemplateBinding HasOverflowItems}"
                                                  Style="{StaticResource ToolBarHorizontalOverflowButtonStyle}" />
                                    <Popup x:Name="OverflowPopup" AllowsTransparency="true" Focusable="false"
                                           IsOpen="{Binding IsOverflowOpen, RelativeSource={RelativeSource TemplatedParent}}"
                                           PopupAnimation="{DynamicResource {x:Static SystemParameters.ComboBoxPopupAnimationKey}}"
                                           Placement="Bottom" StaysOpen="false">
                                        <Border BorderBrush="{StaticResource Border}" BorderThickness="1"
                                                Background="{StaticResource LightBackground}">
                                            <ToolBarOverflowPanel x:Name="PART_ToolBarOverflowPanel"
                                                                  KeyboardNavigation.DirectionalNavigation="Cycle"
                                                                  FocusVisualStyle="{x:Null}" Focusable="true"
                                                                  Margin="2"
                                                                  SnapsToDevicePixels="{TemplateBinding SnapsToDevicePixels}"
                                                                  KeyboardNavigation.TabNavigation="Cycle"
                                                                  WrapWidth="200" />
                                        </Border>
                                    </Popup>
                                </Grid>
                            </DockPanel>
                        </Border>
                    </Grid>
                    <ControlTemplate.Triggers>
                        <Trigger Property="IsOverflowOpen" Value="true">
                            <Setter Property="IsEnabled" TargetName="ToolBarThumb" Value="false" />
                        </Trigger>
                        <Trigger Property="Header" Value="{x:Null}">
                            <Setter Property="Visibility" TargetName="ToolBarHeader" Value="Collapsed" />
                        </Trigger>
                        <Trigger Property="ToolBarTray.IsLocked" Value="true">
                            <Setter Property="Visibility" TargetName="ToolBarThumb" Value="Collapsed" />
                        </Trigger>
                        <Trigger Property="ToolBar.OverflowMode" Value="Never">
                            <Setter Property="Visibility" TargetName="OverflowGrid" Value="Collapsed" />
                        </Trigger>
                        <Trigger Property="Orientation" Value="Vertical">
                            <Setter Property="Margin" TargetName="Grid" Value="1,3,1,1" />
                            <Setter Property="Style" TargetName="OverflowButton"
                                    Value="{StaticResource ToolBarVerticalOverflowButtonStyle}" />
                            <Setter Property="Height" TargetName="ToolBarThumb" Value="10" />
                            <Setter Property="Width" TargetName="ToolBarThumb" Value="Auto" />
                            <Setter Property="Margin" TargetName="ToolBarThumb" Value="-1,-3,0,0" />
                            <Setter Property="Padding" TargetName="ToolBarThumb" Value="5,6,6,1" />
                            <Setter Property="Margin" TargetName="ToolBarHeader" Value="0,0,0,4" />
                            <Setter Property="Margin" TargetName="PART_ToolBarPanel" Value="1,0,2,2" />
                            <Setter Property="DockPanel.Dock" TargetName="ToolBarThumb" Value="Top" />
                            <Setter Property="DockPanel.Dock" TargetName="ToolBarHeader" Value="Top" />
                            <Setter Property="HorizontalAlignment" TargetName="OverflowGrid" Value="Stretch" />
                            <Setter Property="VerticalAlignment" TargetName="OverflowGrid" Value="Bottom" />
                            <Setter Property="Placement" TargetName="OverflowPopup" Value="Right" />
                            <Setter Property="Margin" TargetName="MainPanelBorder" Value="0,0,0,11" />
                        </Trigger>
                        <Trigger Property="IsEnabled" Value="false">
                            <Setter Property="Foreground" Value="{StaticResource DisabledForeground}" />
                        </Trigger>
                    </ControlTemplate.Triggers>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>

    <Style x:Key="{x:Static ToolBar.ButtonStyleKey}" TargetType="{x:Type Button}">
        <Setter Property="Foreground" Value="{StaticResource Foreground}" />
        <Setter Property="BorderThickness" Value="1" />
        <Setter Property="Padding" Value="4" />
        <Setter Property="Margin" Value="2" />
        <Setter Property="Background" Value="Transparent" />
        <Setter Property="BorderBrush" Value="Transparent" />
        <Setter Property="HorizontalAlignment" Value="Center" />
        <Setter Property="VerticalAlignment" Value="Center" />
        <Setter Property="HorizontalContentAlignment" Value="Center" />
        <Setter Property="VerticalContentAlignment" Value="Center" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type Button}">
                    <Border x:Name="Bd" BorderBrush="{TemplateBinding BorderBrush}"
                            BorderThickness="{TemplateBinding BorderThickness}"
                            Background="{TemplateBinding Background}" Padding="{TemplateBinding Padding}"
                            SnapsToDevicePixels="true">
                        <ContentPresenter HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}"
                                          SnapsToDevicePixels="{TemplateBinding SnapsToDevicePixels}"
                                          VerticalAlignment="{TemplateBinding VerticalContentAlignment}" />
                    </Border>
                    <ControlTemplate.Triggers>
                        <Trigger Property="IsMouseOver" Value="true">
                            <Setter Property="Background" TargetName="Bd" Value="{StaticResource HighlightBackground}" />
                            <Setter Property="BorderBrush" TargetName="Bd" Value="{StaticResource Border}" />
                        </Trigger>
                        <Trigger Property="IsKeyboardFocused" Value="true">
                            <Setter Property="Background" TargetName="Bd" Value="{StaticResource HighlightBackground}" />
                            <Setter Property="BorderBrush" TargetName="Bd" Value="{StaticResource Border}" />
                        </Trigger>
                        <Trigger Property="IsPressed" Value="true">
                            <Setter Property="Background" TargetName="Bd" Value="{StaticResource DownBackground}" />
                            <Setter Property="BorderBrush" TargetName="Bd" Value="{StaticResource Border}" />
                        </Trigger>
                        <Trigger Property="IsEnabled" Value="false">
                            <Setter Property="Foreground" Value="{StaticResource DisabledForeground}" />
                        </Trigger>
                    </ControlTemplate.Triggers>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>

    <Style TargetType="{x:Type TabControl}">
        <Setter Property="Foreground" Value="{StaticResource Foreground}" />
        <Setter Property="Background" Value="{StaticResource ControlBackground}" />
        <Setter Property="BorderBrush" Value="{StaticResource Border}" />
        <Setter Property="BorderThickness" Value="1" />
        <Setter Property="Margin" Value="0" />
        <Setter Property="Padding" Value="1" />
        <Setter Property="MinWidth" Value="10" />
        <Setter Property="MinHeight" Value="10" />
        <Setter Property="HorizontalContentAlignment" Value="Center" />
        <Setter Property="VerticalContentAlignment" Value="Center" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type TabControl}">
                    <Grid ClipToBounds="true" SnapsToDevicePixels="true" KeyboardNavigation.TabNavigation="Local">
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition x:Name="ColumnDefinition0" />
                            <ColumnDefinition x:Name="ColumnDefinition1" Width="0" />
                        </Grid.ColumnDefinitions>
                        <Grid.RowDefinitions>
                            <RowDefinition x:Name="RowDefinition0" Height="Auto" />
                            <RowDefinition x:Name="RowDefinition1" Height="*" />
                        </Grid.RowDefinitions>
                        <TabPanel x:Name="HeaderPanel" Background="Transparent" Grid.Column="0" IsItemsHost="true"
                                  Margin="0,2,2,-1" Grid.Row="0" KeyboardNavigation.TabIndex="1" Panel.ZIndex="1"
                                  IsEnabled="{Binding Path=(local:Skin.TabsDisabled), RelativeSource={RelativeSource TemplatedParent}, Converter={x:Static local:InvertBoolConverter.Instance}}" />
                        <Grid x:Name="ContentPanel" Grid.Column="0"
                              KeyboardNavigation.DirectionalNavigation="Contained" Grid.Row="1"
                              KeyboardNavigation.TabIndex="2" KeyboardNavigation.TabNavigation="Local">
                            <Border BorderBrush="{TemplateBinding BorderBrush}"
                                    BorderThickness="{TemplateBinding BorderThickness}"
                                    Background="{TemplateBinding Background}"
                                    Padding="{TemplateBinding Padding}">
                                <ContentPresenter x:Name="PART_SelectedContentHost" ContentSource="SelectedContent"
                                                  Margin="2,2,2,2"
                                                  SnapsToDevicePixels="{TemplateBinding SnapsToDevicePixels}" />
                            </Border>
                        </Grid>
                    </Grid>
                    <ControlTemplate.Triggers>
                        <Trigger Property="TabStripPlacement" Value="Bottom">
                            <Setter Property="Grid.Row" TargetName="HeaderPanel" Value="1" />
                            <Setter Property="Grid.Row" TargetName="ContentPanel" Value="0" />
                            <Setter Property="Height" TargetName="RowDefinition0" Value="*" />
                            <Setter Property="Height" TargetName="RowDefinition1" Value="Auto" />
                            <Setter Property="Margin" TargetName="HeaderPanel" Value="2,0,2,2" />
                        </Trigger>
                        <Trigger Property="TabStripPlacement" Value="Left">
                            <Setter Property="Grid.Row" TargetName="HeaderPanel" Value="0" />
                            <Setter Property="Grid.Row" TargetName="ContentPanel" Value="0" />
                            <Setter Property="Grid.Column" TargetName="HeaderPanel" Value="0" />
                            <Setter Property="Grid.Column" TargetName="ContentPanel" Value="1" />
                            <Setter Property="Width" TargetName="ColumnDefinition0" Value="Auto" />
                            <Setter Property="Width" TargetName="ColumnDefinition1" Value="*" />
                            <Setter Property="Height" TargetName="RowDefinition0" Value="*" />
                            <Setter Property="Height" TargetName="RowDefinition1" Value="0" />
                            <Setter Property="Margin" TargetName="HeaderPanel" Value="2,2,0,2" />
                        </Trigger>
                        <Trigger Property="TabStripPlacement" Value="Right">
                            <Setter Property="Grid.Row" TargetName="HeaderPanel" Value="0" />
                            <Setter Property="Grid.Row" TargetName="ContentPanel" Value="0" />
                            <Setter Property="Grid.Column" TargetName="HeaderPanel" Value="1" />
                            <Setter Property="Grid.Column" TargetName="ContentPanel" Value="0" />
                            <Setter Property="Width" TargetName="ColumnDefinition0" Value="*" />
                            <Setter Property="Width" TargetName="ColumnDefinition1" Value="Auto" />
                            <Setter Property="Height" TargetName="RowDefinition0" Value="*" />
                            <Setter Property="Height" TargetName="RowDefinition1" Value="0" />
                            <Setter Property="Margin" TargetName="HeaderPanel" Value="0,2,2,2" />
                        </Trigger>
                        <Trigger Property="IsEnabled" Value="false">
                            <Setter Property="Foreground" Value="{StaticResource DisabledForeground}" />
                        </Trigger>
                    </ControlTemplate.Triggers>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>

    <Style x:Key="TabItemFocusVisual">
        <Setter Property="Control.Template">
            <Setter.Value>
                <ControlTemplate>
                    <Rectangle Margin="4,4,4,2" SnapsToDevicePixels="true" Stroke="{StaticResource Border}"
                               StrokeThickness="1"
                               StrokeDashArray="1 2" />
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>
    <Style TargetType="{x:Type TabItem}">
        <Setter Property="FocusVisualStyle" Value="{StaticResource TabItemFocusVisual}" />
        <Setter Property="Padding" Value="15,6,15,6" />
        <Setter Property="Foreground" Value="{StaticResource Foreground}" />
        <Setter Property="BorderBrush" Value="{StaticResource Border}" />
        <Setter Property="Background" Value="{StaticResource ControlBackground}" />
        <Setter Property="HorizontalContentAlignment" Value="Stretch" />
        <Setter Property="VerticalContentAlignment" Value="Stretch" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type TabItem}">
                    <Grid x:Name="Grid" Margin="0,0,-1,0">
                        <Border x:Name="Border" BorderBrush="{TemplateBinding BorderBrush}" BorderThickness="1,1,1,0"
                                Background="{TemplateBinding Background}" SnapsToDevicePixels="true">
                            <ContentPresenter ContentSource="Header"
                                              HorizontalAlignment="{Binding HorizontalContentAlignment, RelativeSource={RelativeSource AncestorType={x:Type ItemsControl}}}"
                                              Margin="{TemplateBinding Padding}" RecognizesAccessKey="True"
                                              SnapsToDevicePixels="{TemplateBinding SnapsToDevicePixels}"
                                              VerticalAlignment="{Binding VerticalContentAlignment, RelativeSource={RelativeSource AncestorType={x:Type ItemsControl}}}" />
                        </Border>
                        <Border x:Name="Overlay" Background="{StaticResource HighlightOverlay}" Opacity="0" />
                    </Grid>
                    <ControlTemplate.Triggers>
                        <Trigger Property="IsSelected" Value="true">
                            <Setter Property="Panel.ZIndex" Value="1" />
                        </Trigger>
                        <Trigger Property="TabStripPlacement" Value="Bottom">
                            <Setter Property="BorderThickness" TargetName="Border" Value="1,0,1,1" />
                        </Trigger>
                        <Trigger Property="TabStripPlacement" Value="Left">
                            <Setter Property="BorderThickness" TargetName="Border" Value="1,1,0,1" />
                            <Setter Property="Margin" TargetName="Grid" Value="0,0,0,-1" />
                        </Trigger>
                        <Trigger Property="TabStripPlacement" Value="Right">
                            <Setter Property="BorderThickness" TargetName="Border" Value="0,1,1,1" />
                            <Setter Property="Margin" TargetName="Grid" Value="0,0,0,-1" />
                        </Trigger>
                        <Trigger Property="IsSelected" Value="false">
                            <Setter Property="Background" TargetName="Border" Value="Transparent" />
                        </Trigger>
                        <MultiTrigger>
                            <MultiTrigger.Conditions>
                                <Condition Property="IsMouseOver" Value="false" />
                                <Condition Property="IsSelected" Value="false" />
                            </MultiTrigger.Conditions>
                            <Setter Property="BorderBrush" TargetName="Border" Value="Transparent" />
                        </MultiTrigger>
                        <MultiTrigger>
                            <MultiTrigger.Conditions>
                                <Condition Property="IsMouseOver" Value="true" />
                                <Condition Property="IsSelected" Value="false" />
                            </MultiTrigger.Conditions>
                            <Setter Property="Opacity" TargetName="Overlay" Value="1" />
                        </MultiTrigger>
                        <Trigger Property="IsEnabled" Value="false">
                            <Setter Property="Foreground" Value="{StaticResource DisabledForeground}" />
                        </Trigger>
                    </ControlTemplate.Triggers>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>

    <PopupAnimation x:Key="{x:Static SystemParameters.MenuPopupAnimationKey}">None</PopupAnimation>

    <Style TargetType="{x:Type ContextMenu}">
        <Setter Property="Background" Value="{StaticResource ControlBackground}" />
        <Setter Property="BorderThickness" Value="1" />
        <Setter Property="BorderBrush" Value="{StaticResource Border}" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type ContextMenu}">
                    <Border Background="Transparent" Padding="5">
                        <Border.Effect>
                            <DropShadowEffect BlurRadius="4" Opacity="0.8" ShadowDepth="1" />
                        </Border.Effect>
                        <Border BorderBrush="{TemplateBinding BorderBrush}"
                                BorderThickness="{TemplateBinding BorderThickness}"
                                Background="{TemplateBinding Background}">
                            <ScrollViewer CanContentScroll="True"
                                          Style="{DynamicResource {ComponentResourceKey ResourceId=MenuScrollViewer, TypeInTargetAssembly={x:Type FrameworkElement}}}">
                                <ItemsPresenter KeyboardNavigation.DirectionalNavigation="Cycle"
                                                Margin="{TemplateBinding Padding}"
                                                SnapsToDevicePixels="{TemplateBinding SnapsToDevicePixels}" />
                            </ScrollViewer>
                        </Border>
                    </Border>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>

    <ControlTemplate x:Key="{x:Static MenuItem.SubmenuItemTemplateKey}" TargetType="{x:Type MenuItem}">
        <Border x:Name="Border" Padding="{TemplateBinding Padding}" Background="Transparent">
            <Grid>
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="Auto" SharedSizeGroup="Icon" />
                    <ColumnDefinition Width="*" />
                    <ColumnDefinition Width="Auto" SharedSizeGroup="Shortcut" />
                    <ColumnDefinition Width="13" />
                </Grid.ColumnDefinitions>
                <ContentPresenter x:Name="Icon" Margin="6,0,6,0" VerticalAlignment="Center" ContentSource="Icon" />
                <Border x:Name="Check" Width="13" Height="13" Visibility="Collapsed" Margin="6,0,6,0"
                        Background="Transparent">
                    <Path x:Name="CheckMark" Width="7" Height="7" Visibility="Hidden" SnapsToDevicePixels="False"
                          Stroke="{StaticResource Foreground}" StrokeThickness="2" Data="M 0 0 L 7 7 M 0 7 L 7 0" />
                </Border>
                <ContentPresenter x:Name="HeaderHost" Grid.Column="1" ContentSource="Header" VerticalAlignment="Center"
                                  RecognizesAccessKey="True" />
                <TextBlock x:Name="InputGestureText" Grid.Column="2" Text="{TemplateBinding InputGestureText}"
                           VerticalAlignment="Center" Margin="10,0,0,0" />
            </Grid>
        </Border>
        <ControlTemplate.Triggers>
            <Trigger Property="Icon" Value="{x:Null}">
                <Setter TargetName="Icon" Property="Visibility" Value="Hidden" />
            </Trigger>
            <Trigger Property="IsChecked" Value="true">
                <Setter TargetName="CheckMark" Property="Visibility" Value="Visible" />
            </Trigger>
            <Trigger Property="IsCheckable" Value="true">
                <Setter TargetName="Check" Property="Visibility" Value="Visible" />
                <Setter TargetName="Icon" Property="Visibility" Value="Hidden" />
            </Trigger>
            <Trigger Property="IsHighlighted" Value="true">
                <Setter TargetName="Border" Property="Background" Value="{StaticResource HighlightBackground}" />
            </Trigger>
            <Trigger Property="IsEnabled" Value="false">
                <Setter Property="Foreground" Value="{StaticResource DisabledForeground}" />
            </Trigger>
        </ControlTemplate.Triggers>
    </ControlTemplate>

    <Style x:Key="{x:Type MenuItem}" TargetType="{x:Type MenuItem}">
        <Setter Property="Foreground" Value="{StaticResource Foreground}" />
        <Setter Property="Background" Value="{StaticResource ControlBackground}" />
        <Setter Property="Padding" Value="5,4,5,4" />
        <Style.Triggers>
            <Trigger Property="Role" Value="SubmenuItem">
                <Setter Property="Template" Value="{StaticResource {x:Static MenuItem.SubmenuItemTemplateKey}}" />
            </Trigger>
        </Style.Triggers>
    </Style>

    <Style x:Key="{x:Static MenuItem.SeparatorStyleKey}" TargetType="{x:Type Separator}">
        <Setter Property="Background" Value="{StaticResource Border}" />
        <Setter Property="Margin" Value="2" />
        <Setter Property="Focusable" Value="false" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type Separator}">
                    <Border
                        BorderBrush="{TemplateBinding BorderBrush}"
                        BorderThickness="{TemplateBinding BorderThickness}"
                        Background="{TemplateBinding Background}"
                        Height="1"
                        SnapsToDevicePixels="true" />
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>

    <Style TargetType="{x:Type Separator}">
        <Setter Property="Background" Value="{StaticResource Border}" />
        <Setter Property="Margin" Value="2" />
        <Setter Property="Focusable" Value="false" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type Separator}">
                    <Border
                        BorderBrush="{TemplateBinding BorderBrush}"
                        BorderThickness="{TemplateBinding BorderThickness}"
                        Background="{TemplateBinding Background}"
                        Height="1"
                        SnapsToDevicePixels="true" />
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>

    <Style x:Key="ButtonFocusVisual">
        <Setter Property="Control.Template">
            <Setter.Value>
                <ControlTemplate>
                    <Border>
                        <Rectangle Margin="4" SnapsToDevicePixels="true" Stroke="{StaticResource Border}"
                                   StrokeThickness="1" StrokeDashArray="1 2" />
                    </Border>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>
    <Style TargetType="{x:Type Button}">
        <Setter Property="FocusVisualStyle" Value="{StaticResource ButtonFocusVisual}" />
        <Setter Property="Background" Value="{StaticResource ControlBackground}" />
        <Setter Property="Foreground" Value="{StaticResource Foreground}" />
        <Setter Property="BorderBrush" Value="{StaticResource Border}" />
        <Setter Property="Padding" Value="0" />
        <Setter Property="HorizontalContentAlignment" Value="Center" />
        <Setter Property="VerticalContentAlignment" Value="Center" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type Button}">
                    <Border x:Name="ContentContainer" BorderBrush="{TemplateBinding BorderBrush}" BorderThickness="1"
                            Background="{TemplateBinding Background}" SnapsToDevicePixels="true">
                        <Grid>
                            <ContentPresenter HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}"
                                              Margin="{TemplateBinding Padding}" RecognizesAccessKey="True"
                                              SnapsToDevicePixels="{TemplateBinding SnapsToDevicePixels}"
                                              VerticalAlignment="{TemplateBinding VerticalContentAlignment}" />
                            <Border x:Name="Overlay" Background="{StaticResource HighlightOverlay}" Opacity="0" />
                        </Grid>
                    </Border>
                    <ControlTemplate.Triggers>
                        <Trigger Property="IsDefaulted" Value="true">
                            <Setter Property="BorderThickness" TargetName="ContentContainer" Value="2" />
                        </Trigger>
                        <Trigger Property="IsMouseOver" Value="true">
                            <Setter Property="Opacity" TargetName="Overlay" Value="1" />
                        </Trigger>
                        <Trigger Property="IsPressed" Value="true">
                            <Setter Property="Opacity" TargetName="Overlay" Value="0.7" />
                        </Trigger>
                        <Trigger Property="ToggleButton.IsChecked" Value="true">
                            <Setter Property="Opacity" TargetName="Overlay" Value="1" />
                        </Trigger>
                        <Trigger Property="IsEnabled" Value="false">
                            <Setter Property="Foreground" Value="{StaticResource DisabledForeground}" />
                        </Trigger>
                    </ControlTemplate.Triggers>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>

    <Style TargetType="{x:Type TextBox}">
        <Setter Property="BorderBrush" Value="{StaticResource Border}" />
        <Setter Property="BorderThickness" Value="1" />
        <Setter Property="Foreground" Value="{StaticResource Foreground}" />
        <Setter Property="Background" Value="{StaticResource ControlBackground}" />
        <Setter Property="Padding" Value="1" />
        <Setter Property="KeyboardNavigation.TabNavigation" Value="None" />
        <Setter Property="HorizontalContentAlignment" Value="Left" />
        <Setter Property="FocusVisualStyle" Value="{x:Null}" />
        <Setter Property="AllowDrop" Value="true" />
        <Setter Property="ScrollViewer.PanningMode" Value="VerticalFirst" />
        <Setter Property="Stylus.IsFlicksEnabled" Value="False" />
        <Setter Property="SelectionBrush" Value="{StaticResource Foreground}" />
        <Setter Property="SelectionOpacity" Value="0.2" />
        <Setter Property="CaretBrush" Value="{StaticResource Border}" />
        <Setter Property="ContextMenu">
            <Setter.Value>
                <ContextMenu>
                    <MenuItem Header="Undo" Command="ApplicationCommands.Undo" />
                    <MenuItem Header="Redo" Command="ApplicationCommands.Redo" />
                    <Separator />
                    <MenuItem Header="Cut" Command="ApplicationCommands.Cut" />
                    <MenuItem Header="Copy" Command="ApplicationCommands.Copy" />
                    <MenuItem Header="Paste" Command="ApplicationCommands.Paste" />
                </ContextMenu>
            </Setter.Value>
        </Setter>
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type TextBox}">
                    <Border x:Name="Bd" BorderBrush="{TemplateBinding BorderBrush}"
                            BorderThickness="{TemplateBinding BorderThickness}"
                            Background="{TemplateBinding Background}">
                        <Grid>
                            <Border x:Name="Overlay" Background="{StaticResource HighlightOverlay}" Opacity="0" />
                            <ScrollViewer x:Name="PART_ContentHost" />
                            <Label x:Name="Prompt" Opacity="0"
                                   Content="{Binding Path=(local:Skin.EmptyPrompt), RelativeSource={RelativeSource TemplatedParent}}"
                                   IsHitTestVisible="False"
                                   VerticalContentAlignment="{TemplateBinding VerticalContentAlignment}"
                                   HorizontalContentAlignment="{TemplateBinding HorizontalContentAlignment}" />
                        </Grid>
                    </Border>
                    <ControlTemplate.Triggers>
                        <Trigger Property="IsEnabled" Value="false">
                            <Setter Property="Background" TargetName="Bd" Value="{StaticResource DisabledBackground}" />
                            <Setter Property="Foreground" Value="{StaticResource DisabledForeground}" />
                        </Trigger>
                        <MultiTrigger>
                            <MultiTrigger.Conditions>
                                <Condition Property="IsFocused" Value="true" />
                                <Condition Property="local:Skin.FocusOverlay" Value="true" />
                            </MultiTrigger.Conditions>
                            <Setter Property="Opacity" TargetName="Overlay" Value="0.5" />
                        </MultiTrigger>
                        <Trigger Property="Text" Value="">
                            <Setter Property="Opacity" TargetName="Prompt" Value="0.5" />
                        </Trigger>
                        <Trigger Property="Text" Value="{x:Null}">
                            <Setter Property="Opacity" TargetName="Prompt" Value="0.5" />
                        </Trigger>
                    </ControlTemplate.Triggers>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>

    <Style TargetType="{x:Type RichTextBox}">
        <Setter Property="BorderBrush" Value="{StaticResource Border}" />
        <Setter Property="BorderThickness" Value="1" />
        <Setter Property="Foreground" Value="{StaticResource Foreground}" />
        <Setter Property="Background" Value="{StaticResource ControlBackground}" />
        <Setter Property="Padding" Value="1" />
        <Setter Property="KeyboardNavigation.TabNavigation" Value="None" />
        <Setter Property="HorizontalContentAlignment" Value="Left" />
        <Setter Property="FocusVisualStyle" Value="{x:Null}" />
        <Setter Property="AllowDrop" Value="true" />
        <Setter Property="ScrollViewer.PanningMode" Value="VerticalFirst" />
        <Setter Property="Stylus.IsFlicksEnabled" Value="False" />
        <Setter Property="SelectionBrush" Value="{StaticResource Foreground}" />
        <Setter Property="SelectionOpacity" Value="0.2" />
        <Setter Property="CaretBrush" Value="{StaticResource Border}" />
        <Setter Property="ContextMenu">
            <Setter.Value>
                <ContextMenu>
                    <MenuItem Header="Undo" Command="ApplicationCommands.Undo" />
                    <MenuItem Header="Redo" Command="ApplicationCommands.Redo" />
                    <Separator />
                    <MenuItem Header="Cut" Command="ApplicationCommands.Cut" />
                    <MenuItem Header="Copy" Command="ApplicationCommands.Copy" />
                    <MenuItem Header="Paste" Command="ApplicationCommands.Paste" />
                </ContextMenu>
            </Setter.Value>
        </Setter>
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type RichTextBox}">
                    <Border x:Name="Bd" BorderBrush="{TemplateBinding BorderBrush}"
                            BorderThickness="{TemplateBinding BorderThickness}"
                            Background="{TemplateBinding Background}">
                        <Grid>
                            <Border x:Name="Overlay" Background="{StaticResource HighlightOverlay}" Opacity="0" />
                            <ScrollViewer x:Name="PART_ContentHost" />
                        </Grid>
                    </Border>
                    <ControlTemplate.Triggers>
                        <Trigger Property="IsEnabled" Value="false">
                            <Setter Property="Background" TargetName="Bd" Value="{StaticResource DisabledBackground}" />
                            <Setter Property="Foreground" Value="{StaticResource DisabledForeground}" />
                        </Trigger>
                        <Trigger Property="IsFocused" Value="true">
                            <Setter Property="Opacity" TargetName="Overlay" Value="0.5" />
                        </Trigger>
                    </ControlTemplate.Triggers>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>

    <Style x:Key="CheckRadioFocusVisual">
        <Setter Property="Control.Template">
            <Setter.Value>
                <ControlTemplate>
                    <Rectangle Margin="14,0,0,0" SnapsToDevicePixels="true" Stroke="{StaticResource Border}"
                               StrokeThickness="1" StrokeDashArray="1 2" />
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>
    <Style x:Key="EmptyCheckBoxFocusVisual">
        <Setter Property="Control.Template">
            <Setter.Value>
                <ControlTemplate>
                    <Rectangle Margin="1" SnapsToDevicePixels="true" Stroke="{StaticResource Border}"
                               StrokeThickness="1" StrokeDashArray="1 2" />
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>
    <Style TargetType="{x:Type CheckBox}">
        <Setter Property="FocusVisualStyle" Value="{StaticResource CheckRadioFocusVisual}" />
        <Setter Property="Foreground" Value="{StaticResource Foreground}" />
        <Setter Property="Background" Value="{StaticResource LightBackground}" />
        <Setter Property="BorderBrush" Value="{StaticResource Border}" />
        <Setter Property="BorderThickness" Value="1" />
        <Setter Property="Padding" Value="5,0,0,0" />
        <Setter Property="FocusVisualStyle" Value="{StaticResource EmptyCheckBoxFocusVisual}" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type CheckBox}">
                    <BulletDecorator Background="Transparent" SnapsToDevicePixels="true">
                        <BulletDecorator.Bullet>
                            <Border x:Name="CheckMarkBorder" BorderBrush="{TemplateBinding BorderBrush}"
                                    BorderThickness="{TemplateBinding BorderThickness}"
                                    Background="{TemplateBinding Background}">
                                <Rectangle x:Name="CheckMark" Fill="{TemplateBinding Foreground}"
                                           FlowDirection="LeftToRight" Height="9" Margin="2" Width="9" />
                            </Border>
                        </BulletDecorator.Bullet>
                        <ContentPresenter HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}"
                                          Margin="{TemplateBinding Padding}" RecognizesAccessKey="True"
                                          SnapsToDevicePixels="{TemplateBinding SnapsToDevicePixels}"
                                          VerticalAlignment="{TemplateBinding VerticalContentAlignment}" />
                    </BulletDecorator>
                    <ControlTemplate.Triggers>
                        <Trigger Property="IsChecked" Value="false">
                            <Setter Property="Visibility" TargetName="CheckMark" Value="Hidden" />
                        </Trigger>
                        <Trigger Property="IsChecked" Value="{x:Null}">
                            <Setter Property="Fill" TargetName="CheckMark" Value="{StaticResource DisabledForeground}" />
                        </Trigger>
                        <Trigger Property="IsMouseOver" Value="true">
                            <Setter Property="Background" TargetName="CheckMarkBorder"
                                    Value="{StaticResource HighlightBackground}" />
                        </Trigger>
                        <Trigger Property="IsEnabled" Value="false">
                            <Setter Property="Background" TargetName="CheckMarkBorder"
                                    Value="{StaticResource DisabledBackground}" />
                            <Setter Property="Fill" TargetName="CheckMark" Value="{StaticResource DisabledForeground}" />
                            <Setter Property="Foreground" Value="{StaticResource DisabledForeground}" />
                        </Trigger>
                    </ControlTemplate.Triggers>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>

    <Style TargetType="{x:Type RadioButton}">
        <Setter Property="FocusVisualStyle" Value="{StaticResource CheckRadioFocusVisual}" />
        <Setter Property="Foreground" Value="{StaticResource Foreground}" />
        <Setter Property="Background" Value="{StaticResource LightBackground}" />
        <Setter Property="BorderBrush" Value="{StaticResource Border}" />
        <Setter Property="BorderThickness" Value="1" />
        <Setter Property="Padding" Value="5,0,0,0" />
        <Setter Property="FocusVisualStyle" Value="{StaticResource EmptyCheckBoxFocusVisual}" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type RadioButton}">
                    <BulletDecorator Background="Transparent" SnapsToDevicePixels="true">
                        <BulletDecorator.Bullet>
                            <Grid>
                                <Ellipse x:Name="CheckMarkBorder" Stroke="{TemplateBinding BorderBrush}"
                                        StrokeThickness="{TemplateBinding BorderThickness}"
                                        Fill="{TemplateBinding Background}" />
                                <Ellipse x:Name="CheckMark" Fill="{TemplateBinding Foreground}"
                                               FlowDirection="LeftToRight" Height="7" Margin="3" Width="7" />
                            </Grid>
                        </BulletDecorator.Bullet>
                        <ContentPresenter HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}"
                                          Margin="{TemplateBinding Padding}" RecognizesAccessKey="True"
                                          SnapsToDevicePixels="{TemplateBinding SnapsToDevicePixels}"
                                          VerticalAlignment="{TemplateBinding VerticalContentAlignment}" />
                    </BulletDecorator>
                    <ControlTemplate.Triggers>
                        <Trigger Property="IsChecked" Value="false">
                            <Setter Property="Visibility" TargetName="CheckMark" Value="Hidden" />
                        </Trigger>
                        <Trigger Property="IsChecked" Value="{x:Null}">
                            <Setter Property="Fill" TargetName="CheckMark" Value="{StaticResource DisabledForeground}" />
                        </Trigger>
                        <Trigger Property="IsMouseOver" Value="true">
                            <Setter Property="Fill" TargetName="CheckMarkBorder"
                                    Value="{StaticResource HighlightBackground}" />
                        </Trigger>
                        <Trigger Property="IsEnabled" Value="false">
                            <Setter Property="Fill" TargetName="CheckMarkBorder"
                                    Value="{StaticResource DisabledBackground}" />
                            <Setter Property="Fill" TargetName="CheckMark" Value="{StaticResource DisabledForeground}" />
                            <Setter Property="Foreground" Value="{StaticResource DisabledForeground}" />
                        </Trigger>
                    </ControlTemplate.Triggers>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>

    <Style TargetType="{x:Type ListBox}">
        <Setter Property="Background" Value="{StaticResource ControlBackground}" />
        <Setter Property="Foreground" Value="{StaticResource Foreground}" />
        <Setter Property="BorderBrush" Value="{StaticResource Border}" />
        <Setter Property="BorderThickness" Value="1" />
        <Setter Property="ScrollViewer.HorizontalScrollBarVisibility" Value="Auto" />
        <Setter Property="ScrollViewer.VerticalScrollBarVisibility" Value="Auto" />
        <Setter Property="ScrollViewer.CanContentScroll" Value="true" />
        <Setter Property="ScrollViewer.PanningMode" Value="Both" />
        <Setter Property="Stylus.IsFlicksEnabled" Value="False" />
        <Setter Property="VerticalContentAlignment" Value="Center" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type ListBox}">
                    <Border x:Name="Bd" BorderBrush="{TemplateBinding BorderBrush}"
                            BorderThickness="{TemplateBinding BorderThickness}"
                            Background="{TemplateBinding Background}" SnapsToDevicePixels="true">
                        <Grid>
                            <ScrollViewer Focusable="false" Padding="{TemplateBinding Padding}">
                                <ItemsPresenter SnapsToDevicePixels="{TemplateBinding SnapsToDevicePixels}" />
                            </ScrollViewer>
                            <Label x:Name="Prompt" Opacity="0"
                                   Content="{Binding Path=(local:Skin.EmptyPrompt), RelativeSource={RelativeSource TemplatedParent}}"
                                   IsHitTestVisible="False" VerticalContentAlignment="Center"
                                   HorizontalContentAlignment="Center" />
                        </Grid>
                    </Border>
                    <ControlTemplate.Triggers>
                        <Trigger Property="IsEnabled" Value="false">
                            <Setter Property="Background" TargetName="Bd"
                                    Value="{DynamicResource {x:Static SystemColors.WindowBrushKey}}" />
                        </Trigger>
                        <Trigger Property="IsGrouping" Value="true">
                            <Setter Property="ScrollViewer.CanContentScroll" Value="false" />
                        </Trigger>
                        <DataTrigger Binding="{Binding Items.Count, RelativeSource={x:Static RelativeSource.Self}}"
                                     Value="0">
                            <Setter Property="Opacity" TargetName="Prompt" Value="0.5" />
                        </DataTrigger>
                    </ControlTemplate.Triggers>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>

    <Style TargetType="{x:Type ListBoxItem}">
        <Setter Property="Background" Value="Transparent" />
        <Setter Property="HorizontalContentAlignment"
                Value="{Binding HorizontalContentAlignment, RelativeSource={RelativeSource AncestorType={x:Type ItemsControl}}}" />
        <Setter Property="VerticalContentAlignment"
                Value="{Binding VerticalContentAlignment, RelativeSource={RelativeSource AncestorType={x:Type ItemsControl}}}" />
        <Setter Property="Padding" Value="5,3,5,3" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type ListBoxItem}">
                    <Grid>
                        <Border x:Name="Bd" BorderBrush="{TemplateBinding BorderBrush}"
                                BorderThickness="{TemplateBinding BorderThickness}"
                                Background="{TemplateBinding Background}" Padding="{TemplateBinding Padding}"
                                SnapsToDevicePixels="true">
                            <ContentPresenter HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}"
                                              SnapsToDevicePixels="{TemplateBinding SnapsToDevicePixels}"
                                              VerticalAlignment="{TemplateBinding VerticalContentAlignment}" />
                        </Border>
                        <Border x:Name="Overlay" Background="{StaticResource HighlightOverlay}" Opacity="0"
                                IsHitTestVisible="False" />
                    </Grid>
                    <ControlTemplate.Triggers>
                        <Trigger Property="IsSelected" Value="true">
                            <Setter Property="Background" TargetName="Bd" Value="{StaticResource SelectedBackground}" />
                            <Setter Property="Foreground" Value="{StaticResource SelectedForeground}" />
                        </Trigger>
                        <MultiTrigger>
                            <MultiTrigger.Conditions>
                                <Condition Property="IsMouseOver" Value="true" />
                                <Condition Property="IsSelected" Value="false" />
                            </MultiTrigger.Conditions>
                            <Setter Property="Opacity" TargetName="Overlay" Value="1" />
                        </MultiTrigger>
                        <Trigger Property="IsEnabled" Value="false">
                            <Setter Property="Foreground" Value="{StaticResource DisabledForeground}" />
                        </Trigger>
                    </ControlTemplate.Triggers>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>

    <Style TargetType="{x:Type ScrollViewer}">
        <Setter Property="OverridesDefaultStyle" Value="True" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type ScrollViewer}">
                    <Grid x:Name="Grid" Background="{TemplateBinding Background}">
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition Width="*" />
                            <ColumnDefinition Width="Auto" />
                        </Grid.ColumnDefinitions>
                        <Grid.RowDefinitions>
                            <RowDefinition Height="*" />
                            <RowDefinition Height="Auto" />
                        </Grid.RowDefinitions>
                        <Rectangle x:Name="Corner" Grid.Column="1" Fill="{StaticResource ControlBackground}"
                                   Grid.Row="1" />
                        <ScrollContentPresenter x:Name="PART_ScrollContentPresenter"
                                                CanContentScroll="{TemplateBinding CanContentScroll}"
                                                CanHorizontallyScroll="False" CanVerticallyScroll="False"
                                                ContentTemplate="{TemplateBinding ContentTemplate}"
                                                Content="{TemplateBinding Content}" Grid.Column="0"
                                                Margin="{TemplateBinding Padding}" Grid.Row="0" />
                        <ScrollBar x:Name="PART_VerticalScrollBar"
                                   AutomationProperties.AutomationId="VerticalScrollBar" Cursor="Arrow" Grid.Column="1"
                                   Maximum="{TemplateBinding ScrollableHeight}" Minimum="0" Grid.Row="0"
                                   Visibility="{TemplateBinding ComputedVerticalScrollBarVisibility}"
                                   Value="{Binding VerticalOffset, Mode=OneWay, RelativeSource={RelativeSource TemplatedParent}}"
                                   ViewportSize="{TemplateBinding ViewportHeight}" />
                        <ScrollBar x:Name="PART_HorizontalScrollBar"
                                   AutomationProperties.AutomationId="HorizontalScrollBar" Cursor="Arrow"
                                   Grid.Column="0" Maximum="{TemplateBinding ScrollableWidth}" Minimum="0"
                                   Orientation="Horizontal" Grid.Row="1"
                                   Visibility="{TemplateBinding ComputedHorizontalScrollBarVisibility}"
                                   Value="{Binding HorizontalOffset, Mode=OneWay, RelativeSource={RelativeSource TemplatedParent}}"
                                   ViewportSize="{TemplateBinding ViewportWidth}" />
                    </Grid>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>

    <Style x:Key="ScrollBarLineButtonStyle" TargetType="{x:Type RepeatButton}">
        <Setter Property="OverridesDefaultStyle" Value="true" />
        <Setter Property="Background" Value="Transparent" />
        <Setter Property="Foreground" Value="{StaticResource Border}" />
        <Setter Property="BorderThickness" Value="0" />
        <Setter Property="MinWidth" Value="0" />
        <Setter Property="MinHeight" Value="0" />
        <Setter Property="IsTabStop" Value="false" />
        <Setter Property="Focusable" Value="false" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type RepeatButton}">
                    <Border BorderBrush="{TemplateBinding BorderBrush}"
                            BorderThickness="{TemplateBinding BorderThickness}"
                            Background="{TemplateBinding Background}" Height="{TemplateBinding Height}"
                            Width="{TemplateBinding Width}">
                        <Path x:Name="Path" Data="{Binding Content, RelativeSource={RelativeSource TemplatedParent}}"
                              Fill="{TemplateBinding Foreground}" HorizontalAlignment="Center"
                              VerticalAlignment="Center" />
                    </Border>
                    <ControlTemplate.Triggers>
                        <Trigger Property="IsMouseOver" Value="true">
                            <Setter Property="Fill" TargetName="Path" Value="{StaticResource Foreground}" />
                        </Trigger>
                        <Trigger Property="IsEnabled" Value="false">
                            <Setter Property="Foreground" Value="{StaticResource DisabledForeground}" />
                        </Trigger>
                    </ControlTemplate.Triggers>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>
    <Style x:Key="VerticalScrollBarPageButtonStyle" TargetType="{x:Type RepeatButton}">
        <Setter Property="OverridesDefaultStyle" Value="true" />
        <Setter Property="IsTabStop" Value="false" />
        <Setter Property="Focusable" Value="false" />
        <Setter Property="MinWidth" Value="{DynamicResource {x:Static SystemParameters.VerticalScrollBarWidthKey}}" />
        <Setter Property="MinHeight"
                Value="{DynamicResource {x:Static SystemParameters.VerticalScrollBarButtonHeightKey}}" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type RepeatButton}">
                    <Rectangle Fill="Transparent" />
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>
    <Style x:Key="ScrollBarThumb" TargetType="{x:Type Thumb}">
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type Thumb}">
                    <Border BorderBrush="Transparent" Background="{StaticResource Border}" />
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>
    <Style x:Key="HorizontalScrollBarPageButtonStyle" TargetType="{x:Type RepeatButton}">
        <Setter Property="OverridesDefaultStyle" Value="true" />
        <Setter Property="IsTabStop" Value="false" />
        <Setter Property="Focusable" Value="false" />
        <Setter Property="MinHeight" Value="{DynamicResource {x:Static SystemParameters.HorizontalScrollBarHeightKey}}" />
        <Setter Property="MinWidth"
                Value="{DynamicResource {x:Static SystemParameters.HorizontalScrollBarButtonWidthKey}}" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type RepeatButton}">
                    <Rectangle Fill="Transparent" />
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>
    <Style TargetType="{x:Type ScrollBar}">
        <Setter Property="Stylus.IsPressAndHoldEnabled" Value="false" />
        <Setter Property="Stylus.IsFlicksEnabled" Value="false" />
        <Setter Property="Background" Value="{StaticResource HighlightBackground}" />
        <Setter Property="Foreground" Value="{StaticResource Border}" />
        <Setter Property="BorderThickness" Value="0" />
        <Setter Property="Width" Value="{DynamicResource {x:Static SystemParameters.VerticalScrollBarWidthKey}}" />
        <Setter Property="MinWidth" Value="{DynamicResource {x:Static SystemParameters.VerticalScrollBarWidthKey}}" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type ScrollBar}">
                    <Grid Background="{TemplateBinding Background}">
                        <Grid.RowDefinitions>
                            <RowDefinition
                                MaxHeight="{DynamicResource {x:Static SystemParameters.VerticalScrollBarButtonHeightKey}}" />
                            <RowDefinition Height="0.00001*" />
                            <RowDefinition
                                MaxHeight="{DynamicResource {x:Static SystemParameters.VerticalScrollBarButtonHeightKey}}" />
                        </Grid.RowDefinitions>
                        <Viewbox Stretch="Fill">
                            <RepeatButton Content="M 0 4 L 7 4 L 3.5 0 Z" Command="{x:Static ScrollBar.LineUpCommand}"
                                          Height="{DynamicResource {x:Static SystemParameters.VerticalScrollBarButtonHeightKey}}"
                                          MinWidth="{DynamicResource {x:Static SystemParameters.VerticalScrollBarWidthKey}}"
                                          Style="{StaticResource ScrollBarLineButtonStyle}" />
                        </Viewbox>
                        <Rectangle Fill="Transparent" Grid.Row="1" />
                        <Track x:Name="PART_Track" IsDirectionReversed="true" Grid.Row="1">
                            <Track.DecreaseRepeatButton>
                                <RepeatButton Command="{x:Static ScrollBar.PageUpCommand}"
                                              Style="{StaticResource VerticalScrollBarPageButtonStyle}" />
                            </Track.DecreaseRepeatButton>
                            <Track.IncreaseRepeatButton>
                                <RepeatButton Command="{x:Static ScrollBar.PageDownCommand}"
                                              Style="{StaticResource VerticalScrollBarPageButtonStyle}" />
                            </Track.IncreaseRepeatButton>
                            <Track.Thumb>
                                <Thumb Style="{StaticResource ScrollBarThumb}" Margin="2,0,2,0" />
                            </Track.Thumb>
                        </Track>
                        <Viewbox Grid.Row="2" Stretch="Fill">
                            <RepeatButton Content="M 0 0 L 3.5 4 L 7 0 Z"
                                          Command="{x:Static ScrollBar.LineDownCommand}"
                                          Height="{DynamicResource {x:Static SystemParameters.VerticalScrollBarButtonHeightKey}}"
                                          MinWidth="{DynamicResource {x:Static SystemParameters.VerticalScrollBarWidthKey}}"
                                          Style="{StaticResource ScrollBarLineButtonStyle}" />
                        </Viewbox>
                    </Grid>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
        <Style.Triggers>
            <Trigger Property="Orientation" Value="Horizontal">
                <Setter Property="Width" Value="Auto" />
                <Setter Property="MinWidth" Value="0" />
                <Setter Property="Height"
                        Value="{DynamicResource {x:Static SystemParameters.HorizontalScrollBarHeightKey}}" />
                <Setter Property="MinHeight"
                        Value="{DynamicResource {x:Static SystemParameters.HorizontalScrollBarHeightKey}}" />
                <Setter Property="Template">
                    <Setter.Value>
                        <ControlTemplate TargetType="{x:Type ScrollBar}">
                            <Grid Background="{TemplateBinding Background}">
                                <Grid.ColumnDefinitions>
                                    <ColumnDefinition
                                        MaxWidth="{DynamicResource {x:Static SystemParameters.HorizontalScrollBarButtonWidthKey}}" />
                                    <ColumnDefinition Width="0.00001*" />
                                    <ColumnDefinition
                                        MaxWidth="{DynamicResource {x:Static SystemParameters.HorizontalScrollBarButtonWidthKey}}" />
                                </Grid.ColumnDefinitions>
                                <Viewbox Stretch="Fill">
                                    <RepeatButton Content="M 0 4 L 4 8 L 4 0 Z"
                                                  Command="{x:Static ScrollBar.LineLeftCommand}"
                                                  MinHeight="{DynamicResource {x:Static SystemParameters.HorizontalScrollBarHeightKey}}"
                                                  Style="{StaticResource ScrollBarLineButtonStyle}"
                                                  Width="{DynamicResource {x:Static SystemParameters.HorizontalScrollBarButtonWidthKey}}" />
                                </Viewbox>
                                <Rectangle Fill="Transparent" Grid.Column="1" />
                                <Track x:Name="PART_Track" Grid.Column="1">
                                    <Track.DecreaseRepeatButton>
                                        <RepeatButton Command="{x:Static ScrollBar.PageLeftCommand}"
                                                      Style="{StaticResource HorizontalScrollBarPageButtonStyle}" />
                                    </Track.DecreaseRepeatButton>
                                    <Track.IncreaseRepeatButton>
                                        <RepeatButton Command="{x:Static ScrollBar.PageRightCommand}"
                                                      Style="{StaticResource HorizontalScrollBarPageButtonStyle}" />
                                    </Track.IncreaseRepeatButton>
                                    <Track.Thumb>
                                        <Thumb Style="{StaticResource ScrollBarThumb}" Margin="0,2,0,2" />
                                    </Track.Thumb>
                                </Track>
                                <Viewbox Grid.Column="2" Stretch="Fill">
                                    <RepeatButton Content="M 0 0 L 0 8 L 4 4 Z"
                                                  Command="{x:Static ScrollBar.LineRightCommand}"
                                                  MinHeight="{DynamicResource {x:Static SystemParameters.HorizontalScrollBarHeightKey}}"
                                                  Style="{StaticResource ScrollBarLineButtonStyle}"
                                                  Width="{DynamicResource {x:Static SystemParameters.HorizontalScrollBarButtonWidthKey}}" />
                                </Viewbox>
                            </Grid>
                        </ControlTemplate>
                    </Setter.Value>
                </Setter>
            </Trigger>
        </Style.Triggers>
    </Style>

    <PopupAnimation x:Key="{x:Static SystemParameters.ComboBoxPopupAnimationKey}">None</PopupAnimation>
    <Style x:Key="ComboBoxFocusVisual">
        <Setter Property="Control.Template">
            <Setter.Value>
                <ControlTemplate>
                    <Rectangle Margin="4,4,21,4" SnapsToDevicePixels="true" Stroke="{StaticResource Border}"
                               StrokeThickness="1" StrokeDashArray="1 2" />
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>
    <Geometry x:Key="DownArrowGeometry">M 0 0 L 3.5 4 L 7 0 Z</Geometry>
    <Style x:Key="ComboBoxTransparentButtonStyle" TargetType="{x:Type ToggleButton}">
        <Setter Property="MinWidth" Value="0" />
        <Setter Property="MinHeight" Value="0" />
        <Setter Property="Width" Value="Auto" />
        <Setter Property="Height" Value="Auto" />
        <Setter Property="Background" Value="Transparent" />
        <Setter Property="Foreground" Value="{StaticResource Foreground}" />
        <Setter Property="BorderBrush" Value="{StaticResource Border}" />
        <Setter Property="BorderThickness" Value="1,0,0,0" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type ToggleButton}">
                    <DockPanel Background="{TemplateBinding Background}" LastChildFill="false"
                               SnapsToDevicePixels="true">
                        <Border x:Name="Border" BorderBrush="{TemplateBinding BorderBrush}"
                                BorderThickness="{TemplateBinding BorderThickness}"
                                Background="{StaticResource ControlBackground}" DockPanel.Dock="Right"
                                Width="{DynamicResource {x:Static SystemParameters.VerticalScrollBarWidthKey}}">
                            <Path Data="{StaticResource DownArrowGeometry}" Fill="{TemplateBinding Foreground}"
                                  HorizontalAlignment="Center" VerticalAlignment="Center" />
                        </Border>
                    </DockPanel>
                    <ControlTemplate.Triggers>
                        <Trigger Property="IsMouseOver" Value="true">
                            <Setter Property="Background" TargetName="Border"
                                    Value="{StaticResource HighlightBackground}" />
                        </Trigger>
                        <DataTrigger
                            Binding="{Binding IsDropDownOpen, RelativeSource={RelativeSource FindAncestor, AncestorType={x:Type ComboBox}}}"
                            Value="true">
                            <Setter Property="Background" TargetName="Border"
                                    Value="{StaticResource HighlightBackground}" />
                        </DataTrigger>
                    </ControlTemplate.Triggers>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
        <Style.Triggers>
            <Trigger Property="IsEnabled" Value="false">
                <Setter Property="Foreground" Value="{StaticResource DisabledForeground}" />
            </Trigger>
        </Style.Triggers>
    </Style>
    <Style x:Key="ComboBoxEditableTextBox" TargetType="{x:Type TextBox}">
        <Setter Property="OverridesDefaultStyle" Value="true" />
        <Setter Property="AllowDrop" Value="true" />
        <Setter Property="MinWidth" Value="0" />
        <Setter Property="MinHeight" Value="0" />
        <Setter Property="FocusVisualStyle" Value="{x:Null}" />
        <Setter Property="ScrollViewer.PanningMode" Value="VerticalFirst" />
        <Setter Property="Stylus.IsFlicksEnabled" Value="False" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type TextBox}">
                    <ScrollViewer x:Name="PART_ContentHost" Background="Transparent" Focusable="false"
                                  HorizontalScrollBarVisibility="Hidden" VerticalScrollBarVisibility="Hidden" />
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>
    <ControlTemplate x:Key="ComboBoxEditableTemplate" TargetType="{x:Type ComboBox}">
        <Border BorderBrush="{TemplateBinding BorderBrush}" BorderThickness="{TemplateBinding BorderThickness}"
                Background="{TemplateBinding Background}" SnapsToDevicePixels="true">
            <Grid>
                <Border x:Name="Border" BorderBrush="{StaticResource Border}" BorderThickness="2"
                        Background="{TemplateBinding Background}">
                    <Popup x:Name="PART_Popup" AllowsTransparency="true" Focusable="False"
                           IsOpen="{TemplateBinding IsDropDownOpen}"
                           PopupAnimation="{DynamicResource {x:Static SystemParameters.ComboBoxPopupAnimationKey}}"
                           Placement="Bottom">
                        <Border x:Name="DropDownBorder" BorderBrush="{StaticResource Border}" BorderThickness="1"
                                Background="{StaticResource ControlBackground}"
                                MaxHeight="{TemplateBinding MaxDropDownHeight}"
                                MinWidth="{Binding ActualWidth, ElementName=Border}">
                            <ScrollViewer x:Name="DropDownScrollViewer">
                                <Grid RenderOptions.ClearTypeHint="Enabled">
                                    <Canvas HorizontalAlignment="Left" Height="0" VerticalAlignment="Top" Width="0">
                                        <Rectangle x:Name="OpaqueRect"
                                                   Fill="{Binding Background, ElementName=DropDownBorder}"
                                                   Height="{Binding ActualHeight, ElementName=DropDownBorder}"
                                                   Width="{Binding ActualWidth, ElementName=DropDownBorder}" />
                                    </Canvas>
                                    <ItemsPresenter x:Name="ItemsPresenter"
                                                    KeyboardNavigation.DirectionalNavigation="Contained"
                                                    SnapsToDevicePixels="{TemplateBinding SnapsToDevicePixels}" />
                                </Grid>
                            </ScrollViewer>
                        </Border>
                    </Popup>
                </Border>
                <ToggleButton ClickMode="Press" Focusable="false"
                              IsChecked="{Binding IsDropDownOpen, Mode=TwoWay, RelativeSource={RelativeSource TemplatedParent}}"
                              Margin="2" MinWidth="0" MinHeight="0"
                              Style="{StaticResource ComboBoxTransparentButtonStyle}" Width="Auto" />
                <DockPanel Margin="2">
                    <FrameworkElement DockPanel.Dock="Right"
                                      Width="{DynamicResource {x:Static SystemParameters.VerticalScrollBarWidthKey}}" />
                    <TextBox x:Name="PART_EditableTextBox"
                             HorizontalContentAlignment="{TemplateBinding HorizontalContentAlignment}"
                             IsReadOnly="{Binding IsReadOnly, RelativeSource={RelativeSource TemplatedParent}}"
                             Margin="{TemplateBinding Padding}" Style="{StaticResource ComboBoxEditableTextBox}"
                             VerticalContentAlignment="{TemplateBinding VerticalContentAlignment}" />
                </DockPanel>
            </Grid>
        </Border>
        <ControlTemplate.Triggers>
            <Trigger Property="HasItems" Value="false">
                <Setter Property="MinHeight" TargetName="DropDownBorder" Value="95" />
            </Trigger>
            <Trigger Property="IsEnabled" Value="false">
                <Setter Property="Foreground" Value="{DynamicResource DisabledForeground}" />
                <Setter Property="Background" Value="{DynamicResource DisabledBackground}" />
            </Trigger>
            <Trigger Property="IsGrouping" Value="true">
                <Setter Property="ScrollViewer.CanContentScroll" Value="false" />
            </Trigger>
            <Trigger Property="ScrollViewer.CanContentScroll" SourceName="DropDownScrollViewer" Value="false">
                <Setter Property="Canvas.Top" TargetName="OpaqueRect"
                        Value="{Binding VerticalOffset, ElementName=DropDownScrollViewer}" />
                <Setter Property="Canvas.Left" TargetName="OpaqueRect"
                        Value="{Binding HorizontalOffset, ElementName=DropDownScrollViewer}" />
            </Trigger>
        </ControlTemplate.Triggers>
    </ControlTemplate>
    <Style TargetType="{x:Type ComboBox}">
        <Setter Property="FocusVisualStyle" Value="{StaticResource ComboBoxFocusVisual}" />
        <Setter Property="Foreground" Value="{StaticResource Foreground}" />
        <Setter Property="Background" Value="{StaticResource ControlBackground}" />
        <Setter Property="BorderBrush" Value="{StaticResource Border}" />
        <Setter Property="BorderThickness" Value="1" />
        <Setter Property="Margin" Value="0,0,0,0" />
        <Setter Property="Padding" Value="2,1" />
        <Setter Property="ScrollViewer.HorizontalScrollBarVisibility" Value="Auto" />
        <Setter Property="ScrollViewer.VerticalScrollBarVisibility" Value="Auto" />
        <Setter Property="ScrollViewer.CanContentScroll" Value="true" />
        <Setter Property="ScrollViewer.PanningMode" Value="Both" />
        <Setter Property="Stylus.IsFlicksEnabled" Value="False" />
        <Setter Property="VerticalContentAlignment" Value="Center" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type ComboBox}">
                    <Border x:Name="Border" BorderBrush="{TemplateBinding BorderBrush}"
                            BorderThickness="{TemplateBinding BorderThickness}"
                            Background="{TemplateBinding Background}" SnapsToDevicePixels="true">
                        <Grid>
                            <Popup x:Name="PART_Popup" AllowsTransparency="true" Focusable="False"
                                   IsOpen="{TemplateBinding IsDropDownOpen}"
                                   PopupAnimation="{DynamicResource {x:Static SystemParameters.ComboBoxPopupAnimationKey}}"
                                   Placement="Bottom">
                                <Border x:Name="DropDownBorder" BorderBrush="{StaticResource Border}"
                                        BorderThickness="1" Background="{StaticResource ControlBackground}"
                                        MaxHeight="{TemplateBinding MaxDropDownHeight}"
                                        MinWidth="{Binding ActualWidth, ElementName=Border}">
                                    <Border.Effect>
                                        <DropShadowEffect BlurRadius="4" Opacity="0.8" ShadowDepth="1" />
                                    </Border.Effect>
                                    <ScrollViewer x:Name="DropDownScrollViewer">
                                        <Grid RenderOptions.ClearTypeHint="Enabled">
                                            <Canvas HorizontalAlignment="Left" Height="0" VerticalAlignment="Top"
                                                    Width="0">
                                                <Rectangle x:Name="OpaqueRect"
                                                           Fill="{Binding Background, ElementName=DropDownBorder}"
                                                           Height="{Binding ActualHeight, ElementName=DropDownBorder}"
                                                           Width="{Binding ActualWidth, ElementName=DropDownBorder}" />
                                            </Canvas>
                                            <ItemsPresenter x:Name="ItemsPresenter"
                                                            KeyboardNavigation.DirectionalNavigation="Contained"
                                                            SnapsToDevicePixels="{TemplateBinding SnapsToDevicePixels}" />
                                        </Grid>
                                    </ScrollViewer>
                                </Border>
                            </Popup>
                            <DockPanel Margin="2">
                                <FrameworkElement DockPanel.Dock="Right"
                                                  Width="{DynamicResource {x:Static SystemParameters.VerticalScrollBarWidthKey}}" />
                                <Border Margin="{TemplateBinding Padding}">
                                    <ContentPresenter ContentTemplate="{TemplateBinding SelectionBoxItemTemplate}"
                                                      ContentTemplateSelector="{TemplateBinding ItemTemplateSelector}"
                                                      Content="{TemplateBinding SelectionBoxItem}"
                                                      ContentStringFormat="{TemplateBinding SelectionBoxItemStringFormat}"
                                                      HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}"
                                                      Margin="1,1,1,1"
                                                      SnapsToDevicePixels="{TemplateBinding SnapsToDevicePixels}"
                                                      VerticalAlignment="{TemplateBinding VerticalContentAlignment}" />
                                </Border>
                            </DockPanel>
                            <ToggleButton ClickMode="Press" Focusable="false"
                                          IsChecked="{Binding IsDropDownOpen, Mode=TwoWay, RelativeSource={RelativeSource TemplatedParent}}"
                                          Style="{StaticResource ComboBoxTransparentButtonStyle}" Width="Auto" />
                        </Grid>
                    </Border>
                    <ControlTemplate.Triggers>
                        <Trigger Property="HasItems" Value="false">
                            <Setter Property="MinHeight" TargetName="DropDownBorder" Value="95" />
                        </Trigger>
                        <Trigger Property="IsEnabled" Value="false">
                            <Setter Property="Foreground" Value="{DynamicResource DisabledForeground}" />
                            <Setter Property="Background" Value="{DynamicResource DisabledBackground}" />
                        </Trigger>
                        <Trigger Property="IsGrouping" Value="true">
                            <Setter Property="ScrollViewer.CanContentScroll" Value="false" />
                        </Trigger>
                        <Trigger Property="ScrollViewer.CanContentScroll" SourceName="DropDownScrollViewer"
                                 Value="false">
                            <Setter Property="Canvas.Top" TargetName="OpaqueRect"
                                    Value="{Binding VerticalOffset, ElementName=DropDownScrollViewer}" />
                            <Setter Property="Canvas.Left" TargetName="OpaqueRect"
                                    Value="{Binding HorizontalOffset, ElementName=DropDownScrollViewer}" />
                        </Trigger>
                    </ControlTemplate.Triggers>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
        <Style.Triggers>
            <Trigger Property="IsEditable" Value="true">
                <Setter Property="IsTabStop" Value="false" />
                <Setter Property="Padding" Value="1" />
                <Setter Property="Template" Value="{StaticResource ComboBoxEditableTemplate}" />
            </Trigger>
        </Style.Triggers>
    </Style>

    <Style TargetType="{x:Type ComboBoxItem}">
        <Setter Property="MinHeight" Value="20" />
        <Setter Property="FocusVisualStyle" Value="{x:Null}" />
        <Setter Property="Padding" Value="4,2" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type ComboBoxItem}">
                    <Border x:Name="ListBoxItemRoot" BorderBrush="{TemplateBinding BorderBrush}"
                            BorderThickness="{TemplateBinding BorderThickness}"
                            Background="{TemplateBinding Background}">
                        <ContentPresenter ContentTemplate="{TemplateBinding ContentTemplate}"
                                          Content="{TemplateBinding Content}"
                                          HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}"
                                          Margin="{TemplateBinding Padding}"
                                          VerticalAlignment="{TemplateBinding VerticalContentAlignment}" />
                    </Border>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
        <Style.Triggers>
            <MultiTrigger>
                <MultiTrigger.Conditions>
                    <Condition Property="IsMouseOver" Value="True" />
                    <Condition Property="IsSelected" Value="False" />
                </MultiTrigger.Conditions>
                <Setter Property="Background" Value="{StaticResource HighlightBackground}" />
            </MultiTrigger>
            <MultiDataTrigger>
                <MultiDataTrigger.Conditions>
                    <Condition Binding="{Binding IsSelected, RelativeSource={RelativeSource Self}}" Value="True" />
                    <Condition
                        Binding="{Binding IsEditable, RelativeSource={RelativeSource FindAncestor, AncestorLevel=1, AncestorType={x:Type ComboBox}}}"
                        Value="True" />
                </MultiDataTrigger.Conditions>
                <Setter Property="Background" Value="{StaticResource HighlightBackground}" />
            </MultiDataTrigger>
            <MultiDataTrigger>
                <MultiDataTrigger.Conditions>
                    <Condition Binding="{Binding IsFocused, RelativeSource={RelativeSource Self}}" Value="True" />
                    <Condition
                        Binding="{Binding IsEditable, RelativeSource={RelativeSource FindAncestor, AncestorLevel=1, AncestorType={x:Type ComboBox}}}"
                        Value="False" />
                </MultiDataTrigger.Conditions>
                <Setter Property="Background" Value="{StaticResource HighlightBackground}" />
            </MultiDataTrigger>
            <Trigger Property="IsEnabled" Value="False">
                <Setter Property="Foreground" Value="{StaticResource DisabledForeground}" />
            </Trigger>
        </Style.Triggers>
    </Style>

    <Style TargetType="{x:Type ProgressBar}">
        <Setter Property="Background" Value="{StaticResource ControlBackground}" />
        <Setter Property="Foreground" Value="{StaticResource Foreground}" />
        <Setter Property="BorderBrush" Value="{StaticResource Border}" />
        <Setter Property="BorderThickness" Value="1" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type ProgressBar}">
                    <Grid MinHeight="14" MinWidth="200" Background="{TemplateBinding Background}">
                        <VisualStateManager.VisualStateGroups>
                            <VisualStateGroup x:Name="CommonStates">
                                <VisualState x:Name="Determinate" />
                                <VisualState x:Name="Indeterminate">
                                    <Storyboard>
                                        <ObjectAnimationUsingKeyFrames Duration="0"
                                                                       Storyboard.TargetName="PART_Indicator"
                                                                       Storyboard.TargetProperty="Background">
                                            <DiscreteObjectKeyFrame KeyTime="0">
                                                <DiscreteObjectKeyFrame.Value>
                                                    <SolidColorBrush Color="Transparent" />
                                                </DiscreteObjectKeyFrame.Value>
                                            </DiscreteObjectKeyFrame>
                                        </ObjectAnimationUsingKeyFrames>

                                        <ObjectAnimationUsingKeyFrames Duration="0"
                                                                       Storyboard.TargetName="Animation"
                                                                       Storyboard.TargetProperty="Visibility">
                                            <DiscreteObjectKeyFrame KeyTime="0">
                                                <DiscreteObjectKeyFrame.Value>
                                                    <Visibility>Visible</Visibility>
                                                </DiscreteObjectKeyFrame.Value>
                                            </DiscreteObjectKeyFrame>
                                        </ObjectAnimationUsingKeyFrames>

                                        <DoubleAnimation
                                            Storyboard.TargetName="animTranslate"
                                            Storyboard.TargetProperty="X"
                                            From="0" To="50" Duration="0:0:1" RepeatBehavior="Forever" />
                                    </Storyboard>
                                </VisualState>
                            </VisualStateGroup>
                        </VisualStateManager.VisualStateGroups>
                        <Border x:Name="PART_Track"
                                BorderThickness="{TemplateBinding BorderThickness}"
                                BorderBrush="{TemplateBinding BorderBrush}" />
                        <Border x:Name="PART_Indicator"
                                HorizontalAlignment="Left"
                                Background="{TemplateBinding Foreground}"
                                Margin="3">
                            <Border x:Name="Animation" Visibility="Hidden">
                                <Border.Background>
                                    <DrawingBrush TileMode="Tile" Viewport="0,0,25,25" ViewportUnits="Absolute">
                                        <DrawingBrush.Transform>
                                            <TranslateTransform x:Name="animTranslate" />
                                        </DrawingBrush.Transform>
                                        <DrawingBrush.Drawing>
                                            <GeometryDrawing>
                                                <GeometryDrawing.Brush>
                                                    <LinearGradientBrush SpreadMethod="Repeat" StartPoint="0,0"
                                                                         EndPoint="1,1">
                                                        <LinearGradientBrush.RelativeTransform>
                                                            <ScaleTransform ScaleX="0.5" ScaleY="0.5" />
                                                        </LinearGradientBrush.RelativeTransform>
                                                        <GradientStop Offset="0" Color="Transparent" />
                                                        <GradientStop Offset="0.5" Color="Transparent" />
                                                        <GradientStop Offset="0.5"
                                                                      Color="{Binding Foreground, Converter={x:Static local:BrushToColorConverter.Instance}, RelativeSource={RelativeSource Mode=TemplatedParent}}" />
                                                        <GradientStop Offset="1"
                                                                      Color="{Binding Foreground, Converter={x:Static local:BrushToColorConverter.Instance}, RelativeSource={RelativeSource Mode=TemplatedParent}}" />
                                                    </LinearGradientBrush>
                                                </GeometryDrawing.Brush>
                                                <GeometryDrawing.Geometry>
                                                    <RectangleGeometry Rect="0,0,10,10" />
                                                </GeometryDrawing.Geometry>
                                            </GeometryDrawing>
                                        </DrawingBrush.Drawing>
                                    </DrawingBrush>
                                </Border.Background>
                            </Border>
                        </Border>
                    </Grid>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>

    <Style TargetType="{x:Type Hyperlink}">
        <Style.Triggers>
            <Trigger Property="IsMouseOver" Value="True">
                <Setter Property="TextBlock.TextDecorations" Value="Underline" />
            </Trigger>
        </Style.Triggers>
        <Setter Property="Foreground" Value="{StaticResource Foreground}" />
        <Setter Property="TextBlock.TextDecorations" Value="{x:Null}" />
    </Style>
</ResourceDictionary>


================================================
File: ConfuserEx/StackTraceDecoder.xaml
================================================
ï»¿<Window x:Class="ConfuserEx.StackTraceDecoder"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:local="clr-namespace:ConfuserEx"
        Style="{StaticResource DarkWindow}" ShowInTaskbar="False"
        Title="Stack Trace Decoder" Height="400" Width="600">
    <Grid Margin="10">
        <Grid.RowDefinitions>
            <RowDefinition Height="36px" />
            <RowDefinition Height="36px" />
            <RowDefinition Height="*" />
        </Grid.RowDefinitions>
        <Grid.ColumnDefinitions>
            <ColumnDefinition Width="Auto"/>
            <ColumnDefinition Width="*"/>
        </Grid.ColumnDefinitions>
        <Border Grid.RowSpan="2" Grid.Column="0" BorderThickness="0,0,1,0" BorderBrush="{StaticResource Border}" Margin="5">
            <StackPanel VerticalAlignment="Center">
                <RadioButton x:Name="optSym" Margin="5" IsChecked="True">Symbol Map</RadioButton>
                <RadioButton x:Name="optPass" Margin="5">Password</RadioButton>
            </StackPanel>
        </Border>
        <DockPanel Grid.Row="0" Grid.Column="1" Visibility="{Binding IsChecked, ElementName=optSym, Converter={x:Static local:BoolToVisibilityConverter.Instance}}">
            <Label DockPanel.Dock="Left" VerticalAlignment="Center" HorizontalAlignment="Right">Symbol Map:</Label>
            <Button DockPanel.Dock="Right" Margin="5" VerticalAlignment="Center" Height="26" Width="25"
                    Click="ChooseMapPath">
                <TextBlock FontSize="14px" FontFamily="{DynamicResource FontAwesome}" Text="&#xf141;" Height="10px"
                           TextOptions.TextRenderingMode="GrayScale" />
            </Button>
            <TextBox x:Name="PathBox" Grid.Row="1" Grid.Column="1" Margin="5" VerticalContentAlignment="Center"
                     TextChanged="PathBox_TextChanged"
                     local:FileDragDrop.Command="{x:Static local:FileDragDrop.FileCmd}" />
        </DockPanel>
        <DockPanel Grid.Row="0" Grid.Column="1" Visibility="{Binding IsChecked, ElementName=optPass, Converter={x:Static local:BoolToVisibilityConverter.Instance}}">
            <Label DockPanel.Dock="Left" VerticalAlignment="Center" HorizontalAlignment="Right">Password:</Label>
            <TextBox x:Name="PassBox" Grid.Row="1" Grid.Column="1" Margin="5" VerticalContentAlignment="Center"/>
        </DockPanel>
        <DockPanel Grid.Row="1" Grid.Column="1">
            <Button DockPanel.Dock="Right" Margin="5" Padding="10,0,10,0" Click="Decode_Click">Decode!</Button>
            <Label x:Name="status" HorizontalAlignment="Left" VerticalAlignment="Center" Margin="5,2,10,2" />
        </DockPanel>
        <TextBox x:Name="stackTrace" Grid.ColumnSpan="2" Grid.Row="2" Margin="5" AcceptsReturn="True" FontFamily="Consolas"
                 ScrollViewer.HorizontalScrollBarVisibility="Auto" ScrollViewer.VerticalScrollBarVisibility="Visible" />
    </Grid>
</Window>


================================================
File: ConfuserEx/StackTraceDecoder.xaml.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.IO;
using System.Text.RegularExpressions;
using System.Windows;
using System.Windows.Controls;
using Confuser.Core;
using Confuser.Renamer;
using Ookii.Dialogs.Wpf;

namespace ConfuserEx {
	/// <summary>
	///     Interaction logic for StackTraceDecoder.xaml
	/// </summary>
	public partial class StackTraceDecoder : Window {
		public StackTraceDecoder() {
			InitializeComponent();
		}

		readonly Dictionary<string, string> symMap = new Dictionary<string, string>();

		void PathBox_TextChanged(object sender, TextChangedEventArgs e) {
			if (File.Exists(PathBox.Text))
				LoadSymMap(PathBox.Text);
		}

		void LoadSymMap(string path) {
			string shortPath = path;
			if (path.Length > 35)
				shortPath = "..." + path.Substring(path.Length - 35, 35);

			try {
				symMap.Clear();
				using (var reader = new StreamReader(File.OpenRead(path))) {
					var line = reader.ReadLine();
					while (line != null) {
						int tabIndex = line.IndexOf('\t');
						if (tabIndex == -1)
							throw new FileFormatException();
						symMap.Add(line.Substring(0, tabIndex), line.Substring(tabIndex + 1));
						line = reader.ReadLine();
					}
				}
				status.Content = "Loaded symbol map from '" + shortPath + "' successfully.";
			}
			catch {
				status.Content = "Failed to load symbol map from '" + shortPath + "'.";
			}
		}

		void ChooseMapPath(object sender, RoutedEventArgs e) {
			var ofd = new VistaOpenFileDialog();
			ofd.Filter = "Symbol maps (*.map)|*.map|All Files (*.*)|*.*";
			if (ofd.ShowDialog() ?? false) {
				PathBox.Text = ofd.FileName;
			}
		}

		readonly Regex mapSymbolMatcher = new Regex("_[a-zA-Z0-9]+");
		readonly Regex passSymbolMatcher = new Regex("[a-zA-Z0-9_$]{23,}");
		ReversibleRenamer renamer;

		void Decode_Click(object sender, RoutedEventArgs e) {
			var trace = stackTrace.Text;
			if (optSym.IsChecked ?? true)
				stackTrace.Text = mapSymbolMatcher.Replace(trace, DecodeSymbolMap);
			else {
				renamer = new ReversibleRenamer(PassBox.Text);
				stackTrace.Text = passSymbolMatcher.Replace(trace, DecodeSymbolPass);
			}
		}

		string DecodeSymbolMap(Match match) {
			var sym = match.Value;
			return symMap.GetValueOrDefault(sym, sym);
		}

		string DecodeSymbolPass(Match match) {
			var sym = match.Value;
			try {
				return renamer.Decrypt(sym);
			}
			catch {
				return sym;
			}
		}
	}
}


================================================
File: ConfuserEx/Views.xaml
================================================
ï»¿<ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
    <ResourceDictionary.MergedDictionaries>
        <ResourceDictionary Source="Views\ProjectTabView.xaml" />
        <ResourceDictionary Source="Views\SettingsTabView.xaml" />
        <ResourceDictionary Source="Views\ProtectTabView.xaml" />
        <ResourceDictionary Source="Views\AboutTabView.xaml" />
    </ResourceDictionary.MergedDictionaries>
</ResourceDictionary>


================================================
File: ConfuserEx/app.config
================================================
<?xml version="1.0"?>

<configuration>
  <runtime>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="Microsoft.Practices.ServiceLocation" publicKeyToken="31BF3856AD364E35"
                          culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-1.2.0.0" newVersion="1.2.0.0" />
      </dependentAssembly>
    </assemblyBinding>
    <loadFromRemoteSources enabled="true" />
  </runtime>
</configuration>


================================================
File: ConfuserEx/packages.config
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>

<packages>
  <package id="CommonServiceLocator" version="1.2" targetFramework="net40" />
  <package id="MvvmLightLibs" version="4.3.31.1" targetFramework="net40" />
</packages>


================================================
File: ConfuserEx/Properties/AssemblyInfo.cs
================================================
ï»¿using System;
using System.Reflection;

[assembly: AssemblyTitle("ConfuserEx")]
[assembly: AssemblyDescription("ConfuserEx GUI")]


================================================
File: ConfuserEx/Resources/CREDITS
================================================
Icons adapted from http://flaticons.net


================================================
File: ConfuserEx/Resources/FontAwesome.otf
================================================
[Non-text file]


================================================
File: ConfuserEx/ViewModel/IViewModel.cs
================================================
ï»¿using System;

namespace ConfuserEx.ViewModel {
	public interface IViewModel<TModel> {
		TModel Model { get; }
	}
}


================================================
File: ConfuserEx/ViewModel/StringItem.cs
================================================
ï»¿using System;

namespace ConfuserEx.ViewModel {
	public class StringItem : IViewModel<string> {
		public StringItem(string item) {
			Item = item;
		}

		public string Item { get; private set; }

		string IViewModel<string>.Model {
			get { return Item; }
		}

		public override string ToString() {
			return Item;
		}
	}
}


================================================
File: ConfuserEx/ViewModel/Utils.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.Linq;

namespace ConfuserEx.ViewModel {
	public static class Utils {
		public static ObservableCollection<T> Wrap<T>(IList<T> list) {
			var ret = new ObservableCollection<T>(list);

			ret.CollectionChanged += (sender, e) => {
				var collection = (ObservableCollection<T>)sender;
				switch (e.Action) {
					case NotifyCollectionChangedAction.Reset:
						list.Clear();
						foreach (T item in collection)
							list.Add(item);
						break;

					case NotifyCollectionChangedAction.Add:
						for (int i = 0; i < e.NewItems.Count; i++)
							list.Insert(e.NewStartingIndex + i, (T)e.NewItems[i]);
						break;

					case NotifyCollectionChangedAction.Remove:
						for (int i = 0; i < e.OldItems.Count; i++)
							list.RemoveAt(e.OldStartingIndex);
						break;

					case NotifyCollectionChangedAction.Move:
						list.RemoveAt(e.OldStartingIndex);
						list.Insert(e.NewStartingIndex, (T)e.NewItems[0]);
						break;

					case NotifyCollectionChangedAction.Replace:
						list[e.NewStartingIndex] = (T)e.NewItems[0];
						break;
				}
			};
			return ret;
		}

		public static ObservableCollection<TViewModel> Wrap<TModel, TViewModel>(IList<TModel> list, Func<TModel, TViewModel> transform) where TViewModel : IViewModel<TModel> {
			var ret = new ObservableCollection<TViewModel>(list.Select(item => transform(item)));

			ret.CollectionChanged += (sender, e) => {
				var collection = (ObservableCollection<TViewModel>)sender;
				switch (e.Action) {
					case NotifyCollectionChangedAction.Reset:
						list.Clear();
						foreach (TViewModel item in collection)
							list.Add(item.Model);
						break;

					case NotifyCollectionChangedAction.Add:
						for (int i = 0; i < e.NewItems.Count; i++)
							list.Insert(e.NewStartingIndex + i, ((TViewModel)e.NewItems[i]).Model);
						break;

					case NotifyCollectionChangedAction.Remove:
						for (int i = 0; i < e.OldItems.Count; i++)
							list.RemoveAt(e.OldStartingIndex);
						break;

					case NotifyCollectionChangedAction.Move:
						list.RemoveAt(e.OldStartingIndex);
						list.Insert(e.NewStartingIndex, ((TViewModel)e.NewItems[0]).Model);
						break;

					case NotifyCollectionChangedAction.Replace:
						list[e.NewStartingIndex] = ((TViewModel)e.NewItems[0]).Model;
						break;
				}
			};
			return ret;
		}
	}
}


================================================
File: ConfuserEx/ViewModel/ViewModelBase.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.ComponentModel;

namespace ConfuserEx.ViewModel {
	public class ViewModelBase : INotifyPropertyChanged {
		// http://stackoverflow.com/a/1316417/462805

		public event PropertyChangedEventHandler PropertyChanged;

		protected virtual void OnPropertyChanged(string property) {
			if (PropertyChanged != null)
				PropertyChanged(this, new PropertyChangedEventArgs(property));
		}

		protected bool SetProperty<T>(ref T field, T value, string property) {
			if (!EqualityComparer<T>.Default.Equals(field, value)) {
				field = value;
				OnPropertyChanged(property);
				return true;
			}
			return false;
		}

		protected bool SetProperty<T>(bool changed, Action<T> setter, T value, string property) {
			if (changed) {
				setter(value);
				OnPropertyChanged(property);
				return true;
			}
			return false;
		}
	}
}


================================================
File: ConfuserEx/ViewModel/Project/ProjectModuleVM.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Reflection;
using System.Threading;
using Confuser.Core.Project;

namespace ConfuserEx.ViewModel {
	public class ProjectModuleVM : ViewModelBase, IViewModel<ProjectModule>, IRuleContainer {
		readonly ProjectModule module;
		readonly ProjectVM parent;
		string asmName = "Unknown";
		string simpleName;
		bool isSelected;

		public ProjectModuleVM(ProjectVM parent, ProjectModule module) {
			this.parent = parent;
			this.module = module;

			ObservableCollection<ProjectRuleVM> rules = Utils.Wrap(module.Rules, rule => new ProjectRuleVM(parent, rule));
			rules.CollectionChanged += (sender, e) => parent.IsModified = true;
			Rules = rules;

			if (module.Path != null) {
				SimpleName = System.IO.Path.GetFileName(module.Path);
				LoadAssemblyName();
			}
		}

		public bool IsSelected {
			get { return isSelected; }
			set { SetProperty(ref isSelected, value, "IsSelected"); }
		}

		public ProjectModule Module {
			get { return module; }
		}

		public string Path {
			get { return module.Path; }
			set {
				if (SetProperty(module.Path != value, val => module.Path = val, value, "Path")) {
					parent.IsModified = true;
					SimpleName = System.IO.Path.GetFileName(module.Path);
					LoadAssemblyName();
				}
			}
		}

		public string SimpleName {
			get { return simpleName; }
			private set { SetProperty(ref simpleName, value, "SimpleName"); }
		}

		public string AssemblyName {
			get { return asmName; }
			private set { SetProperty(ref asmName, value, "AssemblyName"); }
		}

		public string SNKeyPath {
			get { return module.SNKeyPath; }
			set {
				if (SetProperty(module.SNKeyPath != value, val => module.SNKeyPath = val, value, "SNKeyPath"))
					parent.IsModified = true;
			}
		}

		public string SNKeyPassword {
			get { return module.SNKeyPassword; }
			set {
				if (SetProperty(module.SNKeyPassword != value, val => module.SNKeyPassword = val, value, "SNKeyPassword"))
					parent.IsModified = true;
			}
		}

		public IList<ProjectRuleVM> Rules { get; private set; }

		ProjectModule IViewModel<ProjectModule>.Model {
			get { return module; }
		}

		void LoadAssemblyName() {
			AssemblyName = "Loading...";
			ThreadPool.QueueUserWorkItem(_ => {
				try {
					string path = System.IO.Path.Combine(parent.BaseDirectory, Path);
					if (!string.IsNullOrEmpty(parent.FileName))
						path = System.IO.Path.Combine(System.IO.Path.GetDirectoryName(parent.FileName), path);
					AssemblyName name = System.Reflection.AssemblyName.GetAssemblyName(path);
					AssemblyName = name.FullName;
				}
				catch {
					AssemblyName = "Unknown";
				}
			});
		}
	}
}


================================================
File: ConfuserEx/ViewModel/Project/ProjectRuleVM.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using Confuser.Core;
using Confuser.Core.Project;
using Confuser.Core.Project.Patterns;

namespace ConfuserEx.ViewModel {
	internal interface IRuleContainer {
		IList<ProjectRuleVM> Rules { get; }
	}

	public class ProjectRuleVM : ViewModelBase, IViewModel<Rule> {
		readonly ProjectVM parent;
		readonly Rule rule;
		string error;
		PatternExpression exp;

		public ProjectRuleVM(ProjectVM parent, Rule rule) {
			this.parent = parent;
			this.rule = rule;

			ObservableCollection<ProjectSettingVM<Protection>> protections = Utils.Wrap(rule, setting => new ProjectSettingVM<Protection>(parent, setting));
			protections.CollectionChanged += (sender, e) => parent.IsModified = true;
			Protections = protections;

			ParseExpression();
		}

		public ProjectVM Project {
			get { return parent; }
		}

		public string Pattern {
			get { return rule.Pattern; }
			set {
				if (SetProperty(rule.Pattern != value, val => rule.Pattern = val, value, "Pattern")) {
					parent.IsModified = true;
					ParseExpression();
				}
			}
		}

		public PatternExpression Expression {
			get { return exp; }
			set { SetProperty(ref exp, value, "Expression"); }
		}

		public string ExpressionError {
			get { return error; }
			set { SetProperty(ref error, value, "ExpressionError"); }
		}

		public ProtectionPreset Preset {
			get { return rule.Preset; }
			set {
				if (SetProperty(rule.Preset != value, val => rule.Preset = val, value, "Preset"))
					parent.IsModified = true;
			}
		}

		public bool Inherit {
			get { return rule.Inherit; }
			set {
				if (SetProperty(rule.Inherit != value, val => rule.Inherit = val, value, "Inherit"))
					parent.IsModified = true;
			}
		}

		public IList<ProjectSettingVM<Protection>> Protections { get; private set; }

		Rule IViewModel<Rule>.Model {
			get { return rule; }
		}

		void ParseExpression() {
			if (Pattern == null)
				return;
			PatternExpression expression;
			try {
				expression = new PatternParser().Parse(Pattern);
				ExpressionError = null;
			}
			catch (Exception e) {
				ExpressionError = e.Message;
				expression = null;
			}
			Expression = expression;
		}
	}
}


================================================
File: ConfuserEx/ViewModel/Project/ProjectSettingVM.cs
================================================
ï»¿using System;
using Confuser.Core.Project;

namespace ConfuserEx.ViewModel {
	public class ProjectSettingVM<T> : ViewModelBase, IViewModel<SettingItem<T>> {
		readonly ProjectVM parent;
		readonly SettingItem<T> setting;

		public ProjectSettingVM(ProjectVM parent, SettingItem<T> setting) {
			this.parent = parent;
			this.setting = setting;
		}

		public string Id {
			get { return setting.Id; }
			set {
				if (SetProperty(setting.Id != value, val => setting.Id = val, value, "Id"))
					parent.IsModified = true;
			}
		}

		public SettingItemAction Action {
			get { return setting.Action; }
			set {
				if (SetProperty(setting.Action != value, val => setting.Action = val, value, "Action"))
					parent.IsModified = true;
			}
		}

		SettingItem<T> IViewModel<SettingItem<T>>.Model {
			get { return setting; }
		}
	}
}


================================================
File: ConfuserEx/ViewModel/Project/ProjectVM.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Reflection;
using Confuser.Core;
using Confuser.Core.Project;

namespace ConfuserEx.ViewModel {
	public class ProjectVM : ViewModelBase, IViewModel<ConfuserProject>, IRuleContainer {
		readonly ConfuserProject proj;
		bool modified;
		ProjectSettingVM<Packer> packer;

		public ProjectVM(ConfuserProject proj, string fileName) {
			this.proj = proj;
			FileName = fileName;

			ObservableCollection<ProjectModuleVM> modules = Utils.Wrap(proj, module => new ProjectModuleVM(this, module));
			modules.CollectionChanged += (sender, e) => IsModified = true;
			Modules = modules;

			ObservableCollection<StringItem> plugins = Utils.Wrap(proj.PluginPaths, path => new StringItem(path));
			plugins.CollectionChanged += (sender, e) => IsModified = true;
			Plugins = plugins;

			ObservableCollection<StringItem> probePaths = Utils.Wrap(proj.ProbePaths, path => new StringItem(path));
			probePaths.CollectionChanged += (sender, e) => IsModified = true;
			ProbePaths = probePaths;

			ObservableCollection<ProjectRuleVM> rules = Utils.Wrap(proj.Rules, rule => new ProjectRuleVM(this, rule));
			rules.CollectionChanged += (sender, e) => IsModified = true;
			Rules = rules;

			Protections = new ObservableCollection<ConfuserComponent>();
			Packers = new ObservableCollection<ConfuserComponent>();
			ComponentDiscovery.LoadComponents(Protections, Packers, Assembly.Load("Confuser.Protections").Location);
			ComponentDiscovery.LoadComponents(Protections, Packers, Assembly.Load("Confuser.Renamer").Location);
		}

		public ConfuserProject Project {
			get { return proj; }
		}

		public bool IsModified {
			get { return modified; }
			set { SetProperty(ref modified, value, "IsModified"); }
		}

		public string Seed {
			get { return proj.Seed; }
			set { SetProperty(proj.Seed != value, val => proj.Seed = val, value, "Seed"); }
		}

		public bool Debug {
			get { return proj.Debug; }
			set { SetProperty(proj.Debug != value, val => proj.Debug = val, value, "Debug"); }
		}

		public string BaseDirectory {
			get { return proj.BaseDirectory; }
			set { SetProperty(proj.BaseDirectory != value, val => proj.BaseDirectory = val, value, "BaseDirectory"); }
		}

		public string OutputDirectory {
			get { return proj.OutputDirectory; }
			set { SetProperty(proj.OutputDirectory != value, val => proj.OutputDirectory = val, value, "OutputDirectory"); }
		}

		public ProjectSettingVM<Packer> Packer {
			get {
				if (proj.Packer == null)
					packer = null;
				else
					packer = new ProjectSettingVM<Packer>(this, proj.Packer);
				return packer;
			}
			set {
				var vm = (IViewModel<SettingItem<Packer>>)value;
				bool changed = (vm == null && proj.Packer != null) || (vm != null && proj.Packer != vm.Model);
				SetProperty(changed, val => proj.Packer = val == null ? null : val.Model, vm, "Packer");
			}
		}

		public IList<ProjectModuleVM> Modules { get; private set; }
		public IList<StringItem> Plugins { get; private set; }
		public IList<StringItem> ProbePaths { get; private set; }

		public ObservableCollection<ConfuserComponent> Protections { get; private set; }
		public ObservableCollection<ConfuserComponent> Packers { get; private set; }
		public IList<ProjectRuleVM> Rules { get; private set; }

		public string FileName { get; set; }

		ConfuserProject IViewModel<ConfuserProject>.Model {
			get { return proj; }
		}

		protected override void OnPropertyChanged(string property) {
			base.OnPropertyChanged(property);
			if (property != "IsModified")
				IsModified = true;
		}
	}
}


================================================
File: ConfuserEx/ViewModel/UI/AboutTabVM.cs
================================================
ï»¿using System;
using System.Diagnostics;
using System.Linq;
using System.Windows.Input;
using System.Windows.Media.Imaging;
using GalaSoft.MvvmLight.Command;

namespace ConfuserEx.ViewModel {
	internal class AboutTabVM : TabViewModel {
		public AboutTabVM(AppVM app)
			: base(app, "About") {
			var decoder = new IconBitmapDecoder(new Uri("pack://application:,,,/ConfuserEx.ico"), BitmapCreateOptions.DelayCreation, BitmapCacheOption.OnDemand);

			Icon = decoder.Frames.First(frame => frame.Width == 64);
		}

		public ICommand LaunchBrowser {
			get { return new RelayCommand<string>(site => Process.Start(site)); }
		}

		public BitmapSource Icon { get; private set; }
	}
}


================================================
File: ConfuserEx/ViewModel/UI/AppVM.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.IO;
using System.Windows;
using System.Windows.Input;
using System.Xml;
using Confuser.Core;
using Confuser.Core.Project;
using GalaSoft.MvvmLight.Command;
using Ookii.Dialogs.Wpf;

namespace ConfuserEx.ViewModel {
	public class AppVM : ViewModelBase {
		readonly IList<TabViewModel> tabs = new ObservableCollection<TabViewModel>();
		string fileName;
		bool navDisabled;
		bool firstSaved;

		ProjectVM proj;

		public bool NavigationDisabled {
			get { return navDisabled; }
			set { SetProperty(ref navDisabled, value, "NavigationDisabled"); }
		}

		public ProjectVM Project {
			get { return proj; }
			set {
				if (proj != null)
					proj.PropertyChanged -= OnProjectPropertyChanged;

				SetProperty(ref proj, value, "Project");

				if (proj != null)
					proj.PropertyChanged += OnProjectPropertyChanged;
			}
		}

		public string FileName {
			get { return fileName; }
			set {
				SetProperty(ref fileName, value, "Project");
				OnPropertyChanged("Title");
			}
		}

		public string Title {
			get {
				return string.Format("{0}{1} - {2}",
				                     Path.GetFileName(fileName),
				                     (proj.IsModified ? "*" : ""),
				                     ConfuserEngine.Version);
			}
		}

		public IList<TabViewModel> Tabs {
			get { return tabs; }
		}

		public ICommand NewProject {
			get { return new RelayCommand(NewProj, () => !NavigationDisabled); }
		}

		public ICommand OpenProject {
			get { return new RelayCommand(OpenProj, () => !NavigationDisabled); }
		}

		public ICommand SaveProject {
			get { return new RelayCommand(() => SaveProj(), () => !NavigationDisabled); }
		}

		public ICommand Decode {
			get { return new RelayCommand(() => new StackTraceDecoder { Owner = Application.Current.MainWindow }.ShowDialog(), () => !NavigationDisabled); }
		}

		public bool OnWindowClosing() {
			return PromptSave();
		}

		bool SaveProj() {
			if (!firstSaved || !File.Exists(FileName)) {
				var sfd = new VistaSaveFileDialog();
				sfd.FileName = FileName;
				sfd.Filter = "ConfuserEx Projects (*.crproj)|*.crproj|All Files (*.*)|*.*";
				sfd.DefaultExt = ".crproj";
				sfd.AddExtension = true;
				if (!(sfd.ShowDialog(Application.Current.MainWindow) ?? false) || sfd.FileName == null)
					return false;
				FileName = sfd.FileName;
			}
			ConfuserProject proj = ((IViewModel<ConfuserProject>)Project).Model;
			proj.Save().Save(FileName);
			Project.IsModified = false;
			firstSaved = true;
			return true;
		}

		bool PromptSave() {
			if (!Project.IsModified)
				return true;
			switch (MessageBox.Show("The current project has unsaved changes. Do you want to save them?", "ConfuserEx", MessageBoxButton.YesNoCancel, MessageBoxImage.Question)) {
				case MessageBoxResult.Yes:
					return SaveProj();
				case MessageBoxResult.No:
					return true;
				case MessageBoxResult.Cancel:
					return false;
			}
			return false;
		}

		void NewProj() {
			if (!PromptSave())
				return;

			Project = new ProjectVM(new ConfuserProject(), null);
			FileName = "Unnamed.crproj";
		}

		void OpenProj() {
			if (!PromptSave())
				return;

			var ofd = new VistaOpenFileDialog();
			ofd.Filter = "ConfuserEx Projects (*.crproj)|*.crproj|All Files (*.*)|*.*";
			if ((ofd.ShowDialog(Application.Current.MainWindow) ?? false) && ofd.FileName != null) {
				string fileName = ofd.FileName;
				try {
					var xmlDoc = new XmlDocument();
					xmlDoc.Load(fileName);
					var proj = new ConfuserProject();
					proj.Load(xmlDoc);
					Project = new ProjectVM(proj, fileName);
					FileName = fileName;
				}
				catch {
					MessageBox.Show("Invalid project!", "ConfuserEx", MessageBoxButton.OK, MessageBoxImage.Error);
				}
			}
		}

		void OnProjectPropertyChanged(object sender, PropertyChangedEventArgs e) {
			if (e.PropertyName == "IsModified")
				OnPropertyChanged("Title");
		}

		protected override void OnPropertyChanged(string property) {
			base.OnPropertyChanged(property);
			if (property == "Project")
				LoadPlugins();
		}

		void LoadPlugins() {
			foreach (var plugin in Project.Plugins) {
				try {
					ComponentDiscovery.LoadComponents(Project.Protections, Project.Packers, plugin.Item);
				}
				catch {
					MessageBox.Show("Failed to load plugin '" + plugin + "'.");
				}
			}
		}
	}
}


================================================
File: ConfuserEx/ViewModel/UI/ProjectTabVM.cs
================================================
ï»¿using System;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Windows;
using System.Windows.Input;
using Confuser.Core.Project;
using ConfuserEx.Views;
using GalaSoft.MvvmLight.Command;
using Ookii.Dialogs.Wpf;

namespace ConfuserEx.ViewModel {
	public class ProjectTabVM : TabViewModel {
		public ProjectTabVM(AppVM app)
			: base(app, "Project") { }

		public ICommand DragDrop {
			get {
				return new RelayCommand<IDataObject>(data => {
					foreach (string file in (string[])data.GetData(DataFormats.FileDrop))
						AddModule(file);
				}, data => {
					if (!data.GetDataPresent(DataFormats.FileDrop))
						return false;
					var files = (string[])data.GetData(DataFormats.FileDrop);
					bool ret = files.All(file => File.Exists(file));
					return ret;
				});
			}
		}

		public ICommand ChooseBaseDir {
			get {
				return new RelayCommand(() => {
					var fbd = new VistaFolderBrowserDialog();
					fbd.SelectedPath = App.Project.BaseDirectory;
					if (fbd.ShowDialog() ?? false) {
						App.Project.BaseDirectory = fbd.SelectedPath;
						App.Project.OutputDirectory = Path.Combine(App.Project.BaseDirectory, "Confused");
					}
				});
			}
		}

		public ICommand ChooseOutputDir {
			get {
				return new RelayCommand(() => {
					var fbd = new VistaFolderBrowserDialog();
					fbd.SelectedPath = App.Project.OutputDirectory;
					if (fbd.ShowDialog() ?? false) {
						App.Project.OutputDirectory = fbd.SelectedPath;
					}
				});
			}
		}

		public ICommand Add {
			get {
				return new RelayCommand(() => {
					var ofd = new VistaOpenFileDialog();
					ofd.Filter = ".NET assemblies (*.exe, *.dll)|*.exe;*.dll|All Files (*.*)|*.*";
					ofd.Multiselect = true;
					if (ofd.ShowDialog() ?? false) {
						foreach (var file in ofd.FileNames)
							AddModule(file);
					}
				});
			}
		}

		public ICommand Remove {
			get {
				return new RelayCommand(() => {
					Debug.Assert(App.Project.Modules.Any(m => m.IsSelected));
					string msg = "Are you sure to remove selected modules?\r\nAll settings specific to it would be lost!";
					if (MessageBox.Show(msg, "ConfuserEx", MessageBoxButton.YesNo, MessageBoxImage.Question) == MessageBoxResult.Yes) {
						foreach (var item in App.Project.Modules.Where(m => m.IsSelected).ToList())
							App.Project.Modules.Remove(item);
					}
				}, () => App.Project.Modules.Any(m => m.IsSelected));
			}
		}

		public ICommand Edit {
			get {
				return new RelayCommand(() => {
					Debug.Assert(App.Project.Modules.Count(m => m.IsSelected) == 1);
					var dialog = new ProjectModuleView(App.Project.Modules.Single(m => m.IsSelected));
					dialog.Owner = Application.Current.MainWindow;
					dialog.ShowDialog();
				}, () => App.Project.Modules.Count(m => m.IsSelected) == 1);
			}
		}

		public ICommand Advanced {
			get {
				return new RelayCommand(() => {
					var dialog = new ProjectTabAdvancedView(App.Project);
					dialog.Owner = Application.Current.MainWindow;
					dialog.ShowDialog();
				});
			}
		}

		void AddModule(string file) {
			if (!File.Exists(file)) {
				MessageBox.Show(string.Format("File '{0}' does not exists!", file), "ConfuserEx", MessageBoxButton.OK, MessageBoxImage.Error);
				return;
			}
			if (string.IsNullOrEmpty(App.Project.BaseDirectory)) {
				string directory = Path.GetDirectoryName(file);
				App.Project.BaseDirectory = directory;
				App.Project.OutputDirectory = Path.Combine(directory, "Confused");
			}
			var module = new ProjectModuleVM(App.Project, new ProjectModule());
			try {
				module.Path = Confuser.Core.Utils.GetRelativePath(file, App.Project.BaseDirectory);
			}
			catch {
				module.Path = file;
			}
			App.Project.Modules.Add(module);
		}
	}
}


================================================
File: ConfuserEx/ViewModel/UI/ProtectTabVM.cs
================================================
ï»¿using System;
using System.IO;
using System.Threading;
using System.Windows;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using Confuser.Core;
using Confuser.Core.Project;
using GalaSoft.MvvmLight.Command;

namespace ConfuserEx.ViewModel {
	internal class ProtectTabVM : TabViewModel, ILogger {
		readonly Paragraph documentContent;
		CancellationTokenSource cancelSrc;
		double? progress = 0;
		bool? result;

		public ProtectTabVM(AppVM app)
			: base(app, "Protect!") {
			documentContent = new Paragraph();
			LogDocument = new FlowDocument();
			LogDocument.Blocks.Add(documentContent);
		}

		public ICommand ProtectCmd {
			get { return new RelayCommand(DoProtect, () => !App.NavigationDisabled); }
		}

		public ICommand CancelCmd {
			get { return new RelayCommand(DoCancel, () => App.NavigationDisabled); }
		}

		public double? Progress {
			get { return progress; }
			set { SetProperty(ref progress, value, "Progress"); }
		}

		public FlowDocument LogDocument { get; private set; }

		public bool? Result {
			get { return result; }
			set { SetProperty(ref result, value, "Result"); }
		}

		void DoProtect() {
			var parameters = new ConfuserParameters();
			parameters.Project = ((IViewModel<ConfuserProject>)App.Project).Model;
			if (File.Exists(App.FileName))
				Environment.CurrentDirectory = Path.GetDirectoryName(App.FileName);
			parameters.Logger = this;

			documentContent.Inlines.Clear();
			cancelSrc = new CancellationTokenSource();
			Result = null;
			Progress = null;
			begin = DateTime.Now;
			App.NavigationDisabled = true;

			ConfuserEngine.Run(parameters, cancelSrc.Token)
			              .ContinueWith(_ =>
			                            Application.Current.Dispatcher.BeginInvoke(new Action(() => {
				                            Progress = 0;
				                            App.NavigationDisabled = false;
				                            CommandManager.InvalidateRequerySuggested();
			                            })));
		}

		void DoCancel() {
			cancelSrc.Cancel();
		}

		void AppendLine(string format, Brush foreground, params object[] args) {
			Application.Current.Dispatcher.BeginInvoke(new Action(() => {
				documentContent.Inlines.Add(new Run(string.Format(format, args)) { Foreground = foreground });
				documentContent.Inlines.Add(new LineBreak());
			}));
		}

		#region Logger Impl

		DateTime begin;

		void ILogger.Debug(string msg) {
			AppendLine("[DEBUG] {0}", Brushes.Gray, msg);
		}

		void ILogger.DebugFormat(string format, params object[] args) {
			AppendLine("[DEBUG] {0}", Brushes.Gray, string.Format(format, args));
		}

		void ILogger.Info(string msg) {
			AppendLine(" [INFO] {0}", Brushes.White, msg);
		}

		void ILogger.InfoFormat(string format, params object[] args) {
			AppendLine(" [INFO] {0}", Brushes.White, string.Format(format, args));
		}

		void ILogger.Warn(string msg) {
			AppendLine(" [WARN] {0}", Brushes.Yellow, msg);
		}

		void ILogger.WarnFormat(string format, params object[] args) {
			AppendLine(" [WARN] {0}", Brushes.Yellow, string.Format(format, args));
		}

		void ILogger.WarnException(string msg, Exception ex) {
			AppendLine(" [WARN] {0}", Brushes.Yellow, msg);
			AppendLine("Exception: {0}", Brushes.Yellow, ex);
		}

		void ILogger.Error(string msg) {
			AppendLine("[ERROR] {0}", Brushes.Red, msg);
		}

		void ILogger.ErrorFormat(string format, params object[] args) {
			AppendLine("[ERROR] {0}", Brushes.Red, string.Format(format, args));
		}

		void ILogger.ErrorException(string msg, Exception ex) {
			AppendLine("[ERROR] {0}", Brushes.Red, msg);
			AppendLine("Exception: {0}", Brushes.Red, ex);
		}

		void ILogger.Progress(int progress, int overall) {
			Progress = (double)progress / overall;
		}

		void ILogger.EndProgress() {
			Progress = null;
		}

		void ILogger.Finish(bool successful) {
			DateTime now = DateTime.Now;
			string timeString = string.Format(
				"at {0}, {1}:{2:d2} elapsed.",
				now.ToShortTimeString(),
				(int)now.Subtract(begin).TotalMinutes,
				now.Subtract(begin).Seconds);
			if (successful)
				AppendLine("Finished {0}", Brushes.Lime, timeString);
			else
				AppendLine("Failed {0}", Brushes.Red, timeString);
			Result = successful;
		}

		#endregion
	}
}


================================================
File: ConfuserEx/ViewModel/UI/SettingsTabVM.cs
================================================
ï»¿using System;
using System.Collections;
using System.Diagnostics;
using System.Windows;
using System.Windows.Data;
using System.Windows.Input;
using Confuser.Core;
using Confuser.Core.Project;
using ConfuserEx.Views;
using GalaSoft.MvvmLight.Command;

namespace ConfuserEx.ViewModel {
	internal class SettingsTabVM : TabViewModel {
		bool hasPacker;
		IRuleContainer selectedList;
		int selectedRuleIndex;

		public SettingsTabVM(AppVM app)
			: base(app, "Settings") {
			app.PropertyChanged += (sender, e) => {
				if (e.PropertyName == "Project")
					InitProject();
			};
			InitProject();
		}

		public bool HasPacker {
			get { return hasPacker; }
			set { SetProperty(ref hasPacker, value, "HasPacker"); }
		}

		public IList ModulesView { get; private set; }

		public IRuleContainer SelectedList {
			get { return selectedList; }
			set {
				if (SetProperty(ref selectedList, value, "SelectedList"))
					SelectedRuleIndex = -1;
			}
		}

		public int SelectedRuleIndex {
			get { return selectedRuleIndex; }
			set { SetProperty(ref selectedRuleIndex, value, "SelectedRuleIndex"); }
		}

		public ICommand Add {
			get {
				return new RelayCommand(() => {
					Debug.Assert(SelectedList != null);

					var rule = new ProjectRuleVM(App.Project, new Rule());
					rule.Pattern = "true";
					SelectedList.Rules.Add(rule);
					SelectedRuleIndex = SelectedList.Rules.Count - 1;
				}, () => SelectedList != null);
			}
		}

		public ICommand Remove {
			get {
				return new RelayCommand(() => {
					int selIndex = SelectedRuleIndex;
					Debug.Assert(SelectedList != null);
					Debug.Assert(selIndex != -1);

					ProjectRuleVM rule = SelectedList.Rules[selIndex];
					SelectedList.Rules.RemoveAt(selIndex);
					SelectedRuleIndex = selIndex >= SelectedList.Rules.Count ? SelectedList.Rules.Count - 1 : selIndex;
				}, () => SelectedRuleIndex != -1 && SelectedList != null);
			}
		}

		public ICommand Edit {
			get {
				return new RelayCommand(() => {
					Debug.Assert(SelectedRuleIndex != -1);
					var dialog = new ProjectRuleView(App.Project, SelectedList.Rules[SelectedRuleIndex]);
					dialog.Owner = Application.Current.MainWindow;
					dialog.ShowDialog();
					dialog.Cleanup();
				}, () => SelectedRuleIndex != -1 && SelectedList != null);
			}
		}

		void InitProject() {
			ModulesView = new CompositeCollection {
				App.Project,
				new CollectionContainer { Collection = App.Project.Modules }
			};
			OnPropertyChanged("ModulesView");
			HasPacker = App.Project.Packer != null;
		}

		protected override void OnPropertyChanged(string property) {
			if (property == "HasPacker") {
				if (hasPacker && App.Project.Packer == null)
					App.Project.Packer = new ProjectSettingVM<Packer>(App.Project, new SettingItem<Packer> { Id = App.Project.Packers[0].Id });
				else if (!hasPacker)
					App.Project.Packer = null;
			}
			base.OnPropertyChanged(property);
		}
	}
}


================================================
File: ConfuserEx/ViewModel/UI/TabViewModel.cs
================================================
ï»¿using System;

namespace ConfuserEx.ViewModel {
	public abstract class TabViewModel : ViewModelBase {
		protected TabViewModel(AppVM app, string header) {
			App = app;
			Header = header;
		}

		public AppVM App { get; private set; }
		public string Header { get; private set; }
	}
}


================================================
File: ConfuserEx/Views/AboutTabView.xaml
================================================
ï»¿<ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
                    xmlns:local="clr-namespace:ConfuserEx"
                    xmlns:vm="clr-namespace:ConfuserEx.ViewModel"
                    xmlns:core="clr-namespace:Confuser.Core;assembly=Confuser.Core">
    <DataTemplate DataType="{x:Type vm:AboutTabVM}">
        <Grid Background="Transparent" Margin="10" x:Name="Root">
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="400px" />
                <ColumnDefinition Width="*" />
            </Grid.ColumnDefinitions>
            <Grid.RowDefinitions>
                <RowDefinition Height="70px" />
                <RowDefinition Height="*" />
                <RowDefinition Height="100px" />
            </Grid.RowDefinitions>

            <Grid Grid.Row="0" Grid.Column="0" HorizontalAlignment="Center">
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="70px" />
                    <ColumnDefinition Width="*" />
                </Grid.ColumnDefinitions>
                <Grid.RowDefinitions>
                    <RowDefinition Height="*" />
                    <RowDefinition Height="*" />
                </Grid.RowDefinitions>
                <Image Grid.Row="0" Grid.Column="0" Grid.RowSpan="2" Source="{Binding Icon}" Width="64" Height="64" />
                <Label Grid.Row="0" Grid.Column="1" FontSize="20" Content="ConfuserEx" Foreground="#ffffff" />
                <TextBox Grid.Row="1" Grid.Column="1" FontSize="14" Text="{x:Static core:ConfuserEngine.Version}"
                         Foreground="#a0a0a0" BorderThickness="0" VerticalAlignment="Center" Background="Transparent"
                         IsReadOnly="True" IsReadOnlyCaretVisible="True" local:Skin.FocusOverlay="False" />
            </Grid>

            <DockPanel Grid.Row="1" Grid.Column="0" Margin="10" LastChildFill="True"
                       VerticalAlignment="Stretch" HorizontalAlignment="Stretch">

                <Separator DockPanel.Dock="Top" />
                <Separator DockPanel.Dock="Bottom" />

                <StackPanel TextBlock.FontSize="13" VerticalAlignment="Center" HorizontalAlignment="Stretch">
                    <Label FontWeight="Bold">ConfuserEx, a .NET protector</Label>
                    <Label>Developed by Ki, open sourced under MIT license.</Label>
                    <Label>
                        <TextBlock>
                            <Hyperlink NavigateUri="http://yck1509.github.io/ConfuserEx/"
                                       Command="{Binding LaunchBrowser}"
                                       CommandParameter="http://yck1509.github.io/ConfuserEx/">
                                Visit the project page for details.
                            </Hyperlink>
                        </TextBlock>
                    </Label>
                    <Label Height="20px" />

                    <Label>If you like it or find it useful,</Label>
                    <Label>
                        <TextBlock>
                            <Hyperlink NavigateUri="http://yck1509.github.io/ConfuserEx/#donation"
                                       Command="{Binding LaunchBrowser}"
                                       CommandParameter="http://yck1509.github.io/ConfuserEx/#donation">
                                feel free to support the project by making a donation!
                            </Hyperlink>
                        </TextBlock>
                    </Label>
                </StackPanel>
            </DockPanel>

            <Button Grid.Row="2" Grid.Column="0" Command="{Binding LaunchBrowser}"
                    CommandParameter="http://board.b-at-s.info/" Focusable="False" Cursor="Hand">
                <Button.Template>
                    <ControlTemplate TargetType="{x:Type Button}">
                        <ContentPresenter />
                    </ControlTemplate>
                </Button.Template>
                <Image Source="{DynamicResource TeamLogo}" Width="400" Height="100" />
            </Button>

            <StackPanel Grid.Column="1" Grid.RowSpan="3" TextBlock.FontSize="13" Margin="10"
                        VerticalAlignment="Stretch" HorizontalAlignment="Center">
                <Label HorizontalContentAlignment="Center">Special Thanks to:</Label>
                <Label HorizontalContentAlignment="Center">0xd4d</Label>
                <Label HorizontalContentAlignment="Center">CodeCracker</Label>
                <Label HorizontalContentAlignment="Center">JeRRy</Label>
                <Label HorizontalContentAlignment="Center">kao</Label>
                <Label HorizontalContentAlignment="Center">Kurapica</Label>
                <Label HorizontalContentAlignment="Center">UbbeLoL</Label>
                <Label HorizontalContentAlignment="Center">whoknows</Label>
                <Label HorizontalContentAlignment="Center">Members of Black Storm Forum</Label>
                <Label HorizontalContentAlignment="Center">and You!</Label>
            </StackPanel>
        </Grid>
    </DataTemplate>
</ResourceDictionary>


================================================
File: ConfuserEx/Views/ProjectModuleView.xaml
================================================
ï»¿<Window x:Class="ConfuserEx.Views.ProjectModuleView"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:local="clr-namespace:ConfuserEx"
        Title="{Binding Path, StringFormat=Edit module \'{0}\'...}" Style="{StaticResource DarkWindow}"
        SizeToContent="WidthAndHeight" ShowInTaskbar="False" ResizeMode="NoResize">
    <Grid Margin="5">
        <Grid.RowDefinitions>
            <RowDefinition Height="36px" />
            <RowDefinition Height="36px" />
            <RowDefinition Height="36px" />
            <RowDefinition Height="36px" />
        </Grid.RowDefinitions>
        <Grid.ColumnDefinitions>
            <ColumnDefinition Width="150px" />
            <ColumnDefinition Width="250px" />
            <ColumnDefinition Width="35px" />
        </Grid.ColumnDefinitions>

        <Label Content="Assembly Path : " Grid.Row="0" Grid.Column="0" HorizontalContentAlignment="Right"
               VerticalContentAlignment="Center" />
        <TextBox Grid.Row="0" Grid.Column="1" Grid.ColumnSpan="2" Margin="5" VerticalContentAlignment="Center"
                 Text="{Binding Path, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"
                 local:FileDragDrop.Command="{x:Static local:FileDragDrop.FileCmd}" />

        <Label Content="SN Key Path : " Grid.Row="1" Grid.Column="0" HorizontalContentAlignment="Right"
               VerticalContentAlignment="Center" />
        <TextBox x:Name="PathBox" Grid.Row="1" Grid.Column="1" Margin="5" VerticalContentAlignment="Center"
                 TextChanged="PathBox_TextChanged"
                 Text="{Binding SNKeyPath, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"
                 local:FileDragDrop.Command="{x:Static local:FileDragDrop.FileCmd}" />
        <Button Grid.Row="1" Grid.Column="2" Margin="5" VerticalAlignment="Center" Height="26" Click="ChooseSNKey">
            <TextBlock FontSize="14px" FontFamily="{DynamicResource FontAwesome}" Text="&#xf141;" Height="10px"
                       TextOptions.TextRenderingMode="GrayScale" />
        </Button>

        <Label Content="SN Key Password : " Grid.Row="2" Grid.Column="0" HorizontalContentAlignment="Right"
               VerticalContentAlignment="Center" />
        <TextBox x:Name="PwdBox" Grid.Row="2" Grid.Column="1" Margin="5" Grid.ColumnSpan="2"
                 VerticalContentAlignment="Center"
                 Text="{Binding SNKeyPassword, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}" />

        <Button Grid.Row="3" Grid.ColumnSpan="3" HorizontalAlignment="Right" Content="Done"
                Width="70" Margin="5" Click="Done" />
    </Grid>
</Window>


================================================
File: ConfuserEx/Views/ProjectModuleView.xaml.cs
================================================
ï»¿using System;
using System.Windows;
using System.Windows.Controls;
using ConfuserEx.ViewModel;
using Ookii.Dialogs.Wpf;

namespace ConfuserEx.Views {
	public partial class ProjectModuleView : Window {
		readonly ProjectModuleVM module;

		public ProjectModuleView(ProjectModuleVM module) {
			InitializeComponent();
			this.module = module;
			DataContext = module;
			PwdBox.IsEnabled = !string.IsNullOrEmpty(PathBox.Text);
		}

		void Done(object sender, RoutedEventArgs e) {
			DialogResult = true;
		}

		void PathBox_TextChanged(object sender, TextChangedEventArgs e) {
			PwdBox.IsEnabled = !string.IsNullOrEmpty(PathBox.Text);
		}

		void ChooseSNKey(object sender, RoutedEventArgs e) {
			var ofd = new VistaOpenFileDialog();
			ofd.Filter = "Supported Key Files (*.snk, *.pfx)|*.snk;*.pfx|All Files (*.*)|*.*";
			if (ofd.ShowDialog() ?? false) {
				module.SNKeyPath = ofd.FileName;
			}
		}
	}
}


================================================
File: ConfuserEx/Views/ProjectRuleView.xaml
================================================
ï»¿<Window x:Class="ConfuserEx.Views.ProjectRuleView"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:local="clr-namespace:ConfuserEx"
        xmlns:core="clr-namespace:Confuser.Core;assembly=Confuser.Core"
        xmlns:proj="clr-namespace:Confuser.Core.Project;assembly=Confuser.Core"
        Title="Edit rule..." Height="600" Width="400" x:Name="View"
        Style="{StaticResource DarkWindow}" ShowInTaskbar="False" ResizeMode="NoResize">
    <Grid Margin="5">
        <Grid.Resources>
            <local:ComponentConverter x:Key="ProtConverter"
                                      xmlns:PresentationOptions="http://schemas.microsoft.com/winfx/2006/xaml/presentation/options"
                                      PresentationOptions:Freeze="True"
                                      Components="{Binding Project.Protections}" />
        </Grid.Resources>
        <Grid.ColumnDefinitions>
            <ColumnDefinition Width="*" />
            <ColumnDefinition Width="36px" />
        </Grid.ColumnDefinitions>
        <Grid.RowDefinitions>
            <RowDefinition Height="25px" />
            <RowDefinition Height="36px" />
            <RowDefinition Height="36px" />
            <RowDefinition Height="25px" />
            <RowDefinition Height="*" />
            <RowDefinition Height="40px" />
        </Grid.RowDefinitions>

        <Label Grid.Row="0" Grid.ColumnSpan="2" Content="Pattern:" VerticalAlignment="Center"
               HorizontalAlignment="Left" />

        <TextBox x:Name="pattern" Grid.Row="1" Grid.ColumnSpan="2"
                 Text="{Binding Pattern, UpdateSourceTrigger=PropertyChanged}" FontFamily="Consolas" Margin="5"
                 VerticalContentAlignment="Center" />
        <Image x:Name="errorImg" Grid.Row="1" Grid.ColumnSpan="2" Source="{StaticResource Error}"
               Width="16px" Height="16px" ToolTip="{Binding ExpressionError}" Margin="0,0,10,0"
               Visibility="Hidden" HorizontalAlignment="Right" />

        <DockPanel Grid.Row="2" Grid.ColumnSpan="2" LastChildFill="False">
            <Label DockPanel.Dock="Left" Content="Preset : " VerticalAlignment="Center" />
            <ComboBox DockPanel.Dock="Left" SelectedItem="{Binding Preset, UpdateSourceTrigger=PropertyChanged}"
                      Margin="5" Width="100" VerticalAlignment="Center"
                      ItemsSource="{local:EnumValues {x:Type core:ProtectionPreset}}" />
            <CheckBox DockPanel.Dock="Right" Content="Inherit protections"
                      IsChecked="{Binding Inherit}" Margin="5" VerticalAlignment="Center" />
        </DockPanel>

        <Label Grid.Row="3" Content="Protections:" VerticalAlignment="Center"
               HorizontalAlignment="Left" />

        <ListBox x:Name="prots" Grid.Row="4" Margin="5"
                 ItemsSource="{Binding Protections}" Grid.IsSharedSizeScope="True">
            <ListBox.ItemTemplate>
                <DataTemplate>
                    <Grid>
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition SharedSizeGroup="Action" />
                            <ColumnDefinition Width="10px" />
                            <ColumnDefinition SharedSizeGroup="Protection" />
                        </Grid.ColumnDefinitions>
                        <ComboBox Grid.Column="0" Width="80" SelectedItem="{Binding Action}" IsEnabled="True"
                                  ItemsSource="{local:EnumValues {x:Type proj:SettingItemAction}}" />
                        <local:CompComboBox Grid.Column="2" Width="150"
                                            Components="{Binding Project.Protections, ElementName=View}"
                                            SelectedComponent="{Binding Id, Converter={StaticResource ProtConverter}, Mode=TwoWay}" />
                    </Grid>
                </DataTemplate>
            </ListBox.ItemTemplate>
        </ListBox>

        <DockPanel Grid.Row="4" Grid.Column="1" LastChildFill="False">
            <Button Height="26" Margin="5" DockPanel.Dock="Top" x:Name="AddBtn">
                <TextBlock FontSize="14px" FontFamily="{DynamicResource FontAwesome}" Text="&#xf067;" Height="12px"
                           TextOptions.TextRenderingMode="GrayScale" />
            </Button>
            <Button Height="26" Margin="5" DockPanel.Dock="Top" x:Name="RemoveBtn">
                <TextBlock FontSize="14px" FontFamily="{DynamicResource FontAwesome}" Text="&#xf068;" Height="12px"
                           TextOptions.TextRenderingMode="GrayScale" />
            </Button>
        </DockPanel>

        <Button Grid.Row="5" Grid.ColumnSpan="2" HorizontalAlignment="Right"
                Margin="5" Width="70" Content="Done" Click="Done" />
    </Grid>
</Window>


================================================
File: ConfuserEx/Views/ProjectRuleView.xaml.cs
================================================
ï»¿using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Windows;
using System.Windows.Media;
using Confuser.Core;
using Confuser.Core.Project;
using ConfuserEx.ViewModel;
using GalaSoft.MvvmLight.Command;

namespace ConfuserEx.Views {
	public partial class ProjectRuleView : Window {
		readonly ProjectVM proj;
		readonly ProjectRuleVM rule;

		public ProjectRuleView(ProjectVM proj, ProjectRuleVM rule) {
			InitializeComponent();
			this.rule = rule;
			this.proj = proj;
			DataContext = rule;

			rule.PropertyChanged += OnPropertyChanged;
			CheckValidity();
		}

		public ProjectVM Project {
			get { return proj; }
		}

		public override void OnApplyTemplate() {
			base.OnApplyTemplate();

			AddBtn.Command = new RelayCommand(() => {
				var prot = new ProjectSettingVM<Protection>(proj, new SettingItem<Protection>());
				prot.Id = proj.Protections[0].Id;
				rule.Protections.Add(prot);
			});
			RemoveBtn.Command = new RelayCommand(() => {
				int selIndex = prots.SelectedIndex;
				Debug.Assert(selIndex != -1);

				rule.Protections.RemoveAt(prots.SelectedIndex);
				prots.SelectedIndex = selIndex >= rule.Protections.Count ? rule.Protections.Count - 1 : selIndex;
			}, () => prots.SelectedIndex != -1);
		}

		public void Cleanup() {
			rule.PropertyChanged -= OnPropertyChanged;
		}

		void OnPropertyChanged(object sender, PropertyChangedEventArgs e) {
			if (e.PropertyName == "Expression")
				CheckValidity();
		}

		void CheckValidity() {
			if (rule.Expression == null) {
				pattern.BorderBrush = Brushes.Red;
				errorImg.Visibility = Visibility.Visible;
			}
			else {
				pattern.ClearValue(BorderBrushProperty);
				errorImg.Visibility = Visibility.Hidden;
			}
		}

		void Done(object sender, RoutedEventArgs e) {
			DialogResult = true;
		}
	}
}


================================================
File: ConfuserEx/Views/ProjectTabAdvancedView.xaml
================================================
ï»¿<Window x:Class="ConfuserEx.Views.ProjectTabAdvancedView"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:local="clr-namespace:ConfuserEx"
        Title="Advanced Settings..." Height="400" Width="600"
        Style="{StaticResource DarkWindow}" ShowInTaskbar="False" ResizeMode="NoResize">
    <Grid Margin="5">
        <Grid.ColumnDefinitions>
            <ColumnDefinition Width="*" />
            <ColumnDefinition Width="36px" />
            <ColumnDefinition Width="*" />
            <ColumnDefinition Width="36px" />
        </Grid.ColumnDefinitions>
        <Grid.RowDefinitions>
            <RowDefinition Height="36px" />
            <RowDefinition Height="*" />
        </Grid.RowDefinitions>

        <Label Grid.Row="0" Grid.Column="0" Content="Probe Paths :" Margin="5" VerticalAlignment="Center" />
        <ListBox Grid.Row="1" Grid.Column="0" Margin="5" x:Name="ProbePaths" ItemsSource="{Binding ProbePaths}"
                 local:FileDragDrop.Command="{x:Static local:FileDragDrop.DirectoryCmd}"
                 ScrollViewer.CanContentScroll="False" />
        <StackPanel Grid.Row="1" Grid.Column="1">
            <Button Height="26" Margin="5" DockPanel.Dock="Top" x:Name="AddProbe">
                <TextBlock FontSize="14px" FontFamily="{DynamicResource FontAwesome}" Text="&#xf067;" Height="12px"
                           TextOptions.TextRenderingMode="GrayScale" />
            </Button>
            <Button Height="26" Margin="5" DockPanel.Dock="Top" x:Name="RemoveProbe">
                <TextBlock FontSize="14px" FontFamily="{DynamicResource FontAwesome}" Text="&#xf068;" Height="12px"
                           TextOptions.TextRenderingMode="GrayScale" />
            </Button>
        </StackPanel>

        <Label Grid.Row="0" Grid.Column="2" Content="Plugins :" Margin="5" VerticalAlignment="Center" />
        <ListBox Grid.Row="1" Grid.Column="2" Margin="5" x:Name="PluginPaths" ItemsSource="{Binding Plugins}"
                 local:FileDragDrop.Command="{x:Static local:FileDragDrop.FileCmd}"
                 ScrollViewer.CanContentScroll="False" />
        <StackPanel Grid.Row="1" Grid.Column="3">
            <Button Height="26" Margin="5" DockPanel.Dock="Top" x:Name="AddPlugin">
                <TextBlock FontSize="14px" FontFamily="{DynamicResource FontAwesome}" Text="&#xf067;" Height="12px"
                           TextOptions.TextRenderingMode="GrayScale" />
            </Button>
            <Button Height="26" Margin="5" DockPanel.Dock="Top" x:Name="RemovePlugin">
                <TextBlock FontSize="14px" FontFamily="{DynamicResource FontAwesome}" Text="&#xf068;" Height="12px"
                           TextOptions.TextRenderingMode="GrayScale" />
            </Button>
        </StackPanel>
    </Grid>
</Window>


================================================
File: ConfuserEx/Views/ProjectTabAdvancedView.xaml.cs
================================================
ï»¿using System;
using System.Diagnostics;
using System.Windows;
using ConfuserEx.ViewModel;
using GalaSoft.MvvmLight.Command;
using Ookii.Dialogs.Wpf;

namespace ConfuserEx.Views {
	public partial class ProjectTabAdvancedView : Window {
		readonly ProjectVM project;

		public ProjectTabAdvancedView(ProjectVM project) {
			InitializeComponent();
			this.project = project;
			DataContext = project;
		}

		public override void OnApplyTemplate() {
			base.OnApplyTemplate();

			AddPlugin.Command = new RelayCommand(() => {
				var ofd = new VistaOpenFileDialog();
				ofd.Filter = ".NET assemblies (*.exe, *.dll)|*.exe;*.dll|All Files (*.*)|*.*";
				ofd.Multiselect = true;
				if (ofd.ShowDialog() ?? false) {
					foreach (string plugin in ofd.FileNames) {
						try {
							ComponentDiscovery.LoadComponents(project.Protections, project.Packers, plugin);
							project.Plugins.Add(new StringItem(plugin));
						}
						catch {
							MessageBox.Show("Failed to load plugin '" + plugin + "'.");
						}
					}
				}
			});

			RemovePlugin.Command = new RelayCommand(() => {
				int selIndex = PluginPaths.SelectedIndex;
				Debug.Assert(selIndex != -1);

				string plugin = project.Plugins[selIndex].Item;
				ComponentDiscovery.RemoveComponents(project.Protections, project.Packers, plugin);
				project.Plugins.RemoveAt(selIndex);

				PluginPaths.SelectedIndex = selIndex >= project.Plugins.Count ? project.Plugins.Count - 1 : selIndex;
			}, () => PluginPaths.SelectedIndex != -1);


			AddProbe.Command = new RelayCommand(() => {
				var fbd = new VistaFolderBrowserDialog();
				if (fbd.ShowDialog() ?? false)
					project.ProbePaths.Add(new StringItem(fbd.SelectedPath));
			});

			RemoveProbe.Command = new RelayCommand(() => {
				int selIndex = ProbePaths.SelectedIndex;
				Debug.Assert(selIndex != -1);
				project.ProbePaths.RemoveAt(selIndex);
				ProbePaths.SelectedIndex = selIndex >= project.ProbePaths.Count ? project.ProbePaths.Count - 1 : selIndex;
			}, () => ProbePaths.SelectedIndex != -1);
		}
	}
}


================================================
File: ConfuserEx/Views/ProjectTabView.xaml
================================================
ï»¿<ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
                    xmlns:local="clr-namespace:ConfuserEx"
                    xmlns:vm="clr-namespace:ConfuserEx.ViewModel">
    <DataTemplate DataType="{x:Type vm:ProjectTabVM}">
        <Grid Background="Transparent">
            <Grid.RowDefinitions>
                <RowDefinition Height="36px" />
                <RowDefinition Height="36px" />
                <RowDefinition Height="36px" />
                <RowDefinition Height="*" />
            </Grid.RowDefinitions>
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="150px" />
                <ColumnDefinition Width="*" />
                <ColumnDefinition Width="36px" />
            </Grid.ColumnDefinitions>
            <Label Content="Base Directory : " Grid.Row="0" Grid.Column="0" HorizontalContentAlignment="Right"
                   VerticalContentAlignment="Center" />
            <TextBox Grid.Row="0" Grid.Column="1" Margin="5" VerticalContentAlignment="Center"
                     Text="{Binding App.Project.BaseDirectory, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"
                     local:FileDragDrop.Command="{x:Static local:FileDragDrop.DirectoryCmd}" />
            <Button Grid.Row="0" Grid.Column="2" Margin="5" VerticalAlignment="Center" Height="26"
                    Command="{Binding ChooseBaseDir}">
                <TextBlock FontSize="14px" FontFamily="{DynamicResource FontAwesome}" Text="&#xf141;" Height="10px"
                           TextOptions.TextRenderingMode="GrayScale" />
            </Button>

            <Label Content="Output Directory : " Grid.Row="1" Grid.Column="0" HorizontalContentAlignment="Right"
                   VerticalContentAlignment="Center" />
            <TextBox Grid.Row="1" Grid.Column="1" Margin="5" VerticalContentAlignment="Center"
                     Text="{Binding App.Project.OutputDirectory, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"
                     local:FileDragDrop.Command="{x:Static local:FileDragDrop.DirectoryCmd}" />
            <Button Grid.Row="1" Grid.Column="2" Margin="5" VerticalAlignment="Center" Height="26"
                    Command="{Binding ChooseOutputDir}">
                <TextBlock FontSize="14px" FontFamily="{DynamicResource FontAwesome}" Text="&#xf141;" Height="10px"
                           TextOptions.TextRenderingMode="GrayScale" />
            </Button>

            <Grid Grid.Row="2" Grid.ColumnSpan="3">
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="150px" />
                    <ColumnDefinition Width="*" />
                    <ColumnDefinition Width="Auto" />
                </Grid.ColumnDefinitions>
                <Label Content="Seed : " Grid.Column="0" HorizontalContentAlignment="Right"
                       VerticalContentAlignment="Center" />
                <TextBox Grid.Column="1" Margin="5" VerticalContentAlignment="Center"
                         Text="{Binding App.Project.Seed, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"
                         local:Skin.EmptyPrompt="Leave blank for random seed" />
                <CheckBox Grid.Column="2" Content="Generate Debug Symbols" VerticalAlignment="Center" Margin="5"
                          IsChecked="{Binding App.Project.Debug, Mode=TwoWay}" />
            </Grid>

            <ListBox Grid.Row="3" Grid.ColumnSpan="2" Margin="5" local:Skin.EmptyPrompt="Drag input modules here"
                     ItemsSource="{Binding App.Project.Modules}" HorizontalContentAlignment="Stretch"
                     SelectionMode="Extended" ScrollViewer.HorizontalScrollBarVisibility="Disabled"
                     Grid.IsSharedSizeScope="True" local:FileDragDrop.Command="{Binding DragDrop}"
                     ScrollViewer.CanContentScroll="False">
                <ListBox.ItemTemplate>
                    <DataTemplate DataType="{x:Type vm:ProjectModuleVM}">
                        <Grid>
                            <Grid.ColumnDefinitions>
                                <ColumnDefinition Width="Auto" />
                                <ColumnDefinition Width="*" />
                            </Grid.ColumnDefinitions>
                            <TextBlock Grid.Column="0" Text="{Binding AssemblyName}"
                                       TextAlignment="Left" Margin="0,0,5,0" TextTrimming="CharacterEllipsis" />
                            <TextBlock Grid.Column="1" Text="{Binding Path}"
                                       TextAlignment="Right" Margin="5,0,0,0" TextTrimming="CharacterEllipsis" />
                        </Grid>
                    </DataTemplate>
                </ListBox.ItemTemplate>
                <ListBox.ItemContainerStyle>
                    <Style TargetType="{x:Type ListBoxItem}" BasedOn="{StaticResource {x:Type ListBoxItem}}">
                        <Setter Property="IsSelected" Value="{Binding IsSelected}" />
                    </Style>
                </ListBox.ItemContainerStyle>
            </ListBox>
            <DockPanel Grid.Row="3" Grid.Column="2" LastChildFill="False">
                <Button Height="26" Margin="5" DockPanel.Dock="Top" Command="{Binding Add}">
                    <TextBlock FontSize="14px" FontFamily="{DynamicResource FontAwesome}" Text="&#xf067;" Height="12px"
                               TextOptions.TextRenderingMode="GrayScale" />
                </Button>
                <Button Height="26" Margin="5" DockPanel.Dock="Top" Command="{Binding Remove}">
                    <TextBlock FontSize="14px" FontFamily="{DynamicResource FontAwesome}" Text="&#xf068;" Height="12px"
                               TextOptions.TextRenderingMode="GrayScale" />
                </Button>
                <Button Height="26" Margin="5" DockPanel.Dock="Top" Command="{Binding Edit}">
                    <TextBlock FontSize="14px" FontFamily="{DynamicResource FontAwesome}" Text="&#xf044;" Height="12px"
                               TextOptions.TextRenderingMode="GrayScale" />
                </Button>
                <Button Height="26" Margin="5" DockPanel.Dock="Bottom" Command="{Binding Advanced}">
                    <TextBlock FontSize="14px" FontFamily="{DynamicResource FontAwesome}" Text="&#xf013;" Height="12px"
                               TextOptions.TextRenderingMode="GrayScale" />
                </Button>
            </DockPanel>
        </Grid>
    </DataTemplate>
</ResourceDictionary>


================================================
File: ConfuserEx/Views/ProtectTabView.xaml
================================================
ï»¿<ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
                    xmlns:local="clr-namespace:ConfuserEx"
                    xmlns:vm="clr-namespace:ConfuserEx.ViewModel">
    <DataTemplate DataType="{x:Type vm:ProtectTabVM}">
        <Grid Background="Transparent">
            <Grid.RowDefinitions>
                <RowDefinition Height="40px" />
                <RowDefinition Height="*" />
            </Grid.RowDefinitions>
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="*" />
                <ColumnDefinition Width="100px" />
                <ColumnDefinition Width="100px" />
            </Grid.ColumnDefinitions>

            <ProgressBar x:Name="progress" Grid.Row="0" Grid.Column="0" Margin="5"
                         Value="{Binding Progress}" Minimum="0" Maximum="1" />
            <Button Grid.Row="0" Grid.Column="1" Margin="5" Content="Protect!" Command="{Binding ProtectCmd}" />
            <Button Grid.Row="0" Grid.Column="2" Margin="5" Content="Cancel" Command="{Binding CancelCmd}" />
            <RichTextBox x:Name="log" Grid.Row="1" Grid.ColumnSpan="3" Margin="5" FontFamily="Consolas"
                         IsReadOnly="True" IsReadOnlyCaretVisible="True" local:Skin.RTBDocument="{Binding LogDocument}"
                         VerticalScrollBarVisibility="Visible" />
        </Grid>
        <DataTemplate.Triggers>
            <DataTrigger Binding="{Binding Progress}" Value="{x:Null}">
                <Setter TargetName="progress" Property="IsIndeterminate" Value="True" />
            </DataTrigger>
            <DataTrigger Binding="{Binding Result}" Value="True">
                <Setter TargetName="log" Property="BorderBrush" Value="#40ff40" />
            </DataTrigger>
            <DataTrigger Binding="{Binding Result}" Value="False">
                <Setter TargetName="log" Property="BorderBrush" Value="#ff4040" />
            </DataTrigger>
        </DataTemplate.Triggers>
    </DataTemplate>
</ResourceDictionary>


================================================
File: ConfuserEx/Views/SettingsTabView.xaml
================================================
ï»¿<ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
                    xmlns:local="clr-namespace:ConfuserEx"
                    xmlns:vm="clr-namespace:ConfuserEx.ViewModel">
    <DataTemplate DataType="{x:Type vm:SettingsTabVM}">
        <Grid Background="Transparent">
            <Grid.Resources>
                <local:ComponentConverter x:Key="PackerConverter" x:Shared="False"
                                          Components="{Binding App.Project.Packers}" />
            </Grid.Resources>

            <Grid.RowDefinitions>
                <RowDefinition Height="40px" />
                <RowDefinition Height="40px" />
                <RowDefinition Height="*" />
            </Grid.RowDefinitions>
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="200px" />
                <ColumnDefinition Width="*" />
                <ColumnDefinition Width="36px" />
            </Grid.ColumnDefinitions>

            <StackPanel Grid.Row="0" Grid.ColumnSpan="3" Orientation="Horizontal" Margin="5">
                <CheckBox Content="Packer : " VerticalAlignment="Center" HorizontalAlignment="Right"
                          Margin="5,0,0,0" IsChecked="{Binding HasPacker}" />
                <local:CompComboBox Width="300" Components="{Binding App.Project.Packers}" Margin="5,0,0,0"
                                    IsEnabled="{Binding HasPacker}" HorizontalAlignment="Left"
                                    VerticalAlignment="Center"
                                    SelectedComponent="{Binding App.Project.Packer.Id, Converter={StaticResource PackerConverter}, Mode=TwoWay}" />
            </StackPanel>

            <Label Grid.Row="1" Grid.Column="0" Content="Modules : " VerticalAlignment="Bottom"
                   HorizontalAlignment="Left" Margin="5,0,0,0" />
            <Label Grid.Row="1" Grid.Column="1" Content="Rules : " VerticalAlignment="Bottom"
                   HorizontalAlignment="Left" Margin="5,0,0,0" />

            <ListBox Grid.Row="2" Grid.Column="0" Margin="5" ItemsSource="{Binding ModulesView}"
                     SelectedItem="{Binding SelectedList, Mode=OneWayToSource}">
                <ListBox.ItemTemplate>
                    <DataTemplate>
                        <TextBlock>
                            <TextBlock.Text>
                                <PriorityBinding>
                                    <Binding Path="SimpleName" />
                                    <Binding Source="&lt;Global settings&gt;" />
                                </PriorityBinding>
                            </TextBlock.Text>
                        </TextBlock>
                    </DataTemplate>
                </ListBox.ItemTemplate>
            </ListBox>
            <ListBox Grid.Row="2" Grid.Column="1" Margin="5" FontFamily="Consolas"
                     ItemsSource="{Binding SelectedList.Rules}"
                     SelectedIndex="{Binding SelectedRuleIndex, Mode=TwoWay}">
                <ListBox.ItemTemplate>
                    <DataTemplate>
                        <TextBlock x:Name="txt" Text="{Binding Pattern}" />
                        <DataTemplate.Triggers>
                            <DataTrigger Binding="{Binding Expression}" Value="{x:Null}">
                                <Setter TargetName="txt" Property="Foreground" Value="Red" />
                            </DataTrigger>
                        </DataTemplate.Triggers>
                    </DataTemplate>
                </ListBox.ItemTemplate>
            </ListBox>

            <DockPanel Grid.Row="2" Grid.Column="2" LastChildFill="False">
                <Button Height="26" Margin="5" DockPanel.Dock="Top" Command="{Binding Add}">
                    <TextBlock FontSize="14px" FontFamily="{DynamicResource FontAwesome}" Text="&#xf067;" Height="12px"
                               TextOptions.TextRenderingMode="GrayScale" />
                </Button>
                <Button Height="26" Margin="5" DockPanel.Dock="Top" Command="{Binding Remove}">
                    <TextBlock FontSize="14px" FontFamily="{DynamicResource FontAwesome}" Text="&#xf068;" Height="12px"
                               TextOptions.TextRenderingMode="GrayScale" />
                </Button>
                <Button Height="26" Margin="5" DockPanel.Dock="Top" Command="{Binding Edit}">
                    <TextBlock FontSize="14px" FontFamily="{DynamicResource FontAwesome}" Text="&#xf044;" Height="12px"
                               TextOptions.TextRenderingMode="GrayScale" />
                </Button>
            </DockPanel>
        </Grid>
    </DataTemplate>
</ResourceDictionary>


================================================
File: additional/Icon.pdn
================================================
[Non-text file]


================================================
File: additional/Icon16.pdn
================================================
[Non-text file]


================================================
File: additional/Icon256.pdn
================================================
[Non-text file]


================================================
File: additional/Icon32.pdn
================================================
[Non-text file]


================================================
File: additional/Icon48.pdn
================================================
[Non-text file]


================================================
File: additional/Icon64.pdn
================================================
[Non-text file]


================================================
File: additional/ilspy.crproj
================================================
<?xml version="1.0" encoding="utf-8"?>
<project baseDir="." outputDir="Confused" xmlns="http://confuser.codeplex.com">
    <rule preset="none" pattern="true">
        <protection id="anti debug" />
        <protection id="anti dump" />
        <protection id="anti ildasm" />
        <protection id="anti tamper" />
        <protection id="constants" />
        <protection id="ctrl flow" />
        <protection id="invalid metadata" />
        <protection id="ref proxy" />
        <protection id="rename" />
        <protection id="resources" />
    </rule>
    <module path="ICSharpCode.AvalonEdit.dll" />
    <module path="ICSharpCode.Decompiler.dll" />
    <module path="ICSharpCode.NRefactory.dll" />
    <module path="ICSharpCode.NRefactory.CSharp.dll" />
    <module path="ICSharpCode.NRefactory.VB.dll" />
    <module path="ICSharpCode.TreeView.dll" />
    <module path="ILSpy.BamlDecompiler.Plugin.dll" />
    <module path="ILSpy.exe" />
    <module path="ILSpy.SharpDevelop.LGPL.dll" />
    <module path="Mono.Cecil.dll" />
    <module path="Mono.Cecil.Pdb.dll" />
</project>


================================================
File: additional/pdn.crproj
================================================
<?xml version="1.0" encoding="utf-8"?>
<project baseDir="." outputDir="Confused" xmlns="http://confuser.codeplex.com">
    <rule preset="none" pattern="true">
        <protection id="anti debug" />
        <protection id="anti dump" />
        <protection id="anti ildasm" />
        <protection id="anti tamper" />
        <protection id="constants" />
        <protection id="ctrl flow" />
        <protection id="invalid metadata" />
        <protection id="ref proxy" />
        <protection id="rename" />
        <protection id="resources" />
    </rule>
    <rule preset="none" pattern="namespace('PaintDotNet.Menus') and match-name('Menu(|Item|Base)$')">
        <protection id="rename" action="remove" />
    </rule>
    <rule preset="none" pattern="namespace('PaintDotNet.Menus') and match-type-name('Menu$') and match-name('^menu')">
        <protection id="rename" action="remove" />
    </rule>
    <rule preset="none" pattern="namespace('PaintDotNet.Tools') and match-name('Tool(|Base)$')">
        <protection id="rename" action="remove" />
    </rule>
    <rule preset="none" pattern="namespace('PaintDotNet.IndirectUI') and match-type-name('PropertyControl') and (member-type('method') or member-type('property'))">
        <protection id="rename" action="remove" />
    </rule>
    <module path="PaintDotNet.exe" />
    <module path="PaintDotNet.Base.dll" />
    <module path="PaintDotNet.Core.dll" />
    <module path="PaintDotNet.Data.dll" />
    <module path="PaintDotNet.Effects.dll" />
    <module path="PaintDotNet.Resources.dll" />
    <module path="PaintDotNet.SystemLayer.dll" />
</project>




================================================
File: docs/DeclarativeObfuscation.txt
================================================
ConfuserEx declarative obfuscation:

Attribute semantics:
ApplyToMembers: The children uses this protection settings as base.
Exclude: No protection will be applied to this item.
!ApplyToMembers + !Exclude: The protection settings just apply to this item.
ApplyToMembers + Exclude: This item and its chilren will have no protection.	

Pattern examples:

generate debug symbol:true
random seed:ABCDEFG
strong name key:C:\key.snk
strong name key password:hunter2
packer:compressor(mode=dynamic)
namespace 'ConfuserEx.CLI':preset(normal);+rename;anti tamper(mode=jit,key=dynamic);-anti debug
preset(none);+rename;

Usage examples:

[assembly: Obfuscation(Exclude = false, Feature = "preset(minimum);+ctrl flow;-anti debug;+rename(mode=letters,flatten=false);")]
[assembly: Obfuscation(Exclude = false, Feature = "random seed: Hello!")]
[assembly: Obfuscation(Exclude = false, Feature = "namespace 'Test':-rename")]
namespace Test {
	[Obfuscation(Exclude = false, Feature = "constants")]
	class Program {
		public static void Main() {
			Console.WriteLine("Hi");
		}
	}
}


================================================
File: docs/ProjectFormat.md
================================================
ConfuserEx Project Format
=======================

ConfuserEx projects (*.crproj) is an XML formatted document describing the ConfuserEx project.

For details of the format, please refer to the XML schema at `Confuser.Core\Project\ConfuserPrj.xsd`.

Element `project`
-----------------

Element `project` is the root element of the project document.

**Attributes:**

`outputDir`:  
The directory which ConfuserEx stores the output files.

`baseDir`:  
The base directory of all relative path used in the project document.
If this attribute value is also a relative path, the result depends on the implementation.
In the offical implementation (Confuser.CLI), it would be based on the location of project file.
 
`seed`:  
The seed of the random generator in protection process.

`debug`:  
Indicates whether the debug symbols (*.pdb) are generated.
Currently unused.

**Elements:**

`rule`:  
The global protection rules applied to all modules.
Optional.

`packer`:  
The packer setting.
Optional.
Currently unused.

`module`:  
The settings of individual modules.

`probePath`:  
The directories in which ConfuserEx searches for dependencies.


Element `module`
----------------

Element `module` describes the settings of individual modules.

**Attributes:**

`path`:  
The path of the module.

`snKey`:  
The path to the Strong Name Key used to sign the module.
Optional.

`snKeyPass`:  
The password of the SNK if a PFX container is used in `snKey`.
Optional.

**Elements:**

`rule`:  
The protection rules applied to the module.


Element `rule`
--------------

Element `rule` describes a rule that determine how the protections are applied.

**Attributes:**

`inherit`:  
Indicates whether this rule inherits the settings from the previous rules.
Default to `true`.

`pattern`:  
The pattern expression used to match the target components of this rule.

`preset`:  
The protection preset of the rule.
Possible values are `none`, `minimum`, `normal`, `aggressive` and `maximum`.
Default to `none`.

**Elements:**

`protection`:  
The protection settings.

Element `protection` and `packer`
---------------------------------

Element `protection` and `packer` describe the settings of individual protection/packer.

**Attributes:**

`action`:  
Indicates whether the protection are to be added or removed from settings.
Possible values are `add` and `remove`.
Default to `add`.

`id`:  
The identifier of the protection/packer.

**Elements:**

`argument`:  
The arguments that passed to the protection.
Optional.

Element `argument`
------------------

An argument that is passed to a protection.

**Attributes:**

`name`:
The name of the argument.

`value`:
The value of the argument.

Applying rules
--------------
The rules are applied from global rules (in `project` element) to local rules (in `module` element), from begin to end.
ConfuserEx will keep a list of protections for every items, and applies the rules in order.

For each rules, ConfuserEx will do:

1. If the item does not match with the rule's pattern, skip the rule.
2. If the rule does not inherit previous settings (i.e. no `inherit`), clear the marking on the item.
3. Mark the items with the protections contained in the specified `preset` value of the rule.
4. For each protection settings in the rule:
5. If `action` is remove, remove the protection from the marking.
6. If `action` is add, add the protection settings to marking.

The pattern is a simple function-based expression that evaluated for every items. If it is evaluated to `true`, the item is matched with the pattern.

Here are some example expressions:
`true`: Matches all items.
`name('X')`: Matches all items that has name 'X'.
`member-type('type') and full-name('NS.Type')`: Matches types that have full name 'NS.Type'.

Examples
----------------
ConfuserEx projects that work for ILSpy and PaintDotNet can be found under `additional` directory as examples.



================================================
File: docs/docs.shfbproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="4.0">
  <PropertyGroup>
    <!-- The configuration and platform will be used to determine which assemblies to include from solution and
				 project documentation sources -->
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{e8d8557e-206d-4f31-97b0-2caa1a598169}</ProjectGuid>
    <SHFBSchemaVersion>1.9.9.0</SHFBSchemaVersion>
    <!-- AssemblyName, Name, and RootNamespace are not used by SHFB but Visual Studio adds them anyway -->
    <AssemblyName>Documentation</AssemblyName>
    <RootNamespace>Documentation</RootNamespace>
    <Name>Documentation</Name>
    <!-- SHFB properties -->
    <FrameworkVersion>.NET Framework 3.5</FrameworkVersion>
    <OutputPath>docs\</OutputPath>
    <HtmlHelpName>Confuser</HtmlHelpName>
    <Language>en-US</Language>
    <DocumentationSources>
      <DocumentationSource sourceFile="Confuser.Core\Confuser.Core.csproj" />
      <DocumentationSource sourceFile="Confuser.CLI\Confuser.CLI.csproj" />
      <DocumentationSource sourceFile="Confuser.Protections\Confuser.Protections.csproj" />
      <DocumentationSource sourceFile="Confuser.Renamer\Confuser.Renamer.csproj" />
    </DocumentationSources>
    <MaximumGroupParts>2</MaximumGroupParts>
    <NamespaceGrouping>False</NamespaceGrouping>
    <SyntaxFilters>C#</SyntaxFilters>
    <SdkLinkTarget>Blank</SdkLinkTarget>
    <RootNamespaceContainer>False</RootNamespaceContainer>
    <PresentationStyle>VS2010</PresentationStyle>
    <Preliminary>False</Preliminary>
    <NamingMethod>MemberName</NamingMethod>
    <HelpTitle>Confuser</HelpTitle>
    <ContentPlacement>AboveNamespaces</ContentPlacement>
    <BuildAssemblerVerbosity>OnlyWarningsAndErrors</BuildAssemblerVerbosity>
    <HelpFileFormat>HtmlHelp1, Website</HelpFileFormat>
    <IndentHtml>False</IndentHtml>
    <KeepLogFile>True</KeepLogFile>
    <DisableCodeBlockComponent>False</DisableCodeBlockComponent>
    <CppCommentsFixup>False</CppCommentsFixup>
    <CleanIntermediates>True</CleanIntermediates>
    <WebsiteSdkLinkType>None</WebsiteSdkLinkType>
    <HtmlSdkLinkType>None</HtmlSdkLinkType>
    <IncludeFavorites>False</IncludeFavorites>
    <BinaryTOC>True</BinaryTOC>
    <ComponentConfigurations>
      <ComponentConfig id="IntelliSense Component" enabled="True">
        <component id="IntelliSense Component">
          <!-- Output options (optional)
  Attributes:
    Include namespaces (false by default)
    Namespaces comments filename ("Namespaces" if not specified or empty)
    Output folder (current folder if not specified or empty) -->
          <output includeNamespaces="false" namespacesFile="Namespaces" folder="{@OutputFolder}" />
        </component>
      </ComponentConfig>
    </ComponentConfigurations>
  </PropertyGroup>
  <!-- There are no properties for these groups.  AnyCPU needs to appear in order for Visual Studio to perform
			 the build.  The others are optional common platform types that may appear. -->
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x64' ">
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x64' ">
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|Win32' ">
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|Win32' ">
  </PropertyGroup>
  <ItemGroup>
    <ProjectReference Include="Confuser.Core\Confuser.Core.csproj">
      <Name>Confuser.Core</Name>
      <Project>{BEB67A6E-4C54-4DE5-8C6B-2C12F44A7B92}</Project>
    </ProjectReference>
    <ProjectReference Include="dnlib\src\dnlib.csproj">
      <Name>dnlib</Name>
      <Project>{FDFC1237-143F-4919-8318-4926901F4639}</Project>
    </ProjectReference>
  </ItemGroup>
  <!-- Import the SHFB build targets -->
  <Import Project="$(SHFBROOT)\SandcastleHelpFileBuilder.targets" />
</Project>


================================================
File: .nuget/NuGet.Config
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <solution>
    <add key="disableSourceControlIntegration" value="true" />
  </solution>
</configuration>


================================================
File: .nuget/NuGet.targets
================================================
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
        <SolutionDir Condition="$(SolutionDir) == '' Or $(SolutionDir) == '*Undefined*'">$(MSBuildProjectDirectory)\..\</SolutionDir>

        <!-- Enable the restore command to run before builds -->
        <RestorePackages Condition="  '$(RestorePackages)' == '' ">false</RestorePackages>

        <!-- Property that enables building a package from a project -->
        <BuildPackage Condition=" '$(BuildPackage)' == '' ">false</BuildPackage>

        <!-- Determines if package restore consent is required to restore packages -->
        <RequireRestoreConsent Condition=" '$(RequireRestoreConsent)' != 'false' ">true</RequireRestoreConsent>

        <!-- Download NuGet.exe if it does not already exist -->
        <DownloadNuGetExe Condition=" '$(DownloadNuGetExe)' == '' ">true</DownloadNuGetExe>
    </PropertyGroup>

    <ItemGroup Condition=" '$(PackageSources)' == '' ">
        <!-- Package sources used to restore packages. By default, registered sources under %APPDATA%\NuGet\NuGet.Config will be used -->
        <!-- The official NuGet package source (https://www.nuget.org/api/v2/) will be excluded if package sources are specified and it does not appear in the list -->
        <!--
            <PackageSource Include="https://www.nuget.org/api/v2/" />
            <PackageSource Include="https://my-nuget-source/nuget/" />
        -->
    </ItemGroup>

    <PropertyGroup Condition=" '$(OS)' == 'Windows_NT'">
        <!-- Windows specific commands -->
        <NuGetToolsPath>$([System.IO.Path]::Combine($(SolutionDir), ".nuget"))</NuGetToolsPath>
    </PropertyGroup>

    <PropertyGroup Condition=" '$(OS)' != 'Windows_NT'">
        <!-- We need to launch nuget.exe with the mono command if we're not on windows -->
        <NuGetToolsPath>$(SolutionDir).nuget</NuGetToolsPath>
    </PropertyGroup>

    <PropertyGroup>
        <PackagesProjectConfig>packages.$(MSBuildProjectName.Replace(' ', '_')).config</PackagesProjectConfig>
    </PropertyGroup>

    <Choose>
        <When Condition="Exists('$(PackagesProjectConfig)')">
            <PropertyGroup>
                <PackagesConfig>$(PackagesProjectConfig)</PackagesConfig>
            </PropertyGroup>
        </When>
        <When Condition="Exists('packages.config')">
            <PropertyGroup>
                <PackagesConfig>packages.config</PackagesConfig>
            </PropertyGroup>
        </When>
    </Choose>
    
    <PropertyGroup>
        <!-- NuGet command -->
        <NuGetExePath Condition=" '$(NuGetExePath)' == '' ">$(NuGetToolsPath)\NuGet.exe</NuGetExePath>
        <PackageSources Condition=" $(PackageSources) == '' ">@(PackageSource)</PackageSources>

        <NuGetCommand Condition=" '$(OS)' == 'Windows_NT'">"$(NuGetExePath)"</NuGetCommand>
        <NuGetCommand Condition=" '$(OS)' != 'Windows_NT' ">mono --runtime=v4.0.30319 $(NuGetExePath)</NuGetCommand>

        <PackageOutputDir Condition="$(PackageOutputDir) == ''">$(TargetDir.Trim('\\'))</PackageOutputDir>

        <RequireConsentSwitch Condition=" $(RequireRestoreConsent) == 'true' ">-RequireConsent</RequireConsentSwitch>
        <NonInteractiveSwitch Condition=" '$(VisualStudioVersion)' != '' AND '$(OS)' == 'Windows_NT' ">-NonInteractive</NonInteractiveSwitch>

        <PaddedSolutionDir Condition=" '$(OS)' == 'Windows_NT'">"$(SolutionDir) "</PaddedSolutionDir>
        <PaddedSolutionDir Condition=" '$(OS)' != 'Windows_NT' ">"$(SolutionDir)"</PaddedSolutionDir>

        <!-- Commands -->
        <RestoreCommand>$(NuGetCommand) install "$(PackagesConfig)" -source "$(PackageSources)"  $(NonInteractiveSwitch) $(RequireConsentSwitch) -solutionDir $(PaddedSolutionDir)</RestoreCommand>
        <BuildCommand>$(NuGetCommand) pack "$(ProjectPath)" -Properties "Configuration=$(Configuration);Platform=$(Platform)" $(NonInteractiveSwitch) -OutputDirectory "$(PackageOutputDir)" -symbols</BuildCommand>

        <!-- We need to ensure packages are restored prior to assembly resolve -->
        <BuildDependsOn Condition="$(RestorePackages) == 'true'">
            RestorePackages;
            $(BuildDependsOn);
        </BuildDependsOn>

        <!-- Make the build depend on restore packages -->
        <BuildDependsOn Condition="$(BuildPackage) == 'true'">
            $(BuildDependsOn);
            BuildPackage;
        </BuildDependsOn>
    </PropertyGroup>

    <Target Name="CheckPrerequisites" Condition=" '$(OS)' == 'Windows_NT'">
        <!-- Raise an error if we're unable to locate nuget.exe  -->
        <Error Condition="'$(DownloadNuGetExe)' != 'true' AND !Exists('$(NuGetExePath)')" Text="Unable to locate '$(NuGetExePath)'" />
        <!--
        Take advantage of MsBuild's build dependency tracking to make sure that we only ever download nuget.exe once.
        This effectively acts as a lock that makes sure that the download operation will only happen once and all
        parallel builds will have to wait for it to complete.
        -->
        <MsBuild Targets="_DownloadNuGet" Projects="$(MSBuildThisFileFullPath)" Properties="Configuration=NOT_IMPORTANT;DownloadNuGetExe=$(DownloadNuGetExe)" />
    </Target>

    <Target Name="_DownloadNuGet">
        <DownloadNuGet OutputFilename="$(NuGetExePath)" Condition=" '$(DownloadNuGetExe)' == 'true' AND !Exists('$(NuGetExePath)')" />
    </Target>

    <Target Name="RestorePackages" DependsOnTargets="CheckPrerequisites">        
        <Exec Command="$(RestoreCommand)"
              Condition="'$(OS)' != 'Windows_NT' And Exists('$(PackagesConfig)')" />

        <Exec Command="$(RestoreCommand)"
              LogStandardErrorAsError="true"
              Condition="'$(OS)' == 'Windows_NT' And Exists('$(PackagesConfig)')" />
    </Target>

    <Target Name="BuildPackage" DependsOnTargets="CheckPrerequisites">
        <Exec Command="$(BuildCommand)"
              Condition=" '$(OS)' != 'Windows_NT' " />

        <Exec Command="$(BuildCommand)"
              LogStandardErrorAsError="true"
              Condition=" '$(OS)' == 'Windows_NT' " />
    </Target>

    <UsingTask TaskName="DownloadNuGet" TaskFactory="CodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.v4.0.dll">
        <ParameterGroup>
            <OutputFilename ParameterType="System.String" Required="true" />
        </ParameterGroup>
        <Task>
            <Reference Include="System.Core" />
            <Using Namespace="System" />
            <Using Namespace="System.IO" />
            <Using Namespace="System.Net" />
            <Using Namespace="Microsoft.Build.Framework" />
            <Using Namespace="Microsoft.Build.Utilities" />
            <Code Type="Fragment" Language="cs">
                <![CDATA[
                try {
                    OutputFilename = Path.GetFullPath(OutputFilename);

                    Log.LogMessage("Downloading latest version of NuGet.exe...");
                    WebClient webClient = new WebClient();
                    webClient.DownloadFile("https://www.nuget.org/nuget.exe", OutputFilename);

                    return true;
                }
                catch (Exception ex) {
                    Log.LogErrorFromException(ex);
                    return false;
                }
            ]]>
            </Code>
        </Task>
    </UsingTask>
</Project>



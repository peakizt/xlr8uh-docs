Directory structure:
└── 0xd4d-de4dot/
    ├── README.md
    ├── COPYING
    ├── De4DotCommon.props
    ├── LICENSE.ICSharpCode.SharpZipLib.txt
    ├── LICENSE.QuickLZ.txt
    ├── LICENSE.de4dot.txt
    ├── LICENSE.dnlib.txt
    ├── LICENSE.lzma.txt
    ├── LICENSE.lzmat.txt
    ├── LICENSE.randomc.txt
    ├── build.ps1
    ├── de4dot.netcore.sln
    ├── de4dot.netframework.sln
    ├── de4dot.snk
    ├── .editorconfig
    ├── AssemblyData/
    │   ├── AssemblyData.csproj
    │   ├── AssemblyResolver.cs
    │   ├── AssemblyServer.cs
    │   ├── AssemblyService.cs
    │   ├── DelegateStringDecrypter.cs
    │   ├── EmuStringDecrypter.cs
    │   ├── GenericService.cs
    │   ├── IAssemblyService.cs
    │   ├── IGenericService.cs
    │   ├── IMethodDecrypterService.cs
    │   ├── IStringDecrypter.cs
    │   ├── IStringDecrypterService.cs
    │   ├── IUserGenericService.cs
    │   ├── MethodDecrypterService.cs
    │   ├── SimpleData.cs
    │   ├── StringDecrypterService.cs
    │   ├── Utils.cs
    │   └── methodsrewriter/
    │       ├── AssemblyResolver.cs
    │       ├── CodeGenerator.cs
    │       ├── IMethodsRewriter.cs
    │       ├── MField.cs
    │       ├── MMethod.cs
    │       ├── MModule.cs
    │       ├── MType.cs
    │       ├── MethodsRewriter.cs
    │       ├── Operand.cs
    │       ├── Resolver.cs
    │       ├── ResolverUtils.cs
    │       ├── TypeInstanceResolver.cs
    │       └── TypeResolver.cs
    ├── AssemblyServer/
    │   ├── App.config
    │   ├── AssemblyServer.csproj
    │   └── Program.cs
    ├── AssemblyServer-CLR20/
    │   ├── App.config
    │   ├── AssemblyServer-CLR20.csproj
    │   └── Program.cs
    ├── AssemblyServer-CLR20-x64/
    │   ├── App.config
    │   ├── AssemblyServer-CLR20-x64.csproj
    │   └── Program.cs
    ├── AssemblyServer-CLR40/
    │   ├── App.config
    │   ├── AssemblyServer-CLR40.csproj
    │   └── Program.cs
    ├── AssemblyServer-CLR40-x64/
    │   ├── App.config
    │   ├── AssemblyServer-CLR40-x64.csproj
    │   └── Program.cs
    ├── AssemblyServer-x64/
    │   ├── App.config
    │   ├── AssemblyServer-x64.csproj
    │   └── Program.cs
    ├── Test.Rename/
    │   ├── Program.cs
    │   └── Test.Rename.csproj
    ├── de4dot/
    │   ├── App.config
    │   ├── Program.cs
    │   └── de4dot.csproj
    ├── de4dot-x64/
    │   ├── App.config
    │   ├── Program.cs
    │   └── de4dot-x64.csproj
    ├── de4dot.blocks/
    │   ├── BaseBlock.cs
    │   ├── Block.cs
    │   ├── Blocks.cs
    │   ├── BlocksSorter.cs
    │   ├── CodeGenerator.cs
    │   ├── DeadBlocksRemover.cs
    │   ├── DotNetUtils.cs
    │   ├── DumpedMethod.cs
    │   ├── DumpedMethods.cs
    │   ├── FilterHandlerBlock.cs
    │   ├── ForwardScanOrder.cs
    │   ├── GenericArgsSubstitutor.cs
    │   ├── HandlerBlock.cs
    │   ├── Instr.cs
    │   ├── InstructionListParser.cs
    │   ├── MemberDefDict.cs
    │   ├── MethodBlocks.cs
    │   ├── ScopeBlock.cs
    │   ├── StackTracePatcher.cs
    │   ├── TryBlock.cs
    │   ├── TryHandlerBlock.cs
    │   ├── Utils.cs
    │   ├── de4dot.blocks.csproj
    │   └── cflow/
    │       ├── AccessChecker.cs
    │       ├── BlockCflowDeobfuscator.cs
    │       ├── BlockDeobfuscator.cs
    │       ├── BlocksCflowDeobfuscator.cs
    │       ├── BranchEmulator.cs
    │       ├── CachedCflowDeobfuscator.cs
    │       ├── CflowDeobfuscator.cs
    │       ├── CflowUtils.cs
    │       ├── ConstantsFolder.cs
    │       ├── DeadCodeRemover.cs
    │       ├── DeadStoreRemover.cs
    │       ├── DupBlockDeobfuscator.cs
    │       ├── IBlocksDeobfuscator.cs
    │       ├── ICflowDeobfuscator.cs
    │       ├── InstructionEmulator.cs
    │       ├── Int32Value.cs
    │       ├── Int64Value.cs
    │       ├── MethodCallInliner.cs
    │       ├── MethodCallInlinerBase.cs
    │       ├── Real8Value.cs
    │       ├── StLdlocFixer.cs
    │       ├── SwitchCflowDeobfuscator.cs
    │       ├── Value.cs
    │       └── ValueStack.cs
    ├── de4dot.code/
    │   ├── AssemblyModule.cs
    │   ├── AssemblyResolver.cs
    │   ├── DeobfuscatorContext.cs
    │   ├── DumpedMethodsRestorer.cs
    │   ├── HandleProcessCorruptedStateExceptionsAttribute.cs
    │   ├── IDeobfuscatorContext.cs
    │   ├── IObfuscatedFile.cs
    │   ├── Logger.cs
    │   ├── MethodPrinter.cs
    │   ├── MethodReturnValueInliner.cs
    │   ├── NameRegexes.cs
    │   ├── ObfuscatedFile.cs
    │   ├── Option.cs
    │   ├── PrintNewTokens.cs
    │   ├── StringInliner.cs
    │   ├── UserException.cs
    │   ├── Utils.cs
    │   ├── Win32Path.cs
    │   ├── de4dot.code.csproj
    │   ├── 7zip/
    │   │   ├── ICoder.cs
    │   │   └── Compress/
    │   │       ├── LZ/
    │   │       │   └── LzOutWindow.cs
    │   │       ├── LZMA/
    │   │       │   ├── LzmaBase.cs
    │   │       │   └── LzmaDecoder.cs
    │   │       └── RangeCoder/
    │   │           ├── RangeCoder.cs
    │   │           ├── RangeCoderBit.cs
    │   │           └── RangeCoderBitTree.cs
    │   ├── AssemblyClient/
    │   │   ├── AssemblyClient.cs
    │   │   ├── AssemblyClientFactory.cs
    │   │   ├── IAssemblyClient.cs
    │   │   ├── IAssemblyServerLoader.cs
    │   │   ├── IpcAssemblyServerLoader.cs
    │   │   ├── NewAppDomainAssemblyServerLoader.cs
    │   │   ├── NewProcessAssemblyServerLoader.cs
    │   │   ├── SameAppDomainAssemblyServerLoader.cs
    │   │   └── ServerClrVersion.cs
    │   ├── SharpZipLib/
    │   │   ├── Main.cs
    │   │   ├── SharpZipBaseException.cs
    │   │   ├── Checksums/
    │   │   │   ├── Adler32.cs
    │   │   │   └── IChecksum.cs
    │   │   └── Zip/
    │   │       └── Compression/
    │   │           ├── Inflater.cs
    │   │           ├── InflaterDynHeader.cs
    │   │           ├── InflaterHuffmanTree.cs
    │   │           └── Streams/
    │   │               ├── OutputWindow.cs
    │   │               └── StreamManipulator.cs
    │   ├── deobfuscators/
    │   │   ├── AllTypesHelper.cs
    │   │   ├── ArrayFinder.cs
    │   │   ├── Blowfish.cs
    │   │   ├── CRC32.cs
    │   │   ├── ConstantsReader.cs
    │   │   ├── DeobUtils.cs
    │   │   ├── DeobfuscatorBase.cs
    │   │   ├── DeobfuscatorInfoBase.cs
    │   │   ├── ExceptionLoggerRemover.cs
    │   │   ├── IDeobfuscatedFile.cs
    │   │   ├── IDeobfuscator.cs
    │   │   ├── IDeobfuscatorInfo.cs
    │   │   ├── ISimpleDeobfuscator.cs
    │   │   ├── InitializedDataCreator.cs
    │   │   ├── InlinedMethodsFinder.cs
    │   │   ├── MemberReferenceBuilder.cs
    │   │   ├── MethodBodyParser.cs
    │   │   ├── MethodCallRestorerBase.cs
    │   │   ├── MethodCollection.cs
    │   │   ├── MethodStack.cs
    │   │   ├── MethodsDecrypter.cs
    │   │   ├── MyPEImage.cs
    │   │   ├── NullStream.cs
    │   │   ├── Operations.cs
    │   │   ├── ProxyCallFixerBase.cs
    │   │   ├── QuickLZ.cs
    │   │   ├── RandomNameChecker.cs
    │   │   ├── StringCounts.cs
    │   │   ├── TypesRestorer.cs
    │   │   ├── UnpackedFile.cs
    │   │   ├── UnusedMethodsFinder.cs
    │   │   ├── ValueInlinerBase.cs
    │   │   ├── Agile_NET/
    │   │   │   ├── CliSecureRtType.cs
    │   │   │   ├── CsBlowfish.cs
    │   │   │   ├── Deobfuscator.cs
    │   │   │   ├── MethodsDecrypter.cs
    │   │   │   ├── ProxyCallFixer.cs
    │   │   │   ├── ResourceDecrypter.cs
    │   │   │   ├── StackFrameHelper.cs
    │   │   │   ├── StringDecrypter.cs
    │   │   │   ├── StringDecrypterInfo.cs
    │   │   │   └── vm/
    │   │   │       ├── CilOperandInstructionRestorer.cs
    │   │   │       ├── CsvmDataReader.cs
    │   │   │       ├── CsvmMethodData.cs
    │   │   │       ├── CsvmToCilMethodConverterBase.cs
    │   │   │       ├── VmOperand.cs
    │   │   │       ├── v1/
    │   │   │       │   ├── Csvm.cs
    │   │   │       │   ├── CsvmToCilMethodConverter.cs
    │   │   │       │   ├── FieldsInfo.cs
    │   │   │       │   ├── OpCodeHandler.cs
    │   │   │       │   ├── OpCodeHandlers.cs
    │   │   │       │   ├── UnknownHandlerInfo.cs
    │   │   │       │   └── VmOpCodeHandlerDetector.cs
    │   │   │       └── v2/
    │   │   │           ├── CSVM1.bin
    │   │   │           ├── CSVM2.bin
    │   │   │           ├── CSVM3.bin
    │   │   │           ├── CSVM4.bin
    │   │   │           ├── CSVM5.bin
    │   │   │           ├── CSVM6.bin
    │   │   │           ├── CompositeHandlerDetector.cs
    │   │   │           ├── CompositeOpCodeHandler.cs
    │   │   │           ├── Csvm.cs
    │   │   │           ├── CsvmInfo.cs
    │   │   │           ├── CsvmResources.Designer.cs
    │   │   │           ├── CsvmResources.resx
    │   │   │           ├── CsvmToCilMethodConverter.cs
    │   │   │           ├── HandlerTypeCode.cs
    │   │   │           ├── OpCodeHandlerInfo.cs
    │   │   │           ├── OpCodeHandlerInfoReader.cs
    │   │   │           ├── OpCodeHandlerInfos.cs
    │   │   │           ├── SigCreator.cs
    │   │   │           ├── VmOpCode.cs
    │   │   │           └── VmOpCodeHandlerDetector.cs
    │   │   ├── Babel_NET/
    │   │   │   ├── AssemblyResolver.cs
    │   │   │   ├── BabelInflater.cs
    │   │   │   ├── BabelMethodCallInliner.cs
    │   │   │   ├── BabelUtils.cs
    │   │   │   ├── ConstantsDecrypter.cs
    │   │   │   ├── Deobfuscator.cs
    │   │   │   ├── ImageReader.cs
    │   │   │   ├── InflaterCreator.cs
    │   │   │   ├── MemberReferenceConverter.cs
    │   │   │   ├── MethodBodyReader.cs
    │   │   │   ├── MethodReferenceReader.cs
    │   │   │   ├── MethodsDecrypter.cs
    │   │   │   ├── ProxyCallFixer.cs
    │   │   │   ├── ResourceDecrypter.cs
    │   │   │   ├── ResourceResolver.cs
    │   │   │   └── StringDecrypter.cs
    │   │   ├── CodeFort/
    │   │   │   ├── AssemblyData.cs
    │   │   │   ├── AssemblyDecrypter.cs
    │   │   │   ├── CfMethodCallInliner.cs
    │   │   │   ├── Deobfuscator.cs
    │   │   │   ├── PasswordFinder.cs
    │   │   │   ├── ProxyCallFixer.cs
    │   │   │   └── StringDecrypter.cs
    │   │   ├── CodeVeil/
    │   │   │   ├── AssemblyResolver.cs
    │   │   │   ├── DataReaderUtils.cs
    │   │   │   ├── Deobfuscator.cs
    │   │   │   ├── ErexResourceReader.cs
    │   │   │   ├── InvalidDataException.cs
    │   │   │   ├── InvalidMethodsFinder.cs
    │   │   │   ├── MainType.cs
    │   │   │   ├── MethodsDecrypter.cs
    │   │   │   ├── ObfuscatorVersion.cs
    │   │   │   ├── ProxyCallFixer.cs
    │   │   │   ├── ResourceConverter.cs
    │   │   │   ├── ResourceDecrypter.cs
    │   │   │   ├── ResourceInfo.cs
    │   │   │   ├── ResourceReader.cs
    │   │   │   ├── StringDecrypter.cs
    │   │   │   └── TamperDetection.cs
    │   │   ├── CodeWall/
    │   │   │   ├── AssemblyDecrypter.cs
    │   │   │   ├── Deobfuscator.cs
    │   │   │   ├── KeyGenerator.cs
    │   │   │   ├── MethodsDecrypter.cs
    │   │   │   ├── StringDecrypter.cs
    │   │   │   └── randomc/
    │   │   │       ├── CRandomMersenne.cs
    │   │   │       └── CRandomMother.cs
    │   │   ├── Confuser/
    │   │   │   ├── AntiDebugger.cs
    │   │   │   ├── AntiDumping.cs
    │   │   │   ├── Arg64ConstantsReader.cs
    │   │   │   ├── ConfuserUtils.cs
    │   │   │   ├── ConstantsDecrypterBase.cs
    │   │   │   ├── ConstantsDecrypterUtils.cs
    │   │   │   ├── ConstantsDecrypterV15.cs
    │   │   │   ├── ConstantsDecrypterV17.cs
    │   │   │   ├── ConstantsDecrypterV18.cs
    │   │   │   ├── ConstantsFolder.cs
    │   │   │   ├── ConstantsInliner.cs
    │   │   │   ├── Deobfuscator.cs
    │   │   │   ├── IVersionProvider.cs
    │   │   │   ├── JitMethodsDecrypter.cs
    │   │   │   ├── MemoryMethodsDecrypter.cs
    │   │   │   ├── MethodsDecrypterBase.cs
    │   │   │   ├── ProxyCallFixer.cs
    │   │   │   ├── ResourceDecrypter.cs
    │   │   │   ├── StringDecrypter.cs
    │   │   │   ├── Unpacker.cs
    │   │   │   ├── VersionDetector.cs
    │   │   │   └── x86Emulator.cs
    │   │   ├── CryptoObfuscator/
    │   │   │   ├── AntiDebugger.cs
    │   │   │   ├── AssemblyResolver.cs
    │   │   │   ├── CoMethodCallInliner.cs
    │   │   │   ├── CoUtils.cs
    │   │   │   ├── ConstantsDecrypter.cs
    │   │   │   ├── Deobfuscator.cs
    │   │   │   ├── InlinedMethodTypes.cs
    │   │   │   ├── LdnullFixer.cs
    │   │   │   ├── MethodBodyReader.cs
    │   │   │   ├── MethodsDecrypter.cs
    │   │   │   ├── ProxyCallFixer.cs
    │   │   │   ├── ResourceDecrypter.cs
    │   │   │   ├── ResourceResolver.cs
    │   │   │   ├── StringDecrypter.cs
    │   │   │   └── TamperDetection.cs
    │   │   ├── DeepSea/
    │   │   │   ├── ArrayBlockDeobfuscator.cs
    │   │   │   ├── ArrayBlockState.cs
    │   │   │   ├── AssemblyResolver.cs
    │   │   │   ├── CastDeobfuscator.cs
    │   │   │   ├── Deobfuscator.cs
    │   │   │   ├── DsConstantsReader.cs
    │   │   │   ├── DsInlinedMethodsFinder.cs
    │   │   │   ├── DsMethodCallInliner.cs
    │   │   │   ├── DsUtils.cs
    │   │   │   ├── FieldsRestorer.cs
    │   │   │   ├── ResolverBase.cs
    │   │   │   ├── ResourceResolver.cs
    │   │   │   └── StringDecrypter.cs
    │   │   ├── Dotfuscator/
    │   │   │   ├── CflowDecrypter.cs
    │   │   │   ├── Deobfuscator.cs
    │   │   │   ├── StringBuilderDecrypter.cs
    │   │   │   └── StringDecrypter.cs
    │   │   ├── Eazfuscator_NET/
    │   │   │   ├── AssemblyResolver.cs
    │   │   │   ├── CodeCompilerMethodCallRestorer.cs
    │   │   │   ├── DecrypterType.cs
    │   │   │   ├── Deobfuscator.cs
    │   │   │   ├── DynamicDynocodeIterator.cs
    │   │   │   ├── DynocodeService.cs
    │   │   │   ├── EfConstantsReader.cs
    │   │   │   ├── EfUtils.cs
    │   │   │   ├── ResourceMethodsRestorer.cs
    │   │   │   ├── ResourceResolver.cs
    │   │   │   ├── StringDecrypter.cs
    │   │   │   └── VersionDetector.cs
    │   │   ├── Goliath_NET/
    │   │   │   ├── ArrayDecrypter.cs
    │   │   │   ├── ArrayValueInliner.cs
    │   │   │   ├── DecrypterBase.cs
    │   │   │   ├── Deobfuscator.cs
    │   │   │   ├── IntegerDecrypter.cs
    │   │   │   ├── LocalsRestorer.cs
    │   │   │   ├── LogicalExpressionFixer.cs
    │   │   │   ├── ProxyCallFixer.cs
    │   │   │   ├── StringDecrypter.cs
    │   │   │   └── StrongNameChecker.cs
    │   │   ├── ILProtector/
    │   │   │   ├── DecryptedMethodInfo.cs
    │   │   │   ├── Deobfuscator.cs
    │   │   │   ├── DynamicMethodsDecrypter.cs
    │   │   │   ├── DynamicMethodsDecrypterService.cs
    │   │   │   ├── DynamicMethodsRestorer.cs
    │   │   │   ├── MainType.cs
    │   │   │   ├── MethodReader.cs
    │   │   │   ├── MethodsDecrypterBase.cs
    │   │   │   ├── RuntimeFileInfo.cs
    │   │   │   └── StaticMethodsDecrypter.cs
    │   │   ├── MPRESS/
    │   │   │   ├── Deobfuscator.cs
    │   │   │   └── Lzmat.cs
    │   │   ├── MaxtoCode/
    │   │   │   ├── CryptDecrypter.cs
    │   │   │   ├── Decrypter6.cs
    │   │   │   ├── DecrypterInfo.cs
    │   │   │   ├── Deobfuscator.cs
    │   │   │   ├── EncryptionInfos.cs
    │   │   │   ├── MainType.cs
    │   │   │   ├── McKey.cs
    │   │   │   ├── MethodsDecrypter.cs
    │   │   │   ├── PeHeader.cs
    │   │   │   └── StringDecrypter.cs
    │   │   ├── Rummage/
    │   │   │   ├── Deobfuscator.cs
    │   │   │   ├── RummageVersion.cs
    │   │   │   └── StringDecrypter.cs
    │   │   ├── Skater_NET/
    │   │   │   ├── Deobfuscator.cs
    │   │   │   ├── EnumClassFinder.cs
    │   │   │   └── StringDecrypter.cs
    │   │   ├── SmartAssembly/
    │   │   │   ├── AssemblyResolver.cs
    │   │   │   ├── AssemblyResolverInfo.cs
    │   │   │   ├── AutomatedErrorReportingFinder.cs
    │   │   │   ├── Deobfuscator.cs
    │   │   │   ├── MemoryManagerInfo.cs
    │   │   │   ├── ProxyCallFixer.cs
    │   │   │   ├── ResolverInfoBase.cs
    │   │   │   ├── ResourceDecrypter.cs
    │   │   │   ├── ResourceDecrypterInfo.cs
    │   │   │   ├── ResourceResolver.cs
    │   │   │   ├── ResourceResolverInfo.cs
    │   │   │   ├── SimpleZipInfo.cs
    │   │   │   ├── StringDecrypter.cs
    │   │   │   ├── StringDecrypterInfo.cs
    │   │   │   ├── StringEncoderClassFinder.cs
    │   │   │   └── TamperProtectionRemover.cs
    │   │   ├── Spices_Net/
    │   │   │   ├── Deobfuscator.cs
    │   │   │   ├── QclzDecompressor.cs
    │   │   │   ├── ResourceNamesRestorer.cs
    │   │   │   ├── SpicesMethodCallInliner.cs
    │   │   │   └── StringDecrypter.cs
    │   │   ├── Unknown/
    │   │   │   └── Deobfuscator.cs
    │   │   ├── Xenocode/
    │   │   │   ├── Deobfuscator.cs
    │   │   │   └── StringDecrypter.cs
    │   │   └── dotNET_Reactor/
    │   │       ├── v3/
    │   │       │   ├── AntiStrongName.cs
    │   │       │   ├── ApplicationModeDecrypter.cs
    │   │       │   ├── ApplicationModeUnpacker.cs
    │   │       │   ├── AssemblyResolver.cs
    │   │       │   ├── DecryptMethod.cs
    │   │       │   ├── DecrypterType.cs
    │   │       │   ├── Deobfuscator.cs
    │   │       │   ├── LibAssemblyResolver.cs
    │   │       │   ├── MemoryPatcher.cs
    │   │       │   └── NativeLibSaver.cs
    │   │       └── v4/
    │   │           ├── AntiStrongName.cs
    │   │           ├── AssemblyResolver.cs
    │   │           ├── BooleanDecrypter.cs
    │   │           ├── Deobfuscator.cs
    │   │           ├── DnrMethodCallInliner.cs
    │   │           ├── EmptyClass.cs
    │   │           ├── EncryptedResource.cs
    │   │           ├── MetadataTokenObfuscator.cs
    │   │           ├── MethodsDecrypter.cs
    │   │           ├── NativeFileDecrypter.cs
    │   │           ├── NativeImageUnpacker.cs
    │   │           ├── ProxyCallFixer.cs
    │   │           ├── ResourceResolver.cs
    │   │           └── StringDecrypter.cs
    │   └── renamer/
    │       ├── DerivedFrom.cs
    │       ├── ExistingNames.cs
    │       ├── INameChecker.cs
    │       ├── MemberInfos.cs
    │       ├── NameCreators.cs
    │       ├── Renamer.cs
    │       ├── ResourceKeysRenamer.cs
    │       ├── ResourceRenamer.cs
    │       ├── TypeInfo.cs
    │       ├── TypeNames.cs
    │       ├── TypeRenamerState.cs
    │       ├── VariableNameState.cs
    │       └── asmmodules/
    │           ├── EventDef.cs
    │           ├── FieldDef.cs
    │           ├── GenericParamDef.cs
    │           ├── IResolver.cs
    │           ├── MemberRefFinder.cs
    │           ├── MethodDef.cs
    │           ├── MethodNameGroups.cs
    │           ├── Module.cs
    │           ├── Modules.cs
    │           ├── ParamDef.cs
    │           ├── PropertyDef.cs
    │           ├── Ref.cs
    │           ├── RefDict.cs
    │           └── TypeDef.cs
    ├── de4dot.cui/
    │   ├── CommandLineParser.cs
    │   ├── FilesDeobfuscator.cs
    │   ├── Program.cs
    │   ├── de4dot.cui.csproj
    │   └── Properties/
    │       └── AssemblyInfo.cs
    ├── de4dot.mdecrypt/
    │   ├── DecryptMethodsInfo.cs
    │   ├── DynamicMethodsDecrypter.cs
    │   ├── NativeCodeGenerator.cs
    │   └── de4dot.mdecrypt.csproj
    ├── deobfuscator.Template/
    │   ├── deobfuscator.Template.csproj
    │   └── readme.txt
    └── .github/
        └── workflows/
            └── build.yml

================================================
File: README.md
================================================
Description
===========

de4dot is an open source (GPLv3) .NET deobfuscator and unpacker written in C#. It will try its best to restore a packed and obfuscated assembly to almost the original assembly. Most of the obfuscation can be completely restored (eg. string encryption), but symbol renaming is impossible to restore since the original names aren't (usually) part of the obfuscated assembly.

It uses [dnlib](https://github.com/0xd4d/dnlib/) to read and write assemblies so make sure you get it or it won't compile.

Binaries
========

Get binaries from the build server [![](https://github.com/0xd4d/de4dot/workflows/GitHub%20CI/badge.svg)](https://github.com/0xd4d/de4dot/actions).

It's FREE but there's NO SUPPORT
================================

There's no support. Don't email me if you can't use it or if it fails to deobfuscate a file obfuscated with an updated obfuscator.

Instead, try to update de4dot yourself. It's a lot easier than you think. If you can't, search the Internet and you should find a couple of forums where you can ask your question.

Features
========

Here's a pseudo random list of the things it will do depending on what obfuscator was used to obfuscate an assembly:

* Inline methods. Some obfuscators move small parts of a method to another static method and calls it.
* Decrypt strings statically or dynamically
* Decrypt other constants. Some obfuscators can also encrypt other constants, such as all integers, all doubles, etc.
* Decrypt methods statically or dynamically
* Remove proxy methods. Many obfuscators replace most/all call instructions with a call to a delegate. This delegate in turn calls the real method.
* Rename symbols. Even though most symbols can't be restored, it will rename them to human readable strings. Sometimes, some of the original names can be restored, though.
* Devirtualize virtualized code
* Decrypt resources. Many obfuscators have an option to encrypt .NET resources.
* Decrypt embedded files. Many obfuscators have an option to embed and possibly encrypt/compress other assemblies.
* Remove tamper detection code
* Remove anti-debug code
* Control flow deobfuscation. Many obfuscators modify the IL code so it looks like spaghetti code making it very difficult to understand the code.
* Restore class fields. Some obfuscators can move fields from one class to some other obfuscator created class.
* Convert a PE exe to a .NET exe. Some obfuscators wrap a .NET assembly inside a Win32 PE so a .NET decompiler can't read the file.
* Removes most/all junk classes added by the obfuscator.
* Fixes some peverify errors. Many of the obfuscators are buggy and create unverifiable code by mistake.
* Restore the types of method parameters and fields

Supported obfuscators/packers
=============================

* Agile.NET (aka CliSecure)
* Babel.NET
* CodeFort
* CodeVeil
* CodeWall
* CryptoObfuscator
* DeepSea Obfuscator
* Dotfuscator
* .NET Reactor
* Eazfuscator.NET
* Goliath.NET
* ILProtector
* MaxtoCode
* MPRESS
* Rummage
* Skater.NET
* SmartAssembly
* Spices.Net
* Xenocode

Some of the above obfuscators are rarely used (eg. Goliath.NET), so they have had much less testing. Help me out by reporting bugs or problems you find.

Warning
=======

Sometimes the obfuscated assembly and all its dependencies are loaded into memory for execution. Use a safe sandbox environment if you suspect the assembly or assemblies to be malware.

Even if the current version of de4dot doesn't load a certain assembly into memory for execution, a future version might.

How to use de4dot
=================

N00b users
----------

Drag and drop the file(s) onto de4dot.exe and wait a few seconds.

Deobfuscate more than one file at a time
----------------------------------------

When more than one assembly has been obfuscated, it's very likely that you must deobfuscate them all at the same time unless you disable symbol renaming. The reason is that if assembly A has a reference to class C in assembly B, and you rename symbols only in assembly B, then class C could be renamed to eg. Class0 but the reference in assembly A still references a class called C in assembly B. If you deobfuscate both assemblies at the same time, all references will also be updated.

Find all obfuscated files and deobfuscate them
----------------------------------------------

The following command line will deobfuscate all assemblies that have been obfuscated by a supported obfuscator and save the assemblies to `c:\output`

    de4dot -r c:\input -ru -ro c:\output

`-r` means recursive search. `-ru` means it should ignore unknown files. `-ro` means it should place the output files in the following directory. Typically, you'd first copy `c:\input` to `c:\output`, and then run the command. That way all the files will be in `c:\output`, even non-assemblies and non-processed assemblies. When de4dot is finished, you'd just double click the main assembly in `c:\output` and it should hopefully start.

Detect obfuscator
-----------------

Use the `-d` option to detect the obfuscator without deobfuscating any assembly.

Find all .NET assemblies and detect obfuscator. If it's an unsupported obfuscator or if it's not obfuscated, it will print "Unknown obfuscator".

    de4dot -d -r c:\input

Same as above except that it will only show which files have been obfuscated by a supported obfuscator.

    de4dot -d -r c:\input -ru

Detect obfuscator

    de4dot -d file1.dll file2.dll file3.dll

Preserving metadata tokens
--------------------------

Sometimes in rare cases, you'd want to preserve the metadata tokens. Use `--preserve-tokens` or `--preserve-table`. Also consider using `--keep-types` since it won't remove any types and methods added by the obfuscator. Another useful option is `--dont-create-params`. If used, the renamer won't create Param rows for method parameters that don't have a Param row. That way the ParamPtr table won't be added to your assemblies. Peverify has a bug and doesn't support it (you'll see lots of "errors").

The #Strings, #US and #Blob heaps can also be preserved by using `--preserve-strings`, `--preserve-us`, and `--preserve-blob` respectively. Of these three, `--preserve-us` is the most useful one since `ldstr` instruction and `module.ResolveString()` directly reference the #US heap.

`--preserve-sig-data` should be used if the obfuscator adds extra data at the end of signatures that it uses for its own purpose, eg. as decryption keys. Confuser is one obfuscator that does this.

`--preserve-tokens` preserves all important tokens but will also enable `--preserve-us`, `--preserve-blob` and `--preserve-sig-data`.

If it's detected as an unknown (unsupported) obfuscator (or if you force it with `-p un`), all tokens are preserved, including the #US heap and any extra data at the end of signatures. Also, no obfuscator types, fields or methods are removed.

Preserve all important tokens, #US, #Blob, extra sig data.

    de4dot --preserve-tokens file1.dll

Preserve all important tokens, #US, #Blob, extra sig data and don't remove types/fields added by the obfuscator

    de4dot --keep-types --preserve-tokens file1.dll

Preserve all important tokens, #US, #Blob, extra sig data and don't create extra Param rows to prevent the ParamPtr table from being created.

    de4dot --dont-create-params --preserve-tokens file1.dll

Preserve all important tokens except the Param tokens.

    de4dot --preserve-table all,-pd file1.dll

Dynamically decrypting strings
------------------------------

Although `de4dot` supports a lot of obfuscators, there's still some it doesn't support. To decrypt strings, you'll first need to figure out which method or methods decrypt strings. To get the method token of these string decrypters, you can use ILDASM with the 'show metadata tokens' option enabled. A method token is a 32-bit number and begins with 06, eg. 06012345.

This command will load assembly file1.dll into memory by calling `Assembly.Load()`. When it detects calls to the two string decrypters (06012345 and 060ABCDE), it will call them by creating a dynamic method, and save the result (the decrypted string). The call to the string decrypter will be removed and the decrypted string will be in its place.

    de4dot file1.dll --strtyp delegate --strtok 06012345 --strtok 060ABCDE

Since the assembly is loaded and executed, make sure you run this in a sandbox if you suspect the file to be malware.

Forcing detection of a certain obfuscator
-----------------------------------------

`de4dot` isn't perfect. If it fails to detect an obfuscator, you can use the `-p` option to force it to assume it's been obfuscated by it.

Force SmartAssembly

    de4dot file1.dll -p sa

Force unsupported obfuscator

    de4dot file1.dll -p un

For other obfuscator types, see the help screen.

Disabling symbol renaming
-------------------------

Renaming symbols isn't as easy as renaming A to B when reflection is involved. `de4dot` currently doesn't support renaming XAML so if you suspect that it uses WPF (or if it's a Silverlight app) you should disable renaming if the assembly fails to run.

    de4dot --dont-rename file1.dll file2.dll

`--keep-names` can also be used to tell `de4dot` not to rename certain symbols, eg. "don't rename fields".

Rename everything that should be renamed except properties, events and methods.

    de4dot --keep-names pem file1.dll

Using a different rename regex
------------------------------

The default regexes should be enough, except possibly the one that is used when an unsupported obfuscator is detected. To see all default regexes, start `de4dot` without any arguments and it will list all options and all default values.

Eg., currently the following is the default regex used when Dotfuscator is detected

    !^[a-z][a-z0-9]{0,2}$&!^A_[0-9]+$&^[\u2E80-\u9FFFa-zA-Z_<{$][\u2E80-\u9FFFa-zA-Z_0-9<>{}$.`-]*$

As you can see, it's not just one regex, it's more than one. Each one is separated by `&` and each regex can be negated by using `!` in front of it. To show it more clearly, these regexes are used:

    (negated) ^[a-z][a-z0-9]{0,2}$
    (negated) ^A_[0-9]+$
    ^[\u2E80-\u9FFFa-zA-Z_<{$][\u2E80-\u9FFFa-zA-Z_0-9<>{}$.`-]*$

To change the regex(es), you must know the short type name of the obfuscator (see help screen). Eg. it's `sa` if it's SmartAssembly, and `un` if it's an unsupported/unknown obfuscator. The option to use is `--TYPE-name` (eg. `--sa-name` for SmartAssembly and `--un-name` for unknown/unsupported obfuscators):

    de4dot --un-name "^[a-zA-Z]\w*$" file1.dll

Other options
-------------

Start `de4dot` without any arguments and it will show all options.



================================================
File: COPYING
================================================
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<http://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<http://www.gnu.org/philosophy/why-not-lgpl.html>.



================================================
File: De4DotCommon.props
================================================
<Project>

  <PropertyGroup>
    <De4DotNetFramework>false</De4DotNetFramework>
    <De4DotNetFramework Condition=" '$(SolutionName)' == 'de4dot.netframework' ">true</De4DotNetFramework>
    <!-- Two different sln files are used because some of the projects are only available when targetting .NET Framework -->
    <TargetFrameworks Condition=" '$(De4DotNetFramework)' == 'true' ">net35;net45</TargetFrameworks>
    <TargetFrameworks Condition=" '$(De4DotNetFramework)' != 'true' ">netcoreapp3.1;netcoreapp2.1</TargetFrameworks>
    <Features>strict</Features>
    <LangVersion>latest</LangVersion>
    <SignAssembly>true</SignAssembly>
    <AssemblyOriginatorKeyFile>$(MSBuildThisFileDirectory)\de4dot.snk</AssemblyOriginatorKeyFile>
    <Version>3.1.41592.3405</Version>
    <Copyright>Copyright (C) 2011-2018 de4dot@gmail.com</Copyright>
    <OutputPath>$(MSBuildThisFileDirectory)\$(Configuration)</OutputPath>

    <DnlibVersion>3.3.2</DnlibVersion>
  </PropertyGroup>

</Project>



================================================
File: LICENSE.ICSharpCode.SharpZipLib.txt
================================================
<LICENSE>
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
//
// Linking this library statically or dynamically with other modules is
// making a combined work based on this library.  Thus, the terms and
// conditions of the GNU General Public License cover the whole
// combination.
// 
// As a special exception, the copyright holders of this library give you
// permission to link this library with independent modules to produce an
// executable, regardless of the license terms of these independent
// modules, and to copy and distribute the resulting executable under
// terms of your choice, provided that you also meet, for each linked
// independent module, the terms and conditions of the license of that
// module.  An independent module is a module which is not derived from
// or based on this library.  If you modify this library, you may extend
// this exception to your version of the library, but you are not
// obligated to do so.  If you do not wish to do so, delete this
// exception statement from your version.
</LICENSE>

Official site: http://www.icsharpcode.net/opensource/sharpziplib/



================================================
File: LICENSE.QuickLZ.txt
================================================
<LICENSE>
// QuickLZ data compression library
// Copyright (C) 2006-2011 Lasse Mikkel Reinhold
// lar@quicklz.com
//
// QuickLZ can be used for free under the GPL 1, 2 or 3 license (where anything 
// released into public must be open source) or under a commercial license if such 
// has been acquired (see http://www.quicklz.com/order.html). The commercial license 
// does not cover derived or ported versions created by third parties under GPL.
</LICENSE>



================================================
File: LICENSE.de4dot.txt
================================================
<LICENSE>
    Copyright (C) 2011-2014 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
</LICENSE>

Official site: https://github.com/0xd4d/de4dot

See the file COPYING for more details.



================================================
File: LICENSE.dnlib.txt
================================================
<LICENSE>
    Copyright (C) 2012-2019 de4dot@gmail.com

    Permission is hereby granted, free of charge, to any person obtaining
    a copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject to
    the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</LICENSE>

Official site: https://github.com/0xd4d/dnlib



================================================
File: LICENSE.lzma.txt
================================================
<LICENSE>
LICENSE
-------

LZMA SDK is written and placed in the public domain by Igor Pavlov.

Some code in LZMA SDK is based on public domain code from another developers:
  1) PPMd var.H (2001): Dmitry Shkarin
  2) SHA-256: Wei Dai (Crypto++ library)

You can copy, modify, distribute and perform LZMA SDK code, even for commercial purposes,
all without asking permission.

LZMA SDK code is compatible with open source licenses, for example, you can
include it to GNU GPL or GNU LGPL code.
</LICENSE>

http://www.7-zip.org/sdk.html
http://downloads.sourceforge.net/sevenzip/lzma922.tar.bz2



================================================
File: LICENSE.lzmat.txt
================================================
<LICENSE>
***************************************************************************
** LZMAT ANSI-C decoder 1.01
** Copyright (C) 2007,2008 Vitaly Evseenko. All Rights Reserved.
** lzmat_dec.c
**
** This file is part of the LZMAT real-time data compression library.
**
** The LZMAT library is free software; you can redistribute it and/or
** modify it under the terms of the GNU General Public License as
** published by the Free Software Foundation; either version 2 of
** the License, or (at your option) any later version.
**
** The LZMAT library is distributed WITHOUT ANY WARRANTY;
** without even the implied warranty of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
** License for more details.
**
** You should have received a copy of the GNU General Public License
** along with the LZMAT library; see the file GPL.TXT.
** If not, write to the Free Software Foundation, Inc.,
** 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
**
** Vitaly Evseenko
** <ve@matcode.com>
** http://www.matcode.com/lzmat.htm
***************************************************************************
</LICENSE>



================================================
File: LICENSE.randomc.txt
================================================
<LICENSE>
* Copyright 2001-2008 by Agner Fog.
* GNU General Public License http://www.gnu.org/licenses/gpl.html
</LICENSE>


See these links for the original C++ code:
	http://www.agner.org/random/
	http://www.agner.org/random/randomc.zip



================================================
File: build.ps1
================================================
$ErrorActionPreference = 'Stop'

#
# dotnet build isn't used because it can't build net35 tfms
#

msbuild -v:m -restore -t:Build -p:Configuration=Release -p:TargetFramework=net35 de4dot.netframework.sln
if ($LASTEXITCODE) { exit $LASTEXITCODE }
Remove-Item Release\net35\*.pdb, Release\net35\*.xml, Release\net35\Test.Rename.*

msbuild -v:m -restore -t:Build -p:Configuration=Release -p:TargetFramework=net45 de4dot.netframework.sln
if ($LASTEXITCODE) { exit $LASTEXITCODE }
Remove-Item Release\net45\*.pdb, Release\net45\*.xml, Release\net45\Test.Rename.*

dotnet publish -c Release -f netcoreapp2.1 -o publish-netcoreapp2.1 de4dot
if ($LASTEXITCODE) { exit $LASTEXITCODE }
Remove-Item publish-netcoreapp2.1\*.pdb, publish-netcoreapp2.1\*.xml

dotnet publish -c Release -f netcoreapp3.1 -o publish-netcoreapp3.1 de4dot
if ($LASTEXITCODE) { exit $LASTEXITCODE }
Remove-Item publish-netcoreapp3.1\*.pdb, publish-netcoreapp3.1\*.xml



================================================
File: de4dot.netcore.sln
================================================
ï»¿
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.26228.4
MinimumVisualStudioVersion = 15.0.26206.0
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "de4dot.code", "de4dot.code\de4dot.code.csproj", "{4D10B9EB-3BF1-4D61-A389-CB019E8C9622}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Test.Rename", "Test.Rename\Test.Rename.csproj", "{3FEB2023-B4B0-4DF3-BECF-AD727B55FF37}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Test.Rename.Dll", "Test.Rename.Dll\Test.Rename.Dll.csproj", "{3B408415-5203-4618-ABC1-F88D0BBE849B}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "AssemblyData", "AssemblyData\AssemblyData.csproj", "{FBD84077-9D35-41FE-89DF-8D79EFE0B595}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "de4dot", "de4dot\de4dot.csproj", "{004EB657-252C-4361-A2D2-2E514130C7FC}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "de4dot.blocks", "de4dot.blocks\de4dot.blocks.csproj", "{045B96F2-AF80-4C4C-8D27-E38635AC705E}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "de4dot.cui", "de4dot.cui\de4dot.cui.csproj", "{879E4A7E-C320-42D2-8275-4F1E44CE64AA}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "de4dot.mdecrypt", "de4dot.mdecrypt\de4dot.mdecrypt.csproj", "{5C93C5E2-196F-4877-BF65-96FEBFCEFCA1}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Debug|Mixed Platforms = Debug|Mixed Platforms
		Debug|Win32 = Debug|Win32
		Debug|x86 = Debug|x86
		Release|Any CPU = Release|Any CPU
		Release|Mixed Platforms = Release|Mixed Platforms
		Release|Win32 = Release|Win32
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{4D10B9EB-3BF1-4D61-A389-CB019E8C9622}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{4D10B9EB-3BF1-4D61-A389-CB019E8C9622}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{4D10B9EB-3BF1-4D61-A389-CB019E8C9622}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
		{4D10B9EB-3BF1-4D61-A389-CB019E8C9622}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
		{4D10B9EB-3BF1-4D61-A389-CB019E8C9622}.Debug|Win32.ActiveCfg = Debug|Any CPU
		{4D10B9EB-3BF1-4D61-A389-CB019E8C9622}.Debug|x86.ActiveCfg = Debug|Any CPU
		{4D10B9EB-3BF1-4D61-A389-CB019E8C9622}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{4D10B9EB-3BF1-4D61-A389-CB019E8C9622}.Release|Any CPU.Build.0 = Release|Any CPU
		{4D10B9EB-3BF1-4D61-A389-CB019E8C9622}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{4D10B9EB-3BF1-4D61-A389-CB019E8C9622}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{4D10B9EB-3BF1-4D61-A389-CB019E8C9622}.Release|Win32.ActiveCfg = Release|Any CPU
		{4D10B9EB-3BF1-4D61-A389-CB019E8C9622}.Release|x86.ActiveCfg = Release|Any CPU
		{3FEB2023-B4B0-4DF3-BECF-AD727B55FF37}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{3FEB2023-B4B0-4DF3-BECF-AD727B55FF37}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{3FEB2023-B4B0-4DF3-BECF-AD727B55FF37}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
		{3FEB2023-B4B0-4DF3-BECF-AD727B55FF37}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
		{3FEB2023-B4B0-4DF3-BECF-AD727B55FF37}.Debug|Win32.ActiveCfg = Debug|Any CPU
		{3FEB2023-B4B0-4DF3-BECF-AD727B55FF37}.Debug|x86.ActiveCfg = Debug|Any CPU
		{3FEB2023-B4B0-4DF3-BECF-AD727B55FF37}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{3FEB2023-B4B0-4DF3-BECF-AD727B55FF37}.Release|Any CPU.Build.0 = Release|Any CPU
		{3FEB2023-B4B0-4DF3-BECF-AD727B55FF37}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{3FEB2023-B4B0-4DF3-BECF-AD727B55FF37}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{3FEB2023-B4B0-4DF3-BECF-AD727B55FF37}.Release|Win32.ActiveCfg = Release|Any CPU
		{3FEB2023-B4B0-4DF3-BECF-AD727B55FF37}.Release|x86.ActiveCfg = Release|Any CPU
		{3B408415-5203-4618-ABC1-F88D0BBE849B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{3B408415-5203-4618-ABC1-F88D0BBE849B}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{3B408415-5203-4618-ABC1-F88D0BBE849B}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
		{3B408415-5203-4618-ABC1-F88D0BBE849B}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
		{3B408415-5203-4618-ABC1-F88D0BBE849B}.Debug|Win32.ActiveCfg = Debug|Any CPU
		{3B408415-5203-4618-ABC1-F88D0BBE849B}.Debug|x86.ActiveCfg = Debug|Any CPU
		{3B408415-5203-4618-ABC1-F88D0BBE849B}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{3B408415-5203-4618-ABC1-F88D0BBE849B}.Release|Any CPU.Build.0 = Release|Any CPU
		{3B408415-5203-4618-ABC1-F88D0BBE849B}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{3B408415-5203-4618-ABC1-F88D0BBE849B}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{3B408415-5203-4618-ABC1-F88D0BBE849B}.Release|Win32.ActiveCfg = Release|Any CPU
		{3B408415-5203-4618-ABC1-F88D0BBE849B}.Release|x86.ActiveCfg = Release|Any CPU
		{FBD84077-9D35-41FE-89DF-8D79EFE0B595}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{FBD84077-9D35-41FE-89DF-8D79EFE0B595}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{FBD84077-9D35-41FE-89DF-8D79EFE0B595}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
		{FBD84077-9D35-41FE-89DF-8D79EFE0B595}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
		{FBD84077-9D35-41FE-89DF-8D79EFE0B595}.Debug|Win32.ActiveCfg = Debug|Any CPU
		{FBD84077-9D35-41FE-89DF-8D79EFE0B595}.Debug|Win32.Build.0 = Debug|Any CPU
		{FBD84077-9D35-41FE-89DF-8D79EFE0B595}.Debug|x86.ActiveCfg = Debug|Any CPU
		{FBD84077-9D35-41FE-89DF-8D79EFE0B595}.Debug|x86.Build.0 = Debug|Any CPU
		{FBD84077-9D35-41FE-89DF-8D79EFE0B595}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{FBD84077-9D35-41FE-89DF-8D79EFE0B595}.Release|Any CPU.Build.0 = Release|Any CPU
		{FBD84077-9D35-41FE-89DF-8D79EFE0B595}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{FBD84077-9D35-41FE-89DF-8D79EFE0B595}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{FBD84077-9D35-41FE-89DF-8D79EFE0B595}.Release|Win32.ActiveCfg = Release|Any CPU
		{FBD84077-9D35-41FE-89DF-8D79EFE0B595}.Release|Win32.Build.0 = Release|Any CPU
		{FBD84077-9D35-41FE-89DF-8D79EFE0B595}.Release|x86.ActiveCfg = Release|Any CPU
		{FBD84077-9D35-41FE-89DF-8D79EFE0B595}.Release|x86.Build.0 = Release|Any CPU
		{004EB657-252C-4361-A2D2-2E514130C7FC}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{004EB657-252C-4361-A2D2-2E514130C7FC}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{004EB657-252C-4361-A2D2-2E514130C7FC}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
		{004EB657-252C-4361-A2D2-2E514130C7FC}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
		{004EB657-252C-4361-A2D2-2E514130C7FC}.Debug|Win32.ActiveCfg = Debug|Any CPU
		{004EB657-252C-4361-A2D2-2E514130C7FC}.Debug|Win32.Build.0 = Debug|Any CPU
		{004EB657-252C-4361-A2D2-2E514130C7FC}.Debug|x86.ActiveCfg = Debug|Any CPU
		{004EB657-252C-4361-A2D2-2E514130C7FC}.Debug|x86.Build.0 = Debug|Any CPU
		{004EB657-252C-4361-A2D2-2E514130C7FC}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{004EB657-252C-4361-A2D2-2E514130C7FC}.Release|Any CPU.Build.0 = Release|Any CPU
		{004EB657-252C-4361-A2D2-2E514130C7FC}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{004EB657-252C-4361-A2D2-2E514130C7FC}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{004EB657-252C-4361-A2D2-2E514130C7FC}.Release|Win32.ActiveCfg = Release|Any CPU
		{004EB657-252C-4361-A2D2-2E514130C7FC}.Release|Win32.Build.0 = Release|Any CPU
		{004EB657-252C-4361-A2D2-2E514130C7FC}.Release|x86.ActiveCfg = Release|Any CPU
		{004EB657-252C-4361-A2D2-2E514130C7FC}.Release|x86.Build.0 = Release|Any CPU
		{045B96F2-AF80-4C4C-8D27-E38635AC705E}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{045B96F2-AF80-4C4C-8D27-E38635AC705E}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{045B96F2-AF80-4C4C-8D27-E38635AC705E}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
		{045B96F2-AF80-4C4C-8D27-E38635AC705E}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
		{045B96F2-AF80-4C4C-8D27-E38635AC705E}.Debug|Win32.ActiveCfg = Debug|Any CPU
		{045B96F2-AF80-4C4C-8D27-E38635AC705E}.Debug|x86.ActiveCfg = Debug|Any CPU
		{045B96F2-AF80-4C4C-8D27-E38635AC705E}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{045B96F2-AF80-4C4C-8D27-E38635AC705E}.Release|Any CPU.Build.0 = Release|Any CPU
		{045B96F2-AF80-4C4C-8D27-E38635AC705E}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{045B96F2-AF80-4C4C-8D27-E38635AC705E}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{045B96F2-AF80-4C4C-8D27-E38635AC705E}.Release|Win32.ActiveCfg = Release|Any CPU
		{045B96F2-AF80-4C4C-8D27-E38635AC705E}.Release|x86.ActiveCfg = Release|Any CPU
		{879E4A7E-C320-42D2-8275-4F1E44CE64AA}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{879E4A7E-C320-42D2-8275-4F1E44CE64AA}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{879E4A7E-C320-42D2-8275-4F1E44CE64AA}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
		{879E4A7E-C320-42D2-8275-4F1E44CE64AA}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
		{879E4A7E-C320-42D2-8275-4F1E44CE64AA}.Debug|Win32.ActiveCfg = Debug|Any CPU
		{879E4A7E-C320-42D2-8275-4F1E44CE64AA}.Debug|x86.ActiveCfg = Debug|Any CPU
		{879E4A7E-C320-42D2-8275-4F1E44CE64AA}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{879E4A7E-C320-42D2-8275-4F1E44CE64AA}.Release|Any CPU.Build.0 = Release|Any CPU
		{879E4A7E-C320-42D2-8275-4F1E44CE64AA}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{879E4A7E-C320-42D2-8275-4F1E44CE64AA}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{879E4A7E-C320-42D2-8275-4F1E44CE64AA}.Release|Win32.ActiveCfg = Release|Any CPU
		{879E4A7E-C320-42D2-8275-4F1E44CE64AA}.Release|x86.ActiveCfg = Release|Any CPU
		{5C93C5E2-196F-4877-BF65-96FEBFCEFCA1}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{5C93C5E2-196F-4877-BF65-96FEBFCEFCA1}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{5C93C5E2-196F-4877-BF65-96FEBFCEFCA1}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
		{5C93C5E2-196F-4877-BF65-96FEBFCEFCA1}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
		{5C93C5E2-196F-4877-BF65-96FEBFCEFCA1}.Debug|Win32.ActiveCfg = Debug|Any CPU
		{5C93C5E2-196F-4877-BF65-96FEBFCEFCA1}.Debug|x86.ActiveCfg = Debug|Any CPU
		{5C93C5E2-196F-4877-BF65-96FEBFCEFCA1}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{5C93C5E2-196F-4877-BF65-96FEBFCEFCA1}.Release|Any CPU.Build.0 = Release|Any CPU
		{5C93C5E2-196F-4877-BF65-96FEBFCEFCA1}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{5C93C5E2-196F-4877-BF65-96FEBFCEFCA1}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{5C93C5E2-196F-4877-BF65-96FEBFCEFCA1}.Release|Win32.ActiveCfg = Release|Any CPU
		{5C93C5E2-196F-4877-BF65-96FEBFCEFCA1}.Release|x86.ActiveCfg = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {9FACD7D2-CFD5-4E9E-A9D1-48B71319A5A4}
	EndGlobalSection
EndGlobal



================================================
File: de4dot.netframework.sln
================================================
ï»¿
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.26228.4
MinimumVisualStudioVersion = 15.0.26206.0
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "de4dot.code", "de4dot.code\de4dot.code.csproj", "{4D10B9EB-3BF1-4D61-A389-CB019E8C9622}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Test.Rename", "Test.Rename\Test.Rename.csproj", "{3FEB2023-B4B0-4DF3-BECF-AD727B55FF37}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Test.Rename.Dll", "Test.Rename.Dll\Test.Rename.Dll.csproj", "{3B408415-5203-4618-ABC1-F88D0BBE849B}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "AssemblyData", "AssemblyData\AssemblyData.csproj", "{FBD84077-9D35-41FE-89DF-8D79EFE0B595}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "de4dot", "de4dot\de4dot.csproj", "{004EB657-252C-4361-A2D2-2E514130C7FC}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "de4dot-x64", "de4dot-x64\de4dot-x64.csproj", "{A9F35AC2-D016-444B-B7E6-FC1D55569021}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "AssemblyServer", "AssemblyServer\AssemblyServer.csproj", "{593AB87D-7B92-47CF-8201-3574CF6A6457}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "AssemblyServer-x64", "AssemblyServer-x64\AssemblyServer-x64.csproj", "{F458A89A-AEAB-4965-AA4D-393C9F7411D0}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "de4dot.blocks", "de4dot.blocks\de4dot.blocks.csproj", "{045B96F2-AF80-4C4C-8D27-E38635AC705E}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "de4dot.cui", "de4dot.cui\de4dot.cui.csproj", "{879E4A7E-C320-42D2-8275-4F1E44CE64AA}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "de4dot.mdecrypt", "de4dot.mdecrypt\de4dot.mdecrypt.csproj", "{5C93C5E2-196F-4877-BF65-96FEBFCEFCA1}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "AssemblyServer-CLR20", "AssemblyServer-CLR20\AssemblyServer-CLR20.csproj", "{C72DC899-1760-432B-B429-3CD88B669A6A}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "AssemblyServer-CLR20-x64", "AssemblyServer-CLR20-x64\AssemblyServer-CLR20-x64.csproj", "{9F84607D-3662-4CF2-BA40-8BDB11935643}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "AssemblyServer-CLR40", "AssemblyServer-CLR40\AssemblyServer-CLR40.csproj", "{B8FF4ADD-BAD8-47FD-B126-63234E2BB0B3}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "AssemblyServer-CLR40-x64", "AssemblyServer-CLR40-x64\AssemblyServer-CLR40-x64.csproj", "{A0F58B9F-BB56-4D9B-B04A-726F9E7961EB}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Debug|Mixed Platforms = Debug|Mixed Platforms
		Debug|Win32 = Debug|Win32
		Debug|x86 = Debug|x86
		Release|Any CPU = Release|Any CPU
		Release|Mixed Platforms = Release|Mixed Platforms
		Release|Win32 = Release|Win32
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{4D10B9EB-3BF1-4D61-A389-CB019E8C9622}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{4D10B9EB-3BF1-4D61-A389-CB019E8C9622}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{4D10B9EB-3BF1-4D61-A389-CB019E8C9622}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
		{4D10B9EB-3BF1-4D61-A389-CB019E8C9622}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
		{4D10B9EB-3BF1-4D61-A389-CB019E8C9622}.Debug|Win32.ActiveCfg = Debug|Any CPU
		{4D10B9EB-3BF1-4D61-A389-CB019E8C9622}.Debug|x86.ActiveCfg = Debug|Any CPU
		{4D10B9EB-3BF1-4D61-A389-CB019E8C9622}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{4D10B9EB-3BF1-4D61-A389-CB019E8C9622}.Release|Any CPU.Build.0 = Release|Any CPU
		{4D10B9EB-3BF1-4D61-A389-CB019E8C9622}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{4D10B9EB-3BF1-4D61-A389-CB019E8C9622}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{4D10B9EB-3BF1-4D61-A389-CB019E8C9622}.Release|Win32.ActiveCfg = Release|Any CPU
		{4D10B9EB-3BF1-4D61-A389-CB019E8C9622}.Release|x86.ActiveCfg = Release|Any CPU
		{3FEB2023-B4B0-4DF3-BECF-AD727B55FF37}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{3FEB2023-B4B0-4DF3-BECF-AD727B55FF37}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{3FEB2023-B4B0-4DF3-BECF-AD727B55FF37}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
		{3FEB2023-B4B0-4DF3-BECF-AD727B55FF37}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
		{3FEB2023-B4B0-4DF3-BECF-AD727B55FF37}.Debug|Win32.ActiveCfg = Debug|Any CPU
		{3FEB2023-B4B0-4DF3-BECF-AD727B55FF37}.Debug|x86.ActiveCfg = Debug|Any CPU
		{3FEB2023-B4B0-4DF3-BECF-AD727B55FF37}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{3FEB2023-B4B0-4DF3-BECF-AD727B55FF37}.Release|Any CPU.Build.0 = Release|Any CPU
		{3FEB2023-B4B0-4DF3-BECF-AD727B55FF37}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{3FEB2023-B4B0-4DF3-BECF-AD727B55FF37}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{3FEB2023-B4B0-4DF3-BECF-AD727B55FF37}.Release|Win32.ActiveCfg = Release|Any CPU
		{3FEB2023-B4B0-4DF3-BECF-AD727B55FF37}.Release|x86.ActiveCfg = Release|Any CPU
		{3B408415-5203-4618-ABC1-F88D0BBE849B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{3B408415-5203-4618-ABC1-F88D0BBE849B}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{3B408415-5203-4618-ABC1-F88D0BBE849B}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
		{3B408415-5203-4618-ABC1-F88D0BBE849B}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
		{3B408415-5203-4618-ABC1-F88D0BBE849B}.Debug|Win32.ActiveCfg = Debug|Any CPU
		{3B408415-5203-4618-ABC1-F88D0BBE849B}.Debug|x86.ActiveCfg = Debug|Any CPU
		{3B408415-5203-4618-ABC1-F88D0BBE849B}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{3B408415-5203-4618-ABC1-F88D0BBE849B}.Release|Any CPU.Build.0 = Release|Any CPU
		{3B408415-5203-4618-ABC1-F88D0BBE849B}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{3B408415-5203-4618-ABC1-F88D0BBE849B}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{3B408415-5203-4618-ABC1-F88D0BBE849B}.Release|Win32.ActiveCfg = Release|Any CPU
		{3B408415-5203-4618-ABC1-F88D0BBE849B}.Release|x86.ActiveCfg = Release|Any CPU
		{FBD84077-9D35-41FE-89DF-8D79EFE0B595}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{FBD84077-9D35-41FE-89DF-8D79EFE0B595}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{FBD84077-9D35-41FE-89DF-8D79EFE0B595}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
		{FBD84077-9D35-41FE-89DF-8D79EFE0B595}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
		{FBD84077-9D35-41FE-89DF-8D79EFE0B595}.Debug|Win32.ActiveCfg = Debug|Any CPU
		{FBD84077-9D35-41FE-89DF-8D79EFE0B595}.Debug|x86.ActiveCfg = Debug|Any CPU
		{FBD84077-9D35-41FE-89DF-8D79EFE0B595}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{FBD84077-9D35-41FE-89DF-8D79EFE0B595}.Release|Any CPU.Build.0 = Release|Any CPU
		{FBD84077-9D35-41FE-89DF-8D79EFE0B595}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{FBD84077-9D35-41FE-89DF-8D79EFE0B595}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{FBD84077-9D35-41FE-89DF-8D79EFE0B595}.Release|Win32.ActiveCfg = Release|Any CPU
		{FBD84077-9D35-41FE-89DF-8D79EFE0B595}.Release|x86.ActiveCfg = Release|Any CPU
		{004EB657-252C-4361-A2D2-2E514130C7FC}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{004EB657-252C-4361-A2D2-2E514130C7FC}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{004EB657-252C-4361-A2D2-2E514130C7FC}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
		{004EB657-252C-4361-A2D2-2E514130C7FC}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
		{004EB657-252C-4361-A2D2-2E514130C7FC}.Debug|Win32.ActiveCfg = Debug|Any CPU
		{004EB657-252C-4361-A2D2-2E514130C7FC}.Debug|Win32.Build.0 = Debug|Any CPU
		{004EB657-252C-4361-A2D2-2E514130C7FC}.Debug|x86.ActiveCfg = Debug|Any CPU
		{004EB657-252C-4361-A2D2-2E514130C7FC}.Debug|x86.Build.0 = Debug|Any CPU
		{004EB657-252C-4361-A2D2-2E514130C7FC}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{004EB657-252C-4361-A2D2-2E514130C7FC}.Release|Any CPU.Build.0 = Release|Any CPU
		{004EB657-252C-4361-A2D2-2E514130C7FC}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{004EB657-252C-4361-A2D2-2E514130C7FC}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{004EB657-252C-4361-A2D2-2E514130C7FC}.Release|Win32.ActiveCfg = Release|Any CPU
		{004EB657-252C-4361-A2D2-2E514130C7FC}.Release|Win32.Build.0 = Release|Any CPU
		{004EB657-252C-4361-A2D2-2E514130C7FC}.Release|x86.ActiveCfg = Release|Any CPU
		{004EB657-252C-4361-A2D2-2E514130C7FC}.Release|x86.Build.0 = Release|Any CPU
		{A9F35AC2-D016-444B-B7E6-FC1D55569021}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{A9F35AC2-D016-444B-B7E6-FC1D55569021}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{A9F35AC2-D016-444B-B7E6-FC1D55569021}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
		{A9F35AC2-D016-444B-B7E6-FC1D55569021}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
		{A9F35AC2-D016-444B-B7E6-FC1D55569021}.Debug|Win32.ActiveCfg = Debug|Any CPU
		{A9F35AC2-D016-444B-B7E6-FC1D55569021}.Debug|Win32.Build.0 = Debug|Any CPU
		{A9F35AC2-D016-444B-B7E6-FC1D55569021}.Debug|x86.ActiveCfg = Debug|Any CPU
		{A9F35AC2-D016-444B-B7E6-FC1D55569021}.Debug|x86.Build.0 = Debug|Any CPU
		{A9F35AC2-D016-444B-B7E6-FC1D55569021}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{A9F35AC2-D016-444B-B7E6-FC1D55569021}.Release|Any CPU.Build.0 = Release|Any CPU
		{A9F35AC2-D016-444B-B7E6-FC1D55569021}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{A9F35AC2-D016-444B-B7E6-FC1D55569021}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{A9F35AC2-D016-444B-B7E6-FC1D55569021}.Release|Win32.ActiveCfg = Release|Any CPU
		{A9F35AC2-D016-444B-B7E6-FC1D55569021}.Release|Win32.Build.0 = Release|Any CPU
		{A9F35AC2-D016-444B-B7E6-FC1D55569021}.Release|x86.ActiveCfg = Release|Any CPU
		{A9F35AC2-D016-444B-B7E6-FC1D55569021}.Release|x86.Build.0 = Release|Any CPU
		{593AB87D-7B92-47CF-8201-3574CF6A6457}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{593AB87D-7B92-47CF-8201-3574CF6A6457}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{593AB87D-7B92-47CF-8201-3574CF6A6457}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
		{593AB87D-7B92-47CF-8201-3574CF6A6457}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
		{593AB87D-7B92-47CF-8201-3574CF6A6457}.Debug|Win32.ActiveCfg = Debug|Any CPU
		{593AB87D-7B92-47CF-8201-3574CF6A6457}.Debug|Win32.Build.0 = Debug|Any CPU
		{593AB87D-7B92-47CF-8201-3574CF6A6457}.Debug|x86.ActiveCfg = Debug|Any CPU
		{593AB87D-7B92-47CF-8201-3574CF6A6457}.Debug|x86.Build.0 = Debug|Any CPU
		{593AB87D-7B92-47CF-8201-3574CF6A6457}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{593AB87D-7B92-47CF-8201-3574CF6A6457}.Release|Any CPU.Build.0 = Release|Any CPU
		{593AB87D-7B92-47CF-8201-3574CF6A6457}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{593AB87D-7B92-47CF-8201-3574CF6A6457}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{593AB87D-7B92-47CF-8201-3574CF6A6457}.Release|Win32.ActiveCfg = Release|Any CPU
		{593AB87D-7B92-47CF-8201-3574CF6A6457}.Release|Win32.Build.0 = Release|Any CPU
		{593AB87D-7B92-47CF-8201-3574CF6A6457}.Release|x86.ActiveCfg = Release|Any CPU
		{593AB87D-7B92-47CF-8201-3574CF6A6457}.Release|x86.Build.0 = Release|Any CPU
		{F458A89A-AEAB-4965-AA4D-393C9F7411D0}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{F458A89A-AEAB-4965-AA4D-393C9F7411D0}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{F458A89A-AEAB-4965-AA4D-393C9F7411D0}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
		{F458A89A-AEAB-4965-AA4D-393C9F7411D0}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
		{F458A89A-AEAB-4965-AA4D-393C9F7411D0}.Debug|Win32.ActiveCfg = Debug|Any CPU
		{F458A89A-AEAB-4965-AA4D-393C9F7411D0}.Debug|Win32.Build.0 = Debug|Any CPU
		{F458A89A-AEAB-4965-AA4D-393C9F7411D0}.Debug|x86.ActiveCfg = Debug|Any CPU
		{F458A89A-AEAB-4965-AA4D-393C9F7411D0}.Debug|x86.Build.0 = Debug|Any CPU
		{F458A89A-AEAB-4965-AA4D-393C9F7411D0}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{F458A89A-AEAB-4965-AA4D-393C9F7411D0}.Release|Any CPU.Build.0 = Release|Any CPU
		{F458A89A-AEAB-4965-AA4D-393C9F7411D0}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{F458A89A-AEAB-4965-AA4D-393C9F7411D0}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{F458A89A-AEAB-4965-AA4D-393C9F7411D0}.Release|Win32.ActiveCfg = Release|Any CPU
		{F458A89A-AEAB-4965-AA4D-393C9F7411D0}.Release|Win32.Build.0 = Release|Any CPU
		{F458A89A-AEAB-4965-AA4D-393C9F7411D0}.Release|x86.ActiveCfg = Release|Any CPU
		{F458A89A-AEAB-4965-AA4D-393C9F7411D0}.Release|x86.Build.0 = Release|Any CPU
		{045B96F2-AF80-4C4C-8D27-E38635AC705E}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{045B96F2-AF80-4C4C-8D27-E38635AC705E}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{045B96F2-AF80-4C4C-8D27-E38635AC705E}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
		{045B96F2-AF80-4C4C-8D27-E38635AC705E}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
		{045B96F2-AF80-4C4C-8D27-E38635AC705E}.Debug|Win32.ActiveCfg = Debug|Any CPU
		{045B96F2-AF80-4C4C-8D27-E38635AC705E}.Debug|x86.ActiveCfg = Debug|Any CPU
		{045B96F2-AF80-4C4C-8D27-E38635AC705E}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{045B96F2-AF80-4C4C-8D27-E38635AC705E}.Release|Any CPU.Build.0 = Release|Any CPU
		{045B96F2-AF80-4C4C-8D27-E38635AC705E}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{045B96F2-AF80-4C4C-8D27-E38635AC705E}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{045B96F2-AF80-4C4C-8D27-E38635AC705E}.Release|Win32.ActiveCfg = Release|Any CPU
		{045B96F2-AF80-4C4C-8D27-E38635AC705E}.Release|x86.ActiveCfg = Release|Any CPU
		{879E4A7E-C320-42D2-8275-4F1E44CE64AA}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{879E4A7E-C320-42D2-8275-4F1E44CE64AA}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{879E4A7E-C320-42D2-8275-4F1E44CE64AA}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
		{879E4A7E-C320-42D2-8275-4F1E44CE64AA}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
		{879E4A7E-C320-42D2-8275-4F1E44CE64AA}.Debug|Win32.ActiveCfg = Debug|Any CPU
		{879E4A7E-C320-42D2-8275-4F1E44CE64AA}.Debug|x86.ActiveCfg = Debug|Any CPU
		{879E4A7E-C320-42D2-8275-4F1E44CE64AA}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{879E4A7E-C320-42D2-8275-4F1E44CE64AA}.Release|Any CPU.Build.0 = Release|Any CPU
		{879E4A7E-C320-42D2-8275-4F1E44CE64AA}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{879E4A7E-C320-42D2-8275-4F1E44CE64AA}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{879E4A7E-C320-42D2-8275-4F1E44CE64AA}.Release|Win32.ActiveCfg = Release|Any CPU
		{879E4A7E-C320-42D2-8275-4F1E44CE64AA}.Release|x86.ActiveCfg = Release|Any CPU
		{5C93C5E2-196F-4877-BF65-96FEBFCEFCA1}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{5C93C5E2-196F-4877-BF65-96FEBFCEFCA1}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{5C93C5E2-196F-4877-BF65-96FEBFCEFCA1}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
		{5C93C5E2-196F-4877-BF65-96FEBFCEFCA1}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
		{5C93C5E2-196F-4877-BF65-96FEBFCEFCA1}.Debug|Win32.ActiveCfg = Debug|Any CPU
		{5C93C5E2-196F-4877-BF65-96FEBFCEFCA1}.Debug|x86.ActiveCfg = Debug|Any CPU
		{5C93C5E2-196F-4877-BF65-96FEBFCEFCA1}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{5C93C5E2-196F-4877-BF65-96FEBFCEFCA1}.Release|Any CPU.Build.0 = Release|Any CPU
		{5C93C5E2-196F-4877-BF65-96FEBFCEFCA1}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{5C93C5E2-196F-4877-BF65-96FEBFCEFCA1}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{5C93C5E2-196F-4877-BF65-96FEBFCEFCA1}.Release|Win32.ActiveCfg = Release|Any CPU
		{5C93C5E2-196F-4877-BF65-96FEBFCEFCA1}.Release|x86.ActiveCfg = Release|Any CPU
		{C72DC899-1760-432B-B429-3CD88B669A6A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{C72DC899-1760-432B-B429-3CD88B669A6A}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{C72DC899-1760-432B-B429-3CD88B669A6A}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
		{C72DC899-1760-432B-B429-3CD88B669A6A}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
		{C72DC899-1760-432B-B429-3CD88B669A6A}.Debug|Win32.ActiveCfg = Debug|Any CPU
		{C72DC899-1760-432B-B429-3CD88B669A6A}.Debug|Win32.Build.0 = Debug|Any CPU
		{C72DC899-1760-432B-B429-3CD88B669A6A}.Debug|x86.ActiveCfg = Debug|Any CPU
		{C72DC899-1760-432B-B429-3CD88B669A6A}.Debug|x86.Build.0 = Debug|Any CPU
		{C72DC899-1760-432B-B429-3CD88B669A6A}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{C72DC899-1760-432B-B429-3CD88B669A6A}.Release|Any CPU.Build.0 = Release|Any CPU
		{C72DC899-1760-432B-B429-3CD88B669A6A}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{C72DC899-1760-432B-B429-3CD88B669A6A}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{C72DC899-1760-432B-B429-3CD88B669A6A}.Release|Win32.ActiveCfg = Release|Any CPU
		{C72DC899-1760-432B-B429-3CD88B669A6A}.Release|Win32.Build.0 = Release|Any CPU
		{C72DC899-1760-432B-B429-3CD88B669A6A}.Release|x86.ActiveCfg = Release|Any CPU
		{C72DC899-1760-432B-B429-3CD88B669A6A}.Release|x86.Build.0 = Release|Any CPU
		{9F84607D-3662-4CF2-BA40-8BDB11935643}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{9F84607D-3662-4CF2-BA40-8BDB11935643}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{9F84607D-3662-4CF2-BA40-8BDB11935643}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
		{9F84607D-3662-4CF2-BA40-8BDB11935643}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
		{9F84607D-3662-4CF2-BA40-8BDB11935643}.Debug|Win32.ActiveCfg = Debug|Any CPU
		{9F84607D-3662-4CF2-BA40-8BDB11935643}.Debug|Win32.Build.0 = Debug|Any CPU
		{9F84607D-3662-4CF2-BA40-8BDB11935643}.Debug|x86.ActiveCfg = Debug|Any CPU
		{9F84607D-3662-4CF2-BA40-8BDB11935643}.Debug|x86.Build.0 = Debug|Any CPU
		{9F84607D-3662-4CF2-BA40-8BDB11935643}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{9F84607D-3662-4CF2-BA40-8BDB11935643}.Release|Any CPU.Build.0 = Release|Any CPU
		{9F84607D-3662-4CF2-BA40-8BDB11935643}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{9F84607D-3662-4CF2-BA40-8BDB11935643}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{9F84607D-3662-4CF2-BA40-8BDB11935643}.Release|Win32.ActiveCfg = Release|Any CPU
		{9F84607D-3662-4CF2-BA40-8BDB11935643}.Release|Win32.Build.0 = Release|Any CPU
		{9F84607D-3662-4CF2-BA40-8BDB11935643}.Release|x86.ActiveCfg = Release|Any CPU
		{9F84607D-3662-4CF2-BA40-8BDB11935643}.Release|x86.Build.0 = Release|Any CPU
		{B8FF4ADD-BAD8-47FD-B126-63234E2BB0B3}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{B8FF4ADD-BAD8-47FD-B126-63234E2BB0B3}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{B8FF4ADD-BAD8-47FD-B126-63234E2BB0B3}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
		{B8FF4ADD-BAD8-47FD-B126-63234E2BB0B3}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
		{B8FF4ADD-BAD8-47FD-B126-63234E2BB0B3}.Debug|Win32.ActiveCfg = Debug|Any CPU
		{B8FF4ADD-BAD8-47FD-B126-63234E2BB0B3}.Debug|Win32.Build.0 = Debug|Any CPU
		{B8FF4ADD-BAD8-47FD-B126-63234E2BB0B3}.Debug|x86.ActiveCfg = Debug|Any CPU
		{B8FF4ADD-BAD8-47FD-B126-63234E2BB0B3}.Debug|x86.Build.0 = Debug|Any CPU
		{B8FF4ADD-BAD8-47FD-B126-63234E2BB0B3}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{B8FF4ADD-BAD8-47FD-B126-63234E2BB0B3}.Release|Any CPU.Build.0 = Release|Any CPU
		{B8FF4ADD-BAD8-47FD-B126-63234E2BB0B3}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{B8FF4ADD-BAD8-47FD-B126-63234E2BB0B3}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{B8FF4ADD-BAD8-47FD-B126-63234E2BB0B3}.Release|Win32.ActiveCfg = Release|Any CPU
		{B8FF4ADD-BAD8-47FD-B126-63234E2BB0B3}.Release|Win32.Build.0 = Release|Any CPU
		{B8FF4ADD-BAD8-47FD-B126-63234E2BB0B3}.Release|x86.ActiveCfg = Release|Any CPU
		{B8FF4ADD-BAD8-47FD-B126-63234E2BB0B3}.Release|x86.Build.0 = Release|Any CPU
		{A0F58B9F-BB56-4D9B-B04A-726F9E7961EB}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{A0F58B9F-BB56-4D9B-B04A-726F9E7961EB}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{A0F58B9F-BB56-4D9B-B04A-726F9E7961EB}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
		{A0F58B9F-BB56-4D9B-B04A-726F9E7961EB}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
		{A0F58B9F-BB56-4D9B-B04A-726F9E7961EB}.Debug|Win32.ActiveCfg = Debug|Any CPU
		{A0F58B9F-BB56-4D9B-B04A-726F9E7961EB}.Debug|Win32.Build.0 = Debug|Any CPU
		{A0F58B9F-BB56-4D9B-B04A-726F9E7961EB}.Debug|x86.ActiveCfg = Debug|Any CPU
		{A0F58B9F-BB56-4D9B-B04A-726F9E7961EB}.Debug|x86.Build.0 = Debug|Any CPU
		{A0F58B9F-BB56-4D9B-B04A-726F9E7961EB}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{A0F58B9F-BB56-4D9B-B04A-726F9E7961EB}.Release|Any CPU.Build.0 = Release|Any CPU
		{A0F58B9F-BB56-4D9B-B04A-726F9E7961EB}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{A0F58B9F-BB56-4D9B-B04A-726F9E7961EB}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{A0F58B9F-BB56-4D9B-B04A-726F9E7961EB}.Release|Win32.ActiveCfg = Release|Any CPU
		{A0F58B9F-BB56-4D9B-B04A-726F9E7961EB}.Release|Win32.Build.0 = Release|Any CPU
		{A0F58B9F-BB56-4D9B-B04A-726F9E7961EB}.Release|x86.ActiveCfg = Release|Any CPU
		{A0F58B9F-BB56-4D9B-B04A-726F9E7961EB}.Release|x86.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {9FACD7D2-CFD5-4E9E-A9D1-48B71319A5A4}
	EndGlobalSection
EndGlobal



================================================
File: de4dot.snk
================================================
[Non-text file]


================================================
File: .editorconfig
================================================
root = true

[*]
charset = utf-8
#end_of_line =
indent_size = 4
indent_style = tab
tab_width = 4

[*.json]

[app.config]

[*.yml]
indent_size = 2
indent_style = space

[*.{proj,csproj,vbproj,props,targets,resx,vsixmanifest}]
indent_size = 2
indent_style = space

[app.manifest]
indent_size = 2
indent_style = space

[*.xml]

[*.xaml]
indent_style = space

[*.{cs,vb}]
insert_final_newline = true

dotnet_separate_import_directive_groups = false
dotnet_sort_system_directives_first = true
dotnet_style_coalesce_expression = true:suggestion
dotnet_style_collection_initializer = true:suggestion
dotnet_style_explicit_tuple_names = true:suggestion
dotnet_style_null_propagation = true:suggestion
dotnet_style_object_initializer = true:suggestion
dotnet_style_predefined_type_for_locals_parameters_members = true:none
dotnet_style_predefined_type_for_member_access = true:none
dotnet_style_prefer_auto_properties = true:suggestion
dotnet_style_prefer_inferred_anonymous_type_member_names = true:suggestion
dotnet_style_prefer_inferred_tuple_names = true:suggestion
dotnet_style_prefer_is_null_check_over_reference_equality_method = false:suggestion
dotnet_style_qualification_for_event = false:suggestion
dotnet_style_qualification_for_field = false:suggestion
dotnet_style_qualification_for_method = false:suggestion
dotnet_style_qualification_for_property = false:suggestion
dotnet_style_require_accessibility_modifiers = never:info

[*.cs]
csharp_indent_block_contents = true
csharp_indent_braces = false
csharp_indent_case_contents = true
csharp_indent_case_contents_when_block = false
csharp_indent_labels = flush_left
csharp_indent_switch_labels = false
csharp_new_line_before_catch = true
csharp_new_line_before_else = true
csharp_new_line_before_finally = true
csharp_new_line_before_members_in_anonymous_types = true
csharp_new_line_before_members_in_object_initializers = true
csharp_new_line_before_open_brace = none
csharp_new_line_between_query_expression_clauses = true
csharp_prefer_braces = false
csharp_prefer_simple_default_expression = true:suggestion
#csharp_preferred_modifier_order =
csharp_preserve_single_line_blocks = true
csharp_preserve_single_line_statements = true
csharp_space_after_cast = false
csharp_space_after_colon_in_inheritance_clause = true
csharp_space_after_comma = true
csharp_space_after_dot = false
csharp_space_after_keywords_in_control_flow_statements = true
csharp_space_after_semicolon_in_for_statement = true
csharp_space_around_binary_operators = before_and_after
csharp_space_around_declaration_statements = false
csharp_space_before_colon_in_inheritance_clause = true
csharp_space_before_comma = false
csharp_space_before_dot = false
csharp_space_before_open_square_brackets = false
csharp_space_before_semicolon_in_for_statement = false
csharp_space_between_empty_square_brackets = false
csharp_space_between_method_call_empty_parameter_list_parentheses = false
csharp_space_between_method_call_name_and_opening_parenthesis = false
csharp_space_between_method_call_parameter_list_parentheses = false
csharp_space_between_method_declaration_empty_parameter_list_parentheses = false
csharp_space_between_method_declaration_name_and_open_parenthesis = false
csharp_space_between_method_declaration_parameter_list_parentheses = false
csharp_space_between_parentheses =
csharp_space_between_square_brackets = false
csharp_style_conditional_delegate_call = true:suggestion
csharp_style_deconstructed_variable_declaration = false:none
csharp_style_expression_bodied_accessors = true:suggestion
csharp_style_expression_bodied_constructors = true:suggestion
csharp_style_expression_bodied_indexers = true:suggestion
csharp_style_expression_bodied_methods = true:suggestion
csharp_style_expression_bodied_operators = true:suggestion
csharp_style_expression_bodied_properties = true:suggestion
csharp_style_inlined_variable_declaration = true:suggestion
csharp_style_pattern_local_over_anonymous_function = true:suggestion
csharp_style_pattern_matching_over_as_with_null_check = true:suggestion
csharp_style_pattern_matching_over_is_with_cast_check = true:suggestion
csharp_style_throw_expression = true:suggestion
csharp_style_var_elsewhere = true:suggestion
csharp_style_var_for_built_in_types = false:none
csharp_style_var_when_type_is_apparent = true:suggestion

[*.vb]
#visual_basic_preferred_modifier_order =



================================================
File: AssemblyData/AssemblyData.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">

  <Import Project="..\De4DotCommon.props" />

  <ItemGroup>
    <Reference Include="System.Runtime.Remoting" Condition=" '$(De4DotNetFramework)' == 'true' " />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\de4dot.blocks\de4dot.blocks.csproj" />
    <ProjectReference Include="..\de4dot.mdecrypt\de4dot.mdecrypt.csproj" />
  </ItemGroup>

</Project>



================================================
File: AssemblyData/AssemblyResolver.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Reflection;
using System.Collections.Generic;
using System.IO;
using System.Xml;

namespace AssemblyData {
	class AssemblyResolver {
		Dictionary<string, Assembly> assemblies = new Dictionary<string, Assembly>(StringComparer.Ordinal);
		Dictionary<string, bool> assemblySearchPathsDict = new Dictionary<string, bool>(StringComparer.OrdinalIgnoreCase);
		List<string> assemblySearchPaths = new List<string>();

		public AssemblyResolver() => AppDomain.CurrentDomain.AssemblyResolve += AssemblyResolve;

		void AddAssemblySearchPath(string path) {
			if (assemblySearchPathsDict.ContainsKey(path))
				return;
			assemblySearchPathsDict[path] = true;
			assemblySearchPaths.Add(path);
		}

		Assembly Get(string assemblyFullName) {
			var asmName = new AssemblyName(assemblyFullName);

			if (assemblies.TryGetValue(asmName.FullName, out var assembly))
				return assembly;
			if (assemblies.TryGetValue(asmName.Name, out assembly))
				return assembly;

			return null;
		}

		static string[] assemblyExtensions = new string[] { ".dll", ".exe" };
		Assembly AssemblyResolve(object sender, ResolveEventArgs args) {
			var assembly = Get(args.Name);
			if (assembly != null)
				return assembly;

			var asmName = new AssemblyName(args.Name);
			foreach (var path in assemblySearchPaths) {
				foreach (var ext in assemblyExtensions) {
					try {
						var filename = Path.Combine(path, asmName.Name + ext);
						if (!new FileInfo(filename).Exists)
							continue;
						AddConfigFile(filename + ".config");
						return AddAssembly(Assembly.LoadFile(filename));
					}
					catch (IOException) {
					}
					catch (BadImageFormatException) {
					}
					catch (ArgumentException) {
					}
					catch (NotSupportedException) {
					}
					catch (UnauthorizedAccessException) {
					}
					catch (System.Security.SecurityException) {
					}
				}
			}

			return null;
		}

		public Assembly Load(string filename) {
			AddConfigFile(filename + ".config");
			return AddAssembly(LoadFile(filename));
		}

		Assembly LoadFile(string filename) {
			try {
				return Assembly.LoadFrom(filename);
			}
			catch (FileLoadException) {
				// Here if eg. strong name signature validation failed and possibly other errors
				return Assembly.Load(File.ReadAllBytes(filename));
			}
		}

		Assembly AddAssembly(Assembly assembly) {
			var asmName = assembly.GetName();
			assemblies[asmName.FullName] = assembly;
			assemblies[asmName.Name] = assembly;
			return assembly;
		}

		void AddConfigFile(string configFilename) {
			var dirName = Utils.GetDirName(Utils.GetFullPath(configFilename));
			AddAssemblySearchPath(dirName);

			try {
				using (var xmlStream = new FileStream(configFilename, FileMode.Open, FileAccess.Read, FileShare.Read)) {
					var doc = new XmlDocument();
					doc.Load(XmlReader.Create(xmlStream));
					foreach (var tmp in doc.GetElementsByTagName("probing")) {
						var probingElem = tmp as XmlElement;
						if (probingElem == null)
							continue;
						var privatePath = probingElem.GetAttribute("privatePath");
						if (string.IsNullOrEmpty(privatePath))
							continue;
						foreach (var path in privatePath.Split(';'))
							AddAssemblySearchPath(Path.Combine(dirName, path));
					}
				}
			}
			catch (IOException) {
			}
			catch (XmlException) {
			}
		}
	}
}



================================================
File: AssemblyData/AssemblyServer.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

#if NETFRAMEWORK
using System;
using System.Collections;
using System.Runtime.Remoting;
using System.Runtime.Remoting.Channels;
using System.Runtime.Remoting.Channels.Ipc;
using AssemblyData;

namespace AssemblyServer {
	public static class Start {
		public static int Main(string[] args) {
			if (args.Length != 3)
				Environment.Exit(1);
			var serviceType = (AssemblyServiceType)int.Parse(args[0]);
			var channelName = args[1];
			var uri = args[2];

			var service = (AssemblyService)AssemblyService.Create(serviceType);
			StartServer(service, channelName, uri);
			service.WaitExit();
			return 0;
		}

		static void StartServer(AssemblyService service, string name, string uri) {
			var props = new Hashtable();
			props["portName"] = name;
			var provider = new BinaryServerFormatterSinkProvider();
			provider.TypeFilterLevel = System.Runtime.Serialization.Formatters.TypeFilterLevel.Full;
			var channel = new IpcServerChannel(props, provider);
			ChannelServices.RegisterChannel(channel, false);
			RemotingServices.Marshal(service, uri);
		}
	}
}
#else
namespace AssemblyServer {
	public static class Start {
		public static int Main(string[] args) {
			System.Console.WriteLine("Not supported");
			return -1;
		}
	}
}
#endif



================================================
File: AssemblyData/AssemblyService.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Reflection;
using System.Threading;

namespace AssemblyData {
	public abstract class AssemblyService : MarshalByRefObject, IAssemblyService {
		ManualResetEvent exitEvent = new ManualResetEvent(false);
		protected Assembly assembly = null;
		AssemblyResolver assemblyResolver = new AssemblyResolver();

		public static AssemblyService Create(AssemblyServiceType serviceType) {
			switch (serviceType) {
			case AssemblyServiceType.StringDecrypter:
				return new StringDecrypterService();

			case AssemblyServiceType.MethodDecrypter:
				return new MethodDecrypterService();

			case AssemblyServiceType.Generic:
				return new GenericService();

			default:
				throw new ArgumentException("Invalid assembly service type");
			}
		}

		public static Type GetType(AssemblyServiceType serviceType) {
			switch (serviceType) {
			case AssemblyServiceType.StringDecrypter:
				return typeof(StringDecrypterService);

			case AssemblyServiceType.MethodDecrypter:
				return typeof(MethodDecrypterService);

			case AssemblyServiceType.Generic:
				return typeof(GenericService);

			default:
				throw new ArgumentException("Invalid assembly service type");
			}
		}

		public void DoNothing() { }
		public virtual void Exit() => exitEvent.Set();
		public void WaitExit() => exitEvent.WaitOne();
		public override object InitializeLifetimeService() => null;

		protected void CheckAssembly() {
			if (assembly == null)
				throw new ApplicationException("LoadAssembly() hasn't been called yet.");
		}

		protected void LoadAssemblyInternal(string filename) {
			if (assembly != null)
				throw new ApplicationException("Only one assembly can be explicitly loaded");
			try {
				assembly = assemblyResolver.Load(filename);
			}
			catch (BadImageFormatException ex) {
				throw new ApplicationException($"Could not load assembly {filename}. Maybe it's 32-bit or 64-bit only?", ex);
			}
		}
	}
}



================================================
File: AssemblyData/DelegateStringDecrypter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Reflection;
using System.Reflection.Emit;
using System.Collections.Generic;

namespace AssemblyData {
	class DelegateStringDecrypter : IStringDecrypter {
		delegate string DecryptString(object[] args);
		List<DecryptString> stringDecryptMethods = new List<DecryptString>();

		public int DefineStringDecrypter(MethodInfo method) {
			stringDecryptMethods.Add(BuildDynamicMethod(method));
			return stringDecryptMethods.Count - 1;
		}

		public object[] DecryptStrings(int stringDecrypterMethod, object[] args, MethodBase caller) {
			if (stringDecrypterMethod > stringDecryptMethods.Count)
				throw new ApplicationException("Invalid string decrypter method");

			var rv = new object[args.Length];
			var stringDecrypter = stringDecryptMethods[stringDecrypterMethod];
			for (int i = 0; i < args.Length; i++)
				rv[i] = stringDecrypter((object[])args[i]);
			return rv;
		}

		DecryptString BuildDynamicMethod(MethodInfo method) {
			var dm = new DynamicMethod("", typeof(string), new Type[] { typeof(object[]) }, typeof(DelegateStringDecrypter), true);
			Utils.AddCallStringDecrypterMethodInstructions(method, dm.GetILGenerator());
			return (DecryptString)dm.CreateDelegate(typeof(DecryptString));
		}
	}
}



================================================
File: AssemblyData/EmuStringDecrypter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using System.Reflection;
using AssemblyData.methodsrewriter;

namespace AssemblyData {
	class EmuStringDecrypter : IStringDecrypter {
		List<DecryptInfo> decryptInfos = new List<DecryptInfo>();
		MethodsRewriter methodsRewriter = new MethodsRewriter();

		class DecryptInfo {
			public MethodInfo method;
			public RewrittenMethod decryptString;

			public DecryptInfo(MethodInfo method) => this.method = method;
		}

		public int DefineStringDecrypter(MethodInfo method) {
			decryptInfos.Add(new DecryptInfo(method));
			return decryptInfos.Count - 1;
		}

		public object[] DecryptStrings(int stringDecrypterMethod, object[] args, MethodBase caller) {
			var decryptInfo = decryptInfos[stringDecrypterMethod];
			if (decryptInfo.decryptString == null)
				decryptInfo.decryptString = CreateDecryptString(decryptInfo.method);

			methodsRewriter.SetCaller(decryptInfo.decryptString, caller);
			var result = new object[args.Length];
			for (int i = 0; i < args.Length; i++)
				result[i] = decryptInfo.decryptString((object[])args[i]);
			return result;
		}

		RewrittenMethod CreateDecryptString(MethodInfo method) {
			methodsRewriter.CreateMethod(method);
			return methodsRewriter.CreateDelegate(method);
		}
	}
}



================================================
File: AssemblyData/GenericService.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Reflection;

namespace AssemblyData {
	class GenericService : AssemblyService, IGenericService {
		IUserGenericService userGenericService;

		public override void Exit() {
			if (userGenericService != null)
				userGenericService.Dispose();
			userGenericService = null;
			base.Exit();
		}

		public void LoadUserService(Type createServiceType, object createMethodArgs) {
			var createServiceMethod = GetCreateUserServiceMethod(createServiceType);
			userGenericService = createServiceMethod.Invoke(null, null) as IUserGenericService;
			if (userGenericService == null)
				throw new ApplicationException("create-service-method failed to create user service");
		}

		MethodInfo GetCreateUserServiceMethod(Type createServiceType) {
			if (createServiceType == null)
				throw new ApplicationException("Create-service-type is null");
			foreach (var method in createServiceType.GetMethods(BindingFlags.DeclaredOnly | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic)) {
				if (method.GetCustomAttributes(typeof(CreateUserGenericServiceAttribute), false).Length > 0)
					return method;
			}
			throw new ApplicationException($"Failed to find create-service-method. Type token: Type: {createServiceType}");
		}

		void CheckUserService() {
			if (userGenericService == null)
				throw new ApplicationException("LoadUserService() hasn't been called yet.");
		}

		public void LoadAssembly(string filename) {
			CheckUserService();
			LoadAssemblyInternal(filename);
			userGenericService.AssemblyLoaded(assembly);
		}

		public object SendMessage(int msg, object[] args) {
			CheckUserService();
			return userGenericService.HandleMessage(msg, args);
		}
	}
}



================================================
File: AssemblyData/IAssemblyService.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

namespace AssemblyData {
	public enum AssemblyServiceType {
		StringDecrypter,
		MethodDecrypter,
		Generic,
	}

	public interface IAssemblyService {
		void DoNothing();
		void Exit();
	}
}



================================================
File: AssemblyData/IGenericService.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;

namespace AssemblyData {
	public class CreateUserGenericServiceAttribute : Attribute {
	}

	public interface IGenericService : IAssemblyService {
		void LoadUserService(Type createServiceType, object createMethodArgs);
		void LoadAssembly(string filename);
		object SendMessage(int msg, object[] args);
	}
}



================================================
File: AssemblyData/IMethodDecrypterService.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using de4dot.blocks;
using de4dot.mdecrypt;

namespace AssemblyData {
	public interface IMethodDecrypterService : IAssemblyService {
		void InstallCompileMethod(DecryptMethodsInfo decryptMethodsInfo);
		void LoadObfuscator(string filename);
		bool CanDecryptMethods();
		DumpedMethods DecryptMethods();
	}
}



================================================
File: AssemblyData/IStringDecrypter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Reflection;

namespace AssemblyData {
	interface IStringDecrypter {
		int DefineStringDecrypter(MethodInfo method);
		object[] DecryptStrings(int stringDecrypterMethod, object[] args, MethodBase caller);
	}
}



================================================
File: AssemblyData/IStringDecrypterService.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

namespace AssemblyData {
	public enum StringDecrypterType {
		Delegate,
		Emulate,
	}

	public interface IStringDecrypterService : IAssemblyService {
		void LoadAssembly(string filename);
		void SetStringDecrypterType(StringDecrypterType type);
		int DefineStringDecrypter(int methodToken);
		object[] DecryptStrings(int stringDecrypterMethod, object[] args, int callerToken);
	}
}



================================================
File: AssemblyData/IUserGenericService.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Reflection;

namespace AssemblyData {
	public interface IUserGenericService : IDisposable {
		void AssemblyLoaded(Assembly assembly);
		object HandleMessage(int msg, object[] args);
	}
}



================================================
File: AssemblyData/MethodDecrypterService.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using de4dot.blocks;
using de4dot.mdecrypt;

namespace AssemblyData {
	class MethodDecrypterService : AssemblyService, IMethodDecrypterService {
		bool installCompileMethodCalled = false;

		public void InstallCompileMethod(DecryptMethodsInfo decryptMethodsInfo) {
			if (installCompileMethodCalled)
				throw new ApplicationException("installCompileMethod() has already been called");
			installCompileMethodCalled = true;
			DynamicMethodsDecrypter.Instance.DecryptMethodsInfo = decryptMethodsInfo;
			DynamicMethodsDecrypter.Instance.InstallCompileMethod();
		}

		public void LoadObfuscator(string filename) {
			LoadAssemblyInternal(filename);
			DynamicMethodsDecrypter.Instance.Module = assembly.ManifestModule;
			DynamicMethodsDecrypter.Instance.LoadObfuscator();
		}

		public bool CanDecryptMethods() {
			CheckAssembly();
			return DynamicMethodsDecrypter.Instance.CanDecryptMethods();
		}

		public DumpedMethods DecryptMethods() {
			CheckAssembly();
			return DynamicMethodsDecrypter.Instance.DecryptMethods();
		}
	}
}



================================================
File: AssemblyData/SimpleData.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Text;

namespace AssemblyData {
	// This class will make sure no data in the string is destroyed by serialization
	[Serializable]
	class MyString {
		short[] data;

		public MyString() {
		}

		public MyString(string s) {
			if (s == null)
				data = null;
			else {
				data = new short[s.Length];
				for (int i = 0; i < s.Length; i++)
					data[i] = (short)s[i];
			}
		}

		public override string ToString() {
			if (data == null)
				return null;

			var sb = new StringBuilder(data.Length);
			foreach (var c in data)
				sb.Append((char)c);
			return sb.ToString();
		}
	}

	public static class SimpleData {
		public static object[] Pack(object[] args) {
			for (int i = 0; i < args.Length; i++) {
				if (args[i] is string s)
					args[i] = new MyString(s);
			}
			return args;
		}

		public static object[] Unpack(object[] args) {
			for (int i = 0; i < args.Length; i++) {
				if (args[i] is MyString s)
					args[i] = s.ToString();
			}
			return args;
		}
	}
}



================================================
File: AssemblyData/StringDecrypterService.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Reflection;

namespace AssemblyData {
	class StringDecrypterService : AssemblyService, IStringDecrypterService {
		IStringDecrypter stringDecrypter = null;

		void CheckStringDecrypter() {
			if (stringDecrypter == null)
				throw new ApplicationException("SetStringDecrypterType() hasn't been called yet.");
		}

		public void LoadAssembly(string filename) => LoadAssemblyInternal(filename);

		public void SetStringDecrypterType(StringDecrypterType type) {
			if (stringDecrypter != null)
				throw new ApplicationException("StringDecrypterType already set");

			switch (type) {
			case StringDecrypterType.Delegate:
				stringDecrypter = new DelegateStringDecrypter();
				break;

			case StringDecrypterType.Emulate:
				stringDecrypter = new EmuStringDecrypter();
				break;

			default:
				throw new ApplicationException($"Unknown StringDecrypterType {type}");
			}
		}

		public int DefineStringDecrypter(int methodToken) {
			CheckStringDecrypter();
			var methodInfo = FindMethod(methodToken);
			if (methodInfo == null)
				throw new ApplicationException($"Could not find method {methodToken:X8}");
			if (methodInfo.ReturnType != typeof(string) && methodInfo.ReturnType != typeof(object))
				throw new ApplicationException($"Method return type must be string or object: {methodInfo}");
			return stringDecrypter.DefineStringDecrypter(methodInfo);
		}

		public object[] DecryptStrings(int stringDecrypterMethod, object[] args, int callerToken) {
			CheckStringDecrypter();
			var caller = GetCaller(callerToken);
			foreach (var arg in args)
				SimpleData.Unpack((object[])arg);
			return SimpleData.Pack(stringDecrypter.DecryptStrings(stringDecrypterMethod, args, caller));
		}

		MethodBase GetCaller(int callerToken) {
			try {
				return assembly.GetModules()[0].ResolveMethod(callerToken);
			}
			catch {
				return null;
			}
		}

		MethodInfo FindMethod(int methodToken) {
			CheckAssembly();

			foreach (var module in assembly.GetModules()) {
				if (module.ResolveMethod(methodToken) is MethodInfo method)
					return method;
			}

			return null;
		}
	}
}



================================================
File: AssemblyData/Utils.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.IO;
using System.Reflection;
using System.Reflection.Emit;
using System.Text;

namespace AssemblyData {
	internal delegate void Action<T1, T2, T3, T4>(T1 arg1, T2 arg2, T3 arg3, T4 arg4);
	internal delegate void Action<T1, T2, T3, T4, T5>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
	internal delegate void Action<T1, T2, T3, T4, T5, T6>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
	internal delegate void Action<T1, T2, T3, T4, T5, T6, T7>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
	internal delegate void Action<T1, T2, T3, T4, T5, T6, T7, T8>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
	internal delegate void Action<T1, T2, T3, T4, T5, T6, T7, T8, T9>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);
	internal delegate void Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10);
	internal delegate void Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11);
	internal delegate void Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12);
	internal delegate void Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13);
	internal delegate void Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14);
	internal delegate void Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15);
	internal delegate void Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16);
	internal delegate void Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16, T17 arg17);
	internal delegate void Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16, T17 arg17, T18 arg18);
	internal delegate void Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16, T17 arg17, T18 arg18, T19 arg19);
	internal delegate TResult Func<T1, T2, T3, T4, T5, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
	internal delegate TResult Func<T1, T2, T3, T4, T5, T6, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
	internal delegate TResult Func<T1, T2, T3, T4, T5, T6, T7, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
	internal delegate TResult Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
	internal delegate TResult Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);
	internal delegate TResult Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10);
	internal delegate TResult Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11);
	internal delegate TResult Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12);
	internal delegate TResult Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13);
	internal delegate TResult Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14);
	internal delegate TResult Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15);
	internal delegate TResult Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16);
	internal delegate TResult Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16, T17 arg17);
	internal delegate TResult Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16, T17 arg17, T18 arg18);
	internal delegate TResult Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16, T17 arg17, T18 arg18, T19 arg19);

	static class Utils {
		static Random random = new Random();

		public static uint GetRandomUint() => (uint)(random.NextDouble() * uint.MaxValue);

		public static Type GetDelegateType(Type returnType, Type[] args) {
			Type[] types;
			if (returnType == typeof(void)) {
				types = args;
				switch (types.Length) {
				case 0: return typeof(Action).MakeGenericType(types);
				case 1: return typeof(Action<>).MakeGenericType(types);
				case 2: return typeof(Action<,>).MakeGenericType(types);
				case 3: return typeof(Action<,,>).MakeGenericType(types);
				case 4: return typeof(Action<,,,>).MakeGenericType(types);
				case 5: return typeof(Action<,,,,>).MakeGenericType(types);
				case 6: return typeof(Action<,,,,,>).MakeGenericType(types);
				case 7: return typeof(Action<,,,,,,>).MakeGenericType(types);
				case 8: return typeof(Action<,,,,,,,>).MakeGenericType(types);
				case 9: return typeof(Action<,,,,,,,,>).MakeGenericType(types);
				case 10: return typeof(Action<,,,,,,,,,>).MakeGenericType(types);
				case 11: return typeof(Action<,,,,,,,,,,>).MakeGenericType(types);
				case 12: return typeof(Action<,,,,,,,,,,,>).MakeGenericType(types);
				case 13: return typeof(Action<,,,,,,,,,,,,>).MakeGenericType(types);
				case 14: return typeof(Action<,,,,,,,,,,,,,>).MakeGenericType(types);
				case 15: return typeof(Action<,,,,,,,,,,,,,,>).MakeGenericType(types);
				case 16: return typeof(Action<,,,,,,,,,,,,,,,>).MakeGenericType(types);
				case 17: return typeof(Action<,,,,,,,,,,,,,,,,>).MakeGenericType(types);
				case 18: return typeof(Action<,,,,,,,,,,,,,,,,,>).MakeGenericType(types);
				case 19: return typeof(Action<,,,,,,,,,,,,,,,,,,>).MakeGenericType(types);
				default:
					throw new ApplicationException($"Too many delegate type arguments: {types.Length}");
				}
			}
			else {
				types = new Type[args.Length + 1];
				Array.Copy(args, types, args.Length);
				types[types.Length - 1] = returnType;

				switch (types.Length) {
				case 1: return typeof(Func<>).MakeGenericType(types);
				case 2: return typeof(Func<,>).MakeGenericType(types);
				case 3: return typeof(Func<,,>).MakeGenericType(types);
				case 4: return typeof(Func<,,,>).MakeGenericType(types);
				case 5: return typeof(Func<,,,,>).MakeGenericType(types);
				case 6: return typeof(Func<,,,,,>).MakeGenericType(types);
				case 7: return typeof(Func<,,,,,,>).MakeGenericType(types);
				case 8: return typeof(Func<,,,,,,,>).MakeGenericType(types);
				case 9: return typeof(Func<,,,,,,,,>).MakeGenericType(types);
				case 10: return typeof(Func<,,,,,,,,,>).MakeGenericType(types);
				case 11: return typeof(Func<,,,,,,,,,,>).MakeGenericType(types);
				case 12: return typeof(Func<,,,,,,,,,,,>).MakeGenericType(types);
				case 13: return typeof(Func<,,,,,,,,,,,,>).MakeGenericType(types);
				case 14: return typeof(Func<,,,,,,,,,,,,,>).MakeGenericType(types);
				case 15: return typeof(Func<,,,,,,,,,,,,,,>).MakeGenericType(types);
				case 16: return typeof(Func<,,,,,,,,,,,,,,,>).MakeGenericType(types);
				case 17: return typeof(Func<,,,,,,,,,,,,,,,,>).MakeGenericType(types);
				case 18: return typeof(Func<,,,,,,,,,,,,,,,,,>).MakeGenericType(types);
				case 19: return typeof(Func<,,,,,,,,,,,,,,,,,,>).MakeGenericType(types);
				case 20: return typeof(Func<,,,,,,,,,,,,,,,,,,,>).MakeGenericType(types);
				default:
					throw new ApplicationException($"Too many delegate type arguments: {types.Length}");
				}
			}
		}

		public static string RandomName(int min, int max) {
			int numChars = random.Next(min, max + 1);
			var sb = new StringBuilder(numChars);
			int numLower = 0;
			for (int i = 0; i < numChars; i++) {
				if (numLower == 0)
					sb.Append((char)((int)'A' + random.Next(26)));
				else
					sb.Append((char)((int)'a' + random.Next(26)));

				if (numLower == 0) {
					numLower = random.Next(1, 5);
				}
				else {
					numLower--;
				}
			}
			return sb.ToString();
		}

		public static void AddCallStringDecrypterMethodInstructions(MethodInfo method, ILGenerator ilg) {
			var args = method.GetParameters();
			for (int i = 0; i < args.Length; i++) {
				var arg = args[i].ParameterType;

				ilg.Emit(OpCodes.Ldarg_0);
				ilg.Emit(OpCodes.Ldc_I4, i);
				ilg.Emit(OpCodes.Ldelem_Ref);

				if (arg.IsValueType)
					ilg.Emit(OpCodes.Unbox_Any, arg);
				else
					ilg.Emit(OpCodes.Castclass, arg);
			}
			ilg.Emit(OpCodes.Call, method);
			ilg.Emit(OpCodes.Ret);
		}

		public static string GetFullPath(string path) {
			try {
				return Path.GetFullPath(path);
			}
			catch (Exception) {
				return path;
			}
		}

		public static string GetDirName(string name) => Path.GetDirectoryName(name);
	}
}



================================================
File: AssemblyData/methodsrewriter/AssemblyResolver.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Reflection;
using dnlib.DotNet;

namespace AssemblyData.methodsrewriter {
	class MGenericParameter {
	}

	class AssemblyResolver {
		Dictionary<string, List<TypeResolver>> types = new Dictionary<string, List<TypeResolver>>(StringComparer.Ordinal);
		List<MethodBase> globalMethods;
		List<FieldInfo> globalFields;
		Assembly assembly;

		public AssemblyResolver(string asmName) {
			assembly = Assembly.Load(new AssemblyName(asmName));
			InitTypes();
		}

		void InitTypes() {
			foreach (var type in assembly.GetTypes()) {
				string key = (type.Namespace ?? "") + "." + type.Name;
				if (!types.TryGetValue(key, out var list))
					types[key] = list = new List<TypeResolver>();
				list.Add(new TypeResolver(type));
			}
		}

		TypeResolver GetTypeResolver(ITypeDefOrRef typeRef) {
			if (typeRef == null)
				return null;
			var scopeType = typeRef.ScopeType;
			var key = scopeType.Namespace + "." + scopeType.TypeName;
			if (!types.TryGetValue(key, out var list))
				return null;

			if (scopeType is TypeDef) {
				foreach (var resolver in list) {
					if (resolver.type.MetadataToken == scopeType.MDToken.Raw)
						return resolver;
				}
			}

			foreach (var resolver in list) {
				if (ResolverUtils.CompareTypes(resolver.type, scopeType))
					return resolver;
			}

			return null;
		}

		public FieldInfo Resolve(IField fieldRef) {
			var resolver = GetTypeResolver(fieldRef.DeclaringType);
			if (resolver != null)
				return resolver.Resolve(fieldRef);
			return ResolveGlobalField(fieldRef);
		}

		FieldInfo ResolveGlobalField(IField fieldRef) {
			InitGlobalFields();
			foreach (var globalField in globalFields) {
				if (ResolverUtils.CompareFields(globalField, fieldRef))
					return globalField;
			}
			return null;
		}

		void InitGlobalFields() {
			if (globalFields != null)
				return;
			globalFields = new List<FieldInfo>();

			var flags = BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance;
			foreach (var module in assembly.GetModules(true)) {
				foreach (var method in module.GetFields(flags))
					globalFields.Add(method);
			}
		}

		public MethodBase Resolve(IMethod methodRef) {
			var resolver = GetTypeResolver(methodRef.DeclaringType);
			if (resolver != null)
				return resolver.Resolve(methodRef);
			return ResolveGlobalMethod(methodRef);
		}

		MethodBase ResolveGlobalMethod(IMethod methodRef) {
			InitGlobalMethods();
			foreach (var globalMethod in globalMethods) {
				if (ResolverUtils.CompareMethods(globalMethod, methodRef))
					return globalMethod;
			}
			return null;
		}

		void InitGlobalMethods() {
			if (globalMethods != null)
				return;
			globalMethods = new List<MethodBase>();

			var flags = BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance;
			foreach (var module in assembly.GetModules(true)) {
				foreach (var method in module.GetMethods(flags))
					globalMethods.Add(method);
			}
		}

		public Type Resolve(ITypeDefOrRef typeRef) {
			var resolver = GetTypeResolver(typeRef);
			if (resolver != null)
				return resolver.type;

			if (typeRef is TypeSpec ts && ts.TypeSig is GenericSig)
				return typeof(MGenericParameter);

			return null;
		}

		public override string ToString() => assembly.ToString();
	}
}



================================================
File: AssemblyData/methodsrewriter/CodeGenerator.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Reflection;
using System.Reflection.Emit;
using dnlib.DotNet.Emit;
using dnlib.DotNet;

using OpCode = dnlib.DotNet.Emit.OpCode;
using OpCodes = dnlib.DotNet.Emit.OpCodes;
using OperandType = dnlib.DotNet.Emit.OperandType;
using ROpCode = System.Reflection.Emit.OpCode;
using ROpCodes = System.Reflection.Emit.OpCodes;

namespace AssemblyData.methodsrewriter {
	class CodeGenerator {
		static Dictionary<OpCode, ROpCode> dnlibToReflection = new Dictionary<OpCode, ROpCode>();
		static CodeGenerator() {
			var refDict = new Dictionary<short, ROpCode>(0x100);
			foreach (var f in typeof(ROpCodes).GetFields(BindingFlags.Static | BindingFlags.Public)) {
				if (f.FieldType != typeof(ROpCode))
					continue;
				var ropcode = (ROpCode)f.GetValue(null);
				refDict[ropcode.Value] = ropcode;
			}

			foreach (var f in typeof(OpCodes).GetFields(BindingFlags.Static | BindingFlags.Public)) {
				if (f.FieldType != typeof(OpCode))
					continue;
				var opcode = (OpCode)f.GetValue(null);
				if (!refDict.TryGetValue(opcode.Value, out var ropcode))
					continue;
				dnlibToReflection[opcode] = ropcode;
			}
		}

		IMethodsRewriter methodsRewriter;
		string methodName;
		IList<Instruction> allInstructions;
		IList<dnlib.DotNet.Emit.ExceptionHandler> allExceptionHandlers;
		ILGenerator ilg;
		Type methodReturnType;
		Type[] methodParameters;
		Type delegateType;
		MMethod methodInfo;
		LocalBuilder tempObjLocal;
		LocalBuilder tempObjArrayLocal;
		int thisArgIndex;
		List<LocalBuilder> locals;
		List<Label> labels;
		Dictionary<Instruction, int> instrToIndex;
		Stack<dnlib.DotNet.Emit.ExceptionHandler> exceptionHandlersStack;

		public Type DelegateType => delegateType;

		public CodeGenerator(IMethodsRewriter methodsRewriter, string methodName) {
			this.methodsRewriter = methodsRewriter;
			this.methodName = methodName;
		}

		public void SetMethodInfo(MMethod methodInfo) {
			this.methodInfo = methodInfo;
			methodReturnType = ResolverUtils.GetReturnType(methodInfo.methodBase);
			methodParameters = GetMethodParameterTypes(methodInfo.methodBase);
			delegateType = Utils.GetDelegateType(methodReturnType, methodParameters);
		}

		public Delegate Generate(IList<Instruction> allInstructions, IList<dnlib.DotNet.Emit.ExceptionHandler> allExceptionHandlers) {
			this.allInstructions = allInstructions;
			this.allExceptionHandlers = allExceptionHandlers;

			var dm = new DynamicMethod(methodName, methodReturnType, methodParameters, methodInfo.methodBase.Module, true);
			var lastInstr = allInstructions[allInstructions.Count - 1];
			ilg = dm.GetILGenerator((int)lastInstr.Offset + lastInstr.GetSize());

			InitInstrToIndex();
			InitLocals();
			InitLabels();

			exceptionHandlersStack = new Stack<dnlib.DotNet.Emit.ExceptionHandler>();
			for (int i = 0; i < allInstructions.Count; i++) {
				UpdateExceptionHandlers(i);
				var instr = allInstructions[i];
				ilg.MarkLabel(labels[i]);
				if (instr.Operand is Operand)
					WriteSpecialInstr(instr, (Operand)instr.Operand);
				else
					WriteInstr(instr);
			}
			UpdateExceptionHandlers(-1);

			return dm.CreateDelegate(delegateType);
		}

		Instruction GetExceptionInstruction(int instructionIndex) => instructionIndex < 0 ? null : allInstructions[instructionIndex];

		void UpdateExceptionHandlers(int instructionIndex) {
			var instr = GetExceptionInstruction(instructionIndex);
			UpdateExceptionHandlers(instr);
			if (AddTryStart(instr))
				UpdateExceptionHandlers(instr);
		}

		void UpdateExceptionHandlers(Instruction instr) {
			while (exceptionHandlersStack.Count > 0) {
				var ex = exceptionHandlersStack.Peek();
				if (ex.TryEnd == instr) {
				}
				if (ex.FilterStart == instr) {
				}
				if (ex.HandlerStart == instr) {
					if (ex.HandlerType == ExceptionHandlerType.Finally)
						ilg.BeginFinallyBlock();
					else
						ilg.BeginCatchBlock(Resolver.GetRtType(ex.CatchType));
				}
				if (ex.HandlerEnd == instr) {
					exceptionHandlersStack.Pop();
					if (exceptionHandlersStack.Count == 0 || !IsSameTryBlock(ex, exceptionHandlersStack.Peek()))
						ilg.EndExceptionBlock();
				}
				else
					break;
			}
		}

		bool AddTryStart(Instruction instr) {
			var list = new List<dnlib.DotNet.Emit.ExceptionHandler>();
			foreach (var ex in allExceptionHandlers) {
				if (ex.TryStart == instr)
					list.Add(ex);
			}
			list.Reverse();

			foreach (var ex in list) {
				if (exceptionHandlersStack.Count == 0 || !IsSameTryBlock(ex, exceptionHandlersStack.Peek()))
					ilg.BeginExceptionBlock();
				exceptionHandlersStack.Push(ex);
			}

			return list.Count > 0;
		}

		static bool IsSameTryBlock(dnlib.DotNet.Emit.ExceptionHandler ex1, dnlib.DotNet.Emit.ExceptionHandler ex2) => ex1.TryStart == ex2.TryStart && ex1.TryEnd == ex2.TryEnd;

		void InitInstrToIndex() {
			instrToIndex = new Dictionary<Instruction, int>(allInstructions.Count);
			for (int i = 0; i < allInstructions.Count; i++)
				instrToIndex[allInstructions[i]] = i;
		}

		void InitLocals() {
			locals = new List<LocalBuilder>();
			foreach (var local in methodInfo.methodDef.Body.Variables)
				locals.Add(ilg.DeclareLocal(Resolver.GetRtType(local.Type), local.Type.RemoveModifiers().IsPinned));
			tempObjLocal = ilg.DeclareLocal(typeof(object));
			tempObjArrayLocal = ilg.DeclareLocal(typeof(object[]));
		}

		void InitLabels() {
			labels = new List<Label>(allInstructions.Count);
			for (int i = 0; i < allInstructions.Count; i++)
				labels.Add(ilg.DefineLabel());
		}

		Type[] GetMethodParameterTypes(MethodBase method) {
			var list = new List<Type>();
			if (ResolverUtils.HasThis(method))
				list.Add(method.DeclaringType);

			foreach (var param in method.GetParameters())
				list.Add(param.ParameterType);

			thisArgIndex = list.Count;
			list.Add(methodsRewriter.GetType());

			return list.ToArray();
		}

		void WriteSpecialInstr(Instruction instr, Operand operand) {
			BindingFlags flags;
			switch (operand.type) {
			case Operand.Type.ThisArg:
				ilg.Emit(ConvertOpCode(instr.OpCode), (short)thisArgIndex);
				break;

			case Operand.Type.TempObj:
				ilg.Emit(ConvertOpCode(instr.OpCode), tempObjLocal);
				break;

			case Operand.Type.TempObjArray:
				ilg.Emit(ConvertOpCode(instr.OpCode), tempObjArrayLocal);
				break;

			case Operand.Type.OurMethod:
				flags = BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.Public;
				var methodName = (string)operand.data;
				var ourMethod = methodsRewriter.GetType().GetMethod(methodName, flags);
				if (ourMethod == null)
					throw new ApplicationException($"Could not find method {methodName}");
				ilg.Emit(ConvertOpCode(instr.OpCode), ourMethod);
				break;

			case Operand.Type.NewMethod:
				var methodBase = (MethodBase)operand.data;
				var delegateType = methodsRewriter.GetDelegateType(methodBase);
				flags = BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.Instance;
				var invokeMethod = delegateType.GetMethod("Invoke", flags);
				ilg.Emit(ConvertOpCode(instr.OpCode), invokeMethod);
				break;

			case Operand.Type.ReflectionType:
				ilg.Emit(ConvertOpCode(instr.OpCode), (Type)operand.data);
				break;

			default:
				throw new ApplicationException($"Unknown operand type: {operand.type}");
			}
		}

		Label GetLabel(Instruction target) => labels[instrToIndex[target]];

		Label[] GetLabels(Instruction[] targets) {
			var labels = new Label[targets.Length];
			for (int i = 0; i < labels.Length; i++)
				labels[i] = GetLabel(targets[i]);
			return labels;
		}

		void WriteInstr(Instruction instr) {
			var opcode = ConvertOpCode(instr.OpCode);
			switch (instr.OpCode.OperandType) {
			case OperandType.InlineNone:
				ilg.Emit(opcode);
				break;

			case OperandType.InlineBrTarget:
			case OperandType.ShortInlineBrTarget:
				ilg.Emit(opcode, GetLabel((Instruction)instr.Operand));
				break;

			case OperandType.InlineSwitch:
				ilg.Emit(opcode, GetLabels((Instruction[])instr.Operand));
				break;

			case OperandType.ShortInlineI:
				if (instr.OpCode.Code == Code.Ldc_I4_S)
					ilg.Emit(opcode, (sbyte)instr.Operand);
				else
					ilg.Emit(opcode, (byte)instr.Operand);
				break;

			case OperandType.InlineI:
				ilg.Emit(opcode, (int)instr.Operand);
				break;

			case OperandType.InlineI8:
				ilg.Emit(opcode, (long)instr.Operand);
				break;

			case OperandType.InlineR:
				ilg.Emit(opcode, (double)instr.Operand);
				break;

			case OperandType.ShortInlineR:
				ilg.Emit(opcode, (float)instr.Operand);
				break;

			case OperandType.InlineString:
				ilg.Emit(opcode, (string)instr.Operand);
				break;

			case OperandType.InlineTok:
			case OperandType.InlineType:
			case OperandType.InlineMethod:
			case OperandType.InlineField:
				var obj = Resolver.GetRtObject((ITokenOperand)instr.Operand);
				if (obj is ConstructorInfo)
					ilg.Emit(opcode, (ConstructorInfo)obj);
				else if (obj is MethodInfo)
					ilg.Emit(opcode, (MethodInfo)obj);
				else if (obj is FieldInfo)
					ilg.Emit(opcode, (FieldInfo)obj);
				else if (obj is Type)
					ilg.Emit(opcode, (Type)obj);
				else
					throw new ApplicationException($"Unknown type: {(obj == null ? obj : obj.GetType())}");
				break;

			case OperandType.InlineVar:
				ilg.Emit(opcode, checked((short)((IVariable)instr.Operand).Index));
				break;

			case OperandType.ShortInlineVar:
				ilg.Emit(opcode, checked((byte)((IVariable)instr.Operand).Index));
				break;

			case OperandType.InlineSig:	//TODO:
			default:
				throw new ApplicationException($"Unknown OperandType {instr.OpCode.OperandType}");
			}
		}

		ROpCode ConvertOpCode(OpCode opcode) {
			if (dnlibToReflection.TryGetValue(opcode, out var ropcode))
				return ropcode;
			return ROpCodes.Nop;
		}
	}
}



================================================
File: AssemblyData/methodsrewriter/IMethodsRewriter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Reflection;

namespace AssemblyData.methodsrewriter {
	interface IMethodsRewriter {
		Type GetDelegateType(MethodBase methodBase);
	}
}



================================================
File: AssemblyData/methodsrewriter/MField.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Reflection;
using dnlib.DotNet;

namespace AssemblyData.methodsrewriter {
	class MField {
		public FieldInfo fieldInfo;
		public FieldDef fieldDef;

		public MField(FieldInfo fieldInfo, FieldDef fieldDef) {
			this.fieldInfo = fieldInfo;
			this.fieldDef = fieldDef;
		}

		public override string ToString() => fieldDef.ToString();
	}
}



================================================
File: AssemblyData/methodsrewriter/MMethod.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Reflection;
using dnlib.DotNet;

namespace AssemblyData.methodsrewriter {
	class MMethod {
		public MethodBase methodBase;
		public MethodDef methodDef;
		public MMethod(MethodBase methodBase, MethodDef methodDef) {
			this.methodBase = methodBase;
			this.methodDef = methodDef;
		}

		public bool HasInstructions() => methodDef.Body != null && methodDef.Body.Instructions.Count != 0;
		public override string ToString() => methodDef.ToString();
	}
}



================================================
File: AssemblyData/methodsrewriter/MModule.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Reflection;
using dnlib.DotNet;
using de4dot.blocks;

namespace AssemblyData.methodsrewriter {
	class MModule {
		public Module module;
		public ModuleDefMD moduleDef;
		TypeDefDict<MType> typeRefToType = new TypeDefDict<MType>();
		Dictionary<int, MType> tokenToType = new Dictionary<int, MType>();
		Dictionary<int, MMethod> tokenToGlobalMethod;
		Dictionary<int, MField> tokenToGlobalField;
		TypeDef moduleType;

		public MModule(Module module, ModuleDefMD moduleDef) {
			this.module = module;
			this.moduleDef = moduleDef;
			InitTokenToType();
		}

		void InitTokenToType() {
			moduleType = moduleDef.Types[0];
			foreach (var typeDef in moduleDef.GetTypes()) {
				int token = (int)typeDef.MDToken.Raw;
				Type type;
				try {
					type = module.ResolveType(token);
				}
				catch {
					tokenToType[token] = null;
					typeRefToType.Add(typeDef, null);
					continue;
				}
				var mtype = new MType(type, typeDef);
				tokenToType[token] = mtype;
				typeRefToType.Add(typeDef, mtype);
			}
		}

		public MType GetType(IType typeRef) => typeRefToType.Find(typeRef);

		public MMethod GetMethod(IMethod methodRef) {
			var type = GetType(methodRef.DeclaringType);
			if (type != null)
				return type.GetMethod(methodRef);
			if (!new SigComparer().Equals(moduleType, methodRef.DeclaringType))
				return null;

			InitGlobalMethods();
			foreach (var method in tokenToGlobalMethod.Values) {
				if (new SigComparer().Equals(methodRef, method.methodDef))
					return method;
			}

			return null;
		}

		public MField GetField(IField fieldRef) {
			var type = GetType(fieldRef.DeclaringType);
			if (type != null)
				return type.GetField(fieldRef);
			if (!new SigComparer().Equals(moduleType, fieldRef.DeclaringType))
				return null;

			InitGlobalFields();
			foreach (var field in tokenToGlobalField.Values) {
				if (new SigComparer().Equals(fieldRef, field.fieldDef))
					return field;
			}

			return null;
		}

		public MMethod GetMethod(MethodBase method) {
			if (method.Module != module)
				throw new ApplicationException("Not our module");
			if (method.DeclaringType == null)
				return GetGlobalMethod(method);
			var type = tokenToType[method.DeclaringType.MetadataToken];
			return type.GetMethod(method.MetadataToken);
		}

		public MMethod GetGlobalMethod(MethodBase method) {
			InitGlobalMethods();
			return tokenToGlobalMethod[method.MetadataToken];
		}

		void InitGlobalMethods() {
			if (tokenToGlobalMethod != null)
				return;
			tokenToGlobalMethod = new Dictionary<int, MMethod>();

			var tmpTokenToGlobalMethod = new Dictionary<int, MethodInfo>();
			var flags = BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic;
			foreach (var m in module.GetMethods(flags))
				tmpTokenToGlobalMethod[m.MetadataToken] = m;
			foreach (var m in moduleType.Methods) {
				if (m.Name == ".cctor")	//TODO: Use module.GetMethod(token) to get .cctor method
					continue;
				var token = (int)m.MDToken.Raw;
				tokenToGlobalMethod[token] = new MMethod(tmpTokenToGlobalMethod[token], m);
			}
		}

		void InitGlobalFields() {
			if (tokenToGlobalField != null)
				return;
			tokenToGlobalField = new Dictionary<int, MField>();

			var tmpTokenToGlobalField = new Dictionary<int, FieldInfo>();
			var flags = BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic;
			foreach (var f in module.GetFields(flags))
				tmpTokenToGlobalField[f.MetadataToken] = f;
			foreach (var f in moduleType.Fields) {
				var token = (int)f.MDToken.Raw;
				tokenToGlobalField[token] = new MField(tmpTokenToGlobalField[token], f);
			}
		}

		public override string ToString() => moduleDef.Location;
	}
}



================================================
File: AssemblyData/methodsrewriter/MType.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Reflection;
using dnlib.DotNet;
using de4dot.blocks;

namespace AssemblyData.methodsrewriter {
	class MType {
		public Type type;
		public TypeDef typeDef;
		Dictionary<int, MMethod> tokenToMethod;
		MethodDefDict<MMethod> methodRefToMethod;
		Dictionary<int, MField> tokenToField;
		FieldDefDict<MField> fieldRefToField;

		public MType(Type type, TypeDef typeDef) {
			this.type = type;
			this.typeDef = typeDef;
		}

		public MMethod GetMethod(IMethod methodRef) {
			InitMethods();
			return methodRefToMethod.Find(methodRef);
		}

		public MField GetField(IField fieldRef) {
			InitFields();
			return fieldRefToField.Find(fieldRef);
		}

		public MMethod GetMethod(int token) {
			InitMethods();
			return tokenToMethod[token];
		}

		public MField GetField(int token) {
			InitFields();
			return tokenToField[token];
		}

		void InitMethods() {
			if (tokenToMethod != null)
				return;
			tokenToMethod = new Dictionary<int, MMethod>(typeDef.Methods.Count);
			methodRefToMethod = new MethodDefDict<MMethod>();

			var tmpTokenToMethod = new Dictionary<int, MethodBase>();
			var flags = BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic;
			foreach (var m in ResolverUtils.GetMethodBases(type, flags))
				tmpTokenToMethod[m.MetadataToken] = m;
			foreach (var m in typeDef.Methods) {
				var token = (int)m.MDToken.Raw;
				var method = new MMethod(tmpTokenToMethod[token], m);
				tokenToMethod[token] = method;
				methodRefToMethod.Add(method.methodDef, method);
			}
		}

		void InitFields() {
			if (tokenToField != null)
				return;
			tokenToField = new Dictionary<int, MField>(typeDef.Fields.Count);
			fieldRefToField = new FieldDefDict<MField>();

			var tmpTokenToField = new Dictionary<int, FieldInfo>();
			var flags = BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic;
			foreach (var f in type.GetFields(flags))
				tmpTokenToField[f.MetadataToken] = f;
			foreach (var f in typeDef.Fields) {
				var token = (int)f.MDToken.Raw;
				var field = new MField(tmpTokenToField[token], f);
				tokenToField[token] = field;
				fieldRefToField.Add(field.fieldDef, field);
			}
		}

		public override string ToString() => $"{typeDef.MDToken.Raw:X8} - {typeDef.FullName}";
	}
}



================================================
File: AssemblyData/methodsrewriter/MethodsRewriter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;
using System.Reflection.Emit;
using dnlib.DotNet.Emit;
using dnlib.DotNet;
using de4dot.blocks;

using OpCode = dnlib.DotNet.Emit.OpCode;
using OpCodes = dnlib.DotNet.Emit.OpCodes;
using ROpCodes = System.Reflection.Emit.OpCodes;

namespace AssemblyData.methodsrewriter {
	delegate object RewrittenMethod(object[] args);

	class MethodsFinder {
		Dictionary<Module, MethodsModule> moduleToMethods = new Dictionary<Module, MethodsModule>();

		class MethodsModule {
			const int MAX_METHODS = 30;
			List<MethodBase> methods = new List<MethodBase>(MAX_METHODS);
			int next;

			public MethodsModule(Module module) {
				var flags = BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic;

				foreach (var type in module.GetTypes()) {
					if (methods.Count >= MAX_METHODS)
						break;
					foreach (var method in type.GetMethods(flags)) {
						if (methods.Count >= MAX_METHODS)
							break;
						methods.Add(method);
					}
				}

				foreach (var method in module.GetMethods(flags)) {
					if (methods.Count >= MAX_METHODS)
						break;
					methods.Add(method);
				}
			}

			public MethodBase GetNext() => methods[next++ % methods.Count];
		}

		public MethodBase GetMethod(Module module) {
			if (!moduleToMethods.TryGetValue(module, out var methodsModule))
				moduleToMethods[module] = methodsModule = new MethodsModule(module);
			return methodsModule.GetNext();
		}
	}

	class MethodsRewriter : IMethodsRewriter {
		MethodsFinder methodsFinder = new MethodsFinder();
		Dictionary<MethodBase, NewMethodInfo> realMethodToNewMethod = new Dictionary<MethodBase, NewMethodInfo>();
		Dictionary<NewMethodInfo, MethodBase> newStackMethodDict = new Dictionary<NewMethodInfo, MethodBase>();
		List<NewMethodInfo> newMethodInfos = new List<NewMethodInfo>();

		// There's no documented way to get a dynamic method's MethodInfo. If we name the
		// method and it's a unique random name, we can still find the emulated method.
		Dictionary<string, NewMethodInfo> delegateNameToNewMethodInfo = new Dictionary<string, NewMethodInfo>(StringComparer.Ordinal);

		class NewMethodInfo {
			// Original method
			public MethodBase oldMethod;

			public Type delegateType;

			// The modified code is here
			public Delegate delegateInstance;

			// newMethodInfos index
			public int delegateIndex;

			public RewrittenMethod rewrittenMethod;

			// Name of method used by delegateInstance
			public string delegateMethodName;

			// Name of method used by rewrittenMethod
			public string rewrittenMethodName;

			public NewMethodInfo(MethodBase oldMethod, int delegateIndex, string delegateMethodName, string rewrittenMethodName) {
				this.oldMethod = oldMethod;
				this.delegateIndex = delegateIndex;
				this.delegateMethodName = delegateMethodName;
				this.rewrittenMethodName = rewrittenMethodName;
			}

			public bool IsRewrittenMethod(string name) => name == rewrittenMethodName;
			public bool IsDelegateMethod(string name) => name == delegateMethodName;
		}

		public Type GetDelegateType(MethodBase methodBase) => realMethodToNewMethod[methodBase].delegateType;

		public RewrittenMethod CreateDelegate(MethodBase realMethod) {
			var newMethodInfo = realMethodToNewMethod[realMethod];
			if (newMethodInfo.rewrittenMethod != null)
				return newMethodInfo.rewrittenMethod;

			var dm = new DynamicMethod(newMethodInfo.rewrittenMethodName, typeof(object), new Type[] { GetType(), typeof(object[]) }, newMethodInfo.oldMethod.Module, true);
			var ilg = dm.GetILGenerator();

			ilg.Emit(ROpCodes.Ldarg_0);
			ilg.Emit(ROpCodes.Ldc_I4, newMethodInfo.delegateIndex);
			ilg.Emit(ROpCodes.Call, GetType().GetMethod("RtGetDelegateInstance", BindingFlags.DeclaredOnly | BindingFlags.NonPublic | BindingFlags.Instance));
			ilg.Emit(ROpCodes.Castclass, newMethodInfo.delegateType);

			var args = newMethodInfo.oldMethod.GetParameters();
			for (int i = 0; i < args.Length; i++) {
				var arg = args[i].ParameterType;

				ilg.Emit(ROpCodes.Ldarg_1);
				ilg.Emit(ROpCodes.Ldc_I4, i);
				ilg.Emit(ROpCodes.Ldelem_Ref);

				if (arg.IsValueType)
					ilg.Emit(ROpCodes.Unbox_Any, arg);
				else
					ilg.Emit(ROpCodes.Castclass, arg);
			}
			ilg.Emit(ROpCodes.Ldarg_0);

			var flags = BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.Instance;
			var invokeMethod = newMethodInfo.delegateType.GetMethod("Invoke", flags);
			ilg.Emit(ROpCodes.Call, invokeMethod);
			if (ResolverUtils.GetReturnType(newMethodInfo.oldMethod) == typeof(void))
				ilg.Emit(ROpCodes.Ldnull);
			ilg.Emit(ROpCodes.Ret);

			newMethodInfo.rewrittenMethod = (RewrittenMethod)dm.CreateDelegate(typeof(RewrittenMethod), this);
			return newMethodInfo.rewrittenMethod;
		}

		public void SetCaller(RewrittenMethod rewrittenMethod, MethodBase caller) {
			if (caller == null)
				return;
			var newMethodInfo = GetNewMethodInfo(rewrittenMethod.Method.Name);
			newStackMethodDict[newMethodInfo] = caller;
		}

		string GetDelegateMethodName(MethodBase method) {
			string name = null;
			do {
				name = $" {method.Name} {method.MetadataToken:X8} DMN {Utils.GetRandomUint():X8} ";
			} while (delegateNameToNewMethodInfo.ContainsKey(name));
			return name;
		}

		public void CreateMethod(MethodBase realMethod) {
			if (realMethodToNewMethod.ContainsKey(realMethod))
				return;
			var newMethodInfo = new NewMethodInfo(realMethod, newMethodInfos.Count, GetDelegateMethodName(realMethod), GetDelegateMethodName(realMethod));
			newMethodInfos.Add(newMethodInfo);
			delegateNameToNewMethodInfo[newMethodInfo.delegateMethodName] = newMethodInfo;
			delegateNameToNewMethodInfo[newMethodInfo.rewrittenMethodName] = newMethodInfo;
			realMethodToNewMethod[realMethod] = newMethodInfo;

			var moduleInfo = Resolver.LoadAssembly(realMethod.Module);
			var methodInfo = moduleInfo.GetMethod(realMethod);
			if (!methodInfo.HasInstructions())
				throw new ApplicationException($"Method {methodInfo.methodDef} ({methodInfo.methodDef.MDToken.Raw:X8}) has no body");

			var codeGenerator = new CodeGenerator(this, newMethodInfo.delegateMethodName);
			codeGenerator.SetMethodInfo(methodInfo);
			newMethodInfo.delegateType = codeGenerator.DelegateType;

			var blocks = new Blocks(methodInfo.methodDef);
			foreach (var block in blocks.MethodBlocks.GetAllBlocks())
				Update(block, newMethodInfo);

			blocks.GetCode(out var allInstructions, out var allExceptionHandlers);
			newMethodInfo.delegateInstance = codeGenerator.Generate(allInstructions, allExceptionHandlers);
		}

		static Instruction Create(OpCode opcode, object operand) =>
			new Instruction {
				OpCode = opcode,
				Operand = operand,
			};

		// Inserts ldarg THIS, and returns number of instructions inserted at 'i'
		int InsertLoadThis(Block block, int i) {
			block.Insert(i, Create(OpCodes.Ldarg, new Operand(Operand.Type.ThisArg)));
			return 1;
		}

		int InsertCallOurMethod(Block block, int i, string methodName) {
			block.Insert(i, Create(OpCodes.Call, new Operand(Operand.Type.OurMethod, methodName)));
			return 1;
		}

		void Update(Block block, NewMethodInfo currentMethodInfo) {
			var instrs = block.Instructions;
			for (int i = 0; i < instrs.Count; i++) {
				var instr = instrs[i];
				if (instr.OpCode == OpCodes.Newobj) {
					var ctor = (IMethod)instr.Operand;
					var ctorTypeFullName = ctor.DeclaringType.FullName;
					if (ctorTypeFullName == "System.Diagnostics.StackTrace") {
						InsertLoadThis(block, i + 1);
						InsertCallOurMethod(block, i + 2, "static_RtFixStackTrace");
						i += 2;
						continue;
					}
					else if (ctorTypeFullName == "System.Diagnostics.StackFrame") {
						InsertLoadThis(block, i + 1);
						InsertCallOurMethod(block, i + 2, "static_RtFixStackFrame");
						i += 2;
						continue;
					}
				}

				if (instr.OpCode == OpCodes.Call || instr.OpCode == OpCodes.Callvirt) {
					var calledMethod = (IMethod)instr.Operand;
					if (calledMethod.DeclaringType.DefinitionAssembly.IsCorLib()) {
						var calledMethodFullName = calledMethod.FullName;
						if (calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetAssembly(System.Type)") {
							block.Replace(i, 1, OpCodes.Nop.ToInstruction());
							InsertLoadThis(block, i + 1);
							InsertCallOurMethod(block, i + 2, "static_RtGetAssembly_TypeArg");
							i += 2;
							continue;
						}
						else if (calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetCallingAssembly()" ||
								calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetEntryAssembly()" ||
								calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetExecutingAssembly()") {
							block.Replace(i, 1, OpCodes.Nop.ToInstruction());
							InsertLoadThis(block, i + 1);
							block.Insert(i + 2, OpCodes.Ldc_I4.ToInstruction(currentMethodInfo.delegateIndex));
							InsertCallOurMethod(block, i + 3, "RtGetAssembly");
							i += 3;
							continue;
						}
					}

					var method = Resolver.GetMethod((IMethod)instr.Operand);
					if (method != null) {
						CreateMethod(method.methodBase);
						var newMethodInfo = realMethodToNewMethod[method.methodBase];

						block.Replace(i, 1, OpCodes.Nop.ToInstruction());
						int n = i + 1;

						// Pop all pushed args to a temp array
						var mparams = GetParameters(method.methodDef);
						if (mparams.Count > 0) {
							block.Insert(n++, OpCodes.Ldc_I4.ToInstruction(mparams.Count));
							var objectType = method.methodDef.DeclaringType.Module.CorLibTypes.Object;
							block.Insert(n++, OpCodes.Newarr.ToInstruction(objectType));
							block.Insert(n++, Create(OpCodes.Stloc, new Operand(Operand.Type.TempObjArray)));

							for (int j = mparams.Count - 1; j >= 0; j--) {
								var argType = mparams[j];
								if (argType.RemovePinnedAndModifiers().IsValueType)
									block.Insert(n++, OpCodes.Box.ToInstruction(((TypeDefOrRefSig)argType).TypeDefOrRef));
								block.Insert(n++, Create(OpCodes.Stloc, new Operand(Operand.Type.TempObj)));
								block.Insert(n++, Create(OpCodes.Ldloc, new Operand(Operand.Type.TempObjArray)));
								block.Insert(n++, OpCodes.Ldc_I4.ToInstruction(j));
								block.Insert(n++, Create(OpCodes.Ldloc, new Operand(Operand.Type.TempObj)));
								block.Insert(n++, OpCodes.Stelem_Ref.ToInstruction());
							}
						}

						// Push delegate instance
						InsertLoadThis(block, n++);
						block.Insert(n++, OpCodes.Ldc_I4.ToInstruction(newMethodInfo.delegateIndex));
						InsertCallOurMethod(block, n++, "RtGetDelegateInstance");
						block.Insert(n++, Create(OpCodes.Castclass, new Operand(Operand.Type.ReflectionType, newMethodInfo.delegateType)));

						// Push all popped args
						if (mparams.Count > 0) {
							for (int j = 0; j < mparams.Count; j++) {
								block.Insert(n++, Create(OpCodes.Ldloc, new Operand(Operand.Type.TempObjArray)));
								block.Insert(n++, OpCodes.Ldc_I4.ToInstruction(j));
								block.Insert(n++, OpCodes.Ldelem_Ref.ToInstruction());
								var argType = mparams[j];
								if (argType.RemovePinnedAndModifiers().IsValueType)
									block.Insert(n++, OpCodes.Unbox_Any.ToInstruction(((TypeDefOrRefSig)argType).TypeDefOrRef));
								else {
									// Don't cast it to its correct type. This will sometimes cause
									// an exception in some EF obfuscated assembly since we'll be
									// trying to cast a System.Reflection.AssemblyName type to some
									// other type.
									// block.insert(n++, Instruction.Create(OpCodes.Castclass, argType.ToTypeDefOrRef()));
								}
							}
						}

						InsertLoadThis(block, n++);
						block.Insert(n++, Create(OpCodes.Call, new Operand(Operand.Type.NewMethod, method.methodBase)));
						i = n - 1;
						continue;
					}
				}
			}
		}

		static IList<TypeSig> GetParameters(MethodDef method) {
			var list = new List<TypeSig>(method.Parameters.Count);
			for (int i = 0; i < method.Parameters.Count; i++)
				list.Add(method.Parameters[i].Type);
			return list;
		}

		static FieldInfo GetStackTraceStackFramesField() {
			var flags = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance;
			return ResolverUtils.GetFieldThrow(typeof(StackTrace), typeof(StackFrame[]), flags, "Could not find StackTrace's frames (StackFrame[]) field");
		}

		static FieldInfo GetStackFrameMethodField() {
			var flags = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance;
			return ResolverUtils.GetFieldThrow(typeof(StackFrame), typeof(MethodBase), flags, "Could not find StackFrame's method (MethodBase) field");
		}

		static void WriteMethodBase(StackFrame frame, MethodBase method) {
			var methodField = GetStackFrameMethodField();
			methodField.SetValue(frame, method);
			if (frame.GetMethod() != method)
				throw new ApplicationException($"Could not set new method: {method}");
		}

		NewMethodInfo GetNewMethodInfo(string name) {
			delegateNameToNewMethodInfo.TryGetValue(name, out var info);
			return info;
		}

		// Called after the StackTrace ctor has been called.
		static StackTrace static_RtFixStackTrace(StackTrace stackTrace, MethodsRewriter self) => self.RtFixStackTrace(stackTrace);

		StackTrace RtFixStackTrace(StackTrace stackTrace) {
			var framesField = GetStackTraceStackFramesField();
			var frames = (StackFrame[])framesField.GetValue(stackTrace);

			var newFrames = new List<StackFrame>(frames.Length);
			foreach (var frame in frames) {
				FixStackFrame(frame);
				newFrames.Add(frame);
			}

			framesField.SetValue(stackTrace, newFrames.ToArray());
			return stackTrace;
		}

		static StackFrame static_RtFixStackFrame(StackFrame stackFrame, MethodsRewriter self) => self.RtFixStackFrame(stackFrame);

		StackFrame RtFixStackFrame(StackFrame frame) {
			FixStackFrame(frame);
			return frame;
		}

		void FixStackFrame(StackFrame frame) {
			var method = frame.GetMethod();
			var info = GetNewMethodInfo(method.Name);
			if (info == null)
				return;

			if (newStackMethodDict.TryGetValue(info, out var stackMethod)) {
				WriteMethodBase(frame, stackMethod);
			}
			else if (info.IsRewrittenMethod(method.Name)) {
				// Write random method from the same module
				WriteMethodBase(frame, methodsFinder.GetMethod(info.oldMethod.Module));
			}
			else if (info.IsDelegateMethod(method.Name)) {
				// Write original method
				WriteMethodBase(frame, info.oldMethod);
			}
			else
				throw new ApplicationException("BUG: Shouldn't be here");
		}

		// Called when the code calls GetCallingAssembly(), GetEntryAssembly(), or GetExecutingAssembly()
		Assembly RtGetAssembly(int delegateIndex) => newMethodInfos[delegateIndex].oldMethod.Module.Assembly;

		// Called when the code calls GetAssembly(Type)
		static Assembly static_RtGetAssembly_TypeArg(Type type, MethodsRewriter self) => self.RtGetAssembly_TypeArg(type);
		Assembly RtGetAssembly_TypeArg(Type type) => Assembly.GetAssembly(type);
		Delegate RtGetDelegateInstance(int delegateIndex) => newMethodInfos[delegateIndex].delegateInstance;
	}
}



================================================
File: AssemblyData/methodsrewriter/Operand.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

namespace AssemblyData.methodsrewriter {
	class Operand {
		public enum Type {
			ThisArg,		// Replace operand with the 'this' arg
			TempObj,		// Replace operand with temp object local variable
			TempObjArray,	// Replace operand with temp object[] local variable
			OurMethod,		// Replace operand with a call to our method. methodName must be unique.
			NewMethod,		// Replace operand with a call to new method. data is realMethod
			ReflectionType,	// Replace operand with a .NET type
		}

		public Type type;
		public object data;

		public Operand(Type type) {
			this.type = type;
			data = null;
		}

		public Operand(Type type, object data) {
			this.type = type;
			this.data = data;
		}

		public override string ToString() => "{" + type + " => " + data + "}";
	}
}



================================================
File: AssemblyData/methodsrewriter/Resolver.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Reflection;
using dnlib.DotNet;

namespace AssemblyData.methodsrewriter {
	static class Resolver {
		static Dictionary<string, AssemblyResolver> assemblyResolvers = new Dictionary<string, AssemblyResolver>(StringComparer.Ordinal);
		static Dictionary<Module, MModule> modules = new Dictionary<Module, MModule>();

		public static MModule LoadAssembly(Module module) {
			if (modules.TryGetValue(module, out var info))
				return info;

			info = new MModule(module, ModuleDefMD.Load(module.FullyQualifiedName));
			modules[module] = info;
			return info;
		}

		static MModule GetModule(ModuleDef moduleDef) {
			foreach (var mm in modules.Values) {
				if (mm.moduleDef == moduleDef)
					return mm;
			}
			return null;
		}

		static MModule GetModule(AssemblyRef asmRef) {
			foreach (var mm in modules.Values) {
				var asm = mm.moduleDef.Assembly;
				if (asm != null && asm.FullName == asmRef.FullName)
					return mm;
			}
			return null;
		}

		public static MModule GetModule(IScope scope) {
			if (scope.ScopeType == ScopeType.ModuleDef)
				return GetModule((ModuleDef)scope);
			else if (scope.ScopeType == ScopeType.AssemblyRef)
				return GetModule((AssemblyRef)scope);

			return null;
		}

		public static MType GetType(IType typeRef) {
			if (typeRef == null)
				return null;
			var module = GetModule(typeRef.Scope);
			if (module != null)
				return module.GetType(typeRef);
			return null;
		}

		public static MMethod GetMethod(IMethod methodRef) {
			if (methodRef == null)
				return null;
			var module = GetModule(methodRef.DeclaringType.Scope);
			if (module != null)
				return module.GetMethod(methodRef);
			return null;
		}

		public static MField GetField(IField fieldRef) {
			if (fieldRef == null)
				return null;
			var module = GetModule(fieldRef.DeclaringType.Scope);
			if (module != null)
				return module.GetField(fieldRef);
			return null;
		}

		public static object GetRtObject(ITokenOperand memberRef) {
			if (memberRef == null)
				return null;
			if (memberRef is ITypeDefOrRef tdr)
				return GetRtType(tdr);
			if (memberRef is IField field && field.FieldSig != null)
				return GetRtField(field);
			if (memberRef is IMethod method && method.MethodSig != null)
				return GetRtMethod(method);

			throw new ApplicationException($"Unknown MemberRef: {memberRef}");
		}

		public static Type GetRtType(IType typeRef) {
			var mtype = GetType(typeRef);
			if (mtype != null)
				return mtype.type;

			return Resolver.Resolve(typeRef);
		}

		public static FieldInfo GetRtField(IField fieldRef) {
			var mfield = GetField(fieldRef);
			if (mfield != null)
				return mfield.fieldInfo;

			return Resolver.Resolve(fieldRef);
		}

		public static MethodBase GetRtMethod(IMethod methodRef) {
			var mmethod = GetMethod(methodRef);
			if (mmethod != null)
				return mmethod.methodBase;

			return Resolver.Resolve(methodRef);
		}

		static AssemblyResolver GetAssemblyResolver(ITypeDefOrRef type) {
			var asmName = type.DefinitionAssembly.FullName;
			if (!assemblyResolvers.TryGetValue(asmName, out var resolver))
				assemblyResolvers[asmName] = resolver = new AssemblyResolver(asmName);
			return resolver;
		}

		static Type Resolve(IType typeRef) {
			if (typeRef == null)
				return null;
			var scopeType = typeRef.ScopeType;
			var resolver = GetAssemblyResolver(scopeType);
			var resolvedType = resolver.Resolve(scopeType);
			if (resolvedType != null)
				return FixType(typeRef, resolvedType);
			throw new ApplicationException($"Could not resolve type {typeRef} ({typeRef.MDToken.Raw:X8}) in assembly {resolver}");
		}

		static FieldInfo Resolve(IField fieldRef) {
			if (fieldRef == null)
				return null;
			var resolver = GetAssemblyResolver(fieldRef.DeclaringType);
			var fieldInfo = resolver.Resolve(fieldRef);
			if (fieldInfo != null)
				return fieldInfo;
			throw new ApplicationException($"Could not resolve field {fieldRef} ({fieldRef.MDToken.Raw:X8}) in assembly {resolver}");
		}

		static MethodBase Resolve(IMethod methodRef) {
			if (methodRef == null)
				return null;
			var resolver = GetAssemblyResolver(methodRef.DeclaringType);
			var methodBase = resolver.Resolve(methodRef);
			if (methodBase != null)
				return methodBase;
			throw new ApplicationException($"Could not resolve method {methodRef} ({methodRef.MDToken.Raw:X8}) in assembly {resolver}");
		}

		static Type FixType(IType typeRef, Type type) {
			var sig = typeRef as TypeSig;
			if (sig == null) {
				if (typeRef is TypeSpec ts)
					sig = ts.TypeSig;
			}
			while (sig != null) {
				switch (sig.ElementType) {
				case ElementType.SZArray:
					type = type.MakeArrayType();
					break;

				case ElementType.Array:
					type = type.MakeArrayType((int)((ArraySig)sig).Rank);
					break;

				case ElementType.ByRef:
					type = type.MakeByRefType();
					break;

				case ElementType.Ptr:
					type = type.MakePointerType();
					break;

				case ElementType.GenericInst:
					var git = (GenericInstSig)sig;
					var args = new Type[git.GenericArguments.Count];
					bool isGenericTypeDef = true;
					for (int i = 0; i < args.Length; i++) {
						var arg = git.GenericArguments[i];
						if (!(arg is GenericSig))
							isGenericTypeDef = false;
						args[i] = Resolver.Resolve(arg);
					}
					if (!isGenericTypeDef)
						type = type.MakeGenericType(args);
					break;

				default:
					break;
				}

				sig = sig.Next;
			}
			return type;
		}
	}
}



================================================
File: AssemblyData/methodsrewriter/ResolverUtils.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Reflection;
using dnlib.DotNet;

namespace AssemblyData.methodsrewriter {
	static class ResolverUtils {
		public static bool CompareTypes(Type a, IType b) => new SigComparer().Equals(a, b);
		public static bool CompareFields(FieldInfo a, IField b) => new SigComparer().Equals(a, b);
		public static bool HasThis(MethodBase method) => (method.CallingConvention & CallingConventions.HasThis) != 0;
		public static bool ExplicitThis(MethodBase method) => (method.CallingConvention & CallingConventions.ExplicitThis) != 0;
		public static bool CompareMethods(MethodBase a, IMethod b) => new SigComparer().Equals(a, b);

		public static Type GetReturnType(MethodBase methodBase) {
			if (methodBase is MethodInfo methodInfo)
				return methodInfo.ReturnType;

			if (methodBase is ConstructorInfo ctorInfo)
				return typeof(void);

			throw new ApplicationException($"Could not figure out return type: {methodBase} ({methodBase.MetadataToken:X8})");
		}

		public static Type[] GetGenericArguments(MethodBase methodBase) {
			try {
				return methodBase.GetGenericArguments();
			}
			catch (NotSupportedException) {
				return new Type[0];
			}
		}

		public static IEnumerable<MethodBase> GetMethodBases(Type type, BindingFlags flags) {
			if (type.TypeInitializer != null)
				yield return type.TypeInitializer;
			foreach (var ctor in type.GetConstructors(flags))
				yield return ctor;
			foreach (var m in type.GetMethods(flags))
				yield return m;
		}

		class CachedMemberInfo {
			Type type;
			Type memberType;
			public CachedMemberInfo(Type type, Type memberType) {
				this.type = type;
				this.memberType = memberType;
			}

			public override int GetHashCode() => type.GetHashCode() ^ memberType.GetHashCode();

			public override bool Equals(object obj) {
				var other = obj as CachedMemberInfo;
				if (other == null)
					return false;
				return type == other.type && memberType == other.memberType;
			}
		}

		static Dictionary<CachedMemberInfo, FieldInfo> cachedFieldInfos = new Dictionary<CachedMemberInfo, FieldInfo>();
		public static FieldInfo GetField(Type type, Type fieldType, BindingFlags flags) {
			var key = new CachedMemberInfo(type, fieldType);
			if (cachedFieldInfos.TryGetValue(key, out var fieldInfo))
				return fieldInfo;

			foreach (var field in type.GetFields(flags)) {
				if (field.FieldType == fieldType) {
					cachedFieldInfos[key] = field;
					return field;
				}
			}
			return null;
		}

		public static FieldInfo GetFieldThrow(Type type, Type fieldType, BindingFlags flags, string msg) {
			var info = GetField(type, fieldType, flags);
			if (info != null)
				return info;
			throw new ApplicationException(msg);
		}

		public static List<FieldInfo> GetFields(Type type, Type fieldType, BindingFlags flags) {
			var list = new List<FieldInfo>();
			foreach (var field in type.GetFields(flags)) {
				if (field.FieldType == fieldType)
					list.Add(field);
			}
			return list;
		}

		public static Type MakeInstanceType(Type type, ITypeDefOrRef typeRef) {
			var ts = typeRef as TypeSpec;
			if (ts == null)
				return type;
			var git = ts.TypeSig as GenericInstSig;
			if (git == null)
				return type;
			var types = new Type[git.GenericArguments.Count];
			bool isTypeDef = true;
			for (int i = 0; i < git.GenericArguments.Count; i++) {
				var arg = git.GenericArguments[i];
				if (!(arg is GenericSig))
					isTypeDef = false;
				types[i] = Resolver.GetRtType(arg);
			}
			if (isTypeDef)
				return type;
			return type.MakeGenericType(types);
		}
	}
}



================================================
File: AssemblyData/methodsrewriter/TypeInstanceResolver.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Reflection;
using dnlib.DotNet;
using de4dot.blocks;

namespace AssemblyData.methodsrewriter {
	class TypeInstanceResolver {
		Type type;
		Dictionary<string, List<MethodBase>> methods;
		Dictionary<string, List<FieldInfo>> fields;

		public TypeInstanceResolver(Type type, ITypeDefOrRef typeRef) => this.type = ResolverUtils.MakeInstanceType(type, typeRef);

		public FieldInfo Resolve(IField fieldRef) {
			InitFields();

			if (!fields.TryGetValue(fieldRef.Name.String, out var list))
				return null;

			fieldRef = GenericArgsSubstitutor.Create(fieldRef, fieldRef.DeclaringType.TryGetGenericInstSig());

			foreach (var field in list) {
				if (ResolverUtils.CompareFields(field, fieldRef))
					return field;
			}

			return null;
		}

		void InitFields() {
			if (fields != null)
				return;
			fields = new Dictionary<string, List<FieldInfo>>(StringComparer.Ordinal);

			var flags = BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance;
			foreach (var field in type.GetFields(flags)) {
				if (!fields.TryGetValue(field.Name, out var list))
					fields[field.Name] = list = new List<FieldInfo>();
				list.Add(field);
			}
		}

		public MethodBase Resolve(IMethod methodRef) {
			InitMethods();

			if (!methods.TryGetValue(methodRef.Name.String, out var list))
				return null;

			methodRef = GenericArgsSubstitutor.Create(methodRef, methodRef.DeclaringType.TryGetGenericInstSig());

			foreach (var method in list) {
				if (ResolverUtils.CompareMethods(method, methodRef))
					return method;
			}

			return null;
		}

		void InitMethods() {
			if (methods != null)
				return;
			methods = new Dictionary<string, List<MethodBase>>(StringComparer.Ordinal);

			var flags = BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance;
			foreach (var method in ResolverUtils.GetMethodBases(type, flags)) {
				if (!methods.TryGetValue(method.Name, out var list))
					methods[method.Name] = list = new List<MethodBase>();
				list.Add(method);
			}
		}
	}
}



================================================
File: AssemblyData/methodsrewriter/TypeResolver.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Reflection;
using dnlib.DotNet;

namespace AssemblyData.methodsrewriter {
	class TypeResolver {
		public Type type;
		Dictionary<ITypeDefOrRef, TypeInstanceResolver> typeRefToInstance = new Dictionary<ITypeDefOrRef, TypeInstanceResolver>(TypeEqualityComparer.Instance);

		public TypeResolver(Type type) => this.type = type;

		TypeInstanceResolver GetTypeInstance(ITypeDefOrRef typeRef) {
			if (!typeRefToInstance.TryGetValue(typeRef, out var instance))
				typeRefToInstance[typeRef] = instance = new TypeInstanceResolver(type, typeRef);
			return instance;
		}

		public FieldInfo Resolve(IField fieldRef) => GetTypeInstance(fieldRef.DeclaringType).Resolve(fieldRef);
		public MethodBase Resolve(IMethod methodRef) => GetTypeInstance(methodRef.DeclaringType).Resolve(methodRef);
	}
}



================================================
File: AssemblyServer/App.config
================================================
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
	<startup>
		<supportedRuntime version="v4.0"/>
		<supportedRuntime version="v2.0.50727"/>
	</startup>
	<runtime>
		<loadFromRemoteSources enabled="true"/>
	</runtime>
</configuration>



================================================
File: AssemblyServer/AssemblyServer.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">

  <Import Project="..\De4DotCommon.props" />

  <PropertyGroup>
    <PlatformTarget>x86</PlatformTarget>
    <OutputType>Exe</OutputType>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\AssemblyData\AssemblyData.csproj" />
  </ItemGroup>

</Project>



================================================
File: AssemblyServer/Program.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

namespace AssemblyServer_x86 {
	class Program {
		static int Main(string[] args) => AssemblyServer.Start.Main(args);
	}
}



================================================
File: AssemblyServer-CLR20/App.config
================================================
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
	<startup>
		<supportedRuntime version="v2.0.50727"/>
	</startup>
	<runtime>
		<loadFromRemoteSources enabled="true"/>
	</runtime>
</configuration>



================================================
File: AssemblyServer-CLR20/AssemblyServer-CLR20.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">

  <Import Project="..\De4DotCommon.props" />

  <PropertyGroup>
    <PlatformTarget>x86</PlatformTarget>
    <OutputType>Exe</OutputType>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\AssemblyData\AssemblyData.csproj" />
  </ItemGroup>

</Project>



================================================
File: AssemblyServer-CLR20/Program.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

namespace AssemblyServer_CLR20 {
	class Program {
		static int Main(string[] args) => AssemblyServer.Start.Main(args);
	}
}



================================================
File: AssemblyServer-CLR20-x64/App.config
================================================
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
	<startup>
		<supportedRuntime version="v2.0.50727"/>
	</startup>
	<runtime>
		<loadFromRemoteSources enabled="true"/>
	</runtime>
</configuration>



================================================
File: AssemblyServer-CLR20-x64/AssemblyServer-CLR20-x64.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">

  <Import Project="..\De4DotCommon.props" />

  <PropertyGroup>
    <PlatformTarget>x64</PlatformTarget>
    <OutputType>Exe</OutputType>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\AssemblyData\AssemblyData.csproj" />
  </ItemGroup>

</Project>



================================================
File: AssemblyServer-CLR20-x64/Program.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

namespace AssemblyServer_CLR20_x64 {
	class Program {
		static int Main(string[] args) => AssemblyServer.Start.Main(args);
	}
}



================================================
File: AssemblyServer-CLR40/App.config
================================================
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
	<startup>
		<supportedRuntime version="v4.0"/>
	</startup>
	<runtime>
		<loadFromRemoteSources enabled="true"/>
	</runtime>
</configuration>



================================================
File: AssemblyServer-CLR40/AssemblyServer-CLR40.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">

  <Import Project="..\De4DotCommon.props" />

  <PropertyGroup>
    <PlatformTarget>x86</PlatformTarget>
    <OutputType>Exe</OutputType>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\AssemblyData\AssemblyData.csproj" />
  </ItemGroup>

</Project>



================================================
File: AssemblyServer-CLR40/Program.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

namespace AssemblyServer_CLR40 {
	class Program {
		static int Main(string[] args) => AssemblyServer.Start.Main(args);
	}
}



================================================
File: AssemblyServer-CLR40-x64/App.config
================================================
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
	<startup>
		<supportedRuntime version="v4.0"/>
	</startup>
	<runtime>
		<loadFromRemoteSources enabled="true"/>
	</runtime>
</configuration>



================================================
File: AssemblyServer-CLR40-x64/AssemblyServer-CLR40-x64.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">

  <Import Project="..\De4DotCommon.props" />

  <PropertyGroup>
    <PlatformTarget>x64</PlatformTarget>
    <OutputType>Exe</OutputType>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\AssemblyData\AssemblyData.csproj" />
  </ItemGroup>

</Project>



================================================
File: AssemblyServer-CLR40-x64/Program.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

namespace AssemblyServer_CLR40_x64 {
	class Program {
		static int Main(string[] args) => AssemblyServer.Start.Main(args);
	}
}



================================================
File: AssemblyServer-x64/App.config
================================================
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
	<startup>
		<supportedRuntime version="v4.0"/>
		<supportedRuntime version="v2.0.50727"/>
	</startup>
	<runtime>
		<loadFromRemoteSources enabled="true"/>
	</runtime>
</configuration>



================================================
File: AssemblyServer-x64/AssemblyServer-x64.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">

  <Import Project="..\De4DotCommon.props" />

  <PropertyGroup>
    <PlatformTarget>x64</PlatformTarget>
    <OutputType>Exe</OutputType>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\AssemblyData\AssemblyData.csproj" />
  </ItemGroup>

</Project>



================================================
File: AssemblyServer-x64/Program.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

namespace AssemblyServer_x64 {
	class Program {
		static int Main(string[] args) => AssemblyServer.Start.Main(args);
	}
}



================================================
File: Test.Rename/Program.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

namespace Test.Rename {
	namespace test1 {
		public class Class1 : Test.Rename.Dll.test.pub1.Class1 {
			public override int Prop2 {
				get { return 1; }
			}
			public override int Prop3 {
				set { }
			}
			public override void meth1(int i) { }
			public override void meth1(string s) { }
		}
	}

	namespace test2 {
		public class Class1 : Test.Rename.Dll.test.pub2.IFace1 {
			public void meth1(int i) { }
			public void meth1(string s) { }
		}
		public class Class2 : Test.Rename.Dll.test.pub2.IFace1 {
			void Test.Rename.Dll.test.pub2.IFace1.meth1(int i) { }
			void Test.Rename.Dll.test.pub2.IFace1.meth1(string s) { }
		}
	}

	namespace test3 {
		public class Class1 : Test.Rename.Dll.test.pub3.Class1<int>.IFace1<string> {
			public void meth1(int t) { }
			public void meth1(string u) { }
			public void meth1<V>(V v) { }
		}
		public class Class2 : Test.Rename.Dll.test.pub3.Class1<int>.IFace1<string> {
			void Test.Rename.Dll.test.pub3.Class1<int>.IFace1<string>.meth1(int t) { }
			void Test.Rename.Dll.test.pub3.Class1<int>.IFace1<string>.meth1(string u) { }
			void Test.Rename.Dll.test.pub3.Class1<int>.IFace1<string>.meth1<V>(V v) { }
		}
	}

	namespace test4 {
		public interface IFace {
			void meth1(int i);
			void meth1(string s);
		}
		public class Class1 : Test.Rename.Dll.test.pub4.Class1.EnclosedClass, IFace {
			public override void meth1() { }
			public void meth1(string s) { }
		}
	}

	namespace test5 {
		public class Class1 : Test.Rename.Dll.test.pub5.Class1, Test.Rename.Dll.test.pub5.IFace1 {
			// The C# compiler will create a private virtual method for us, calling Class1's
			// non-virtual method.
		}
	}

	class Program {
		static void Main(string[] args) {
		}
	}
}



================================================
File: Test.Rename/Test.Rename.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">

  <Import Project="..\De4DotCommon.props" />

  <PropertyGroup>
    <OutputType>Exe</OutputType>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\Test.Rename.Dll\Test.Rename.Dll.csproj" />
  </ItemGroup>

</Project>



================================================
File: de4dot/App.config
================================================
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
	<startup>
		<supportedRuntime version="v4.0"/>
		<supportedRuntime version="v2.0.50727"/>
	</startup>
	<runtime>
		<assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
			<probing privatePath="bin"/>
		</assemblyBinding>
		<loadFromRemoteSources enabled="true"/>
	</runtime>
</configuration>



================================================
File: de4dot/Program.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

namespace de4dot_x86 {
	class Program {
		static int Main(string[] args) => de4dot.cui.Program.Main(args);
	}
}



================================================
File: de4dot/de4dot.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">

  <Import Project="..\De4DotCommon.props" />

  <PropertyGroup>
    <!-- Only force x86 if it's .NET Framework. If it's .NET Core, we must use AnyCPU so it can be started by 32-bit and 64-bit dotnet -->
    <PlatformTarget Condition=" '$(De4DotNetFramework)' == 'true' ">x86</PlatformTarget>
    <OutputType>Exe</OutputType>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\de4dot.cui\de4dot.cui.csproj" />
  </ItemGroup>

   <ItemGroup>
    <LicenseFiles Include="$(MSBuildThisFileDirectory)\..\LICENSE.*" />
    <LicenseFiles Include="$(MSBuildThisFileDirectory)\..\COPYING" />
  </ItemGroup>

  <Target Name="CopyLicenseFiles_AfterBuild" AfterTargets="AfterBuild">
    <Copy SourceFiles="@(LicenseFiles)" DestinationFolder="$(TargetDir)LICENSES" />
  </Target>

  <Target Name="CopyLicenseFiles_Publish" AfterTargets="Publish">
    <Copy SourceFiles="@(LicenseFiles)" DestinationFolder="$(PublishDir)LICENSES" />
  </Target>

</Project>



================================================
File: de4dot-x64/App.config
================================================
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
	<startup>
		<supportedRuntime version="v4.0"/>
		<supportedRuntime version="v2.0.50727"/>
	</startup>
	<runtime>
		<assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
			<probing privatePath="bin"/>
		</assemblyBinding>
		<loadFromRemoteSources enabled="true"/>
	</runtime>
</configuration>



================================================
File: de4dot-x64/Program.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

namespace de4dot_x64 {
	class Program {
		static int Main(string[] args) => de4dot.cui.Program.Main(args);
	}
}



================================================
File: de4dot-x64/de4dot-x64.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">

  <Import Project="..\De4DotCommon.props" />

  <PropertyGroup>
    <PlatformTarget>x64</PlatformTarget>
    <OutputType>Exe</OutputType>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\de4dot.cui\de4dot.cui.csproj" />
  </ItemGroup>

</Project>



================================================
File: de4dot.blocks/BaseBlock.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

namespace de4dot.blocks {
	public abstract class BaseBlock {
		ScopeBlock parent = null;

		public ScopeBlock Parent {
			get => parent;
			set => parent = value;
		}
	}
}



================================================
File: de4dot.blocks/Block.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet.Emit;

namespace de4dot.blocks {
	public class Block : BaseBlock {
		List<Instr> instructions = new List<Instr>();

		// List of all explicit (non-fall-through) targets. It's just one if it's a normal
		// branch, but if it's a switch, it could be many targets.
		List<Block> targets;

		// This is the fall through Block (non branch instructions)
		Block fallThrough;

		// All blocks that fall through or branches to this block
		List<Block> sources = new List<Block>();

		public Block FallThrough {
			get => fallThrough;
			set => fallThrough = value;
		}

		public List<Block> Targets {
			get => targets;
			set => targets = value;
		}

		public List<Block> Sources => sources;

		public Instr FirstInstr {
			get {
				if (instructions.Count == 0)
					Add(new Instr(OpCodes.Nop.ToInstruction()));
				return instructions[0];
			}
		}

		public Instr LastInstr {
			get {
				if (instructions.Count == 0)
					Add(new Instr(OpCodes.Nop.ToInstruction()));
				return instructions[instructions.Count - 1];
			}
		}

		public void Add(Instr instr) => instructions.Add(instr);
		public void Insert(int index, Instruction instr) => instructions.Insert(index, new Instr(instr));

		public List<Instr> Instructions => instructions;

		// If last instr is a br/br.s, removes it and replaces it with a fall through
		public void RemoveLastBr() {
			if (!LastInstr.IsBr())
				return;

			if (fallThrough != null || (LastInstr.Operand != null && (targets == null || targets.Count != 1)))
				throw new ApplicationException("Invalid block state when last instr is a br/br.s");
			fallThrough = LastInstr.Operand != null ? targets[0] : null;
			targets = null;
			instructions.RemoveAt(instructions.Count - 1);
		}

		public void Replace(int index, int num, Instruction instruction) {
			if (num <= 0)
				throw new ArgumentOutOfRangeException("num");
			Remove(index, num);
			instructions.Insert(index, new Instr(instruction));
		}

		public void Remove(int index, int num) {
			if (index + num > instructions.Count)
				throw new ApplicationException("Overflow");
			if (num > 0 && index + num == instructions.Count && LastInstr.IsConditionalBranch())
				DisconnectFromFallThroughAndTargets();
			instructions.RemoveRange(index, num);
		}

		public void Remove(IEnumerable<int> indexes) {
			var instrsToDelete = new List<int>(Utils.Unique(indexes));
			instrsToDelete.Sort();
			instrsToDelete.Reverse();
			foreach (var index in instrsToDelete)
				Remove(index, 1);
		}

		// Replace the last instructions with a branch to target
		public void ReplaceLastInstrsWithBranch(int numInstrs, Block target) {
			if (numInstrs < 0 || numInstrs > instructions.Count)
				throw new ApplicationException("Invalid numInstrs to replace with branch");
			if (target == null)
				throw new ApplicationException("Invalid new target, it's null");

			DisconnectFromFallThroughAndTargets();
			if (numInstrs > 0)
				instructions.RemoveRange(instructions.Count - numInstrs, numInstrs);
			fallThrough = target;
			target.sources.Add(this);
		}

		public void ReplaceLastNonBranchWithBranch(int numInstrs, Block target) {
			if (LastInstr.IsBr())
				numInstrs++;
			ReplaceLastInstrsWithBranch(numInstrs, target);
		}

		public void ReplaceBccWithBranch(bool isTaken) => ReplaceLastInstrsWithBranch(1, isTaken ? targets[0] : fallThrough);

		public void ReplaceSwitchWithBranch(Block target) {
			if (LastInstr.OpCode.Code != Code.Switch)
				throw new ApplicationException("Last instruction is not a switch");
			ReplaceLastInstrsWithBranch(1, target);
		}

		public void SetNewFallThrough(Block newFallThrough) {
			DisconnectFromFallThrough();
			fallThrough = newFallThrough;
			newFallThrough.sources.Add(this);
		}

		public void SetNewTarget(int index, Block newTarget) {
			DisconnectFromBlock(targets[index]);
			targets[index] = newTarget;
			newTarget.sources.Add(this);
		}

		public void RemoveDeadBlock() {
			if (sources.Count != 0)
				throw new ApplicationException("Trying to remove a non-dead block");
			RemoveGuaranteedDeadBlock();
		}

		// Removes a block that has been guaranteed to be dead. This method won't verify
		// that it really is dead.
		public void RemoveGuaranteedDeadBlock() {
			DisconnectFromFallThroughAndTargets();
			Parent = null;
		}

		void DisconnectFromFallThroughAndTargets() {
			DisconnectFromFallThrough();
			DisconnectFromTargets();
		}

		void DisconnectFromFallThrough() {
			if (fallThrough != null) {
				DisconnectFromBlock(fallThrough);
				fallThrough = null;
			}
		}

		void DisconnectFromTargets() {
			if (targets != null) {
				foreach (var target in targets)
					DisconnectFromBlock(target);
				targets = null;
			}
		}

		void DisconnectFromBlock(Block target) {
			if (!target.sources.Remove(this))
				throw new ApplicationException("Could not remove the block from its target block");
		}

		public int CountTargets() {
			int count = fallThrough != null ? 1 : 0;
			if (targets != null)
				count += targets.Count;
			return count;
		}

		// Returns the target iff it has only ONE target. Else it returns null.
		public Block GetOnlyTarget() {
			if (CountTargets() != 1)
				return null;
			if (fallThrough != null)
				return fallThrough;
			return targets[0];
		}

		// Returns all targets. FallThrough (if not null) is always returned first!
		public IEnumerable<Block> GetTargets() {
			if (fallThrough != null)
				yield return fallThrough;
			if (targets != null) {
				foreach (var block in targets)
					yield return block;
			}
		}

		// Returns true iff other is the only block in Sources
		public bool IsOnlySource(Block other) => sources.Count == 1 && sources[0] == other;

		// Returns true if we can merge other with this
		public bool CanMerge(Block other) => CanAppend(other) && other.IsOnlySource(this);

		// Merge two blocks into one
		public void Merge(Block other) {
			if (!CanMerge(other))
				throw new ApplicationException("Can't merge the two blocks!");
			Append(other);
			other.DisconnectFromFallThroughAndTargets();
			other.Parent = null;
		}

		public bool CanAppend(Block other) {
			if (other == null || other == this || GetOnlyTarget() != other)
				return false;
			// If it's eg. a leave, then don't merge them since it clears the stack.
			return LastInstr.IsBr() || Instr.IsFallThrough(LastInstr.OpCode);
		}

		public void Append(Block other) {
			if (!CanAppend(other))
				throw new ApplicationException("Can't append the block!");

			RemoveLastBr();		// Get rid of last br/br.s if present

			var newInstructions = new List<Instr>(instructions.Count + other.instructions.Count);
			AddInstructions(newInstructions, instructions, false);
			AddInstructions(newInstructions, other.instructions, true);
			instructions = newInstructions;

			DisconnectFromFallThroughAndTargets();
			if (other.targets != null)
				targets = new List<Block>(other.targets);
			else
				targets = null;
			fallThrough = other.fallThrough;
			UpdateSources();
		}

		void AddInstructions(IList<Instr> dest, IList<Instr> instrs, bool clone) {
			for (int i = 0; i < instrs.Count; i++) {
				var instr = instrs[i];
				if (instr.OpCode != OpCodes.Nop)
					dest.Add(clone ? new Instr(instr.Instruction.Clone()) : instr);
			}
		}

		// Update each target's Sources property. Must only be called if this isn't in the
		// Sources list!
		public void UpdateSources() {
			if (fallThrough != null)
				fallThrough.sources.Add(this);
			if (targets != null) {
				foreach (var target in targets)
					target.sources.Add(this);
			}
		}

		// Returns true if it falls through
		public bool IsFallThrough() => targets == null && fallThrough != null;

		public bool CanFlipConditionalBranch() => LastInstr.CanFlipConditionalBranch();

		public void FlipConditionalBranch() {
			if (fallThrough == null || targets == null || targets.Count != 1)
				throw new ApplicationException("Invalid bcc block state");
			LastInstr.FlipConditonalBranch();
			var oldFallThrough = fallThrough;
			fallThrough = targets[0];
			targets[0] = oldFallThrough;
		}

		// Returns true if it's a conditional branch
		public bool IsConditionalBranch() => LastInstr.IsConditionalBranch();

		public bool IsNopBlock() {
			if (!IsFallThrough())
				return false;
			foreach (var instr in instructions) {
				if (instr.OpCode.Code != Code.Nop)
					return false;
			}
			return true;
		}
	}
}



================================================
File: de4dot.blocks/Blocks.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace de4dot.blocks {
	public class Blocks {
		MethodDef method;
		IList<Local> locals;
		MethodBlocks methodBlocks;

		public MethodBlocks MethodBlocks => methodBlocks;
		public IList<Local> Locals => locals;
		public MethodDef Method => method;

		public Blocks(MethodDef method) {
			this.method = method;
			UpdateBlocks();
		}

		public void UpdateBlocks() {
			var body = method.Body;
			locals = body.Variables;
			methodBlocks = new InstructionListParser(body.Instructions, body.ExceptionHandlers).Parse();
		}

		IEnumerable<ScopeBlock> GetAllScopeBlocks(ScopeBlock scopeBlock) {
			var list = new List<ScopeBlock>();
			list.Add(scopeBlock);
			list.AddRange(scopeBlock.GetAllScopeBlocks());
			return list;
		}

		public int RemoveDeadBlocks() => new DeadBlocksRemover(methodBlocks).Remove();

		public void GetCode(out IList<Instruction> allInstructions, out IList<ExceptionHandler> allExceptionHandlers) =>
			new CodeGenerator(methodBlocks).GetCode(out allInstructions, out allExceptionHandlers);

		struct LocalVariableInfo {
			public Block block;
			public int index;
			public LocalVariableInfo(Block block, int index) {
				this.block = block;
				this.index = index;
			}
		}

		public int OptimizeLocals() {
			if (locals.Count == 0)
				return 0;

			var usedLocals = new Dictionary<Local, List<LocalVariableInfo>>();
			foreach (var block in methodBlocks.GetAllBlocks()) {
				for (int i = 0; i < block.Instructions.Count; i++) {
					var instr = block.Instructions[i];
					Local local;
					switch (instr.OpCode.Code) {
					case Code.Ldloc:
					case Code.Ldloc_S:
					case Code.Ldloc_0:
					case Code.Ldloc_1:
					case Code.Ldloc_2:
					case Code.Ldloc_3:
					case Code.Stloc:
					case Code.Stloc_S:
					case Code.Stloc_0:
					case Code.Stloc_1:
					case Code.Stloc_2:
					case Code.Stloc_3:
						local = Instr.GetLocalVar(locals, instr);
						break;

					case Code.Ldloca_S:
					case Code.Ldloca:
						local = (Local)instr.Operand;
						break;

					default:
						local = null;
						break;
					}
					if (local == null)
						continue;

					if (!usedLocals.TryGetValue(local, out var list))
						usedLocals[local] = list = new List<LocalVariableInfo>();
					list.Add(new LocalVariableInfo(block, i));
					if (usedLocals.Count == locals.Count)
						return 0;
				}
			}

			int newIndex = -1;
			var newLocals = new List<Local>(usedLocals.Count);
			var newLocalsDict = new Dictionary<Local, bool>(usedLocals.Count);
			foreach (var local in usedLocals.Keys) {
				newIndex++;
				newLocals.Add(local);
				newLocalsDict[local] = true;
				foreach (var info in usedLocals[local])
					info.block.Instructions[info.index] = new Instr(OptimizeLocalInstr(info.block.Instructions[info.index], local, (uint)newIndex));
			}

			// We can't remove all locals. Locals that reference another assembly will
			// cause the CLR to load that assembly before the method is executed if it
			// hasn't been loaded yet. This is a side effect the program may depend on.
			// At least one program has this dependency and will crash if we remove the
			// unused local. This took a while to figure out...
			var keptAssemblies = new Dictionary<string, bool>(StringComparer.Ordinal);
			foreach (var local in locals) {
				if (newLocalsDict.ContainsKey(local))
					continue;
				var defAsm = local.Type.DefinitionAssembly;
				if (defAsm == null)
					continue;	// eg. fnptr
				if (defAsm == method.DeclaringType.Module.Assembly)
					continue;	// this assembly is always loaded
				if (defAsm.IsCorLib())
					continue;	// mscorlib is always loaded
				var asmName = defAsm.FullName;
				if (keptAssemblies.ContainsKey(asmName))
					continue;
				keptAssemblies[asmName] = true;
				newLocals.Add(local);
			}

			int numRemoved = locals.Count - newLocals.Count;
			locals.Clear();
			foreach (var local in newLocals)
				locals.Add(local);
			return numRemoved;
		}

		static Instruction OptimizeLocalInstr(Instr instr, Local local, uint newIndex) {
			switch (instr.OpCode.Code) {
			case Code.Ldloc:
			case Code.Ldloc_S:
			case Code.Ldloc_0:
			case Code.Ldloc_1:
			case Code.Ldloc_2:
			case Code.Ldloc_3:
				if (newIndex == 0)
					return OpCodes.Ldloc_0.ToInstruction();
				if (newIndex == 1)
					return OpCodes.Ldloc_1.ToInstruction();
				if (newIndex == 2)
					return OpCodes.Ldloc_2.ToInstruction();
				if (newIndex == 3)
					return OpCodes.Ldloc_3.ToInstruction();
				if (newIndex <= 0xFF)
					return OpCodes.Ldloc_S.ToInstruction(local);
				return OpCodes.Ldloc.ToInstruction(local);

			case Code.Stloc:
			case Code.Stloc_S:
			case Code.Stloc_0:
			case Code.Stloc_1:
			case Code.Stloc_2:
			case Code.Stloc_3:
				if (newIndex == 0)
					return OpCodes.Stloc_0.ToInstruction();
				if (newIndex == 1)
					return OpCodes.Stloc_1.ToInstruction();
				if (newIndex == 2)
					return OpCodes.Stloc_2.ToInstruction();
				if (newIndex == 3)
					return OpCodes.Stloc_3.ToInstruction();
				if (newIndex <= 0xFF)
					return OpCodes.Stloc_S.ToInstruction(local);
				return OpCodes.Stloc.ToInstruction(local);

			case Code.Ldloca_S:
			case Code.Ldloca:
				if (newIndex <= 0xFF)
					return OpCodes.Ldloca_S.ToInstruction(local);
				return OpCodes.Ldloca.ToInstruction(local);

			default:
				throw new ApplicationException("Invalid ld/st local instruction");
			}
		}

		public void RepartitionBlocks() {
			MergeNopBlocks();
			foreach (var scopeBlock in GetAllScopeBlocks(methodBlocks)) {
				try {
					scopeBlock.RepartitionBlocks();
				}
				catch (NullReferenceException) {
					//TODO: Send this message to the log
					Console.WriteLine("Null ref exception! Invalid metadata token in code? Method: {0:X8}: {1}", method.MDToken.Raw, method.FullName);
					return;
				}
			}
		}

		void MergeNopBlocks() {
			var allBlocks = methodBlocks.GetAllBlocks();

			var nopBlocks = new Dictionary<Block, bool>();
			foreach (var nopBlock in allBlocks) {
				if (nopBlock.IsNopBlock())
					nopBlocks[nopBlock] = true;
			}

			if (nopBlocks.Count == 0)
				return;

			for (int i = 0; i < 10; i++) {
				bool modified = false;

				foreach (var block in allBlocks) {
					Block nopBlockTarget;

					nopBlockTarget = GetNopBlockTarget(nopBlocks, block, block.FallThrough);
					if (nopBlockTarget != null) {
						block.SetNewFallThrough(nopBlockTarget);
						modified = true;
					}

					if (block.Targets != null) {
						for (int targetIndex = 0; targetIndex < block.Targets.Count; targetIndex++) {
							nopBlockTarget = GetNopBlockTarget(nopBlocks, block, block.Targets[targetIndex]);
							if (nopBlockTarget == null)
								continue;
							block.SetNewTarget(targetIndex, nopBlockTarget);
							modified = true;
						}
					}
				}

				if (!modified)
					break;
			}

			foreach (var nopBlock in nopBlocks.Keys)
				nopBlock.Parent.RemoveDeadBlock(nopBlock);
		}

		static Block GetNopBlockTarget(Dictionary<Block, bool> nopBlocks, Block source, Block nopBlock) {
			if (nopBlock == null || !nopBlocks.ContainsKey(nopBlock) || source == nopBlock.FallThrough)
				return null;
			if (nopBlock.Parent.BaseBlocks[0] == nopBlock)
				return null;
			var target = nopBlock.FallThrough;
			if (nopBlock.Parent != target.Parent)
				return null;
			return target;
		}
	}
}



================================================
File: de4dot.blocks/BlocksSorter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;

namespace de4dot.blocks {
	class BlocksSorter {
		ScopeBlock scopeBlock;

		class BlockInfo {
			public int dfsNumber = -1;
			public int low;
			public BaseBlock baseBlock;
			public bool onStack;

			public BlockInfo(BaseBlock baseBlock) => this.baseBlock = baseBlock;
			public bool Visited() => dfsNumber >= 0;
			public override string ToString() => $"L:{low}, D:{dfsNumber}, S:{onStack}";
		}

		// It uses Tarjan's strongly connected components algorithm to find all SCCs.
		// See http://www.ics.uci.edu/~eppstein/161/960220.html or wikipedia for a good explanation.
		// The non-Tarjan code is still pretty simple and can (should) be improved.
		class Sorter {
			ScopeBlock scopeBlock;
			IList<BaseBlock> validBlocks;
			Dictionary<BaseBlock, BlockInfo> blockToInfo = new Dictionary<BaseBlock, BlockInfo>();
			Stack<BlockInfo> stack = new Stack<BlockInfo>();
			List<BaseBlock> sorted;
			int dfsNumber = 0;
			bool skipFirstBlock;
			BaseBlock firstBlock;

			public Sorter(ScopeBlock scopeBlock, IList<BaseBlock> validBlocks, bool skipFirstBlock) {
				this.scopeBlock = scopeBlock;
				this.validBlocks = validBlocks;
				this.skipFirstBlock = skipFirstBlock;
			}

			public List<BaseBlock> Sort() {
				if (validBlocks.Count == 0)
					return new List<BaseBlock>();
				if (skipFirstBlock)
					firstBlock = validBlocks[0];

				foreach (var block in validBlocks) {
					if (block != firstBlock)
						blockToInfo[block] = new BlockInfo(block);
				}

				sorted = new List<BaseBlock>(validBlocks.Count);
				var finalList = new List<BaseBlock>(validBlocks.Count);

				if (firstBlock is Block) {
					foreach (var target in GetTargets(firstBlock)) {
						Visit(target);
						finalList.AddRange(sorted);
						sorted.Clear();
					}
				}
				foreach (var bb in validBlocks) {
					Visit(bb);
					finalList.AddRange(sorted);
					sorted.Clear();
				}

				if (stack.Count > 0)
					throw new ApplicationException("Stack isn't empty");

				if (firstBlock != null)
					finalList.Insert(0, firstBlock);
				else if (validBlocks[0] != finalList[0]) {
					// Make sure the original first block is first
					int index = finalList.IndexOf(validBlocks[0]);
					finalList.RemoveAt(index);
					finalList.Insert(0, validBlocks[0]);
				}
				return finalList;
			}

			void Visit(BaseBlock bb) {
				var info = GetInfo(bb);
				if (info == null)
					return;
				if (info.baseBlock == firstBlock)
					return;
				if (info.Visited())
					return;
				Visit(info);
			}

			BlockInfo GetInfo(BaseBlock baseBlock) {
				baseBlock = scopeBlock.ToChild(baseBlock);
				if (baseBlock == null)
					return null;
				blockToInfo.TryGetValue(baseBlock, out var info);
				return info;
			}

			List<BaseBlock> GetTargets(BaseBlock baseBlock) {
				var list = new List<BaseBlock>();

				if (baseBlock is Block block)
					AddTargets(list, block.GetTargets());
				else if (baseBlock is TryBlock)
					AddTargets(list, (TryBlock)baseBlock);
				else if (baseBlock is TryHandlerBlock)
					AddTargets(list, (TryHandlerBlock)baseBlock);
				else
					AddTargets(list, (ScopeBlock)baseBlock);

				return list;
			}

			void AddTargets(List<BaseBlock> dest, TryBlock tryBlock) {
				AddTargets(dest, (ScopeBlock)tryBlock);
				foreach (var tryHandlerBlock in tryBlock.TryHandlerBlocks) {
					dest.Add(tryHandlerBlock);
					AddTargets(dest, tryHandlerBlock);
				}
			}

			void AddTargets(List<BaseBlock> dest, TryHandlerBlock tryHandlerBlock) {
				AddTargets(dest, (ScopeBlock)tryHandlerBlock);

				dest.Add(tryHandlerBlock.FilterHandlerBlock);
				AddTargets(dest, tryHandlerBlock.FilterHandlerBlock);

				dest.Add(tryHandlerBlock.HandlerBlock);
				AddTargets(dest, tryHandlerBlock.HandlerBlock);
			}

			void AddTargets(List<BaseBlock> dest, ScopeBlock scopeBlock) {
				foreach (var block in scopeBlock.GetAllBlocks())
					AddTargets(dest, block.GetTargets());
			}

			void AddTargets(List<BaseBlock> dest, IEnumerable<Block> source) {
				var list = new List<Block>(source);
				list.Reverse();
				foreach (var block in list)
					dest.Add(block);
			}

			struct VisitState {
				public BlockInfo Info;
				public List<BaseBlock> Targets;
				public int TargetIndex;
				public BlockInfo TargetInfo;
				public VisitState(BlockInfo info) {
					Info = info;
					Targets = null;
					TargetIndex = 0;
					TargetInfo = null;
				}
			}
			Stack<VisitState> visitStateStack = new Stack<VisitState>();
			void Visit(BlockInfo info) {
				// This method used to be recursive but to prevent stack overflows,
				// it's not recursive anymore.

				var state = new VisitState(info);
recursive_call:
				if (state.Info.baseBlock == firstBlock)
					throw new ApplicationException("Can't visit firstBlock");
				stack.Push(state.Info);
				state.Info.onStack = true;
				state.Info.dfsNumber = dfsNumber;
				state.Info.low = dfsNumber;
				dfsNumber++;

				state.Targets = GetTargets(state.Info.baseBlock);
				state.TargetIndex = 0;
return_to_caller:
				for (; state.TargetIndex < state.Targets.Count; state.TargetIndex++) {
					state.TargetInfo = GetInfo(state.Targets[state.TargetIndex]);
					if (state.TargetInfo == null)
						continue;
					if (state.TargetInfo.baseBlock == firstBlock)
						continue;

					if (!state.TargetInfo.Visited()) {
						visitStateStack.Push(state);
						state = new VisitState(state.TargetInfo);
						goto recursive_call;
					}
					else if (state.TargetInfo.onStack)
						state.Info.low = Math.Min(state.Info.low, state.TargetInfo.dfsNumber);
				}

				if (state.Info.low != state.Info.dfsNumber)
					goto return_from_method;
				var sccBlocks = new List<BaseBlock>();
				while (true) {
					var poppedInfo = stack.Pop();
					poppedInfo.onStack = false;
					sccBlocks.Add(poppedInfo.baseBlock);
					if (ReferenceEquals(state.Info, poppedInfo))
						break;
				}
				if (sccBlocks.Count > 1) {
					sccBlocks.Reverse();
					var result = new Sorter(scopeBlock, sccBlocks, true).Sort();
					SortLoopBlock(result);
					sorted.InsertRange(0, result);
				}
				else {
					sorted.Insert(0, sccBlocks[0]);
				}

return_from_method:
				if (visitStateStack.Count == 0)
					return;
				state = visitStateStack.Pop();
				state.Info.low = Math.Min(state.Info.low, state.TargetInfo.low);
				state.TargetIndex++;
				goto return_to_caller;
			}

			void SortLoopBlock(List<BaseBlock> list) {
				// Some popular decompilers sometimes produce bad output unless the loop condition
				// checker block is at the end of the loop. Eg., they may use a while loop when
				// it's really a for/foreach loop.

				var loopStart = GetLoopStartBlock(list);
				if (loopStart == null)
					return;

				if (!list.Remove(loopStart))
					throw new ApplicationException("Could not remove block");
				list.Add(loopStart);
			}

			Block GetLoopStartBlock(List<BaseBlock> list) {
				var loopBlocks = new Dictionary<Block, bool>(list.Count);
				foreach (var bb in list) {
					if (bb is Block block)
						loopBlocks[block] = true;
				}

				var targetBlocks = new Dictionary<Block, int>();
				foreach (var bb in list) {
					var block = bb as Block;
					if (block == null)
						continue;
					foreach (var source in block.Sources) {
						if (loopBlocks.ContainsKey(source))
							continue;
						targetBlocks.TryGetValue(block, out int count);
						targetBlocks[block] = count + 1;
					}
				}

				int max = -1;
				Block loopStart = null;
				foreach (var kv in targetBlocks) {
					if (kv.Value <= max)
						continue;
					max = kv.Value;
					loopStart = kv.Key;
				}

				return loopStart;
			}
		}

		public BlocksSorter(ScopeBlock scopeBlock) => this.scopeBlock = scopeBlock;

		public List<BaseBlock> Sort() {
			var sorted = new Sorter(scopeBlock, scopeBlock.BaseBlocks, false).Sort();
			return new ForwardScanOrder(scopeBlock, sorted).Fix();
		}
	}
}



================================================
File: de4dot.blocks/CodeGenerator.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace de4dot.blocks {
	class CodeGenerator {
		MethodBlocks methodBlocks;
		List<Block> blocks = new List<Block>();
		Stack<BlockState> stateStack = new Stack<BlockState>();
		List<ExceptionInfo> exceptions = new List<ExceptionInfo>();
		Dictionary<BaseBlock, bool> visited = new Dictionary<BaseBlock, bool>();
		List<BaseBlock> notProcessedYet = new List<BaseBlock>();

		class BlockState {
			public ScopeBlock scopeBlock;
			public BlockState(ScopeBlock scopeBlock) => this.scopeBlock = scopeBlock;
		}

		class ExceptionInfo {
			public int tryStart;
			public int tryEnd;
			public int filterStart;
			public int handlerStart;
			public int handlerEnd;
			public ITypeDefOrRef catchType;
			public ExceptionHandlerType handlerType;
			public ExceptionInfo(int tryStart, int tryEnd, int filterStart,
				int handlerStart, int handlerEnd, ITypeDefOrRef catchType,
				ExceptionHandlerType handlerType) {
				if (tryStart > tryEnd || filterStart > handlerStart ||
					tryStart < 0 || tryEnd < 0 || filterStart < 0 || handlerStart < 0 || handlerEnd < 0)
					throw new ApplicationException("Invalid start/end/filter/handler indexes");
				this.tryStart = tryStart;
				this.tryEnd = tryEnd;
				this.filterStart = filterStart == handlerStart ? -1 : filterStart;
				this.handlerStart = handlerStart;
				this.handlerEnd = handlerEnd;
				this.catchType = catchType;
				this.handlerType = handlerType;
			}
		}

		public CodeGenerator(MethodBlocks methodBlocks) => this.methodBlocks = methodBlocks;

		public void GetCode(out IList<Instruction> allInstructions, out IList<ExceptionHandler> allExceptionHandlers) {
			FixEmptyBlocks();
			LayOutBlocks();
			SortExceptions();
			LayOutInstructions(out allInstructions, out allExceptionHandlers);

			allInstructions.SimplifyBranches();
			allInstructions.OptimizeBranches();
			allInstructions.UpdateInstructionOffsets();
		}

		class BlockInfo {
			public int start;
			public int end;
			public BlockInfo(int start, int end) {
				this.start = start;
				this.end = end;
			}
		}

		void LayOutInstructions(out IList<Instruction> allInstructions, out IList<ExceptionHandler> allExceptionHandlers) {
			allInstructions = new List<Instruction>();
			allExceptionHandlers = new List<ExceptionHandler>();

			var blockInfos = new List<BlockInfo>();
			for (int i = 0; i < blocks.Count; i++) {
				var block = blocks[i];

				int startIndex = allInstructions.Count;
				for (int j = 0; j < block.Instructions.Count - 1; j++)
					allInstructions.Add(block.Instructions[j].Instruction);

				if (block.Targets != null) {
					var targets = new List<Instr>();
					foreach (var target in block.Targets)
						targets.Add(target.FirstInstr);
					block.LastInstr.UpdateTargets(targets);
				}
				allInstructions.Add(block.LastInstr.Instruction);

				var next = i + 1 < blocks.Count ? blocks[i + 1] : null;

				// If eg. ble next, then change it to bgt XYZ and fall through to next.
				if (block.Targets != null && block.CanFlipConditionalBranch() && block.Targets[0] == next) {
					block.FlipConditionalBranch();
					block.LastInstr.UpdateTargets(new List<Instr> { block.Targets[0].FirstInstr });
				}
				else if (block.FallThrough != null && block.FallThrough != next) {
					var instr = new Instr(OpCodes.Br.ToInstruction(block.FallThrough.FirstInstr.Instruction));
					instr.UpdateTargets(new List<Instr> { block.FallThrough.FirstInstr });
					allInstructions.Add(instr.Instruction);
				}

				int endIndex = allInstructions.Count - 1;

				blockInfos.Add(new BlockInfo(startIndex, endIndex));
			}

			foreach (var ex in exceptions) {
				var tryStart = GetBlockInfo(blockInfos, ex.tryStart).start;
				var tryEnd = GetBlockInfo(blockInfos, ex.tryEnd).end;
				var filterStart = ex.filterStart == -1 ? -1 : GetBlockInfo(blockInfos, ex.filterStart).start;
				var handlerStart = GetBlockInfo(blockInfos, ex.handlerStart).start;
				var handlerEnd = GetBlockInfo(blockInfos, ex.handlerEnd).end;

				var eh = new ExceptionHandler(ex.handlerType);
				eh.CatchType = ex.catchType;
				eh.TryStart = GetInstruction(allInstructions, tryStart);
				eh.TryEnd = GetInstruction(allInstructions, tryEnd + 1);
				eh.FilterStart = filterStart == -1 ? null : GetInstruction(allInstructions, filterStart);
				eh.HandlerStart = GetInstruction(allInstructions, handlerStart);
				eh.HandlerEnd = GetInstruction(allInstructions, handlerEnd + 1);

				allExceptionHandlers.Add(eh);
			}
		}

		static BlockInfo GetBlockInfo(List<BlockInfo> blockInfos, int index) {
			if (index >= blockInfos.Count)
				index = blockInfos.Count - 1;
			if (index < 0)
				index = 0;
			return blockInfos[index];
		}

		static Instruction GetInstruction(IList<Instruction> allInstructions, int i) {
			if (i < allInstructions.Count)
				return allInstructions[i];
			return null;
		}

		void SortExceptions() =>
			exceptions.Sort((a, b) => {
				// Make sure nested try blocks are sorted before the outer try block.
				if (a.tryStart > b.tryStart) return -1;	// a could be nested, but b is not
				if (a.tryStart < b.tryStart) return 1;	// b could be nested, but a is not
				// same tryStart
				if (a.tryEnd < b.tryEnd) return -1;		// a is nested
				if (a.tryEnd > b.tryEnd) return 1;		// b is nested
				// same tryEnd (they share try block)

				int ai = a.filterStart == -1 ? a.handlerStart : a.filterStart;
				int bi = b.filterStart == -1 ? b.handlerStart : b.filterStart;
				if (ai < bi) return -1;
				if (ai > bi) return 1;
				// same start

				// if we're here, they should be identical since handlers can't overlap
				// when they share the try block!
				if (a.handlerEnd < b.handlerEnd) return -1;
				if (a.handlerEnd > b.handlerEnd) return 1;
				// same handler end

				return 0;
			});

		void FixEmptyBlocks() {
			foreach (var block in methodBlocks.GetAllBlocks()) {
				if (block.Instructions.Count == 0) {
					block.Instructions.Add(new Instr(OpCodes.Nop.ToInstruction()));
				}
			}
		}

		// Write all blocks to the blocks list
		void LayOutBlocks() {
			if (methodBlocks.BaseBlocks.Count == 0)
				return;

			stateStack.Push(new BlockState(methodBlocks));
			ProcessBaseBlocks(methodBlocks.BaseBlocks, (block) => {
				return block.LastInstr.OpCode == OpCodes.Ret;
			});

			stateStack.Pop();

			foreach (var bb in notProcessedYet) {
				visited.TryGetValue(bb, out bool wasVisited);
				if (!wasVisited)
					throw new ApplicationException("A block wasn't processed");
			}
		}

		void ProcessBaseBlocks(List<BaseBlock> lb, Func<Block, bool> placeLast) {
			var bbs = new List<BaseBlock>();
			int lastIndex = -1;
			for (int i = 0; i < lb.Count; i++) {
				var bb = lb[i];
				if (bb is Block block && placeLast(block))
					lastIndex = i;
				bbs.Add(bb);
			}
			if (lastIndex != -1) {
				var block = (Block)bbs[lastIndex];
				bbs.RemoveAt(lastIndex);
				bbs.Add(block);
			}
			foreach (var bb in bbs)
				DoBaseBlock(bb);
		}

		// Returns the BaseBlock's ScopeBlock. The return value is either current ScopeBlock,
		// the ScopeBlock one step below current (current one's child), or null.
		ScopeBlock GetScopeBlock(BaseBlock bb) {
			var current = stateStack.Peek();

			if (current.scopeBlock.IsOurBaseBlock(bb))
				return current.scopeBlock;
			return (ScopeBlock)current.scopeBlock.ToChild(bb);
		}

		void DoBaseBlock(BaseBlock bb) {
			var current = stateStack.Peek();
			var newOne = GetScopeBlock(bb);
			if (newOne == null)
				return;		// Not a BaseBlock somewhere inside this ScopeBlock
			if (newOne != current.scopeBlock)
				bb = newOne;

			if (!visited.TryGetValue(bb, out bool hasVisited))
				visited[bb] = hasVisited = false;
			if (hasVisited)
				return;
			visited[bb] = true;

			if (bb is Block)
				DoBlock(bb as Block);
			else if (bb is TryBlock)
				DoTryBlock(bb as TryBlock);
			else if (bb is FilterHandlerBlock)
				DoFilterHandlerBlock(bb as FilterHandlerBlock);
			else if (bb is HandlerBlock)
				DoHandlerBlock(bb as HandlerBlock);
			else if (bb is TryHandlerBlock) {
				// The try handler block is usually after the try block, but sometimes it isn't...
				// Handle that case here.
				visited.Remove(bb);
				notProcessedYet.Add(bb);
			}
			else
				throw new ApplicationException("Invalid block found");
		}

		void DoBlock(Block block) => blocks.Add(block);

		void DoTryBlock(TryBlock tryBlock) {
			var tryStart = blocks.Count;
			stateStack.Push(new BlockState(tryBlock));
			ProcessBaseBlocks(tryBlock.BaseBlocks, (block) => {
				return block.LastInstr.OpCode == OpCodes.Leave ||
						block.LastInstr.OpCode == OpCodes.Leave_S;
			});
			stateStack.Pop();
			var tryEnd = blocks.Count - 1;

			if (tryBlock.TryHandlerBlocks.Count == 0)
				throw new ApplicationException("No handler blocks");

			foreach (var handlerBlock in tryBlock.TryHandlerBlocks) {
				visited[handlerBlock] = true;

				stateStack.Push(new BlockState(handlerBlock));

				var filterStart = blocks.Count;
				if (handlerBlock.FilterHandlerBlock.BaseBlocks != null)
					DoBaseBlock(handlerBlock.FilterHandlerBlock);

				var handlerStart = blocks.Count;
				DoBaseBlock(handlerBlock.HandlerBlock);
				var handlerEnd = blocks.Count - 1;

				exceptions.Add(new ExceptionInfo(tryStart, tryEnd, filterStart, handlerStart, handlerEnd, handlerBlock.CatchType, handlerBlock.HandlerType));

				stateStack.Pop();
			}
		}

		void DoFilterHandlerBlock(FilterHandlerBlock filterHandlerBlock) {
			stateStack.Push(new BlockState(filterHandlerBlock));
			ProcessBaseBlocks(filterHandlerBlock.BaseBlocks, (block) => {
				return block.LastInstr.OpCode == OpCodes.Endfilter;	// MUST end with endfilter!
			});
			stateStack.Pop();
		}

		void DoHandlerBlock(HandlerBlock handlerBlock) {
			stateStack.Push(new BlockState(handlerBlock));
			ProcessBaseBlocks(handlerBlock.BaseBlocks, (block) => {
				return block.LastInstr.OpCode == OpCodes.Endfinally ||
						block.LastInstr.OpCode == OpCodes.Leave ||
						block.LastInstr.OpCode == OpCodes.Leave_S;
			});
			stateStack.Pop();
		}
	}
}



================================================
File: de4dot.blocks/DeadBlocksRemover.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;

namespace de4dot.blocks {
	class DeadBlocksRemover {
		MethodBlocks methodBlocks;
		Dictionary<BaseBlock, bool> checkedBaseBlocks = new Dictionary<BaseBlock, bool>();
		Dictionary<ScopeBlock, bool> checkedScopeBlocks = new Dictionary<ScopeBlock, bool>();
		Stack<BaseBlock> baseBlocksToCheck = new Stack<BaseBlock>();
		Stack<ScopeBlock> scopeBlocksToCheck = new Stack<ScopeBlock>();

		public DeadBlocksRemover(MethodBlocks methodBlocks) => this.methodBlocks = methodBlocks;

		public int Remove() {
			AddScopeBlock(methodBlocks);
			ProcessAll();
			return RemoveDeadBlocks();
		}

		class ScopeBlockInfo {
			public ScopeBlock scopeBlock;
			public IList<BaseBlock> deadBlocks = new List<BaseBlock>();
			public ScopeBlockInfo(ScopeBlock scopeBlock) => this.scopeBlock = scopeBlock;
		}

		int RemoveDeadBlocks() {
			int numDeadBlocks = 0;

			var infos = new Dictionary<ScopeBlock, ScopeBlockInfo>();
			var deadBlocksDict = new Dictionary<BaseBlock, bool>();
			foreach (var baseBlock in FindDeadBlocks()) {
				deadBlocksDict[baseBlock] = true;
				var parent = baseBlock.Parent;
				if (!infos.TryGetValue(parent, out var info))
					infos[parent] = info = new ScopeBlockInfo(parent);
				info.deadBlocks.Add(baseBlock);
				numDeadBlocks++;
			}

			foreach (var info in infos.Values)
				info.scopeBlock.RemoveAllDeadBlocks(info.deadBlocks, deadBlocksDict);

			return numDeadBlocks;
		}

		IList<BaseBlock> FindDeadBlocks() {
			var deadBlocks = new List<BaseBlock>();

			foreach (var bb in methodBlocks.GetAllBaseBlocks()) {
				if (!checkedBaseBlocks.ContainsKey(bb))
					deadBlocks.Add(bb);
			}

			return deadBlocks;
		}

		void AddScopeBlock(ScopeBlock scopeBlock) => scopeBlocksToCheck.Push(scopeBlock);

		void ProcessAll() {
			bool didSomething;
			do {
				didSomething = false;
				while (baseBlocksToCheck.Count > 0) {
					ProcessBaseBlock(baseBlocksToCheck.Pop());
					didSomething = true;
				}
				while (scopeBlocksToCheck.Count > 0) {
					ProcessScopeBlock(scopeBlocksToCheck.Pop());
					didSomething = true;
				}
			} while (didSomething);
		}

		void ProcessBaseBlock(BaseBlock baseBlock) {
			if (baseBlock == null || checkedBaseBlocks.ContainsKey(baseBlock))
				return;
			checkedBaseBlocks[baseBlock] = true;

			if (baseBlock is Block block) {
				foreach (var block2 in block.GetTargets())
					AddBaseBlock(block2);
			}
			else if (baseBlock is ScopeBlock scopeBlock) {
				AddScopeBlock(scopeBlock);
				if (scopeBlock.BaseBlocks != null && scopeBlock.BaseBlocks.Count > 0)
					AddBaseBlock(scopeBlock.BaseBlocks[0]);
			}
			else
				throw new ApplicationException($"Unknown BaseBlock type {baseBlock.GetType()}");
		}

		// Add a block to be processed later, including all its enclosing ScopeBlocks.
		void AddBaseBlock(BaseBlock baseBlock) {
			for (var bb = baseBlock; bb != null; bb = bb.Parent)
				baseBlocksToCheck.Push(bb);
		}

		void ProcessScopeBlock(ScopeBlock scopeBlock) {
			if (scopeBlock == null || checkedScopeBlocks.ContainsKey(scopeBlock))
				return;
			checkedScopeBlocks[scopeBlock] = true;
			AddBaseBlock(scopeBlock);

			if (scopeBlock is TryBlock tryBlock) {
				foreach (var handler in tryBlock.TryHandlerBlocks)
					AddScopeBlock(handler);
			}
			else if (scopeBlock is TryHandlerBlock tryHandlerBlock) {
				AddScopeBlock(tryHandlerBlock.FilterHandlerBlock);
				AddScopeBlock(tryHandlerBlock.HandlerBlock);
			}
		}
	}
}



================================================
File: de4dot.blocks/DotNetUtils.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace de4dot.blocks {
	public enum FrameworkType {
		Unknown,
		Desktop,
		Silverlight,		// and WindowsPhone, XNA Xbox360
		CompactFramework,
		XNA,
		Zune,
	}

	public class CallCounter {
		Dictionary<IMethod, int> calls = new Dictionary<IMethod, int>(MethodEqualityComparer.CompareDeclaringTypes);

		public void Add(IMethod calledMethod) {
			calls.TryGetValue(calledMethod, out int count);
			calls[calledMethod] = count + 1;
		}

		public IMethod Most() => Most(out int numCalls);

		public IMethod Most(out int numCalls) {
			IMethod method = null;
			int callCount = 0;
			foreach (var key in calls.Keys) {
				if (calls[key] > callCount) {
					callCount = calls[key];
					method = key;
				}
			}
			numCalls = callCount;
			return method;
		}
	}

	public static class DotNetUtils {
		public static TypeDef GetModuleType(ModuleDef module) => module.GlobalType;
		public static MethodDef GetModuleTypeCctor(ModuleDef module) => module.GlobalType.FindStaticConstructor();

		public static bool IsEmpty(MethodDef method) {
			if (method.Body == null)
				return false;
			foreach (var instr in method.Body.Instructions) {
				var code = instr.OpCode.Code;
				if (code != Code.Nop && code != Code.Ret)
					return false;
			}
			return true;
		}

		public static bool IsEmptyObfuscated(MethodDef method) {
			if (method.Body == null)
				return false;
			int index = 0;
			var instr = GetInstruction(method.Body.Instructions, ref index);
			if (instr == null || instr.OpCode.Code != Code.Ret)
				return false;

			return true;
		}

		public static FieldDef FindFieldType(TypeDef typeDef, string typeName, bool isStatic) {
			if (typeDef == null)
				return null;
			foreach (var field in typeDef.Fields) {
				if (field.IsStatic == isStatic && field.FieldSig.GetFieldType().GetFullName() == typeName)
					return field;
			}
			return null;
		}

		public static IEnumerable<MethodDef> FindMethods(IEnumerable<MethodDef> methods, string returnType, string[] argsTypes) =>
			FindMethods(methods, returnType, argsTypes, true);

		public static IEnumerable<MethodDef> FindMethods(IEnumerable<MethodDef> methods, string returnType, string[] argsTypes, bool isStatic) {
			foreach (var method in methods) {
				var sig = method.MethodSig;
				if (sig == null || !method.HasBody || !sig.IsDefault)
					continue;
				if (method.IsStatic != isStatic || sig.Params.Count != argsTypes.Length)
					continue;
				if (sig.GenParamCount > 0)
					continue;
				if (sig.RetType.GetFullName() != returnType)
					continue;
				for (int i = 0; i < argsTypes.Length; i++) {
					if (sig.Params[i].GetFullName() != argsTypes[i])
						goto next;
				}
				yield return method;
			next: ;
			}
		}

		public static bool IsDelegate(IType type) {
			if (type == null)
				return false;
			var fn = type.FullName;
			return fn == "System.Delegate" || fn == "System.MulticastDelegate";
		}

		public static bool DerivesFromDelegate(TypeDef type) => type != null && IsDelegate(type.BaseType);

		public static bool IsMethod(IMethod method, string returnType, string parameters) =>
			method != null && method.FullName == returnType + " " + method.DeclaringType.FullName + "::" + method.Name + parameters;

		public static string GetDllName(string dll) {
			if (dll.EndsWith(".dll", StringComparison.OrdinalIgnoreCase))
				return dll.Substring(0, dll.Length - 4);
			return dll;
		}

		public static bool HasPinvokeMethod(TypeDef type, string methodName) =>
			GetPInvokeMethod(type, methodName) != null;

		public static MethodDef GetPInvokeMethod(TypeDef type, string methodName) {
			if (type == null)
				return null;
			UTF8String mname = methodName;
			foreach (var method in type.Methods) {
				if (method.ImplMap == null)
					continue;
				if (UTF8String.Equals(method.ImplMap.Name, mname))
					return method;
			}
			return null;
		}

		public static MethodDef GetPInvokeMethod(TypeDef type, string dll, string funcName) {
			foreach (var method in type.Methods) {
				if (IsPinvokeMethod(method, dll, funcName))
					return method;
			}
			return null;
		}

		public static bool IsPinvokeMethod(MethodDef method, string dll, string funcName) {
			if (method == null)
				return false;
			if (method.ImplMap == null)
				return false;
			return method.ImplMap.IsPinvokeMethod(dll, funcName);
		}

		public static MethodDef GetMethod(ModuleDefMD module, IMethod method) {
			if (method == null)
				return null;
			return GetMethod(module, method, method.DeclaringType);
		}

		public static MethodDef GetMethod2(ModuleDefMD module, IMethod method) {
			if (method == null)
				return null;
			if (method is MethodDef)
				return (MethodDef)method;
			var git = method.DeclaringType.TryGetGenericInstSig();
			var dt = git == null ? method.DeclaringType : git.GenericType.TypeDefOrRef;
			return GetMethod(module, method, dt);
		}

		static MethodDef GetMethod(ModuleDefMD module, IMethod method, ITypeDefOrRef declaringType) {
			if (method == null)
				return null;
			if (method is MethodDef)
				return (MethodDef)method;
			return GetMethod(GetType(module, declaringType), method);
		}

		public static MethodDef GetMethod(TypeDef type, string returnType, string parameters) {
			foreach (var method in type.Methods) {
				if (IsMethod(method, returnType, parameters))
					return method;
			}
			return null;
		}

		public static MethodDef GetMethod2(ModuleDef module, IMethod method) {
			if (method == null)
				return null;
			return GetMethod(module, method, method.DeclaringType.ScopeType);
		}

		public static TypeDef GetType(ModuleDef module, TypeSig type) {
			type = type.RemovePinnedAndModifiers();
			var tdr = type as TypeDefOrRefSig;
			if (tdr == null)
				return null;
			return GetType(module, tdr.TypeDefOrRef);
		}

		public static TypeDef GetType(ModuleDef module, ITypeDefOrRef type) {
			var td = type as TypeDef;
			if (td == null) {
				if (type is TypeRef tr) {
					var trAsm = tr.DefinitionAssembly;
					var modAsm = module.Assembly;
					if (trAsm != null && modAsm != null && trAsm.Name == modAsm.Name)
						td = tr.Resolve();
				}
			}
			return td != null && td.Module == module ? td : null;
		}

		static MethodDef GetMethod(ModuleDef module, IMethod method, ITypeDefOrRef declaringType) {
			if (method == null)
				return null;
			if (method is MethodDef)
				return (MethodDef)method;
			return GetMethod(GetType(module, declaringType), method);
		}

		public static MethodDef GetMethod(TypeDef type, IMethod methodRef) {
			if (type == null || methodRef == null)
				return null;
			if (methodRef is MethodDef)
				return (MethodDef)methodRef;
			return type.FindMethod(methodRef.Name, methodRef.MethodSig);
		}

		public static IEnumerable<MethodDef> GetNormalMethods(TypeDef type) {
			foreach (var method in type.Methods) {
				if (method.HasImplMap)
					continue;
				if (method.IsConstructor)
					continue;

				yield return method;
			}
		}

		public static FieldDef GetField(ModuleDef module, IField field) {
			if (field == null)
				return null;
			if (field is FieldDef)
				return (FieldDef)field;
			return GetField(GetType(module, field.DeclaringType), field);
		}

		public static FieldDef GetField(TypeDef type, IField fieldRef) {
			if (type == null || fieldRef == null)
				return null;
			if (fieldRef is FieldDef)
				return (FieldDef)fieldRef;
			return type.FindField(fieldRef.Name, fieldRef.FieldSig);
		}

		public static FieldDef GetField(TypeDef type, string typeFullName) {
			if (type == null)
				return null;
			foreach (var field in type.Fields) {
				if (field.FieldSig.GetFieldType().GetFullName() == typeFullName)
					return field;
			}
			return null;
		}

		public static IEnumerable<IMethod> GetMethodCalls(MethodDef method) {
			var list = new List<IMethod>();
			if (method.HasBody) {
				foreach (var instr in method.Body.Instructions) {
					if (instr.Operand is IMethod calledMethod)
						list.Add(calledMethod);
				}
			}
			return list;
		}

		public static bool HasString(MethodDef method, string s) {
			if (method == null || method.Body == null)
				return false;
			foreach (var instr in method.Body.Instructions) {
				if (instr.OpCode.Code == Code.Ldstr && (string)instr.Operand == s)
					return true;
			}
			return false;
		}

		public static IList<string> GetCodeStrings(MethodDef method) {
			var strings = new List<string>();
			if (method != null && method.Body != null) {
				foreach (var instr in method.Body.Instructions) {
					if (instr.OpCode.Code == Code.Ldstr)
						strings.Add((string)instr.Operand);
				}
			}
			return strings;
		}

		public static Resource GetResource(ModuleDef module, string name) =>
			GetResource(module, new List<string> { name });

		public static Resource GetResource(ModuleDef module, IEnumerable<string> strings) {
			if (!module.HasResources)
				return null;

			var resources = module.Resources;
			foreach (var tmp in strings) {
				var resourceName = RemoveFromNullChar(tmp);
				if (resourceName == null)
					continue;
				UTF8String name = resourceName;
				foreach (var resource in resources) {
					if (UTF8String.Equals(resource.Name, name))
						return resource;
				}
			}

			return null;
		}

		static string RemoveFromNullChar(string s) {
			int index = s.IndexOf((char)0);
			if (index < 0)
				return s;
			return s.Substring(0, index);
		}

		// Copies most things but not everything
		public static MethodDef Clone(MethodDef method) {
			var newMethod = new MethodDefUser(method.Name, method.MethodSig, method.ImplAttributes, method.Attributes);
			newMethod.Rid = method.Rid;
			newMethod.DeclaringType2 = method.DeclaringType;
			foreach (var pd in method.ParamDefs)
				newMethod.ParamDefs.Add(new ParamDefUser(pd.Name, pd.Sequence, pd.Attributes));
			foreach (var gp in method.GenericParameters) {
				var newGp = new GenericParamUser(gp.Number, gp.Flags, gp.Name);
				foreach (var gpc in gp.GenericParamConstraints)
					newGp.GenericParamConstraints.Add(new GenericParamConstraintUser(gpc.Constraint));
				newMethod.GenericParameters.Add(newGp);
			}
			newMethod.Body = new CilBody();
			CopyBodyFromTo(method, newMethod);
			return newMethod;
		}

		public static void CopyBody(MethodDef method, out IList<Instruction> instructions, out IList<ExceptionHandler> exceptionHandlers) {
			if (method == null || !method.HasBody) {
				instructions = new List<Instruction>();
				exceptionHandlers = new List<ExceptionHandler>();
				return;
			}

			var oldInstrs = method.Body.Instructions;
			var oldExHandlers = method.Body.ExceptionHandlers;
			instructions = new List<Instruction>(oldInstrs.Count);
			exceptionHandlers = new List<ExceptionHandler>(oldExHandlers.Count);
			var oldToIndex = Utils.CreateObjectToIndexDictionary(oldInstrs);

			foreach (var oldInstr in oldInstrs)
				instructions.Add(oldInstr.Clone());

			foreach (var newInstr in instructions) {
				var operand = newInstr.Operand;
				if (operand is Instruction)
					newInstr.Operand = instructions[oldToIndex[(Instruction)operand]];
				else if (operand is IList<Instruction> oldArray) {
					var newArray = new Instruction[oldArray.Count];
					for (int i = 0; i < oldArray.Count; i++)
						newArray[i] = instructions[oldToIndex[oldArray[i]]];
					newInstr.Operand = newArray;
				}
			}

			foreach (var oldEx in oldExHandlers) {
				var newEx = new ExceptionHandler(oldEx.HandlerType) {
					TryStart = GetInstruction(instructions, oldToIndex, oldEx.TryStart),
					TryEnd = GetInstruction(instructions, oldToIndex, oldEx.TryEnd),
					FilterStart = GetInstruction(instructions, oldToIndex, oldEx.FilterStart),
					HandlerStart = GetInstruction(instructions, oldToIndex, oldEx.HandlerStart),
					HandlerEnd = GetInstruction(instructions, oldToIndex, oldEx.HandlerEnd),
					CatchType = oldEx.CatchType,
				};
				exceptionHandlers.Add(newEx);
			}
		}

		static Instruction GetInstruction(IList<Instruction> instructions, IDictionary<Instruction, int> instructionToIndex, Instruction instruction) {
			if (instruction == null)
				return null;
			return instructions[instructionToIndex[instruction]];
		}

		public static void RestoreBody(MethodDef method, IEnumerable<Instruction> instructions, IEnumerable<ExceptionHandler> exceptionHandlers) {
			if (method == null || method.Body == null)
				return;

			var bodyInstrs = method.Body.Instructions;
			bodyInstrs.Clear();
			foreach (var instr in instructions)
				bodyInstrs.Add(instr);

			var bodyExceptionHandlers = method.Body.ExceptionHandlers;
			bodyExceptionHandlers.Clear();
			foreach (var eh in exceptionHandlers)
				bodyExceptionHandlers.Add(eh);
		}

		public static void CopyBodyFromTo(MethodDef fromMethod, MethodDef toMethod) {
			if (fromMethod == toMethod)
				return;

			CopyBody(fromMethod, out var instructions, out var exceptionHandlers);
			RestoreBody(toMethod, instructions, exceptionHandlers);
			CopyLocalsFromTo(fromMethod, toMethod);
			UpdateInstructionOperands(fromMethod, toMethod);
		}

		static void CopyLocalsFromTo(MethodDef fromMethod, MethodDef toMethod) {
			var fromBody = fromMethod.Body;
			var toBody = toMethod.Body;

			toBody.Variables.Clear();
			foreach (var local in fromBody.Variables)
				toBody.Variables.Add(new Local(local.Type));
		}

		static void UpdateInstructionOperands(MethodDef fromMethod, MethodDef toMethod) {
			var fromBody = fromMethod.Body;
			var toBody = toMethod.Body;

			toBody.InitLocals = fromBody.InitLocals;
			toBody.MaxStack = fromBody.MaxStack;

			var newOperands = new Dictionary<object, object>();
			var fromParams = fromMethod.Parameters;
			var toParams = toMethod.Parameters;
			for (int i = 0; i < fromParams.Count; i++)
				newOperands[fromParams[i]] = toParams[i];
			for (int i = 0; i < fromBody.Variables.Count; i++)
				newOperands[fromBody.Variables[i]] = toBody.Variables[i];

			foreach (var instr in toBody.Instructions) {
				if (instr.Operand == null)
					continue;
				if (newOperands.TryGetValue(instr.Operand, out object newOperand))
					instr.Operand = newOperand;
			}
		}

		public static string GetCustomArgAsString(CustomAttribute cattr, int arg) {
			if (cattr == null || arg >= cattr.ConstructorArguments.Count)
				return null;
			var carg = cattr.ConstructorArguments[arg];
			if (carg.Type.GetElementType() != ElementType.String)
				return null;
			return UTF8String.ToSystemStringOrEmpty((UTF8String)carg.Value);
		}

		public static IEnumerable<MethodDef> GetCalledMethods(ModuleDef module, MethodDef method) {
			if (method != null && method.HasBody) {
				foreach (var call in method.Body.Instructions) {
					if (call.OpCode.Code != Code.Call && call.OpCode.Code != Code.Callvirt)
						continue;
					var methodRef = call.Operand as IMethod;
					if (methodRef == null)
						continue;
					var type = GetType(module, methodRef.DeclaringType);
					var methodDef = GetMethod(type, methodRef);
					if (methodDef != null)
						yield return methodDef;
				}
			}
		}

		public static IList<Instruction> GetInstructions(IList<Instruction> instructions, int i, params OpCode[] opcodes) {
			if (i + opcodes.Length > instructions.Count)
				return null;
			if (opcodes.Length == 0)
				return new List<Instruction>();
			if (opcodes[0] != instructions[i].OpCode)
				return null;

			var list = new List<Instruction>(opcodes.Length);
			for (int j = 0; j < opcodes.Length; j++) {
				var instr = instructions[i + j];
				if (instr.OpCode != opcodes[j])
					return null;
				list.Add(instr);
			}
			return list;
		}

		public static bool HasReturnValue(IMethod method) {
			if (method == null || method.MethodSig == null || method.MethodSig.RetType == null)
				return false;
			return method.MethodSig.RetType.RemovePinnedAndModifiers().ElementType != ElementType.Void;
		}

		public static Parameter GetParameter(IList<Parameter> parameters, int index) {
			if (0 <= index && index < parameters.Count)
				return parameters[index];
			return null;
		}

		public static TypeSig GetArg(IList<TypeSig> args, int index) {
			if (0 <= index && index < args.Count)
				return args[index];
			return null;
		}

		public static List<TypeSig> GetArgs(IMethod method) {
			var sig = method.MethodSig;
			var args = new List<TypeSig>(sig.Params.Count + 1);
			if (sig.ImplicitThis)
				args.Add(method.DeclaringType.ToTypeSig());
			foreach (var arg in sig.Params)
				args.Add(arg);
			return args;
		}

		public static int GetArgsCount(IMethod method) {
			var sig = method.MethodSig;
			if (sig == null)
				return 0;
			int count = sig.Params.Count;
			if (sig.ImplicitThis)
				count++;
			return count;
		}

		public static IList<TypeSig> ReplaceGenericParameters(GenericInstSig typeOwner, MethodSpec methodOwner, IList<TypeSig> types) {
			if (typeOwner == null && methodOwner == null)
				return types;
			for (int i = 0; i < types.Count; i++)
				types[i] = GetGenericArgument(typeOwner, methodOwner, types[i]);
			return types;
		}

		public static TypeSig GetGenericArgument(GenericInstSig typeOwner, MethodSpec methodOwner, TypeSig type) {
			var typeArgs = typeOwner?.GenericArguments;
			var genMethodArgs = methodOwner == null || methodOwner.GenericInstMethodSig == null ?
						null : methodOwner.GenericInstMethodSig.GenericArguments;
			return GenericArgsSubstitutor.Create(type, typeArgs, genMethodArgs);
		}

		public static Instruction GetInstruction(IList<Instruction> instructions, ref int index) {
			for (int i = 0; i < 10; i++) {
				if (index < 0 || index >= instructions.Count)
					return null;
				var instr = instructions[index++];
				if (instr.OpCode.Code == Code.Nop)
					continue;
				if (instr.OpCode.OpCodeType == OpCodeType.Prefix)
					continue;
				if (instr == null || (instr.OpCode.Code != Code.Br && instr.OpCode.Code != Code.Br_S))
					return instr;
				instr = instr.Operand as Instruction;
				if (instr == null)
					return null;
				index = instructions.IndexOf(instr);
			}
			return null;
		}

		public static TypeDefOrRefSig FindOrCreateTypeRef(ModuleDef module, AssemblyRef asmRef, string ns, string name, bool isValueType) {
			var typeRef = module.UpdateRowId(new TypeRefUser(module, ns, name, asmRef));
			if (isValueType)
				return new ValueTypeSig(typeRef);
			else
				return new ClassSig(typeRef);
		}

		public static FrameworkType GetFrameworkType(ModuleDefMD module) {
			foreach (var modRef in module.GetAssemblyRefs()) {
				if (modRef.Name != "mscorlib")
					continue;
				if (PublicKeyBase.IsNullOrEmpty2(modRef.PublicKeyOrToken))
					continue;
				switch (BitConverter.ToString(modRef.PublicKeyOrToken.Data).Replace("-", "").ToLowerInvariant()) {
				case "b77a5c561934e089":
					return FrameworkType.Desktop;
				case "7cec85d7bea7798e":
					return FrameworkType.Silverlight;
				case "969db8053d3322ac":
					return FrameworkType.CompactFramework;
				case "1c9e259686f921e0":
					return FrameworkType.XNA;
				case "e92a8b81eba7ceb7":
					return FrameworkType.Zune;
				}
			}

			return FrameworkType.Unknown;
		}

		public static int GetMethodCalls(MethodDef method, string methodFullName) {
			if (method == null || method.Body == null)
				return 0;

			int count = 0;
			foreach (var instr in method.Body.Instructions) {
				if (instr.OpCode.Code != Code.Call && instr.OpCode.Code != Code.Callvirt && instr.OpCode.Code != Code.Newobj)
					continue;
				var calledMethod = instr.Operand as IMethod;
				if (calledMethod == null)
					continue;
				if (calledMethod.FullName == methodFullName)
					count++;
			}

			return count;
		}

		public static bool CallsMethod(MethodDef method, string methodFullName) {
			if (method == null || method.Body == null)
				return false;

			foreach (var instr in method.Body.Instructions) {
				if (instr.OpCode.Code != Code.Call && instr.OpCode.Code != Code.Callvirt && instr.OpCode.Code != Code.Newobj)
					continue;
				var calledMethod = instr.Operand as IMethod;
				if (calledMethod == null)
					continue;
				if (calledMethod.FullName == methodFullName)
					return true;
			}

			return false;
		}

		public static bool CallsMethod(MethodDef method, string returnType, string parameters) {
			if (method == null || method.Body == null)
				return false;

			foreach (var instr in method.Body.Instructions) {
				if (instr.OpCode.Code != Code.Call && instr.OpCode.Code != Code.Callvirt && instr.OpCode.Code != Code.Newobj)
					continue;
				if (IsMethod(instr.Operand as IMethod, returnType, parameters))
					return true;
			}

			return false;
		}

		public static IList<Instruction> GetArgPushes(IList<Instruction> instrs, int index) =>
			GetArgPushes(instrs, ref index);

		public static IList<Instruction> GetArgPushes(IList<Instruction> instrs, ref int index) {
			if (index < 0 || index >= instrs.Count)
				return null;
			var startInstr = instrs[index];
			startInstr.CalculateStackUsage(false, out int pushes, out int pops);

			index--;
			int numArgs = pops;
			var args = new List<Instruction>(numArgs);
			int stackSize = numArgs;
			while (index >= 0 && args.Count != numArgs) {
				var instr = instrs[index--];
				instr.CalculateStackUsage(false, out pushes, out pops);
				if (instr.OpCode.Code == Code.Dup) {
					args.Add(instr);
					stackSize--;
				}
				else {
					if (pushes == 1)
						args.Add(instr);
					else if (pushes > 1)
						throw new NotImplementedException();
					stackSize -= pushes;

					if (pops != 0) {
						index++;
						if (GetArgPushes(instrs, ref index) == null)
							return null;
					}
				}

				if (stackSize < 0)
					return null;
			}
			if (args.Count != numArgs)
				return null;
			args.Reverse();
			return args;
		}
	}
}



================================================
File: de4dot.blocks/DumpedMethod.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;

namespace de4dot.blocks {
	[Serializable]
	public class DumpedMethod {
		public ushort mhFlags;			// method header Flags
		public ushort mhMaxStack;		// method header MaxStack
		public uint mhCodeSize;			// method header CodeSize
		public uint mhLocalVarSigTok;	// method header LocalVarSigTok

		public uint mdRVA;				// methodDef RVA
		public ushort mdImplFlags;		// methodDef ImplFlags
		public ushort mdFlags;			// methodDef Flags
		public uint mdName;				// methodDef Name (index into #String)
		public uint mdSignature;		// methodDef Signature (index into #Blob)
		public uint mdParamList;		// methodDef ParamList (index into Param table)

		public uint token;				// metadata token

		public byte[] code;
		public byte[] extraSections;
	}
}



================================================
File: de4dot.blocks/DumpedMethods.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet.MD;
using dnlib.DotNet;

namespace de4dot.blocks {
	[Serializable]
	public class DumpedMethods {
		Dictionary<uint, DumpedMethod> methods = new Dictionary<uint, DumpedMethod>();

		public int Count => methods.Count;
		public void Add(uint token, DumpedMethod info) => methods[token] = info;
		public DumpedMethod Get(MethodDef method) => Get(method.MDToken.ToUInt32());

		public DumpedMethod Get(uint token) {
			methods.TryGetValue(token, out var dm);
			return dm;
		}

		public void Add(DumpedMethod dm) {
			if (MDToken.ToTable(dm.token) != Table.Method || MDToken.ToRID(dm.token) == 0)
				throw new ArgumentException("Invalid token");
			methods[dm.token] = dm;
		}
	}
}



================================================
File: de4dot.blocks/FilterHandlerBlock.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

namespace de4dot.blocks {
	public class FilterHandlerBlock : ScopeBlock {
	}
}



================================================
File: de4dot.blocks/ForwardScanOrder.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet.Emit;

namespace de4dot.blocks {
	// This class makes sure that each block that is entered with a non-empty stack has at
	// least one of its source blocks sorted before itself. This is to make sure peverify
	// doesn't complain AND also to make sure dnlib sets the correct maxstack.
	class ForwardScanOrder {
		ScopeBlock scopeBlock;
		IList<BaseBlock> sorted;
		Dictionary<BaseBlock, BlockInfo> blockInfos = new Dictionary<BaseBlock, BlockInfo>();
		Dictionary<BaseBlock, bool> inNewList = new Dictionary<BaseBlock, bool>();
		List<BaseBlock> newList;

		class BlockInfo {
			BaseBlock baseBlock;
			public int stackStart = 0;
			public int stackEnd = 0;

			public BlockInfo(BaseBlock baseBlock, int stackStart) {
				this.baseBlock = baseBlock;
				this.stackStart = stackStart;
			}

			public void CalculateStackUsage() {
				var block = baseBlock as Block;
				if (block == null) {
					stackEnd = stackStart;
					return;
				}

				int stack = stackStart;
				foreach (var instr in block.Instructions)
					instr.Instruction.UpdateStack(ref stack, false);
				stackEnd = stack;
			}
		}

		public ForwardScanOrder(ScopeBlock scopeBlock, IList<BaseBlock> sorted) {
			this.scopeBlock = scopeBlock;
			this.sorted = sorted;
		}

		public List<BaseBlock> Fix() {
			CreateBlockInfos();
			CreateNewList();
			return newList;
		}

		void CreateBlockInfos() {
			int firstBlockStackStart = 0;
			if ((scopeBlock is HandlerBlock || scopeBlock is FilterHandlerBlock) &&
				scopeBlock.Parent is TryHandlerBlock tryHandlerBlock &&
				(tryHandlerBlock.HandlerType == ExceptionHandlerType.Catch || tryHandlerBlock.HandlerType == ExceptionHandlerType.Filter)) {
				firstBlockStackStart = 1;
			}
			foreach (var bb in GetStartBlocks()) {
				int stackStart = ReferenceEquals(bb, sorted[0]) ? firstBlockStackStart : 0;
				ScanBaseBlock(bb, stackStart);
			}

			// One reason for this to fail is if there are still dead blocks left. Could also
			// be a bug in the code.
			if (blockInfos.Count != sorted.Count)
				throw new ApplicationException($"Didn't add all blocks: {blockInfos.Count} vs {sorted.Count}");
		}

		IEnumerable<BaseBlock> GetStartBlocks() {
			if (sorted.Count > 0) {
				yield return sorted[0];
				foreach (var bb in sorted) {
					if (ReferenceEquals(bb, sorted[0]))
						continue;
					var block = bb as Block;
					if (block == null || block.Sources == null || IsOneSourceInAnotherScopeBlock(block))
						yield return bb;
				}
			}
		}

		bool IsOneSourceInAnotherScopeBlock(Block block) {
			foreach (var source in block.Sources) {
				if (!scopeBlock.IsOurBaseBlock(source))
					return true;
			}
			return false;
		}

		struct ScanBaseBlockState {
			public BaseBlock bb;
			public int stackStart;
			public ScanBaseBlockState(BaseBlock bb, int stackStart) {
				this.bb = bb;
				this.stackStart = stackStart;
			}
		}
		Stack<ScanBaseBlockState> scanBaseBlockStack = new Stack<ScanBaseBlockState>();
		void ScanBaseBlock(BaseBlock bb, int stackStart) {
			scanBaseBlockStack.Push(new ScanBaseBlockState(bb, stackStart));
			while (scanBaseBlockStack.Count > 0) {
				var state = scanBaseBlockStack.Pop();
				if (blockInfos.ContainsKey(state.bb) || !scopeBlock.IsOurBaseBlock(state.bb))
					continue;

				var blockInfo = new BlockInfo(state.bb, state.stackStart);
				blockInfos[state.bb] = blockInfo;

				var block = state.bb as Block;
				if (block == null) {	// i.e., if try, filter, or handler block
					// It's not important to know the exact values, so we set them both to 0.
					// Compilers must make sure the stack is empty when entering a try block.
					blockInfo.stackStart = blockInfo.stackEnd = 0;
					continue;
				}

				blockInfo.CalculateStackUsage();

				foreach (var target in block.GetTargets())
					scanBaseBlockStack.Push(new ScanBaseBlockState(target, blockInfo.stackEnd));
			}
		}

		void CreateNewList() {
			newList = new List<BaseBlock>(sorted.Count);
			foreach (var bb in sorted)
				AddToNewList(bb);
			if (newList.Count != sorted.Count)
				throw new ApplicationException($"Too many/few blocks after sorting: {newList.Count} vs {sorted.Count}");
			if (newList.Count > 0 && !ReferenceEquals(newList[0], sorted[0]))
				throw new ApplicationException("Start block is not first block after sorting");
		}

		void AddToNewList(BaseBlock bb) {
			if (inNewList.ContainsKey(bb) || !scopeBlock.IsOurBaseBlock(bb))
				return;
			inNewList[bb] = false;

			var blockInfo = blockInfos[bb];
			var block = bb as Block;
			if (blockInfo.stackStart == 0 || ReferenceEquals(bb, sorted[0]) ||
				block == null || block.Sources == null || IsInNewList(block.Sources)) {
			}
			else {
				foreach (var source in block.Sources) {
					if (!scopeBlock.IsOurBaseBlock(source))
						continue;
					int oldCount = newList.Count;
					AddToNewList(source);	// Make sure it's before this block
					if (oldCount != newList.Count)
						break;
				}
			}

			inNewList[bb] = true;
			newList.Add(bb);
		}

		bool IsInNewList(IEnumerable<Block> blocks) {
			foreach (var block in blocks) {
				if (inNewList.ContainsKey(block) && inNewList[block])
					return true;
			}
			return false;
		}
	}
}



================================================
File: de4dot.blocks/GenericArgsSubstitutor.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet;

namespace de4dot.blocks {
	public struct GenericArgsSubstitutor {
		IList<TypeSig> genericArgs;
		IList<TypeSig> genericMethodArgs;
		bool updated;

		public static ITypeDefOrRef Create(ITypeDefOrRef type, GenericInstSig git) {
			if (git == null)
				return type;
			return Create(type, git.GenericArguments);
		}

		public static ITypeDefOrRef Create(ITypeDefOrRef type, IList<TypeSig> genericArgs) {
			if (genericArgs == null || genericArgs.Count == 0)
				return type;
			var ts = type as TypeSpec;
			if (ts == null)
				return type;
			var newSig = Create(ts.TypeSig, genericArgs);
			return newSig == ts.TypeSig ? type : new TypeSpecUser(newSig);
		}

		public static TypeSig Create(TypeSig type, IList<TypeSig> genericArgs) {
			if (type == null || genericArgs == null || genericArgs.Count == 0)
				return type;
			return new GenericArgsSubstitutor(genericArgs).Create(type);
		}

		public static TypeSig Create(TypeSig type, IList<TypeSig> genericArgs, IList<TypeSig> genericMethodArgs) {
			if (type == null || ((genericArgs == null || genericArgs.Count == 0) &&
				(genericMethodArgs == null || genericMethodArgs.Count == 0)))
				return type;
			return new GenericArgsSubstitutor(genericArgs, genericMethodArgs).Create(type);
		}

		public static IField Create(IField field, GenericInstSig git) {
			if (git == null)
				return field;
			return Create(field, git.GenericArguments);
		}

		public static IField Create(IField field, IList<TypeSig> genericArgs) {
			if (field == null || genericArgs == null || genericArgs.Count == 0)
				return field;
			var newSig = Create(field.FieldSig, genericArgs);
			if (newSig == field.FieldSig)
				return field;
			var module = field.DeclaringType?.Module;
			return new MemberRefUser(module, field.Name, newSig, field.DeclaringType);
		}

		public static FieldSig Create(FieldSig sig, GenericInstSig git) {
			if (git == null)
				return sig;
			return Create(sig, git.GenericArguments);
		}

		public static FieldSig Create(FieldSig sig, IList<TypeSig> genericArgs) {
			if (sig == null || genericArgs == null || genericArgs.Count == 0)
				return sig;
			return new GenericArgsSubstitutor(genericArgs).Create(sig);
		}

		public static IMethod Create(IMethod method, GenericInstSig git) {
			if (git == null)
				return method;

			if (method is IMethodDefOrRef mdr)
				return Create(mdr, git);

			if (method is MethodSpec ms)
				return Create(ms, git);

			return method;
		}

		public static MethodSpec Create(MethodSpec method, GenericInstSig git) {
			if (method == null || git == null)
				return method;
			var newMethod = Create(method.Method, git);
			var newInst = Create(method.GenericInstMethodSig, git);
			bool updated = newMethod != method.Method || newInst != method.GenericInstMethodSig;
			return updated ? new MethodSpecUser(newMethod, newInst) : method;
		}

		public static GenericInstMethodSig Create(GenericInstMethodSig sig, GenericInstSig git) {
			if (git == null)
				return sig;
			return Create(sig, git.GenericArguments);
		}

		public static GenericInstMethodSig Create(GenericInstMethodSig sig, IList<TypeSig> genericArgs) {
			if (sig == null || genericArgs == null || genericArgs.Count == 0)
				return sig;
			return new GenericArgsSubstitutor(genericArgs).Create(sig);
		}

		public static IMethodDefOrRef Create(IMethodDefOrRef method, GenericInstSig git) {
			if (git == null)
				return method;
			return Create(method, git.GenericArguments);
		}

		public static IMethodDefOrRef Create(IMethodDefOrRef method, IList<TypeSig> genericArgs) =>
			Create(method, genericArgs, null);

		public static IMethodDefOrRef Create(IMethodDefOrRef method, GenericInstSig git, IList<TypeSig> genericMethodArgs) =>
			Create(method, git?.GenericArguments, genericMethodArgs);

		// Creates a new method but keeps declaring type as is
		public static IMethodDefOrRef Create(IMethodDefOrRef method, IList<TypeSig> genericArgs, IList<TypeSig> genericMethodArgs) {
			if (method == null)
				return method;
			if ((genericArgs == null || genericArgs.Count == 0) && (genericMethodArgs == null || genericMethodArgs.Count == 0))
				return method;

			var sig = method.MethodSig;
			if (sig == null)
				return method;

			var newSig = new GenericArgsSubstitutor(genericArgs, genericMethodArgs).Create(sig);
			if (newSig == sig)
				return method;

			return new MemberRefUser(method.DeclaringType.Module, method.Name, newSig, method.DeclaringType);
		}

		GenericArgsSubstitutor(IList<TypeSig> genericArgs) {
			this.genericArgs = genericArgs;
			genericMethodArgs = null;
			updated = false;
		}

		GenericArgsSubstitutor(IList<TypeSig> genericArgs, IList<TypeSig> genericMethodArgs) {
			this.genericArgs = genericArgs;
			this.genericMethodArgs = genericMethodArgs;
			updated = false;
		}

		TypeSig Create(TypeSig type) {
			var newType = Create2(type);
			return updated ? newType : type;
		}

		TypeSig Create2(TypeSig type) {
			if (type == null)
				return type;
			TypeSig result;

			GenericSig varSig;
			switch (type.ElementType) {
			case ElementType.Void:
			case ElementType.Boolean:
			case ElementType.Char:
			case ElementType.I1:
			case ElementType.U1:
			case ElementType.I2:
			case ElementType.U2:
			case ElementType.I4:
			case ElementType.U4:
			case ElementType.I8:
			case ElementType.U8:
			case ElementType.R4:
			case ElementType.R8:
			case ElementType.String:
			case ElementType.TypedByRef:
			case ElementType.I:
			case ElementType.U:
			case ElementType.Object:
				result = type;
				break;

			case ElementType.Ptr:
				result = new PtrSig(Create2(type.Next));
				break;

			case ElementType.ByRef:
				result = new ByRefSig(Create2(type.Next));
				break;

			case ElementType.Array:
				var ary = (ArraySig)type;
				result = new ArraySig(ary.Next, ary.Rank, ary.Sizes, ary.LowerBounds);
				break;

			case ElementType.SZArray:
				result = new SZArraySig(Create2(type.Next));
				break;

			case ElementType.Pinned:
				result = new PinnedSig(Create2(type.Next));
				break;

			case ElementType.ValueType:
			case ElementType.Class:
				result = type;
				break;

			case ElementType.Var:
				varSig = (GenericSig)type;
				if (genericArgs != null && varSig.Number < (uint)genericArgs.Count) {
					result = genericArgs[(int)varSig.Number];
					updated = true;
				}
				else
					result = type;
				break;

			case ElementType.MVar:
				varSig = (GenericSig)type;
				if (genericMethodArgs != null && varSig.Number < (uint)genericMethodArgs.Count) {
					result = genericMethodArgs[(int)varSig.Number];
					updated = true;
				}
				else
					result = type;
				break;

			case ElementType.GenericInst:
				var gis = (GenericInstSig)type;
				var newGis = new GenericInstSig(Create2(gis.GenericType) as ClassOrValueTypeSig, gis.GenericArguments.Count);
				for (int i = 0; i < gis.GenericArguments.Count; i++)
					newGis.GenericArguments.Add(Create2(gis.GenericArguments[i]));
				result = newGis;
				break;

			case ElementType.ValueArray:
				result = new ValueArraySig(type.Next, ((ValueArraySig)type).Size);
				break;

			case ElementType.Module:
				result = new ModuleSig(((ModuleSig)type).Index, type.Next);
				break;

			case ElementType.CModReqd:
				result = new CModReqdSig(((ModifierSig)type).Modifier, type.Next);
				break;

			case ElementType.CModOpt:
				result = new CModOptSig(((ModifierSig)type).Modifier, type.Next);
				break;

			case ElementType.FnPtr:
				result = new FnPtrSig(Create(((FnPtrSig)type).MethodSig));
				break;

			case ElementType.End:
			case ElementType.R:
			case ElementType.Sentinel:
			case ElementType.Internal:
			default:
				result = type;
				break;
			}

			return result;
		}

		MethodSig Create(MethodSig sig) {
			if (sig == null)
				return sig;
			var newSig = new MethodSig(sig.GetCallingConvention());
			newSig.RetType = Create2(sig.RetType);
			for (int i = 0; i < sig.Params.Count; i++)
				newSig.Params.Add(Create2(sig.Params[i]));
			newSig.GenParamCount = sig.GenParamCount;
			if (sig.ParamsAfterSentinel != null) {
				newSig.ParamsAfterSentinel = new List<TypeSig>();
				for (int i = 0; i < sig.ParamsAfterSentinel.Count; i++)
					newSig.ParamsAfterSentinel.Add(Create2(sig.ParamsAfterSentinel[i]));
			}
			return updated ? newSig : sig;
		}

		GenericInstMethodSig Create(GenericInstMethodSig sig) {
			var newSig = new GenericInstMethodSig();
			for (int i = 0; i < sig.GenericArguments.Count; i++)
				newSig.GenericArguments.Add(Create2(sig.GenericArguments[i]));
			return updated ? newSig : sig;
		}

		FieldSig Create(FieldSig sig) {
			var newSig = new FieldSig(Create2(sig.Type));
			return updated ? newSig : sig;
		}
	}
}



================================================
File: de4dot.blocks/HandlerBlock.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

namespace de4dot.blocks {
	// This is the block inside catch(xxx) { }.
	public class HandlerBlock : ScopeBlock {
	}
}



================================================
File: de4dot.blocks/Instr.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet.Emit;

namespace de4dot.blocks {
	public class Instr {
		Instruction instruction;

		public OpCode OpCode => instruction.OpCode;

		public object Operand {
			get => instruction.Operand;
			set => instruction.Operand = value;
		}

		public Instr(Instruction instruction) => this.instruction = instruction;

		public Instruction Instruction => instruction;

		// Returns the variable or null if it's not a ldloc/stloc instruction. It does not return
		// a local variable if it's a ldloca/ldloca.s instruction.
		public static Local GetLocalVar(IList<Local> locals, Instr instr) {
			if (instr.Instruction.IsLdloc() || instr.Instruction.IsStloc())
				return instr.Instruction.GetLocal(locals);
			return null;
		}

		static public bool IsFallThrough(OpCode opCode) {
			switch (opCode.FlowControl) {
			case FlowControl.Call:
				return opCode != OpCodes.Jmp;
			case FlowControl.Cond_Branch:
			case FlowControl.Next:
				return true;
			default:
				return false;
			}
		}

		// Returns true if the instruction only pushes one value onto the stack and pops nothing
		public bool IsSimpleLoad() {
			switch (OpCode.Code) {
			case Code.Ldarg:
			case Code.Ldarg_S:
			case Code.Ldarg_0:
			case Code.Ldarg_1:
			case Code.Ldarg_2:
			case Code.Ldarg_3:
			case Code.Ldarga:
			case Code.Ldarga_S:
			case Code.Ldc_I4:
			case Code.Ldc_I4_S:
			case Code.Ldc_I4_0:
			case Code.Ldc_I4_1:
			case Code.Ldc_I4_2:
			case Code.Ldc_I4_3:
			case Code.Ldc_I4_4:
			case Code.Ldc_I4_5:
			case Code.Ldc_I4_6:
			case Code.Ldc_I4_7:
			case Code.Ldc_I4_8:
			case Code.Ldc_I4_M1:
			case Code.Ldc_I8:
			case Code.Ldc_R4:
			case Code.Ldc_R8:
			case Code.Ldloc:
			case Code.Ldloc_S:
			case Code.Ldloc_0:
			case Code.Ldloc_1:
			case Code.Ldloc_2:
			case Code.Ldloc_3:
			case Code.Ldloca:
			case Code.Ldloca_S:
			case Code.Ldnull:
			case Code.Ldstr:
			case Code.Ldtoken:
				return true;
			default:
				return false;
			}
		}

		public bool IsLdcI4() => instruction.IsLdcI4();
		public int GetLdcI4Value() => instruction.GetLdcI4Value();
		public bool IsLdarg() => instruction.IsLdarg();
		public bool IsStloc() => instruction.IsStloc();
		public bool IsLdloc() => instruction.IsLdloc();
		public bool IsNop() => OpCode == OpCodes.Nop;
		public bool IsPop() => OpCode == OpCodes.Pop;
		public bool IsLeave() => instruction.IsLeave();
		public bool IsBr() => instruction.IsBr();
		public bool IsBrfalse() => instruction.IsBrfalse();
		public bool IsBrtrue() => instruction.IsBrtrue();
		public bool IsConditionalBranch() => instruction.IsConditionalBranch();

		public bool GetFlippedBranchOpCode(out OpCode opcode) {
			switch (OpCode.Code) {
			case Code.Bge:		opcode = OpCodes.Blt; return true;
			case Code.Bge_S:	opcode = OpCodes.Blt_S; return true;
			case Code.Bge_Un:	opcode = OpCodes.Blt_Un; return true;
			case Code.Bge_Un_S: opcode = OpCodes.Blt_Un_S; return true;

			case Code.Blt:		opcode = OpCodes.Bge; return true;
			case Code.Blt_S:	opcode = OpCodes.Bge_S; return true;
			case Code.Blt_Un:	opcode = OpCodes.Bge_Un; return true;
			case Code.Blt_Un_S: opcode = OpCodes.Bge_Un_S; return true;

			case Code.Bgt:		opcode = OpCodes.Ble; return true;
			case Code.Bgt_S:	opcode = OpCodes.Ble_S; return true;
			case Code.Bgt_Un:	opcode = OpCodes.Ble_Un; return true;
			case Code.Bgt_Un_S: opcode = OpCodes.Ble_Un_S; return true;

			case Code.Ble:		opcode = OpCodes.Bgt; return true;
			case Code.Ble_S:	opcode = OpCodes.Bgt_S; return true;
			case Code.Ble_Un:	opcode = OpCodes.Bgt_Un; return true;
			case Code.Ble_Un_S: opcode = OpCodes.Bgt_Un_S; return true;

			case Code.Brfalse:	opcode = OpCodes.Brtrue; return true;
			case Code.Brfalse_S:opcode = OpCodes.Brtrue_S; return true;

			case Code.Brtrue:	opcode = OpCodes.Brfalse; return true;
			case Code.Brtrue_S: opcode = OpCodes.Brfalse_S; return true;

			// Can't flip beq and bne.un since it's object vs uint/float
			case Code.Beq:
			case Code.Beq_S:
			case Code.Bne_Un:
			case Code.Bne_Un_S:
			default:
				opcode = OpCodes.Nop;	// Whatever...
				return false;
			}
		}

		public void FlipConditonalBranch() {
			if (!GetFlippedBranchOpCode(out var opcode))
				throw new ApplicationException("Can't flip conditional since it's not a supported conditional instruction");
			instruction.OpCode = opcode;
		}

		// Returns true if we can flip a conditional branch
		public bool CanFlipConditionalBranch() => GetFlippedBranchOpCode(out var opcode);

		public void UpdateTargets(List<Instr> targets) {
			switch (OpCode.OperandType) {
			case OperandType.ShortInlineBrTarget:
			case OperandType.InlineBrTarget:
				if (targets.Count != 1)
					throw new ApplicationException("More than one target!");
				instruction.Operand = targets[0].Instruction;
				break;

			case OperandType.InlineSwitch:
				var switchTargets = new Instruction[targets.Count];
				for (var i = 0; i < targets.Count; i++)
					switchTargets[i] = targets[i].Instruction;
				instruction.Operand = switchTargets;
				break;

			default:
				if (targets.Count != 0)
					throw new ApplicationException("This instruction doesn't have any targets!");
				break;
			}
		}

		public override string ToString() => instruction.ToString();
	}
}



================================================
File: de4dot.blocks/InstructionListParser.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet.Emit;

namespace de4dot.blocks {
	class InstructionListParser {
		IList<Instruction> instructions;
		IList<ExceptionHandler> exceptionHandlers;
		Dictionary<Instruction, int> instrToIndex;
		Dictionary<int, List<int>> branches;	// key = dest index, value = instrs branching to dest

		public InstructionListParser(IList<Instruction> instructions, IList<ExceptionHandler> exceptionHandlers) {
			this.instructions = instructions;
			this.exceptionHandlers = exceptionHandlers;
			branches = new Dictionary<int, List<int>>();

			CreateInstrToIndex();
			CreateBranches();
			CreateExceptionBranches();
		}

		void CreateInstrToIndex() {
			instrToIndex = new Dictionary<Instruction, int>();

			for (int i = 0; i < instructions.Count; i++)
				instrToIndex[instructions[i]] = i;
		}

		List<int> GetBranchTargetList(int index) {
			if (!branches.TryGetValue(index, out var targetsList))
				branches[index] = targetsList = new List<int>();
			return targetsList;
		}

		void MarkAsBranchTarget(Instruction instr) {
			if (instr == null)
				return;

			int index = instrToIndex[instr];
			GetBranchTargetList(index);	// Just create the list
		}

		void CreateExceptionBranches() {
			foreach (var eh in exceptionHandlers) {
				MarkAsBranchTarget(eh.TryStart);
				MarkAsBranchTarget(eh.TryEnd);
				MarkAsBranchTarget(eh.FilterStart);
				MarkAsBranchTarget(eh.HandlerStart);
				MarkAsBranchTarget(eh.HandlerEnd);
			}
		}

		void CreateBranches() {
			for (int i = 0; i < instructions.Count; i++) {
				var instr = instructions[i];

				List<int> targets = null;
				switch (instr.OpCode.OperandType) {
				case OperandType.ShortInlineBrTarget:
				case OperandType.InlineBrTarget:
					var targetInstr = instr.Operand as Instruction;
					if (targetInstr != null)
						targets = new List<int> { instrToIndex[targetInstr] };
					break;

				case OperandType.InlineSwitch:
					var switchTargets = (Instruction[])instr.Operand;
					targets = new List<int>(switchTargets.Length);
					for (int j = 0; j < switchTargets.Length; j++) {
						var target = switchTargets[j];
						if (target == null)
							continue;
						targets.Add(instrToIndex[target]);
					}
					break;

				default:
					switch (instr.OpCode.Code) {
					case Code.Endfilter:
					case Code.Endfinally:
					case Code.Jmp:
					case Code.Ret:
					case Code.Rethrow:
					case Code.Throw:
						targets = new List<int>();
						break;
					}
					break;
				}

				if (targets != null) {
					if (i + 1 < instructions.Count)
						targets.Add(i + 1);
					for (int j = 0; j < targets.Count; j++) {
						int targetIndex = targets[j];
						GetBranchTargetList(targetIndex).Add(i);
					}
				}
			}
		}

		void FindBlocks(List<Block> instrToBlock, List<Block> allBlocks) {
			Block block = null;
			for (var i = 0; i < instructions.Count; i++) {
				if (branches.TryGetValue(i, out var branchSources) || block == null) {
					block = new Block();
					allBlocks.Add(block);
				}

				block.Add(new Instr(instructions[i]));
				instrToBlock.Add(block);
			}
		}

		// Fix all branches so they now point to a Block, and not an Instruction. The
		// block's Targets field is updated, not the Instruction's Operand field.
		// Also update Block.FallThrough with next Block if last instr falls through.
		void FixBranchTargets(List<Block> instrToBlock, List<Block> allBlocks) {
			for (var i = 0; i < allBlocks.Count; i++) {
				var block = allBlocks[i];
				var lastInstr = block.LastInstr;

				switch (lastInstr.OpCode.OperandType) {
				case OperandType.ShortInlineBrTarget:
				case OperandType.InlineBrTarget:
					var targetInstr = lastInstr.Operand as Instruction;
					if (targetInstr != null)
						block.Targets = new List<Block> { instrToBlock[instrToIndex[targetInstr]] };
					break;

				case OperandType.InlineSwitch:
					var switchTargets = (Instruction[])lastInstr.Operand;
					var newSwitchTargets = new List<Block>();
					block.Targets = newSwitchTargets;
					foreach (var target in switchTargets) {
						if (target != null)
							newSwitchTargets.Add(instrToBlock[instrToIndex[target]]);
					}
					break;
				}

				if (i + 1 < allBlocks.Count && Instr.IsFallThrough(lastInstr.OpCode))
					block.FallThrough = allBlocks[i + 1];
			}
		}

		// Updates the sources field of each block
		void FixBlockSources(List<Block> allBlocks) {
			foreach (var block in allBlocks) {
				block.UpdateSources();
			}
		}

		class EHInfo {
			public ExceptionHandler eh;

			public EHInfo(ExceptionHandler eh) => this.eh = eh;

			public override int GetHashCode() {
				int res = eh.TryStart.GetHashCode();
				if (eh.TryEnd != null)
					res += eh.TryEnd.GetHashCode();
				return res;
			}

			public override bool Equals(object obj) {
				var other = obj as EHInfo;
				if (other == null)
					return false;
				return ReferenceEquals(eh.TryStart, other.eh.TryStart) &&
					   ReferenceEquals(eh.TryEnd, other.eh.TryEnd);
			}
		}

		List<List<ExceptionHandler>> GetSortedExceptionInfos() {
			var exInfos = new Dictionary<EHInfo, List<ExceptionHandler>>();
			foreach (var eh in exceptionHandlers) {
				if (!exInfos.TryGetValue(new EHInfo(eh), out var handlers))
					exInfos[new EHInfo(eh)] = handlers = new List<ExceptionHandler>();

				handlers.Add(eh);
				if (!ReferenceEquals(handlers[0].TryEnd, eh.TryEnd))
					throw new ApplicationException("Exception handler's try block does not start and end at the same place as the other one.");
			}

			var exSorted = new List<List<ExceptionHandler>>(exInfos.Values);
			exSorted.Sort((a, b) => {
				int ai, bi;

				// Sort in reverse order of TryStart. This is to make sure that nested
				// try handlers are before the outer try handler.
				ai = instrToIndex[a[0].TryStart];
				bi = instrToIndex[b[0].TryStart];
				if (ai > bi) return -1;
				if (ai < bi) return 1;

				// Same start instruction. The nested one is the one that ends earliest,
				// so it should be sorted before the outer one.
				ai = GetInstrIndex(a[0].TryEnd);
				bi = GetInstrIndex(b[0].TryEnd);
				if (ai < bi) return -1;
				if (ai > bi) return 1;

				return 0;
			});

			return exSorted;
		}

		class BaseBlocksList {
			class BaseBlockInfo {
				public int startInstr, endInstr;
				public BaseBlock baseBlock;

				public BaseBlockInfo(int start, int end, BaseBlock bb) {
					startInstr = start;
					endInstr = end;
					baseBlock = bb;
				}
			}

			List<BaseBlockInfo> blocksLeft = new List<BaseBlockInfo>();

			public void Add(BaseBlock bb, int start, int end) {
				if (start < 0 || end < 0 || end < start)
					throw new ApplicationException("Invalid start and/or end index");
				if (blocksLeft.Count != 0) {
					var bbi = blocksLeft[blocksLeft.Count - 1];
					if (bbi.endInstr + 1 != start)
						throw new ApplicationException("Previous BaseBlock does not end where this new one starts");
				}
				blocksLeft.Add(new BaseBlockInfo(start, end, bb));
			}

			int FindStart(int instrIndex) {
				for (int i = 0; i < blocksLeft.Count; i++) {
					if (blocksLeft[i].startInstr == instrIndex)
						return i;
				}
				throw new ApplicationException("Could not find start BaseBlockInfo");
			}

			int FindEnd(int instrIndex) {
				for (int i = 0; i < blocksLeft.Count; i++) {
					if (blocksLeft[i].endInstr == instrIndex)
						return i;
				}
				throw new ApplicationException("Could not find end BaseBlockInfo");
			}

			List<BaseBlock> GetBlocks(int startInstr, int endInstr, out int startIndex, out int endIndex) {
				if (endInstr < startInstr || startInstr < 0 || endInstr < 0)
					throw new ApplicationException("Invalid startInstr and/or endInstr");

				var rv = new List<BaseBlock>();

				startIndex = FindStart(startInstr);
				endIndex = FindEnd(endInstr);

				for (int i = startIndex; i <= endIndex; i++)
					rv.Add(blocksLeft[i].baseBlock);

				return rv;
			}

			// Replace the BaseBlocks with a new BaseBlock, returning the old ones.
			public List<BaseBlock> Replace(int startInstr, int endInstr, ScopeBlock bb) {
				if (endInstr < startInstr)
					return new List<BaseBlock>();

				var rv = GetBlocks(startInstr, endInstr, out int startIndex, out int endIndex);
				UpdateParent(rv, bb);

				var bbi = new BaseBlockInfo(blocksLeft[startIndex].startInstr, blocksLeft[endIndex].endInstr, bb);
				blocksLeft.RemoveRange(startIndex, endIndex - startIndex + 1);
				blocksLeft.Insert(startIndex, bbi);

				return rv;
			}

			public List<BaseBlock> GetBlocks(ScopeBlock parent) {
				if (blocksLeft.Count == 0)
					return new List<BaseBlock>();
				var lb = GetBlocks(0, blocksLeft[blocksLeft.Count - 1].endInstr, out int startIndex, out int endIndex);
				return UpdateParent(lb, parent);
			}

			List<BaseBlock> UpdateParent(List<BaseBlock> lb, ScopeBlock parent) {
				foreach (var bb in lb)
					bb.Parent = parent;
				return lb;
			}
		}

		BaseBlocksList CreateBaseBlockList(List<Block> allBlocks, List<List<ExceptionHandler>> exSorted) {
			var bbl = new BaseBlocksList();
			foreach (var block in allBlocks) {
				int start = instrToIndex[block.FirstInstr.Instruction];
				int end = instrToIndex[block.LastInstr.Instruction];
				bbl.Add(block, start, end);
			}

			foreach (var exHandlers in exSorted) {
				var tryBlock = new TryBlock();
				var tryStart = instrToIndex[exHandlers[0].TryStart];
				var tryEnd = GetInstrIndex(exHandlers[0].TryEnd) - 1;
				tryBlock.BaseBlocks = bbl.Replace(tryStart, tryEnd, tryBlock);

				foreach (var exHandler in exHandlers) {
					var tryHandlerBlock = new TryHandlerBlock(exHandler);
					tryBlock.AddTryHandler(tryHandlerBlock);

					int filterStart = -1, handlerStart = -1, handlerEnd = -1;

					if (exHandler.FilterStart != null) {
						filterStart = instrToIndex[exHandler.FilterStart];
						var end = instrToIndex[exHandler.HandlerStart] - 1;
						tryHandlerBlock.FilterHandlerBlock.BaseBlocks = bbl.Replace(filterStart, end, tryHandlerBlock.FilterHandlerBlock);
					}

					handlerStart = instrToIndex[exHandler.HandlerStart];
					handlerEnd = GetInstrIndex(exHandler.HandlerEnd) - 1;
					tryHandlerBlock.HandlerBlock.BaseBlocks = bbl.Replace(handlerStart, handlerEnd, tryHandlerBlock.HandlerBlock);

					tryHandlerBlock.BaseBlocks = bbl.Replace(filterStart == -1 ? handlerStart : filterStart, handlerEnd, tryHandlerBlock);
				}
			}

			return bbl;
		}

		int GetInstrIndex(Instruction instruction) {
			if (instruction == null)
				return instructions.Count;
			return instrToIndex[instruction];
		}

		public MethodBlocks Parse() {
			var instrToBlock = new List<Block>(instructions.Count);
			var allBlocks = new List<Block>();
			FindBlocks(instrToBlock, allBlocks);
			FixBranchTargets(instrToBlock, allBlocks);
			FixBlockSources(allBlocks);
			var exSorted = GetSortedExceptionInfos();
			var bbl = CreateBaseBlockList(allBlocks, exSorted);

			foreach (var block in allBlocks)
				block.RemoveLastBr();

			var mb = new MethodBlocks();
			mb.BaseBlocks = bbl.GetBlocks(mb);
			return mb;
		}
	}
}



================================================
File: de4dot.blocks/MemberDefDict.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet;

namespace de4dot.blocks {
	public class TypeDefDict<TValue> {
		Dictionary<ScopeAndTokenKey, TValue> tokenToValue = new Dictionary<ScopeAndTokenKey, TValue>();
		Dictionary<ScopeAndTokenKey, TypeDef> tokenToKey = new Dictionary<ScopeAndTokenKey, TypeDef>();
		Dictionary<IType, TValue> refToValue = new Dictionary<IType, TValue>(TypeEqualityComparer.Instance);
		Dictionary<IType, TypeDef> refToKey = new Dictionary<IType, TypeDef>(TypeEqualityComparer.Instance);

		public int Count => tokenToValue.Count;
		public IEnumerable<TypeDef> GetKeys() => tokenToKey.Values;
		public IEnumerable<TValue> GetValues() => tokenToValue.Values;
		ScopeAndTokenKey GetTokenKey(TypeDef typeDef) => new ScopeAndTokenKey(typeDef);

		public TValue Find(IType typeRef) {
			TValue value;
			if (typeRef is TypeDef typeDef)
				tokenToValue.TryGetValue(GetTokenKey(typeDef), out value);
			else if (typeRef != null)
				refToValue.TryGetValue(typeRef, out value);
			else
				value = default;
			return value;
		}

		public TValue FindAny(IType type) {
			if (type is TypeDef typeDef && tokenToValue.TryGetValue(GetTokenKey(typeDef), out var value))
				return value;

			refToValue.TryGetValue(type, out value);
			return value;
		}

		public void Add(TypeDef typeDef, TValue value) {
			var tokenKey = GetTokenKey(typeDef);
			tokenToValue[tokenKey] = value;
			tokenToKey[tokenKey] = typeDef;

			if (!refToValue.ContainsKey(typeDef) ||
				GetAccessibilityOrder(typeDef) < GetAccessibilityOrder(refToKey[typeDef])) {
				refToKey[typeDef] = typeDef;
				refToValue[typeDef] = value;
			}
		}

		// Order: public, family, assembly, private
		static int[] accessibilityOrder = new int[8] {
			40,		// NotPublic
			0,		// Public
			10,		// NestedPublic
			70,		// NestedPrivate
			20,		// NestedFamily
			50,		// NestedAssembly
			60,		// NestedFamANDAssem
			30,		// NestedFamORAssem
		};
		static int GetAccessibilityOrder(TypeDef typeDef) => accessibilityOrder[(int)typeDef.Attributes & 7];

		public void OnTypesRenamed() {
			var newTypeRefToValue = new Dictionary<IType, TValue>(refToValue.Count);
			foreach (var kvp in refToValue)
				newTypeRefToValue[kvp.Key] = kvp.Value;
			refToValue = newTypeRefToValue;
		}
	}

	public abstract class FieldDefDictBase<TValue> {
		Dictionary<ScopeAndTokenKey, TValue> tokenToValue = new Dictionary<ScopeAndTokenKey, TValue>();
		Dictionary<ScopeAndTokenKey, FieldDef> tokenToKey = new Dictionary<ScopeAndTokenKey, FieldDef>();
		Dictionary<IFieldRefKey, TValue> refToValue = new Dictionary<IFieldRefKey, TValue>();
		Dictionary<IFieldRefKey, FieldDef> refToKey = new Dictionary<IFieldRefKey, FieldDef>();

		public int Count => tokenToValue.Count;
		public IEnumerable<FieldDef> GetKeys() => tokenToKey.Values;
		public IEnumerable<TValue> GetValues() => tokenToValue.Values;
		ScopeAndTokenKey GetTokenKey(FieldDef fieldDef) => new ScopeAndTokenKey(fieldDef);
		internal abstract IFieldRefKey GetRefKey(IField fieldRef);

		public TValue Find(IField fieldRef) {
			TValue value;
			if (fieldRef is FieldDef fieldDef)
				tokenToValue.TryGetValue(GetTokenKey(fieldDef), out value);
			else
				refToValue.TryGetValue(GetRefKey(fieldRef), out value);
			return value;
		}

		public TValue FindAny(IField fieldRef) {
			if (fieldRef is FieldDef fieldDef && tokenToValue.TryGetValue(GetTokenKey(fieldDef), out var value))
				return value;

			refToValue.TryGetValue(GetRefKey(fieldRef), out value);
			return value;
		}

		public void Add(FieldDef fieldDef, TValue value) {
			var tokenKey = GetTokenKey(fieldDef);
			tokenToValue[tokenKey] = value;
			tokenToKey[tokenKey] = fieldDef;

			var refKey = GetRefKey(fieldDef);
			if (!refToValue.ContainsKey(refKey) ||
				GetAccessibilityOrder(fieldDef) < GetAccessibilityOrder(refToKey[refKey])) {
				refToKey[refKey] = fieldDef;
				refToValue[refKey] = value;
			}
		}

		// Order: public, family, assembly, private
		static int[] accessibilityOrder = new int[8] {
			60,		// PrivateScope
			50,		// Private
			40,		// FamANDAssem
			30,		// Assembly
			10,		// Family
			20,		// FamORAssem
			0,		// Public
			70,		// <reserved>
		};
		static int GetAccessibilityOrder(FieldDef fieldDef) => accessibilityOrder[(int)fieldDef.Attributes & 7];

		public void OnTypesRenamed() {
			var newFieldRefToDef = new Dictionary<IFieldRefKey, TValue>(refToValue.Count);
			foreach (var kvp in refToValue)
				newFieldRefToDef[GetRefKey((FieldDef)kvp.Key.FieldRef)] = kvp.Value;
			refToValue = newFieldRefToDef;
		}
	}

	public class FieldDefDict<TValue> : FieldDefDictBase<TValue> {
		internal override IFieldRefKey GetRefKey(IField fieldRef) => new FieldRefKey(fieldRef);
	}

	public class FieldDefAndDeclaringTypeDict<TValue> : FieldDefDictBase<TValue> {
		internal override IFieldRefKey GetRefKey(IField fieldRef) => new FieldRefAndDeclaringTypeKey(fieldRef);
	}

	public abstract class MethodDefDictBase<TValue> {
		Dictionary<ScopeAndTokenKey, TValue> tokenToValue = new Dictionary<ScopeAndTokenKey, TValue>();
		Dictionary<ScopeAndTokenKey, MethodDef> tokenToKey = new Dictionary<ScopeAndTokenKey, MethodDef>();
		Dictionary<IMethodRefKey, TValue> refToValue = new Dictionary<IMethodRefKey, TValue>();
		Dictionary<IMethodRefKey, MethodDef> refToKey = new Dictionary<IMethodRefKey, MethodDef>();

		public int Count => tokenToValue.Count;
		public IEnumerable<MethodDef> GetKeys() => tokenToKey.Values;
		public IEnumerable<TValue> GetValues() => tokenToValue.Values;
		ScopeAndTokenKey GetTokenKey(MethodDef methodDef) => new ScopeAndTokenKey(methodDef);
		internal abstract IMethodRefKey GetRefKey(IMethod methodRef);

		public TValue Find(IMethod methodRef) {
			TValue value;
			if (methodRef is MethodDef methodDef)
				tokenToValue.TryGetValue(GetTokenKey(methodDef), out value);
			else
				refToValue.TryGetValue(GetRefKey(methodRef), out value);
			return value;
		}

		public TValue FindAny(IMethod methodRef) {
			if (methodRef is MethodDef methodDef && tokenToValue.TryGetValue(GetTokenKey(methodDef), out var value))
				return value;

			refToValue.TryGetValue(GetRefKey(methodRef), out value);
			return value;
		}

		public void Add(MethodDef methodDef, TValue value) {
			var tokenKey = GetTokenKey(methodDef);
			tokenToValue[tokenKey] = value;
			tokenToKey[tokenKey] = methodDef;

			var refKey = GetRefKey(methodDef);
			if (!refToValue.ContainsKey(refKey) ||
				GetAccessibilityOrder(methodDef) < GetAccessibilityOrder(refToKey[refKey])) {
				refToKey[refKey] = methodDef;
				refToValue[refKey] = value;
			}
		}

		// Order: public, family, assembly, private
		static int[] accessibilityOrder = new int[8] {
			60,		// PrivateScope
			50,		// Private
			40,		// FamANDAssem
			30,		// Assembly
			10,		// Family
			20,		// FamORAssem
			0,		// Public
			70,		// <reserved>
		};
		static int GetAccessibilityOrder(MethodDef methodDef) => accessibilityOrder[(int)methodDef.Attributes & 7];

		public void OnTypesRenamed() {
			var newFieldRefToDef = new Dictionary<IMethodRefKey, TValue>(refToValue.Count);
			foreach (var kvp in refToValue)
				newFieldRefToDef[GetRefKey((MethodDef)kvp.Key.MethodRef)] = kvp.Value;
			refToValue = newFieldRefToDef;
		}
	}

	public class MethodDefDict<TValue> : MethodDefDictBase<TValue> {
		internal override IMethodRefKey GetRefKey(IMethod methodRef) => new MethodRefKey(methodRef);
	}

	public class MethodDefAndDeclaringTypeDict<TValue> : MethodDefDictBase<TValue> {
		internal override IMethodRefKey GetRefKey(IMethod methodRef) => new MethodRefAndDeclaringTypeKey(methodRef);
	}

	public abstract class EventDefDictBase<TValue> {
		Dictionary<ScopeAndTokenKey, TValue> tokenToValue = new Dictionary<ScopeAndTokenKey, TValue>();
		Dictionary<ScopeAndTokenKey, EventDef> tokenToKey = new Dictionary<ScopeAndTokenKey, EventDef>();
		Dictionary<IEventRefKey, TValue> refToValue = new Dictionary<IEventRefKey, TValue>();

		public int Count => tokenToValue.Count;
		public IEnumerable<EventDef> GetKeys() => tokenToKey.Values;
		public IEnumerable<TValue> GetValues() => tokenToValue.Values;
		ScopeAndTokenKey GetTokenKey(EventDef eventRef) => new ScopeAndTokenKey(eventRef);
		internal abstract IEventRefKey GetRefKey(EventDef eventRef);

		public TValue Find(EventDef eventRef) {
			tokenToValue.TryGetValue(GetTokenKey(eventRef), out var value);
			return value;
		}

		public TValue FindAny(EventDef eventRef) {
			if (tokenToValue.TryGetValue(GetTokenKey(eventRef), out var value))
				return value;

			refToValue.TryGetValue(GetRefKey(eventRef), out value);
			return value;
		}

		public void Add(EventDef eventDef, TValue value) {
			var tokenKey = GetTokenKey(eventDef);
			tokenToValue[tokenKey] = value;
			tokenToKey[tokenKey] = eventDef;

			refToValue[GetRefKey(eventDef)] = value;
		}

		public void OnTypesRenamed() {
			var newFieldRefToDef = new Dictionary<IEventRefKey, TValue>(refToValue.Count);
			foreach (var kvp in refToValue)
				newFieldRefToDef[GetRefKey((EventDef)kvp.Key.EventDef)] = kvp.Value;
			refToValue = newFieldRefToDef;
		}
	}

	public class EventDefDict<TValue> : EventDefDictBase<TValue> {
		internal override IEventRefKey GetRefKey(EventDef eventRef) => new EventRefKey(eventRef);
	}

	public class EventDefAndDeclaringTypeDict<TValue> : EventDefDictBase<TValue> {
		internal override IEventRefKey GetRefKey(EventDef eventRef) => new EventRefAndDeclaringTypeKey(eventRef);
	}

	public abstract class PropertyDefDictBase<TValue> {
		Dictionary<ScopeAndTokenKey, TValue> tokenToValue = new Dictionary<ScopeAndTokenKey, TValue>();
		Dictionary<ScopeAndTokenKey, PropertyDef> tokenToKey = new Dictionary<ScopeAndTokenKey, PropertyDef>();
		Dictionary<IPropertyRefKey, TValue> refToValue = new Dictionary<IPropertyRefKey, TValue>();

		public int Count => tokenToValue.Count;
		public IEnumerable<PropertyDef> GetKeys() => tokenToKey.Values;
		public IEnumerable<TValue> GetValues() => tokenToValue.Values;
		ScopeAndTokenKey GetTokenKey(PropertyDef propertyRef) => new ScopeAndTokenKey(propertyRef);
		internal abstract IPropertyRefKey GetRefKey(PropertyDef propertyRef);

		public TValue Find(PropertyDef propRef) {
			tokenToValue.TryGetValue(GetTokenKey(propRef), out var value);
			return value;
		}

		public TValue FindAny(PropertyDef propRef) {
			if (tokenToValue.TryGetValue(GetTokenKey(propRef), out var value))
				return value;

			refToValue.TryGetValue(GetRefKey(propRef), out value);
			return value;
		}

		public void Add(PropertyDef propDef, TValue value) {
			var tokenKey = GetTokenKey(propDef);
			tokenToValue[tokenKey] = value;
			tokenToKey[tokenKey] = propDef;

			refToValue[GetRefKey(propDef)] = value;
		}

		public void OnTypesRenamed() {
			var newFieldRefToDef = new Dictionary<IPropertyRefKey, TValue>(refToValue.Count);
			foreach (var kvp in refToValue)
				newFieldRefToDef[GetRefKey((PropertyDef)kvp.Key.PropertyDef)] = kvp.Value;
			refToValue = newFieldRefToDef;
		}
	}

	public class PropertyDefDict<TValue> : PropertyDefDictBase<TValue> {
		internal override IPropertyRefKey GetRefKey(PropertyDef propRef) => new PropertyRefKey(propRef);
	}

	public class PropertyDefAndDeclaringTypeDict<TValue> : PropertyDefDictBase<TValue> {
		internal override IPropertyRefKey GetRefKey(PropertyDef propRef) => new PropertyRefAndDeclaringTypeKey(propRef);
	}

	sealed class ScopeAndTokenKey {
		readonly IScope scope;
		readonly uint token;

		public ScopeAndTokenKey(TypeDef type)
			: this(type.Module, type.MDToken.Raw) {
		}

		public ScopeAndTokenKey(FieldDef field)
			: this(field.DeclaringType?.Module, field.MDToken.Raw) {
		}

		public ScopeAndTokenKey(MethodDef method)
			: this(method.DeclaringType?.Module, method.MDToken.Raw) {
		}

		public ScopeAndTokenKey(PropertyDef prop)
			: this(prop.DeclaringType?.Module, prop.MDToken.Raw) {
		}

		public ScopeAndTokenKey(EventDef evt)
			: this(evt.DeclaringType?.Module, evt.MDToken.Raw) {
		}

		public ScopeAndTokenKey(IScope scope, uint token) {
			this.scope = scope;
			this.token = token;
		}

		public override int GetHashCode() => (int)token + GetHashCode(scope);

		public override bool Equals(object obj) {
			var other = obj as ScopeAndTokenKey;
			if (other == null)
				return false;
			return token == other.token &&
				Equals(scope, other.scope);
		}

		public override string ToString() => $"{token:X8} {scope}";

		static bool Equals(IScope a, IScope b) {
			if (a == b)
				return true;
			if (a == null || b == null)
				return false;
			return GetCanonicalizedScopeName(a) == GetCanonicalizedScopeName(b);
		}

		static int GetHashCode(IScope a) {
			if (a == null)
				return 0;
			return GetCanonicalizedScopeName(a).GetHashCode();
		}

		static string GetAssemblyName(IScope a) {
			switch (a.ScopeType) {
			case ScopeType.AssemblyRef:
				return ((AssemblyRef)a).Name.String;
			case ScopeType.ModuleDef:
				var asm = ((ModuleDef)a).Assembly;
				if (asm != null)
					return asm.Name.String;
				break;
			}
			return null;
		}

		static string GetCanonicalizedScopeName(IScope a) {
			if (a == null)
				return string.Empty;
			var asmName = GetAssemblyName(a);
			if (asmName != null) {
				// The version number should be ignored. Older code may reference an old version of
				// the assembly, but if the newer one has been loaded, that one is used.
				return asmName.ToUpperInvariant();
			}
			return a.ScopeName.ToUpperInvariant();
		}
	}

	interface IFieldRefKey {
		IField FieldRef { get; }
	}

	interface IMethodRefKey {
		IMethod MethodRef { get; }
	}

	interface IEventRefKey {
		EventDef EventDef { get; }
	}

	interface IPropertyRefKey {
		PropertyDef PropertyDef { get; }
	}

	sealed class FieldRefKey : IFieldRefKey {
		static SigComparerOptions SIG_COMPARER_FLAGS = SigComparerOptions.PrivateScopeFieldIsComparable;
		readonly IField fieldRef;

		public IField FieldRef => fieldRef;

		public FieldRefKey(IField fieldRef) => this.fieldRef = fieldRef;

		public override int GetHashCode() => new SigComparer(SIG_COMPARER_FLAGS).GetHashCode(fieldRef);

		public override bool Equals(object obj) {
			var other = obj as FieldRefKey;
			if (other == null)
				return false;
			return new SigComparer(SIG_COMPARER_FLAGS).Equals(fieldRef, other.fieldRef);
		}

		public override string ToString() => fieldRef.ToString();
	}

	sealed class MethodRefKey : IMethodRefKey {
		static SigComparerOptions SIG_COMPARER_FLAGS = SigComparerOptions.PrivateScopeMethodIsComparable;
		readonly IMethod methodRef;

		public IMethod MethodRef => methodRef;

		public MethodRefKey(IMethod methodRef) => this.methodRef = methodRef;

		public override int GetHashCode() => new SigComparer(SIG_COMPARER_FLAGS).GetHashCode(methodRef);

		public override bool Equals(object obj) {
			var other = obj as MethodRefKey;
			if (other == null)
				return false;
			return new SigComparer(SIG_COMPARER_FLAGS).Equals(methodRef, other.methodRef);
		}

		public override string ToString() => methodRef.ToString();
	}

	sealed class FieldRefAndDeclaringTypeKey : IFieldRefKey {
		static SigComparerOptions SIG_COMPARER_FLAGS = SigComparerOptions.CompareMethodFieldDeclaringType | SigComparerOptions.PrivateScopeFieldIsComparable;
		readonly IField fieldRef;

		public IField FieldRef => fieldRef;

		public FieldRefAndDeclaringTypeKey(IField fieldRef) => this.fieldRef = fieldRef;

		public override int GetHashCode() => new SigComparer(SIG_COMPARER_FLAGS).GetHashCode(fieldRef);

		public override bool Equals(object obj) {
			var other = obj as FieldRefAndDeclaringTypeKey;
			if (other == null)
				return false;
			return new SigComparer(SIG_COMPARER_FLAGS).Equals(fieldRef, other.fieldRef);
		}

		public override string ToString() => fieldRef.ToString();
	}

	sealed class MethodRefAndDeclaringTypeKey : IMethodRefKey {
		static SigComparerOptions SIG_COMPARER_FLAGS = SigComparerOptions.CompareMethodFieldDeclaringType | SigComparerOptions.PrivateScopeMethodIsComparable;
		readonly IMethod methodRef;

		public IMethod MethodRef => methodRef;

		public MethodRefAndDeclaringTypeKey(IMethod methodRef) => this.methodRef = methodRef;

		public override int GetHashCode() => new SigComparer(SIG_COMPARER_FLAGS).GetHashCode(methodRef);

		public override bool Equals(object obj) {
			var other = obj as MethodRefAndDeclaringTypeKey;
			if (other == null)
				return false;
			return new SigComparer(SIG_COMPARER_FLAGS).Equals(methodRef, other.methodRef);
		}

		public override string ToString() => methodRef.ToString();
	}

	sealed class EventRefKey : IEventRefKey {
		readonly EventDef eventRef;

		public EventDef EventDef => eventRef;

		public EventRefKey(EventDef eventRef) => this.eventRef = eventRef;

		public override int GetHashCode() => new SigComparer().GetHashCode(eventRef);

		public override bool Equals(object obj) {
			var other = obj as EventRefKey;
			if (other == null)
				return false;
			return new SigComparer().Equals(eventRef, other.eventRef);
		}

		public override string ToString() => eventRef.ToString();
	}

	sealed class EventRefAndDeclaringTypeKey : IEventRefKey {
		readonly EventDef eventRef;

		public EventDef EventDef => eventRef;

		public EventRefAndDeclaringTypeKey(EventDef eventRef) => this.eventRef = eventRef;

		public override int GetHashCode() => new SigComparer(SigComparerOptions.CompareEventDeclaringType).GetHashCode(eventRef);

		public override bool Equals(object obj) {
			var other = obj as EventRefAndDeclaringTypeKey;
			if (other == null)
				return false;
			return new SigComparer(SigComparerOptions.CompareEventDeclaringType).Equals(eventRef, other.eventRef);
		}

		public override string ToString() => eventRef.ToString();
	}

	sealed class PropertyRefKey : IPropertyRefKey {
		readonly PropertyDef propRef;

		public PropertyDef PropertyDef => propRef;

		public PropertyRefKey(PropertyDef propRef) => this.propRef = propRef;

		public override int GetHashCode() => new SigComparer().GetHashCode(propRef);

		public override bool Equals(object obj) {
			var other = obj as PropertyRefKey;
			if (other == null)
				return false;
			return new SigComparer().Equals(propRef, other.propRef);
		}

		public override string ToString() => propRef.ToString();
	}

	sealed class PropertyRefAndDeclaringTypeKey : IPropertyRefKey {
		readonly PropertyDef propRef;

		public PropertyDef PropertyDef => propRef;

		public PropertyRefAndDeclaringTypeKey(PropertyDef propRef) => this.propRef = propRef;

		public override int GetHashCode() => new SigComparer(SigComparerOptions.ComparePropertyDeclaringType).GetHashCode(propRef);

		public override bool Equals(object obj) {
			var other = obj as PropertyRefAndDeclaringTypeKey;
			if (other == null)
				return false;
			return new SigComparer(SigComparerOptions.ComparePropertyDeclaringType).Equals(propRef, other.propRef);
		}

		public override string ToString() => propRef.ToString();
	}
}



================================================
File: de4dot.blocks/MethodBlocks.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

namespace de4dot.blocks {
	// Start of a method
	public class MethodBlocks : ScopeBlock {
	}
}



================================================
File: de4dot.blocks/ScopeBlock.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet.Emit;

namespace de4dot.blocks {
	// A normal branch may not transfer out of a protected block (try block), filter handler,
	// an exception handler block, or a method.
	public abstract class ScopeBlock : BaseBlock {
		protected List<BaseBlock> baseBlocks;

		public List<BaseBlock> BaseBlocks {
			get => baseBlocks;
			set => baseBlocks = value;
		}

		public IEnumerable<BaseBlock> GetBaseBlocks() {
			if (baseBlocks != null) {
				foreach (var bb in baseBlocks)
					yield return bb;
			}
		}

		public List<BaseBlock> GetAllBaseBlocks() => GetTheBlocks(new List<BaseBlock>());
		public List<Block> GetAllBlocks() => GetTheBlocks(new List<Block>());

		public List<Block> GetAllBlocks(List<Block> allBlocks) {
			allBlocks.Clear();
			return GetTheBlocks(allBlocks);
		}

		public List<ScopeBlock> GetAllScopeBlocks() => GetTheBlocks(new List<ScopeBlock>());

		public List<T> GetTheBlocks<T>(List<T> list) where T : BaseBlock {
			AddBlocks(list, this);
			return list;
		}

		void AddBlocks<T>(IList<T> list, ScopeBlock scopeBlock) where T : BaseBlock {
			foreach (var bb in scopeBlock.GetBaseBlocks()) {
				if (bb is T t)
					list.Add(t);
				if (bb is ScopeBlock)
					AddBlocks(list, (ScopeBlock)bb);
			}
		}

		List<Block> FindBlocks() => FindBlocks(null);

		List<Block> FindBlocks(Func<Block, bool> blockChecker) {
			var blocks = new List<Block>();
			foreach (var bb in GetBaseBlocks()) {
				if (bb is Block block && (blockChecker == null || blockChecker(block)))
					blocks.Add(block);
			}
			return blocks;
		}

		internal bool GetLdcValue(Instr instr, out int value) {
			if (Code.Ldc_I4_0 <= instr.OpCode.Code && instr.OpCode.Code <= Code.Ldc_I4_8)
				value = instr.OpCode.Code - Code.Ldc_I4_0;
			else if (instr.OpCode.Code == Code.Ldc_I4)
				value = (int)instr.Operand;
			else if (instr.OpCode.Code == Code.Ldc_I4_S)
				value = (sbyte)instr.Operand;
			else if (instr.OpCode.Code == Code.Ldc_I4_M1)
				value = -1;
			else {
				value = 0;
				return false;
			}
			return true;
		}

		// Remove the block if it's a dead block. If it has refs to other dead blocks, those
		// are also removed.
		public void RemoveDeadBlock(Block block) => RemoveDeadBlocks(new List<Block> { block });

		// Remove all dead blocks we can find
		public void RemoveDeadBlocks() => RemoveDeadBlocks(FindBlocks());

		// Remove the blocks if they're dead blocks. If they have refs to other dead blocks,
		// those are also removed.
		public void RemoveDeadBlocks(List<Block> blocks) {
			while (blocks.Count != 0) {
				var block = blocks[blocks.Count - 1];
				blocks.RemoveAt(blocks.Count - 1);
				if (block.Sources.Count != 0)
					continue;	// Not dead
				if (block == baseBlocks[0])
					continue;	// It's the start of this block fence so must be present
				if (!IsOurBaseBlock(block))
					continue;	// Some other ScopeBlock owns it, eg. first instr of an exception handler

				// It's a dead block we can delete!

				if (block.FallThrough != null)
					blocks.Add(block.FallThrough);
				if (block.Targets != null)
					blocks.AddRange(block.Targets);
				block.RemoveDeadBlock();
				if (!baseBlocks.Remove(block))
					throw new ApplicationException("Could not remove dead block from baseBlocks");
			}
		}

		public bool IsOurBaseBlock(BaseBlock bb) => bb != null && bb.Parent == this;

		// For each block, if it has only one target, and the target has only one source, then
		// merge them into one block.
		public int MergeBlocks() {
			int mergedBlocks = 0;
			var blocks = FindBlocks();
			for (int i = 0; i < blocks.Count; i++) {
				var block = blocks[i];
				var target = block.GetOnlyTarget();
				if (!IsOurBaseBlock(target))
					continue;	// Only merge blocks we own!
				if (!block.CanMerge(target))
					continue;	// Can't merge them!
				if (target == baseBlocks[0])
					continue;	// The first one has an implicit source (eg. start of method or exception handler)

				var targetIndex = blocks.IndexOf(target);
				if (targetIndex < 0)
					throw new ApplicationException("Could not remove target block from blocks");
				blocks.RemoveAt(targetIndex);
				block.Merge(target);
				if (!baseBlocks.Remove(target))
					throw new ApplicationException("Could not remove merged block from baseBlocks");
				if (targetIndex < i)
					i--;
				i--;				// Redo since there may be more blocks we can merge
				mergedBlocks++;
			}

			return mergedBlocks;
		}

		// If bb is in baseBlocks (a direct child), return bb. If bb is a BaseBlock in a
		// ScopeBlock that is a direct child, then return that ScopeBlock. Else return null.
		public BaseBlock ToChild(BaseBlock bb) {
			if (IsOurBaseBlock(bb))
				return bb;

			for (var sb = bb.Parent; sb != null; sb = sb.Parent) {
				if (IsOurBaseBlock(sb))
					return sb;
			}

			return null;
		}

		internal void RepartitionBlocks() {
			var newBaseBlocks = new BlocksSorter(this).Sort();

			const bool insane = true;
			if (insane) {
				if (newBaseBlocks.Count != baseBlocks.Count)
					throw new ApplicationException("BlocksSorter included too many/few BaseBlocks");
				if (baseBlocks.Count > 0 && baseBlocks[0] != newBaseBlocks[0])
					throw new ApplicationException("BlocksSorter removed the start block");
				foreach (var bb in baseBlocks) {
					if (!newBaseBlocks.Contains(bb))
						throw new ApplicationException("BlocksSorter forgot a child");
				}
			}

			baseBlocks = newBaseBlocks;
		}

		// Removes the TryBlock and all its TryHandlerBlocks. The code inside the try block
		// is not removed.
		public void RemoveTryBlock(TryBlock tryBlock) {
			int tryBlockIndex = baseBlocks.IndexOf(tryBlock);
			if (tryBlockIndex < 0)
				throw new ApplicationException("Can't remove the TryBlock since it's not this ScopeBlock's TryBlock");

			foreach (var bb in tryBlock.BaseBlocks)
				bb.Parent = this;
			baseBlocks.RemoveAt(tryBlockIndex);
			baseBlocks.InsertRange(tryBlockIndex, tryBlock.BaseBlocks);
			tryBlock.BaseBlocks.Clear();

			// Get removed blocks and make sure they're not referenced by remaining code
			var removedBlocks = new List<Block>();
			foreach (var handler in tryBlock.TryHandlerBlocks)
				handler.GetTheBlocks(removedBlocks);
			if (!VerifyNoExternalRefs(removedBlocks))
				throw new ApplicationException("Removed blocks are referenced by remaining code");

			RemoveAllDeadBlocks(Utils.Convert<TryHandlerBlock, BaseBlock>(tryBlock.TryHandlerBlocks));
		}

		// Returns true if no external blocks references the blocks
		static bool VerifyNoExternalRefs(IList<Block> removedBlocks) {
			var removedDict = new Dictionary<Block, bool>();
			foreach (var removedBlock in removedBlocks)
				removedDict[removedBlock] = true;
			foreach (var removedBlock in removedBlocks) {
				foreach (var source in removedBlock.Sources) {
					if (!removedDict.TryGetValue(source, out bool val))
						return false;   // external code references a removed block
				}
			}
			return true;
		}

		// Remove all blocks in deadBlocks. They're guaranteed to be dead.
		void RemoveAllDeadBlocks(IEnumerable<BaseBlock> deadBlocks) => RemoveAllDeadBlocks(deadBlocks, null);

		// Remove all blocks in deadBlocks. They're guaranteed to be dead. deadBlocksDict is
		// a dictionary of all dead blocks (even those not in this ScopeBlock).
		internal void RemoveAllDeadBlocks(IEnumerable<BaseBlock> deadBlocks, Dictionary<BaseBlock, bool> deadBlocksDict) {

			// Verify that all the blocks really are dead. If all their source blocks are
			// dead, then they are dead.

			var allDeadBlocks = new List<Block>();
			foreach (var bb in deadBlocks) {
				if (bb is Block)
					allDeadBlocks.Add(bb as Block);
				else if (bb is ScopeBlock sb)
					allDeadBlocks.AddRange(sb.GetAllBlocks());
				else
					throw new ApplicationException($"Unknown BaseBlock type {bb.GetType()}");
			}

			if (deadBlocksDict != null) {
				foreach (var block in allDeadBlocks) {
					if (block.Sources == null)
						continue;
					foreach (var source in block.Sources) {
						if (!deadBlocksDict.ContainsKey(source))
							throw new ApplicationException("Trying to remove a block that is not dead!");
					}
				}
			}

			foreach (var block in allDeadBlocks)
				block.RemoveGuaranteedDeadBlock();
			foreach (var bb in deadBlocks) {
				if (!baseBlocks.Remove(bb))
					throw new ApplicationException("Could not remove dead base block from baseBlocks");
			}
		}

		public void RemoveGuaranteedDeadBlock(Block block) {
			if (!baseBlocks.Remove(block))
				throw new ApplicationException("Could not remove dead block");
			block.RemoveGuaranteedDeadBlock();
		}

		public void Add(Block block) {
			if (block.Parent != null)
				throw new ApplicationException("Block already has a parent");
			baseBlocks.Add(block);
			block.Parent = this;
		}
	}
}



================================================
File: de4dot.blocks/StackTracePatcher.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Reflection;
using System.Diagnostics;

namespace de4dot.blocks {
	public class StackTracePatcher {
		static readonly FieldInfo methodField;
		static readonly FieldInfo framesField;
		static readonly FieldInfo methodsToSkipField;

		static StackTracePatcher() {
			methodField = GetStackFrameMethodField();
			framesField = GetStackTraceStackFramesField();
			methodsToSkipField = GetMethodsToSkipField();
		}

		static FieldInfo GetStackFrameMethodField() {
			var flags = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance;
			return GetFieldThrow(typeof(StackFrame), typeof(MethodBase), flags, "Could not find StackFrame's method (MethodBase) field");
		}

		static FieldInfo GetStackTraceStackFramesField() {
			var flags = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance;
			return GetFieldThrow(typeof(StackTrace), typeof(StackFrame[]), flags, "Could not find StackTrace's frames (StackFrame[]) field");
		}

		static FieldInfo GetMethodsToSkipField() {
			var flags = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance;
			return GetFieldThrow(typeof(StackTrace), "m_iMethodsToSkip", flags, "Could not find StackTrace's iMethodsToSkip field");
		}

		static FieldInfo GetFieldThrow(Type type, Type fieldType, BindingFlags flags, string msg) {
			var info = GetField(type, fieldType, flags);
			if (info != null)
				return info;
			throw new ApplicationException(msg);
		}

		static FieldInfo GetField(Type type, Type fieldType, BindingFlags flags) {
			foreach (var field in type.GetFields(flags)) {
				if (field.FieldType == fieldType)
					return field;
			}
			return null;
		}

		static FieldInfo GetFieldThrow(Type type, string fieldName, BindingFlags flags, string msg) {
			var info = GetField(type, fieldName, flags);
			if (info != null)
				return info;
			throw new ApplicationException(msg);
		}

		static FieldInfo GetField(Type type, string fieldName, BindingFlags flags) {
			foreach (var field in type.GetFields(flags)) {
				if (field.Name == fieldName)
					return field;
			}
			return null;
		}

		public static StackTrace WriteStackFrame(StackTrace stackTrace, int frameNo, MethodBase newMethod) {
			var frames = (StackFrame[])framesField.GetValue(stackTrace);
			int numFramesToSkip = (int)methodsToSkipField.GetValue(stackTrace);
			WriteMethodBase(frames[numFramesToSkip + frameNo], newMethod);
			return stackTrace;
		}

		static void WriteMethodBase(StackFrame frame, MethodBase method) {
			methodField.SetValue(frame, method);
			if (frame.GetMethod() != method)
				throw new ApplicationException($"Could not set new method: {method}");
		}
	}
}



================================================
File: de4dot.blocks/TryBlock.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;

namespace de4dot.blocks {
	// This is the block inside try { }.
	public class TryBlock : ScopeBlock {
		// The first one is the most nested one and the last one is the
		// outer most handler. I.e., the exceptions are written to the
		// image in the same order they're saved here.
		List<TryHandlerBlock> handlerBlocks = new List<TryHandlerBlock>();

		public List<TryHandlerBlock> TryHandlerBlocks => handlerBlocks;
		public void AddTryHandler(TryHandlerBlock tryHandlerBlock) => handlerBlocks.Add(tryHandlerBlock);
	}
}



================================================
File: de4dot.blocks/TryHandlerBlock.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace de4dot.blocks {
	// Contains the filter handler block and the catch handler block.
	public class TryHandlerBlock : ScopeBlock {
		FilterHandlerBlock filterHandlerBlock = new FilterHandlerBlock();
		HandlerBlock handlerBlock = new HandlerBlock();

		// State for an ExceptionHandler instance
		ITypeDefOrRef catchType;
		ExceptionHandlerType handlerType;

		public ITypeDefOrRef CatchType => catchType;
		public ExceptionHandlerType HandlerType => handlerType;
		public FilterHandlerBlock FilterHandlerBlock => filterHandlerBlock;
		public HandlerBlock HandlerBlock => handlerBlock;

		public TryHandlerBlock(ExceptionHandler handler) {
			catchType = handler.CatchType;
			handlerType = handler.HandlerType;
		}
	}
}



================================================
File: de4dot.blocks/Utils.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;

namespace de4dot.blocks {
	public class Tuple<T1, T2> {
		public T1 Item1 { get; set; }
		public T2 Item2 { get; set; }
		public override bool Equals(object obj) {
			var other = obj as Tuple<T1, T2>;
			if (other == null)
				return false;
			return Item1.Equals(other.Item1) && Item2.Equals(other.Item2);
		}
		public override int GetHashCode() => Item1.GetHashCode() + Item2.GetHashCode();
		public override string ToString() => "<" + Item1.ToString() + "," + Item2.ToString() + ">";
	}

	static class Utils {
		public static IDictionary<T, int> CreateObjectToIndexDictionary<T>(IList<T> objs) {
			var dict = new Dictionary<T, int>();
			for (int i = 0; i < objs.Count; i++)
				dict[objs[i]] = i;
			return dict;
		}

		public static List<TOut> Convert<TIn, TOut>(IEnumerable<TIn> list) where TIn : TOut {
			var olist = new List<TOut>();
			foreach (var l in list)
				olist.Add(l);
			return olist;
		}

		public static IEnumerable<T> Unique<T>(IEnumerable<T> values) {
			// HashSet is only available in .NET 3.5 and later.
			var dict = new Dictionary<T, bool>();
			foreach (var val in values)
				dict[val] = true;
			return dict.Keys;
		}
	}
}



================================================
File: de4dot.blocks/de4dot.blocks.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">

  <Import Project="..\De4DotCommon.props" />

  <ItemGroup>
    <PackageReference Include="dnlib" Version="$(DnlibVersion)" />
  </ItemGroup>

</Project>



================================================
File: de4dot.blocks/cflow/AccessChecker.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet;

namespace de4dot.blocks.cflow {
	/// <summary>
	/// Checks whether a type has access to some other target type, method or field
	/// according to the target's visibility.
	/// </summary>
	public struct AccessChecker {
		TypeDef userType;
		List<TypeDef> userTypeEnclosingTypes;
		bool enclosingTypesInitialized;
		Dictionary<IType, bool> baseTypes;
		bool baseTypesInitialized;

		[Flags]
		enum CheckTypeAccess {
			/// <summary>
			/// Can't access the type
			/// </summary>
			None = 0,

			/// <summary>
			/// Normal access to the type and its members. Type + member must be public, internal
			/// or protected (for sub classes) to access the member.
			/// </summary>
			Normal = 1,

			/// <summary>
			/// Full access to the type, even if the type is private. If clear, the type
			/// must be public, internal or protected (for sub classes).
			/// </summary>
			FullTypeAccess = 2,

			/// <summary>
			/// Full access to the type's members (types, fields, methods), even if the
			/// members are private. If clear, the members must be public, internal
			/// or protected (for sub classes)
			/// </summary>
			FullMemberAccess = 4,

			/// <summary>
			/// Full access to the type and its members
			/// </summary>
			Full = Normal | FullTypeAccess | FullMemberAccess,
		}

		/// <summary>
		/// Gets/sets the user type which is accessing the target type, field or method
		/// </summary>
		public TypeDef UserType {
			get => userType;
			set {
				if (userType == value)
					return;
				userType = value;
				enclosingTypesInitialized = false;
				baseTypesInitialized = false;
				if (userTypeEnclosingTypes != null)
					userTypeEnclosingTypes.Clear();
				if (baseTypes != null)
					baseTypes.Clear();
			}
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="userType">The type accessing the target type, field or method</param>
		public AccessChecker(TypeDef userType) {
			this.userType = userType;
			userTypeEnclosingTypes = null;
			baseTypes = null;
			enclosingTypesInitialized = false;
			baseTypesInitialized = false;
		}

		/// <summary>
		/// Checks whether it can access a method or a field
		/// </summary>
		/// <param name="op">Operand</param>
		/// <returns><c>true</c> if it has access to it, <c>false</c> if not, and <c>null</c>
		/// if we can't determine it (eg. we couldn't resolve a type or input was <c>null</c>)</returns>
		public bool? CanAccess(object op) {
			if (op is MethodDef md)
				return CanAccess(md);

			if (op is MemberRef mr)
				return CanAccess(mr);

			if (op is FieldDef fd)
				return CanAccess(fd);

			if (op is MethodSpec ms)
				return CanAccess(ms);

			if (op is TypeRef tr)
				return CanAccess(tr.Resolve());

			if (op is TypeDef td)
				return CanAccess(td);

			if (op is TypeSpec ts)
				return CanAccess(ts);

			return null;
		}

		/// <summary>
		/// Checks whether it can access a <see cref="TypeRef"/>
		/// </summary>
		/// <param name="tr">The type</param>
		/// <returns><c>true</c> if it has access to it, <c>false</c> if not, and <c>null</c>
		/// if we can't determine it (eg. we couldn't resolve a type or input was <c>null</c>)</returns>
		public bool? CanAccess(TypeRef tr) {
			if (tr == null)
				return null;
			return CanAccess(tr.Resolve());
		}

		/// <summary>
		/// Checks whether it can access a <see cref="TypeDef"/>
		/// </summary>
		/// <param name="td">The type</param>
		/// <returns><c>true</c> if it has access to it, <c>false</c> if not, and <c>null</c>
		/// if we can't determine it (eg. we couldn't resolve a type or input was <c>null</c>)</returns>
		public bool? CanAccess(TypeDef td) {
			var access = GetTypeAccess(td, null);
			if (access == null)
				return null;
			return (access.Value & CheckTypeAccess.Normal) != 0;
		}

		/// <summary>
		/// Returns the access we have to <paramref name="td"/>. If <paramref name="td"/> is
		/// enclosing this type, we have private access to it and all its members. If its
		/// declaring type encloses us, we have private access to it, but only normal access
		/// to its members. Else, we only have normal access to it and its members. If we inherit
		/// it, we have protected access to it and its members.
		/// </summary>
		/// <param name="td">The type</param>
		/// <param name="git">Generic instance of <paramref name="td"/> or <c>null</c> if none</param>
		CheckTypeAccess? GetTypeAccess(TypeDef td, GenericInstSig git) {
			if (td == null)
				return null;
			if (userType == td)
				return CheckTypeAccess.Full;

			// If this is our nested type, we have private access to it itself, but normal
			// access to its members.
			if (td.DeclaringType == userType)
				return CheckTypeAccess.Normal | CheckTypeAccess.FullTypeAccess;

			// If we're not a nested type, td can't be our enclosing type
			if (userType.DeclaringType == null)
				return GetTypeAccess2(td, git);

			// Can't be an enclosing type if they're not in the same module
			if (userType.Module != td.Module)
				return GetTypeAccess2(td, git);

			var tdEncTypes = GetEnclosingTypes(td, true);
			var ourEncTypes = InitializeOurEnclosingTypes();
			int maxChecks = Math.Min(tdEncTypes.Count, ourEncTypes.Count);
			int commonIndex;
			for (commonIndex = 0; commonIndex < maxChecks; commonIndex++) {
				if (tdEncTypes[commonIndex] != ourEncTypes[commonIndex])
					break;
			}

			// If td encloses us, then we have access to td and all its members even if
			// they're private.
			if (commonIndex == tdEncTypes.Count)
				return CheckTypeAccess.Full;

			// If there are no common enclosing types, only check the visibility.
			if (commonIndex == 0)
				return GetTypeAccess2(td, git);

			// If td's declaring type encloses this, then we have full access to td even if
			// it's private, but only normal access to its members.
			if (commonIndex + 1 == tdEncTypes.Count)
				return CheckTypeAccess.Normal | CheckTypeAccess.FullTypeAccess;

			// Normal visibility checks starting from type after common enclosing type.
			// Note that we have full access to it so we don't need to check its access,
			// so start from the next one.
			for (int i = commonIndex + 1; i < tdEncTypes.Count; i++) {
				if (!IsVisible(tdEncTypes[i], null))
					return CheckTypeAccess.None;
			}
			return CheckTypeAccess.Normal;
		}

		CheckTypeAccess GetTypeAccess2(TypeDef td, GenericInstSig git) {
			while (td != null) {
				var declType = td.DeclaringType;
				if (userType != declType && !IsVisible(td, git))
					return CheckTypeAccess.None;
				td = declType;
				git = null;
			}
			return CheckTypeAccess.Normal;
		}

		/// <summary>
		/// Checks whether <paramref name="td"/> is visible to us without checking whether they
		/// have any common enclosing types.
		/// </summary>
		/// <param name="td">Type</param>
		/// <param name="git">Generic instance of <paramref name="td"/> or <c>null</c> if none</param>
		bool IsVisible(TypeDef td, GenericInstSig git) {
			if (td == null)
				return false;
			if (td == userType)
				return true;

			switch (td.Visibility) {
			case TypeAttributes.NotPublic:
				return IsSameAssemblyOrFriendAssembly(td.Module);

			case TypeAttributes.Public:
				return true;

			case TypeAttributes.NestedPublic:
				return true;

			case TypeAttributes.NestedPrivate:
				return false;

			case TypeAttributes.NestedFamily:
				return CheckFamily(td, git);

			case TypeAttributes.NestedAssembly:
				return IsSameAssemblyOrFriendAssembly(td.Module);

			case TypeAttributes.NestedFamANDAssem:
				return IsSameAssemblyOrFriendAssembly(td.Module) &&
					CheckFamily(td, git);

			case TypeAttributes.NestedFamORAssem:
				return IsSameAssemblyOrFriendAssembly(td.Module) ||
					CheckFamily(td, git);

			default:
				return false;
			}
		}

		bool IsSameAssemblyOrFriendAssembly(ModuleDef module) {
			if (module == null)
				return false;
			var userModule = userType.Module;
			if (userModule == null)
				return false;
			if (userModule == module)
				return true;
			var userAsm = userModule.Assembly;
			var modAsm = module.Assembly;
			if (IsSameAssembly(userAsm, modAsm))
				return true;
			if (userAsm != null && userAsm.IsFriendAssemblyOf(modAsm))
				return true;

			return false;
		}

		static bool IsSameAssembly(IAssembly asm1, IAssembly asm2) {
			if (asm1 == null || asm2 == null)
				return false;
			if (asm1 == asm2)
				return true;
			return new AssemblyNameComparer(AssemblyNameComparerFlags.All).Equals(asm1, asm2);
		}

		/// <summary>
		/// Checks whether <see cref="userType"/> has access to <paramref name="td"/>.
		/// <paramref name="td"/> is Family, FamANDAssem, or FamORAssem.
		/// </summary>
		/// <param name="td">Type</param>
		/// <param name="git">Generic instance of <paramref name="td"/> or <c>null</c> if none</param>
		bool CheckFamily(TypeDef td, GenericInstSig git) {
			if (td == null)
				return false;
			InitializeBaseTypes();

			if (baseTypes.ContainsKey(git ?? (IType)td))
				return true;

			// td is Family, FamANDAssem, or FamORAssem. If we derive from its enclosing type,
			// we have access to it.
			var td2 = td.DeclaringType;
			if (td2 != null && baseTypes.ContainsKey(td2))
				return true;

			// If one of our enclosing types derive from it, we also have access to it
			var userDeclType = userType.DeclaringType;
			if (userDeclType != null)
				return new AccessChecker(userDeclType).CheckFamily(td, git);

			return false;
		}

		void InitializeBaseTypes() {
			if (baseTypesInitialized)
				return;
			if (baseTypes == null)
				baseTypes = new Dictionary<IType, bool>(TypeEqualityComparer.Instance);
			baseTypesInitialized = true;

			ITypeDefOrRef baseType = userType;
			while (baseType != null) {
				baseTypes[baseType] = true;
				baseType = baseType.GetBaseType();
			}
		}

		List<TypeDef> InitializeOurEnclosingTypes() {
			if (!enclosingTypesInitialized) {
				userTypeEnclosingTypes = GetEnclosingTypes(userType, true);
				enclosingTypesInitialized = true;
			}
			return userTypeEnclosingTypes;
		}

		/// <summary>
		/// Returns a list of all enclosing types, in order of non-enclosed to most enclosed type
		/// </summary>
		/// <param name="td">Type</param>
		/// <param name="includeInput"><c>true</c> if <paramref name="td"/> should be included</param>
		/// <returns>A list of all enclosing types</returns>
		static List<TypeDef> GetEnclosingTypes(TypeDef td, bool includeInput) {
			var list = new List<TypeDef>();
			if (includeInput && td != null)
				list.Add(td);
			while (td != null) {
				var dt = td.DeclaringType;
				if (dt == null)
					break;
				if (list.Contains(dt))
					break;
				list.Add(dt);
				td = dt;
			}
			list.Reverse();
			return list;
		}

		/// <summary>
		/// Checks whether it can access a <see cref="FieldDef"/>
		/// </summary>
		/// <param name="fd">The field</param>
		/// <returns><c>true</c> if it has access to it, <c>false</c> if not, and <c>null</c>
		/// if we can't determine it (eg. we couldn't resolve a type or input was <c>null</c>)</returns>
		public bool? CanAccess(FieldDef fd) => CanAccess(fd, null);

		bool? CanAccess(FieldDef fd, GenericInstSig git) {
			if (fd == null)
				return null;
			var access = GetTypeAccess(fd.DeclaringType, git);
			if (access == null)
				return null;
			var acc = access.Value;
			if ((acc & CheckTypeAccess.Normal) == 0)
				return false;
			if ((acc & CheckTypeAccess.FullMemberAccess) != 0)
				return true;

			return IsVisible(fd, git);
		}

		bool IsVisible(FieldDef fd, GenericInstSig git) {
			if (fd == null)
				return false;
			var fdDeclaringType = fd.DeclaringType;
			if (fdDeclaringType == null)
				return false;
			if (userType == fdDeclaringType)
				return true;

			switch (fd.Access) {
			case FieldAttributes.PrivateScope:
				// Private scope aka compiler controlled fields/methods can only be accessed
				// by a Field/Method token. This means they must be in the same module.
				return userType.Module == fdDeclaringType.Module;

			case FieldAttributes.Private:
				return false;

			case FieldAttributes.FamANDAssem:
				return IsSameAssemblyOrFriendAssembly(fdDeclaringType.Module) &&
					CheckFamily(fdDeclaringType, git);

			case FieldAttributes.Assembly:
				return IsSameAssemblyOrFriendAssembly(fdDeclaringType.Module);

			case FieldAttributes.Family:
				return CheckFamily(fdDeclaringType, git);

			case FieldAttributes.FamORAssem:
				return IsSameAssemblyOrFriendAssembly(fdDeclaringType.Module) ||
					CheckFamily(fdDeclaringType, git);

			case FieldAttributes.Public:
				return true;

			default:
				return false;
			}
		}

		/// <summary>
		/// Checks whether it can access a <see cref="MethodDef"/>
		/// </summary>
		/// <param name="md">The method</param>
		/// <returns><c>true</c> if it has access to it, <c>false</c> if not, and <c>null</c>
		/// if we can't determine it (eg. we couldn't resolve a type or input was <c>null</c>)</returns>
		public bool? CanAccess(MethodDef md) => CanAccess(md, (GenericInstSig)null);

		bool? CanAccess(MethodDef md, GenericInstSig git) {
			if (md == null)
				return null;
			var access = GetTypeAccess(md.DeclaringType, git);
			if (access == null)
				return null;
			var acc = access.Value;
			if ((acc & CheckTypeAccess.Normal) == 0)
				return false;
			if ((acc & CheckTypeAccess.FullMemberAccess) != 0)
				return true;

			return IsVisible(md, git);
		}

		bool IsVisible(MethodDef md, GenericInstSig git) {
			if (md == null)
				return false;
			var mdDeclaringType = md.DeclaringType;
			if (mdDeclaringType == null)
				return false;
			if (userType == mdDeclaringType)
				return true;

			switch (md.Access) {
			case MethodAttributes.PrivateScope:
				// Private scope aka compiler controlled fields/methods can only be accessed
				// by a Field/Method token. This means they must be in the same module.
				return userType.Module == mdDeclaringType.Module;

			case MethodAttributes.Private:
				return false;

			case MethodAttributes.FamANDAssem:
				return IsSameAssemblyOrFriendAssembly(mdDeclaringType.Module) &&
					CheckFamily(mdDeclaringType, git);

			case MethodAttributes.Assembly:
				return IsSameAssemblyOrFriendAssembly(mdDeclaringType.Module);

			case MethodAttributes.Family:
				return CheckFamily(mdDeclaringType, git);

			case MethodAttributes.FamORAssem:
				return IsSameAssemblyOrFriendAssembly(mdDeclaringType.Module) ||
					CheckFamily(mdDeclaringType, git);

			case MethodAttributes.Public:
				return true;

			default:
				return false;
			}
		}

		/// <summary>
		/// Checks whether it can access a <see cref="MemberRef"/>
		/// </summary>
		/// <param name="mr">The member reference</param>
		/// <returns><c>true</c> if it has access to it, <c>false</c> if not, and <c>null</c>
		/// if we can't determine it (eg. we couldn't resolve a type or input was <c>null</c>)</returns>
		public bool? CanAccess(MemberRef mr) {
			if (mr == null)
				return null;

			var parent = mr.Class;

			if (parent is TypeDef td)
				return CanAccess(td, mr);

			if (parent is TypeRef tr)
				return CanAccess(tr.Resolve(), mr);

			if (parent is TypeSpec ts)
				return CanAccess(ts.ResolveTypeDef(), ts.TryGetGenericInstSig(), mr);

			if (parent is MethodDef md)
				return CanAccess(md, mr);

			if (parent is ModuleRef mod)
				return CanAccess(mod, mr);

			return null;
		}

		bool? CanAccess(TypeDef td, MemberRef mr) => CanAccess(td, null, mr);

		bool? CanAccess(TypeDef td, GenericInstSig git, MemberRef mr) {
			if (mr == null || td == null)
				return null;

			if (mr.MethodSig != null) {
				var md = td.FindMethodCheckBaseType(mr.Name, mr.MethodSig);
				if (md == null) {
					// Assume that it's an array type if it's one of these methods
					if (mr.Name == "Get" || mr.Name == "Set" || mr.Name == "Address" || mr.Name == ".ctor")
						return true;
					return null;
				}
				return CanAccess(md, git);
			}

			if (mr.FieldSig != null)
				return CanAccess(td.FindFieldCheckBaseType(mr.Name, mr.FieldSig), git);

			return null;
		}

		bool? CanAccess(MethodDef md, MemberRef mr) {
			if (mr == null || md == null)
				return null;
			return CanAccess(md);
		}

		bool? CanAccess(ModuleRef mod, MemberRef mr) {
			if (mr == null || mod == null || mod.Module == null)
				return null;

			var userModule = userType.Module;
			if (userModule == null)
				return null;
			var userAsm = userModule.Assembly;
			if (!IsSameAssembly(userAsm, mod.Module.Assembly))
				return false;
			if (userAsm == null)
				return false;
			var otherMod = userAsm.FindModule(mod.Name);
			if (otherMod == null)
				return false;
			return CanAccess(otherMod.GlobalType, mr);
		}

		/// <summary>
		/// Checks whether it can access a <see cref="TypeSpec"/>
		/// </summary>
		/// <param name="ts">The type spec</param>
		/// <returns><c>true</c> if it has access to it, <c>false</c> if not, and <c>null</c>
		/// if we can't determine it (eg. we couldn't resolve a type or input was <c>null</c>)</returns>
		public bool? CanAccess(TypeSpec ts) => CanAccess(ts.ResolveTypeDef());

		/// <summary>
		/// Checks whether it can access a <see cref="MethodSpec"/>
		/// </summary>
		/// <param name="ms">The method spec</param>
		/// <returns><c>true</c> if it has access to it, <c>false</c> if not, and <c>null</c>
		/// if we can't determine it (eg. we couldn't resolve a type or input was <c>null</c>)</returns>
		public bool? CanAccess(MethodSpec ms) {
			if (ms == null)
				return null;

			var mdr = ms.Method;

			if (mdr is MethodDef md)
				return CanAccess(md);

			if (mdr is MemberRef mr)
				return CanAccess(mr);

			return null;
		}

		/// <inheritdoc/>
		public override string ToString() => userType.ToString();
	}
}



================================================
File: de4dot.blocks/cflow/BlockCflowDeobfuscator.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using dnlib.DotNet.Emit;

namespace de4dot.blocks.cflow {
	class BlockCflowDeobfuscator : BlockDeobfuscator, IBranchHandler {
		Block block;
		InstructionEmulator instructionEmulator;
		BranchEmulator branchEmulator;

		public BlockCflowDeobfuscator() {
			instructionEmulator = new InstructionEmulator();
			branchEmulator = new BranchEmulator(instructionEmulator, this);
		}

		protected override bool Deobfuscate(Block block) {
			this.block = block;
			if (!block.LastInstr.IsConditionalBranch() && block.LastInstr.OpCode.Code != Code.Switch)
				return false;
			instructionEmulator.Initialize(blocks, allBlocks[0] == block);

			var instructions = block.Instructions;
			if (instructions.Count == 0)
				return false;
			try {
				for (int i = 0; i < instructions.Count - 1; i++) {
					var instr = instructions[i].Instruction;
					instructionEmulator.Emulate(instr);
				}
			}
			catch (NullReferenceException) {
				// Here if eg. invalid metadata token in a call instruction (operand is null)
				return false;
			}

			return branchEmulator.Emulate(block.LastInstr.Instruction);
		}

		void PopPushedArgs(int stackArgs) {
			// Pop the arguments to the bcc instruction. The dead code remover will get rid of the
			// pop and any pushed arguments. Insert the pops just before the bcc instr.
			for (int i = 0; i < stackArgs; i++)
				block.Insert(block.Instructions.Count - 1, OpCodes.Pop.ToInstruction());
		}

		void IBranchHandler.HandleNormal(int stackArgs, bool isTaken) {
			PopPushedArgs(stackArgs);
			block.ReplaceBccWithBranch(isTaken);
		}

		bool IBranchHandler.HandleSwitch(Int32Value switchIndex) {
			var target = CflowUtils.GetSwitchTarget(block.Targets, block.FallThrough, switchIndex);
			if (target == null)
				return false;

			PopPushedArgs(1);
			block.ReplaceSwitchWithBranch(target);
			return true;
		}
	}
}



================================================
File: de4dot.blocks/cflow/BlockDeobfuscator.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;

namespace de4dot.blocks.cflow {
	public abstract class BlockDeobfuscator : IBlocksDeobfuscator {
		protected List<Block> allBlocks;
		protected Blocks blocks;

		public bool ExecuteIfNotModified { get; set; }

		public virtual void DeobfuscateBegin(Blocks blocks) => this.blocks = blocks;

		public bool Deobfuscate(List<Block> allBlocks) {
			Initialize(allBlocks);

			bool modified = false;
			foreach (var block in allBlocks) {
				try {
					modified |= Deobfuscate(block);
				}
				catch (NullReferenceException) {
					// Here if eg. invalid metadata token in a call instruction (operand is null)
				}
			}
			return modified;
		}

		protected virtual void Initialize(List<Block> allBlocks) => this.allBlocks = allBlocks;
		protected abstract bool Deobfuscate(Block block);
	}
}



================================================
File: de4dot.blocks/cflow/BlocksCflowDeobfuscator.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet.Emit;

namespace de4dot.blocks.cflow {
	public class BlocksCflowDeobfuscator {
		Blocks blocks;
		List<Block> allBlocks = new List<Block>();
		List<IBlocksDeobfuscator> userBlocksDeobfuscators = new List<IBlocksDeobfuscator>();
		List<IBlocksDeobfuscator> ourBlocksDeobfuscators = new List<IBlocksDeobfuscator>();

		public BlocksCflowDeobfuscator()
			: this(false) {
		}

		public BlocksCflowDeobfuscator(bool disableNewCFCode) => Initialize(disableNewCFCode);

		public BlocksCflowDeobfuscator(IEnumerable<IBlocksDeobfuscator> blocksDeobfuscator)
			: this(blocksDeobfuscator, false) {
		}

		public BlocksCflowDeobfuscator(IEnumerable<IBlocksDeobfuscator> blocksDeobfuscator, bool disableNewCFCode) {
			Initialize(disableNewCFCode);
			Add(blocksDeobfuscator);
		}

		void Initialize(bool disableNewCFCode) {
			ourBlocksDeobfuscators.Add(new BlockCflowDeobfuscator { ExecuteIfNotModified = false });
			ourBlocksDeobfuscators.Add(new SwitchCflowDeobfuscator { ExecuteIfNotModified = false });
			ourBlocksDeobfuscators.Add(new DeadStoreRemover { ExecuteIfNotModified = false });
			ourBlocksDeobfuscators.Add(new DeadCodeRemover { ExecuteIfNotModified = false });
			ourBlocksDeobfuscators.Add(new ConstantsFolder { ExecuteIfNotModified = true, DisableNewCode = disableNewCFCode });
			ourBlocksDeobfuscators.Add(new StLdlocFixer { ExecuteIfNotModified = true });
			ourBlocksDeobfuscators.Add(new DupBlockCflowDeobfuscator { ExecuteIfNotModified = true });
		}

		public void Add(IEnumerable<IBlocksDeobfuscator> blocksDeobfuscators) {
			foreach (var bd in blocksDeobfuscators)
				Add(bd);
		}

		public void Add(IBlocksDeobfuscator blocksDeobfuscator) {
			if (blocksDeobfuscator != null)
				userBlocksDeobfuscators.Add(blocksDeobfuscator);
		}

		public void Initialize(Blocks blocks) => this.blocks = blocks;

		public void Deobfuscate() {
			bool modified;
			int iterations = -1;

			DeobfuscateBegin(userBlocksDeobfuscators);
			DeobfuscateBegin(ourBlocksDeobfuscators);

			do {
				iterations++;
				modified = false;
				RemoveDeadBlocks();
				MergeBlocks();

				blocks.MethodBlocks.GetAllBlocks(allBlocks);

				if (iterations == 0)
					modified |= FixDotfuscatorLoop();

				modified |= Deobfuscate(userBlocksDeobfuscators, allBlocks);
				modified |= Deobfuscate(ourBlocksDeobfuscators, allBlocks);
				modified |= DeobfuscateIfNotModified(modified, userBlocksDeobfuscators, allBlocks);
				modified |= DeobfuscateIfNotModified(modified, ourBlocksDeobfuscators, allBlocks);
			} while (modified);
		}

		void DeobfuscateBegin(IEnumerable<IBlocksDeobfuscator> bds) {
			foreach (var bd in bds)
				bd.DeobfuscateBegin(blocks);
		}

		bool Deobfuscate(IEnumerable<IBlocksDeobfuscator> bds, List<Block> allBlocks) {
			bool modified = false;
			foreach (var bd in bds) {
				if (bd.ExecuteIfNotModified)
					continue;
				modified |= bd.Deobfuscate(allBlocks);
			}
			return modified;
		}

		bool DeobfuscateIfNotModified(bool modified, IEnumerable<IBlocksDeobfuscator> bds, List<Block> allBlocks) {
			foreach (var bd in bds) {
				if (modified)
					break;
				if (!bd.ExecuteIfNotModified)
					continue;
				modified |= bd.Deobfuscate(allBlocks);
			}
			return modified;
		}

		// Hack for old Dotfuscator
		bool FixDotfuscatorLoop() {
			/*
			blk1:
				...
				ldc.i4.x
			blk2:
				dup
				dup
				ldc.i4.y
				some_op
				bcc blk2
			blk3:
				pop
				...
			*/
			bool modified = false;
			foreach (var block in allBlocks) {
				if (block.Instructions.Count != 5)
					continue;
				var instructions = block.Instructions;
				if (instructions[0].OpCode.Code != Code.Dup)
					continue;
				if (instructions[1].OpCode.Code != Code.Dup)
					continue;
				if (!instructions[2].IsLdcI4())
					continue;
				if (instructions[3].OpCode.Code != Code.Sub && instructions[3].OpCode.Code != Code.Add)
					continue;
				if (instructions[4].OpCode.Code != Code.Blt && instructions[4].OpCode.Code != Code.Blt_S &&
					instructions[4].OpCode.Code != Code.Bgt && instructions[4].OpCode.Code != Code.Bgt_S)
					continue;
				if (block.Sources.Count != 2)
					continue;
				var prev = block.Sources[0];
				if (prev == block)
					prev = block.Sources[1];
				if (prev == null || !prev.LastInstr.IsLdcI4())
					continue;
				var next = block.FallThrough;
				if (next.FirstInstr.OpCode.Code != Code.Pop)
					continue;
				block.ReplaceLastInstrsWithBranch(5, next);
				modified = true;
			}
			return modified;
		}

		bool RemoveDeadBlocks() => new DeadBlocksRemover(blocks.MethodBlocks).Remove() > 0;

		bool MergeBlocks() {
			bool modified = false;
			foreach (var scopeBlock in GetAllScopeBlocks(blocks.MethodBlocks))
				modified |= scopeBlock.MergeBlocks() > 0;
			return modified;
		}

		IEnumerable<ScopeBlock> GetAllScopeBlocks(ScopeBlock scopeBlock) {
			var list = new List<ScopeBlock>();
			list.Add(scopeBlock);
			list.AddRange(scopeBlock.GetAllScopeBlocks());
			return list;
		}
	}
}



================================================
File: de4dot.blocks/cflow/BranchEmulator.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using dnlib.DotNet.Emit;

namespace de4dot.blocks.cflow {
	public interface IBranchHandler {
		// stackArgs is the number of args used by the branch instruction (1 or 2)
		void HandleNormal(int stackArgs, bool isTaken);

		// Returns true if the switch target was found (even if it was the fall-through)
		bool HandleSwitch(Int32Value switchIndex);
	}

	public class BranchEmulator {
		IBranchHandler branchHandler;
		InstructionEmulator instructionEmulator;

		public BranchEmulator(InstructionEmulator instructionEmulator, IBranchHandler branchHandler) {
			this.instructionEmulator = instructionEmulator;
			this.branchHandler = branchHandler;
		}

		public bool Emulate(Instruction instr) {
			switch (instr.OpCode.Code) {
			case Code.Br:
			case Code.Br_S:		return Emulate_Br();
			case Code.Beq:
			case Code.Beq_S:	return Emulate_Beq();
			case Code.Bge:
			case Code.Bge_S:	return Emulate_Bge();
			case Code.Bge_Un:
			case Code.Bge_Un_S:	return Emulate_Bge_Un();
			case Code.Bgt:
			case Code.Bgt_S:	return Emulate_Bgt();
			case Code.Bgt_Un:
			case Code.Bgt_Un_S:	return Emulate_Bgt_Un();
			case Code.Ble:
			case Code.Ble_S:	return Emulate_Ble();
			case Code.Ble_Un:
			case Code.Ble_Un_S:	return Emulate_Ble_Un();
			case Code.Blt:
			case Code.Blt_S:	return Emulate_Blt();
			case Code.Blt_Un:
			case Code.Blt_Un_S:	return Emulate_Blt_Un();
			case Code.Bne_Un:
			case Code.Bne_Un_S:	return Emulate_Bne_Un();
			case Code.Brfalse:
			case Code.Brfalse_S:return Emulate_Brfalse();
			case Code.Brtrue:
			case Code.Brtrue_S:	return Emulate_Brtrue();
			case Code.Switch:	return Emulate_Switch();

			default:
				return false;
			}
		}

		bool EmulateBranch(int stackArgs, Bool3 cond) {
			if (cond == Bool3.Unknown)
				return false;
			return EmulateBranch(stackArgs, cond == Bool3.True);
		}

		bool EmulateBranch(int stackArgs, bool isTaken) {
			branchHandler.HandleNormal(stackArgs, isTaken);
			return true;
		}

		bool Emulate_Br() => EmulateBranch(0, true);

		bool Emulate_Beq() {
			var val2 = instructionEmulator.Pop();
			var val1 = instructionEmulator.Pop();

			if (val1.IsInt32() && val2.IsInt32())
				return EmulateBranch(2, Int32Value.CompareEq((Int32Value)val1, (Int32Value)val2));
			else if (val1.IsInt64() && val2.IsInt64())
				return EmulateBranch(2, Int64Value.CompareEq((Int64Value)val1, (Int64Value)val2));
			else if (val1.IsReal8() && val2.IsReal8())
				return EmulateBranch(2, Real8Value.CompareEq((Real8Value)val1, (Real8Value)val2));
			else if (val1.IsNull() && val2.IsNull())
				return EmulateBranch(2, true);
			else
				return false;
		}

		bool Emulate_Bne_Un() {
			var val2 = instructionEmulator.Pop();
			var val1 = instructionEmulator.Pop();

			if (val1.IsInt32() && val2.IsInt32())
				return EmulateBranch(2, Int32Value.CompareNeq((Int32Value)val1, (Int32Value)val2));
			else if (val1.IsInt64() && val2.IsInt64())
				return EmulateBranch(2, Int64Value.CompareNeq((Int64Value)val1, (Int64Value)val2));
			else if (val1.IsReal8() && val2.IsReal8())
				return EmulateBranch(2, Real8Value.CompareNeq((Real8Value)val1, (Real8Value)val2));
			else if (val1.IsNull() && val2.IsNull())
				return EmulateBranch(2, false);
			else
				return false;
		}

		bool Emulate_Bge() {
			var val2 = instructionEmulator.Pop();
			var val1 = instructionEmulator.Pop();

			if (val1.IsInt32() && val2.IsInt32())
				return EmulateBranch(2, Int32Value.CompareGe((Int32Value)val1, (Int32Value)val2));
			else if (val1.IsInt64() && val2.IsInt64())
				return EmulateBranch(2, Int64Value.CompareGe((Int64Value)val1, (Int64Value)val2));
			else if (val1.IsReal8() && val2.IsReal8())
				return EmulateBranch(2, Real8Value.CompareGe((Real8Value)val1, (Real8Value)val2));
			else
				return false;
		}

		bool Emulate_Bge_Un() {
			var val2 = instructionEmulator.Pop();
			var val1 = instructionEmulator.Pop();

			if (val1.IsInt32() && val2.IsInt32())
				return EmulateBranch(2, Int32Value.CompareGe_Un((Int32Value)val1, (Int32Value)val2));
			else if (val1.IsInt64() && val2.IsInt64())
				return EmulateBranch(2, Int64Value.CompareGe_Un((Int64Value)val1, (Int64Value)val2));
			else if (val1.IsReal8() && val2.IsReal8())
				return EmulateBranch(2, Real8Value.CompareGe_Un((Real8Value)val1, (Real8Value)val2));
			else
				return false;
		}

		bool Emulate_Bgt() {
			var val2 = instructionEmulator.Pop();
			var val1 = instructionEmulator.Pop();

			if (val1.IsInt32() && val2.IsInt32())
				return EmulateBranch(2, Int32Value.CompareGt((Int32Value)val1, (Int32Value)val2));
			else if (val1.IsInt64() && val2.IsInt64())
				return EmulateBranch(2, Int64Value.CompareGt((Int64Value)val1, (Int64Value)val2));
			else if (val1.IsReal8() && val2.IsReal8())
				return EmulateBranch(2, Real8Value.CompareGt((Real8Value)val1, (Real8Value)val2));
			else
				return false;
		}

		bool Emulate_Bgt_Un() {
			var val2 = instructionEmulator.Pop();
			var val1 = instructionEmulator.Pop();

			if (val1.IsInt32() && val2.IsInt32())
				return EmulateBranch(2, Int32Value.CompareGt_Un((Int32Value)val1, (Int32Value)val2));
			else if (val1.IsInt64() && val2.IsInt64())
				return EmulateBranch(2, Int64Value.CompareGt_Un((Int64Value)val1, (Int64Value)val2));
			else if (val1.IsReal8() && val2.IsReal8())
				return EmulateBranch(2, Real8Value.CompareGt_Un((Real8Value)val1, (Real8Value)val2));
			else
				return false;
		}

		bool Emulate_Ble() {
			var val2 = instructionEmulator.Pop();
			var val1 = instructionEmulator.Pop();

			if (val1.IsInt32() && val2.IsInt32())
				return EmulateBranch(2, Int32Value.CompareLe((Int32Value)val1, (Int32Value)val2));
			else if (val1.IsInt64() && val2.IsInt64())
				return EmulateBranch(2, Int64Value.CompareLe((Int64Value)val1, (Int64Value)val2));
			else if (val1.IsReal8() && val2.IsReal8())
				return EmulateBranch(2, Real8Value.CompareLe((Real8Value)val1, (Real8Value)val2));
			else
				return false;
		}

		bool Emulate_Ble_Un() {
			var val2 = instructionEmulator.Pop();
			var val1 = instructionEmulator.Pop();

			if (val1.IsInt32() && val2.IsInt32())
				return EmulateBranch(2, Int32Value.CompareLe_Un((Int32Value)val1, (Int32Value)val2));
			else if (val1.IsInt64() && val2.IsInt64())
				return EmulateBranch(2, Int64Value.CompareLe_Un((Int64Value)val1, (Int64Value)val2));
			else if (val1.IsReal8() && val2.IsReal8())
				return EmulateBranch(2, Real8Value.CompareLe_Un((Real8Value)val1, (Real8Value)val2));
			else
				return false;
		}

		bool Emulate_Blt() {
			var val2 = instructionEmulator.Pop();
			var val1 = instructionEmulator.Pop();

			if (val1.IsInt32() && val2.IsInt32())
				return EmulateBranch(2, Int32Value.CompareLt((Int32Value)val1, (Int32Value)val2));
			else if (val1.IsInt64() && val2.IsInt64())
				return EmulateBranch(2, Int64Value.CompareLt((Int64Value)val1, (Int64Value)val2));
			else if (val1.IsReal8() && val2.IsReal8())
				return EmulateBranch(2, Real8Value.CompareLt((Real8Value)val1, (Real8Value)val2));
			else
				return false;
		}

		bool Emulate_Blt_Un() {
			var val2 = instructionEmulator.Pop();
			var val1 = instructionEmulator.Pop();

			if (val1.IsInt32() && val2.IsInt32())
				return EmulateBranch(2, Int32Value.CompareLt_Un((Int32Value)val1, (Int32Value)val2));
			else if (val1.IsInt64() && val2.IsInt64())
				return EmulateBranch(2, Int64Value.CompareLt_Un((Int64Value)val1, (Int64Value)val2));
			else if (val1.IsReal8() && val2.IsReal8())
				return EmulateBranch(2, Real8Value.CompareLt_Un((Real8Value)val1, (Real8Value)val2));
			else
				return false;
		}

		bool Emulate_Brfalse() {
			var val1 = instructionEmulator.Pop();

			if (val1.IsInt32())
				return EmulateBranch(1, Int32Value.CompareFalse((Int32Value)val1));
			else if (val1.IsInt64())
				return EmulateBranch(1, Int64Value.CompareFalse((Int64Value)val1));
			else if (val1.IsReal8())
				return EmulateBranch(1, Real8Value.CompareFalse((Real8Value)val1));
			else if (val1.IsNull())
				return EmulateBranch(1, true);
			else if (val1.IsObject() || val1.IsString())
				return EmulateBranch(1, false);
			else
				return false;
		}

		bool Emulate_Brtrue() {
			var val1 = instructionEmulator.Pop();

			if (val1.IsInt32())
				return EmulateBranch(1, Int32Value.CompareTrue((Int32Value)val1));
			else if (val1.IsInt64())
				return EmulateBranch(1, Int64Value.CompareTrue((Int64Value)val1));
			else if (val1.IsReal8())
				return EmulateBranch(1, Real8Value.CompareTrue((Real8Value)val1));
			else if (val1.IsNull())
				return EmulateBranch(1, false);
			else if (val1.IsObject() || val1.IsString())
				return EmulateBranch(1, true);
			else
				return false;
		}

		bool Emulate_Switch() {
			var val1 = instructionEmulator.Pop();

			if (!val1.IsInt32())
				return false;
			return branchHandler.HandleSwitch((Int32Value)val1);
		}
	}
}



================================================
File: de4dot.blocks/cflow/CachedCflowDeobfuscator.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace de4dot.blocks.cflow {
	// Only deobfuscates a method once. A copy of the method (now deobfuscated) is returned.
	public class CachedCflowDeobfuscator {
		BlocksCflowDeobfuscator cflowDeobfuscator = new BlocksCflowDeobfuscator();
		Dictionary<MethodDef, MethodDef> deobfuscated = new Dictionary<MethodDef, MethodDef>();

		public CachedCflowDeobfuscator() {
		}

		public CachedCflowDeobfuscator(IEnumerable<IBlocksDeobfuscator> blocksDeobfuscators) => Add(blocksDeobfuscators);

		public void Add(IEnumerable<IBlocksDeobfuscator> blocksDeobfuscators) {
			foreach (var bd in blocksDeobfuscators)
				cflowDeobfuscator.Add(bd);
		}

		public void Add(IBlocksDeobfuscator blocksDeobfuscator) => cflowDeobfuscator.Add(blocksDeobfuscator);

		public MethodDef Deobfuscate(MethodDef method) {
			if (deobfuscated.TryGetValue(method, out var deobfuscatedMethod))
				return deobfuscatedMethod;

			if (method.Body == null || method.Body.Instructions.Count == 0) {
				deobfuscated[method] = method;
				return method;
			}

			deobfuscatedMethod = DotNetUtils.Clone(method);
			deobfuscated[method] = deobfuscatedMethod;

			var blocks = new Blocks(deobfuscatedMethod);
			Deobfuscate(blocks);
			blocks.GetCode(out var allInstructions, out var allExceptionHandlers);
			DotNetUtils.RestoreBody(deobfuscatedMethod, allInstructions, allExceptionHandlers);

			return deobfuscatedMethod;
		}

		void Deobfuscate(Blocks blocks) {
			cflowDeobfuscator.Initialize(blocks);
			cflowDeobfuscator.Deobfuscate();
		}
	}
}



================================================
File: de4dot.blocks/cflow/CflowDeobfuscator.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace de4dot.blocks.cflow {
	public class CflowDeobfuscator : ICflowDeobfuscator {
		BlocksCflowDeobfuscator cflowDeobfuscator = new BlocksCflowDeobfuscator();

		public CflowDeobfuscator() {
		}

		public CflowDeobfuscator(IBlocksDeobfuscator blocksDeobfuscator) => cflowDeobfuscator.Add(blocksDeobfuscator);

		public void Deobfuscate(MethodDef method) =>
			Deobfuscate(method, (blocks) => {
				cflowDeobfuscator.Initialize(blocks);
				cflowDeobfuscator.Deobfuscate();
			});

		static bool HasNonEmptyBody(MethodDef method) => method.Body != null && method.Body.Instructions.Count > 0;

		void Deobfuscate(MethodDef method, Action<Blocks> handler) {
			if (HasNonEmptyBody(method)) {
				var blocks = new Blocks(method);

				handler(blocks);

				blocks.GetCode(out var allInstructions, out var allExceptionHandlers);
				DotNetUtils.RestoreBody(method, allInstructions, allExceptionHandlers);
			}
		}
	}
}



================================================
File: de4dot.blocks/cflow/CflowUtils.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;

namespace de4dot.blocks.cflow {
	static class CflowUtils {
		public static Block GetSwitchTarget(IList<Block> targets, Block fallThrough, Int32Value intValue) {
			if (!intValue.AllBitsValid())
				return null;

			int index = intValue.Value;
			if (targets == null || index < 0 || index >= targets.Count)
				return fallThrough;
			else
				return targets[index];
		}
	}
}



================================================
File: de4dot.blocks/cflow/ConstantsFolder.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace de4dot.blocks.cflow {
	// Very simple constants folder which is all that's needed at the moment
	class ConstantsFolder : BlockDeobfuscator {
		InstructionEmulator instructionEmulator = new InstructionEmulator();
		IList<Parameter> args;

		public bool DisableNewCode { get; set; }

		protected override void Initialize(List<Block> allBlocks) {
			base.Initialize(allBlocks);
			args = blocks.Method.Parameters;
		}

		protected override bool Deobfuscate(Block block) {
			bool modified = false;

			instructionEmulator.Initialize(blocks, allBlocks[0] == block);
			var instrs = block.Instructions;
			for (int i = 0; i < instrs.Count; i++) {
				var instr = instrs[i];

				switch (instr.OpCode.Code) {
				case Code.Ldarg:
				case Code.Ldarg_0:
				case Code.Ldarg_1:
				case Code.Ldarg_2:
				case Code.Ldarg_3:
				case Code.Ldarg_S:
					modified |= FixLoadInstruction(block, i, instructionEmulator.GetArg(instr.Instruction.GetParameter(args)));
					break;

				case Code.Ldloc:
				case Code.Ldloc_0:
				case Code.Ldloc_1:
				case Code.Ldloc_2:
				case Code.Ldloc_3:
				case Code.Ldloc_S:
					modified |= FixLoadInstruction(block, i, instructionEmulator.GetLocal(instr.Instruction.GetLocal(blocks.Locals)));
					break;

				case Code.Ldarga:
				case Code.Ldarga_S:
					instructionEmulator.MakeArgUnknown((Parameter)instr.Operand);
					break;

				case Code.Ldloca:
				case Code.Ldloca_S:
					instructionEmulator.MakeLocalUnknown((Local)instr.Operand);
					break;

				case Code.Add:
				case Code.Add_Ovf:
				case Code.Add_Ovf_Un:
				case Code.And:
				case Code.Ceq:
				case Code.Cgt:
				case Code.Cgt_Un:
				case Code.Clt:
				case Code.Clt_Un:
				case Code.Conv_I:
				case Code.Conv_I1:
				case Code.Conv_I2:
				case Code.Conv_I4:
				case Code.Conv_I8:
				case Code.Conv_Ovf_I:
				case Code.Conv_Ovf_I_Un:
				case Code.Conv_Ovf_I1:
				case Code.Conv_Ovf_I1_Un:
				case Code.Conv_Ovf_I2:
				case Code.Conv_Ovf_I2_Un:
				case Code.Conv_Ovf_I4:
				case Code.Conv_Ovf_I4_Un:
				case Code.Conv_Ovf_I8:
				case Code.Conv_Ovf_I8_Un:
				case Code.Conv_Ovf_U:
				case Code.Conv_Ovf_U_Un:
				case Code.Conv_Ovf_U1:
				case Code.Conv_Ovf_U1_Un:
				case Code.Conv_Ovf_U2:
				case Code.Conv_Ovf_U2_Un:
				case Code.Conv_Ovf_U4:
				case Code.Conv_Ovf_U4_Un:
				case Code.Conv_Ovf_U8:
				case Code.Conv_Ovf_U8_Un:
				case Code.Conv_R_Un:
				case Code.Conv_R4:
				case Code.Conv_R8:
				case Code.Conv_U:
				case Code.Conv_U1:
				case Code.Conv_U2:
				case Code.Conv_U4:
				case Code.Conv_U8:
				case Code.Div:
				case Code.Div_Un:
				case Code.Dup:
				case Code.Mul:
				case Code.Mul_Ovf:
				case Code.Mul_Ovf_Un:
				case Code.Neg:
				case Code.Not:
				case Code.Or:
				case Code.Rem:
				case Code.Rem_Un:
				case Code.Shl:
				case Code.Shr:
				case Code.Shr_Un:
				case Code.Sub:
				case Code.Sub_Ovf:
				case Code.Sub_Ovf_Un:
				case Code.Xor:
					if (DisableNewCode)
						break;
					if (i + 1 < instrs.Count && instrs[i + 1].OpCode.Code == Code.Pop)
						break;
					if (!VerifyValidArgs(instr.Instruction))
						break;
					instructionEmulator.Emulate(instr.Instruction);
					var tos = instructionEmulator.Peek();
					Instruction newInstr = null;
					if (tos.IsInt32()) {
						var val = (Int32Value)tos;
						if (val.AllBitsValid())
							newInstr = Instruction.CreateLdcI4(val.Value);
					}
					else if (tos.IsInt64()) {
						var val = (Int64Value)tos;
						if (val.AllBitsValid())
							newInstr = OpCodes.Ldc_I8.ToInstruction(val.Value);
					}
					else if (tos.IsReal8()) {
						var val = (Real8Value)tos;
						if (val.IsValid)
							newInstr = GetLoadRealInstruction(val.Value);
					}
					if (newInstr != null) {
						block.Insert(i + 1, Instruction.Create(OpCodes.Pop));
						block.Insert(i + 2, newInstr);
						i += 2;
						modified = true;
					}
					continue;
				}

				try {
					instructionEmulator.Emulate(instr.Instruction);
				}
				catch (NullReferenceException) {
					// Here if eg. invalid metadata token in a call instruction (operand is null)
					break;
				}
			}

			return modified;
		}

		bool VerifyValidArgs(Instruction instr) {
			instr.CalculateStackUsage(out int pushes, out int pops);
			if (pops < 0)
				return false;

			bool retVal;
			Value val2, val1;
			switch (pops) {
			case 0:
				return true;

			case 1:
				val1 = instructionEmulator.Pop();
				retVal = VerifyValidArg(val1);
				instructionEmulator.Push(val1);
				return retVal;

			case 2:
				val2 = instructionEmulator.Pop();
				val1 = instructionEmulator.Pop();
				retVal = VerifyValidArg(val2) && VerifyValidArg(val1);
				instructionEmulator.Push(val1);
				instructionEmulator.Push(val2);
				return retVal;
			}

			return false;
		}

		static bool VerifyValidArg(Value value) {
			if (value.IsInt32())
				return ((Int32Value)value).AllBitsValid();
			if (value.IsInt64())
				return ((Int64Value)value).AllBitsValid();
			if (value.IsReal8())
				return ((Real8Value)value).IsValid;
			return false;
		}

		static Instruction GetLoadRealInstruction(double value) {
			var floatVal = (float)value;
			if (floatVal == value || double.IsNaN(value))
				return OpCodes.Ldc_R4.ToInstruction(floatVal);
			return OpCodes.Ldc_R8.ToInstruction(value);
		}

		bool FixLoadInstruction(Block block, int index, Value value) {
			if (value.IsInt32()) {
				var intValue = (Int32Value)value;
				if (!intValue.AllBitsValid())
					return false;
				block.Instructions[index] = new Instr(Instruction.CreateLdcI4(intValue.Value));
				return true;
			}
			else if (value.IsInt64()) {
				var intValue = (Int64Value)value;
				if (!intValue.AllBitsValid())
					return false;
				block.Instructions[index] = new Instr(OpCodes.Ldc_I8.ToInstruction(intValue.Value));
				return true;
			}
			return false;
		}
	}
}



================================================
File: de4dot.blocks/cflow/DeadCodeRemover.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet.Emit;

namespace de4dot.blocks.cflow {
	// Removes dead code that is the result of one of our optimizations, or created by the
	// obfuscator.
	class DeadCodeRemover : BlockDeobfuscator {
		List<int> allDeadInstructions = new List<int>();
		InstructionExpressionFinder instructionExpressionFinder = new InstructionExpressionFinder();

		protected override bool Deobfuscate(Block block) {
			allDeadInstructions.Clear();

			bool modified = false;
			var instructions = block.Instructions;
			for (int i = 0; i < instructions.Count; i++) {
				var instr = instructions[i];
				switch (instr.OpCode.Code) {
				case Code.Nop:
					// The NOP is recreated if the block is empty so don't remove it if it's
					// the only instruction.
					if (instructions.Count > 1)
						allDeadInstructions.Add(i);
					break;

				case Code.Dup:
					if (i + 1 >= instructions.Count)
						break;
					if (instructions[i + 1].OpCode.Code != Code.Pop)
						break;
					allDeadInstructions.Add(i);
					allDeadInstructions.Add(i + 1);
					i++;
					break;

				case Code.Leave:
				case Code.Leave_S:
				case Code.Endfinally:
				case Code.Pop:
					instructionExpressionFinder.Initialize(block, false);
					if (!instructionExpressionFinder.Find(i))
						continue;
					if (!OkInstructions(block, instructionExpressionFinder.DeadInstructions))
						continue;
					allDeadInstructions.AddRange(instructionExpressionFinder.DeadInstructions);
					break;

				default:
					break;
				}
			}

			if (allDeadInstructions.Count > 0) {
				block.Remove(allDeadInstructions);
				modified = true;
			}

			return modified;
		}

		bool OkInstructions(Block block, IEnumerable<int> indexes) {
			foreach (var index in indexes) {
				var instr = block.Instructions[index];
				switch (instr.OpCode.Code) {
				case Code.Add:
				case Code.Add_Ovf:
				case Code.Add_Ovf_Un:
				case Code.And:
				case Code.Arglist:
				case Code.Beq:
				case Code.Beq_S:
				case Code.Bge:
				case Code.Bge_S:
				case Code.Bge_Un:
				case Code.Bge_Un_S:
				case Code.Bgt:
				case Code.Bgt_S:
				case Code.Bgt_Un:
				case Code.Bgt_Un_S:
				case Code.Ble:
				case Code.Ble_S:
				case Code.Ble_Un:
				case Code.Ble_Un_S:
				case Code.Blt:
				case Code.Blt_S:
				case Code.Blt_Un:
				case Code.Blt_Un_S:
				case Code.Bne_Un:
				case Code.Bne_Un_S:
				case Code.Box:
				case Code.Br:
				case Code.Br_S:
				case Code.Break:
				case Code.Brfalse:
				case Code.Brfalse_S:
				case Code.Brtrue:
				case Code.Brtrue_S:
				case Code.Castclass:
				case Code.Ceq:
				case Code.Cgt:
				case Code.Cgt_Un:
				case Code.Ckfinite:
				case Code.Clt:
				case Code.Clt_Un:
				case Code.Constrained:
				case Code.Conv_I:
				case Code.Conv_I1:
				case Code.Conv_I2:
				case Code.Conv_I4:
				case Code.Conv_I8:
				case Code.Conv_Ovf_I:
				case Code.Conv_Ovf_I1:
				case Code.Conv_Ovf_I1_Un:
				case Code.Conv_Ovf_I2:
				case Code.Conv_Ovf_I2_Un:
				case Code.Conv_Ovf_I4:
				case Code.Conv_Ovf_I4_Un:
				case Code.Conv_Ovf_I8:
				case Code.Conv_Ovf_I8_Un:
				case Code.Conv_Ovf_I_Un:
				case Code.Conv_Ovf_U:
				case Code.Conv_Ovf_U1:
				case Code.Conv_Ovf_U1_Un:
				case Code.Conv_Ovf_U2:
				case Code.Conv_Ovf_U2_Un:
				case Code.Conv_Ovf_U4:
				case Code.Conv_Ovf_U4_Un:
				case Code.Conv_Ovf_U8:
				case Code.Conv_Ovf_U8_Un:
				case Code.Conv_Ovf_U_Un:
				case Code.Conv_R4:
				case Code.Conv_R8:
				case Code.Conv_R_Un:
				case Code.Conv_U:
				case Code.Conv_U1:
				case Code.Conv_U2:
				case Code.Conv_U4:
				case Code.Conv_U8:
				case Code.Div:
				case Code.Div_Un:
				case Code.Dup:
				case Code.Endfilter:
				case Code.Endfinally:
				case Code.Isinst:
				case Code.Jmp:
				case Code.Ldarg:
				case Code.Ldarg_0:
				case Code.Ldarg_1:
				case Code.Ldarg_2:
				case Code.Ldarg_3:
				case Code.Ldarg_S:
				case Code.Ldarga:
				case Code.Ldarga_S:
				case Code.Ldc_I4:
				case Code.Ldc_I4_0:
				case Code.Ldc_I4_1:
				case Code.Ldc_I4_2:
				case Code.Ldc_I4_3:
				case Code.Ldc_I4_4:
				case Code.Ldc_I4_5:
				case Code.Ldc_I4_6:
				case Code.Ldc_I4_7:
				case Code.Ldc_I4_8:
				case Code.Ldc_I4_M1:
				case Code.Ldc_I4_S:
				case Code.Ldc_I8:
				case Code.Ldc_R4:
				case Code.Ldc_R8:
				case Code.Ldelem:
				case Code.Ldelem_I:
				case Code.Ldelem_I1:
				case Code.Ldelem_I2:
				case Code.Ldelem_I4:
				case Code.Ldelem_I8:
				case Code.Ldelem_R4:
				case Code.Ldelem_R8:
				case Code.Ldelem_Ref:
				case Code.Ldelem_U1:
				case Code.Ldelem_U2:
				case Code.Ldelem_U4:
				case Code.Ldelema:
				case Code.Ldfld:
				case Code.Ldflda:
				case Code.Ldftn:
				case Code.Ldind_I:
				case Code.Ldind_I1:
				case Code.Ldind_I2:
				case Code.Ldind_I4:
				case Code.Ldind_I8:
				case Code.Ldind_R4:
				case Code.Ldind_R8:
				case Code.Ldind_Ref:
				case Code.Ldind_U1:
				case Code.Ldind_U2:
				case Code.Ldind_U4:
				case Code.Ldlen:
				case Code.Ldloc:
				case Code.Ldloc_0:
				case Code.Ldloc_1:
				case Code.Ldloc_2:
				case Code.Ldloc_3:
				case Code.Ldloc_S:
				case Code.Ldloca:
				case Code.Ldloca_S:
				case Code.Ldnull:
				case Code.Ldobj:
				case Code.Ldsfld:
				case Code.Ldsflda:
				case Code.Ldstr:
				case Code.Ldtoken:
				case Code.Ldvirtftn:
				case Code.Leave:
				case Code.Leave_S:
				case Code.Localloc:
				case Code.Mkrefany:
				case Code.Mul:
				case Code.Mul_Ovf:
				case Code.Mul_Ovf_Un:
				case Code.Neg:
				case Code.Newarr:
				case Code.Nop:
				case Code.Not:
				case Code.Or:
				case Code.Pop:
				case Code.Readonly:
				case Code.Refanytype:
				case Code.Refanyval:
				case Code.Rem:
				case Code.Rem_Un:
				case Code.Ret:
				case Code.Rethrow:
				case Code.Shl:
				case Code.Shr:
				case Code.Shr_Un:
				case Code.Sizeof:
				case Code.Sub:
				case Code.Sub_Ovf:
				case Code.Sub_Ovf_Un:
				case Code.Switch:
				case Code.Tailcall:
				case Code.Throw:
				case Code.Unaligned:
				case Code.Unbox:
				case Code.Unbox_Any:
				case Code.Volatile:
				case Code.Xor:
					break;

				case Code.Call:
				case Code.Calli:
				case Code.Callvirt:
				case Code.Cpblk:
				case Code.Cpobj:
				case Code.Initblk:
				case Code.Initobj:
				case Code.Newobj:
				case Code.Starg:
				case Code.Starg_S:
				case Code.Stelem:
				case Code.Stelem_I:
				case Code.Stelem_I1:
				case Code.Stelem_I2:
				case Code.Stelem_I4:
				case Code.Stelem_I8:
				case Code.Stelem_R4:
				case Code.Stelem_R8:
				case Code.Stelem_Ref:
				case Code.Stfld:
				case Code.Stind_I:
				case Code.Stind_I1:
				case Code.Stind_I2:
				case Code.Stind_I4:
				case Code.Stind_I8:
				case Code.Stind_R4:
				case Code.Stind_R8:
				case Code.Stind_Ref:
				case Code.Stloc:
				case Code.Stloc_0:
				case Code.Stloc_1:
				case Code.Stloc_2:
				case Code.Stloc_3:
				case Code.Stloc_S:
				case Code.Stobj:
				case Code.Stsfld:
				default:
					return false;
				}
			}

			return true;
		}

		class InstructionExpressionFinder {
			List<int> deadInstructions = new List<int>();
			Block block;
			bool methodHasReturnValue;

			public List<int> DeadInstructions => deadInstructions;

			public void Initialize(Block block, bool methodHasReturnValue) {
				deadInstructions.Clear();
				this.block = block;
				this.methodHasReturnValue = methodHasReturnValue;
			}

			public bool Find(int index) => Find(ref index, true);

			bool Find(ref int index, bool addIt) {
				if (index < 0)
					return false;

				var startInstr = block.Instructions[index];
				CalculateStackUsage(startInstr.Instruction, false, out int startInstrPushes, out int startInstrPops);

				// Don't add it if it clears the stack (eg. leave)
				if (addIt && startInstrPops >= 0)
					AddIndex(index);

				if (startInstrPops == 0)
					return true;

				while (index > 0) {
					var instr = block.Instructions[index - 1];
					if (startInstrPops == 0 && instr.OpCode.OpCodeType != OpCodeType.Prefix)
						break;

					CalculateStackUsage(instr.Instruction, methodHasReturnValue, out int pushes, out int pops);
					if (pops < 0)
						break;	// eg. leave
					index--;

					if (pops > 0) {	// if instr uses any args
						bool otherExpr = pops > 0 && pushes == 0;
						if (!Find(ref index, addIt && !otherExpr))
							break;
					}
					else if (pushes != 0 || pops != 0) {
						if (addIt)
							AddIndex(index);
					}
					if (pushes > 0 && startInstrPops >= 0) {
						if (pushes > startInstrPops)
							return false;
						startInstrPops -= pushes;
					}
				}

				return startInstrPops <= 0;
			}

			void AddIndex(int index) => deadInstructions.Add(index);
		}

		static void CalculateStackUsage(Instruction instr, bool methodHasReturnValue, out int pushes, out int pops) =>
			instr.CalculateStackUsage(false, out pushes, out pops);
	}
}



================================================
File: de4dot.blocks/cflow/DeadStoreRemover.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet.Emit;

namespace de4dot.blocks.cflow {
	// Removes dead stores by replacing the stloc with a pop. Other optimizations will notice it's
	// dead code and remove it.
	// I've only seen Xenocode generate this kind of code, so the code below is a special case of
	// the more general case.
	class DeadStoreRemover : IBlocksDeobfuscator {
		Blocks blocks;
		List<Block> allBlocks;
		List<AccessFlags> localFlags = new List<AccessFlags>();
		List<bool> deadLocals = new List<bool>();

		[Flags]
		enum AccessFlags {
			None = 0,
			Read = 1,
			Write = 2,
		}

		public bool ExecuteIfNotModified { get; set; }

		public void DeobfuscateBegin(Blocks blocks) => this.blocks = blocks;

		public bool Deobfuscate(List<Block> allBlocks) {
			this.allBlocks = allBlocks;
			return Remove();
		}

		bool Remove() {
			if (blocks.Locals.Count == 0)
				return false;

			localFlags.Clear();
			deadLocals.Clear();
			for (int i = 0; i < blocks.Locals.Count; i++) {
				localFlags.Add(AccessFlags.None);
				deadLocals.Add(false);
			}

			FindLoadStores();

			bool deadStores = false;
			for (int i = 0; i < blocks.Locals.Count; i++) {
				var flags = localFlags[i];
				if ((flags & AccessFlags.Read) == AccessFlags.None) {
					deadLocals[i] = true;
					deadStores = true;
				}
			}
			if (!deadStores)
				return false;

			return RemoveDeadStores();
		}

		void FindLoadStores() {
			foreach (var block in allBlocks) {
				foreach (var instr in block.Instructions) {
					Local local;
					AccessFlags flags;
					switch (instr.OpCode.Code) {
					case Code.Ldloc:
					case Code.Ldloc_S:
					case Code.Ldloc_0:
					case Code.Ldloc_1:
					case Code.Ldloc_2:
					case Code.Ldloc_3:
						local = Instr.GetLocalVar(blocks.Locals, instr);
						flags = AccessFlags.Read;
						break;

					case Code.Stloc:
					case Code.Stloc_S:
					case Code.Stloc_0:
					case Code.Stloc_1:
					case Code.Stloc_2:
					case Code.Stloc_3:
						local = Instr.GetLocalVar(blocks.Locals, instr);
						flags = AccessFlags.Write;
						break;

					case Code.Ldloca_S:
					case Code.Ldloca:
						local = instr.Operand as Local;
						flags = AccessFlags.Read | AccessFlags.Write;
						break;

					default:
						local = null;
						flags = AccessFlags.None;
						break;
					}

					if (local == null)
						continue;
					localFlags[local.Index] |= flags;
				}
			}
		}

		bool RemoveDeadStores() {
			bool modified = false;
			foreach (var block in allBlocks) {
				var instructions = block.Instructions;
				for (int i = 0; i < instructions.Count; i++) {
					var instr = instructions[i];
					Local local;
					switch (instr.OpCode.Code) {
					case Code.Stloc:
					case Code.Stloc_S:
					case Code.Stloc_0:
					case Code.Stloc_1:
					case Code.Stloc_2:
					case Code.Stloc_3:
						local = Instr.GetLocalVar(blocks.Locals, instr);
						break;

					default:
						continue;
					}

					if (local == null)
						continue;
					if (!deadLocals[local.Index])
						continue;
					instructions[i] = new Instr(OpCodes.Pop.ToInstruction());
					modified = true;
				}
			}

			return modified;
		}
	}
}



================================================
File: de4dot.blocks/cflow/DupBlockDeobfuscator.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet.Emit;

namespace de4dot.blocks.cflow {
	// If a block is just a dup followed by a bcc, try to append the block
	// to all its sources. Will fix some SA assemblies.
	class DupBlockCflowDeobfuscator : BlockDeobfuscator {
		protected override bool Deobfuscate(Block block) {
			if (block.Instructions.Count != 2)
				return false;
			if (block.Instructions[0].OpCode.Code != Code.Dup)
				return false;
			if (!block.LastInstr.IsConditionalBranch() && block.LastInstr.OpCode.Code != Code.Switch)
				return false;

			bool modified = false;
			foreach (var source in new List<Block>(block.Sources)) {
				if (source.GetOnlyTarget() != block)
					continue;
				if (!source.CanAppend(block))
					continue;

				source.Append(block);
				modified = true;
			}
			return modified;
		}
	}
}



================================================
File: de4dot.blocks/cflow/IBlocksDeobfuscator.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;

namespace de4dot.blocks.cflow {
	public interface IBlocksDeobfuscator {
		bool ExecuteIfNotModified { get; }

		void DeobfuscateBegin(Blocks blocks);

		// Returns true if something was updated
		bool Deobfuscate(List<Block> allBlocks);
	}
}



================================================
File: de4dot.blocks/cflow/ICflowDeobfuscator.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using dnlib.DotNet;

namespace de4dot.blocks.cflow {
	public interface ICflowDeobfuscator {
		void Deobfuscate(MethodDef method);
	}
}



================================================
File: de4dot.blocks/cflow/InstructionEmulator.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace de4dot.blocks.cflow {
	public class InstructionEmulator {
		ValueStack valueStack = new ValueStack();
		Dictionary<Value, bool> protectedStackValues = new Dictionary<Value, bool>();
		IList<Parameter> parameterDefs;
		IList<Local> localDefs;
		List<Value> args = new List<Value>();
		List<Value> locals = new List<Value>();

		MethodDef prev_method;
		List<Value> cached_args = new List<Value>();
		List<Value> cached_locals = new List<Value>();
		List<Value> cached_zeroed_locals = new List<Value>();

		public InstructionEmulator() {
		}

		public InstructionEmulator(MethodDef method) => Initialize(method, false);
		public void Initialize(Blocks blocks, bool emulateFromFirstInstruction) =>
			Initialize(blocks.Method, emulateFromFirstInstruction);
		public void Initialize(MethodDef method) => Initialize(method, false);
		public void Initialize(MethodDef method, bool emulateFromFirstInstruction) =>
			Initialize(method, method.Parameters, method.Body.Variables, method.Body.InitLocals, emulateFromFirstInstruction);

		public void Initialize(MethodDef method, IList<Parameter> methodParameters, IList<Local> methodLocals, bool initLocals, bool emulateFromFirstInstruction) {
			parameterDefs = methodParameters;
			localDefs = methodLocals;
			valueStack.Initialize();
			protectedStackValues.Clear();

			if (method != prev_method) {
				prev_method = method;

				cached_args.Clear();
				for (int i = 0; i < parameterDefs.Count; i++)
					cached_args.Add(GetUnknownValue(parameterDefs[i].Type));

				cached_locals.Clear();
				cached_zeroed_locals.Clear();
				for (int i = 0; i < localDefs.Count; i++) {
					cached_locals.Add(GetUnknownValue(localDefs[i].Type));
					cached_zeroed_locals.Add(GetDefaultValue(localDefs[i].Type));
				}
			}

			args.Clear();
			args.AddRange(cached_args);
			locals.Clear();
			locals.AddRange(initLocals && emulateFromFirstInstruction ? cached_zeroed_locals : cached_locals);
		}

		public void SetProtected(Value value) => protectedStackValues[value] = true;
		static Value GetUnknownValue(ITypeDefOrRef type) => GetUnknownValue(type.ToTypeSig(false));

		static Value GetUnknownValue(TypeSig type) {
			if (type == null)
				return new UnknownValue();
			switch (type.ElementType) {
			case ElementType.Boolean: return Int32Value.CreateUnknownBool();
			case ElementType.I1: return Int32Value.CreateUnknown();
			case ElementType.U1: return Int32Value.CreateUnknownUInt8();
			case ElementType.I2: return Int32Value.CreateUnknown();
			case ElementType.U2: return Int32Value.CreateUnknownUInt16();
			case ElementType.I4: return Int32Value.CreateUnknown();
			case ElementType.U4: return Int32Value.CreateUnknown();
			case ElementType.I8: return Int64Value.CreateUnknown();
			case ElementType.U8: return Int64Value.CreateUnknown();
			}
			return new UnknownValue();
		}

		static Value GetDefaultValue(TypeSig type) {
			if (type == null)
				return new UnknownValue();
			switch (type.ElementType) {
			case ElementType.Boolean:
			case ElementType.I1:
			case ElementType.U1:
			case ElementType.I2:
			case ElementType.U2:
			case ElementType.I4:
			case ElementType.U4:
				return Int32Value.Zero;
			case ElementType.I8:
			case ElementType.U8:
				return Int64Value.Zero;
			}
			return new UnknownValue();
		}

		Value TruncateValue(Value value, TypeSig type) {
			if (type == null)
				return value;
			if (protectedStackValues.ContainsKey(value))
				return value;

			switch (type.ElementType) {
			case ElementType.Boolean:
				if (value.IsInt32())
					return ((Int32Value)value).ToBoolean();
				return Int32Value.CreateUnknownBool();

			case ElementType.I1:
				if (value.IsInt32())
					return ((Int32Value)value).ToInt8();
				return Int32Value.CreateUnknown();

			case ElementType.U1:
				if (value.IsInt32())
					return ((Int32Value)value).ToUInt8();
				return Int32Value.CreateUnknownUInt8();

			case ElementType.I2:
				if (value.IsInt32())
					return ((Int32Value)value).ToInt16();
				return Int32Value.CreateUnknown();

			case ElementType.U2:
				if (value.IsInt32())
					return ((Int32Value)value).ToUInt16();
				return Int32Value.CreateUnknownUInt16();

			case ElementType.I4:
			case ElementType.U4:
				if (value.IsInt32())
					return value;
				return Int32Value.CreateUnknown();

			case ElementType.I8:
			case ElementType.U8:
				if (value.IsInt64())
					return value;
				return Int64Value.CreateUnknown();

			case ElementType.R4:
				if (value.IsReal8())
					return ((Real8Value)value).ToSingle();
				return new UnknownValue();

			case ElementType.R8:
				if (value.IsReal8())
					return value;
				return new UnknownValue();
			}
			return value;
		}

		static Value GetValue(List<Value> list, int i) {
			if (0 <= i && i < list.Count)
				return list[i];
			return new UnknownValue();
		}

		public Value GetArg(int i) => GetValue(args, i);

		public Value GetArg(Parameter arg) {
			if (arg == null)
				return new UnknownValue();
			return GetArg(arg.Index);
		}

		TypeSig GetArgType(int index) {
			if (0 <= index && index < parameterDefs.Count)
				return parameterDefs[index].Type;
			return null;
		}

		public void SetArg(Parameter arg, Value value) {
			if (arg != null)
				SetArg(arg.Index, value);
		}

		public void MakeArgUnknown(Parameter arg) {
			if (arg != null)
				SetArg(arg, GetUnknownArg(arg.Index));
		}

		void SetArg(int index, Value value) {
			if (0 <= index && index < args.Count)
				args[index] = TruncateValue(value, GetArgType(index));
		}

		Value GetUnknownArg(int index) => GetUnknownValue(GetArgType(index));
		public Value GetLocal(int i) => GetValue(locals, i);

		public Value GetLocal(Local local) {
			if (local == null)
				return new UnknownValue();
			return GetLocal(local.Index);
		}

		public void SetLocal(Local local, Value value) {
			if (local != null)
				SetLocal(local.Index, value);
		}

		public void MakeLocalUnknown(Local local) {
			if (local != null)
				SetLocal(local.Index, GetUnknownLocal(local.Index));
		}

		void SetLocal(int index, Value value) {
			if (0 <= index && index < locals.Count)
				locals[index] = TruncateValue(value, localDefs[index].Type);
		}

		Value GetUnknownLocal(int index) {
			if (0 <= index && index < localDefs.Count)
				return GetUnknownValue(localDefs[index].Type);
			return new UnknownValue();
		}

		public int StackSize() => valueStack.Size;
		public void Push(Value value) => valueStack.Push(value);
		public void ClearStack() => valueStack.Clear();

		public void Pop(int num) {
			if (num < 0)
				valueStack.Clear();
			else
				valueStack.Pop(num);
		}

		public Value Pop() => valueStack.Pop();
		public Value Peek() => valueStack.Peek();

		public void Emulate(IEnumerable<Instr> instructions) {
			foreach (var instr in instructions)
				Emulate(instr.Instruction);
		}

		public void Emulate(IList<Instr> instructions, int start, int end) {
			for (int i = start; i < end; i++)
				Emulate(instructions[i].Instruction);
		}

		public void Emulate(Instruction instr) {
			switch (instr.OpCode.Code) {
			case Code.Starg:
			case Code.Starg_S:	Emulate_Starg((Parameter)instr.Operand); break;
			case Code.Stloc:
			case Code.Stloc_S:	Emulate_Stloc((Local)instr.Operand); break;
			case Code.Stloc_0:	Emulate_Stloc(0); break;
			case Code.Stloc_1:	Emulate_Stloc(1); break;
			case Code.Stloc_2:	Emulate_Stloc(2); break;
			case Code.Stloc_3:	Emulate_Stloc(3); break;

			case Code.Ldarg:
			case Code.Ldarg_S:	valueStack.Push(GetArg((Parameter)instr.Operand)); break;
			case Code.Ldarg_0:	valueStack.Push(GetArg(0)); break;
			case Code.Ldarg_1:	valueStack.Push(GetArg(1)); break;
			case Code.Ldarg_2:	valueStack.Push(GetArg(2)); break;
			case Code.Ldarg_3:	valueStack.Push(GetArg(3)); break;
			case Code.Ldloc:
			case Code.Ldloc_S:	valueStack.Push(GetLocal((Local)instr.Operand)); break;
			case Code.Ldloc_0:	valueStack.Push(GetLocal(0)); break;
			case Code.Ldloc_1:	valueStack.Push(GetLocal(1)); break;
			case Code.Ldloc_2:	valueStack.Push(GetLocal(2)); break;
			case Code.Ldloc_3:	valueStack.Push(GetLocal(3)); break;

			case Code.Ldarga:
			case Code.Ldarga_S:	Emulate_Ldarga((Parameter)instr.Operand); break;
			case Code.Ldloca:
			case Code.Ldloca_S:	Emulate_Ldloca((Local)instr.Operand); break;

			case Code.Dup:		valueStack.CopyTop(); break;

			case Code.Ldc_I4:	valueStack.Push(new Int32Value((int)instr.Operand)); break;
			case Code.Ldc_I4_S:	valueStack.Push(new Int32Value((sbyte)instr.Operand)); break;
			case Code.Ldc_I8:	valueStack.Push(new Int64Value((long)instr.Operand)); break;
			case Code.Ldc_R4:	valueStack.Push(new Real8Value((float)instr.Operand)); break;
			case Code.Ldc_R8:	valueStack.Push(new Real8Value((double)instr.Operand)); break;
			case Code.Ldc_I4_0:	valueStack.Push(Int32Value.Zero); break;
			case Code.Ldc_I4_1:	valueStack.Push(Int32Value.One); break;
			case Code.Ldc_I4_2:	valueStack.Push(new Int32Value(2)); break;
			case Code.Ldc_I4_3:	valueStack.Push(new Int32Value(3)); break;
			case Code.Ldc_I4_4:	valueStack.Push(new Int32Value(4)); break;
			case Code.Ldc_I4_5:	valueStack.Push(new Int32Value(5)); break;
			case Code.Ldc_I4_6:	valueStack.Push(new Int32Value(6)); break;
			case Code.Ldc_I4_7:	valueStack.Push(new Int32Value(7)); break;
			case Code.Ldc_I4_8:	valueStack.Push(new Int32Value(8)); break;
			case Code.Ldc_I4_M1:valueStack.Push(new Int32Value(-1)); break;
			case Code.Ldnull:	valueStack.Push(NullValue.Instance); break;
			case Code.Ldstr:	valueStack.Push(new StringValue((string)instr.Operand)); break;
			case Code.Box:		valueStack.Push(new BoxedValue(valueStack.Pop())); break;

			case Code.Conv_U1:	Emulate_Conv_U1(instr); break;
			case Code.Conv_U2:	Emulate_Conv_U2(instr); break;
			case Code.Conv_U4:	Emulate_Conv_U4(instr); break;
			case Code.Conv_U8:	Emulate_Conv_U8(instr); break;
			case Code.Conv_I1:	Emulate_Conv_I1(instr); break;
			case Code.Conv_I2:	Emulate_Conv_I2(instr); break;
			case Code.Conv_I4:	Emulate_Conv_I4(instr); break;
			case Code.Conv_I8:	Emulate_Conv_I8(instr); break;
			case Code.Add:		Emulate_Add(instr); break;
			case Code.Sub:		Emulate_Sub(instr); break;
			case Code.Mul:		Emulate_Mul(instr); break;
			case Code.Div:		Emulate_Div(instr); break;
			case Code.Div_Un:	Emulate_Div_Un(instr); break;
			case Code.Rem:		Emulate_Rem(instr); break;
			case Code.Rem_Un:	Emulate_Rem_Un(instr); break;
			case Code.Neg:		Emulate_Neg(instr); break;
			case Code.And:		Emulate_And(instr); break;
			case Code.Or:		Emulate_Or(instr); break;
			case Code.Xor:		Emulate_Xor(instr); break;
			case Code.Not:		Emulate_Not(instr); break;
			case Code.Shl:		Emulate_Shl(instr); break;
			case Code.Shr:		Emulate_Shr(instr); break;
			case Code.Shr_Un:	Emulate_Shr_Un(instr); break;
			case Code.Ceq:		Emulate_Ceq(instr); break;
			case Code.Cgt:		Emulate_Cgt(instr); break;
			case Code.Cgt_Un:	Emulate_Cgt_Un(instr); break;
			case Code.Clt:		Emulate_Clt(instr); break;
			case Code.Clt_Un:	Emulate_Clt_Un(instr); break;
			case Code.Unbox_Any:Emulate_Unbox_Any(instr); break;

			case Code.Call:		Emulate_Call(instr); break;
			case Code.Callvirt:	Emulate_Callvirt(instr); break;

			case Code.Castclass: Emulate_Castclass(instr); break;
			case Code.Isinst:	Emulate_Isinst(instr); break;

			case Code.Add_Ovf:	Emulate_Add_Ovf(instr); break;
			case Code.Add_Ovf_Un: Emulate_Add_Ovf_Un(instr); break;
			case Code.Sub_Ovf:	Emulate_Sub_Ovf(instr); break;
			case Code.Sub_Ovf_Un: Emulate_Sub_Ovf_Un(instr); break;
			case Code.Mul_Ovf:	Emulate_Mul_Ovf(instr); break;
			case Code.Mul_Ovf_Un: Emulate_Mul_Ovf_Un(instr); break;

			case Code.Conv_Ovf_I1:		Emulate_Conv_Ovf_I1(instr); break;
			case Code.Conv_Ovf_I1_Un:	Emulate_Conv_Ovf_I1_Un(instr); break;
			case Code.Conv_Ovf_I2:		Emulate_Conv_Ovf_I2(instr); break;
			case Code.Conv_Ovf_I2_Un:	Emulate_Conv_Ovf_I2_Un(instr); break;
			case Code.Conv_Ovf_I4:		Emulate_Conv_Ovf_I4(instr); break;
			case Code.Conv_Ovf_I4_Un:	Emulate_Conv_Ovf_I4_Un(instr); break;
			case Code.Conv_Ovf_I8:		Emulate_Conv_Ovf_I8(instr); break;
			case Code.Conv_Ovf_I8_Un:	Emulate_Conv_Ovf_I8_Un(instr); break;
			case Code.Conv_Ovf_U1:		Emulate_Conv_Ovf_U1(instr); break;
			case Code.Conv_Ovf_U1_Un:	Emulate_Conv_Ovf_U1_Un(instr); break;
			case Code.Conv_Ovf_U2:		Emulate_Conv_Ovf_U2(instr); break;
			case Code.Conv_Ovf_U2_Un:	Emulate_Conv_Ovf_U2_Un(instr); break;
			case Code.Conv_Ovf_U4:		Emulate_Conv_Ovf_U4(instr); break;
			case Code.Conv_Ovf_U4_Un:	Emulate_Conv_Ovf_U4_Un(instr); break;
			case Code.Conv_Ovf_U8:		Emulate_Conv_Ovf_U8(instr); break;
			case Code.Conv_Ovf_U8_Un:	Emulate_Conv_Ovf_U8_Un(instr); break;

			case Code.Ldelem_I1: valueStack.Pop(2); valueStack.Push(Int32Value.CreateUnknown()); break;
			case Code.Ldelem_I2: valueStack.Pop(2); valueStack.Push(Int32Value.CreateUnknown()); break;
			case Code.Ldelem_I4: valueStack.Pop(2); valueStack.Push(Int32Value.CreateUnknown()); break;
			case Code.Ldelem_I8: valueStack.Pop(2); valueStack.Push(Int64Value.CreateUnknown()); break;
			case Code.Ldelem_U1: valueStack.Pop(2); valueStack.Push(Int32Value.CreateUnknownUInt8()); break;
			case Code.Ldelem_U2: valueStack.Pop(2); valueStack.Push(Int32Value.CreateUnknownUInt16()); break;
			case Code.Ldelem_U4: valueStack.Pop(2); valueStack.Push(Int32Value.CreateUnknown()); break;
			case Code.Ldelem:	 valueStack.Pop(2); valueStack.Push(GetUnknownValue(instr.Operand as ITypeDefOrRef)); break;

			case Code.Ldind_I1:	valueStack.Pop(); valueStack.Push(Int32Value.CreateUnknown()); break;
			case Code.Ldind_I2:	valueStack.Pop(); valueStack.Push(Int32Value.CreateUnknown()); break;
			case Code.Ldind_I4:	valueStack.Pop(); valueStack.Push(Int32Value.CreateUnknown()); break;
			case Code.Ldind_I8:	valueStack.Pop(); valueStack.Push(Int64Value.CreateUnknown()); break;
			case Code.Ldind_U1:	valueStack.Pop(); valueStack.Push(Int32Value.CreateUnknownUInt8()); break;
			case Code.Ldind_U2:	valueStack.Pop(); valueStack.Push(Int32Value.CreateUnknownUInt16()); break;
			case Code.Ldind_U4:	valueStack.Pop(); valueStack.Push(Int32Value.CreateUnknown()); break;

			case Code.Ldlen:	valueStack.Pop(); valueStack.Push(Int32Value.CreateUnknown()); break;
			case Code.Sizeof:	valueStack.Push(Int32Value.CreateUnknown()); break;

			case Code.Ldfld:	Emulate_Ldfld(instr); break;
			case Code.Ldsfld:	Emulate_Ldsfld(instr); break;

			case Code.Ldftn:	valueStack.Push(new ObjectValue(instr.Operand)); break;
			case Code.Ldsflda:	valueStack.Push(new ObjectValue(instr.Operand)); break;
			case Code.Ldtoken:	valueStack.Push(new ObjectValue(instr.Operand)); break;
			case Code.Ldvirtftn:valueStack.Pop(); valueStack.Push(new ObjectValue()); break;
			case Code.Ldflda:	valueStack.Pop(); valueStack.Push(new ObjectValue()); break;

			case Code.Unbox:

			case Code.Conv_R_Un:Emulate_Conv_R_Un(instr); break;
			case Code.Conv_R4:	Emulate_Conv_R4(instr); break;
			case Code.Conv_R8:	Emulate_Conv_R8(instr); break;

			case Code.Arglist:
			case Code.Beq:
			case Code.Beq_S:
			case Code.Bge:
			case Code.Bge_S:
			case Code.Bge_Un:
			case Code.Bge_Un_S:
			case Code.Bgt:
			case Code.Bgt_S:
			case Code.Bgt_Un:
			case Code.Bgt_Un_S:
			case Code.Ble:
			case Code.Ble_S:
			case Code.Ble_Un:
			case Code.Ble_Un_S:
			case Code.Blt:
			case Code.Blt_S:
			case Code.Blt_Un:
			case Code.Blt_Un_S:
			case Code.Bne_Un:
			case Code.Bne_Un_S:
			case Code.Brfalse:
			case Code.Brfalse_S:
			case Code.Brtrue:
			case Code.Brtrue_S:
			case Code.Br:
			case Code.Br_S:
			case Code.Break:
			case Code.Calli:
			case Code.Ckfinite:
			case Code.Constrained:
			case Code.Conv_I:
			case Code.Conv_Ovf_I:
			case Code.Conv_Ovf_I_Un:
			case Code.Conv_Ovf_U:
			case Code.Conv_Ovf_U_Un:
			case Code.Conv_U:
			case Code.Cpblk:
			case Code.Cpobj:
			case Code.Endfilter:
			case Code.Endfinally:
			case Code.Initblk:
			case Code.Initobj:
			case Code.Jmp:
			case Code.Ldelema:
			case Code.Ldelem_I:
			case Code.Ldelem_R4:
			case Code.Ldelem_R8:
			case Code.Ldelem_Ref:
			case Code.Ldind_I:
			case Code.Ldind_R4:
			case Code.Ldind_R8:
			case Code.Ldind_Ref:
			case Code.Ldobj:
			case Code.Leave:
			case Code.Leave_S:
			case Code.Localloc:
			case Code.Mkrefany:
			case Code.Newarr:
			case Code.Newobj:
			case Code.Nop:
			case Code.Pop:
			case Code.Readonly:
			case Code.Refanytype:
			case Code.Refanyval:
			case Code.Ret:
			case Code.Rethrow:
			case Code.Stelem:
			case Code.Stelem_I:
			case Code.Stelem_I1:
			case Code.Stelem_I2:
			case Code.Stelem_I4:
			case Code.Stelem_I8:
			case Code.Stelem_R4:
			case Code.Stelem_R8:
			case Code.Stelem_Ref:
			case Code.Stfld:
			case Code.Stind_I:
			case Code.Stind_I1:
			case Code.Stind_I2:
			case Code.Stind_I4:
			case Code.Stind_I8:
			case Code.Stind_R4:
			case Code.Stind_R8:
			case Code.Stind_Ref:
			case Code.Stobj:
			case Code.Stsfld:
			case Code.Switch:
			case Code.Tailcall:
			case Code.Throw:
			case Code.Unaligned:
			case Code.Volatile:
			default:
				UpdateStack(instr);
				break;
			}
		}

		void UpdateStack(Instruction instr) {
			instr.CalculateStackUsage(out int pushes, out int pops);
			if (pops == -1)
				valueStack.Clear();
			else {
				valueStack.Pop(pops);
				valueStack.Push(pushes);
			}
		}

		void Emulate_Conv_U1(Instruction instr) {
			var val1 = valueStack.Pop();
			switch (val1.valueType) {
			case ValueType.Int32:	valueStack.Push(Int32Value.Conv_U1((Int32Value)val1)); break;
			case ValueType.Int64:	valueStack.Push(Int32Value.Conv_U1((Int64Value)val1)); break;
			case ValueType.Real8:	valueStack.Push(Int32Value.Conv_U1((Real8Value)val1)); break;
			default:				valueStack.Push(Int32Value.CreateUnknownUInt8()); break;
			}
		}

		void Emulate_Conv_I1(Instruction instr) {
			var val1 = valueStack.Pop();
			switch (val1.valueType) {
			case ValueType.Int32:	valueStack.Push(Int32Value.Conv_I1((Int32Value)val1)); break;
			case ValueType.Int64:	valueStack.Push(Int32Value.Conv_I1((Int64Value)val1)); break;
			case ValueType.Real8:	valueStack.Push(Int32Value.Conv_I1((Real8Value)val1)); break;
			default:				valueStack.Push(Int32Value.CreateUnknown()); break;
			}
		}

		void Emulate_Conv_U2(Instruction instr) {
			var val1 = valueStack.Pop();
			switch (val1.valueType) {
			case ValueType.Int32:	valueStack.Push(Int32Value.Conv_U2((Int32Value)val1)); break;
			case ValueType.Int64:	valueStack.Push(Int32Value.Conv_U2((Int64Value)val1)); break;
			case ValueType.Real8:	valueStack.Push(Int32Value.Conv_U2((Real8Value)val1)); break;
			default:				valueStack.Push(Int32Value.CreateUnknownUInt16()); break;
			}
		}

		void Emulate_Conv_I2(Instruction instr) {
			var val1 = valueStack.Pop();
			switch (val1.valueType) {
			case ValueType.Int32:	valueStack.Push(Int32Value.Conv_I2((Int32Value)val1)); break;
			case ValueType.Int64:	valueStack.Push(Int32Value.Conv_I2((Int64Value)val1)); break;
			case ValueType.Real8:	valueStack.Push(Int32Value.Conv_I2((Real8Value)val1)); break;
			default:				valueStack.Push(Int32Value.CreateUnknown()); break;
			}
		}

		void Emulate_Conv_U4(Instruction instr) {
			var val1 = valueStack.Pop();
			switch (val1.valueType) {
			case ValueType.Int32:	valueStack.Push(Int32Value.Conv_U4((Int32Value)val1)); break;
			case ValueType.Int64:	valueStack.Push(Int32Value.Conv_U4((Int64Value)val1)); break;
			case ValueType.Real8:	valueStack.Push(Int32Value.Conv_U4((Real8Value)val1)); break;
			default:				valueStack.Push(Int32Value.CreateUnknown()); break;
			}
		}

		void Emulate_Conv_I4(Instruction instr) {
			var val1 = valueStack.Pop();
			switch (val1.valueType) {
			case ValueType.Int32:	valueStack.Push(Int32Value.Conv_I4((Int32Value)val1)); break;
			case ValueType.Int64:	valueStack.Push(Int32Value.Conv_I4((Int64Value)val1)); break;
			case ValueType.Real8:	valueStack.Push(Int32Value.Conv_I4((Real8Value)val1)); break;
			default:				valueStack.Push(Int32Value.CreateUnknown()); break;
			}
		}

		void Emulate_Conv_U8(Instruction instr) {
			var val1 = valueStack.Pop();
			switch (val1.valueType) {
			case ValueType.Int32:	valueStack.Push(Int64Value.Conv_U8((Int32Value)val1)); break;
			case ValueType.Int64:	valueStack.Push(Int64Value.Conv_U8((Int64Value)val1)); break;
			case ValueType.Real8:	valueStack.Push(Int64Value.Conv_U8((Real8Value)val1)); break;
			default:				valueStack.Push(Int64Value.CreateUnknown()); break;
			}
		}

		void Emulate_Conv_I8(Instruction instr) {
			var val1 = valueStack.Pop();
			switch (val1.valueType) {
			case ValueType.Int32:	valueStack.Push(Int64Value.Conv_I8((Int32Value)val1)); break;
			case ValueType.Int64:	valueStack.Push(Int64Value.Conv_I8((Int64Value)val1)); break;
			case ValueType.Real8:	valueStack.Push(Int64Value.Conv_I8((Real8Value)val1)); break;
			default:				valueStack.Push(Int64Value.CreateUnknown()); break;
			}
		}

		void Emulate_Conv_Ovf_I1(Instruction instr) {
			var val1 = valueStack.Pop();
			switch (val1.valueType) {
			case ValueType.Int32:	valueStack.Push(Int32Value.Conv_Ovf_I1((Int32Value)val1)); break;
			case ValueType.Int64:	valueStack.Push(Int64Value.Conv_Ovf_I1((Int64Value)val1)); break;
			case ValueType.Real8:	valueStack.Push(Real8Value.Conv_Ovf_I1((Real8Value)val1)); break;
			default:				valueStack.Push(Int32Value.CreateUnknown()); break;
			}
		}

		void Emulate_Conv_Ovf_I1_Un(Instruction instr) {
			var val1 = valueStack.Pop();
			switch (val1.valueType) {
			case ValueType.Int32:	valueStack.Push(Int32Value.Conv_Ovf_I1_Un((Int32Value)val1)); break;
			case ValueType.Int64:	valueStack.Push(Int64Value.Conv_Ovf_I1_Un((Int64Value)val1)); break;
			case ValueType.Real8:	valueStack.Push(Real8Value.Conv_Ovf_I1_Un((Real8Value)val1)); break;
			default:				valueStack.Push(Int32Value.CreateUnknown()); break;
			}
		}

		void Emulate_Conv_Ovf_I2(Instruction instr) {
			var val1 = valueStack.Pop();
			switch (val1.valueType) {
			case ValueType.Int32:	valueStack.Push(Int32Value.Conv_Ovf_I2((Int32Value)val1)); break;
			case ValueType.Int64:	valueStack.Push(Int64Value.Conv_Ovf_I2((Int64Value)val1)); break;
			case ValueType.Real8:	valueStack.Push(Real8Value.Conv_Ovf_I2((Real8Value)val1)); break;
			default:				valueStack.Push(Int32Value.CreateUnknown()); break;
			}
		}

		void Emulate_Conv_Ovf_I2_Un(Instruction instr) {
			var val1 = valueStack.Pop();
			switch (val1.valueType) {
			case ValueType.Int32:	valueStack.Push(Int32Value.Conv_Ovf_I2_Un((Int32Value)val1)); break;
			case ValueType.Int64:	valueStack.Push(Int64Value.Conv_Ovf_I2_Un((Int64Value)val1)); break;
			case ValueType.Real8:	valueStack.Push(Real8Value.Conv_Ovf_I2_Un((Real8Value)val1)); break;
			default:				valueStack.Push(Int32Value.CreateUnknown()); break;
			}
		}

		void Emulate_Conv_Ovf_I4(Instruction instr) {
			var val1 = valueStack.Pop();
			switch (val1.valueType) {
			case ValueType.Int32:	valueStack.Push(Int32Value.Conv_Ovf_I4((Int32Value)val1)); break;
			case ValueType.Int64:	valueStack.Push(Int64Value.Conv_Ovf_I4((Int64Value)val1)); break;
			case ValueType.Real8:	valueStack.Push(Real8Value.Conv_Ovf_I4((Real8Value)val1)); break;
			default:				valueStack.Push(Int32Value.CreateUnknown()); break;
			}
		}

		void Emulate_Conv_Ovf_I4_Un(Instruction instr) {
			var val1 = valueStack.Pop();
			switch (val1.valueType) {
			case ValueType.Int32:	valueStack.Push(Int32Value.Conv_Ovf_I4_Un((Int32Value)val1)); break;
			case ValueType.Int64:	valueStack.Push(Int64Value.Conv_Ovf_I4_Un((Int64Value)val1)); break;
			case ValueType.Real8:	valueStack.Push(Real8Value.Conv_Ovf_I4_Un((Real8Value)val1)); break;
			default:				valueStack.Push(Int32Value.CreateUnknown()); break;
			}
		}

		void Emulate_Conv_Ovf_I8(Instruction instr) {
			var val1 = valueStack.Pop();
			switch (val1.valueType) {
			case ValueType.Int32:	valueStack.Push(Int32Value.Conv_Ovf_I8((Int32Value)val1)); break;
			case ValueType.Int64:	valueStack.Push(Int64Value.Conv_Ovf_I8((Int64Value)val1)); break;
			case ValueType.Real8:	valueStack.Push(Real8Value.Conv_Ovf_I8((Real8Value)val1)); break;
			default:				valueStack.Push(Int64Value.CreateUnknown()); break;
			}
		}

		void Emulate_Conv_Ovf_I8_Un(Instruction instr) {
			var val1 = valueStack.Pop();
			switch (val1.valueType) {
			case ValueType.Int32:	valueStack.Push(Int32Value.Conv_Ovf_I8_Un((Int32Value)val1)); break;
			case ValueType.Int64:	valueStack.Push(Int64Value.Conv_Ovf_I8_Un((Int64Value)val1)); break;
			case ValueType.Real8:	valueStack.Push(Real8Value.Conv_Ovf_I8_Un((Real8Value)val1)); break;
			default:				valueStack.Push(Int64Value.CreateUnknown()); break;
			}
		}

		void Emulate_Conv_Ovf_U1(Instruction instr) {
			var val1 = valueStack.Pop();
			switch (val1.valueType) {
			case ValueType.Int32:	valueStack.Push(Int32Value.Conv_Ovf_U1((Int32Value)val1)); break;
			case ValueType.Int64:	valueStack.Push(Int64Value.Conv_Ovf_U1((Int64Value)val1)); break;
			case ValueType.Real8:	valueStack.Push(Real8Value.Conv_Ovf_U1((Real8Value)val1)); break;
			default:				valueStack.Push(Int32Value.CreateUnknownUInt8()); break;
			}
		}

		void Emulate_Conv_Ovf_U1_Un(Instruction instr) {
			var val1 = valueStack.Pop();
			switch (val1.valueType) {
			case ValueType.Int32:	valueStack.Push(Int32Value.Conv_Ovf_U1_Un((Int32Value)val1)); break;
			case ValueType.Int64:	valueStack.Push(Int64Value.Conv_Ovf_U1_Un((Int64Value)val1)); break;
			case ValueType.Real8:	valueStack.Push(Real8Value.Conv_Ovf_U1_Un((Real8Value)val1)); break;
			default:				valueStack.Push(Int32Value.CreateUnknownUInt8()); break;
			}
		}

		void Emulate_Conv_Ovf_U2(Instruction instr) {
			var val1 = valueStack.Pop();
			switch (val1.valueType) {
			case ValueType.Int32:	valueStack.Push(Int32Value.Conv_Ovf_U2((Int32Value)val1)); break;
			case ValueType.Int64:	valueStack.Push(Int64Value.Conv_Ovf_U2((Int64Value)val1)); break;
			case ValueType.Real8:	valueStack.Push(Real8Value.Conv_Ovf_U2((Real8Value)val1)); break;
			default:				valueStack.Push(Int32Value.CreateUnknownUInt16()); break;
			}
		}

		void Emulate_Conv_Ovf_U2_Un(Instruction instr) {
			var val1 = valueStack.Pop();
			switch (val1.valueType) {
			case ValueType.Int32:	valueStack.Push(Int32Value.Conv_Ovf_U2_Un((Int32Value)val1)); break;
			case ValueType.Int64:	valueStack.Push(Int64Value.Conv_Ovf_U2_Un((Int64Value)val1)); break;
			case ValueType.Real8:	valueStack.Push(Real8Value.Conv_Ovf_U2_Un((Real8Value)val1)); break;
			default:				valueStack.Push(Int32Value.CreateUnknownUInt16()); break;
			}
		}

		void Emulate_Conv_Ovf_U4(Instruction instr) {
			var val1 = valueStack.Pop();
			switch (val1.valueType) {
			case ValueType.Int32:	valueStack.Push(Int32Value.Conv_Ovf_U4((Int32Value)val1)); break;
			case ValueType.Int64:	valueStack.Push(Int64Value.Conv_Ovf_U4((Int64Value)val1)); break;
			case ValueType.Real8:	valueStack.Push(Real8Value.Conv_Ovf_U4((Real8Value)val1)); break;
			default:				valueStack.Push(Int32Value.CreateUnknown()); break;
			}
		}

		void Emulate_Conv_Ovf_U4_Un(Instruction instr) {
			var val1 = valueStack.Pop();
			switch (val1.valueType) {
			case ValueType.Int32:	valueStack.Push(Int32Value.Conv_Ovf_U4_Un((Int32Value)val1)); break;
			case ValueType.Int64:	valueStack.Push(Int64Value.Conv_Ovf_U4_Un((Int64Value)val1)); break;
			case ValueType.Real8:	valueStack.Push(Real8Value.Conv_Ovf_U4_Un((Real8Value)val1)); break;
			default:				valueStack.Push(Int32Value.CreateUnknown()); break;
			}
		}

		void Emulate_Conv_Ovf_U8(Instruction instr) {
			var val1 = valueStack.Pop();
			switch (val1.valueType) {
			case ValueType.Int32:	valueStack.Push(Int32Value.Conv_Ovf_U8((Int32Value)val1)); break;
			case ValueType.Int64:	valueStack.Push(Int64Value.Conv_Ovf_U8((Int64Value)val1)); break;
			case ValueType.Real8:	valueStack.Push(Real8Value.Conv_Ovf_U8((Real8Value)val1)); break;
			default:				valueStack.Push(Int64Value.CreateUnknown()); break;
			}
		}

		void Emulate_Conv_Ovf_U8_Un(Instruction instr) {
			var val1 = valueStack.Pop();
			switch (val1.valueType) {
			case ValueType.Int32:	valueStack.Push(Int32Value.Conv_Ovf_U8_Un((Int32Value)val1)); break;
			case ValueType.Int64:	valueStack.Push(Int64Value.Conv_Ovf_U8_Un((Int64Value)val1)); break;
			case ValueType.Real8:	valueStack.Push(Real8Value.Conv_Ovf_U8_Un((Real8Value)val1)); break;
			default:				valueStack.Push(Int64Value.CreateUnknown()); break;
			}
		}

		void Emulate_Conv_R_Un(Instruction instr) {
			var val1 = valueStack.Pop();
			switch (val1.valueType) {
			case ValueType.Int32:	valueStack.Push(Int32Value.Conv_R_Un((Int32Value)val1)); break;
			case ValueType.Int64:	valueStack.Push(Int64Value.Conv_R_Un((Int64Value)val1)); break;
			case ValueType.Real8:	valueStack.Push(Real8Value.Conv_R_Un((Real8Value)val1)); break;
			default:				valueStack.Push(Real8Value.CreateUnknown()); break;
			}
		}

		void Emulate_Conv_R4(Instruction instr) {
			var val1 = valueStack.Pop();
			switch (val1.valueType) {
			case ValueType.Int32:	valueStack.Push(Int32Value.Conv_R4((Int32Value)val1)); break;
			case ValueType.Int64:	valueStack.Push(Int64Value.Conv_R4((Int64Value)val1)); break;
			case ValueType.Real8:	valueStack.Push(Real8Value.Conv_R4((Real8Value)val1)); break;
			default:				valueStack.Push(Real8Value.CreateUnknown()); break;
			}
		}

		void Emulate_Conv_R8(Instruction instr) {
			var val1 = valueStack.Pop();
			switch (val1.valueType) {
			case ValueType.Int32:	valueStack.Push(Int32Value.Conv_R8((Int32Value)val1)); break;
			case ValueType.Int64:	valueStack.Push(Int64Value.Conv_R8((Int64Value)val1)); break;
			case ValueType.Real8:	valueStack.Push(Real8Value.Conv_R8((Real8Value)val1)); break;
			default:				valueStack.Push(Real8Value.CreateUnknown()); break;
			}
		}

		void Emulate_Add(Instruction instr) {
			var val2 = valueStack.Pop();
			var val1 = valueStack.Pop();

			if (val1.IsInt32() && val2.IsInt32())
				valueStack.Push(Int32Value.Add((Int32Value)val1, (Int32Value)val2));
			else if (val1.IsInt64() && val2.IsInt64())
				valueStack.Push(Int64Value.Add((Int64Value)val1, (Int64Value)val2));
			else if (val1.IsReal8() && val2.IsReal8())
				valueStack.Push(Real8Value.Add((Real8Value)val1, (Real8Value)val2));
			else
				valueStack.PushUnknown();
		}

		void Emulate_Sub(Instruction instr) {
			var val2 = valueStack.Pop();
			var val1 = valueStack.Pop();

			if (val1.IsInt32() && val2.IsInt32())
				valueStack.Push(Int32Value.Sub((Int32Value)val1, (Int32Value)val2));
			else if (val1.IsInt64() && val2.IsInt64())
				valueStack.Push(Int64Value.Sub((Int64Value)val1, (Int64Value)val2));
			else if (val1.IsReal8() && val2.IsReal8())
				valueStack.Push(Real8Value.Sub((Real8Value)val1, (Real8Value)val2));
			else
				valueStack.PushUnknown();
		}

		void Emulate_Mul(Instruction instr) {
			var val2 = valueStack.Pop();
			var val1 = valueStack.Pop();

			if (val1.IsInt32() && val2.IsInt32())
				valueStack.Push(Int32Value.Mul((Int32Value)val1, (Int32Value)val2));
			else if (val1.IsInt64() && val2.IsInt64())
				valueStack.Push(Int64Value.Mul((Int64Value)val1, (Int64Value)val2));
			else if (val1.IsReal8() && val2.IsReal8())
				valueStack.Push(Real8Value.Mul((Real8Value)val1, (Real8Value)val2));
			else
				valueStack.PushUnknown();
		}

		void Emulate_Div(Instruction instr) {
			var val2 = valueStack.Pop();
			var val1 = valueStack.Pop();

			if (val1.IsInt32() && val2.IsInt32())
				valueStack.Push(Int32Value.Div((Int32Value)val1, (Int32Value)val2));
			else if (val1.IsInt64() && val2.IsInt64())
				valueStack.Push(Int64Value.Div((Int64Value)val1, (Int64Value)val2));
			else if (val1.IsReal8() && val2.IsReal8())
				valueStack.Push(Real8Value.Div((Real8Value)val1, (Real8Value)val2));
			else
				valueStack.PushUnknown();
		}

		void Emulate_Div_Un(Instruction instr) {
			var val2 = valueStack.Pop();
			var val1 = valueStack.Pop();

			if (val1.IsInt32() && val2.IsInt32())
				valueStack.Push(Int32Value.Div_Un((Int32Value)val1, (Int32Value)val2));
			else if (val1.IsInt64() && val2.IsInt64())
				valueStack.Push(Int64Value.Div_Un((Int64Value)val1, (Int64Value)val2));
			else
				valueStack.PushUnknown();
		}

		void Emulate_Rem(Instruction instr) {
			var val2 = valueStack.Pop();
			var val1 = valueStack.Pop();

			if (val1.IsInt32() && val2.IsInt32())
				valueStack.Push(Int32Value.Rem((Int32Value)val1, (Int32Value)val2));
			else if (val1.IsInt64() && val2.IsInt64())
				valueStack.Push(Int64Value.Rem((Int64Value)val1, (Int64Value)val2));
			else if (val1.IsReal8() && val2.IsReal8())
				valueStack.Push(Real8Value.Rem((Real8Value)val1, (Real8Value)val2));
			else
				valueStack.PushUnknown();
		}

		void Emulate_Rem_Un(Instruction instr) {
			var val2 = valueStack.Pop();
			var val1 = valueStack.Pop();

			if (val1.IsInt32() && val2.IsInt32())
				valueStack.Push(Int32Value.Rem_Un((Int32Value)val1, (Int32Value)val2));
			else if (val1.IsInt64() && val2.IsInt64())
				valueStack.Push(Int64Value.Rem_Un((Int64Value)val1, (Int64Value)val2));
			else
				valueStack.PushUnknown();
		}

		void Emulate_Neg(Instruction instr) {
			var val1 = valueStack.Pop();

			if (val1.IsInt32())
				valueStack.Push(Int32Value.Neg((Int32Value)val1));
			else if (val1.IsInt64())
				valueStack.Push(Int64Value.Neg((Int64Value)val1));
			else if (val1.IsReal8())
				valueStack.Push(Real8Value.Neg((Real8Value)val1));
			else
				valueStack.PushUnknown();
		}

		void Emulate_Add_Ovf(Instruction instr) {
			var val2 = valueStack.Pop();
			var val1 = valueStack.Pop();

			if (val1.IsInt32() && val2.IsInt32())
				valueStack.Push(Int32Value.Add_Ovf((Int32Value)val1, (Int32Value)val2));
			else if (val1.IsInt64() && val2.IsInt64())
				valueStack.Push(Int64Value.Add_Ovf((Int64Value)val1, (Int64Value)val2));
			else if (val1.IsReal8() && val2.IsReal8())
				valueStack.Push(Real8Value.Add_Ovf((Real8Value)val1, (Real8Value)val2));
			else
				valueStack.PushUnknown();
		}

		void Emulate_Add_Ovf_Un(Instruction instr) {
			var val2 = valueStack.Pop();
			var val1 = valueStack.Pop();

			if (val1.IsInt32() && val2.IsInt32())
				valueStack.Push(Int32Value.Add_Ovf_Un((Int32Value)val1, (Int32Value)val2));
			else if (val1.IsInt64() && val2.IsInt64())
				valueStack.Push(Int64Value.Add_Ovf_Un((Int64Value)val1, (Int64Value)val2));
			else if (val1.IsReal8() && val2.IsReal8())
				valueStack.Push(Real8Value.Add_Ovf_Un((Real8Value)val1, (Real8Value)val2));
			else
				valueStack.PushUnknown();
		}

		void Emulate_Sub_Ovf(Instruction instr) {
			var val2 = valueStack.Pop();
			var val1 = valueStack.Pop();

			if (val1.IsInt32() && val2.IsInt32())
				valueStack.Push(Int32Value.Sub_Ovf((Int32Value)val1, (Int32Value)val2));
			else if (val1.IsInt64() && val2.IsInt64())
				valueStack.Push(Int64Value.Sub_Ovf((Int64Value)val1, (Int64Value)val2));
			else if (val1.IsReal8() && val2.IsReal8())
				valueStack.Push(Real8Value.Sub_Ovf((Real8Value)val1, (Real8Value)val2));
			else
				valueStack.PushUnknown();
		}

		void Emulate_Sub_Ovf_Un(Instruction instr) {
			var val2 = valueStack.Pop();
			var val1 = valueStack.Pop();

			if (val1.IsInt32() && val2.IsInt32())
				valueStack.Push(Int32Value.Sub_Ovf_Un((Int32Value)val1, (Int32Value)val2));
			else if (val1.IsInt64() && val2.IsInt64())
				valueStack.Push(Int64Value.Sub_Ovf_Un((Int64Value)val1, (Int64Value)val2));
			else if (val1.IsReal8() && val2.IsReal8())
				valueStack.Push(Real8Value.Sub_Ovf_Un((Real8Value)val1, (Real8Value)val2));
			else
				valueStack.PushUnknown();
		}

		void Emulate_Mul_Ovf(Instruction instr) {
			var val2 = valueStack.Pop();
			var val1 = valueStack.Pop();

			if (val1.IsInt32() && val2.IsInt32())
				valueStack.Push(Int32Value.Mul_Ovf((Int32Value)val1, (Int32Value)val2));
			else if (val1.IsInt64() && val2.IsInt64())
				valueStack.Push(Int64Value.Mul_Ovf((Int64Value)val1, (Int64Value)val2));
			else if (val1.IsReal8() && val2.IsReal8())
				valueStack.Push(Real8Value.Mul_Ovf((Real8Value)val1, (Real8Value)val2));
			else
				valueStack.PushUnknown();
		}

		void Emulate_Mul_Ovf_Un(Instruction instr) {
			var val2 = valueStack.Pop();
			var val1 = valueStack.Pop();

			if (val1.IsInt32() && val2.IsInt32())
				valueStack.Push(Int32Value.Mul_Ovf_Un((Int32Value)val1, (Int32Value)val2));
			else if (val1.IsInt64() && val2.IsInt64())
				valueStack.Push(Int64Value.Mul_Ovf_Un((Int64Value)val1, (Int64Value)val2));
			else if (val1.IsReal8() && val2.IsReal8())
				valueStack.Push(Real8Value.Mul_Ovf_Un((Real8Value)val1, (Real8Value)val2));
			else
				valueStack.PushUnknown();
		}

		void Emulate_And(Instruction instr) {
			var val2 = valueStack.Pop();
			var val1 = valueStack.Pop();

			if (val1.IsInt32() && val2.IsInt32())
				valueStack.Push(Int32Value.And((Int32Value)val1, (Int32Value)val2));
			else if (val1.IsInt64() && val2.IsInt64())
				valueStack.Push(Int64Value.And((Int64Value)val1, (Int64Value)val2));
			else
				valueStack.PushUnknown();
		}

		void Emulate_Or(Instruction instr) {
			var val2 = valueStack.Pop();
			var val1 = valueStack.Pop();

			if (val1.IsInt32() && val2.IsInt32())
				valueStack.Push(Int32Value.Or((Int32Value)val1, (Int32Value)val2));
			else if (val1.IsInt64() && val2.IsInt64())
				valueStack.Push(Int64Value.Or((Int64Value)val1, (Int64Value)val2));
			else
				valueStack.PushUnknown();
		}

		void Emulate_Xor(Instruction instr) {
			var val2 = valueStack.Pop();
			var val1 = valueStack.Pop();

			if (val1.IsInt32() && val2.IsInt32())
				valueStack.Push(Int32Value.Xor((Int32Value)val1, (Int32Value)val2));
			else if (val1.IsInt64() && val2.IsInt64())
				valueStack.Push(Int64Value.Xor((Int64Value)val1, (Int64Value)val2));
			else
				valueStack.PushUnknown();
		}

		void Emulate_Not(Instruction instr) {
			var val1 = valueStack.Pop();

			if (val1.IsInt32())
				valueStack.Push(Int32Value.Not((Int32Value)val1));
			else if (val1.IsInt64())
				valueStack.Push(Int64Value.Not((Int64Value)val1));
			else
				valueStack.PushUnknown();
		}

		void Emulate_Shl(Instruction instr) {
			var val2 = valueStack.Pop();
			var val1 = valueStack.Pop();

			if (val1.IsInt32() && val2.IsInt32())
				valueStack.Push(Int32Value.Shl((Int32Value)val1, (Int32Value)val2));
			else if (val1.IsInt64() && val2.IsInt32())
				valueStack.Push(Int64Value.Shl((Int64Value)val1, (Int32Value)val2));
			else
				valueStack.PushUnknown();
		}

		void Emulate_Shr(Instruction instr) {
			var val2 = valueStack.Pop();
			var val1 = valueStack.Pop();

			if (val1.IsInt32() && val2.IsInt32())
				valueStack.Push(Int32Value.Shr((Int32Value)val1, (Int32Value)val2));
			else if (val1.IsInt64() && val2.IsInt32())
				valueStack.Push(Int64Value.Shr((Int64Value)val1, (Int32Value)val2));
			else
				valueStack.PushUnknown();
		}

		void Emulate_Shr_Un(Instruction instr) {
			var val2 = valueStack.Pop();
			var val1 = valueStack.Pop();

			if (val1.IsInt32() && val2.IsInt32())
				valueStack.Push(Int32Value.Shr_Un((Int32Value)val1, (Int32Value)val2));
			else if (val1.IsInt64() && val2.IsInt32())
				valueStack.Push(Int64Value.Shr_Un((Int64Value)val1, (Int32Value)val2));
			else
				valueStack.PushUnknown();
		}

		void Emulate_Ceq(Instruction instr) {
			var val2 = valueStack.Pop();
			var val1 = valueStack.Pop();

			if (val1.IsInt32() && val2.IsInt32())
				valueStack.Push(Int32Value.Ceq((Int32Value)val1, (Int32Value)val2));
			else if (val1.IsInt64() && val2.IsInt64())
				valueStack.Push(Int64Value.Ceq((Int64Value)val1, (Int64Value)val2));
			else if (val1.IsReal8() && val2.IsReal8())
				valueStack.Push(Real8Value.Ceq((Real8Value)val1, (Real8Value)val2));
			else if (val1.IsNull() && val2.IsNull())
				valueStack.Push(Int32Value.One);
			else
				valueStack.Push(Int32Value.CreateUnknownBool());
		}

		void Emulate_Cgt(Instruction instr) {
			var val2 = valueStack.Pop();
			var val1 = valueStack.Pop();

			if (val1.IsInt32() && val2.IsInt32())
				valueStack.Push(Int32Value.Cgt((Int32Value)val1, (Int32Value)val2));
			else if (val1.IsInt64() && val2.IsInt64())
				valueStack.Push(Int64Value.Cgt((Int64Value)val1, (Int64Value)val2));
			else if (val1.IsReal8() && val2.IsReal8())
				valueStack.Push(Real8Value.Cgt((Real8Value)val1, (Real8Value)val2));
			else
				valueStack.Push(Int32Value.CreateUnknownBool());
		}

		void Emulate_Cgt_Un(Instruction instr) {
			var val2 = valueStack.Pop();
			var val1 = valueStack.Pop();

			if (val1.IsInt32() && val2.IsInt32())
				valueStack.Push(Int32Value.Cgt_Un((Int32Value)val1, (Int32Value)val2));
			else if (val1.IsInt64() && val2.IsInt64())
				valueStack.Push(Int64Value.Cgt_Un((Int64Value)val1, (Int64Value)val2));
			else if (val1.IsReal8() && val2.IsReal8())
				valueStack.Push(Real8Value.Cgt_Un((Real8Value)val1, (Real8Value)val2));
			else
				valueStack.Push(Int32Value.CreateUnknownBool());
		}

		void Emulate_Clt(Instruction instr) {
			var val2 = valueStack.Pop();
			var val1 = valueStack.Pop();

			if (val1.IsInt32() && val2.IsInt32())
				valueStack.Push(Int32Value.Clt((Int32Value)val1, (Int32Value)val2));
			else if (val1.IsInt64() && val2.IsInt64())
				valueStack.Push(Int64Value.Clt((Int64Value)val1, (Int64Value)val2));
			else if (val1.IsReal8() && val2.IsReal8())
				valueStack.Push(Real8Value.Clt((Real8Value)val1, (Real8Value)val2));
			else
				valueStack.Push(Int32Value.CreateUnknownBool());
		}

		void Emulate_Clt_Un(Instruction instr) {
			var val2 = valueStack.Pop();
			var val1 = valueStack.Pop();

			if (val1.IsInt32() && val2.IsInt32())
				valueStack.Push(Int32Value.Clt_Un((Int32Value)val1, (Int32Value)val2));
			else if (val1.IsInt64() && val2.IsInt64())
				valueStack.Push(Int64Value.Clt_Un((Int64Value)val1, (Int64Value)val2));
			else if (val1.IsReal8() && val2.IsReal8())
				valueStack.Push(Real8Value.Clt_Un((Real8Value)val1, (Real8Value)val2));
			else
				valueStack.Push(Int32Value.CreateUnknownBool());
		}

		void Emulate_Unbox_Any(Instruction instr) {
			var val1 = valueStack.Pop();
			if (val1.IsBoxed())
				valueStack.Push(((BoxedValue)val1).value);
			else
				valueStack.PushUnknown();
		}

		void Emulate_Starg(Parameter arg) => SetArg(arg == null ? -1 : arg.Index, valueStack.Pop());
		void Emulate_Stloc(Local local) => Emulate_Stloc(local == null ? -1 : local.Index);
		void Emulate_Stloc(int index) => SetLocal(index, valueStack.Pop());

		void Emulate_Ldarga(Parameter arg) {
			valueStack.PushUnknown();
			MakeArgUnknown(arg);
		}

		void Emulate_Ldloca(Local local) => Emulate_Ldloca(local == null ? -1 : local.Index);

		void Emulate_Ldloca(int index) {
			valueStack.PushUnknown();
			SetLocal(index, GetUnknownLocal(index));
		}

		void Emulate_Call(Instruction instr) => Emulate_Call(instr, (IMethod)instr.Operand);
		void Emulate_Callvirt(Instruction instr) => Emulate_Call(instr, (IMethod)instr.Operand);

		void Emulate_Call(Instruction instr, IMethod method) {
			instr.CalculateStackUsage(out int pushes, out int pops);
			valueStack.Pop(pops);
			if (pushes == 1)
				valueStack.Push(GetUnknownValue(method.MethodSig.GetRetType()));
			else
				valueStack.Push(pushes);
		}

		void Emulate_Castclass(Instruction instr) {
			var val1 = valueStack.Pop();

			if (val1.IsNull())
				valueStack.Push(val1);
			else
				valueStack.PushUnknown();
		}

		void Emulate_Isinst(Instruction instr) {
			var val1 = valueStack.Pop();

			if (val1.IsNull())
				valueStack.Push(val1);
			else
				valueStack.PushUnknown();
		}

		void Emulate_Ldfld(Instruction instr) {
			/*var val1 =*/ valueStack.Pop();
			EmulateLoadField(instr.Operand as IField);
		}

		void Emulate_Ldsfld(Instruction instr) => EmulateLoadField(instr.Operand as IField);

		void EmulateLoadField(IField field) {
			if (field != null)
				valueStack.Push(GetUnknownValue(field.FieldSig.GetFieldType()));
			else
				valueStack.PushUnknown();
		}

		void EmulateIntOps2() {
			var val2 = valueStack.Pop();
			var val1 = valueStack.Pop();
			if (val1.IsInt32() && val2.IsInt32())
				valueStack.Push(Int32Value.CreateUnknown());
			else if (val1.IsInt64() && val2.IsInt64())
				valueStack.Push(Int64Value.CreateUnknown());
			else
				valueStack.PushUnknown();
		}
	}
}



================================================
File: de4dot.blocks/cflow/Int32Value.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;

namespace de4dot.blocks.cflow {
	public class Int32Value : Value {
		public static readonly Int32Value Zero = new Int32Value(0);
		public static readonly Int32Value One = new Int32Value(1);

		internal const uint NO_UNKNOWN_BITS = uint.MaxValue;
		public readonly int Value;
		public readonly uint ValidMask;

		public Int32Value(int value)
			: base(ValueType.Int32) {
			Value = value;
			ValidMask = NO_UNKNOWN_BITS;
		}

		public Int32Value(int value, uint validMask)
			: base(ValueType.Int32) {
			Value = value;
			ValidMask = validMask;
		}

		public bool HasUnknownBits() => ValidMask != NO_UNKNOWN_BITS;
		public bool AllBitsValid() => !HasUnknownBits();
		bool IsBitValid(int n) => IsBitValid(ValidMask, n);
		static bool IsBitValid(uint validMask, int n) => (validMask & (1U << n)) != 0;
		bool AreBitsValid(uint bitsToTest) => (ValidMask & bitsToTest) == bitsToTest;
		public static Int32Value CreateUnknownBool() => new Int32Value(0, NO_UNKNOWN_BITS << 1);
		public static Int32Value CreateUnknownUInt8() => new Int32Value(0, NO_UNKNOWN_BITS << 8);
		public static Int32Value CreateUnknownUInt16() => new Int32Value(0, NO_UNKNOWN_BITS << 16);
		public static Int32Value CreateUnknown() => new Int32Value(0, 0U);
		public bool IsZero() => HasValue(0);
		public bool IsNonZero() => ((uint)Value & ValidMask) != 0;
		public bool HasValue(int value) => AllBitsValid() && Value == value;
		public bool HasValue(uint value) => HasValue((int)value);

		public Int32Value ToBoolean() {
			if (IsNonZero())
				return new Int32Value(1, NO_UNKNOWN_BITS);
			if (IsZero())
				return this;
			return CreateUnknownBool();
		}

		public Int32Value ToInt8() => Conv_I1(this);
		public Int32Value ToUInt8() => Conv_U1(this);
		public Int32Value ToInt16() => Conv_I2(this);
		public Int32Value ToUInt16() => Conv_U2(this);
		public static Int32Value Conv_U1(Int32Value a) => Conv_U1(a.Value, a.ValidMask);
		public static Int32Value Conv_U1(Int64Value a) => Conv_U1((int)a.Value, (uint)a.ValidMask);

		public static Int32Value Conv_U1(int value, uint validMask) {
			value = (int)(byte)value;
			validMask |= NO_UNKNOWN_BITS << 8;
			return new Int32Value(value, validMask);
		}

		public static Int32Value Conv_U1(Real8Value a) {
			if (!a.IsValid)
				return CreateUnknownUInt8();
			return new Int32Value((int)(byte)a.Value);
		}

		public static Int32Value Conv_I1(Int32Value a) => Conv_I1(a.Value, a.ValidMask);
		public static Int32Value Conv_I1(Int64Value a) => Conv_I1((int)a.Value, (uint)a.ValidMask);

		public static Int32Value Conv_I1(int value, uint validMask) {
			value = (int)(sbyte)value;
			if (IsBitValid(validMask, 7))
				validMask |= NO_UNKNOWN_BITS << 8;
			else
				validMask &= ~(NO_UNKNOWN_BITS << 8);
			return new Int32Value(value, validMask);
		}

		public static Int32Value Conv_I1(Real8Value a) {
			if (!a.IsValid)
				return CreateUnknown();
			return new Int32Value((int)(sbyte)a.Value);
		}

		public static Int32Value Conv_U2(Int32Value a) => Conv_U2(a.Value, a.ValidMask);
		public static Int32Value Conv_U2(Int64Value a) => Conv_U2((int)a.Value, (uint)a.ValidMask);

		public static Int32Value Conv_U2(int value, uint validMask) {
			value = (int)(ushort)value;
			validMask |= NO_UNKNOWN_BITS << 16;
			return new Int32Value(value, validMask);
		}

		public static Int32Value Conv_U2(Real8Value a) {
			if (!a.IsValid)
				return CreateUnknownUInt16();
			return new Int32Value((int)(ushort)a.Value);
		}

		public static Int32Value Conv_I2(Int32Value a) => Conv_I2(a.Value, a.ValidMask);
		public static Int32Value Conv_I2(Int64Value a) => Conv_I2((int)a.Value, (uint)a.ValidMask);

		public static Int32Value Conv_I2(int value, uint validMask) {
			value = (int)(short)value;
			if (IsBitValid(validMask, 15))
				validMask |= NO_UNKNOWN_BITS << 16;
			else
				validMask &= ~(NO_UNKNOWN_BITS << 16);
			return new Int32Value(value, validMask);
		}

		public static Int32Value Conv_I2(Real8Value a) {
			if (!a.IsValid)
				return CreateUnknown();
			return new Int32Value((int)(short)a.Value);
		}

		public static Int32Value Conv_U4(Int32Value a) => a;
		public static Int32Value Conv_U4(Int64Value a) => new Int32Value((int)(uint)a.Value, (uint)a.ValidMask);
		public static Int32Value Conv_U4(Real8Value a) {
			if (!a.IsValid)
				return CreateUnknown();
			return new Int32Value((int)(uint)a.Value);
		}

		public static Int32Value Conv_I4(Int32Value a) => a;
		public static Int32Value Conv_I4(Int64Value a) => new Int32Value((int)a.Value, (uint)a.ValidMask);

		public static Int32Value Conv_I4(Real8Value a) {
			if (!a.IsValid)
				return CreateUnknown();
			return new Int32Value((int)a.Value);
		}

		bool CheckSign(uint mask) => ((uint)Value & mask) == 0 || ((uint)Value & mask) == mask;

		public static Int32Value Conv_Ovf_I1(Int32Value a) {
			if (!a.AreBitsValid(NO_UNKNOWN_BITS << 7) ||
				!a.CheckSign(NO_UNKNOWN_BITS << 7))
				return CreateUnknown();
			return Conv_I1(a);
		}

		public static Int32Value Conv_Ovf_I1_Un(Int32Value a) {
			if (!a.AreBitsValid(NO_UNKNOWN_BITS << 7) ||
				(uint)a.Value > sbyte.MaxValue)
				return CreateUnknown();
			return Conv_I1(a);
		}

		public static Int32Value Conv_Ovf_I2(Int32Value a) {
			if (!a.AreBitsValid(NO_UNKNOWN_BITS << 15) ||
				!a.CheckSign(NO_UNKNOWN_BITS << 15))
				return CreateUnknown();
			return Conv_I2(a);
		}

		public static Int32Value Conv_Ovf_I2_Un(Int32Value a) {
			if (!a.AreBitsValid(NO_UNKNOWN_BITS << 15) ||
				(uint)a.Value > short.MaxValue)
				return CreateUnknown();
			return Conv_I2(a);
		}

		public static Int32Value Conv_Ovf_I4(Int32Value a) => a;

		public static Int32Value Conv_Ovf_I4_Un(Int32Value a) {
			if (!IsBitValid(a.ValidMask, 31) || a.Value < 0)
				return CreateUnknown();
			return a;
		}

		public static Int64Value Conv_Ovf_I8(Int32Value a) {
			ulong validMask = a.ValidMask;
			if (IsBitValid(a.ValidMask, 31))
				validMask |= Int64Value.NO_UNKNOWN_BITS << 32;
			return new Int64Value(a.Value, validMask);
		}

		public static Int64Value Conv_Ovf_I8_Un(Int32Value a) =>
			new Int64Value((long)(uint)a.Value, a.ValidMask | (Int64Value.NO_UNKNOWN_BITS << 32));

		public static Int32Value Conv_Ovf_U1(Int32Value a) {
			if (!a.AreBitsValid(NO_UNKNOWN_BITS << 7) ||
				a.Value < 0 || a.Value > byte.MaxValue)
				return CreateUnknownUInt8();
			return Conv_U1(a);
		}

		public static Int32Value Conv_Ovf_U1_Un(Int32Value a) {
			if (!a.AreBitsValid(NO_UNKNOWN_BITS << 8) ||
				(uint)a.Value > byte.MaxValue)
				return CreateUnknownUInt8();
			return Conv_U1(a);
		}

		public static Int32Value Conv_Ovf_U2(Int32Value a) {
			if (!a.AreBitsValid(NO_UNKNOWN_BITS << 15) ||
				a.Value < 0 || a.Value > ushort.MaxValue)
				return CreateUnknownUInt16();
			return Conv_U2(a);
		}

		public static Int32Value Conv_Ovf_U2_Un(Int32Value a) {
			if (!a.AreBitsValid(NO_UNKNOWN_BITS << 16) ||
				(uint)a.Value > ushort.MaxValue)
				return CreateUnknownUInt16();
			return Conv_U2(a);
		}

		public static Int32Value Conv_Ovf_U4(Int32Value a) {
			if (!IsBitValid(a.ValidMask, 31) || a.Value < 0)
				return CreateUnknown();
			return a;
		}

		public static Int32Value Conv_Ovf_U4_Un(Int32Value a) => a;

		public static Int64Value Conv_Ovf_U8(Int32Value a) {
			if (!IsBitValid(a.ValidMask, 31) || a.Value < 0)
				return Int64Value.CreateUnknown();
			return new Int64Value(a.Value, (ulong)a.ValidMask | (Int64Value.NO_UNKNOWN_BITS << 32));
		}

		public static Int64Value Conv_Ovf_U8_Un(Int32Value a) =>
			new Int64Value((long)(uint)a.Value, a.ValidMask | (Int64Value.NO_UNKNOWN_BITS << 32));

		public static Real8Value Conv_R_Un(Int32Value a) {
			if (a.AllBitsValid())
				return new Real8Value((double)(uint)a.Value);
			return Real8Value.CreateUnknown();
		}

		public static Real8Value Conv_R4(Int32Value a) {
			if (a.AllBitsValid())
				return new Real8Value((double)(int)a.Value);
			return Real8Value.CreateUnknown();
		}

		public static Real8Value Conv_R8(Int32Value a) {
			if (a.AllBitsValid())
				return new Real8Value((double)(int)a.Value);
			return Real8Value.CreateUnknown();
		}

		public static Int32Value Add(Int32Value a, Int32Value b) {
			if (a.AllBitsValid() && b.AllBitsValid())
				return new Int32Value(a.Value + b.Value);
			if (ReferenceEquals(a, b))
				return new Int32Value(a.Value << 1, (a.ValidMask << 1) | 1);
			return CreateUnknown();
		}

		public static Int32Value Sub(Int32Value a, Int32Value b) {
			if (a.AllBitsValid() && b.AllBitsValid())
				return new Int32Value(a.Value - b.Value);
			if (ReferenceEquals(a, b))
				return Zero;
			return CreateUnknown();
		}

		public static Int32Value Mul(Int32Value a, Int32Value b) {
			if (a.AllBitsValid() && b.AllBitsValid())
				return new Int32Value(a.Value * b.Value);
			if (a.IsZero() || b.IsZero())
				return Zero;
			if (a.HasValue(1))
				return b;
			if (b.HasValue(1))
				return a;
			return CreateUnknown();
		}

		public static Int32Value Div(Int32Value a, Int32Value b) {
			if (a.AllBitsValid() && b.AllBitsValid()) {
				try {
					return new Int32Value(a.Value / b.Value);
				}
				catch (ArithmeticException) {
					return CreateUnknown();
				}
			}
			if (ReferenceEquals(a, b) && a.IsNonZero())
				return One;
			if (b.HasValue(1))
				return a;
			return CreateUnknown();
		}

		public static Int32Value Div_Un(Int32Value a, Int32Value b) {
			if (a.AllBitsValid() && b.AllBitsValid()) {
				try {
					return new Int32Value((int)((uint)a.Value / (uint)b.Value));
				}
				catch (ArithmeticException) {
					return CreateUnknown();
				}
			}
			if (ReferenceEquals(a, b) && a.IsNonZero())
				return One;
			if (b.HasValue(1))
				return a;
			return CreateUnknown();
		}

		public static Int32Value Rem(Int32Value a, Int32Value b) {
			if (a.AllBitsValid() && b.AllBitsValid()) {
				try {
					return new Int32Value(a.Value % b.Value);
				}
				catch (ArithmeticException) {
					return CreateUnknown();
				}
			}
			if ((ReferenceEquals(a, b) && a.IsNonZero()) || b.HasValue(1))
				return Zero;
			return CreateUnknown();
		}

		public static Int32Value Rem_Un(Int32Value a, Int32Value b) {
			if (a.AllBitsValid() && b.AllBitsValid()) {
				try {
					return new Int32Value((int)((uint)a.Value % (uint)b.Value));
				}
				catch (ArithmeticException) {
					return CreateUnknown();
				}
			}
			if ((ReferenceEquals(a, b) && a.IsNonZero()) || b.HasValue(1))
				return Zero;
			return CreateUnknown();
		}

		public static Int32Value Neg(Int32Value a) {
			if (a.AllBitsValid())
				return new Int32Value(-a.Value);
			return CreateUnknown();
		}

		public static Int32Value Add_Ovf(Int32Value a, Int32Value b) {
			if (a.AllBitsValid() && b.AllBitsValid()) {
				try {
					return new Int32Value(checked(a.Value + b.Value));
				}
				catch (OverflowException) {
				}
			}
			return CreateUnknown();
		}

		public static Int32Value Add_Ovf_Un(Int32Value a, Int32Value b) {
			if (a.AllBitsValid() && b.AllBitsValid()) {
				uint aa = (uint)a.Value, bb = (uint)b.Value;
				try {
					return new Int32Value((int)checked(aa + bb));
				}
				catch (OverflowException) {
				}
			}
			return CreateUnknown();
		}

		public static Int32Value Sub_Ovf(Int32Value a, Int32Value b) {
			if (a.AllBitsValid() && b.AllBitsValid()) {
				try {
					return new Int32Value(checked(a.Value - b.Value));
				}
				catch (OverflowException) {
				}
			}
			return CreateUnknown();
		}

		public static Int32Value Sub_Ovf_Un(Int32Value a, Int32Value b) {
			if (a.AllBitsValid() && b.AllBitsValid()) {
				uint aa = (uint)a.Value, bb = (uint)b.Value;
				try {
					return new Int32Value((int)checked(aa - bb));
				}
				catch (OverflowException) {
				}
			}
			return CreateUnknown();
		}

		public static Int32Value Mul_Ovf(Int32Value a, Int32Value b) {
			if (a.AllBitsValid() && b.AllBitsValid()) {
				try {
					return new Int32Value(checked(a.Value * b.Value));
				}
				catch (OverflowException) {
				}
			}
			return CreateUnknown();
		}

		public static Int32Value Mul_Ovf_Un(Int32Value a, Int32Value b) {
			if (a.AllBitsValid() && b.AllBitsValid()) {
				uint aa = (uint)a.Value, bb = (uint)b.Value;
				try {
					return new Int32Value((int)checked(aa * bb));
				}
				catch (OverflowException) {
				}
			}
			return CreateUnknown();
		}

		public static Int32Value And(Int32Value a, Int32Value b) {
			int av = a.Value, bv = b.Value;
			uint am = a.ValidMask, bm = b.ValidMask;
			return new Int32Value(av & bv, (am & bm) | (((uint)av & am) ^ am) | (((uint)bv & bm) ^ bm));
		}

		public static Int32Value Or(Int32Value a, Int32Value b) {
			int av = a.Value, bv = b.Value;
			uint am = a.ValidMask, bm = b.ValidMask;
			return new Int32Value(av | bv, (am & bm) | ((uint)av & am) | ((uint)bv & bm));
		}

		public static Int32Value Xor(Int32Value a, Int32Value b) {
			if (ReferenceEquals(a, b))
				return Zero;
			int av = a.Value, bv = b.Value;
			uint am = a.ValidMask, bm = b.ValidMask;
			return new Int32Value(av ^ bv, am & bm);
		}

		public static Int32Value Not(Int32Value a) => new Int32Value(~a.Value, a.ValidMask);

		public static Int32Value Shl(Int32Value a, Int32Value b) {
			if (b.HasUnknownBits())
				return CreateUnknown();
			if (b.Value == 0)
				return a;
			if (b.Value < 0 || b.Value >= sizeof(int) * 8)
				return CreateUnknown();
			int shift = b.Value;
			uint validMask = (a.ValidMask << shift) | (uint.MaxValue >> (sizeof(int) * 8 - shift));
			return new Int32Value(a.Value << shift, validMask);
		}

		public static Int32Value Shr(Int32Value a, Int32Value b) {
			if (b.HasUnknownBits())
				return CreateUnknown();
			if (b.Value == 0)
				return a;
			if (b.Value < 0 || b.Value >= sizeof(int) * 8)
				return CreateUnknown();
			int shift = b.Value;
			uint validMask = a.ValidMask >> shift;
			if (a.IsBitValid(sizeof(int) * 8 - 1))
				validMask |= (uint.MaxValue << (sizeof(int) * 8 - shift));
			return new Int32Value(a.Value >> shift, validMask);
		}

		public static Int32Value Shr_Un(Int32Value a, Int32Value b) {
			if (b.HasUnknownBits())
				return CreateUnknown();
			if (b.Value == 0)
				return a;
			if (b.Value < 0 || b.Value >= sizeof(int) * 8)
				return CreateUnknown();
			int shift = b.Value;
			uint validMask = (a.ValidMask >> shift) | (uint.MaxValue << (sizeof(int) * 8 - shift));
			return new Int32Value((int)((uint)a.Value >> shift), validMask);
		}

		public static Int32Value Create(Bool3 b) {
			switch (b) {
			case Bool3.False:	return Zero;
			case Bool3.True:	return One;
			default:			return CreateUnknownBool();
			}
		}

		public static Int32Value Ceq(Int32Value a, Int32Value b) => Create(CompareEq(a, b));
		public static Int32Value Cgt(Int32Value a, Int32Value b) => Create(CompareGt(a, b));
		public static Int32Value Cgt_Un(Int32Value a, Int32Value b) => Create(CompareGt_Un(a, b));
		public static Int32Value Clt(Int32Value a, Int32Value b) => Create(CompareLt(a, b));
		public static Int32Value Clt_Un(Int32Value a, Int32Value b) => Create(CompareLt_Un(a, b));

		public static Bool3 CompareEq(Int32Value a, Int32Value b) {
			if (a.AllBitsValid() && b.AllBitsValid())
				return a.Value == b.Value ? Bool3.True : Bool3.False;
			if (ReferenceEquals(a, b))
				return Bool3.True;
			if (((uint)a.Value & a.ValidMask & b.ValidMask) != ((uint)b.Value & a.ValidMask & b.ValidMask))
				return Bool3.False;
			return Bool3.Unknown;
		}

		public static Bool3 CompareNeq(Int32Value a, Int32Value b) {
			if (a.AllBitsValid() && b.AllBitsValid())
				return a.Value != b.Value ? Bool3.True : Bool3.False;
			if (ReferenceEquals(a, b))
				return Bool3.False;
			if (((uint)a.Value & a.ValidMask & b.ValidMask) != ((uint)b.Value & a.ValidMask & b.ValidMask))
				return Bool3.True;
			return Bool3.Unknown;
		}

		public static Bool3 CompareGt(Int32Value a, Int32Value b) {
			if (a.AllBitsValid() && b.AllBitsValid())
				return a.Value > b.Value ? Bool3.True : Bool3.False;
			if (a.HasValue(int.MinValue))
				return Bool3.False;	// min > x => false
			if (b.HasValue(int.MaxValue))
				return Bool3.False;	// x > max => false
			return Bool3.Unknown;
		}

		public static Bool3 CompareGt_Un(Int32Value a, Int32Value b) {
			if (a.AllBitsValid() && b.AllBitsValid())
				return (uint)a.Value > (uint)b.Value ? Bool3.True : Bool3.False;
			if (a.HasValue(uint.MinValue))
				return Bool3.False;	// min > x => false
			if (b.HasValue(uint.MaxValue))
				return Bool3.False;	// x > max => false
			return Bool3.Unknown;
		}

		public static Bool3 CompareGe(Int32Value a, Int32Value b) {
			if (a.AllBitsValid() && b.AllBitsValid())
				return a.Value >= b.Value ? Bool3.True : Bool3.False;
			if (a.HasValue(int.MaxValue))
				return Bool3.True;	// max >= x => true
			if (b.HasValue(int.MinValue))
				return Bool3.True;	// x >= min => true
			return Bool3.Unknown;
		}

		public static Bool3 CompareGe_Un(Int32Value a, Int32Value b) {
			if (a.AllBitsValid() && b.AllBitsValid())
				return (uint)a.Value >= (uint)b.Value ? Bool3.True : Bool3.False;
			if (a.HasValue(uint.MaxValue))
				return Bool3.True;	// max >= x => true
			if (b.HasValue(uint.MinValue))
				return Bool3.True;	// x >= min => true
			return Bool3.Unknown;
		}

		public static Bool3 CompareLe(Int32Value a, Int32Value b) {
			if (a.AllBitsValid() && b.AllBitsValid())
				return a.Value <= b.Value ? Bool3.True : Bool3.False;
			if (a.HasValue(int.MinValue))
				return Bool3.True;	// min <= x => true
			if (b.HasValue(int.MaxValue))
				return Bool3.True;	// x <= max => true
			return Bool3.Unknown;
		}

		public static Bool3 CompareLe_Un(Int32Value a, Int32Value b) {
			if (a.AllBitsValid() && b.AllBitsValid())
				return (uint)a.Value <= (uint)b.Value ? Bool3.True : Bool3.False;
			if (a.HasValue(uint.MinValue))
				return Bool3.True;	// min <= x => true
			if (b.HasValue(uint.MaxValue))
				return Bool3.True;	// x <= max => true
			return Bool3.Unknown;
		}

		public static Bool3 CompareLt(Int32Value a, Int32Value b) {
			if (a.AllBitsValid() && b.AllBitsValid())
				return a.Value < b.Value ? Bool3.True : Bool3.False;
			if (a.HasValue(int.MaxValue))
				return Bool3.False;	// max < x => false
			if (b.HasValue(int.MinValue))
				return Bool3.False;	// x < min => false
			return Bool3.Unknown;
		}

		public static Bool3 CompareLt_Un(Int32Value a, Int32Value b) {
			if (a.AllBitsValid() && b.AllBitsValid())
				return (uint)a.Value < (uint)b.Value ? Bool3.True : Bool3.False;
			if (a.HasValue(uint.MaxValue))
				return Bool3.False;	// max < x => false
			if (b.HasValue(uint.MinValue))
				return Bool3.False;	// x < min => false
			return Bool3.Unknown;
		}

		public static Bool3 CompareTrue(Int32Value a) {
			if (a.AllBitsValid())
				return a.Value != 0 ? Bool3.True : Bool3.False;
			if (((uint)a.Value & a.ValidMask) != 0)
				return Bool3.True;
			return Bool3.Unknown;
		}

		public static Bool3 CompareFalse(Int32Value a) {
			if (a.AllBitsValid())
				return a.Value == 0 ? Bool3.True : Bool3.False;
			if (((uint)a.Value & a.ValidMask) != 0)
				return Bool3.False;
			return Bool3.Unknown;
		}

		public override string ToString() {
			if (AllBitsValid())
				return Value.ToString();
			return $"0x{Value:X8}({ValidMask:X8})";
		}
	}
}



================================================
File: de4dot.blocks/cflow/Int64Value.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;

namespace de4dot.blocks.cflow {
	public class Int64Value : Value {
		public static readonly Int64Value Zero = new Int64Value(0);
		public static readonly Int64Value One = new Int64Value(1);

		internal const ulong NO_UNKNOWN_BITS = ulong.MaxValue;
		public readonly long Value;
		public readonly ulong ValidMask;

		public Int64Value(long value)
			: base(ValueType.Int64) {
			Value = value;
			ValidMask = NO_UNKNOWN_BITS;
		}

		public Int64Value(long value, ulong validMask)
			: base(ValueType.Int64) {
			Value = value;
			ValidMask = validMask;
		}

		bool HasUnknownBits() => ValidMask != NO_UNKNOWN_BITS;
		public bool AllBitsValid() => !HasUnknownBits();
		bool IsBitValid(int n) => IsBitValid(ValidMask, n);
		static bool IsBitValid(ulong validMask, int n) => (validMask & (1UL << n)) != 0;
		bool AreBitsValid(ulong bitsToTest) => (ValidMask & bitsToTest) == bitsToTest;
		public static Int64Value CreateUnknown() => new Int64Value(0, 0UL);
		public bool IsZero() => HasValue(0);
		public bool IsNonZero() => ((ulong)Value & ValidMask) != 0;
		public bool HasValue(long value) => AllBitsValid() && Value == value;
		public bool HasValue(ulong value) => HasValue((long)value);

		public static Int64Value Conv_U8(Int32Value a) {
			long value = (long)(ulong)(uint)a.Value;
			ulong validMask = a.ValidMask | (NO_UNKNOWN_BITS << 32);
			return new Int64Value(value, validMask);
		}

		public static Int64Value Conv_U8(Int64Value a) => a;

		public static Int64Value Conv_U8(Real8Value a) {
			if (!a.IsValid)
				return CreateUnknown();
			return new Int64Value((long)(ulong)a.Value);
		}

		public static Int64Value Conv_I8(Int32Value a) {
			long value = a.Value;
			ulong validMask = a.ValidMask;
			if (IsBitValid(validMask, 31))
				validMask |= NO_UNKNOWN_BITS << 32;
			else
				validMask &= ~(NO_UNKNOWN_BITS << 32);
			return new Int64Value(value, validMask);
		}

		public static Int64Value Conv_I8(Int64Value a) => a;

		public static Int64Value Conv_I8(Real8Value a) {
			if (!a.IsValid)
				return CreateUnknown();
			return new Int64Value((long)a.Value);
		}

		bool CheckSign(ulong mask) => ((ulong)Value & mask) == 0 || ((ulong)Value & mask) == mask;

		public static Int32Value Conv_Ovf_I1(Int64Value a) {
			if (!a.AreBitsValid(NO_UNKNOWN_BITS << 7) ||
				!a.CheckSign(NO_UNKNOWN_BITS << 7))
				return Int32Value.CreateUnknown();
			return Int32Value.Conv_I1(a);
		}

		public static Int32Value Conv_Ovf_I1_Un(Int64Value a) {
			if (!a.AreBitsValid(NO_UNKNOWN_BITS << 7) ||
				(ulong)a.Value > (ulong)sbyte.MaxValue)
				return Int32Value.CreateUnknown();
			return Int32Value.Conv_I1(a);
		}

		public static Int32Value Conv_Ovf_I2(Int64Value a) {
			if (!a.AreBitsValid(NO_UNKNOWN_BITS << 15) ||
				!a.CheckSign(NO_UNKNOWN_BITS << 15))
				return Int32Value.CreateUnknown();
			return Int32Value.Conv_I2(a);
		}

		public static Int32Value Conv_Ovf_I2_Un(Int64Value a) {
			if (!a.AreBitsValid(NO_UNKNOWN_BITS << 15) ||
				(ulong)a.Value > (ulong)short.MaxValue)
				return Int32Value.CreateUnknown();
			return Int32Value.Conv_I2(a);
		}

		public static Int32Value Conv_Ovf_I4(Int64Value a) {
			if (!a.AreBitsValid(NO_UNKNOWN_BITS << 31) ||
				!a.CheckSign(NO_UNKNOWN_BITS << 31))
				return Int32Value.CreateUnknown();
			return Int32Value.Conv_I4(a);
		}

		public static Int32Value Conv_Ovf_I4_Un(Int64Value a) {
			if (!a.AreBitsValid(NO_UNKNOWN_BITS << 31) ||
				(ulong)a.Value > (ulong)int.MaxValue)
				return Int32Value.CreateUnknown();
			return Int32Value.Conv_I4(a);
		}

		public static Int64Value Conv_Ovf_I8(Int64Value a) => a;

		public static Int64Value Conv_Ovf_I8_Un(Int64Value a) {
			if (!IsBitValid(a.ValidMask, 63) || a.Value < 0)
				return CreateUnknown();
			return a;
		}

		public static Int32Value Conv_Ovf_U1(Int64Value a) {
			if (!a.AreBitsValid(NO_UNKNOWN_BITS << 7) ||
				a.Value < 0 || a.Value > byte.MaxValue)
				return Int32Value.CreateUnknownUInt8();
			return Int32Value.Conv_U1(a);
		}

		public static Int32Value Conv_Ovf_U1_Un(Int64Value a) {
			if (!a.AreBitsValid(NO_UNKNOWN_BITS << 8) ||
				(ulong)a.Value > byte.MaxValue)
				return Int32Value.CreateUnknownUInt8();
			return Int32Value.Conv_U1(a);
		}

		public static Int32Value Conv_Ovf_U2(Int64Value a) {
			if (!a.AreBitsValid(NO_UNKNOWN_BITS << 15) ||
				a.Value < 0 || a.Value > ushort.MaxValue)
				return Int32Value.CreateUnknownUInt16();
			return Int32Value.Conv_U2(a);
		}

		public static Int32Value Conv_Ovf_U2_Un(Int64Value a) {
			if (!a.AreBitsValid(NO_UNKNOWN_BITS << 16) ||
				(ulong)a.Value > ushort.MaxValue)
				return Int32Value.CreateUnknownUInt16();
			return Int32Value.Conv_U2(a);
		}

		public static Int32Value Conv_Ovf_U4(Int64Value a) {
			if (!a.AreBitsValid(NO_UNKNOWN_BITS << 31) ||
				a.Value < 0 || a.Value > uint.MaxValue)
				return Int32Value.CreateUnknown();
			return Int32Value.Conv_U4(a);
		}

		public static Int32Value Conv_Ovf_U4_Un(Int64Value a) {
			if (!a.AreBitsValid(NO_UNKNOWN_BITS << 32) ||
				(ulong)a.Value > uint.MaxValue)
				return Int32Value.CreateUnknown();
			return Int32Value.Conv_U4(a);
		}

		public static Int64Value Conv_Ovf_U8(Int64Value a) {
			if (!IsBitValid(a.ValidMask, 63) || a.Value < 0)
				return CreateUnknown();
			return a;
		}

		public static Int64Value Conv_Ovf_U8_Un(Int64Value a) => a;

		public static Real8Value Conv_R_Un(Int64Value a) {
			if (a.AllBitsValid())
				return new Real8Value((float)(ulong)a.Value);
			return Real8Value.CreateUnknown();
		}

		public static Real8Value Conv_R4(Int64Value a) {
			if (a.AllBitsValid())
				return new Real8Value((float)(long)a.Value);
			return Real8Value.CreateUnknown();
		}

		public static Real8Value Conv_R8(Int64Value a) {
			if (a.AllBitsValid())
				return new Real8Value((double)(long)a.Value);
			return Real8Value.CreateUnknown();
		}

		public static Int64Value Add(Int64Value a, Int64Value b) {
			if (a.AllBitsValid() && b.AllBitsValid())
				return new Int64Value(a.Value + b.Value);
			if (ReferenceEquals(a, b))
				return new Int64Value(a.Value << 1, (a.ValidMask << 1) | 1);
			return CreateUnknown();
		}

		public static Int64Value Sub(Int64Value a, Int64Value b) {
			if (a.AllBitsValid() && b.AllBitsValid())
				return new Int64Value(a.Value - b.Value);
			if (ReferenceEquals(a, b))
				return Zero;
			return CreateUnknown();
		}

		public static Int64Value Mul(Int64Value a, Int64Value b) {
			if (a.AllBitsValid() && b.AllBitsValid())
				return new Int64Value(a.Value * b.Value);
			if (a.IsZero() || b.IsZero())
				return Zero;
			if (a.HasValue(1))
				return b;
			if (b.HasValue(1))
				return a;
			return CreateUnknown();
		}

		public static Int64Value Div(Int64Value a, Int64Value b) {
			if (a.AllBitsValid() && b.AllBitsValid()) {
				try {
					return new Int64Value(a.Value / b.Value);
				}
				catch (ArithmeticException) {
					return CreateUnknown();
				}
			}
			if (ReferenceEquals(a, b) && a.IsNonZero())
				return One;
			if (b.HasValue(1))
				return a;
			return CreateUnknown();
		}

		public static Int64Value Div_Un(Int64Value a, Int64Value b) {
			if (a.AllBitsValid() && b.AllBitsValid()) {
				try {
					return new Int64Value((long)((ulong)a.Value / (ulong)b.Value));
				}
				catch (ArithmeticException) {
					return CreateUnknown();
				}
			}
			if (ReferenceEquals(a, b) && a.IsNonZero())
				return One;
			if (b.HasValue(1))
				return a;
			return CreateUnknown();
		}

		public static Int64Value Rem(Int64Value a, Int64Value b) {
			if (a.AllBitsValid() && b.AllBitsValid()) {
				try {
					return new Int64Value(a.Value % b.Value);
				}
				catch (ArithmeticException) {
					return CreateUnknown();
				}
			}
			if ((ReferenceEquals(a, b) && a.IsNonZero()) || b.HasValue(1))
				return Zero;
			return CreateUnknown();
		}

		public static Int64Value Rem_Un(Int64Value a, Int64Value b) {
			if (a.AllBitsValid() && b.AllBitsValid()) {
				try {
					return new Int64Value((long)((ulong)a.Value % (ulong)b.Value));
				}
				catch (ArithmeticException) {
					return CreateUnknown();
				}
			}
			if ((ReferenceEquals(a, b) && a.IsNonZero()) || b.HasValue(1))
				return Zero;
			return CreateUnknown();
		}

		public static Int64Value Neg(Int64Value a) {
			if (a.AllBitsValid())
				return new Int64Value(-a.Value);
			return CreateUnknown();
		}

		public static Int64Value Add_Ovf(Int64Value a, Int64Value b) {
			if (a.AllBitsValid() && b.AllBitsValid()) {
				try {
					return new Int64Value(checked(a.Value + b.Value));
				}
				catch (OverflowException) {
				}
			}
			return CreateUnknown();
		}

		public static Int64Value Add_Ovf_Un(Int64Value a, Int64Value b) {
			if (a.AllBitsValid() && b.AllBitsValid()) {
				ulong aa = (ulong)a.Value, bb = (ulong)b.Value;
				try {
					return new Int64Value((long)checked(aa + bb));
				}
				catch (OverflowException) {
				}
			}
			return CreateUnknown();
		}

		public static Int64Value Sub_Ovf(Int64Value a, Int64Value b) {
			if (a.AllBitsValid() && b.AllBitsValid()) {
				try {
					return new Int64Value(checked(a.Value - b.Value));
				}
				catch (OverflowException) {
				}
			}
			return CreateUnknown();
		}

		public static Int64Value Sub_Ovf_Un(Int64Value a, Int64Value b) {
			if (a.AllBitsValid() && b.AllBitsValid()) {
				ulong aa = (ulong)a.Value, bb = (ulong)b.Value;
				try {
					return new Int64Value((long)checked(aa - bb));
				}
				catch (OverflowException) {
				}
			}
			return CreateUnknown();
		}

		public static Int64Value Mul_Ovf(Int64Value a, Int64Value b) {
			if (a.AllBitsValid() && b.AllBitsValid()) {
				try {
					return new Int64Value(checked(a.Value * b.Value));
				}
				catch (OverflowException) {
				}
			}
			return CreateUnknown();
		}

		public static Int64Value Mul_Ovf_Un(Int64Value a, Int64Value b) {
			if (a.AllBitsValid() && b.AllBitsValid()) {
				ulong aa = (ulong)a.Value, bb = (ulong)b.Value;
				try {
					return new Int64Value((long)checked(aa * bb));
				}
				catch (OverflowException) {
				}
			}
			return CreateUnknown();
		}

		public static Int64Value And(Int64Value a, Int64Value b) {
			long av = a.Value, bv = b.Value;
			ulong am = a.ValidMask, bm = b.ValidMask;
			return new Int64Value(av & bv, (am & bm) | (((ulong)av & am) ^ am) | (((ulong)bv & bm) ^ bm));
		}

		public static Int64Value Or(Int64Value a, Int64Value b) {
			long av = a.Value, bv = b.Value;
			ulong am = a.ValidMask, bm = b.ValidMask;
			return new Int64Value(av | bv, (am & bm) | ((ulong)av & am) | ((ulong)bv & bm));
		}

		public static Int64Value Xor(Int64Value a, Int64Value b) {
			if (ReferenceEquals(a, b))
				return Zero;
			long av = a.Value, bv = b.Value;
			ulong am = a.ValidMask, bm = b.ValidMask;
			return new Int64Value(av ^ bv, am & bm);
		}

		public static Int64Value Not(Int64Value a) => new Int64Value(~a.Value, a.ValidMask);

		public static Int64Value Shl(Int64Value a, Int32Value b) {
			if (b.HasUnknownBits())
				return CreateUnknown();
			if (b.Value == 0)
				return a;
			if (b.Value < 0 || b.Value >= sizeof(long) * 8)
				return CreateUnknown();
			int shift = b.Value;
			ulong validMask = (a.ValidMask << shift) | (ulong.MaxValue >> (sizeof(long) * 8 - shift));
			return new Int64Value(a.Value << shift, validMask);
		}

		public static Int64Value Shr(Int64Value a, Int32Value b) {
			if (b.HasUnknownBits())
				return CreateUnknown();
			if (b.Value == 0)
				return a;
			if (b.Value < 0 || b.Value >= sizeof(long) * 8)
				return CreateUnknown();
			int shift = b.Value;
			ulong validMask = a.ValidMask >> shift;
			if (a.IsBitValid(sizeof(long) * 8 - 1))
				validMask |= (ulong.MaxValue << (sizeof(long) * 8 - shift));
			return new Int64Value(a.Value >> shift, validMask);
		}

		public static Int64Value Shr_Un(Int64Value a, Int32Value b) {
			if (b.HasUnknownBits())
				return CreateUnknown();
			if (b.Value == 0)
				return a;
			if (b.Value < 0 || b.Value >= sizeof(long) * 8)
				return CreateUnknown();
			int shift = b.Value;
			ulong validMask = (a.ValidMask >> shift) | (ulong.MaxValue << (sizeof(long) * 8 - shift));
			return new Int64Value((long)((ulong)a.Value >> shift), validMask);
		}

		public static Int32Value Ceq(Int64Value a, Int64Value b) =>
			Int32Value.Create(CompareEq(a, b));

		public static Int32Value Cgt(Int64Value a, Int64Value b) =>
			Int32Value.Create(CompareGt(a, b));

		public static Int32Value Cgt_Un(Int64Value a, Int64Value b) =>
			Int32Value.Create(CompareGt_Un(a, b));

		public static Int32Value Clt(Int64Value a, Int64Value b) =>
			Int32Value.Create(CompareLt(a, b));

		public static Int32Value Clt_Un(Int64Value a, Int64Value b) =>
			Int32Value.Create(CompareLt_Un(a, b));

		public static Bool3 CompareEq(Int64Value a, Int64Value b) {
			if (a.AllBitsValid() && b.AllBitsValid())
				return a.Value == b.Value ? Bool3.True : Bool3.False;
			if (ReferenceEquals(a, b))
				return Bool3.True;
			if (((ulong)a.Value & a.ValidMask & b.ValidMask) != ((ulong)b.Value & a.ValidMask & b.ValidMask))
				return Bool3.False;
			return Bool3.Unknown;
		}

		public static Bool3 CompareNeq(Int64Value a, Int64Value b) {
			if (a.AllBitsValid() && b.AllBitsValid())
				return a.Value != b.Value ? Bool3.True : Bool3.False;
			if (ReferenceEquals(a, b))
				return Bool3.False;
			if (((ulong)a.Value & a.ValidMask & b.ValidMask) != ((ulong)b.Value & a.ValidMask & b.ValidMask))
				return Bool3.True;
			return Bool3.Unknown;
		}

		public static Bool3 CompareGt(Int64Value a, Int64Value b) {
			if (a.AllBitsValid() && b.AllBitsValid())
				return a.Value > b.Value ? Bool3.True : Bool3.False;
			if (a.HasValue(long.MinValue))
				return Bool3.False;	// min > x => false
			if (b.HasValue(long.MaxValue))
				return Bool3.False;	// x > max => false
			return Bool3.Unknown;
		}

		public static Bool3 CompareGt_Un(Int64Value a, Int64Value b) {
			if (a.AllBitsValid() && b.AllBitsValid())
				return (ulong)a.Value > (ulong)b.Value ? Bool3.True : Bool3.False;
			if (a.HasValue(ulong.MinValue))
				return Bool3.False;	// min > x => false
			if (b.HasValue(ulong.MaxValue))
				return Bool3.False;	// x > max => false
			return Bool3.Unknown;
		}

		public static Bool3 CompareGe(Int64Value a, Int64Value b) {
			if (a.AllBitsValid() && b.AllBitsValid())
				return a.Value >= b.Value ? Bool3.True : Bool3.False;
			if (a.HasValue(long.MaxValue))
				return Bool3.True;	// max >= x => true
			if (b.HasValue(long.MinValue))
				return Bool3.True;	// x >= min => true
			return Bool3.Unknown;
		}

		public static Bool3 CompareGe_Un(Int64Value a, Int64Value b) {
			if (a.AllBitsValid() && b.AllBitsValid())
				return (ulong)a.Value >= (ulong)b.Value ? Bool3.True : Bool3.False;
			if (a.HasValue(ulong.MaxValue))
				return Bool3.True;	// max >= x => true
			if (b.HasValue(ulong.MinValue))
				return Bool3.True;	// x >= min => true
			return Bool3.Unknown;
		}

		public static Bool3 CompareLe(Int64Value a, Int64Value b) {
			if (a.AllBitsValid() && b.AllBitsValid())
				return a.Value <= b.Value ? Bool3.True : Bool3.False;
			if (a.HasValue(long.MinValue))
				return Bool3.True;	// min <= x => true
			if (b.HasValue(long.MaxValue))
				return Bool3.True;	// x <= max => true
			return Bool3.Unknown;
		}

		public static Bool3 CompareLe_Un(Int64Value a, Int64Value b) {
			if (a.AllBitsValid() && b.AllBitsValid())
				return (ulong)a.Value <= (ulong)b.Value ? Bool3.True : Bool3.False;
			if (a.HasValue(ulong.MinValue))
				return Bool3.True;	// min <= x => true
			if (b.HasValue(ulong.MaxValue))
				return Bool3.True;	// x <= max => true
			return Bool3.Unknown;
		}

		public static Bool3 CompareLt(Int64Value a, Int64Value b) {
			if (a.AllBitsValid() && b.AllBitsValid())
				return a.Value < b.Value ? Bool3.True : Bool3.False;
			if (a.HasValue(long.MaxValue))
				return Bool3.False;	// max < x => false
			if (b.HasValue(long.MinValue))
				return Bool3.False;	// x < min => false
			return Bool3.Unknown;
		}

		public static Bool3 CompareLt_Un(Int64Value a, Int64Value b) {
			if (a.AllBitsValid() && b.AllBitsValid())
				return (ulong)a.Value < (ulong)b.Value ? Bool3.True : Bool3.False;
			if (a.HasValue(ulong.MaxValue))
				return Bool3.False;	// max < x => false
			if (b.HasValue(ulong.MinValue))
				return Bool3.False;	// x < min => false
			return Bool3.Unknown;
		}

		public static Bool3 CompareTrue(Int64Value a) {
			if (a.AllBitsValid())
				return a.Value != 0 ? Bool3.True : Bool3.False;
			if (((ulong)a.Value & a.ValidMask) != 0)
				return Bool3.True;
			return Bool3.Unknown;
		}

		public static Bool3 CompareFalse(Int64Value a) {
			if (a.AllBitsValid())
				return a.Value == 0 ? Bool3.True : Bool3.False;
			if (((ulong)a.Value & a.ValidMask) != 0)
				return Bool3.False;
			return Bool3.Unknown;
		}

		public override string ToString() {
			if (AllBitsValid())
				return Value.ToString();
			return $"0x{Value:X8}L({ValidMask:X8})";
		}
	}
}



================================================
File: de4dot.blocks/cflow/MethodCallInliner.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace de4dot.blocks.cflow {
	public class MethodCallInliner : MethodCallInlinerBase {
		protected readonly bool inlineInstanceMethods;

		public MethodCallInliner(bool inlineInstanceMethods) => this.inlineInstanceMethods = inlineInstanceMethods;

		protected override bool DeobfuscateInternal() {
			bool modified = false;
			var instructions = block.Instructions;
			for (int i = 0; i < instructions.Count; i++) {
				var instr = instructions[i].Instruction;
				if (instr.OpCode.Code == Code.Call)
					modified |= InlineMethod(instr, i);
			}
			return modified;
		}

		protected virtual bool CanInline(MethodDef method) {
			if (method.GenericParameters.Count > 0)
				return false;
			if (method == blocks.Method)
				return false;
			if (!new SigComparer().Equals(method.DeclaringType, blocks.Method.DeclaringType))
				return false;

			if (method.IsStatic)
				return true;
			if (method.IsVirtual)
				return false;
			return inlineInstanceMethods;
		}

		protected virtual Instruction GetFirstInstruction(IList<Instruction> instrs, ref int index) =>
			DotNetUtils.GetInstruction(instrs, ref index);

		bool InlineMethod(Instruction callInstr, int instrIndex) {
			var methodToInline = callInstr.Operand as MethodDef;
			if (methodToInline == null)
				return false;

			if (!CanInline(methodToInline))
				return false;
			var body = methodToInline.Body;
			if (body == null)
				return false;

			int index = 0;
			var instr = GetFirstInstruction(body.Instructions, ref index);
			if (instr == null)
				return false;

			bool inlinedMethod;
			switch (instr.OpCode.Code) {
			case Code.Ldarg:
			case Code.Ldarg_S:
			case Code.Ldarg_0:
			case Code.Ldarg_1:
			case Code.Ldarg_2:
			case Code.Ldarg_3:
			case Code.Ldarga:
			case Code.Ldarga_S:
			case Code.Call:
			case Code.Callvirt:
			case Code.Newobj:
				inlinedMethod = InlineOtherMethod(instrIndex, methodToInline, instr, index);
				break;

			case Code.Ldc_I4:
			case Code.Ldc_I4_0:
			case Code.Ldc_I4_1:
			case Code.Ldc_I4_2:
			case Code.Ldc_I4_3:
			case Code.Ldc_I4_4:
			case Code.Ldc_I4_5:
			case Code.Ldc_I4_6:
			case Code.Ldc_I4_7:
			case Code.Ldc_I4_8:
			case Code.Ldc_I4_M1:
			case Code.Ldc_I4_S:
			case Code.Ldc_I8:
			case Code.Ldc_R4:
			case Code.Ldc_R8:
			case Code.Ldftn:
			case Code.Ldnull:
			case Code.Ldstr:
			case Code.Ldtoken:
			case Code.Ldsfld:
			case Code.Ldsflda:
				inlinedMethod = InlineLoadMethod(instrIndex, methodToInline, instr, index);
				break;

			default:
				inlinedMethod = false;
				break;
			}
			OnInlinedMethod(methodToInline, inlinedMethod);
			return inlinedMethod;
		}

		protected virtual void OnInlinedMethod(MethodDef methodToInline, bool inlinedMethod) {
		}

		protected override bool IsCompatibleType(int paramIndex, IType origType, IType newType) {
			if (new SigComparer(SigComparerOptions.IgnoreModifiers).Equals(origType, newType))
				return true;
			if (IsValueType(newType) || IsValueType(origType))
				return false;
			return newType.FullName == "System.Object";
		}
	}
}



================================================
File: de4dot.blocks/cflow/MethodCallInlinerBase.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace de4dot.blocks.cflow {
	public abstract class MethodCallInlinerBase : IBlocksDeobfuscator {
		// We can't catch all infinite loops, so inline methods at most this many times
		const int MAX_ITERATIONS = 10;

		protected Blocks blocks;
		protected Block block;
		int iteration;
		AccessChecker accessChecker;

		public bool ExecuteIfNotModified { get; set; }

		public void DeobfuscateBegin(Blocks blocks) {
			this.blocks = blocks;
			iteration = 0;
		}

		public bool Deobfuscate(List<Block> allBlocks) {
			if (iteration++ >= MAX_ITERATIONS)
				return false;

			bool modified = false;
			foreach (var block in allBlocks) {
				this.block = block;
				modified |= DeobfuscateInternal();
			}
			return modified;
		}

		protected abstract bool DeobfuscateInternal();

		protected class InstructionPatcher {
			readonly int patchIndex;
			public readonly int afterIndex;
			public readonly Instruction lastInstr;
			readonly Instr clonedInstr;
			public InstructionPatcher(int patchIndex, int afterIndex, Instruction lastInstr) {
				this.patchIndex = patchIndex;
				this.afterIndex = afterIndex;
				this.lastInstr = lastInstr;
				clonedInstr = new Instr(lastInstr.Clone());
			}

			public void Patch(Block block) => block.Instructions[patchIndex] = clonedInstr;
		}

		protected bool InlineLoadMethod(int patchIndex, MethodDef methodToInline, Instruction loadInstr, int instrIndex) {
			if (!IsReturn(methodToInline, instrIndex))
				return false;

			int methodArgsCount = DotNetUtils.GetArgsCount(methodToInline);
			for (int i = 0; i < methodArgsCount; i++)
				block.Insert(patchIndex++, OpCodes.Pop.ToInstruction());

			block.Instructions[patchIndex] = new Instr(loadInstr.Clone());
			return true;
		}

		protected bool InlineOtherMethod(int patchIndex, MethodDef methodToInline, Instruction instr, int instrIndex) =>
			InlineOtherMethod(patchIndex, methodToInline, instr, instrIndex, 0);

		protected bool InlineOtherMethod(int patchIndex, MethodDef methodToInline, Instruction instr, int instrIndex, int popLastArgs) =>
			PatchMethod(methodToInline, TryInlineOtherMethod(patchIndex, methodToInline, instr, instrIndex, popLastArgs));

		protected bool PatchMethod(MethodDef methodToInline, InstructionPatcher patcher) {
			if (patcher == null)
				return false;

			if (!IsReturn(methodToInline, patcher.afterIndex))
				return false;

			patcher.Patch(block);
			return true;
		}

		protected InstructionPatcher TryInlineOtherMethod(int patchIndex, MethodDef methodToInline, Instruction instr, int instrIndex) =>
			TryInlineOtherMethod(patchIndex, methodToInline, instr, instrIndex, 0);

		protected virtual Instruction OnAfterLoadArg(MethodDef methodToInline, Instruction instr, ref int instrIndex) => instr;

		protected InstructionPatcher TryInlineOtherMethod(int patchIndex, MethodDef methodToInline, Instruction instr, int instrIndex, int popLastArgs) {
			int loadIndex = 0;
			int methodArgsCount = DotNetUtils.GetArgsCount(methodToInline);
			bool foundLdarga = false;
			while (instr != null && loadIndex < methodArgsCount) {
				bool isLdarg = true;
				switch (instr.OpCode.Code) {
				case Code.Ldarg:
				case Code.Ldarg_S:
				case Code.Ldarg_0:
				case Code.Ldarg_1:
				case Code.Ldarg_2:
				case Code.Ldarg_3:
					break;
				case Code.Ldarga:
				case Code.Ldarga_S:
					foundLdarga = true;
					break;
				default:
					isLdarg = false;
					break;
				}
				if (!isLdarg)
					break;

				if (instr.GetParameterIndex() != loadIndex)
					return null;
				loadIndex++;
				instr = DotNetUtils.GetInstruction(methodToInline.Body.Instructions, ref instrIndex);
				instr = OnAfterLoadArg(methodToInline, instr, ref instrIndex);
			}
			if (instr == null || loadIndex != methodArgsCount - popLastArgs)
				return null;

			switch (instr.OpCode.Code) {
			case Code.Call:
			case Code.Callvirt:
				if (foundLdarga)
					return null;
				var callInstr = instr;
				var calledMethod = callInstr.Operand as IMethod;
				if (calledMethod == null)
					return null;

				if (!IsCompatibleType(-1, calledMethod.MethodSig.RetType, methodToInline.MethodSig.RetType))
					return null;

				if (!CheckSameMethods(calledMethod, methodToInline, popLastArgs))
					return null;

				if (!HasAccessTo(instr.Operand))
					return null;

				return new InstructionPatcher(patchIndex, instrIndex, callInstr);

			case Code.Newobj:
				if (foundLdarga)
					return null;
				var newobjInstr = instr;
				var ctor = newobjInstr.Operand as IMethod;
				if (ctor == null)
					return null;

				if (!IsCompatibleType(-1, ctor.DeclaringType, methodToInline.MethodSig.RetType))
					return null;

				var methodArgs = methodToInline.Parameters;
				var calledMethodArgs = DotNetUtils.GetArgs(ctor);
				if (methodArgs.Count + 1 - popLastArgs != calledMethodArgs.Count)
					return null;
				for (int i = 1; i < calledMethodArgs.Count; i++) {
					if (!IsCompatibleType(i, calledMethodArgs[i], methodArgs[i - 1].Type))
						return null;
				}

				if (!HasAccessTo(instr.Operand))
					return null;

				return new InstructionPatcher(patchIndex, instrIndex, newobjInstr);

			case Code.Ldfld:
			case Code.Ldflda:
			case Code.Ldftn:
			case Code.Ldvirtftn:
			case Code.Ldlen:
			case Code.Initobj:
			case Code.Isinst:
			case Code.Castclass:
			case Code.Newarr:
			case Code.Ldtoken:
			case Code.Unbox_Any:
				var ldInstr = instr;
				if (methodArgsCount != 1)
					return null;

				if (instr.OpCode.OperandType != OperandType.InlineNone && !HasAccessTo(instr.Operand))
					return null;

				return new InstructionPatcher(patchIndex, instrIndex, ldInstr);

			default:
				return null;
			}
		}

		bool HasAccessTo(object operand) {
			if (operand == null)
				return false;
			accessChecker.UserType = blocks.Method.DeclaringType;
			return accessChecker.CanAccess(operand) ?? GetDefaultAccessResult();
		}

		protected virtual bool GetDefaultAccessResult() => true;

		protected virtual bool IsReturn(MethodDef methodToInline, int instrIndex) {
			var instr = DotNetUtils.GetInstruction(methodToInline.Body.Instructions, ref instrIndex);
			return instr != null && instr.OpCode.Code == Code.Ret;
		}

		protected bool CheckSameMethods(IMethod method, MethodDef methodToInline) =>
			CheckSameMethods(method, methodToInline, 0);

		protected bool CheckSameMethods(IMethod method, MethodDef methodToInline, int ignoreLastMethodToInlineArgs) {
			var methodToInlineArgs = methodToInline.Parameters;
			var methodArgs = DotNetUtils.GetArgs(method);
			bool hasImplicitThis = method.MethodSig.ImplicitThis;
			if (methodToInlineArgs.Count - ignoreLastMethodToInlineArgs != methodArgs.Count)
				return false;
			for (int i = 0; i < methodArgs.Count; i++) {
				var methodArg = methodArgs[i];
				var methodToInlineArg = GetArgType(methodToInline, methodToInlineArgs[i].Type);
				if (!IsCompatibleType(i, methodArg, methodToInlineArg)) {
					if (i != 0 || !hasImplicitThis)
						return false;
					if (!IsCompatibleValueThisPtr(methodArg, methodToInlineArg))
						return false;
				}
			}

			return true;
		}

		static TypeSig GetArgType(MethodDef method, TypeSig arg) {
			if (arg.GetElementType() != ElementType.MVar)
				return arg;
			var mvar = (GenericMVar)arg;
			foreach (var gp in method.GenericParameters) {
				if (gp.Number != mvar.Number)
					continue;
				foreach (var gpc in gp.GenericParamConstraints)
					return gpc.Constraint.ToTypeSig();
			}
			return arg;
		}

		protected virtual bool IsCompatibleType(int paramIndex, IType origType, IType newType) =>
			new SigComparer().Equals(origType, newType);

		static bool IsCompatibleValueThisPtr(IType origType, IType newType) {
			var newByRef = newType as ByRefSig;
			if (newByRef == null)
				return false;
			if (!IsValueType(newByRef.Next) || !IsValueType(origType))
				return false;
			return new SigComparer().Equals(origType, newByRef.Next);
		}

		protected static bool IsValueType(IType type) {
			if (type == null)
				return false;
			var ts = type as TypeSig;
			if (ts == null)
				return type.IsValueType;
			return ts.IsValueType && ts.ElementType != ElementType.Void;
		}
	}
}



================================================
File: de4dot.blocks/cflow/Real8Value.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

namespace de4dot.blocks.cflow {
	public class Real8Value : Value {
		public readonly double Value;
		public readonly bool IsValid;

		public Real8Value(double value)
			: base(ValueType.Real8) {
			Value = value;
			IsValid = true;
		}

		public Real8Value(double value, bool isValid)
			: base(ValueType.Real8) {
			Value = value;
			IsValid = isValid;
		}

		public static Real8Value CreateUnknown() => new Real8Value(0, false);

		public Real8Value ToSingle() {
			if (!IsValid)
				return CreateUnknown();
			return new Real8Value((float)Value);
		}

		public static Real8Value Add(Real8Value a, Real8Value b) {
			if (!a.IsValid || !b.IsValid)
				return CreateUnknown();
			return new Real8Value(a.Value + b.Value);
		}

		public static Real8Value Sub(Real8Value a, Real8Value b) {
			if (!a.IsValid || !b.IsValid)
				return CreateUnknown();
			return new Real8Value(a.Value - b.Value);
		}

		public static Real8Value Mul(Real8Value a, Real8Value b) {
			if (!a.IsValid || !b.IsValid)
				return CreateUnknown();
			return new Real8Value(a.Value * b.Value);
		}

		public static Real8Value Div(Real8Value a, Real8Value b) {
			if (!a.IsValid || !b.IsValid)
				return CreateUnknown();
			return new Real8Value(a.Value / b.Value);
		}

		public static Real8Value Rem(Real8Value a, Real8Value b) {
			if (!a.IsValid || !b.IsValid)
				return CreateUnknown();
			return new Real8Value(a.Value % b.Value);
		}

		public static Real8Value Neg(Real8Value a) {
			if (!a.IsValid)
				return CreateUnknown();
			return new Real8Value(-a.Value);
		}

		public static Real8Value Add_Ovf(Real8Value a, Real8Value b) => CreateUnknown();
		public static Real8Value Add_Ovf_Un(Real8Value a, Real8Value b) => CreateUnknown();
		public static Real8Value Sub_Ovf(Real8Value a, Real8Value b) => CreateUnknown();
		public static Real8Value Sub_Ovf_Un(Real8Value a, Real8Value b) => CreateUnknown();
		public static Real8Value Mul_Ovf(Real8Value a, Real8Value b) => CreateUnknown();
		public static Real8Value Mul_Ovf_Un(Real8Value a, Real8Value b) => CreateUnknown();
		public static Int32Value Conv_Ovf_I1(Real8Value a) => Int32Value.CreateUnknown();
		public static Int32Value Conv_Ovf_I1_Un(Real8Value a) => Int32Value.CreateUnknown();
		public static Int32Value Conv_Ovf_I2(Real8Value a) => Int32Value.CreateUnknown();
		public static Int32Value Conv_Ovf_I2_Un(Real8Value a) => Int32Value.CreateUnknown();
		public static Int32Value Conv_Ovf_I4(Real8Value a) => Int32Value.CreateUnknown();
		public static Int32Value Conv_Ovf_I4_Un(Real8Value a) => Int32Value.CreateUnknown();
		public static Int64Value Conv_Ovf_I8(Real8Value a) => Int64Value.CreateUnknown();
		public static Int64Value Conv_Ovf_I8_Un(Real8Value a) => Int64Value.CreateUnknown();
		public static Int32Value Conv_Ovf_U1(Real8Value a) => Int32Value.CreateUnknownUInt8();
		public static Int32Value Conv_Ovf_U1_Un(Real8Value a) => Int32Value.CreateUnknownUInt8();
		public static Int32Value Conv_Ovf_U2(Real8Value a) => Int32Value.CreateUnknownUInt16();
		public static Int32Value Conv_Ovf_U2_Un(Real8Value a) => Int32Value.CreateUnknownUInt16();
		public static Int32Value Conv_Ovf_U4(Real8Value a) => Int32Value.CreateUnknown();
		public static Int32Value Conv_Ovf_U4_Un(Real8Value a) => Int32Value.CreateUnknown();
		public static Int64Value Conv_Ovf_U8(Real8Value a) => Int64Value.CreateUnknown();
		public static Int64Value Conv_Ovf_U8_Un(Real8Value a) => Int64Value.CreateUnknown();
		public static Real8Value Conv_R_Un(Real8Value a) => CreateUnknown();
		public static Real8Value Conv_R4(Real8Value a) {
			if (a.IsValid)
				return new Real8Value((float)a.Value);
			return CreateUnknown();
		}

		public static Real8Value Conv_R8(Real8Value a) => a;
		public static Int32Value Ceq(Real8Value a, Real8Value b) => Int32Value.Create(CompareEq(a, b));
		public static Int32Value Cgt(Real8Value a, Real8Value b) => Int32Value.Create(CompareGt(a, b));
		public static Int32Value Cgt_Un(Real8Value a, Real8Value b) => Int32Value.Create(CompareGt_Un(a, b));
		public static Int32Value Clt(Real8Value a, Real8Value b) => Int32Value.Create(CompareLt(a, b));
		public static Int32Value Clt_Un(Real8Value a, Real8Value b) => Int32Value.Create(CompareLt_Un(a, b));

		public static Bool3 CompareEq(Real8Value a, Real8Value b) {
			if (a.IsValid && b.IsValid)
				return a.Value == b.Value ? Bool3.True : Bool3.False;
			return Bool3.Unknown;
		}

		public static Bool3 CompareNeq(Real8Value a, Real8Value b) {
			if (a.IsValid && b.IsValid)
				return a.Value != b.Value ? Bool3.True : Bool3.False;
			return Bool3.Unknown;
		}

		public static Bool3 CompareGt(Real8Value a, Real8Value b) {
			if (a.IsValid && b.IsValid)
				return a.Value > b.Value ? Bool3.True : Bool3.False;
			return Bool3.Unknown;
		}

		public static Bool3 CompareGt_Un(Real8Value a, Real8Value b) => Bool3.Unknown;//TODO:

		public static Bool3 CompareGe(Real8Value a, Real8Value b) {
			if (a.IsValid && b.IsValid)
				return a.Value >= b.Value ? Bool3.True : Bool3.False;
			return Bool3.Unknown;
		}

		public static Bool3 CompareGe_Un(Real8Value a, Real8Value b) => Bool3.Unknown;//TODO:

		public static Bool3 CompareLe(Real8Value a, Real8Value b) {
			if (a.IsValid && b.IsValid)
				return a.Value <= b.Value ? Bool3.True : Bool3.False;
			return Bool3.Unknown;
		}

		public static Bool3 CompareLe_Un(Real8Value a, Real8Value b) => Bool3.Unknown;//TODO:

		public static Bool3 CompareLt(Real8Value a, Real8Value b) {
			if (a.IsValid && b.IsValid)
				return a.Value < b.Value ? Bool3.True : Bool3.False;
			return Bool3.Unknown;
		}

		public static Bool3 CompareLt_Un(Real8Value a, Real8Value b) => Bool3.Unknown;//TODO:
		public static Bool3 CompareTrue(Real8Value a) => Bool3.Unknown;
		public static Bool3 CompareFalse(Real8Value a) => Bool3.Unknown;

		public override string ToString() {
			if (!IsValid)
				return "<INVALID_REAL8>";
			return Value.ToString();
		}
	}
}



================================================
File: de4dot.blocks/cflow/StLdlocFixer.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace de4dot.blocks.cflow {
	// Replace stloc + ldloc with dup + stloc
	class StLdlocFixer : BlockDeobfuscator {
		IList<Local> locals;

		protected override void Initialize(List<Block> allBlocks) {
			base.Initialize(allBlocks);
			locals = blocks.Locals;
		}

		protected override bool Deobfuscate(Block block) {
			bool modified = false;
			var instructions = block.Instructions;
			for (int i = 0; i < instructions.Count; i++) {
				var instr = instructions[i];
				switch (instr.OpCode.Code) {
				// Xenocode generates stloc + ldloc (bool). Replace it with dup + stloc. It will eventually
				// become dup + pop and be removed.
				case Code.Stloc:
				case Code.Stloc_S:
				case Code.Stloc_0:
				case Code.Stloc_1:
				case Code.Stloc_2:
				case Code.Stloc_3:
					if (i + 1 >= instructions.Count)
						break;
					if (!instructions[i + 1].IsLdloc())
						break;
					var local = Instr.GetLocalVar(locals, instr);
					if (local.Type.ElementType != ElementType.Boolean)
						continue;
					if (local != Instr.GetLocalVar(locals, instructions[i + 1]))
						break;
					instructions[i] = new Instr(OpCodes.Dup.ToInstruction());
					instructions[i + 1] = instr;
					modified = true;
					break;

				default:
					break;
				}
			}

			return modified;
		}
	}
}



================================================
File: de4dot.blocks/cflow/SwitchCflowDeobfuscator.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet.Emit;

namespace de4dot.blocks.cflow {
	class SwitchCflowDeobfuscator : BlockDeobfuscator {
		InstructionEmulator instructionEmulator = new InstructionEmulator();

		protected override bool Deobfuscate(Block switchBlock) {
			if (switchBlock.LastInstr.OpCode.Code != Code.Switch)
				return false;

			if (IsSwitchTopOfStack(switchBlock) && DeobfuscateTOS(switchBlock))
				return true;

			if (IsLdlocBranch(switchBlock, true) && DeobfuscateLdloc(switchBlock))
				return true;

			if (IsStLdlocBranch(switchBlock, true) && DeobfuscateStLdloc(switchBlock))
				return true;

			if (IsSwitchType1(switchBlock) && DeobfuscateType1(switchBlock))
				return true;

			if (IsSwitchType2(switchBlock) && DeobfuscateType2(switchBlock))
				return true;

			if (switchBlock.FirstInstr.IsLdloc() && FixSwitchBranch(switchBlock))
				return true;

			return false;
		}

		static bool IsSwitchTopOfStack(Block switchBlock) => switchBlock.Instructions.Count == 1;

		static bool IsLdlocBranch(Block switchBlock, bool isSwitch) {
			int numInstrs = 1 + (isSwitch ? 1 : 0);
			return switchBlock.Instructions.Count == numInstrs && switchBlock.Instructions[0].IsLdloc();
		}

		static bool IsSwitchType1(Block switchBlock) => switchBlock.FirstInstr.IsLdloc();

		bool IsSwitchType2(Block switchBlock) {
			Local local = null;
			foreach (var instr in switchBlock.Instructions) {
				if (!instr.IsLdloc())
					continue;
				local = Instr.GetLocalVar(blocks.Locals, instr);
				break;
			}
			if (local == null)
				return false;

			foreach (var source in switchBlock.Sources) {
				var instrs = source.Instructions;
				for (int i = 1; i < instrs.Count; i++) {
					var ldci4 = instrs[i - 1];
					if (!ldci4.IsLdcI4())
						continue;
					var stloc = instrs[i];
					if (!stloc.IsStloc())
						continue;
					if (Instr.GetLocalVar(blocks.Locals, stloc) != local)
						continue;

					return true;
				}
			}

			return false;
		}

		bool IsStLdlocBranch(Block switchBlock, bool isSwitch) {
			int numInstrs = 2 + (isSwitch ? 1 : 0);
			return switchBlock.Instructions.Count == numInstrs &&
				switchBlock.Instructions[0].IsStloc() &&
				switchBlock.Instructions[1].IsLdloc() &&
				Instr.GetLocalVar(blocks.Locals, switchBlock.Instructions[0]) == Instr.GetLocalVar(blocks.Locals, switchBlock.Instructions[1]);
		}

		bool DeobfuscateTOS(Block switchBlock) {
			bool modified = false;
			if (switchBlock.Targets == null)
				return modified;
			var targets = new List<Block>(switchBlock.Targets);

			modified |= DeobfuscateTOS(targets, switchBlock.FallThrough, switchBlock);

			return modified;
		}

		bool DeobfuscateLdloc(Block switchBlock) {
			bool modified = false;

			var switchVariable = Instr.GetLocalVar(blocks.Locals, switchBlock.Instructions[0]);
			if (switchVariable == null)
				return modified;

			if (switchBlock.Targets == null)
				return modified;
			var targets = new List<Block>(switchBlock.Targets);

			modified |= DeobfuscateLdloc(targets, switchBlock.FallThrough, switchBlock, switchVariable);

			return modified;
		}

		bool DeobfuscateStLdloc(Block switchBlock) {
			bool modified = false;

			var switchVariable = Instr.GetLocalVar(blocks.Locals, switchBlock.Instructions[0]);
			if (switchVariable == null)
				return modified;

			if (switchBlock.Targets == null)
				return modified;
			var targets = new List<Block>(switchBlock.Targets);

			modified |= DeobfuscateStLdloc(targets, switchBlock.FallThrough, switchBlock);

			return modified;
		}

		// Switch deobfuscation when block uses stloc N, ldloc N to load switch constant
		//	blk1:
		//		ldc.i4 X
		//		br swblk
		//	swblk:
		//		stloc N
		//		ldloc N
		//		switch (......)
		bool DeobfuscateStLdloc(IList<Block> switchTargets, Block switchFallThrough, Block block) {
			bool modified = false;
			foreach (var source in new List<Block>(block.Sources)) {
				if (!IsBranchBlock(source))
					continue;
				instructionEmulator.Initialize(blocks, allBlocks[0] == source);
				instructionEmulator.Emulate(source.Instructions);

				var target = GetSwitchTarget(switchTargets, switchFallThrough, instructionEmulator.Pop());
				if (target == null)
					continue;
				source.ReplaceLastNonBranchWithBranch(0, target);
				source.Add(new Instr(OpCodes.Pop.ToInstruction()));
				modified = true;
			}
			return modified;
		}

		// Switch deobfuscation when block uses ldloc N to load switch constant
		//	blk1:
		//		ldc.i4 X
		//		stloc N
		//		br swblk / bcc swblk
		//	swblk:
		//		ldloc N
		//		switch (......)
		bool DeobfuscateLdloc(IList<Block> switchTargets, Block switchFallThrough, Block block, Local switchVariable) {
			bool modified = false;
			foreach (var source in new List<Block>(block.Sources)) {
				if (IsBranchBlock(source)) {
					instructionEmulator.Initialize(blocks, allBlocks[0] == source);
					instructionEmulator.Emulate(source.Instructions);

					var target = GetSwitchTarget(switchTargets, switchFallThrough, instructionEmulator.GetLocal(switchVariable));
					if (target == null)
						continue;
					source.ReplaceLastNonBranchWithBranch(0, target);
					modified = true;
				}
				else if (IsBccBlock(source)) {
					instructionEmulator.Initialize(blocks, allBlocks[0] == source);
					instructionEmulator.Emulate(source.Instructions);

					var target = GetSwitchTarget(switchTargets, switchFallThrough, instructionEmulator.GetLocal(switchVariable));
					if (target == null)
						continue;
					if (source.Targets[0] == block) {
						source.SetNewTarget(0, target);
						modified = true;
					}
					if (source.FallThrough == block) {
						source.SetNewFallThrough(target);
						modified = true;
					}
				}
			}
			return modified;
		}

		// Switch deobfuscation when block has switch contant on TOS:
		//	blk1:
		//		ldc.i4 X
		//		br swblk
		//	swblk:
		//		switch (......)
		bool DeobfuscateTOS(IList<Block> switchTargets, Block switchFallThrough, Block block) {
			bool modified = false;
			foreach (var source in new List<Block>(block.Sources)) {
				if (!IsBranchBlock(source))
					continue;
				instructionEmulator.Initialize(blocks, allBlocks[0] == source);
				instructionEmulator.Emulate(source.Instructions);

				var target = GetSwitchTarget(switchTargets, switchFallThrough, instructionEmulator.Pop());
				if (target == null) {
					modified |= DeobfuscateTos_Ldloc(switchTargets, switchFallThrough, source);
				}
				else {
					source.ReplaceLastNonBranchWithBranch(0, target);
					source.Add(new Instr(OpCodes.Pop.ToInstruction()));
					modified = true;
				}
			}
			return modified;
		}

		//		ldloc N
		//		br swblk
		// or
		//		stloc N
		//		ldloc N
		//		br swblk
		bool DeobfuscateTos_Ldloc(IList<Block> switchTargets, Block switchFallThrough, Block block) {
			if (IsLdlocBranch(block, false)) {
				var switchVariable = Instr.GetLocalVar(blocks.Locals, block.Instructions[0]);
				if (switchVariable == null)
					return false;
				return DeobfuscateLdloc(switchTargets, switchFallThrough, block, switchVariable);
			}
			else if (IsStLdlocBranch(block, false))
				return DeobfuscateStLdloc(switchTargets, switchFallThrough, block);

			return false;
		}

		static bool IsBranchBlock(Block block) {
			if (block.Targets != null)
				return false;
			if (block.FallThrough == null)
				return false;
			switch (block.LastInstr.OpCode.Code) {
			case Code.Switch:
			case Code.Leave:
			case Code.Leave_S:
				return false;
			default:
				return true;
			}
		}

		static bool IsBccBlock(Block block) {
			if (block.Targets == null || block.Targets.Count != 1)
				return false;
			if (block.FallThrough == null)
				return false;
			switch (block.LastInstr.OpCode.Code) {
			case Code.Beq:
			case Code.Beq_S:
			case Code.Bge:
			case Code.Bge_S:
			case Code.Bge_Un:
			case Code.Bge_Un_S:
			case Code.Bgt:
			case Code.Bgt_S:
			case Code.Bgt_Un:
			case Code.Bgt_Un_S:
			case Code.Ble:
			case Code.Ble_S:
			case Code.Ble_Un:
			case Code.Ble_Un_S:
			case Code.Blt:
			case Code.Blt_S:
			case Code.Blt_Un:
			case Code.Blt_Un_S:
			case Code.Bne_Un:
			case Code.Bne_Un_S:
			case Code.Brfalse:
			case Code.Brfalse_S:
			case Code.Brtrue:
			case Code.Brtrue_S:
				return true;
			default:
				return false;
			}
		}

		bool DeobfuscateType1(Block switchBlock) {
			if (!EmulateGetTarget(switchBlock, out var target) || target != null)
				return false;

			bool modified = false;

			foreach (var source in new List<Block>(switchBlock.Sources)) {
				if (!source.CanAppend(switchBlock))
					continue;
				if (!WillHaveKnownTarget(switchBlock, source))
					continue;

				source.Append(switchBlock);
				modified = true;
			}

			return modified;
		}

		bool DeobfuscateType2(Block switchBlock) {
			bool modified = false;

			var bccSources = new List<Block>();
			foreach (var source in new List<Block>(switchBlock.Sources)) {
				if (source.LastInstr.IsConditionalBranch()) {
					bccSources.Add(source);
					continue;
				}
				if (!source.CanAppend(switchBlock))
					continue;
				if (!WillHaveKnownTarget(switchBlock, source))
					continue;

				source.Append(switchBlock);
				modified = true;
			}

			foreach (var bccSource in bccSources) {
				if (!WillHaveKnownTarget(switchBlock, bccSource))
					continue;
				var consts = GetBccLocalConstants(bccSource);
				if (consts.Count == 0)
					continue;
				var newFallThrough = CreateBlock(consts, bccSource.FallThrough);
				var newTarget = CreateBlock(consts, bccSource.Targets[0]);
				var oldFallThrough = bccSource.FallThrough;
				var oldTarget = bccSource.Targets[0];
				bccSource.SetNewFallThrough(newFallThrough);
				bccSource.SetNewTarget(0, newTarget);
				newFallThrough.SetNewFallThrough(oldFallThrough);
				newTarget.SetNewFallThrough(oldTarget);
				modified = true;
			}

			return modified;
		}

		static Block CreateBlock(Dictionary<Local, int> consts, Block fallThrough) {
			var block = new Block();
			foreach (var kv in consts) {
				block.Instructions.Add(new Instr(Instruction.CreateLdcI4(kv.Value)));
				block.Instructions.Add(new Instr(OpCodes.Stloc.ToInstruction(kv.Key)));
			}
			fallThrough.Parent.Add(block);
			return block;
		}

		Dictionary<Local, int> GetBccLocalConstants(Block block) {
			var dict = new Dictionary<Local, int>();
			var instrs = block.Instructions;
			for (int i = 0; i < instrs.Count; i++) {
				var instr = instrs[i];
				if (instr.IsStloc()) {
					var local = Instr.GetLocalVar(blocks.Locals, instr);
					if (local == null)
						continue;
					var ldci4 = i == 0 ? null : instrs[i - 1];
					if (ldci4 == null || !ldci4.IsLdcI4())
						dict.Remove(local);
					else
						dict[local] = ldci4.GetLdcI4Value();
				}
				else if (instr.IsLdloc()) {
					var local = Instr.GetLocalVar(blocks.Locals, instr);
					if (local != null)
						dict.Remove(local);
				}
				else if (instr.OpCode.Code == Code.Ldloca || instr.OpCode.Code == Code.Ldloca_S) {
					if (instr.Operand is Local local)
						dict.Remove(local);
				}
			}
			return dict;
		}

		bool EmulateGetTarget(Block switchBlock, out Block target) {
			instructionEmulator.Initialize(blocks, allBlocks[0] == switchBlock);
			try {
				instructionEmulator.Emulate(switchBlock.Instructions, 0, switchBlock.Instructions.Count - 1);
			}
			catch (NullReferenceException) {
				// Here if eg. invalid metadata token in a call instruction (operand is null)
				target = null;
				return false;
			}
			target = GetTarget(switchBlock);
			return true;
		}

		bool WillHaveKnownTarget(Block switchBlock, Block source) {
			instructionEmulator.Initialize(blocks, allBlocks[0] == source);
			try {
				instructionEmulator.Emulate(source.Instructions);
				instructionEmulator.Emulate(switchBlock.Instructions, 0, switchBlock.Instructions.Count - 1);
			}
			catch (NullReferenceException) {
				// Here if eg. invalid metadata token in a call instruction (operand is null)
				return false;
			}
			return GetTarget(switchBlock) != null;
		}

		Block GetTarget(Block switchBlock) {
			var val1 = instructionEmulator.Pop();
			if (!val1.IsInt32())
				return null;
			return CflowUtils.GetSwitchTarget(switchBlock.Targets, switchBlock.FallThrough, (Int32Value)val1);
		}

		static Block GetSwitchTarget(IList<Block> targets, Block fallThrough, Value value) {
			if (!value.IsInt32())
				return null;
			return CflowUtils.GetSwitchTarget(targets, fallThrough, (Int32Value)value);
		}

		static bool FixSwitchBranch(Block switchBlock) {
			// Code:
			//	blk1:
			//		ldc.i4 XXX
			//		br common
			//	blk2:
			//		ldc.i4 YYY
			//		br common
			//	common:
			//		stloc X
			//		br swblk
			//	swblk:
			//		ldloc X
			//		switch
			// Inline common into blk1 and blk2.

			bool modified = false;

			foreach (var commonSource in new List<Block>(switchBlock.Sources)) {
				if (commonSource.Instructions.Count != 1)
					continue;
				if (!commonSource.FirstInstr.IsStloc())
					continue;
				foreach (var blk in new List<Block>(commonSource.Sources)) {
					if (blk.CanAppend(commonSource)) {
						blk.Append(commonSource);
						modified = true;
					}
				}
			}

			return modified;
		}
	}
}



================================================
File: de4dot.blocks/cflow/Value.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

namespace de4dot.blocks.cflow {
	public enum ValueType : byte {
		Unknown,
		Null,
		Object,
		Boxed,
		Int32,
		Int64,
		Real8,
		String,
	}

	public enum Bool3 {
		Unknown = -1,
		False,
		True,
	}

	public abstract class Value {
		public readonly ValueType valueType;
		public bool IsUnknown() => valueType == ValueType.Unknown;
		public bool IsNull() => valueType == ValueType.Null;
		public bool IsObject() => valueType == ValueType.Object;
		public bool IsBoxed() => valueType == ValueType.Boxed;
		public bool IsInt32() => valueType == ValueType.Int32;
		public bool IsInt64() => valueType == ValueType.Int64;
		public bool IsReal8() => valueType == ValueType.Real8;
		public bool IsString() => valueType == ValueType.String;
		protected Value(ValueType valueType) => this.valueType = valueType;
	}

	public class UnknownValue : Value {
		public UnknownValue() : base(ValueType.Unknown) { }
		public override string ToString() => "<unknown>";
	}

	public class ObjectValue : Value {
		public readonly object obj;	// can be null but that doesn't mean that this ObjectValue instance is null
		public ObjectValue() : this(null) { }
		public ObjectValue(object obj) : base(ValueType.Object) => this.obj = obj;
		public override string ToString() => "<non-null object>";
	}

	public class NullValue : Value {
		// There's only one type of null
		public static readonly NullValue Instance = new NullValue();
		NullValue() : base(ValueType.Null) { }
		public override string ToString() => "null";
	}

	public class BoxedValue : Value {
		public readonly Value value;
		public BoxedValue(Value value) : base(ValueType.Boxed) => this.value = value;
		public override string ToString() => $"box({value.ToString()})";
	}

	public class StringValue : Value {
		public readonly string value;
		public StringValue(string value) : base(ValueType.String) => this.value = value;
		public override string ToString() => $"\"{value}\"";
	}
}



================================================
File: de4dot.blocks/cflow/ValueStack.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Text;
using System.Collections.Generic;

namespace de4dot.blocks.cflow {
	class ValueStack {
		List<Value> stack = new List<Value>();

		public int Size => stack.Count;
		public void Initialize() => stack.Clear();
		public void Clear() => stack.Clear();
		public void Push(Value value) => stack.Add(value);

		public Value Peek() {
			if (stack.Count == 0)
				return new UnknownValue();
			return stack[stack.Count - 1];
		}

		public Value Pop() {
			var value = Peek();
			if (stack.Count != 0)
				stack.RemoveAt(stack.Count - 1);
			return value;
		}

		public void Push(int count) {
			if (count < 0)
				throw new ArgumentOutOfRangeException("count");
			for (int i = 0; i < count; i++)
				PushUnknown();
		}

		public void PushUnknown() => Push(new UnknownValue());

		public void Pop(int count) {
			if (count < 0)
				throw new ArgumentOutOfRangeException("count");
			if (count >= stack.Count)
				stack.Clear();
			else if (count > 0)
				stack.RemoveRange(stack.Count - count, count);
		}

		public void CopyTop() => Push(Peek());

		public override string ToString() {
			if (stack.Count == 0)
				return "<empty>";

			var sb = new StringBuilder();
			const int maxValues = 5;
			for (int i = 0; i < maxValues; i++) {
				int index = stack.Count - i - 1;
				if (index < 0)
					break;
				if (i > 0)
					sb.Append(", ");
				sb.Append(stack[index].ToString());
			}
			if (maxValues < stack.Count)
				sb.Append(", ...");
			return sb.ToString();
		}
	}
}



================================================
File: de4dot.code/AssemblyModule.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using dnlib.DotNet;
using dnlib.DotNet.Writer;

namespace de4dot.code {
	public interface IModuleWriterListener {
		void OnWriterEvent(ModuleWriterBase writer, ModuleWriterEvent evt);
	}

	public class AssemblyModule {
		string filename;
		ModuleDefMD module;
		ModuleContext moduleContext;

		public AssemblyModule(string filename, ModuleContext moduleContext) {
			this.filename = Utils.GetFullPath(filename);
			this.moduleContext = moduleContext;
		}

		public ModuleDefMD Load() {
			var options = new ModuleCreationOptions(moduleContext) { TryToLoadPdbFromDisk = false };
			return SetModule(ModuleDefMD.Load(filename, options));
		}

		public ModuleDefMD Load(byte[] fileData) {
			var options = new ModuleCreationOptions(moduleContext) { TryToLoadPdbFromDisk = false };
			return SetModule(ModuleDefMD.Load(fileData, options));
		}

		ModuleDefMD SetModule(ModuleDefMD newModule) {
			module = newModule;
			TheAssemblyResolver.Instance.AddModule(module);
			module.EnableTypeDefFindCache = true;
			module.Location = filename;
			return module;
		}

		public void Save(string newFilename, MetadataFlags mdFlags, IModuleWriterListener writerListener) {
			if (module.IsILOnly) {
				var writerOptions = new ModuleWriterOptions(module);
				writerOptions.WriterEvent += (s, e) => writerListener?.OnWriterEvent(e.Writer, e.Event);
				writerOptions.MetadataOptions.Flags |= mdFlags;
				writerOptions.Logger = Logger.Instance;
				module.Write(newFilename, writerOptions);
			}
			else {
				var writerOptions = new NativeModuleWriterOptions(module, optimizeImageSize: true);
				writerOptions.WriterEvent += (s, e) => writerListener?.OnWriterEvent(e.Writer, e.Event);
				writerOptions.MetadataOptions.Flags |= mdFlags;
				writerOptions.Logger = Logger.Instance;
				writerOptions.KeepExtraPEData = true;
				writerOptions.KeepWin32Resources = true;
				module.NativeWrite(newFilename, writerOptions);
			}
		}

		public ModuleDefMD Reload(byte[] newModuleData, DumpedMethodsRestorer dumpedMethodsRestorer, IStringDecrypter stringDecrypter) {
			TheAssemblyResolver.Instance.Remove(module);
			var options = new ModuleCreationOptions(moduleContext) { TryToLoadPdbFromDisk = false };
			var mod = ModuleDefMD.Load(newModuleData, options);
			if (dumpedMethodsRestorer != null)
				dumpedMethodsRestorer.Module = mod;
			mod.StringDecrypter = stringDecrypter;
			mod.MethodDecrypter = dumpedMethodsRestorer;
			mod.TablesStream.ColumnReader = dumpedMethodsRestorer;
			mod.TablesStream.MethodRowReader = dumpedMethodsRestorer;
			return SetModule(mod);
		}

		public override string ToString() => filename;
	}
}



================================================
File: de4dot.code/AssemblyResolver.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.IO;
using System.Text.RegularExpressions;
using dnlib.DotNet;

namespace de4dot.code {
	public class TheAssemblyResolver : AssemblyResolver {
		public static readonly TheAssemblyResolver Instance = new TheAssemblyResolver();

		public TheAssemblyResolver() {
			EnableTypeDefCache = true;
			AddOtherSearchPaths(PostSearchPaths);
		}

		public void AddSearchDirectory(string dir) {
			if (!PostSearchPaths.Contains(dir))
				PostSearchPaths.Add(dir);
		}

		public void AddModule(ModuleDef module) => AddToCache(module.Assembly);

		public void RemoveModule(ModuleDef module) {
			var assembly = module.Assembly;
			if (assembly == null)
				return;

			Remove(module.Assembly);
		}

		public void ClearAll() {
			//TODO: cache.Clear();
			//TODO: resetSearchPaths();
		}

		static void AddOtherSearchPaths(IList<string> paths) {
			var dirPF = Environment.GetEnvironmentVariable("ProgramFiles");
			AddOtherAssemblySearchPaths(paths, dirPF);
			var dirPFx86 = Environment.GetEnvironmentVariable("ProgramFiles(x86)");
			if (!StringComparer.OrdinalIgnoreCase.Equals(dirPF, dirPFx86))
				AddOtherAssemblySearchPaths(paths, dirPFx86);

			var windir = Environment.GetEnvironmentVariable("WINDIR");
			if (!string.IsNullOrEmpty(windir)) {
				AddIfExists(paths, windir, @"Microsoft.NET\Framework\v1.1.4322");
				AddIfExists(paths, windir, @"Microsoft.NET\Framework\v1.0.3705");
			}
		}

		static void AddOtherAssemblySearchPaths(IList<string> paths, string path) {
			if (string.IsNullOrEmpty(path))
				return;
			AddSilverlightDirs(paths, Path.Combine(path, @"Microsoft Silverlight"));
			AddIfExists(paths, path, @"Microsoft SDKs\Silverlight\v2.0\Libraries\Client");
			AddIfExists(paths, path, @"Microsoft SDKs\Silverlight\v2.0\Libraries\Server");
			AddIfExists(paths, path, @"Microsoft SDKs\Silverlight\v2.0\Reference Assemblies");
			AddIfExists(paths, path, @"Microsoft SDKs\Silverlight\v3.0\Libraries\Client");
			AddIfExists(paths, path, @"Microsoft SDKs\Silverlight\v3.0\Libraries\Server");
			AddIfExists(paths, path, @"Microsoft SDKs\Silverlight\v4.0\Libraries\Client");
			AddIfExists(paths, path, @"Microsoft SDKs\Silverlight\v4.0\Libraries\Server");
			AddIfExists(paths, path, @"Microsoft SDKs\Silverlight\v5.0\Libraries\Client");
			AddIfExists(paths, path, @"Microsoft SDKs\Silverlight\v5.0\Libraries\Server");
			AddIfExists(paths, path, @"Microsoft.NET\SDK\CompactFramework\v2.0\WindowsCE");
			AddIfExists(paths, path, @"Microsoft.NET\SDK\CompactFramework\v3.5\WindowsCE");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\.NETFramework\v4.6.1");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\.NETFramework\v4.6");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.1");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\.NETFramework\v4.0");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\.NETFramework\v4.0\Profile\Client");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\.NETFramework\v3.5\Profile\Client");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\.NETCore\v5.0");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\.NETCore\v4.5.1");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\.NETCore\v4.5");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\.NETMicroFramework\v3.0");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\.NETMicroFramework\v4.0");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\.NETMicroFramework\v4.1");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\.NETMicroFramework\v4.2");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\.NETMicroFramework\v4.3");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\.NETPortable\v4.0");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\.NETPortable\v4.5");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\.NETPortable\v4.6");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\.NETPortable\v5.0");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\v3.0");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\v3.5");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\Silverlight\v3.0");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\Silverlight\v4.0");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\Silverlight\v5.0");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\WindowsPhone\v8.1");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\WindowsPhoneApp\v8.1");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\FSharp\.NETCore\3.259.4.0");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\FSharp\.NETCore\3.259.3.1");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\FSharp\.NETCore\3.78.4.0");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\FSharp\.NETCore\3.78.3.1");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\FSharp\.NETCore\3.7.4.0");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\FSharp\.NETCore\3.3.1.0");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\FSharp\.NETFramework\v2.0\2.3.0.0");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\FSharp\.NETFramework\v4.0\4.3.0.0");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\FSharp\.NETFramework\v4.0\4.3.1.0");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\FSharp\.NETFramework\v4.0\4.4.0.0");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\FSharp\.NETPortable\2.3.5.0");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\FSharp\.NETPortable\2.3.5.1");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\FSharp\.NETPortable\3.47.4.0");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\FSharp\2.0\Runtime\v2.0");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\FSharp\2.0\Runtime\v4.0");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\FSharp\3.0\Runtime\.NETPortable");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\FSharp\3.0\Runtime\v2.0");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\FSharp\3.0\Runtime\v4.0");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\WindowsPowerShell\v1.0");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\WindowsPowerShell\3.0");
			AddIfExists(paths, path, @"Microsoft Visual Studio .NET\Common7\IDE\PublicAssemblies");
			AddIfExists(paths, path, @"Microsoft Visual Studio .NET\Common7\IDE\PrivateAssemblies");
			AddIfExists(paths, path, @"Microsoft Visual Studio .NET 2003\Common7\IDE\PublicAssemblies");
			AddIfExists(paths, path, @"Microsoft Visual Studio .NET 2003\Common7\IDE\PrivateAssemblies");
			AddIfExists(paths, path, @"Microsoft Visual Studio 8\Common7\IDE\PublicAssemblies");
			AddIfExists(paths, path, @"Microsoft Visual Studio 8\Common7\IDE\PrivateAssemblies");
			AddIfExists(paths, path, @"Microsoft Visual Studio 9.0\Common7\IDE\PublicAssemblies");
			AddIfExists(paths, path, @"Microsoft Visual Studio 9.0\Common7\IDE\PrivateAssemblies");
			AddIfExists(paths, path, @"Microsoft Visual Studio 10.0\Common7\IDE\PublicAssemblies");
			AddIfExists(paths, path, @"Microsoft Visual Studio 10.0\Common7\IDE\PrivateAssemblies");
			AddIfExists(paths, path, @"Microsoft Visual Studio 11.0\Common7\IDE\PublicAssemblies");
			AddIfExists(paths, path, @"Microsoft Visual Studio 11.0\Common7\IDE\PrivateAssemblies");
			AddIfExists(paths, path, @"Microsoft Visual Studio 12.0\Common7\IDE\PublicAssemblies");
			AddIfExists(paths, path, @"Microsoft Visual Studio 12.0\Common7\IDE\PrivateAssemblies");
			AddIfExists(paths, path, @"Microsoft Visual Studio 14.0\Common7\IDE\PublicAssemblies");
			AddIfExists(paths, path, @"Microsoft Visual Studio 14.0\Common7\IDE\PrivateAssemblies");
			AddIfExists(paths, path, @"Microsoft XNA\XNA Game Studio\v2.0\References\Windows\x86");
			AddIfExists(paths, path, @"Microsoft XNA\XNA Game Studio\v2.0\References\Xbox360");
			AddIfExists(paths, path, @"Microsoft XNA\XNA Game Studio\v3.0\References\Windows\x86");
			AddIfExists(paths, path, @"Microsoft XNA\XNA Game Studio\v3.0\References\Xbox360");
			AddIfExists(paths, path, @"Microsoft XNA\XNA Game Studio\v3.0\References\Zune");
			AddIfExists(paths, path, @"Microsoft XNA\XNA Game Studio\v3.1\References\Windows\x86");
			AddIfExists(paths, path, @"Microsoft XNA\XNA Game Studio\v3.1\References\Xbox360");
			AddIfExists(paths, path, @"Microsoft XNA\XNA Game Studio\v3.1\References\Zune");
			AddIfExists(paths, path, @"Microsoft XNA\XNA Game Studio\v4.0\References\Windows\x86");
			AddIfExists(paths, path, @"Microsoft XNA\XNA Game Studio\v4.0\References\Xbox360");
			AddIfExists(paths, path, @"Windows CE Tools\wce500\Windows Mobile 5.0 Pocket PC SDK\Designtimereferences");
			AddIfExists(paths, path, @"Windows CE Tools\wce500\Windows Mobile 5.0 Smartphone SDK\Designtimereferences");
			AddIfExists(paths, path, @"Windows Mobile 5.0 SDK R2\Managed Libraries");
			AddIfExists(paths, path, @"Windows Mobile 6 SDK\Managed Libraries");
			AddIfExists(paths, path, @"Windows Mobile 6.5.3 DTK\Managed Libraries");
			AddIfExists(paths, path, @"Microsoft SQL Server\90\SDK\Assemblies");
			AddIfExists(paths, path, @"Microsoft SQL Server\100\SDK\Assemblies");
			AddIfExists(paths, path, @"Microsoft SQL Server\110\SDK\Assemblies");
			AddIfExists(paths, path, @"Microsoft SQL Server\120\SDK\Assemblies");
			AddIfExists(paths, path, @"Microsoft ASP.NET\ASP.NET MVC 2\Assemblies");
			AddIfExists(paths, path, @"Microsoft ASP.NET\ASP.NET MVC 3\Assemblies");
			AddIfExists(paths, path, @"Microsoft ASP.NET\ASP.NET MVC 4\Assemblies");
			AddIfExists(paths, path, @"Microsoft ASP.NET\ASP.NET Web Pages\v1.0\Assemblies");
			AddIfExists(paths, path, @"Microsoft ASP.NET\ASP.NET Web Pages\v2.0\Assemblies");
			AddIfExists(paths, path, @"Microsoft SDKs\F#\3.0\Framework\v4.0");
		}

		static void AddSilverlightDirs(IList<string> paths, string basePath) {
			if (!Directory.Exists(basePath))
				return;
			try {
				var di = new DirectoryInfo(basePath);
				foreach (var dir in di.GetDirectories()) {
					if (Regex.IsMatch(dir.Name, @"^\d+(?:\.\d+){3}$"))
						AddIfExists(paths, basePath, dir.Name);
				}
			}
			catch {
			}
		}

		static void AddIfExists(IList<string> paths, string basePath, string extraPath) {
			var path = Path.Combine(basePath, extraPath);
			if (Directory.Exists(path))
				paths.Add(path);
		}
	}
}



================================================
File: de4dot.code/DeobfuscatorContext.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet;

namespace de4dot.code {
	// "global" data and methods that is shared between all deobfuscators that deobfuscate
	// assemblies at the same time.
	public class DeobfuscatorContext : IDeobfuscatorContext {
		Dictionary<string, object> dataDict = new Dictionary<string, object>(StringComparer.Ordinal);

		public void Clear() => dataDict.Clear();
		public void SetData(string name, object data) => dataDict[name] = data;

		public object GetData(string name) {
			dataDict.TryGetValue(name, out object value);
			return value;
		}

		public void ClearData(string name) => dataDict.Remove(name);

		static ITypeDefOrRef GetNonGenericTypeRef(ITypeDefOrRef typeRef) {
			var ts = typeRef as TypeSpec;
			if (ts == null)
				return typeRef;
			var gis = ts.TryGetGenericInstSig();
			if (gis == null || gis.GenericType == null)
				return typeRef;
			return gis.GenericType.TypeDefOrRef;
		}

		public TypeDef ResolveType(ITypeDefOrRef type) {
			if (type == null)
				return null;
			type = GetNonGenericTypeRef(type);

			if (type is TypeDef typeDef)
				return typeDef;

			if (type is TypeRef tr)
				return tr.Resolve();

			return null;
		}

		public MethodDef ResolveMethod(IMethod method) {
			if (method == null)
				return null;

			if (method is MethodDef md)
				return md;

			var mr = method as MemberRef;
			if (mr == null || !mr.IsMethodRef)
				return null;

			var type = ResolveType(mr.DeclaringType);
			if (type == null)
				return null;

			return type.Resolve(mr) as MethodDef;
		}

		public FieldDef ResolveField(IField field) {
			if (field == null)
				return null;

			if (field is FieldDef fd)
				return fd;

			var mr = field as MemberRef;
			if (mr == null || !mr.IsFieldRef)
				return null;

			var type = ResolveType(mr.DeclaringType);
			if (type == null)
				return null;

			return type.Resolve(mr) as FieldDef;
		}
	}
}



================================================
File: de4dot.code/DumpedMethodsRestorer.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.PE;
using dnlib.DotNet.MD;
using dnlib.DotNet.Emit;
using dnlib.DotNet;
using de4dot.blocks;

namespace de4dot.code {
	public class DumpedMethodsRestorer : IRowReader<RawMethodRow>, IColumnReader, IMethodDecrypter {
		ModuleDefMD module;
		DumpedMethods dumpedMethods;

		public ModuleDefMD Module {
			set => module = value;
		}

		public DumpedMethodsRestorer(DumpedMethods dumpedMethods) => this.dumpedMethods = dumpedMethods;

		DumpedMethod GetDumpedMethod(uint rid) => dumpedMethods.Get(0x06000000 | rid);

		public bool TryReadRow(uint rid, out RawMethodRow row) {
			var dm = GetDumpedMethod(rid);
			if (dm == null) {
				row = default;
				return false;
			}
			else {
				row = new RawMethodRow(dm.mdRVA, dm.mdImplFlags, dm.mdFlags, dm.mdName, dm.mdSignature, dm.mdParamList);
				return true;
			}
		}

		public bool ReadColumn(MDTable table, uint rid, ColumnInfo column, out uint value) {
			if (table.Table == Table.Method) {
				if (TryReadRow(rid, out var row)) {
					value = row[column.Index];
					return true;
				}
			}

			value = 0;
			return false;
		}

		public bool GetMethodBody(uint rid, RVA rva, IList<Parameter> parameters, GenericParamContext gpContext, out MethodBody methodBody) {
			var dm = GetDumpedMethod(rid);
			if (dm == null) {
				methodBody = null;
				return false;
			}
			methodBody = MethodBodyReader.CreateCilBody(module, dm.code, dm.extraSections, parameters, dm.mhFlags, dm.mhMaxStack, dm.mhCodeSize, dm.mhLocalVarSigTok, gpContext);
			return true;
		}
	}
}



================================================
File: de4dot.code/HandleProcessCorruptedStateExceptionsAttribute.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

#if NET35
namespace System.Runtime.ExceptionServices {
	[AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
	public class HandleProcessCorruptedStateExceptionsAttribute : Attribute {
	}
}
#endif



================================================
File: de4dot.code/IDeobfuscatorContext.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using dnlib.DotNet;

namespace de4dot.code {
	public interface IDeobfuscatorContext {
		void Clear();
		void SetData(string name, object data);
		object GetData(string name);
		void ClearData(string name);
		TypeDef ResolveType(ITypeDefOrRef type);
		MethodDef ResolveMethod(IMethod method);
		FieldDef ResolveField(IField field);
	}
}



================================================
File: de4dot.code/IObfuscatedFile.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using de4dot.code.deobfuscators;
using dnlib.DotNet;
using de4dot.code.renamer;

namespace de4dot.code {
	public interface IObfuscatedFile : IDisposable {
		ModuleDefMD ModuleDefMD { get; }
		IDeobfuscator Deobfuscator { get; }
		IDeobfuscatorContext DeobfuscatorContext { get; set; }
		string Filename { get; }
		string NewFilename { get; }
		INameChecker NameChecker { get; }
		bool RenameResourcesInCode { get; }
		bool RemoveNamespaceWithOneType { get; }
		bool RenameResourceKeys { get; }

		void DeobfuscateBegin();
		void Deobfuscate();
		void DeobfuscateEnd();
		void DeobfuscateCleanUp();

		void Load(IList<IDeobfuscator> deobfuscators);
		void Save();
	}
}



================================================
File: de4dot.code/Logger.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet;

namespace de4dot.code {
	public class Logger : ILogger {
		public readonly static Logger Instance = new Logger();

		int indentLevel = 0;
		readonly int indentSize = 0;
		LoggerEvent maxLoggerEvent = LoggerEvent.Info;
		string indentString = "";
		Dictionary<string, bool> ignoredMessages = new Dictionary<string, bool>(StringComparer.Ordinal);
		int numIgnoredMessages;
		bool canIgnoreMessages;

		public int IndentLevel {
			get => indentLevel;
			set {
				if (indentLevel == value)
					return;
				indentLevel = value;
				InitIndentString();
			}
		}

		public LoggerEvent MaxLoggerEvent {
			get => maxLoggerEvent;
			set => maxLoggerEvent = value;
		}

		public bool CanIgnoreMessages {
			get => canIgnoreMessages;
			set => canIgnoreMessages = value;
		}

		public int NumIgnoredMessages => numIgnoredMessages;

		public Logger() : this(2, true) { }

		public Logger(int indentSize, bool canIgnoreMessages) {
			this.indentSize = indentSize;
			this.canIgnoreMessages = canIgnoreMessages;
		}

		void InitIndentString() {
			if (indentLevel < 0)
				indentLevel = 0;
			indentString = new string(' ', indentLevel * indentSize);
		}

		public void Indent() {
			indentLevel++;
			InitIndentString();
		}

		public void DeIndent() {
			indentLevel--;
			InitIndentString();
		}

		public void Log(object sender, LoggerEvent loggerEvent, string format, params object[] args) => Log(true, sender, loggerEvent, format, args);
		public void LogErrorDontIgnore(string format, params object[] args) => Log(false, null, LoggerEvent.Error, format, args);

		public void Log(bool canIgnore, object sender, LoggerEvent loggerEvent, string format, params object[] args) {
			if (IgnoresEvent(loggerEvent))
				return;
			if (canIgnore && IgnoreMessage(loggerEvent, format, args))
				return;

			switch (loggerEvent) {
			case LoggerEvent.Error:
				foreach (var l in string.Format(format, args).Split('\n'))
					LogMessage(string.Empty, $"ERROR: {l}");
				break;

			case LoggerEvent.Warning:
				foreach (var l in string.Format(format, args).Split('\n'))
					LogMessage(string.Empty, $"WARNING: {l}");
				break;

			default:
				var indent = loggerEvent <= LoggerEvent.Warning ? "" : indentString;
				LogMessage(indent, format, args);
				break;
			}
		}

		bool IgnoreMessage(LoggerEvent loggerEvent, string format, object[] args) {
			if (loggerEvent != LoggerEvent.Error && loggerEvent != LoggerEvent.Warning)
				return false;
			if (!canIgnoreMessages)
				return false;
			if (ignoredMessages.ContainsKey(format)) {
				numIgnoredMessages++;
				return true;
			}
			ignoredMessages[format] = true;
			return false;
		}

		void LogMessage(string indent, string format, params object[] args) {
			if (args == null || args.Length == 0)
				Console.WriteLine("{0}{1}", indent, format);
			else
				Console.WriteLine(indent + format, args);
		}

		public bool IgnoresEvent(LoggerEvent loggerEvent) => loggerEvent > maxLoggerEvent;

		public static void Log(LoggerEvent loggerEvent, string format, params object[] args) => Instance.Log(null, loggerEvent, format, args);
		public static void e(string format, params object[] args) => Instance.Log(null, LoggerEvent.Error, format, args);
		public static void w(string format, params object[] args) => Instance.Log(null, LoggerEvent.Warning, format, args);
		public static void n(string format, params object[] args) => Instance.Log(null, LoggerEvent.Info, format, args);
		public static void v(string format, params object[] args) => Instance.Log(null, LoggerEvent.Verbose, format, args);
		public static void vv(string format, params object[] args) => Instance.Log(null, LoggerEvent.VeryVerbose, format, args);
	}
}



================================================
File: de4dot.code/MethodPrinter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using System.Text;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace de4dot.code {
	public class MethodPrinter {
		LoggerEvent loggerEvent;
		IList<Instruction> allInstructions;
		IList<ExceptionHandler> allExceptionHandlers;
		Dictionary<Instruction, bool> targets = new Dictionary<Instruction, bool>();
		Dictionary<Instruction, string> labels = new Dictionary<Instruction, string>();

		class ExInfo {
			public List<ExceptionHandler> tryStarts = new List<ExceptionHandler>();
			public List<ExceptionHandler> tryEnds = new List<ExceptionHandler>();
			public List<ExceptionHandler> filterStarts = new List<ExceptionHandler>();
			public List<ExceptionHandler> handlerStarts = new List<ExceptionHandler>();
			public List<ExceptionHandler> handlerEnds = new List<ExceptionHandler>();
		}
		Dictionary<Instruction, ExInfo> exInfos = new Dictionary<Instruction, ExInfo>();
		ExInfo lastExInfo;

		public void Print(LoggerEvent loggerEvent, IList<Instruction> allInstructions, IList<ExceptionHandler> allExceptionHandlers) {
			try {
				this.loggerEvent = loggerEvent;
				this.allInstructions = allInstructions;
				this.allExceptionHandlers = allExceptionHandlers;
				lastExInfo = new ExInfo();
				Print();
			}
			finally {
				this.allInstructions = null;
				this.allExceptionHandlers = null;
				targets.Clear();
				labels.Clear();
				exInfos.Clear();
				lastExInfo = null;
			}
		}

		void InitTargets() {
			foreach (var instr in allInstructions) {
				switch (instr.OpCode.OperandType) {
				case OperandType.ShortInlineBrTarget:
				case OperandType.InlineBrTarget:
					SetTarget(instr.Operand as Instruction);
					break;

				case OperandType.InlineSwitch:
					foreach (var targetInstr in (Instruction[])instr.Operand)
						SetTarget(targetInstr);
					break;
				}
			}

			foreach (var ex in allExceptionHandlers) {
				SetTarget(ex.TryStart);
				SetTarget(ex.TryEnd);
				SetTarget(ex.FilterStart);
				SetTarget(ex.HandlerStart);
				SetTarget(ex.HandlerEnd);
			}

			var sortedTargets = new List<Instruction>(targets.Keys);
			sortedTargets.Sort((a, b) => a.Offset.CompareTo(b.Offset));
			for (int i = 0; i < sortedTargets.Count; i++)
				labels[sortedTargets[i]] = $"label_{i}";
		}

		void SetTarget(Instruction instr) {
			if (instr != null)
				targets[instr] = true;
		}

		void InitExHandlers() {
			foreach (var ex in allExceptionHandlers) {
				if (ex.TryStart != null) {
					GetExInfo(ex.TryStart).tryStarts.Add(ex);
					GetExInfo(ex.TryEnd).tryEnds.Add(ex);
				}
				if (ex.FilterStart != null)
					GetExInfo(ex.FilterStart).filterStarts.Add(ex);
				if (ex.HandlerStart != null) {
					GetExInfo(ex.HandlerStart).handlerStarts.Add(ex);
					GetExInfo(ex.HandlerEnd).handlerEnds.Add(ex);
				}
			}
		}

		ExInfo GetExInfo(Instruction instruction) {
			if (instruction == null)
				return lastExInfo;
			if (!exInfos.TryGetValue(instruction, out var exInfo))
				exInfos[instruction] = exInfo = new ExInfo();
			return exInfo;
		}

		void Print() {
			InitTargets();
			InitExHandlers();

			Logger.Instance.Indent();
			foreach (var instr in allInstructions) {
				if (targets.ContainsKey(instr)) {
					Logger.Instance.DeIndent();
					Logger.Log(loggerEvent, "{0}:", GetLabel(instr));
					Logger.Instance.Indent();
				}
				if (exInfos.TryGetValue(instr, out var exInfo))
					PrintExInfo(exInfo);
				var instrString = instr.OpCode.Name;
				var operandString = GetOperandString(instr);
				var memberRef = instr.Operand as ITokenOperand;
				if (operandString == "")
					Logger.Log(loggerEvent, "{0}", instrString);
				else if (memberRef != null)
					Logger.Log(loggerEvent, "{0,-9} {1} // {2:X8}", instrString, Utils.RemoveNewlines(operandString), memberRef.MDToken.ToUInt32());
				else
					Logger.Log(loggerEvent, "{0,-9} {1}", instrString, Utils.RemoveNewlines(operandString));
			}
			PrintExInfo(lastExInfo);
			Logger.Instance.DeIndent();
		}

		string GetOperandString(Instruction instr) {
			if (instr.Operand is Instruction)
				return GetLabel((Instruction)instr.Operand);
			else if (instr.Operand is Instruction[]) {
				var sb = new StringBuilder();
				var targets = (Instruction[])instr.Operand;
				for (int i = 0; i < targets.Length; i++) {
					if (i > 0)
						sb.Append(',');
					sb.Append(GetLabel(targets[i]));
				}
				return sb.ToString();
			}
			else if (instr.Operand is string)
				return Utils.ToCsharpString((string)instr.Operand);
			else if (instr.Operand is Parameter arg) {
				var s = InstructionPrinter.GetOperandString(instr);
				if (s != "")
					return s;
				return $"<arg_{arg.Index}>";
			}
			else
				return InstructionPrinter.GetOperandString(instr);
		}

		void PrintExInfo(ExInfo exInfo) {
			Logger.Instance.DeIndent();
			foreach (var ex in exInfo.tryStarts)
				Logger.Log(loggerEvent, "// try start: {0}", GetExceptionString(ex));
			foreach (var ex in exInfo.tryEnds)
				Logger.Log(loggerEvent, "// try end: {0}", GetExceptionString(ex));
			foreach (var ex in exInfo.filterStarts)
				Logger.Log(loggerEvent, "// filter start: {0}", GetExceptionString(ex));
			foreach (var ex in exInfo.handlerStarts)
				Logger.Log(loggerEvent, "// handler start: {0}", GetExceptionString(ex));
			foreach (var ex in exInfo.handlerEnds)
				Logger.Log(loggerEvent, "// handler end: {0}", GetExceptionString(ex));
			Logger.Instance.Indent();
		}

		string GetExceptionString(ExceptionHandler ex) {
			var sb = new StringBuilder();
			if (ex.TryStart != null)
				sb.Append($"TRY: {GetLabel(ex.TryStart)}-{GetLabel(ex.TryEnd)}");
			if (ex.FilterStart != null)
				sb.Append($", FILTER: {GetLabel(ex.FilterStart)}");
			if (ex.HandlerStart != null)
				sb.Append($", HANDLER: {GetLabel(ex.HandlerStart)}-{GetLabel(ex.HandlerEnd)}");
			sb.Append($", TYPE: {ex.HandlerType}");
			if (ex.CatchType != null)
				sb.Append($", CATCH: {ex.CatchType}");
			return sb.ToString();
		}

		string GetLabel(Instruction instr) {
			if (instr == null)
				return "<end>";
			return labels[instr];
		}
	}
}



================================================
File: de4dot.code/MethodReturnValueInliner.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code {
	// A simple class that statically detects the values of some local variables
	public class VariableValues {
		IList<Block> allBlocks;
		IList<Local> locals;
		Dictionary<Local, Variable> variableToValue = new Dictionary<Local, Variable>();

		public class Variable {
			int writes = 0;
			object value;
			bool unknownValue = false;

			public bool IsValid() => !unknownValue && writes == 1;

			public object Value {
				get {
					if (!IsValid())
						throw new ApplicationException("Unknown variable value");
					return value;
				}
				set => this.value = value;
			}

			public void AddWrite() => writes++;
			public void SetUnknown() => unknownValue = true;
		}

		public VariableValues(IList<Local> locals, IList<Block> allBlocks) {
			this.locals = locals;
			this.allBlocks = allBlocks;
			Initialize();
		}

		void Initialize() {
			foreach (var variable in locals)
				variableToValue[variable] = new Variable();

			foreach (var block in allBlocks) {
				for (int i = 0; i < block.Instructions.Count; i++) {
					var instr = block.Instructions[i];

					switch (instr.OpCode.Code) {
					case Code.Stloc:
					case Code.Stloc_S:
					case Code.Stloc_0:
					case Code.Stloc_1:
					case Code.Stloc_2:
					case Code.Stloc_3:
						var variable = Instr.GetLocalVar(locals, instr);
						var val = variableToValue[variable];
						val.AddWrite();
						object obj;
						if (!GetValue(block, i, out obj))
							val.SetUnknown();
						val.Value = obj;
						break;

					default:
						break;
					}
				}
			}
		}

		bool GetValue(Block block, int index, out object obj) {
			while (true) {
				if (index <= 0) {
					obj = null;
					return false;
				}
				var instr = block.Instructions[--index];
				if (instr.OpCode == OpCodes.Nop)
					continue;

				switch (instr.OpCode.Code) {
				case Code.Ldc_I4:
				case Code.Ldc_I8:
				case Code.Ldc_R4:
				case Code.Ldc_R8:
				case Code.Ldstr:
					obj = instr.Operand;
					return true;
				case Code.Ldc_I4_S:
					obj = (int)(sbyte)instr.Operand;
					return true;

				case Code.Ldc_I4_0: obj = 0; return true;
				case Code.Ldc_I4_1: obj = 1; return true;
				case Code.Ldc_I4_2: obj = 2; return true;
				case Code.Ldc_I4_3: obj = 3; return true;
				case Code.Ldc_I4_4: obj = 4; return true;
				case Code.Ldc_I4_5: obj = 5; return true;
				case Code.Ldc_I4_6: obj = 6; return true;
				case Code.Ldc_I4_7: obj = 7; return true;
				case Code.Ldc_I4_8: obj = 8; return true;
				case Code.Ldc_I4_M1:obj = -1; return true;
				case Code.Ldnull:	obj = null; return true;

				default:
					obj = null;
					return false;
				}
			}
		}

		public Variable GetValue(Local variable) => variableToValue[variable];
	}

	public abstract class MethodReturnValueInliner {
		protected List<CallResult> callResults;
		List<Block> allBlocks;
		MethodDef theMethod;
		VariableValues variableValues;
		int errors = 0;
		bool useUnknownArgs = false;

		public bool UseUnknownArgs {
			get => useUnknownArgs;
			set => useUnknownArgs = value;
		}

		protected class CallResult {
			public Block block;
			public int callStartIndex;
			public int callEndIndex;
			public object[] args;
			public object returnValue;

			public CallResult(Block block, int callEndIndex) {
				this.block = block;
				this.callEndIndex = callEndIndex;
			}

			public IMethod GetMethodRef() => (IMethod)block.Instructions[callEndIndex].Operand;
		}

		public bool InlinedAllCalls => errors == 0;
		public abstract bool HasHandlers { get; }
		public MethodDef Method => theMethod;

		protected abstract void InlineAllCalls();

		// Returns null if method is not a method we should inline
		protected abstract CallResult CreateCallResult(IMethod method, MethodSpec gim, Block block, int callInstrIndex);

		public int Decrypt(Blocks blocks) {
			if (!HasHandlers)
				return 0;
			return Decrypt(blocks.Method, blocks.MethodBlocks.GetAllBlocks());
		}

		public int Decrypt(MethodDef method, List<Block> allBlocks) {
			if (!HasHandlers)
				return 0;
			try {
				theMethod = method;
				callResults = new List<CallResult>();
				this.allBlocks = allBlocks;

				FindAllCallResults();
				InlineAllCalls();
				InlineReturnValues();
				return callResults.Count;
			}
			catch {
				errors++;
				throw;
			}
			finally {
				theMethod = null;
				callResults = null;
				this.allBlocks = null;
				variableValues = null;
			}
		}

		bool GetLocalVariableValue(Local variable, out object value) {
			if (variableValues == null)
				variableValues = new VariableValues(theMethod.Body.Variables, allBlocks);
			var val = variableValues.GetValue(variable);
			if (!val.IsValid()) {
				value = null;
				return false;
			}
			value = val.Value;
			return true;
		}

		void FindAllCallResults() {
			foreach (var block in allBlocks)
				FindCallResults(block);
		}

		void FindCallResults(Block block) {
			for (int i = 0; i < block.Instructions.Count; i++) {
				var instr = block.Instructions[i];
				if (instr.OpCode != OpCodes.Call)
					continue;
				var method = instr.Operand as IMethod;
				if (method == null)
					continue;

				var elementMethod = method;
				var gim = method as MethodSpec;
				if (gim != null)
					elementMethod = gim.Method;
				var callResult = CreateCallResult(elementMethod, gim, block, i);
				if (callResult == null)
					continue;

				if (FindArgs(callResult))
					callResults.Add(callResult);
			}
		}

		bool FindArgs(CallResult callResult) {
			var block = callResult.block;
			var method = callResult.GetMethodRef();
			var methodArgs = DotNetUtils.GetArgs(method);
			int numArgs = methodArgs.Count;
			var args = new object[numArgs];

			int instrIndex = callResult.callEndIndex - 1;
			for (int i = numArgs - 1; i >= 0; i--) {
				object arg = null;
				if (!GetArg(method, block, ref arg, ref instrIndex))
					return false;
				if (arg is int)
					arg = FixIntArg(methodArgs[i], (int)arg);
				else if (arg is long)
					arg = FixIntArg(methodArgs[i], (long)arg);
				args[i] = arg;
			}

			callResult.args = args;
			callResult.callStartIndex = instrIndex + 1;
			return true;
		}

		object FixIntArg(TypeSig type, long value) {
			switch (type.ElementType) {
			case ElementType.Boolean: return value != 0;
			case ElementType.Char: return (char)value;
			case ElementType.I1: return (sbyte)value;
			case ElementType.U1: return (byte)value;
			case ElementType.I2: return (short)value;
			case ElementType.U2: return (ushort)value;
			case ElementType.I4: return (int)value;
			case ElementType.U4: return (uint)value;
			case ElementType.I8: return (long)value;
			case ElementType.U8: return (ulong)value;
			}
			throw new ApplicationException($"Wrong type {type}");
		}

		bool GetArg(IMethod method, Block block, ref object arg, ref int instrIndex) {
			while (true) {
				if (instrIndex < 0) {
					// We're here if there were no cflow deobfuscation, or if there are two or
					// more blocks branching to the decrypter method, or the two blocks can't be
					// merged because one is outside the exception handler (eg. buggy obfuscator).
					Logger.w("Could not find all arguments to method {0} ({1:X8})",
								Utils.RemoveNewlines(method),
								method.MDToken.ToInt32());
					errors++;
					return false;
				}

				var instr = block.Instructions[instrIndex--];
				switch (instr.OpCode.Code) {
				case Code.Ldc_I4:
				case Code.Ldc_I8:
				case Code.Ldc_R4:
				case Code.Ldc_R8:
				case Code.Ldstr:
					arg = instr.Operand;
					break;
				case Code.Ldc_I4_S:
					arg = (int)(sbyte)instr.Operand;
					break;

				case Code.Ldc_I4_0: arg = 0; break;
				case Code.Ldc_I4_1: arg = 1; break;
				case Code.Ldc_I4_2: arg = 2; break;
				case Code.Ldc_I4_3: arg = 3; break;
				case Code.Ldc_I4_4: arg = 4; break;
				case Code.Ldc_I4_5: arg = 5; break;
				case Code.Ldc_I4_6: arg = 6; break;
				case Code.Ldc_I4_7: arg = 7; break;
				case Code.Ldc_I4_8: arg = 8; break;
				case Code.Ldc_I4_M1:arg = -1; break;
				case Code.Ldnull:	arg = null; break;

				case Code.Nop:
					continue;

				case Code.Ldloc:
				case Code.Ldloc_S:
				case Code.Ldloc_0:
				case Code.Ldloc_1:
				case Code.Ldloc_2:
				case Code.Ldloc_3:
					GetLocalVariableValue(instr.Instruction.GetLocal(theMethod.Body.Variables), out arg);
					break;

				case Code.Ldfld:
				case Code.Ldsfld:
					arg = instr.Operand;
					break;

				default:
					int pushes, pops;
					instr.Instruction.CalculateStackUsage(false, out pushes, out pops);
					if (!useUnknownArgs || pushes != 1) {
						Logger.w("Could not find all arguments to method {0} ({1:X8}), instr: {2}",
									Utils.RemoveNewlines(method),
									method.MDToken.ToInt32(),
									instr);
						errors++;
						return false;
					}

					for (int i = 0; i < pops; i++) {
						if (!GetArg(method, block, ref arg, ref instrIndex))
							return false;
					}
					arg = null;
					break;
				}
				break;
			}

			return true;
		}

		void InlineReturnValues() {
			callResults = RemoveNulls(callResults);
			callResults.Sort((a, b) => {
				int i1 = allBlocks.FindIndex((x) => a.block == x);
				int i2 = allBlocks.FindIndex((x) => b.block == x);
				if (i1 != i2)
					return i1.CompareTo(i2);

				return a.callStartIndex.CompareTo(b.callStartIndex);
			});
			callResults.Reverse();
			InlineReturnValues(callResults);
		}

		static List<CallResult> RemoveNulls(List<CallResult> inList) {
			var outList = new List<CallResult>(inList.Count);
			foreach (var callResult in inList) {
				if (callResult.returnValue != null)
					outList.Add(callResult);
			}
			return outList;
		}

		protected abstract void InlineReturnValues(IList<CallResult> callResults);
	}
}



================================================
File: de4dot.code/NameRegexes.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using System.Text.RegularExpressions;

namespace de4dot.code {
	public class NameRegex {
		Regex regex;
		public const char invertChar = '!';

		public bool MatchValue { get; private set; }

		public NameRegex(string regex) {
			if (regex.Length > 0 && regex[0] == invertChar) {
				regex = regex.Substring(1);
				MatchValue = false;
			}
			else
				MatchValue = true;

			this.regex = new Regex(regex);
		}

		// Returns true if the regex matches. Use MatchValue to get result.
		public bool IsMatch(string s) => regex.IsMatch(s);

		public override string ToString() {
			if (!MatchValue)
				return invertChar + regex.ToString();
			return regex.ToString();
		}
	}

	public class NameRegexes {
		IList<NameRegex> regexes;
		public bool DefaultValue { get; set; }
		public const char regexSeparatorChar = '&';
		public IList<NameRegex> Regexes => regexes;

		public NameRegexes() : this("") { }
		public NameRegexes(string regex) => Set(regex);

		public void Set(string regexesString) {
			regexes = new List<NameRegex>();
			if (regexesString != "") {
				foreach (var regex in regexesString.Split(new char[] { regexSeparatorChar }))
					regexes.Add(new NameRegex(regex));
			}
		}

		public bool IsMatch(string s) {
			foreach (var regex in regexes) {
				if (regex.IsMatch(s))
					return regex.MatchValue;
			}

			return DefaultValue;
		}

		public override string ToString() {
			var s = "";
			for (int i = 0; i < regexes.Count; i++) {
				if (i > 0)
					s += regexSeparatorChar;
				s += regexes[i].ToString();
			}
			return s;
		}
	}
}



================================================
File: de4dot.code/ObfuscatedFile.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using dnlib.DotNet.Writer;
using dnlib.PE;
using AssemblyData;
using de4dot.code.deobfuscators;
using de4dot.blocks;
using de4dot.blocks.cflow;
using de4dot.code.AssemblyClient;
using de4dot.code.renamer;

namespace de4dot.code {
	public class ObfuscatedFile : IObfuscatedFile, IDeobfuscatedFile {
		Options options;
		ModuleDefMD module;
		IDeobfuscator deob;
		IDeobfuscatorContext deobfuscatorContext;
		AssemblyModule assemblyModule;
		IAssemblyClient assemblyClient;
		DynamicStringInliner dynamicStringInliner;
		IAssemblyClientFactory assemblyClientFactory;
		SavedMethodBodies savedMethodBodies;
		bool userStringDecrypterMethods = false;

		class SavedMethodBodies {
			Dictionary<MethodDef, SavedMethodBody> savedMethodBodies = new Dictionary<MethodDef, SavedMethodBody>();

			class SavedMethodBody {
				MethodDef method;
				IList<Instruction> instructions;
				IList<ExceptionHandler> exceptionHandlers;

				public SavedMethodBody(MethodDef method) {
					this.method = method;
					DotNetUtils.CopyBody(method, out instructions, out exceptionHandlers);
				}

				public void Restore() => DotNetUtils.RestoreBody(method, instructions, exceptionHandlers);
			}

			public void Save(MethodDef method) {
				if (IsSaved(method))
					return;
				savedMethodBodies[method] = new SavedMethodBody(method);
			}

			public void RestoreAll() {
				foreach (var smb in savedMethodBodies.Values)
					smb.Restore();
				savedMethodBodies.Clear();
			}

			public bool IsSaved(MethodDef method) => savedMethodBodies.ContainsKey(method);
		}

		public class Options {
			public string Filename { get; set; }
			public string NewFilename { get; set; }
			public string ForcedObfuscatorType { get; set; }
			public DecrypterType StringDecrypterType { get; set; }
			public List<string> StringDecrypterMethods { get; private set; }
			public bool ControlFlowDeobfuscation { get; set; }
			public bool KeepObfuscatorTypes { get; set; }
			public bool PreserveTokens { get; set; }
			public MetadataFlags MetadataFlags { get; set; }
			public RenamerFlags RenamerFlags { get; set; }

			public Options() {
				StringDecrypterType = DecrypterType.Default;
				StringDecrypterMethods = new List<string>();
			}
		}

		public string Filename => options.Filename;
		public string NewFilename => options.NewFilename;
		public ModuleDefMD ModuleDefMD => module;
		public INameChecker NameChecker => deob;
		public bool RenameResourcesInCode => deob.TheOptions.RenameResourcesInCode;
		public bool RemoveNamespaceWithOneType => (deob.RenamingOptions & RenamingOptions.RemoveNamespaceIfOneType) != 0;
		public bool RenameResourceKeys => (deob.RenamingOptions & RenamingOptions.RenameResourceKeys) != 0;
		public IDeobfuscator Deobfuscator => deob;
		public IDeobfuscatorContext DeobfuscatorContext {
			get => deobfuscatorContext;
			set => deobfuscatorContext = value;
		}

		public ObfuscatedFile(Options options, ModuleContext moduleContext, IAssemblyClientFactory assemblyClientFactory) {
			this.assemblyClientFactory = assemblyClientFactory;
			this.options = options;
			userStringDecrypterMethods = options.StringDecrypterMethods.Count > 0;
			options.Filename = Utils.GetFullPath(options.Filename);
			assemblyModule = new AssemblyModule(options.Filename, moduleContext);

			if (options.NewFilename == null)
				options.NewFilename = GetDefaultNewFilename();

			if (string.Equals(options.Filename, options.NewFilename, StringComparison.OrdinalIgnoreCase))
				throw new UserException($"filename is same as new filename! ({options.Filename})");
		}

		string GetDefaultNewFilename() {
			string newFilename = Path.GetFileNameWithoutExtension(options.Filename) + "-cleaned" + Path.GetExtension(options.Filename);
			return Path.Combine(Path.GetDirectoryName(options.Filename), newFilename);
		}

		public void Load(IList<IDeobfuscator> deobfuscators) {
			try {
				LoadModule(deobfuscators);
				TheAssemblyResolver.Instance.AddSearchDirectory(Utils.GetDirName(Filename));
				TheAssemblyResolver.Instance.AddSearchDirectory(Utils.GetDirName(NewFilename));
				DetectObfuscator(deobfuscators);
				if (deob == null)
					throw new ApplicationException("Could not detect obfuscator!");
				InitializeDeobfuscator();
			}
			finally {
				foreach (var d in deobfuscators) {
					if (d != deob && d != null)
						d.Dispose();
				}
			}
		}

		void LoadModule(IEnumerable<IDeobfuscator> deobfuscators) {
			var oldModule = module;
			try {
				module = assemblyModule.Load();
			}
			catch (BadImageFormatException) {
				if (!UnpackNativeImage(deobfuscators))
					throw new BadImageFormatException();
				Logger.v("Unpacked native file");
			}
			finally {
				if (oldModule != null)
					oldModule.Dispose();
			}
		}

		bool UnpackNativeImage(IEnumerable<IDeobfuscator> deobfuscators) {
			using (var peImage = new PEImage(Filename)) {
				foreach (var deob in deobfuscators) {
					byte[] unpackedData = null;
					try {
						unpackedData = deob.UnpackNativeFile(peImage);
					}
					catch {
					}
					if (unpackedData == null)
						continue;

					var oldModule = module;
					try {
						module = assemblyModule.Load(unpackedData);
					}
					catch {
						Logger.w("Could not load unpacked data. File: {0}, deobfuscator: {0}", peImage.Filename ?? "(unknown filename)", deob.TypeLong);
						continue;
					}
					finally {
						if (oldModule != null)
							oldModule.Dispose();
					}
					this.deob = deob;
					return true;
				}
			}

			return false;
		}

		void InitializeDeobfuscator() {
			if (options.StringDecrypterType == DecrypterType.Default)
				options.StringDecrypterType = deob.DefaultDecrypterType;
			if (options.StringDecrypterType == DecrypterType.Default)
				options.StringDecrypterType = DecrypterType.Static;

			deob.Operations = CreateOperations();
		}

		IOperations CreateOperations() {
			var op = new Operations();

			switch (options.StringDecrypterType) {
			case DecrypterType.None:
				op.DecryptStrings = OpDecryptString.None;
				break;
			case DecrypterType.Static:
				op.DecryptStrings = OpDecryptString.Static;
				break;
			default:
				op.DecryptStrings = OpDecryptString.Dynamic;
				break;
			}

			op.KeepObfuscatorTypes = options.KeepObfuscatorTypes;
			op.MetadataFlags = options.MetadataFlags;
			op.RenamerFlags = options.RenamerFlags;

			return op;
		}

		void DetectObfuscator(IEnumerable<IDeobfuscator> deobfuscators) {

			// The deobfuscators may call methods to deobfuscate control flow and decrypt
			// strings (statically) in order to detect the obfuscator.
			if (!options.ControlFlowDeobfuscation || options.StringDecrypterType == DecrypterType.None)
				savedMethodBodies = new SavedMethodBodies();

			// It's not null if it unpacked a native file
			if (deob != null) {
				deob.Initialize(module);
				deob.DeobfuscatedFile = this;
				deob.Detect();
				return;
			}

			foreach (var deob in deobfuscators) {
				deob.Initialize(module);
				deob.DeobfuscatedFile = this;
			}

			if (options.ForcedObfuscatorType != null) {
				foreach (var deob in deobfuscators) {
					if (string.Equals(options.ForcedObfuscatorType, deob.Type, StringComparison.OrdinalIgnoreCase)) {
						this.deob = deob;
						deob.Detect();
						return;
					}
				}
			}
			else
				deob = DetectObfuscator2(deobfuscators);
		}

		IDeobfuscator DetectObfuscator2(IEnumerable<IDeobfuscator> deobfuscators) {
			var allDetected = new List<IDeobfuscator>();
			IDeobfuscator detected = null;
			int detectVal = 0;
			foreach (var deob in deobfuscators) {
				this.deob = deob;	// So we can call deob.CanInlineMethods in deobfuscate()
				int val;
				try {
					val = deob.Detect();
				}
				catch {
					val = deob.Type == "un" ? 1 : 0;
				}
				Logger.v("{0,3}: {1}", val, deob.TypeLong);
				if (val > 0 && deob.Type != "un")
					allDetected.Add(deob);
				if (val > detectVal) {
					detectVal = val;
					detected = deob;
				}
			}
			deob = null;

			if (allDetected.Count > 1) {
				Logger.n("More than one obfuscator detected:");
				Logger.Instance.Indent();
				foreach (var deob in allDetected)
					Logger.n("{0} (use: -p {1})", deob.Name, deob.Type);
				Logger.Instance.DeIndent();
			}

			return detected;
		}

		MetadataFlags GetMetadataFlags() {
			var mdFlags = options.MetadataFlags | deob.MetadataFlags;

			// Always preserve tokens if it's an unknown obfuscator
			if (deob.Type == "un") {
				mdFlags |= MetadataFlags.PreserveRids |
						MetadataFlags.PreserveUSOffsets |
						MetadataFlags.PreserveBlobOffsets |
						MetadataFlags.PreserveExtraSignatureData;
			}

			return mdFlags;
		}

		public void Save() {
			Logger.n("Saving {0}", options.NewFilename);
			var mdFlags = GetMetadataFlags();
			if (!options.ControlFlowDeobfuscation)
				mdFlags |= MetadataFlags.KeepOldMaxStack;
			assemblyModule.Save(options.NewFilename, mdFlags, new PrintNewTokens(module, deob as IModuleWriterListener));
		}

		IList<MethodDef> GetAllMethods() {
			var list = new List<MethodDef>();

			foreach (var type in module.GetTypes()) {
				foreach (var method in type.Methods)
					list.Add(method);
			}

			return list;
		}

		public void DeobfuscateBegin() {
			switch (options.StringDecrypterType) {
			case DecrypterType.None:
				CheckSupportedStringDecrypter(StringFeatures.AllowNoDecryption);
				break;

			case DecrypterType.Static:
				CheckSupportedStringDecrypter(StringFeatures.AllowStaticDecryption);
				break;

			case DecrypterType.Delegate:
			case DecrypterType.Emulate:
				CheckSupportedStringDecrypter(StringFeatures.AllowDynamicDecryption);
				var newProcFactory = assemblyClientFactory as NewProcessAssemblyClientFactory;
				if (newProcFactory != null)
					assemblyClient = newProcFactory.Create(AssemblyServiceType.StringDecrypter, module);
				else
					assemblyClient = assemblyClientFactory.Create(AssemblyServiceType.StringDecrypter);
				assemblyClient.Connect();
				break;

			default:
				throw new ApplicationException($"Invalid string decrypter type '{options.StringDecrypterType}'");
			}
		}

		public void CheckSupportedStringDecrypter(StringFeatures feature) {
			if ((deob.StringFeatures & feature) == feature)
				return;
			throw new UserException($"Deobfuscator {deob.TypeLong} does not support this string decryption type");
		}

		public void Deobfuscate() {
			Logger.n("Cleaning {0}", options.Filename);
			InitAssemblyClient();

			for (int i = 0; ; i++) {
				byte[] fileData = null;
				DumpedMethods dumpedMethods = null;
				if (!deob.GetDecryptedModule(i, ref fileData, ref dumpedMethods))
					break;
				ReloadModule(fileData, dumpedMethods);
			}

			deob.DeobfuscateBegin();
			DeobfuscateMethods();
			deob.DeobfuscateEnd();
		}

		void ReloadModule(byte[] newModuleData, DumpedMethods dumpedMethods) {
			Logger.v("Reloading decrypted assembly (original filename: {0})", Filename);
			simpleDeobfuscatorFlags.Clear();
			using (var oldModule = module) {
				module = assemblyModule.Reload(newModuleData, CreateDumpedMethodsRestorer(dumpedMethods), deob as IStringDecrypter);
				deob = deob.ModuleReloaded(module);
			}
			InitializeDeobfuscator();
			deob.DeobfuscatedFile = this;
			UpdateDynamicStringInliner();
		}

		DumpedMethodsRestorer CreateDumpedMethodsRestorer(DumpedMethods dumpedMethods) {
			if (dumpedMethods == null || dumpedMethods.Count == 0)
				return null;
			return new DumpedMethodsRestorer(dumpedMethods);
		}

		void InitAssemblyClient() {
			if (assemblyClient == null)
				return;

			assemblyClient.WaitConnected();
			assemblyClient.StringDecrypterService.LoadAssembly(options.Filename);

			if (options.StringDecrypterType == DecrypterType.Delegate)
				assemblyClient.StringDecrypterService.SetStringDecrypterType(AssemblyData.StringDecrypterType.Delegate);
			else if (options.StringDecrypterType == DecrypterType.Emulate)
				assemblyClient.StringDecrypterService.SetStringDecrypterType(AssemblyData.StringDecrypterType.Emulate);
			else
				throw new ApplicationException($"Invalid string decrypter type '{options.StringDecrypterType}'");

			dynamicStringInliner = new DynamicStringInliner(assemblyClient);
			UpdateDynamicStringInliner();
		}

		void UpdateDynamicStringInliner() {
			if (dynamicStringInliner != null)
				dynamicStringInliner.Initialize(GetMethodTokens());
		}

		IEnumerable<int> GetMethodTokens() {
			if (!userStringDecrypterMethods)
				return deob.GetStringDecrypterMethods();

			var tokens = new List<int>();

			foreach (var val in options.StringDecrypterMethods) {
				var tokenStr = val.Trim();
				if (Utils.StartsWith(tokenStr, "0x", StringComparison.OrdinalIgnoreCase))
					tokenStr = tokenStr.Substring(2);
				if (int.TryParse(tokenStr, NumberStyles.HexNumber, null, out int methodToken))
					tokens.Add(methodToken);
				else
					tokens.AddRange(FindMethodTokens(val));
			}

			return tokens;
		}

		IEnumerable<int> FindMethodTokens(string methodDesc) {
			var tokens = new List<int>();

			SplitMethodDesc(methodDesc, out string typeString, out string methodName, out var argsStrings);

			foreach (var type in module.GetTypes()) {
				if (typeString != null && typeString != type.FullName)
					continue;
				foreach (var method in type.Methods) {
					if (!method.IsStatic)
						continue;
					if (method.MethodSig.GetRetType().GetElementType() != ElementType.String && method.MethodSig.GetRetType().GetElementType() != ElementType.Object)
						continue;
					if (methodName != null && methodName != method.Name)
						continue;

					var sig = method.MethodSig;
					if (argsStrings == null) {
						if (sig.Params.Count == 0)
							continue;
					}
					else {
						if (argsStrings.Length != sig.Params.Count)
							continue;
						for (int i = 0; i < argsStrings.Length; i++) {
							if (argsStrings[i] != sig.Params[i].FullName)
								continue;
						}
					}

					Logger.v("Adding string decrypter; token: {0:X8}, method: {1}", method.MDToken.ToInt32(), Utils.RemoveNewlines(method.FullName));
					tokens.Add(method.MDToken.ToInt32());
				}
			}

			return tokens;
		}

		static void SplitMethodDesc(string methodDesc, out string type, out string name, out string[] args) {
			string stringArgs = null;
			args = null;
			type = null;
			name = null;

			var remaining = methodDesc;
			int index = remaining.LastIndexOf("::");
			if (index >= 0) {
				type = remaining.Substring(0, index);
				remaining = remaining.Substring(index + 2);
			}

			index = remaining.IndexOf('(');
			if (index >= 0) {
				name = remaining.Substring(0, index);
				remaining = remaining.Substring(index);
			}
			else {
				name = remaining;
				remaining = "";
			}

			if (Utils.StartsWith(remaining, "(", StringComparison.Ordinal)) {
				stringArgs = remaining;
			}
			else if (remaining.Length > 0)
				throw new UserException($"Invalid method desc: '{methodDesc}'");

			if (stringArgs != null) {
				if (Utils.StartsWith(stringArgs, "(", StringComparison.Ordinal))
					stringArgs = stringArgs.Substring(1);
				if (stringArgs.EndsWith(")", StringComparison.Ordinal))
					stringArgs = stringArgs.Substring(0, stringArgs.Length - 1);
				args = stringArgs.Split(',');
				for (int i = 0; i < args.Length; i++)
					args[i] = args[i].Trim();
			}

			if (type == "")
				type = null;
			if (name == "")
				name = null;
		}

		public void DeobfuscateEnd() => DeobfuscateCleanUp();

		public void DeobfuscateCleanUp() {
			if (assemblyClient != null) {
				assemblyClient.Dispose();
				assemblyClient = null;
			}
		}

		void DeobfuscateMethods() {
			if (savedMethodBodies != null) {
				savedMethodBodies.RestoreAll();
				savedMethodBodies = null;
			}
			deob.DeobfuscatedFile = null;

			if (!options.ControlFlowDeobfuscation) {
				if (options.KeepObfuscatorTypes || deob.Type == "un")
					return;
			}

			bool isVerbose = !Logger.Instance.IgnoresEvent(LoggerEvent.Verbose);
			bool isVV = !Logger.Instance.IgnoresEvent(LoggerEvent.VeryVerbose);
			if (isVerbose)
				Logger.v("Deobfuscating methods");
			var methodPrinter = new MethodPrinter();
			var cflowDeobfuscator = new BlocksCflowDeobfuscator(deob.BlocksDeobfuscators);
			foreach (var method in GetAllMethods()) {
				if (isVerbose) {
					Logger.v("Deobfuscating {0} ({1:X8})", Utils.RemoveNewlines(method), method.MDToken.ToUInt32());
					Logger.Instance.Indent();
				}

				int oldIndentLevel = Logger.Instance.IndentLevel;
				try {
					Deobfuscate(method, cflowDeobfuscator, methodPrinter, isVerbose, isVV);
				}
				catch (Exception ex) {
					if (!CanLoadMethodBody(method)) {
						if (isVerbose)
							Logger.v("Invalid method body. {0:X8}", method.MDToken.ToInt32());
						method.Body = new CilBody();
					}
					else {
						Logger.w("Could not deobfuscate method {0:X8}. Hello, E.T.: {1}",	// E.T. = exception type
								method.MDToken.ToInt32(),
								ex.GetType());
					}
				}
				finally {
					Logger.Instance.IndentLevel = oldIndentLevel;
				}
				RemoveNoInliningAttribute(method);

				if (isVerbose)
					Logger.Instance.DeIndent();
			}
		}

		static bool CanLoadMethodBody(MethodDef method) {
			try {
				var body = method.Body;
				return true;
			}
			catch {
				return false;
			}
		}

		bool CanOptimizeLocals() {
			// Don't remove any locals if we must preserve StandAloneSig table
			return (GetMetadataFlags() & MetadataFlags.PreserveStandAloneSigRids) == 0;
		}

		void Deobfuscate(MethodDef method, BlocksCflowDeobfuscator cflowDeobfuscator, MethodPrinter methodPrinter, bool isVerbose, bool isVV) {
			if (!HasNonEmptyBody(method))
				return;

			var blocks = new Blocks(method);
			int numRemovedLocals = 0;
			int oldNumInstructions = method.Body.Instructions.Count;

			deob.DeobfuscateMethodBegin(blocks);
			if (options.ControlFlowDeobfuscation) {
				cflowDeobfuscator.Initialize(blocks);
				cflowDeobfuscator.Deobfuscate();
			}

			if (deob.DeobfuscateOther(blocks) && options.ControlFlowDeobfuscation)
				cflowDeobfuscator.Deobfuscate();

			if (options.ControlFlowDeobfuscation) {
				if (CanOptimizeLocals())
					numRemovedLocals = blocks.OptimizeLocals();
				blocks.RepartitionBlocks();
			}

			DeobfuscateStrings(blocks);
			deob.DeobfuscateMethodEnd(blocks);

			blocks.GetCode(out var allInstructions, out var allExceptionHandlers);
			DotNetUtils.RestoreBody(method, allInstructions, allExceptionHandlers);

			if (isVerbose && numRemovedLocals > 0)
				Logger.v("Removed {0} unused local(s)", numRemovedLocals);
			int numRemovedInstructions = oldNumInstructions - method.Body.Instructions.Count;
			if (isVerbose && numRemovedInstructions > 0)
				Logger.v("Removed {0} dead instruction(s)", numRemovedInstructions);

			if (isVV) {
				Logger.Log(LoggerEvent.VeryVerbose, "Deobfuscated code:");
				Logger.Instance.Indent();
				methodPrinter.Print(LoggerEvent.VeryVerbose, allInstructions, allExceptionHandlers);
				Logger.Instance.DeIndent();
			}
		}

		bool HasNonEmptyBody(MethodDef method) => method.HasBody && method.Body.Instructions.Count > 0;

		void DeobfuscateStrings(Blocks blocks) {
			switch (options.StringDecrypterType) {
			case DecrypterType.None:
				break;

			case DecrypterType.Static:
				deob.DeobfuscateStrings(blocks);
				break;

			case DecrypterType.Delegate:
			case DecrypterType.Emulate:
				dynamicStringInliner.Decrypt(blocks);
				break;

			default:
				throw new ApplicationException($"Invalid string decrypter type '{options.StringDecrypterType}'");
			}
		}

		void RemoveNoInliningAttribute(MethodDef method) {
			method.IsNoInlining = false;
			for (int i = 0; i < method.CustomAttributes.Count; i++) {
				var cattr = method.CustomAttributes[i];
				if (cattr.TypeFullName != "System.Runtime.CompilerServices.MethodImplAttribute")
					continue;
				int options = 0;
				if (!GetMethodImplOptions(cattr, ref options))
					continue;
				if (options != 0 && options != (int)MethodImplAttributes.NoInlining)
					continue;
				method.CustomAttributes.RemoveAt(i);
				i--;
			}
		}

		static bool GetMethodImplOptions(CustomAttribute cattr, ref int value) {
			if (cattr.IsRawBlob)
				return false;
			if (cattr.ConstructorArguments.Count != 1)
				return false;
			if (cattr.ConstructorArguments[0].Type.ElementType != ElementType.I2 &&
				cattr.ConstructorArguments[0].Type.FullName != "System.Runtime.CompilerServices.MethodImplOptions")
				return false;

			var arg = cattr.ConstructorArguments[0].Value;
			if (arg is short) {
				value = (short)arg;
				return true;
			}
			if (arg is int) {
				value = (int)arg;
				return true;
			}

			return false;
		}

		public override string ToString() {
			if (options == null || options.Filename == null)
				return base.ToString();
			return options.Filename;
		}

		[Flags]
		enum SimpleDeobFlags {
			HasDeobfuscated = 0x1,
		}
		Dictionary<MethodDef, SimpleDeobFlags> simpleDeobfuscatorFlags = new Dictionary<MethodDef, SimpleDeobFlags>();
		bool Check(MethodDef method, SimpleDeobFlags flag) {
			if (method == null)
				return false;
			simpleDeobfuscatorFlags.TryGetValue(method, out var oldFlags);
			simpleDeobfuscatorFlags[method] = oldFlags | flag;
			return (oldFlags & flag) == flag;
		}
		bool Clear(MethodDef method, SimpleDeobFlags flag) {
			if (method == null)
				return false;
			if (!simpleDeobfuscatorFlags.TryGetValue(method, out var oldFlags))
				return false;
			simpleDeobfuscatorFlags[method] = oldFlags & ~flag;
			return true;
		}

		void Deobfuscate(MethodDef method, string msg, Action<Blocks> handler) {
			if (savedMethodBodies != null)
				savedMethodBodies.Save(method);

			Logger.v("{0}: {1} ({2:X8})", msg, Utils.RemoveNewlines(method), method.MDToken.ToUInt32());
			Logger.Instance.Indent();

			if (HasNonEmptyBody(method)) {
				try {
					var blocks = new Blocks(method);

					handler(blocks);

					blocks.GetCode(out var allInstructions, out var allExceptionHandlers);
					DotNetUtils.RestoreBody(method, allInstructions, allExceptionHandlers);
				}
				catch {
					Logger.v("Could not deobfuscate {0:X8}", method.MDToken.ToInt32());
				}
			}

			Logger.Instance.DeIndent();
		}

		void ISimpleDeobfuscator.MethodModified(MethodDef method) => Clear(method, SimpleDeobFlags.HasDeobfuscated);
		void ISimpleDeobfuscator.Deobfuscate(MethodDef method) => ((ISimpleDeobfuscator)this).Deobfuscate(method, 0);

		void ISimpleDeobfuscator.Deobfuscate(MethodDef method, SimpleDeobfuscatorFlags flags) {
			bool force = (flags & SimpleDeobfuscatorFlags.Force) != 0;
			if (method == null || (!force && Check(method, SimpleDeobFlags.HasDeobfuscated)))
				return;

			Deobfuscate(method, "Deobfuscating control flow", (blocks) => {
				bool disableNewCFCode = (flags & SimpleDeobfuscatorFlags.DisableConstantsFolderExtraInstrs) != 0;
				var cflowDeobfuscator = new BlocksCflowDeobfuscator(deob.BlocksDeobfuscators, disableNewCFCode);
				cflowDeobfuscator.Initialize(blocks);
				cflowDeobfuscator.Deobfuscate();
			});
		}

		void ISimpleDeobfuscator.DecryptStrings(MethodDef method, IDeobfuscator theDeob) =>
			Deobfuscate(method, "Static string decryption", (blocks) => theDeob.DeobfuscateStrings(blocks));

		void IDeobfuscatedFile.CreateAssemblyFile(byte[] data, string assemblyName, string extension) {
			if (extension == null)
				extension = ".dll";
			var baseDir = Utils.GetDirName(options.NewFilename);
			var newName = Path.Combine(baseDir, assemblyName + extension);
			Logger.n("Creating file {0}", newName);
			File.WriteAllBytes(newName, data);
		}

		void IDeobfuscatedFile.StringDecryptersAdded() => UpdateDynamicStringInliner();

		void IDeobfuscatedFile.SetDeobfuscator(IDeobfuscator deob) => this.deob = deob;

		public void Dispose() {
			DeobfuscateCleanUp();
			if (module != null)
				module.Dispose();
			if (deob != null)
				deob.Dispose();
			module = null;
			deob = null;
		}
	}
}



================================================
File: de4dot.code/Option.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Text.RegularExpressions;

namespace de4dot.code {
	public abstract class Option {
		const string SHORTNAME_PREFIX = "-";
		const string LONGNAME_PREFIX = "--";

		string shortName;
		string longName;
		string description;
		object defaultVal;

		public string ShortName => shortName;
		public string LongName => longName;
		public string Description => description;

		public object Default {
			get => defaultVal;
			protected set => defaultVal = value;
		}

		public virtual bool NeedArgument => true;
		public virtual string ArgumentValueName => "value";

		// Returns true if the new value is set, or false on error. error string is also updated.
		public abstract bool Set(string val, out string error);

		public Option(string shortName, string longName, string description) {
			if (shortName != null)
				this.shortName = SHORTNAME_PREFIX + shortName;
			if (longName != null)
				this.longName = LONGNAME_PREFIX + longName;
			this.description = description;
		}
	}

	public class BoolOption : Option {
		bool val;
		public BoolOption(string shortName, string longName, string description, bool val)
			: base(shortName, longName, description) => Default = this.val = val;

		public override string ArgumentValueName => "bool";

		public override bool Set(string newVal, out string error) {
			if (string.Equals(newVal, "false", StringComparison.OrdinalIgnoreCase) ||
				string.Equals(newVal, "off", StringComparison.OrdinalIgnoreCase) ||
				string.Equals(newVal, "0", StringComparison.OrdinalIgnoreCase)) {
				val = false;
			}
			else
				val = true;
			error = "";
			return true;
		}

		public bool Get() => val;
	}

	public class IntOption : Option {
		int val;

		public IntOption(string shortName, string longName, string description, int val)
			: base(shortName, longName, description) => Default = this.val = val;

		public override string ArgumentValueName => "int";

		public override bool Set(string newVal, out string error) {
			if (!int.TryParse(newVal, out int newInt)) {
				error = $"Not an integer: '{newVal}'";
				return false;
			}
			val = newInt;
			error = "";
			return true;
		}

		public int Get() => val;
	}

	public class StringOption : Option {
		string val;

		public override string ArgumentValueName => "string";

		public StringOption(string shortName, string longName, string description, string val)
			: base(shortName, longName, description) => Default = this.val = val;

		public override bool Set(string newVal, out string error) {
			val = newVal;
			error = "";
			return true;
		}

		public string Get() => val;
	}

	public class NameRegexOption : Option {
		NameRegexes val;

		public override string ArgumentValueName => "regex";

		public NameRegexOption(string shortName, string longName, string description, string val)
			: base(shortName, longName, description) => Default = this.val = new NameRegexes(val);

		public override bool Set(string newVal, out string error) {
			try {
				var regexes = new NameRegexes();
				regexes.Set(newVal);
				val = regexes;
			}
			catch (ArgumentException) {
				error = $"Could not parse regex '{newVal}'";
				return false;
			}
			error = "";
			return true;
		}

		public NameRegexes Get() => val;
	}

	public class RegexOption : Option {
		Regex val;

		public override string ArgumentValueName => "regex";

		public RegexOption(string shortName, string longName, string description, string val)
			: base(shortName, longName, description) => Default = this.val = new Regex(val);

		public override bool Set(string newVal, out string error) {
			try {
				val = new Regex(newVal);
			}
			catch (ArgumentException) {
				error = $"Could not parse regex '{newVal}'";
				return false;
			}
			error = "";
			return true;
		}

		public Regex Get() => val;
	}

	public class NoArgOption : Option {
		Action action;
		bool triggered;

		public override bool NeedArgument => false;

		public NoArgOption(string shortName, string longName, string description)
			: this(shortName, longName, description, null) {
		}

		public NoArgOption(string shortName, string longName, string description, Action action)
			: base(shortName, longName, description) => this.action = action;

		public override bool Set(string val, out string error) {
			triggered = true;
			action?.Invoke();
			error = "";
			return true;
		}

		public bool Get() => triggered;
	}

	public class OneArgOption : Option {
		Action<string> action;
		string typeName;

		public override string ArgumentValueName => typeName;

		public OneArgOption(string shortName, string longName, string description, string typeName, Action<string> action)
			: base(shortName, longName, description) {
			this.typeName = typeName ?? "value";
			this.action = action;
			Default = null;
		}

		public override bool Set(string val, out string error) {
			action(val);
			error = "";
			return true;
		}
	}
}



================================================
File: de4dot.code/PrintNewTokens.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using dnlib.DotNet;
using dnlib.DotNet.MD;
using dnlib.DotNet.Writer;

namespace de4dot.code {
	public class PrintNewTokens : IModuleWriterListener {
		readonly ModuleDef module;
		readonly IModuleWriterListener otherListener;

		public PrintNewTokens(ModuleDef module, IModuleWriterListener otherListener) {
			this.module = module;
			this.otherListener = otherListener;
		}

		public void OnWriterEvent(ModuleWriterBase writer, ModuleWriterEvent evt) {
			if (otherListener != null)
				otherListener.OnWriterEvent(writer, evt);
			if (evt == ModuleWriterEvent.End)
				PrintTokens(writer);
		}

		void PrintTokens(ModuleWriterBase writer) {
			if (Logger.Instance.IgnoresEvent(LoggerEvent.Verbose))
				return;

			var md = writer.Metadata;

			Logger.v("Old -> new tokens: Assembly: {0} (module: {1})", module.Assembly, module.Location);
			Logger.Instance.Indent();
			foreach (var type in module.GetTypes()) {
				uint newRid;

				newRid = md.GetRid(type);
				if (newRid == 0)
					continue;
				Logger.v("{0:X8} -> {1:X8} Type: {2}",
						type.MDToken.ToUInt32(),
						new MDToken(Table.TypeDef, newRid).ToUInt32(),
						Utils.RemoveNewlines(type));

				Logger.Instance.Indent();

				foreach (var method in type.Methods) {
					newRid = md.GetRid(method);
					if (newRid == 0)
						continue;
					Logger.v("{0:X8} -> {1:X8} Method: {2}",
							method.MDToken.ToUInt32(),
							new MDToken(Table.Method, newRid).ToUInt32(),
							Utils.RemoveNewlines(method));
				}

				foreach (var field in type.Fields) {
					newRid = md.GetRid(field);
					if (newRid == 0)
						continue;
					Logger.v("{0:X8} -> {1:X8} Field: {2}",
							field.MDToken.ToUInt32(),
							new MDToken(Table.Field, newRid).ToUInt32(),
							Utils.RemoveNewlines(field));
				}

				foreach (var prop in type.Properties) {
					newRid = md.GetRid(prop);
					if (newRid == 0)
						continue;
					Logger.v("{0:X8} -> {1:X8} Property: {2}",
							prop.MDToken.ToUInt32(),
							new MDToken(Table.Property, newRid).ToUInt32(),
							Utils.RemoveNewlines(prop));
				}

				foreach (var evt in type.Events) {
					newRid = md.GetRid(evt);
					if (newRid == 0)
						continue;
					Logger.v("{0:X8} -> {1:X8} Event: {2}",
							evt.MDToken.ToUInt32(),
							new MDToken(Table.Event, newRid).ToUInt32(),
							Utils.RemoveNewlines(evt));
				}

				Logger.Instance.DeIndent();
			}
			Logger.Instance.DeIndent();
		}
	}
}



================================================
File: de4dot.code/StringInliner.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.code.AssemblyClient;
using de4dot.blocks;

namespace de4dot.code {
	public abstract class StringInlinerBase : MethodReturnValueInliner {
		protected override void InlineReturnValues(IList<CallResult> callResults) {
			foreach (var callResult in callResults) {
				var block = callResult.block;
				int num = callResult.callEndIndex - callResult.callStartIndex + 1;

				var decryptedString = callResult.returnValue as string;
				if (decryptedString == null)
					continue;

				int ldstrIndex = callResult.callStartIndex;
				block.Replace(ldstrIndex, num, OpCodes.Ldstr.ToInstruction(decryptedString));

				// If it's followed by castclass string, remove it
				if (ldstrIndex + 1 < block.Instructions.Count) {
					var instr = block.Instructions[ldstrIndex + 1];
					if (instr.OpCode.Code == Code.Castclass && instr.Operand.ToString() == "System.String")
						block.Remove(ldstrIndex + 1, 1);
				}

				// If it's followed by String.Intern(), then nop out that call
				if (ldstrIndex + 1 < block.Instructions.Count) {
					var instr = block.Instructions[ldstrIndex + 1];
					if (instr.OpCode.Code == Code.Call) {
						if (instr.Operand is IMethod calledMethod &&
							calledMethod.FullName == "System.String System.String::Intern(System.String)") {
							block.Remove(ldstrIndex + 1, 1);
						}
					}
				}

				Logger.v("Decrypted string: {0}", Utils.ToCsharpString(decryptedString));
			}
		}
	}

	public class DynamicStringInliner : StringInlinerBase {
		IAssemblyClient assemblyClient;
		Dictionary<int, int> methodTokenToId = new Dictionary<int, int>();

		class MyCallResult : CallResult {
			public int methodId;
			public MethodSpec gim;
			public MyCallResult(Block block, int callEndIndex, int methodId, MethodSpec gim)
				: base(block, callEndIndex) {
				this.methodId = methodId;
				this.gim = gim;
			}
		}

		public override bool HasHandlers => methodTokenToId.Count != 0;

		public DynamicStringInliner(IAssemblyClient assemblyClient) => this.assemblyClient = assemblyClient;

		public void Initialize(IEnumerable<int> methodTokens) {
			methodTokenToId.Clear();
			foreach (var methodToken in methodTokens) {
				if (methodTokenToId.ContainsKey(methodToken))
					continue;
				methodTokenToId[methodToken] = assemblyClient.StringDecrypterService.DefineStringDecrypter(methodToken);
			}
		}

		protected override CallResult CreateCallResult(IMethod method, MethodSpec gim, Block block, int callInstrIndex) {
			if (!methodTokenToId.TryGetValue(method.MDToken.ToInt32(), out int methodId))
				return null;
			return new MyCallResult(block, callInstrIndex, methodId, gim);
		}

		protected override void InlineAllCalls() {
			var sortedCalls = new Dictionary<int, List<MyCallResult>>();
			foreach (var tmp in callResults) {
				var callResult = (MyCallResult)tmp;
				if (!sortedCalls.TryGetValue(callResult.methodId, out var list))
					sortedCalls[callResult.methodId] = list = new List<MyCallResult>(callResults.Count);
				list.Add(callResult);
			}

			foreach (var methodId in sortedCalls.Keys) {
				var list = sortedCalls[methodId];
				var args = new object[list.Count];
				for (int i = 0; i < list.Count; i++) {
					AssemblyData.SimpleData.Pack(list[i].args);
					args[i] = list[i].args;
				}
				var decryptedStrings = assemblyClient.StringDecrypterService.DecryptStrings(methodId, args, Method.MDToken.ToInt32());
				if (decryptedStrings.Length != args.Length)
					throw new ApplicationException("Invalid decrypted strings array length");
				AssemblyData.SimpleData.Unpack(decryptedStrings);
				for (int i = 0; i < list.Count; i++)
					list[i].returnValue = (string)decryptedStrings[i];
			}
		}
	}

	public class StaticStringInliner : StringInlinerBase {
		MethodDefAndDeclaringTypeDict<Func<MethodDef, MethodSpec, object[], string>> stringDecrypters = new MethodDefAndDeclaringTypeDict<Func<MethodDef, MethodSpec, object[], string>>();

		public override bool HasHandlers => stringDecrypters.Count != 0;
		public IEnumerable<MethodDef> Methods => stringDecrypters.GetKeys();

		class MyCallResult : CallResult {
			public IMethod IMethod;
			public MethodSpec gim;
			public MyCallResult(Block block, int callEndIndex, IMethod method, MethodSpec gim)
				: base(block, callEndIndex) {
				IMethod = method;
				this.gim = gim;
			}
		}

		public void Add(MethodDef method, Func<MethodDef, MethodSpec, object[], string> handler) {
			if (method != null)
				stringDecrypters.Add(method, handler);
		}

		protected override void InlineAllCalls() {
			foreach (var tmp in callResults) {
				var callResult = (MyCallResult)tmp;
				var handler = stringDecrypters.Find(callResult.IMethod);
				callResult.returnValue = handler((MethodDef)callResult.IMethod, callResult.gim, callResult.args);
			}
		}

		protected override CallResult CreateCallResult(IMethod method, MethodSpec gim, Block block, int callInstrIndex) {
			if (stringDecrypters.Find(method) == null)
				return null;
			return new MyCallResult(block, callInstrIndex, method, gim);
		}
	}
}



================================================
File: de4dot.code/UserException.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;

namespace de4dot.code {
	public class UserException : Exception {
		public UserException(string message)
			: base(message) {
		}

		public UserException(string message, Exception innerException)
			: base(message, innerException) {
		}
	}
}



================================================
File: de4dot.code/Utils.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using dnlib.DotNet;

namespace de4dot.code {
	public class Tuple<T1, T2> {
		public T1 Item1 { get; set; }
		public T2 Item2 { get; set; }
		public override bool Equals(object obj) {
			var other = obj as Tuple<T1, T2>;
			if (other == null)
				return false;
			return Item1.Equals(other.Item1) && Item2.Equals(other.Item2);
		}
		public override int GetHashCode() => Item1.GetHashCode() + Item2.GetHashCode();
		public override string ToString() => "<" + Item1.ToString() + "," + Item2.ToString() + ">";
	}

	public static class Utils {
		static Random random = new Random();

		public static IEnumerable<T> Unique<T>(IEnumerable<T> values) {
			// HashSet is only available in .NET 3.5 and later.
			var dict = new Dictionary<T, bool>();
			foreach (var val in values)
				dict[val] = true;
			return dict.Keys;
		}

		public static string ToCsharpString(UTF8String s) => ToCsharpString(UTF8String.ToSystemStringOrEmpty(s));

		public static string ToCsharpString(string s) {
			var sb = new StringBuilder(s.Length + 2);
			sb.Append('"');
			foreach (var c in s) {
				if ((int)c < 0x20) {
					switch (c) {
					case '\a': AppendEscape(sb, 'a'); break;
					case '\b': AppendEscape(sb, 'b'); break;
					case '\f': AppendEscape(sb, 'f'); break;
					case '\n': AppendEscape(sb, 'n'); break;
					case '\r': AppendEscape(sb, 'r'); break;
					case '\t': AppendEscape(sb, 't'); break;
					case '\v': AppendEscape(sb, 'v'); break;
					default:
						sb.Append($@"\u{(int)c:X4}");
						break;
					}
				}
				else if (c == '\\' || c == '"') {
					AppendEscape(sb, c);
				}
				else
					sb.Append(c);
			}
			sb.Append('"');
			return sb.ToString();
		}

		public static string ShellEscape(string s) {
			var sb = new StringBuilder(s.Length + 2);
			sb.Append('"');
			foreach (var c in s) {
				if (c == '"')
					AppendEscape(sb, c);
				else
					sb.Append(c);
			}
			sb.Append('"');
			return sb.ToString();
		}

		static void AppendEscape(StringBuilder sb, char c) {
			sb.Append('\\');
			sb.Append(c);
		}

		public static string RemoveNewlines(object o) => RemoveNewlines(o.ToString());
		public static string RemoveNewlines(string s) => s.Replace('\n', ' ').Replace('\r', ' ');

		public static string GetFullPath(string path) {
			try {
				return Path.GetFullPath(path);
			}
			catch (Exception) {
				return path;
			}
		}

		public static string RandomName(int min, int max) {
			int numChars = random.Next(min, max + 1);
			var sb = new StringBuilder(numChars);
			int numLower = 0;
			for (int i = 0; i < numChars; i++) {
				if (numLower == 0)
					sb.Append((char)((int)'A' + random.Next(26)));
				else
					sb.Append((char)((int)'a' + random.Next(26)));

				if (numLower == 0) {
					numLower = random.Next(1, 5);
				}
				else {
					numLower--;
				}
			}
			return sb.ToString();
		}

		public static string GetBaseName(string name) {
			int index = name.LastIndexOf(Path.DirectorySeparatorChar);
			if (index < 0)
				return name;
			return name.Substring(index + 1);
		}

		public static string GetDirName(string name) => Path.GetDirectoryName(name);

		static string ourBaseDir = null;
		public static string GetOurBaseDir() {
			if (ourBaseDir != null)
				return ourBaseDir;
			return ourBaseDir = GetDirName(typeof(Utils).Assembly.Location);
		}

		public static string GetPathOfOurFile(string filename) => Path.Combine(GetOurBaseDir(), filename);

		// This fixes a mono (tested 2.10.5) String.StartsWith() bug. NB: stringComparison must be
		// Ordinal or OrdinalIgnoreCase!
		public static bool StartsWith(string left, string right, StringComparison stringComparison) {
			if (left.Length < right.Length)
				return false;
			return left.Substring(0, right.Length).Equals(right, stringComparison);
		}

		public static string GetAssemblySimpleName(string name) {
			int i = name.IndexOf(',');
			if (i < 0)
				return name;
			return name.Substring(0, i);
		}

		public static bool PathExists(string path) {
			try {
				return new DirectoryInfo(path).Exists;
			}
			catch (Exception) {
				return false;
			}
		}

		public static bool FileExists(string path) {
			try {
				return new FileInfo(path).Exists;
			}
			catch (Exception) {
				return false;
			}
		}

		public static bool Compare(byte[] a, byte[] b) {
			if (a.Length != b.Length)
				return false;
			for (int i = 0; i < a.Length; i++) {
				if (a[i] != b[i])
					return false;
			}
			return true;
		}

		public static byte[] ReadFile(string filename) {
			// If the file is on the network, and we read more than 2MB, we'll read from the wrong
			// offset in the file! Tested: VMware 8, Win7 x64.
			const int MAX_BYTES_READ = 0x200000;

			using (var fileStream = new FileStream(filename, FileMode.Open, FileAccess.Read, FileShare.Read)) {
				var fileData = new byte[(int)fileStream.Length];

				int bytes, offset = 0, length = fileData.Length;
				while ((bytes = fileStream.Read(fileData, offset, Math.Min(MAX_BYTES_READ, length - offset))) > 0)
					offset += bytes;
				if (offset != length)
					throw new ApplicationException("Could not read all bytes");

				return fileData;
			}
		}
	}
}



================================================
File: de4dot.code/Win32Path.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

namespace de4dot.code {
	// Needed when executing on non-Windows platforms
	public static class Win32Path {
		public static string GetFileName(string path) {
			if (path == null)
				return null;
			if (path.Length == 0)
				return string.Empty;
			var c = path[path.Length - 1];
			if (c == '\\' || c == ':')
				return string.Empty;
			int index = path.LastIndexOf('\\');
			if (index < 0)
				return path;
			return path.Substring(index + 1);
		}

		public static string GetFileNameWithoutExtension(string path) {
			if (path == null)
				return null;
			var s = GetFileName(path);
			int i = s.LastIndexOf('.');
			if (i < 0)
				return s;
			return s.Substring(0, i);
		}

		public static string GetExtension(string path) {
			if (path == null)
				return null;
			var s = GetFileName(path);
			int i = s.LastIndexOf('.');
			if (i < 0)
				return string.Empty;
			return s.Substring(i);
		}
	}
}



================================================
File: de4dot.code/de4dot.code.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">

  <Import Project="..\De4DotCommon.props" />

  <PropertyGroup>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>

  <ItemGroup>
    <Compile Update="deobfuscators\Agile_NET\vm\v2\CsvmResources.Designer.cs">
      <AutoGen>True</AutoGen>
      <DesignTime>True</DesignTime>
      <DependentUpon>CsvmResources.resx</DependentUpon>
    </Compile>
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\AssemblyData\AssemblyData.csproj" />
    <ProjectReference Include="..\de4dot.blocks\de4dot.blocks.csproj" />
    <ProjectReference Include="..\de4dot.mdecrypt\de4dot.mdecrypt.csproj" />
  </ItemGroup>

  <ItemGroup>
    <Reference Include="System.Runtime.Remoting" Condition=" '$(De4DotNetFramework)' == 'true' " />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="System.Drawing.Common" Version="4.7.0" Condition=" '$(De4DotNetFramework)' != 'true' " />
  </ItemGroup>

</Project>



================================================
File: de4dot.code/7zip/ICoder.cs
================================================
// ICoder.h

using System;

namespace SevenZip
{
	/// <summary>
	/// The exception that is thrown when an error in input stream occurs during decoding.
	/// </summary>
	class DataErrorException : ApplicationException
	{
		public DataErrorException(): base("Data Error") { }
	}

	/// <summary>
	/// The exception that is thrown when the value of an argument is outside the allowable range.
	/// </summary>
	class InvalidParamException : ApplicationException
	{
		public InvalidParamException(): base("Invalid Parameter") { }
	}

	public interface ICodeProgress
	{
		/// <summary>
		/// Callback progress.
		/// </summary>
		/// <param name="inSize">
		/// input size. -1 if unknown.
		/// </param>
		/// <param name="outSize">
		/// output size. -1 if unknown.
		/// </param>
		void SetProgress(Int64 inSize, Int64 outSize);
	};

	public interface ICoder
	{
		/// <summary>
		/// Codes streams.
		/// </summary>
		/// <param name="inStream">
		/// input Stream.
		/// </param>
		/// <param name="outStream">
		/// output Stream.
		/// </param>
		/// <param name="inSize">
		/// input Size. -1 if unknown.
		/// </param>
		/// <param name="outSize">
		/// output Size. -1 if unknown.
		/// </param>
		/// <param name="progress">
		/// callback progress reference.
		/// </param>
		/// <exception cref="SevenZip.DataErrorException">
		/// if input stream is not valid
		/// </exception>
		void Code(System.IO.Stream inStream, System.IO.Stream outStream,
			Int64 inSize, Int64 outSize, ICodeProgress progress);
	};

	public interface ISetDecoderProperties
	{
		void SetDecoderProperties(byte[] properties);
	}
}



================================================
File: de4dot.code/7zip/Compress/LZ/LzOutWindow.cs
================================================
// LzOutWindow.cs

namespace SevenZip.Compression.LZ
{
	public class OutWindow
	{
		byte[] _buffer = null;
		uint _pos;
		uint _windowSize = 0;
		uint _streamPos;
		System.IO.Stream _stream;

		public uint TrainSize = 0;

		public void Create(uint windowSize)
		{
			if (_windowSize != windowSize)
			{
				// System.GC.Collect();
				_buffer = new byte[windowSize];
			}
			_windowSize = windowSize;
			_pos = 0;
			_streamPos = 0;
		}

		public void Init(System.IO.Stream stream, bool solid)
		{
			ReleaseStream();
			_stream = stream;
			if (!solid)
			{
				_streamPos = 0;
				_pos = 0;
				TrainSize = 0;
			}
		}
	
		public bool Train(System.IO.Stream stream)
		{
			long len = stream.Length;
			uint size = (len < _windowSize) ? (uint)len : _windowSize;
			TrainSize = size;
			stream.Position = len - size;
			_streamPos = _pos = 0;
			while (size > 0)
			{
				uint curSize = _windowSize - _pos;
				if (size < curSize)
					curSize = size;
				int numReadBytes = stream.Read(_buffer, (int)_pos, (int)curSize);
				if (numReadBytes == 0)
					return false;
				size -= (uint)numReadBytes;
				_pos += (uint)numReadBytes;
				_streamPos += (uint)numReadBytes;
				if (_pos == _windowSize)
					_streamPos = _pos = 0;
			}
			return true;
		}

		public void ReleaseStream()
		{
			Flush();
			_stream = null;
		}

		public void Flush()
		{
			uint size = _pos - _streamPos;
			if (size == 0)
				return;
			_stream.Write(_buffer, (int)_streamPos, (int)size);
			if (_pos >= _windowSize)
				_pos = 0;
			_streamPos = _pos;
		}

		public void CopyBlock(uint distance, uint len)
		{
			uint pos = _pos - distance - 1;
			if (pos >= _windowSize)
				pos += _windowSize;
			for (; len > 0; len--)
			{
				if (pos >= _windowSize)
					pos = 0;
				_buffer[_pos++] = _buffer[pos++];
				if (_pos >= _windowSize)
					Flush();
			}
		}

		public void PutByte(byte b)
		{
			_buffer[_pos++] = b;
			if (_pos >= _windowSize)
				Flush();
		}

		public byte GetByte(uint distance)
		{
			uint pos = _pos - distance - 1;
			if (pos >= _windowSize)
				pos += _windowSize;
			return _buffer[pos];
		}
	}
}



================================================
File: de4dot.code/7zip/Compress/LZMA/LzmaBase.cs
================================================
// LzmaBase.cs

namespace SevenZip.Compression.LZMA
{
	internal abstract class Base
	{
		public const uint kNumRepDistances = 4;
		public const uint kNumStates = 12;

		// static byte []kLiteralNextStates  = {0, 0, 0, 0, 1, 2, 3, 4,  5,  6,   4, 5};
		// static byte []kMatchNextStates    = {7, 7, 7, 7, 7, 7, 7, 10, 10, 10, 10, 10};
		// static byte []kRepNextStates      = {8, 8, 8, 8, 8, 8, 8, 11, 11, 11, 11, 11};
		// static byte []kShortRepNextStates = {9, 9, 9, 9, 9, 9, 9, 11, 11, 11, 11, 11};

		public struct State
		{
			public uint Index;
			public void Init() { Index = 0; }
			public void UpdateChar()
			{
				if (Index < 4) Index = 0;
				else if (Index < 10) Index -= 3;
				else Index -= 6;
			}
			public void UpdateMatch() { Index = (uint)(Index < 7 ? 7 : 10); }
			public void UpdateRep() { Index = (uint)(Index < 7 ? 8 : 11); }
			public void UpdateShortRep() { Index = (uint)(Index < 7 ? 9 : 11); }
			public bool IsCharState() { return Index < 7; }
		}

		public const int kNumPosSlotBits = 6;
		public const int kDicLogSizeMin = 0;
		// public const int kDicLogSizeMax = 30;
		// public const uint kDistTableSizeMax = kDicLogSizeMax * 2;

		public const int kNumLenToPosStatesBits = 2; // it's for speed optimization
		public const uint kNumLenToPosStates = 1 << kNumLenToPosStatesBits;

		public const uint kMatchMinLen = 2;

		public static uint GetLenToPosState(uint len)
		{
			len -= kMatchMinLen;
			if (len < kNumLenToPosStates)
				return len;
			return (uint)(kNumLenToPosStates - 1);
		}

		public const int kNumAlignBits = 4;
		public const uint kAlignTableSize = 1 << kNumAlignBits;
		public const uint kAlignMask = (kAlignTableSize - 1);

		public const uint kStartPosModelIndex = 4;
		public const uint kEndPosModelIndex = 14;
		public const uint kNumPosModels = kEndPosModelIndex - kStartPosModelIndex;

		public const uint kNumFullDistances = 1 << ((int)kEndPosModelIndex / 2);

		public const uint kNumLitPosStatesBitsEncodingMax = 4;
		public const uint kNumLitContextBitsMax = 8;

		public const int kNumPosStatesBitsMax = 4;
		public const uint kNumPosStatesMax = (1 << kNumPosStatesBitsMax);
		public const int kNumPosStatesBitsEncodingMax = 4;
		public const uint kNumPosStatesEncodingMax = (1 << kNumPosStatesBitsEncodingMax);

		public const int kNumLowLenBits = 3;
		public const int kNumMidLenBits = 3;
		public const int kNumHighLenBits = 8;
		public const uint kNumLowLenSymbols = 1 << kNumLowLenBits;
		public const uint kNumMidLenSymbols = 1 << kNumMidLenBits;
		public const uint kNumLenSymbols = kNumLowLenSymbols + kNumMidLenSymbols +
				(1 << kNumHighLenBits);
		public const uint kMatchMaxLen = kMatchMinLen + kNumLenSymbols - 1;
	}
}



================================================
File: de4dot.code/7zip/Compress/LZMA/LzmaDecoder.cs
================================================
// LzmaDecoder.cs

using System;

namespace SevenZip.Compression.LZMA
{
	using RangeCoder;

	public class Decoder : ICoder, ISetDecoderProperties // ,System.IO.Stream
	{
		class LenDecoder
		{
			BitDecoder m_Choice = new BitDecoder();
			BitDecoder m_Choice2 = new BitDecoder();
			BitTreeDecoder[] m_LowCoder = new BitTreeDecoder[Base.kNumPosStatesMax];
			BitTreeDecoder[] m_MidCoder = new BitTreeDecoder[Base.kNumPosStatesMax];
			BitTreeDecoder m_HighCoder = new BitTreeDecoder(Base.kNumHighLenBits);
			uint m_NumPosStates = 0;

			public void Create(uint numPosStates)
			{
				for (uint posState = m_NumPosStates; posState < numPosStates; posState++)
				{
					m_LowCoder[posState] = new BitTreeDecoder(Base.kNumLowLenBits);
					m_MidCoder[posState] = new BitTreeDecoder(Base.kNumMidLenBits);
				}
				m_NumPosStates = numPosStates;
			}

			public void Init()
			{
				m_Choice.Init();
				for (uint posState = 0; posState < m_NumPosStates; posState++)
				{
					m_LowCoder[posState].Init();
					m_MidCoder[posState].Init();
				}
				m_Choice2.Init();
				m_HighCoder.Init();
			}

			public uint Decode(RangeCoder.Decoder rangeDecoder, uint posState)
			{
				if (m_Choice.Decode(rangeDecoder) == 0)
					return m_LowCoder[posState].Decode(rangeDecoder);
				else
				{
					uint symbol = Base.kNumLowLenSymbols;
					if (m_Choice2.Decode(rangeDecoder) == 0)
						symbol += m_MidCoder[posState].Decode(rangeDecoder);
					else
					{
						symbol += Base.kNumMidLenSymbols;
						symbol += m_HighCoder.Decode(rangeDecoder);
					}
					return symbol;
				}
			}
		}

		class LiteralDecoder
		{
			struct Decoder2
			{
				BitDecoder[] m_Decoders;
				public void Create() { m_Decoders = new BitDecoder[0x300]; }
				public void Init() { for (int i = 0; i < 0x300; i++) m_Decoders[i].Init(); }

				public byte DecodeNormal(RangeCoder.Decoder rangeDecoder)
				{
					uint symbol = 1;
					do
						symbol = (symbol << 1) | m_Decoders[symbol].Decode(rangeDecoder);
					while (symbol < 0x100);
					return (byte)symbol;
				}

				public byte DecodeWithMatchByte(RangeCoder.Decoder rangeDecoder, byte matchByte)
				{
					uint symbol = 1;
					do
					{
						uint matchBit = (uint)(matchByte >> 7) & 1;
						matchByte <<= 1;
						uint bit = m_Decoders[((1 + matchBit) << 8) + symbol].Decode(rangeDecoder);
						symbol = (symbol << 1) | bit;
						if (matchBit != bit)
						{
							while (symbol < 0x100)
								symbol = (symbol << 1) | m_Decoders[symbol].Decode(rangeDecoder);
							break;
						}
					}
					while (symbol < 0x100);
					return (byte)symbol;
				}
			}

			Decoder2[] m_Coders;
			int m_NumPrevBits;
			int m_NumPosBits;
			uint m_PosMask;

			public void Create(int numPosBits, int numPrevBits)
			{
				if (m_Coders != null && m_NumPrevBits == numPrevBits &&
					m_NumPosBits == numPosBits)
					return;
				m_NumPosBits = numPosBits;
				m_PosMask = ((uint)1 << numPosBits) - 1;
				m_NumPrevBits = numPrevBits;
				uint numStates = (uint)1 << (m_NumPrevBits + m_NumPosBits);
				m_Coders = new Decoder2[numStates];
				for (uint i = 0; i < numStates; i++)
					m_Coders[i].Create();
			}

			public void Init()
			{
				uint numStates = (uint)1 << (m_NumPrevBits + m_NumPosBits);
				for (uint i = 0; i < numStates; i++)
					m_Coders[i].Init();
			}

			uint GetState(uint pos, byte prevByte)
			{ return ((pos & m_PosMask) << m_NumPrevBits) + (uint)(prevByte >> (8 - m_NumPrevBits)); }

			public byte DecodeNormal(RangeCoder.Decoder rangeDecoder, uint pos, byte prevByte)
			{ return m_Coders[GetState(pos, prevByte)].DecodeNormal(rangeDecoder); }

			public byte DecodeWithMatchByte(RangeCoder.Decoder rangeDecoder, uint pos, byte prevByte, byte matchByte)
			{ return m_Coders[GetState(pos, prevByte)].DecodeWithMatchByte(rangeDecoder, matchByte); }
		};

		LZ.OutWindow m_OutWindow = new LZ.OutWindow();
		RangeCoder.Decoder m_RangeDecoder = new RangeCoder.Decoder();

		BitDecoder[] m_IsMatchDecoders = new BitDecoder[Base.kNumStates << Base.kNumPosStatesBitsMax];
		BitDecoder[] m_IsRepDecoders = new BitDecoder[Base.kNumStates];
		BitDecoder[] m_IsRepG0Decoders = new BitDecoder[Base.kNumStates];
		BitDecoder[] m_IsRepG1Decoders = new BitDecoder[Base.kNumStates];
		BitDecoder[] m_IsRepG2Decoders = new BitDecoder[Base.kNumStates];
		BitDecoder[] m_IsRep0LongDecoders = new BitDecoder[Base.kNumStates << Base.kNumPosStatesBitsMax];

		BitTreeDecoder[] m_PosSlotDecoder = new BitTreeDecoder[Base.kNumLenToPosStates];
		BitDecoder[] m_PosDecoders = new BitDecoder[Base.kNumFullDistances - Base.kEndPosModelIndex];

		BitTreeDecoder m_PosAlignDecoder = new BitTreeDecoder(Base.kNumAlignBits);

		LenDecoder m_LenDecoder = new LenDecoder();
		LenDecoder m_RepLenDecoder = new LenDecoder();

		LiteralDecoder m_LiteralDecoder = new LiteralDecoder();

		uint m_DictionarySize;
		uint m_DictionarySizeCheck;

		uint m_PosStateMask;

		public Decoder()
		{
			m_DictionarySize = 0xFFFFFFFF;
			for (int i = 0; i < Base.kNumLenToPosStates; i++)
				m_PosSlotDecoder[i] = new BitTreeDecoder(Base.kNumPosSlotBits);
		}

		void SetDictionarySize(uint dictionarySize)
		{
			if (m_DictionarySize != dictionarySize)
			{
				m_DictionarySize = dictionarySize;
				m_DictionarySizeCheck = Math.Max(m_DictionarySize, 1);
				uint blockSize = Math.Max(m_DictionarySizeCheck, (1 << 12));
				m_OutWindow.Create(blockSize);
			}
		}

		void SetLiteralProperties(int lp, int lc)
		{
			if (lp > 8)
				throw new InvalidParamException();
			if (lc > 8)
				throw new InvalidParamException();
			m_LiteralDecoder.Create(lp, lc);
		}

		void SetPosBitsProperties(int pb)
		{
			if (pb > Base.kNumPosStatesBitsMax)
				throw new InvalidParamException();
			uint numPosStates = (uint)1 << pb;
			m_LenDecoder.Create(numPosStates);
			m_RepLenDecoder.Create(numPosStates);
			m_PosStateMask = numPosStates - 1;
		}

		bool _solid = false;
		void Init(System.IO.Stream inStream, System.IO.Stream outStream)
		{
			m_RangeDecoder.Init(inStream);
			m_OutWindow.Init(outStream, _solid);

			uint i;
			for (i = 0; i < Base.kNumStates; i++)
			{
				for (uint j = 0; j <= m_PosStateMask; j++)
				{
					uint index = (i << Base.kNumPosStatesBitsMax) + j;
					m_IsMatchDecoders[index].Init();
					m_IsRep0LongDecoders[index].Init();
				}
				m_IsRepDecoders[i].Init();
				m_IsRepG0Decoders[i].Init();
				m_IsRepG1Decoders[i].Init();
				m_IsRepG2Decoders[i].Init();
			}

			m_LiteralDecoder.Init();
			for (i = 0; i < Base.kNumLenToPosStates; i++)
				m_PosSlotDecoder[i].Init();
			// m_PosSpecDecoder.Init();
			for (i = 0; i < Base.kNumFullDistances - Base.kEndPosModelIndex; i++)
				m_PosDecoders[i].Init();

			m_LenDecoder.Init();
			m_RepLenDecoder.Init();
			m_PosAlignDecoder.Init();
		}

		public void Code(System.IO.Stream inStream, System.IO.Stream outStream,
			Int64 inSize, Int64 outSize, ICodeProgress progress)
		{
			Init(inStream, outStream);

			Base.State state = new Base.State();
			state.Init();
			uint rep0 = 0, rep1 = 0, rep2 = 0, rep3 = 0;

			UInt64 nowPos64 = 0;
			UInt64 outSize64 = (UInt64)outSize;
			if (nowPos64 < outSize64)
			{
				if (m_IsMatchDecoders[state.Index << Base.kNumPosStatesBitsMax].Decode(m_RangeDecoder) != 0)
					throw new DataErrorException();
				state.UpdateChar();
				byte b = m_LiteralDecoder.DecodeNormal(m_RangeDecoder, 0, 0);
				m_OutWindow.PutByte(b);
				nowPos64++;
			}
			while (nowPos64 < outSize64)
			{
				// UInt64 next = Math.Min(nowPos64 + (1 << 18), outSize64);
					// while(nowPos64 < next)
				{
					uint posState = (uint)nowPos64 & m_PosStateMask;
					if (m_IsMatchDecoders[(state.Index << Base.kNumPosStatesBitsMax) + posState].Decode(m_RangeDecoder) == 0)
					{
						byte b;
						byte prevByte = m_OutWindow.GetByte(0);
						if (!state.IsCharState())
							b = m_LiteralDecoder.DecodeWithMatchByte(m_RangeDecoder,
								(uint)nowPos64, prevByte, m_OutWindow.GetByte(rep0));
						else
							b = m_LiteralDecoder.DecodeNormal(m_RangeDecoder, (uint)nowPos64, prevByte);
						m_OutWindow.PutByte(b);
						state.UpdateChar();
						nowPos64++;
					}
					else
					{
						uint len;
						if (m_IsRepDecoders[state.Index].Decode(m_RangeDecoder) == 1)
						{
							if (m_IsRepG0Decoders[state.Index].Decode(m_RangeDecoder) == 0)
							{
								if (m_IsRep0LongDecoders[(state.Index << Base.kNumPosStatesBitsMax) + posState].Decode(m_RangeDecoder) == 0)
								{
									state.UpdateShortRep();
									m_OutWindow.PutByte(m_OutWindow.GetByte(rep0));
									nowPos64++;
									continue;
								}
							}
							else
							{
								UInt32 distance;
								if (m_IsRepG1Decoders[state.Index].Decode(m_RangeDecoder) == 0)
								{
									distance = rep1;
								}
								else
								{
									if (m_IsRepG2Decoders[state.Index].Decode(m_RangeDecoder) == 0)
										distance = rep2;
									else
									{
										distance = rep3;
										rep3 = rep2;
									}
									rep2 = rep1;
								}
								rep1 = rep0;
								rep0 = distance;
							}
							len = m_RepLenDecoder.Decode(m_RangeDecoder, posState) + Base.kMatchMinLen;
							state.UpdateRep();
						}
						else
						{
							rep3 = rep2;
							rep2 = rep1;
							rep1 = rep0;
							len = Base.kMatchMinLen + m_LenDecoder.Decode(m_RangeDecoder, posState);
							state.UpdateMatch();
							uint posSlot = m_PosSlotDecoder[Base.GetLenToPosState(len)].Decode(m_RangeDecoder);
							if (posSlot >= Base.kStartPosModelIndex)
							{
								int numDirectBits = (int)((posSlot >> 1) - 1);
								rep0 = ((2 | (posSlot & 1)) << numDirectBits);
								if (posSlot < Base.kEndPosModelIndex)
									rep0 += BitTreeDecoder.ReverseDecode(m_PosDecoders,
											rep0 - posSlot - 1, m_RangeDecoder, numDirectBits);
								else
								{
									rep0 += (m_RangeDecoder.DecodeDirectBits(
										numDirectBits - Base.kNumAlignBits) << Base.kNumAlignBits);
									rep0 += m_PosAlignDecoder.ReverseDecode(m_RangeDecoder);
								}
							}
							else
								rep0 = posSlot;
						}
						if (rep0 >= m_OutWindow.TrainSize + nowPos64 || rep0 >= m_DictionarySizeCheck)
						{
							if (rep0 == 0xFFFFFFFF)
								break;
							throw new DataErrorException();
						}
						m_OutWindow.CopyBlock(rep0, len);
						nowPos64 += len;
					}
				}
			}
			m_OutWindow.Flush();
			m_OutWindow.ReleaseStream();
			m_RangeDecoder.ReleaseStream();
		}

		public void SetDecoderProperties(byte[] properties)
		{
			if (properties.Length < 5)
				throw new InvalidParamException();
			int lc = properties[0] % 9;
			int remainder = properties[0] / 9;
			int lp = remainder % 5;
			int pb = remainder / 5;
			if (pb > Base.kNumPosStatesBitsMax)
				throw new InvalidParamException();
			UInt32 dictionarySize = 0;
			for (int i = 0; i < 4; i++)
				dictionarySize += ((UInt32)(properties[1 + i])) << (i * 8);
			SetDictionarySize(dictionarySize);
			SetLiteralProperties(lp, lc);
			SetPosBitsProperties(pb);
		}

		public bool Train(System.IO.Stream stream)
		{
			_solid = true;
			return m_OutWindow.Train(stream);
		}

		/*
		public override bool CanRead { get { return true; }}
		public override bool CanWrite { get { return true; }}
		public override bool CanSeek { get { return true; }}
		public override long Length { get { return 0; }}
		public override long Position
		{
			get { return 0;	}
			set { }
		}
		public override void Flush() { }
		public override int Read(byte[] buffer, int offset, int count) 
		{
			return 0;
		}
		public override void Write(byte[] buffer, int offset, int count)
		{
		}
		public override long Seek(long offset, System.IO.SeekOrigin origin)
		{
			return 0;
		}
		public override void SetLength(long value) {}
		*/
	}
}



================================================
File: de4dot.code/7zip/Compress/RangeCoder/RangeCoder.cs
================================================
namespace SevenZip.Compression.RangeCoder
{
	class Decoder
	{
		public const uint kTopValue = (1 << 24);
		public uint Range;
		public uint Code;
		// public Buffer.InBuffer Stream = new Buffer.InBuffer(1 << 16);
		public System.IO.Stream Stream;

		public void Init(System.IO.Stream stream)
		{
			// Stream.Init(stream);
			Stream = stream;

			Code = 0;
			Range = 0xFFFFFFFF;
			for (int i = 0; i < 5; i++)
				Code = (Code << 8) | (byte)Stream.ReadByte();
		}

		public void ReleaseStream()
		{
			// Stream.ReleaseStream();
			Stream = null;
		}

		public void CloseStream()
		{
			Stream.Close();
		}

		public void Normalize()
		{
			while (Range < kTopValue)
			{
				Code = (Code << 8) | (byte)Stream.ReadByte();
				Range <<= 8;
			}
		}

		public void Normalize2()
		{
			if (Range < kTopValue)
			{
				Code = (Code << 8) | (byte)Stream.ReadByte();
				Range <<= 8;
			}
		}

		public uint GetThreshold(uint total)
		{
			return Code / (Range /= total);
		}

		public void Decode(uint start, uint size, uint total)
		{
			Code -= start * Range;
			Range *= size;
			Normalize();
		}

		public uint DecodeDirectBits(int numTotalBits)
		{
			uint range = Range;
			uint code = Code;
			uint result = 0;
			for (int i = numTotalBits; i > 0; i--)
			{
				range >>= 1;
				/*
				result <<= 1;
				if (code >= range)
				{
					code -= range;
					result |= 1;
				}
				*/
				uint t = (code - range) >> 31;
				code -= range & (t - 1);
				result = (result << 1) | (1 - t);

				if (range < kTopValue)
				{
					code = (code << 8) | (byte)Stream.ReadByte();
					range <<= 8;
				}
			}
			Range = range;
			Code = code;
			return result;
		}

		public uint DecodeBit(uint size0, int numTotalBits)
		{
			uint newBound = (Range >> numTotalBits) * size0;
			uint symbol;
			if (Code < newBound)
			{
				symbol = 0;
				Range = newBound;
			}
			else
			{
				symbol = 1;
				Code -= newBound;
				Range -= newBound;
			}
			Normalize();
			return symbol;
		}

		// ulong GetProcessedSize() {return Stream.GetProcessedSize(); }
	}
}



================================================
File: de4dot.code/7zip/Compress/RangeCoder/RangeCoderBit.cs
================================================
namespace SevenZip.Compression.RangeCoder
{
	struct BitDecoder
	{
		public const int kNumBitModelTotalBits = 11;
		public const uint kBitModelTotal = (1 << kNumBitModelTotalBits);
		const int kNumMoveBits = 5;

		uint Prob;

		public void UpdateModel(int numMoveBits, uint symbol)
		{
			if (symbol == 0)
				Prob += (kBitModelTotal - Prob) >> numMoveBits;
			else
				Prob -= (Prob) >> numMoveBits;
		}

		public void Init() { Prob = kBitModelTotal >> 1; }

		public uint Decode(RangeCoder.Decoder rangeDecoder)
		{
			uint newBound = (uint)(rangeDecoder.Range >> kNumBitModelTotalBits) * (uint)Prob;
			if (rangeDecoder.Code < newBound)
			{
				rangeDecoder.Range = newBound;
				Prob += (kBitModelTotal - Prob) >> kNumMoveBits;
				if (rangeDecoder.Range < Decoder.kTopValue)
				{
					rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();
					rangeDecoder.Range <<= 8;
				}
				return 0;
			}
			else
			{
				rangeDecoder.Range -= newBound;
				rangeDecoder.Code -= newBound;
				Prob -= (Prob) >> kNumMoveBits;
				if (rangeDecoder.Range < Decoder.kTopValue)
				{
					rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();
					rangeDecoder.Range <<= 8;
				}
				return 1;
			}
		}
	}
}



================================================
File: de4dot.code/7zip/Compress/RangeCoder/RangeCoderBitTree.cs
================================================
using System;

namespace SevenZip.Compression.RangeCoder
{
	struct BitTreeDecoder
	{
		BitDecoder[] Models;
		int NumBitLevels;

		public BitTreeDecoder(int numBitLevels)
		{
			NumBitLevels = numBitLevels;
			Models = new BitDecoder[1 << numBitLevels];
		}

		public void Init()
		{
			for (uint i = 1; i < (1 << NumBitLevels); i++)
				Models[i].Init();
		}

		public uint Decode(RangeCoder.Decoder rangeDecoder)
		{
			uint m = 1;
			for (int bitIndex = NumBitLevels; bitIndex > 0; bitIndex--)
				m = (m << 1) + Models[m].Decode(rangeDecoder);
			return m - ((uint)1 << NumBitLevels);
		}

		public uint ReverseDecode(RangeCoder.Decoder rangeDecoder)
		{
			uint m = 1;
			uint symbol = 0;
			for (int bitIndex = 0; bitIndex < NumBitLevels; bitIndex++)
			{
				uint bit = Models[m].Decode(rangeDecoder);
				m <<= 1;
				m += bit;
				symbol |= (bit << bitIndex);
			}
			return symbol;
		}

		public static uint ReverseDecode(BitDecoder[] Models, UInt32 startIndex,
			RangeCoder.Decoder rangeDecoder, int NumBitLevels)
		{
			uint m = 1;
			uint symbol = 0;
			for (int bitIndex = 0; bitIndex < NumBitLevels; bitIndex++)
			{
				uint bit = Models[startIndex + m].Decode(rangeDecoder);
				m <<= 1;
				m += bit;
				symbol |= (bit << bitIndex);
			}
			return symbol;
		}
	}
}



================================================
File: de4dot.code/AssemblyClient/AssemblyClient.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Runtime.Remoting;
using System.Runtime.Serialization;
using System.Threading;
using AssemblyData;

#if !NETFRAMEWORK
namespace System.Runtime.Remoting {
	class RemotingException : SystemException {
	}
}
#endif

namespace de4dot.code.AssemblyClient {
	public sealed class AssemblyClient : IAssemblyClient {
		const int WAIT_TIME_BEFORE_CONNECTING = 1000;
		const int MAX_CONNECT_WAIT_TIME_MS = 2000;
		IAssemblyServerLoader loader;
		IAssemblyService service;
		DateTime serverLoadedTime;

		public IAssemblyService Service => service;
		public IStringDecrypterService StringDecrypterService => (IStringDecrypterService)service;
		public IMethodDecrypterService MethodDecrypterService => (IMethodDecrypterService)service;
		public IGenericService GenericService => (IGenericService)service;
		public AssemblyClient(IAssemblyServerLoader loader) => this.loader = loader;

		public void Connect() {
			loader.LoadServer();
			service = loader.CreateService();
			serverLoadedTime = DateTime.UtcNow;
		}

		public void WaitConnected() {
			// If we don't wait here, we'll sometimes get stuck in doNothing(). Make sure the
			// server has had time to start... This only seems to be needed when starting a
			// server in a different process, though.
			var loadedTime = DateTime.UtcNow - serverLoadedTime;
			var waitTime = WAIT_TIME_BEFORE_CONNECTING - (int)loadedTime.TotalMilliseconds;
			if (waitTime > 0)
				Thread.Sleep(waitTime);

			var startTime = DateTime.UtcNow;
			while (true) {
				try {
					service.DoNothing();
					break;
				}
				catch (RemotingException) {
					// Couldn't connect
				}
				var elapsedTime = DateTime.UtcNow - startTime;
				if (elapsedTime.TotalMilliseconds >= MAX_CONNECT_WAIT_TIME_MS)
					throw new ApplicationException("Could not connect to server");
				Thread.Sleep(20);
			}
		}

		public void Dispose() {
			if (service != null) {
				try {
					service.Exit();
				}
				catch (RemotingException) {
					// Couldn't connect
				}
				catch (SerializationException) {
					// For this: "End of Stream encountered before parsing was completed."
				}
				service = null;
			}
			if (loader != null) {
				loader.Dispose();
				loader = null;
			}
		}
	}
}



================================================
File: de4dot.code/AssemblyClient/AssemblyClientFactory.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using dnlib.DotNet;
using AssemblyData;

namespace de4dot.code.AssemblyClient {
	public interface IAssemblyClientFactory {
		IAssemblyClient Create(AssemblyServiceType serviceType);
	}

	public class SameAppDomainAssemblyClientFactory : IAssemblyClientFactory {
		public IAssemblyClient Create(AssemblyServiceType serviceType) => new AssemblyClient(new SameAppDomainAssemblyServerLoader(serviceType));
	}

	public class NewAppDomainAssemblyClientFactory : IAssemblyClientFactory {
		public IAssemblyClient Create(AssemblyServiceType serviceType) =>
#if NETFRAMEWORK
			new AssemblyClient(new NewAppDomainAssemblyServerLoader(serviceType));
#else
			new AssemblyClient(new SameAppDomainAssemblyServerLoader(serviceType));
#endif
	}

	public class NewProcessAssemblyClientFactory : IAssemblyClientFactory {
		ServerClrVersion serverVersion;

		public NewProcessAssemblyClientFactory() => serverVersion = ServerClrVersion.CLR_ANY_ANYCPU;
		public NewProcessAssemblyClientFactory(ServerClrVersion serverVersion) => this.serverVersion = serverVersion;

		public IAssemblyClient Create(AssemblyServiceType serviceType, ModuleDef module) =>
#if NETFRAMEWORK
			new AssemblyClient(new NewProcessAssemblyServerLoader(serviceType, GetServerClrVersion(module)));
#else
			new AssemblyClient(new SameAppDomainAssemblyServerLoader(serviceType));
#endif

		public IAssemblyClient Create(AssemblyServiceType serviceType) =>
#if NETFRAMEWORK
			new AssemblyClient(new NewProcessAssemblyServerLoader(serviceType, serverVersion));
#else
			new AssemblyClient(new SameAppDomainAssemblyServerLoader(serviceType));
#endif

		public static ServerClrVersion GetServerClrVersion(ModuleDef module) {
			switch (module.GetPointerSize()) {
			default:
			case 4:
				if (module.IsClr40)
					return ServerClrVersion.CLR_v40_x86;
				return ServerClrVersion.CLR_v20_x86;

			case 8:
				if (module.IsClr40)
					return ServerClrVersion.CLR_v40_x64;
				return ServerClrVersion.CLR_v20_x64;
			}
		}
	}
}



================================================
File: de4dot.code/AssemblyClient/IAssemblyClient.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using AssemblyData;

namespace de4dot.code.AssemblyClient {
	public interface IAssemblyClient : IDisposable {
		IAssemblyService Service { get; }
		IStringDecrypterService StringDecrypterService { get; }
		IMethodDecrypterService MethodDecrypterService { get; }
		IGenericService GenericService { get; }
		void Connect();
		void WaitConnected();
	}
}



================================================
File: de4dot.code/AssemblyClient/IAssemblyServerLoader.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using AssemblyData;

namespace de4dot.code.AssemblyClient {
	public interface IAssemblyServerLoader : IDisposable {
		void LoadServer();
		IAssemblyService CreateService();
	}
}



================================================
File: de4dot.code/AssemblyClient/IpcAssemblyServerLoader.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

#if NETFRAMEWORK
using System;
using AssemblyData;

namespace de4dot.code.AssemblyClient {
	public abstract class IpcAssemblyServerLoader : IAssemblyServerLoader {
		readonly string assemblyServerFilename;
		protected string ipcName;
		protected string ipcUri;
		protected AssemblyServiceType serviceType;
		string url;

		protected IpcAssemblyServerLoader(AssemblyServiceType serviceType)
			: this(serviceType, ServerClrVersion.CLR_ANY_ANYCPU) {
		}

		protected IpcAssemblyServerLoader(AssemblyServiceType serviceType, ServerClrVersion serverVersion) {
			this.serviceType = serviceType;
			assemblyServerFilename = GetServerName(serverVersion);
			ipcName = Utils.RandomName(15, 20);
			ipcUri = Utils.RandomName(15, 20);
			url = $"ipc://{ipcName}/{ipcUri}";
		}

		static string GetServerName(ServerClrVersion serverVersion) {
			if (serverVersion == ServerClrVersion.CLR_ANY_ANYCPU)
				serverVersion = IntPtr.Size == 4 ? ServerClrVersion.CLR_ANY_x86 : ServerClrVersion.CLR_ANY_x64;
			switch (serverVersion) {
			case ServerClrVersion.CLR_ANY_x86: return "AssemblyServer.exe";
			case ServerClrVersion.CLR_ANY_x64: return "AssemblyServer-x64.exe";
			case ServerClrVersion.CLR_v20_x86: return "AssemblyServer-CLR20.exe";
			case ServerClrVersion.CLR_v20_x64: return "AssemblyServer-CLR20-x64.exe";
			case ServerClrVersion.CLR_v40_x86: return "AssemblyServer-CLR40.exe";
			case ServerClrVersion.CLR_v40_x64: return "AssemblyServer-CLR40-x64.exe";
			default: throw new ArgumentException($"Invalid server version: {serverVersion}");
			}
		}

		public void LoadServer() => LoadServer(Utils.GetPathOfOurFile(assemblyServerFilename));
		public abstract void LoadServer(string filename);
		public IAssemblyService CreateService() => (IAssemblyService)Activator.GetObject(AssemblyService.GetType(serviceType), url);
		public abstract void Dispose();
	}
}
#endif



================================================
File: de4dot.code/AssemblyClient/NewAppDomainAssemblyServerLoader.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

#if NETFRAMEWORK
using System;
using System.Threading;
using AssemblyData;

namespace de4dot.code.AssemblyClient {
	// Starts the server in a new app domain.
	public sealed class NewAppDomainAssemblyServerLoader : IpcAssemblyServerLoader {
		AppDomain appDomain;
		Thread thread;

		public NewAppDomainAssemblyServerLoader(AssemblyServiceType serviceType)
			: base(serviceType) {
		}

		public override void LoadServer(string filename) {
			if (appDomain != null)
				throw new ApplicationException("Server is already loaded");

			appDomain = AppDomain.CreateDomain(Utils.RandomName(15, 20));
			thread = new Thread(new ThreadStart(() => {
				try {
#if NET35
					appDomain.ExecuteAssembly(filename, null, new string[] {
#elif NET45
					appDomain.ExecuteAssembly(filename, new string[] {
#else
#error Unknown tfm
#endif
						((int)serviceType).ToString(), ipcName, ipcUri
					});
				}
				catch (NullReferenceException) {
					// Here if appDomain was set to null by Dispose() before this thread started
				}
				catch (AppDomainUnloadedException) {
					// Here if it was unloaded by Dispose()
				}
				UnloadAppDomain(appDomain);
				appDomain = null;
			}));
			thread.Start();
		}

		public override void Dispose() {
			UnloadAppDomain(appDomain);
			if (thread != null) {
				try {
					if (!thread.Join(100))
						thread.Abort();
				}
				catch (ThreadStateException) {
					// Here if eg. the thread wasn't started
				}
				thread = null;
			}
			// It could still be loaded if the thread was aborted so do it again
			UnloadAppDomain(appDomain);
			appDomain = null;
		}

		static void UnloadAppDomain(AppDomain appDomain) {
			if (appDomain != null) {
				try {
					AppDomain.Unload(appDomain);
				}
				catch (AppDomainUnloadedException) {
				}
				catch (CannotUnloadAppDomainException) {
				}
			}
		}
	}
}
#endif



================================================
File: de4dot.code/AssemblyClient/NewProcessAssemblyServerLoader.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

#if NETFRAMEWORK
using System;
using System.Diagnostics;
using AssemblyData;

namespace de4dot.code.AssemblyClient {
	// Starts the server in a new process
	public class NewProcessAssemblyServerLoader : IpcAssemblyServerLoader {
		Process process;

		public NewProcessAssemblyServerLoader(AssemblyServiceType serviceType)
			: base(serviceType) {
		}

		public NewProcessAssemblyServerLoader(AssemblyServiceType serviceType, ServerClrVersion version)
			: base(serviceType, version) {
		}

		public override void LoadServer(string filename) {
			if (process != null)
				throw new ApplicationException("Server is already loaded");

			var psi = new ProcessStartInfo {
				Arguments = $"{(int)serviceType} {Utils.ShellEscape(ipcName)} {Utils.ShellEscape(ipcUri)}",
				CreateNoWindow = true,
				ErrorDialog = false,
				FileName = filename,
				LoadUserProfile = false,
				UseShellExecute = false,
				WorkingDirectory = Utils.GetOurBaseDir(),
			};
			process = Process.Start(psi);
			if (process == null)
				throw new ApplicationException("Could not start process");
		}

		public override void Dispose() {
			if (process != null) {
				if (!process.WaitForExit(300)) {
					try {
						process.Kill();
					}
					catch (InvalidOperationException) {
						// Here if process has already exited.
					}
				}
				process = null;
			}
		}
	}
}
#endif



================================================
File: de4dot.code/AssemblyClient/SameAppDomainAssemblyServerLoader.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using AssemblyData;

namespace de4dot.code.AssemblyClient {
	// Starts the server in the current app domain.
	public class SameAppDomainAssemblyServerLoader : IAssemblyServerLoader {
		IAssemblyService service;
		AssemblyServiceType serviceType;

		public SameAppDomainAssemblyServerLoader(AssemblyServiceType serviceType) => this.serviceType = serviceType;

		public void LoadServer() {
			if (service != null)
				throw new ApplicationException("Server already loaded");
			service = AssemblyService.Create(serviceType);
		}

		public IAssemblyService CreateService() => service;
		public void Dispose() { }
	}
}



================================================
File: de4dot.code/AssemblyClient/ServerClrVersion.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

namespace de4dot.code.AssemblyClient {
	public enum ServerClrVersion {
		CLR_ANY_ANYCPU,
		CLR_ANY_x86,
		CLR_ANY_x64,
		CLR_v20_x86,
		CLR_v20_x64,
		CLR_v40_x86,
		CLR_v40_x64,
	}
}



================================================
File: de4dot.code/SharpZipLib/Main.cs
================================================
// Main.cs
//
// Copyright (C) 2001 Mike Krueger
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
//
// Linking this library statically or dynamically with other modules is
// making a combined work based on this library.  Thus, the terms and
// conditions of the GNU General Public License cover the whole
// combination.
// 
// As a special exception, the copyright holders of this library give you
// permission to link this library with independent modules to produce an
// executable, regardless of the license terms of these independent
// modules, and to copy and distribute the resulting executable under
// terms of your choice, provided that you also meet, for each linked
// independent module, the terms and conditions of the license of that
// module.  An independent module is a module which is not derived from
// or based on this library.  If you modify this library, you may extend
// this exception to your version of the library, but you are not
// obligated to do so.  If you do not wish to do so, delete this
// exception statement from your version.
//




================================================
File: de4dot.code/SharpZipLib/SharpZipBaseException.cs
================================================
// SharpZipBaseException.cs
//
// Copyright 2004 John Reilly
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
//
// Linking this library statically or dynamically with other modules is
// making a combined work based on this library.  Thus, the terms and
// conditions of the GNU General Public License cover the whole
// combination.
// 
// As a special exception, the copyright holders of this library give you
// permission to link this library with independent modules to produce an
// executable, regardless of the license terms of these independent
// modules, and to copy and distribute the resulting executable under
// terms of your choice, provided that you also meet, for each linked
// independent module, the terms and conditions of the license of that
// module.  An independent module is a module which is not derived from
// or based on this library.  If you modify this library, you may extend
// this exception to your version of the library, but you are not
// obligated to do so.  If you do not wish to do so, delete this
// exception statement from your version.

using System;

#if !NETCF_1_0 && !NETCF_2_0
using System.Runtime.Serialization;
#endif

namespace ICSharpCode.SharpZipLib
{
	/// <summary>
	/// SharpZipBaseException is the base exception class for the SharpZipLibrary.
	/// All library exceptions are derived from this.
	/// </summary>
	/// <remarks>NOTE: Not all exceptions thrown will be derived from this class.
	/// A variety of other exceptions are possible for example <see cref="ArgumentNullException"></see></remarks>
#if !NETCF_1_0 && !NETCF_2_0
	[Serializable]
#endif
	public class SharpZipBaseException : ApplicationException
	{
#if !NETCF_1_0 && !NETCF_2_0
		/// <summary>
		/// Deserialization constructor 
		/// </summary>
		/// <param name="info"><see cref="System.Runtime.Serialization.SerializationInfo"/> for this constructor</param>
		/// <param name="context"><see cref="StreamingContext"/> for this constructor</param>
		protected SharpZipBaseException(SerializationInfo info, StreamingContext context )
			: base( info, context )
		{
		}
#endif
		
		/// <summary>
		/// Initializes a new instance of the SharpZipBaseException class.
		/// </summary>
		public SharpZipBaseException()
		{
		}
		
		/// <summary>
		/// Initializes a new instance of the SharpZipBaseException class with a specified error message.
		/// </summary>
		/// <param name="message">A message describing the exception.</param>
		public SharpZipBaseException(string message)
			: base(message)
		{
		}

		/// <summary>
		/// Initializes a new instance of the SharpZipBaseException class with a specified
		/// error message and a reference to the inner exception that is the cause of this exception.
		/// </summary>
		/// <param name="message">A message describing the exception.</param>
		/// <param name="innerException">The inner exception</param>
		public SharpZipBaseException(string message, Exception innerException)
			: base(message, innerException)
		{
		}
	}
}



================================================
File: de4dot.code/SharpZipLib/Checksums/Adler32.cs
================================================
// Adler32.cs - Computes Adler32 data checksum of a data stream
// Copyright (C) 2001 Mike Krueger
//
// This file was translated from java, it was part of the GNU Classpath
// Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
//
// Linking this library statically or dynamically with other modules is
// making a combined work based on this library.  Thus, the terms and
// conditions of the GNU General Public License cover the whole
// combination.
// 
// As a special exception, the copyright holders of this library give you
// permission to link this library with independent modules to produce an
// executable, regardless of the license terms of these independent
// modules, and to copy and distribute the resulting executable under
// terms of your choice, provided that you also meet, for each linked
// independent module, the terms and conditions of the license of that
// module.  An independent module is a module which is not derived from
// or based on this library.  If you modify this library, you may extend
// this exception to your version of the library, but you are not
// obligated to do so.  If you do not wish to do so, delete this
// exception statement from your version.

using System;

namespace ICSharpCode.SharpZipLib.Checksums 
{
	
	/// <summary>
	/// Computes Adler32 checksum for a stream of data. An Adler32
	/// checksum is not as reliable as a CRC32 checksum, but a lot faster to
	/// compute.
	/// 
	/// The specification for Adler32 may be found in RFC 1950.
	/// ZLIB Compressed Data Format Specification version 3.3)
	/// 
	/// 
	/// From that document:
	/// 
	///      "ADLER32 (Adler-32 checksum)
	///       This contains a checksum value of the uncompressed data
	///       (excluding any dictionary data) computed according to Adler-32
	///       algorithm. This algorithm is a 32-bit extension and improvement
	///       of the Fletcher algorithm, used in the ITU-T X.224 / ISO 8073
	///       standard.
	/// 
	///       Adler-32 is composed of two sums accumulated per byte: s1 is
	///       the sum of all bytes, s2 is the sum of all s1 values. Both sums
	///       are done modulo 65521. s1 is initialized to 1, s2 to zero.  The
	///       Adler-32 checksum is stored as s2*65536 + s1 in most-
	///       significant-byte first (network) order."
	/// 
	///  "8.2. The Adler-32 algorithm
	/// 
	///    The Adler-32 algorithm is much faster than the CRC32 algorithm yet
	///    still provides an extremely low probability of undetected errors.
	/// 
	///    The modulo on unsigned long accumulators can be delayed for 5552
	///    bytes, so the modulo operation time is negligible.  If the bytes
	///    are a, b, c, the second sum is 3a + 2b + c + 3, and so is position
	///    and order sensitive, unlike the first sum, which is just a
	///    checksum.  That 65521 is prime is important to avoid a possible
	///    large class of two-byte errors that leave the check unchanged.
	///    (The Fletcher checksum uses 255, which is not prime and which also
	///    makes the Fletcher check insensitive to single byte changes 0 -
	///    255.)
	/// 
	///    The sum s1 is initialized to 1 instead of zero to make the length
	///    of the sequence part of s2, so that the length does not have to be
	///    checked separately. (Any sequence of zeroes has a Fletcher
	///    checksum of zero.)"
	/// </summary>
	/// <see cref="ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream"/>
	/// <see cref="ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream"/>
	public sealed class Adler32 : IChecksum
	{
		/// <summary>
		/// largest prime smaller than 65536
		/// </summary>
		const uint BASE = 65521;
		
		/// <summary>
		/// Returns the Adler32 data checksum computed so far.
		/// </summary>
		public long Value {
			get {
				return checksum;
			}
		}
		
		/// <summary>
		/// Creates a new instance of the Adler32 class.
		/// The checksum starts off with a value of 1.
		/// </summary>
		public Adler32()
		{
			Reset();
		}
		
		/// <summary>
		/// Resets the Adler32 checksum to the initial value.
		/// </summary>
		public void Reset()
		{
			checksum = 1;
		}
		
		/// <summary>
		/// Updates the checksum with a byte value.
		/// </summary>
		/// <param name="value">
		/// The data value to add. The high byte of the int is ignored.
		/// </param>
		public void Update(int value)
		{
			// We could make a length 1 byte array and call update again, but I
			// would rather not have that overhead
			uint s1 = checksum & 0xFFFF;
			uint s2 = checksum >> 16;
			
			s1 = (s1 + ((uint)value & 0xFF)) % BASE;
			s2 = (s1 + s2) % BASE;
			
			checksum = (s2 << 16) + s1;
		}
		
		/// <summary>
		/// Updates the checksum with an array of bytes.
		/// </summary>
		/// <param name="buffer">
		/// The source of the data to update with.
		/// </param>
		public void Update(byte[] buffer)
		{
			if ( buffer == null ) {
				throw new ArgumentNullException("buffer");
			}

			Update(buffer, 0, buffer.Length);
		}
		
		/// <summary>
		/// Updates the checksum with the bytes taken from the array.
		/// </summary>
		/// <param name="buffer">
		/// an array of bytes
		/// </param>
		/// <param name="offset">
		/// the start of the data used for this update
		/// </param>
		/// <param name="count">
		/// the number of bytes to use for this update
		/// </param>
		public void Update(byte[] buffer, int offset, int count)
		{
			if (buffer == null) {
				throw new ArgumentNullException("buffer");
			}
			
			if (offset < 0) {
#if NETCF_1_0
				throw new ArgumentOutOfRangeException("offset");
#else
				throw new ArgumentOutOfRangeException("offset", "cannot be negative");
#endif				
			}

			if ( count < 0 ) 
			{
#if NETCF_1_0
				throw new ArgumentOutOfRangeException("count");
#else
				throw new ArgumentOutOfRangeException("count", "cannot be negative");
#endif				
			}

			if (offset >= buffer.Length) 
			{
#if NETCF_1_0
				throw new ArgumentOutOfRangeException("offset");
#else
				throw new ArgumentOutOfRangeException("offset", "not a valid index into buffer");
#endif				
			}
			
			if (offset + count > buffer.Length) 
			{
#if NETCF_1_0
				throw new ArgumentOutOfRangeException("count");
#else
				throw new ArgumentOutOfRangeException("count", "exceeds buffer size");
#endif				
			}

			//(By Per Bothner)
			uint s1 = checksum & 0xFFFF;
			uint s2 = checksum >> 16;
			
			while (count > 0) {
				// We can defer the modulo operation:
				// s1 maximally grows from 65521 to 65521 + 255 * 3800
				// s2 maximally grows by 3800 * median(s1) = 2090079800 < 2^31
				int n = 3800;
				if (n > count) {
					n = count;
				}
				count -= n;
				while (--n >= 0) {
					s1 = s1 + (uint)(buffer[offset++] & 0xff);
					s2 = s2 + s1;
				}
				s1 %= BASE;
				s2 %= BASE;
			}
			
			checksum = (s2 << 16) | s1;
		}
		
		#region Instance Fields
		uint checksum;
		#endregion
	}
}



================================================
File: de4dot.code/SharpZipLib/Checksums/IChecksum.cs
================================================
// IChecksum.cs - Interface to compute a data checksum
// Copyright (C) 2001 Mike Krueger
//
// This file was translated from java, it was part of the GNU Classpath
// Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
//
// Linking this library statically or dynamically with other modules is
// making a combined work based on this library.  Thus, the terms and
// conditions of the GNU General Public License cover the whole
// combination.
// 
// As a special exception, the copyright holders of this library give you
// permission to link this library with independent modules to produce an
// executable, regardless of the license terms of these independent
// modules, and to copy and distribute the resulting executable under
// terms of your choice, provided that you also meet, for each linked
// independent module, the terms and conditions of the license of that
// module.  An independent module is a module which is not derived from
// or based on this library.  If you modify this library, you may extend
// this exception to your version of the library, but you are not
// obligated to do so.  If you do not wish to do so, delete this
// exception statement from your version.

namespace ICSharpCode.SharpZipLib.Checksums 
{
	
	/// <summary>
	/// Interface to compute a data checksum used by checked input/output streams.
	/// A data checksum can be updated by one byte or with a byte array. After each
	/// update the value of the current checksum can be returned by calling
	/// <code>getValue</code>. The complete checksum object can also be reset
	/// so it can be used again with new data.
	/// </summary>
	public interface IChecksum
	{
		/// <summary>
		/// Returns the data checksum computed so far.
		/// </summary>
		long Value 
		{
			get;
		}
		
		/// <summary>
		/// Resets the data checksum as if no update was ever called.
		/// </summary>
		void Reset();
		
		/// <summary>
		/// Adds one byte to the data checksum.
		/// </summary>
		/// <param name = "value">
		/// the data value to add. The high byte of the int is ignored.
		/// </param>
		void Update(int value);
		
		/// <summary>
		/// Updates the data checksum with the bytes taken from the array.
		/// </summary>
		/// <param name="buffer">
		/// buffer an array of bytes
		/// </param>
		void Update(byte[] buffer);
		
		/// <summary>
		/// Adds the byte array to the data checksum.
		/// </summary>
		/// <param name = "buffer">
		/// The buffer which contains the data
		/// </param>
		/// <param name = "offset">
		/// The offset in the buffer where the data starts
		/// </param>
		/// <param name = "count">
		/// the number of data bytes to add.
		/// </param>
		void Update(byte[] buffer, int offset, int count);
	}
}



================================================
File: de4dot.code/SharpZipLib/Zip/Compression/Inflater.cs
================================================
// Inflater.cs
//
// Copyright (C) 2001 Mike Krueger
// Copyright (C) 2004 John Reilly
//
// This file was translated from java, it was part of the GNU Classpath
// Copyright (C) 2001 Free Software Foundation, Inc.
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
//
// Linking this library statically or dynamically with other modules is
// making a combined work based on this library.  Thus, the terms and
// conditions of the GNU General Public License cover the whole
// combination.
// 
// As a special exception, the copyright holders of this library give you
// permission to link this library with independent modules to produce an
// executable, regardless of the license terms of these independent
// modules, and to copy and distribute the resulting executable under
// terms of your choice, provided that you also meet, for each linked
// independent module, the terms and conditions of the license of that
// module.  An independent module is a module which is not derived from
// or based on this library.  If you modify this library, you may extend
// this exception to your version of the library, but you are not
// obligated to do so.  If you do not wish to do so, delete this
// exception statement from your version.

using System;

using ICSharpCode.SharpZipLib.Checksums;
using ICSharpCode.SharpZipLib.Zip.Compression.Streams;

namespace ICSharpCode.SharpZipLib.Zip.Compression 
{
	/// <summary>
	/// Inflater is used to decompress data that has been compressed according
	/// to the "deflate" standard described in rfc1951.
	/// 
	/// By default Zlib (rfc1950) headers and footers are expected in the input.
	/// You can use constructor <code> public Inflater(bool noHeader)</code> passing true
	/// if there is no Zlib header information
	///
	/// The usage is as following.  First you have to set some input with
	/// <code>SetInput()</code>, then Inflate() it.  If inflate doesn't
	/// inflate any bytes there may be three reasons:
	/// <ul>
	/// <li>IsNeedingInput() returns true because the input buffer is empty.
	/// You have to provide more input with <code>SetInput()</code>.
	/// NOTE: IsNeedingInput() also returns true when, the stream is finished.
	/// </li>
	/// <li>IsNeedingDictionary() returns true, you have to provide a preset
	///    dictionary with <code>SetDictionary()</code>.</li>
	/// <li>IsFinished returns true, the inflater has finished.</li>
	/// </ul>
	/// Once the first output byte is produced, a dictionary will not be
	/// needed at a later stage.
	///
	/// author of the original java version : John Leuner, Jochen Hoenicke
	/// </summary>
	public class Inflater
	{
		#region Constants/Readonly
		/// <summary>
		/// Copy lengths for literal codes 257..285
		/// </summary>
		static readonly int[] CPLENS = {
								  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
								  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258
							  };
		
		/// <summary>
		/// Extra bits for literal codes 257..285
		/// </summary>
		static readonly int[] CPLEXT = {
								  0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
								  3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0
							  };
		
		/// <summary>
		/// Copy offsets for distance codes 0..29
		/// </summary>
		static readonly int[] CPDIST = {
								1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
								257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
								8193, 12289, 16385, 24577
							  };
		
		/// <summary>
		/// Extra bits for distance codes
		/// </summary>
		static readonly int[] CPDEXT = {
								0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
								7, 7, 8, 8, 9, 9, 10, 10, 11, 11,
								12, 12, 13, 13
							  };
		
		/// <summary>
		/// These are the possible states for an inflater
		/// </summary>
		const int DECODE_HEADER           = 0;
		const int DECODE_DICT             = 1;
		const int DECODE_BLOCKS           = 2;
		const int DECODE_STORED_LEN1      = 3;
		//const int DECODE_STORED_LEN2      = 4;
		const int DECODE_STORED           = 5;
		const int DECODE_DYN_HEADER       = 6;
		const int DECODE_HUFFMAN          = 7;
		const int DECODE_HUFFMAN_LENBITS  = 8;
		const int DECODE_HUFFMAN_DIST     = 9;
		const int DECODE_HUFFMAN_DISTBITS = 10;
		const int DECODE_CHKSUM           = 11;
		const int FINISHED                = 12;

		public const  int DEFLATED = 8;

		/// <summary>
		/// Written to Zip file to identify a stored block
		/// </summary>
		public const int STORED_BLOCK = 0;
		
		/// <summary>
		/// Identifies static tree in Zip file
		/// </summary>
		public const int STATIC_TREES = 1;
		
		/// <summary>
		/// Identifies dynamic tree in Zip file
		/// </summary>
		public const int DYN_TREES    = 2;
		#endregion

		#region Instance Fields
		/// <summary>
		/// This variable contains the current state.
		/// </summary>
		int mode;
		
		/// <summary>
		/// The adler checksum of the dictionary or of the decompressed
		/// stream, as it is written in the header resp. footer of the
		/// compressed stream. 
		/// Only valid if mode is DECODE_DICT or DECODE_CHKSUM.
		/// </summary>
		int readAdler;
		
		/// <summary>
		/// The number of bits needed to complete the current state.  This
		/// is valid, if mode is DECODE_DICT, DECODE_CHKSUM,
		/// DECODE_HUFFMAN_LENBITS or DECODE_HUFFMAN_DISTBITS.
		/// </summary>
		int neededBits;
		int repLength;
		int repDist;
		protected int uncomprLen;
		
		/// <summary>
		/// True, if the last block flag was set in the last block of the
		/// inflated stream.  This means that the stream ends after the
		/// current block.
		/// </summary>
		bool isLastBlock;
		
		/// <summary>
		/// The total number of inflated bytes.
		/// </summary>
		long totalOut;
		
		/// <summary>
		/// The total number of bytes set with setInput().  This is not the
		/// value returned by the TotalIn property, since this also includes the
		/// unprocessed input.
		/// </summary>
		long totalIn;
		
		/// <summary>
		/// This variable stores the noHeader flag that was given to the constructor.
		/// True means, that the inflated stream doesn't contain a Zlib header or 
		/// footer.
		/// </summary>
		bool noHeader;
		
		protected StreamManipulator input;
		OutputWindow outputWindow;
		InflaterDynHeader dynHeader;
		InflaterHuffmanTree litlenTree, distTree;
		Adler32 adler;
		#endregion
		
		#region Constructors
		/// <summary>
		/// Creates a new inflater or RFC1951 decompressor
		/// RFC1950/Zlib headers and footers will be expected in the input data
		/// </summary>
		public Inflater() : this(false)
		{
		}
		
		/// <summary>
		/// Creates a new inflater.
		/// </summary>
		/// <param name="noHeader">
		/// True if no RFC1950/Zlib header and footer fields are expected in the input data
		/// 
		/// This is used for GZIPed/Zipped input.
		/// 
		/// For compatibility with
		/// Sun JDK you should provide one byte of input more than needed in
		/// this case.
		/// </param>
		public Inflater(bool noHeader)
		{
			this.noHeader = noHeader;
			adler = new Adler32();
			input = new StreamManipulator();
			outputWindow = new OutputWindow();
			mode = noHeader ? DECODE_BLOCKS : DECODE_HEADER;
		}
		#endregion

		/// <summary>
		/// Resets the inflater so that a new stream can be decompressed.  All
		/// pending input and output will be discarded.
		/// </summary>
		public void Reset()
		{
			mode = noHeader ? DECODE_BLOCKS : DECODE_HEADER;
			totalIn = 0;
			totalOut = 0;
			input.Reset();
			outputWindow.Reset();
			dynHeader = null;
			litlenTree = null;
			distTree = null;
			isLastBlock = false;
			adler.Reset();
		}
		
		/// <summary>
		/// Decodes a zlib/RFC1950 header.
		/// </summary>
		/// <returns>
		/// False if more input is needed.
		/// </returns>
		/// <exception cref="SharpZipBaseException">
		/// The header is invalid.
		/// </exception>
		private bool DecodeHeader()
		{
			int header = input.PeekBits(16);
			if (header < 0) {
				return false;
			}
			input.DropBits(16);
			
			// The header is written in "wrong" byte order
			header = ((header << 8) | (header >> 8)) & 0xffff;
			if (header % 31 != 0) {
				throw new SharpZipBaseException("Header checksum illegal");
			}
			
			if ((header & 0x0f00) != (DEFLATED << 8)) {
				throw new SharpZipBaseException("Compression Method unknown");
			}
			
			/* Maximum size of the backwards window in bits.
			* We currently ignore this, but we could use it to make the
			* inflater window more space efficient. On the other hand the
			* full window (15 bits) is needed most times, anyway.
			int max_wbits = ((header & 0x7000) >> 12) + 8;
			*/
			
			if ((header & 0x0020) == 0) { // Dictionary flag?
				mode = DECODE_BLOCKS;
			} else {
				mode = DECODE_DICT;
				neededBits = 32;
			}
			return true;
		}
		
		/// <summary>
		/// Decodes the dictionary checksum after the deflate header.
		/// </summary>
		/// <returns>
		/// False if more input is needed.
		/// </returns>
		private bool DecodeDict()
		{
			while (neededBits > 0) {
				int dictByte = input.PeekBits(8);
				if (dictByte < 0) {
					return false;
				}
				input.DropBits(8);
				readAdler = (readAdler << 8) | dictByte;
				neededBits -= 8;
			}
			return false;
		}
		
		/// <summary>
		/// Decodes the huffman encoded symbols in the input stream.
		/// </summary>
		/// <returns>
		/// false if more input is needed, true if output window is
		/// full or the current block ends.
		/// </returns>
		/// <exception cref="SharpZipBaseException">
		/// if deflated stream is invalid.
		/// </exception>
		private bool DecodeHuffman()
		{
			int free = outputWindow.GetFreeSpace();
			while (free >= 258) 
			{
				int symbol;
				switch (mode) 
				{
					case DECODE_HUFFMAN:
						// This is the inner loop so it is optimized a bit
						while (((symbol = litlenTree.GetSymbol(input)) & ~0xff) == 0) 
						{
							outputWindow.Write(symbol);
							if (--free < 258) 
							{
								return true;
							}
						}
						
						if (symbol < 257) 
						{
							if (symbol < 0) 
							{
								return false;
							} 
							else 
							{
								// symbol == 256: end of block
								distTree = null;
								litlenTree = null;
								mode = DECODE_BLOCKS;
								return true;
							}
						}
						
						try 
						{
							repLength = CPLENS[symbol - 257];
							neededBits = CPLEXT[symbol - 257];
						} 
						catch (Exception) 
						{
							throw new SharpZipBaseException("Illegal rep length code");
						}
						goto case DECODE_HUFFMAN_LENBITS; // fall through
						
					case DECODE_HUFFMAN_LENBITS:
						if (neededBits > 0) 
						{
							mode = DECODE_HUFFMAN_LENBITS;
							int i = input.PeekBits(neededBits);
							if (i < 0) 
							{
								return false;
							}
							input.DropBits(neededBits);
							repLength += i;
						}
						mode = DECODE_HUFFMAN_DIST;
						goto case DECODE_HUFFMAN_DIST; // fall through
						
					case DECODE_HUFFMAN_DIST:
						symbol = distTree.GetSymbol(input);
						if (symbol < 0) 
						{
							return false;
						}
						
						try 
						{
							repDist = CPDIST[symbol];
							neededBits = CPDEXT[symbol];
						} 
						catch (Exception) 
						{
							throw new SharpZipBaseException("Illegal rep dist code");
						}
						
						goto case DECODE_HUFFMAN_DISTBITS; // fall through
						
					case DECODE_HUFFMAN_DISTBITS:
						if (neededBits > 0) 
						{
							mode = DECODE_HUFFMAN_DISTBITS;
							int i = input.PeekBits(neededBits);
							if (i < 0) 
							{
								return false;
							}
							input.DropBits(neededBits);
							repDist += i;
						}
						
						outputWindow.Repeat(repLength, repDist);
						free -= repLength;
						mode = DECODE_HUFFMAN;
						break;
					
					default:
						throw new SharpZipBaseException("Inflater unknown mode");
				}
			}
			return true;
		}
		
		/// <summary>
		/// Decodes the adler checksum after the deflate stream.
		/// </summary>
		/// <returns>
		/// false if more input is needed.
		/// </returns>
		/// <exception cref="SharpZipBaseException">
		/// If checksum doesn't match.
		/// </exception>
		private bool DecodeChksum()
		{
			while (neededBits > 0) {
				int chkByte = input.PeekBits(8);
				if (chkByte < 0) {
					return false;
				}
				input.DropBits(8);
				readAdler = (readAdler << 8) | chkByte;
				neededBits -= 8;
			}

			if ((int) adler.Value != readAdler) {
				throw new SharpZipBaseException("Adler chksum doesn't match: " + (int)adler.Value + " vs. " + readAdler);
			}

			mode = FINISHED;
			return false;
		}
		
		/// <summary>
		/// Decodes the deflated stream.
		/// </summary>
		/// <returns>
		/// false if more input is needed, or if finished.
		/// </returns>
		/// <exception cref="SharpZipBaseException">
		/// if deflated stream is invalid.
		/// </exception>
		private bool Decode()
		{
			switch (mode) {
				case DECODE_HEADER:
					return DecodeHeader();

				case DECODE_DICT:
					return DecodeDict();

				case DECODE_CHKSUM:
					return DecodeChksum();
				
				case DECODE_BLOCKS:
					if (isLastBlock) {
						if (noHeader) {
							mode = FINISHED;
							return false;
						} else {
							input.SkipToByteBoundary();
							neededBits = 32;
							mode = DECODE_CHKSUM;
							return true;
						}
					}
					
					int blockType;
					if (!ReadHeader(ref isLastBlock, out blockType)) {
						return false;
					}
					switch (blockType){
						case STORED_BLOCK:
							input.SkipToByteBoundary();
							mode = DECODE_STORED_LEN1;
							break;
						case STATIC_TREES:
							litlenTree = InflaterHuffmanTree.defLitLenTree;
							distTree = InflaterHuffmanTree.defDistTree;
							mode = DECODE_HUFFMAN;
							break;
						case DYN_TREES:
							dynHeader = new InflaterDynHeader();
							mode = DECODE_DYN_HEADER;
							break;
						default:
							throw new SharpZipBaseException("Unknown block type " + blockType);
					}
					return true;
				
				case DECODE_STORED_LEN1:
					if (!DecodeStoredLength()) {
						return false;
					}
					mode = DECODE_STORED;
					goto case DECODE_STORED; // fall through
					
				case DECODE_STORED: 
				{
					int more = outputWindow.CopyStored(input, uncomprLen);
					uncomprLen -= more;
					if (uncomprLen == 0) {
						mode = DECODE_BLOCKS;
						return true;
					}
					return !input.IsNeedingInput;
				}
				
				case DECODE_DYN_HEADER:
					if (!dynHeader.Decode(input)) {
						return false;
					}
					
					litlenTree = dynHeader.BuildLitLenTree();
					distTree = dynHeader.BuildDistTree();
					mode = DECODE_HUFFMAN;
					goto case DECODE_HUFFMAN; // fall through
					
				case DECODE_HUFFMAN:
				case DECODE_HUFFMAN_LENBITS:
				case DECODE_HUFFMAN_DIST:
				case DECODE_HUFFMAN_DISTBITS:
					return DecodeHuffman();
				
				case FINISHED:
					return false;
				
				default:
					throw new SharpZipBaseException("Inflater.Decode unknown mode");
			}
		}

		protected virtual bool ReadHeader(ref bool isLastBlock, out int blockType)
		{
			int type = input.PeekBits(3);
			if (type < 0) {
				blockType = -1;
				return false;
			}
			input.DropBits(3);
					
			if ((type & 1) != 0) {
				isLastBlock = true;
			}
			blockType = type >> 1;
			return true;
		}

		protected virtual bool DecodeStoredLength()
		{
			if ((uncomprLen = input.PeekBits(16)) < 0) {
				return false;
			}
			input.DropBits(16);

			int nlen = input.PeekBits(16);
			if (nlen < 0) {
				return false;
			}
			input.DropBits(16);
			if (nlen != (uncomprLen ^ 0xffff)) {
				throw new SharpZipBaseException("broken uncompressed block");
			}

			return true;
		}
			
		/// <summary>
		/// Sets the preset dictionary.  This should only be called, if
		/// needsDictionary() returns true and it should set the same
		/// dictionary, that was used for deflating.  The getAdler()
		/// function returns the checksum of the dictionary needed.
		/// </summary>
		/// <param name="buffer">
		/// The dictionary.
		/// </param>
		public void SetDictionary(byte[] buffer)
		{
			SetDictionary(buffer, 0, buffer.Length);
		}
		
		/// <summary>
		/// Sets the preset dictionary.  This should only be called, if
		/// needsDictionary() returns true and it should set the same
		/// dictionary, that was used for deflating.  The getAdler()
		/// function returns the checksum of the dictionary needed.
		/// </summary>
		/// <param name="buffer">
		/// The dictionary.
		/// </param>
		/// <param name="index">
		/// The index into buffer where the dictionary starts.
		/// </param>
		/// <param name="count">
		/// The number of bytes in the dictionary.
		/// </param>
		/// <exception cref="System.InvalidOperationException">
		/// No dictionary is needed.
		/// </exception>
		/// <exception cref="SharpZipBaseException">
		/// The adler checksum for the buffer is invalid
		/// </exception>
		public void SetDictionary(byte[] buffer, int index, int count)
		{
			if ( buffer == null ) {
				throw new ArgumentNullException("buffer");
			}

			if ( index < 0 ) {
				throw new ArgumentOutOfRangeException("index");
			}

			if ( count < 0 ) {
				throw new ArgumentOutOfRangeException("count");
			}

			if (!IsNeedingDictionary) {
				throw new InvalidOperationException("Dictionary is not needed");
			}
			
			adler.Update(buffer, index, count);

			if ((int)adler.Value != readAdler) {
				throw new SharpZipBaseException("Wrong adler checksum");
			}
			adler.Reset();
			outputWindow.CopyDict(buffer, index, count);
			mode = DECODE_BLOCKS;
		}
		
		/// <summary>
		/// Sets the input.  This should only be called, if needsInput()
		/// returns true.
		/// </summary>
		/// <param name="buffer">
		/// the input.
		/// </param>
		public void SetInput(byte[] buffer)
		{
			SetInput(buffer, 0, buffer.Length);
		}
		
		/// <summary>
		/// Sets the input.  This should only be called, if needsInput()
		/// returns true.
		/// </summary>
		/// <param name="buffer">
		/// The source of input data
		/// </param>
		/// <param name="index">
		/// The index into buffer where the input starts.
		/// </param>
		/// <param name="count">
		/// The number of bytes of input to use.
		/// </param>
		/// <exception cref="System.InvalidOperationException">
		/// No input is needed.
		/// </exception>
		/// <exception cref="System.ArgumentOutOfRangeException">
		/// The index and/or count are wrong.
		/// </exception>
		public void SetInput(byte[] buffer, int index, int count)
		{
			input.SetInput(buffer, index, count);
			totalIn += (long)count;
		}
		
		/// <summary>
		/// Inflates the compressed stream to the output buffer.  If this
		/// returns 0, you should check, whether IsNeedingDictionary(),
		/// IsNeedingInput() or IsFinished() returns true, to determine why no
		/// further output is produced.
		/// </summary>
		/// <param name="buffer">
		/// the output buffer.
		/// </param>
		/// <returns>
		/// The number of bytes written to the buffer, 0 if no further
		/// output can be produced.
		/// </returns>
		/// <exception cref="System.ArgumentOutOfRangeException">
		/// if buffer has length 0.
		/// </exception>
		/// <exception cref="System.FormatException">
		/// if deflated stream is invalid.
		/// </exception>
		public int Inflate(byte[] buffer)
		{
			if ( buffer == null )
			{
				throw new ArgumentNullException("buffer");
			}

			return Inflate(buffer, 0, buffer.Length);
		}
		
		/// <summary>
		/// Inflates the compressed stream to the output buffer.  If this
		/// returns 0, you should check, whether needsDictionary(),
		/// needsInput() or finished() returns true, to determine why no
		/// further output is produced.
		/// </summary>
		/// <param name="buffer">
		/// the output buffer.
		/// </param>
		/// <param name="offset">
		/// the offset in buffer where storing starts.
		/// </param>
		/// <param name="count">
		/// the maximum number of bytes to output.
		/// </param>
		/// <returns>
		/// the number of bytes written to the buffer, 0 if no further output can be produced.
		/// </returns>
		/// <exception cref="System.ArgumentOutOfRangeException">
		/// if count is less than 0.
		/// </exception>
		/// <exception cref="System.ArgumentOutOfRangeException">
		/// if the index and / or count are wrong.
		/// </exception>
		/// <exception cref="System.FormatException">
		/// if deflated stream is invalid.
		/// </exception>
		public int Inflate(byte[] buffer, int offset, int count)
		{
			if ( buffer == null )
			{
				throw new ArgumentNullException("buffer");
			}

			if ( count < 0 ) {
#if NETCF_1_0
				throw new ArgumentOutOfRangeException("count");
#else
				throw new ArgumentOutOfRangeException("count", "count cannot be negative");
#endif
			}

			if ( offset < 0 ) {
#if NETCF_1_0
				throw new ArgumentOutOfRangeException("offset");
#else
				throw new ArgumentOutOfRangeException("offset", "offset cannot be negative");
#endif
			}

			if ( offset + count > buffer.Length ) {
				throw new ArgumentException("count exceeds buffer bounds");
			}

			// Special case: count may be zero
			if (count == 0) 
			{
				if (!IsFinished) { // -jr- 08-Nov-2003 INFLATE_BUG fix..
					Decode();
				}
				return 0;
			}

			int bytesCopied = 0;

			do {
				if (mode != DECODE_CHKSUM) {
					/* Don't give away any output, if we are waiting for the
					* checksum in the input stream.
					*
					* With this trick we have always:
					*   IsNeedingInput() and not IsFinished()
					*   implies more output can be produced.
					*/
					int more = outputWindow.CopyOutput(buffer, offset, count);
					if ( more > 0 ) {
						adler.Update(buffer, offset, more);
						offset += more;
						bytesCopied += more;
						totalOut += (long)more;
						count -= more;
						if (count == 0) {
							return bytesCopied;
						}
					}
				}
			} while (Decode() || ((outputWindow.GetAvailable() > 0) && (mode != DECODE_CHKSUM)));
			return bytesCopied;
		}
		
		/// <summary>
		/// Returns true, if the input buffer is empty.
		/// You should then call setInput(). 
		/// NOTE: This method also returns true when the stream is finished.
		/// </summary>
		public bool IsNeedingInput {
			get {
				return input.IsNeedingInput;
			}
		}
		
		/// <summary>
		/// Returns true, if a preset dictionary is needed to inflate the input.
		/// </summary>
		public bool IsNeedingDictionary {
			get {
				return mode == DECODE_DICT && neededBits == 0;
			}
		}
		
		/// <summary>
		/// Returns true, if the inflater has finished.  This means, that no
		/// input is needed and no output can be produced.
		/// </summary>
		public bool IsFinished {
			get {
				return mode == FINISHED && outputWindow.GetAvailable() == 0;
			}
		}
		
		/// <summary>
		/// Gets the adler checksum.  This is either the checksum of all
		/// uncompressed bytes returned by inflate(), or if needsDictionary()
		/// returns true (and thus no output was yet produced) this is the
		/// adler checksum of the expected dictionary.
		/// </summary>
		/// <returns>
		/// the adler checksum.
		/// </returns>
		public int Adler {
			get {
				return IsNeedingDictionary ? readAdler : (int) adler.Value;
			}
		}
		
		/// <summary>
		/// Gets the total number of output bytes returned by Inflate().
		/// </summary>
		/// <returns>
		/// the total number of output bytes.
		/// </returns>
		public long TotalOut {
			get {
				return totalOut;
			}
		}
		
		/// <summary>
		/// Gets the total number of processed compressed input bytes.
		/// </summary>
		/// <returns>
		/// The total number of bytes of processed input bytes.
		/// </returns>
		public long TotalIn {
			get {
				return totalIn - (long)RemainingInput;
			}
		}
		
		/// <summary>
		/// Gets the number of unprocessed input bytes.  Useful, if the end of the
		/// stream is reached and you want to further process the bytes after
		/// the deflate stream.
		/// </summary>
		/// <returns>
		/// The number of bytes of the input which have not been processed.
		/// </returns>
		public int RemainingInput {
			// TODO: This should be a long?
			get {
				return input.AvailableBytes;
			}
		}
	}
}



================================================
File: de4dot.code/SharpZipLib/Zip/Compression/InflaterDynHeader.cs
================================================
// InflaterDynHeader.cs
// Copyright (C) 2001 Mike Krueger
//
// This file was translated from java, it was part of the GNU Classpath
// Copyright (C) 2001 Free Software Foundation, Inc.
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
//
// Linking this library statically or dynamically with other modules is
// making a combined work based on this library.  Thus, the terms and
// conditions of the GNU General Public License cover the whole
// combination.
//
// As a special exception, the copyright holders of this library give you
// permission to link this library with independent modules to produce an
// executable, regardless of the license terms of these independent
// modules, and to copy and distribute the resulting executable under
// terms of your choice, provided that you also meet, for each linked
// independent module, the terms and conditions of the license of that
// module.  An independent module is a module which is not derived from
// or based on this library.  If you modify this library, you may extend
// this exception to your version of the library, but you are not
// obligated to do so.  If you do not wish to do so, delete this
// exception statement from your version.

using System;

using ICSharpCode.SharpZipLib.Zip.Compression.Streams;

namespace ICSharpCode.SharpZipLib.Zip.Compression 
{
	
	class InflaterDynHeader
	{
		#region Constants
		const int LNUM   = 0;
		const int DNUM   = 1;
		const int BLNUM  = 2;
		const int BLLENS = 3;
		const int LENS   = 4;
		const int REPS   = 5;
		
		static readonly int[] repMin  = { 3, 3, 11 };
		static readonly int[] repBits = { 2, 3,  7 };

		static readonly int[] BL_ORDER = 
		{ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 };
		
		#endregion

		#region Constructors
		public InflaterDynHeader()
		{
		}
		#endregion
		
		public bool Decode(StreamManipulator input)
		{
			decode_loop:
				for (;;) {
					switch (mode) {
						case LNUM:
							lnum = input.PeekBits(5);
							if (lnum < 0) {
								return false;
							}
							lnum += 257;
							input.DropBits(5);
							//  	    System.err.println("LNUM: "+lnum);
							mode = DNUM;
							goto case DNUM; // fall through
						case DNUM:
							dnum = input.PeekBits(5);
							if (dnum < 0) {
								return false;
							}
							dnum++;
							input.DropBits(5);
							//  	    System.err.println("DNUM: "+dnum);
							num = lnum+dnum;
							litdistLens = new byte[num];
							mode = BLNUM;
							goto case BLNUM; // fall through
						case BLNUM:
							blnum = input.PeekBits(4);
							if (blnum < 0) {
								return false;
							}
							blnum += 4;
							input.DropBits(4);
							blLens = new byte[19];
							ptr = 0;
							//  	    System.err.println("BLNUM: "+blnum);
							mode = BLLENS;
							goto case BLLENS; // fall through
						case BLLENS:
							while (ptr < blnum) {
								int len = input.PeekBits(3);
								if (len < 0) {
									return false;
								}
								input.DropBits(3);
								//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);
								blLens[BL_ORDER[ptr]] = (byte) len;
								ptr++;
							}
							blTree = new InflaterHuffmanTree(blLens);
							blLens = null;
							ptr = 0;
							mode = LENS;
							goto case LENS; // fall through
						case LENS: 
						{
							int symbol;
							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {
								/* Normal case: symbol in [0..15] */
							
								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);
								litdistLens[ptr++] = lastLen = (byte)symbol;
							
								if (ptr == num) {
									/* Finished */
									return true;
								}
							}
						
							/* need more input ? */
							if (symbol < 0) {
								return false;
							}
						
							/* otherwise repeat code */
							if (symbol >= 17) {
								/* repeat zero */
								//  		  System.err.println("repeating zero");
								lastLen = 0;
							} else {
								if (ptr == 0) {
									throw new SharpZipBaseException();
								}
							}
							repSymbol = symbol-16;
						}
							mode = REPS;
							goto case REPS; // fall through
						case REPS:
						{
							int bits = repBits[repSymbol];
							int count = input.PeekBits(bits);
							if (count < 0) {
								return false;
							}
							input.DropBits(bits);
							count += repMin[repSymbol];
							//  	      System.err.println("litdistLens repeated: "+count);
							
							if (ptr + count > num) {
								throw new SharpZipBaseException();
							}
							while (count-- > 0) {
								litdistLens[ptr++] = lastLen;
							}
							
							if (ptr == num) {
								/* Finished */
								return true;
							}
						}
						mode = LENS;
						goto decode_loop;
					}
				}
		}
		
		public InflaterHuffmanTree BuildLitLenTree()
		{
			byte[] litlenLens = new byte[lnum];
			Array.Copy(litdistLens, 0, litlenLens, 0, lnum);
			return new InflaterHuffmanTree(litlenLens);
		}
		
		public InflaterHuffmanTree BuildDistTree()
		{
			byte[] distLens = new byte[dnum];
			Array.Copy(litdistLens, lnum, distLens, 0, dnum);
			return new InflaterHuffmanTree(distLens);
		}

		#region Instance Fields
		byte[] blLens;
		byte[] litdistLens;

		InflaterHuffmanTree blTree;

        /// <summary>
        /// The current decode mode
        /// </summary>
		int mode;
		int lnum, dnum, blnum, num;
		int repSymbol;
		byte lastLen;
		int ptr;
		#endregion

	}
}



================================================
File: de4dot.code/SharpZipLib/Zip/Compression/InflaterHuffmanTree.cs
================================================
// InflaterHuffmanTree.cs
// Copyright (C) 2001 Mike Krueger
//
// This file was translated from java, it was part of the GNU Classpath
// Copyright (C) 2001 Free Software Foundation, Inc.
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
//
// Linking this library statically or dynamically with other modules is
// making a combined work based on this library.  Thus, the terms and
// conditions of the GNU General Public License cover the whole
// combination.
// 
// As a special exception, the copyright holders of this library give you
// permission to link this library with independent modules to produce an
// executable, regardless of the license terms of these independent
// modules, and to copy and distribute the resulting executable under
// terms of your choice, provided that you also meet, for each linked
// independent module, the terms and conditions of the license of that
// module.  An independent module is a module which is not derived from
// or based on this library.  If you modify this library, you may extend
// this exception to your version of the library, but you are not
// obligated to do so.  If you do not wish to do so, delete this
// exception statement from your version.

using System;

using ICSharpCode.SharpZipLib.Zip.Compression.Streams;

namespace ICSharpCode.SharpZipLib.Zip.Compression 
{
	
	/// <summary>
	/// Huffman tree used for inflation
	/// </summary>
	public class InflaterHuffmanTree
	{
		#region Constants
		const int MAX_BITLEN = 15;

		static readonly byte[] bit4Reverse = {
			0,
			8,
			4,
			12,
			2,
			10,
			6,
			14,
			1,
			9,
			5,
			13,
			3,
			11,
			7,
			15
		};
		#endregion

		#region Instance Fields
		short[] tree;
		#endregion

		/// <summary>
		/// Literal length tree
		/// </summary>
		public static InflaterHuffmanTree defLitLenTree;
		
		/// <summary>
		/// Distance tree
		/// </summary>
		public static InflaterHuffmanTree defDistTree;
		
		static InflaterHuffmanTree()
		{
			try {
				byte[] codeLengths = new byte[288];
				int i = 0;
				while (i < 144) {
					codeLengths[i++] = 8;
				}
				while (i < 256) {
					codeLengths[i++] = 9;
				}
				while (i < 280) {
					codeLengths[i++] = 7;
				}
				while (i < 288) {
					codeLengths[i++] = 8;
				}
				defLitLenTree = new InflaterHuffmanTree(codeLengths);
				
				codeLengths = new byte[32];
				i = 0;
				while (i < 32) {
					codeLengths[i++] = 5;
				}
				defDistTree = new InflaterHuffmanTree(codeLengths);
			} catch (Exception) {
				throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");
			}
		}

		#region Constructors
		/// <summary>
		/// Constructs a Huffman tree from the array of code lengths.
		/// </summary>
		/// <param name = "codeLengths">
		/// the array of code lengths
		/// </param>
		public InflaterHuffmanTree(byte[] codeLengths)
		{
			BuildTree(codeLengths);
		}
		#endregion

		void BuildTree(byte[] codeLengths)
		{
			int[] blCount  = new int[MAX_BITLEN + 1];
			int[] nextCode = new int[MAX_BITLEN + 1];
			
			for (int i = 0; i < codeLengths.Length; i++) {
				int bits = codeLengths[i];
				if (bits > 0) {
					blCount[bits]++;
				}
			}
			
			int code = 0;
			int treeSize = 512;
			for (int bits = 1; bits <= MAX_BITLEN; bits++) {
				nextCode[bits] = code;
				code += blCount[bits] << (16 - bits);
				if (bits >= 10) {
					/* We need an extra table for bit lengths >= 10. */
					int start = nextCode[bits] & 0x1ff80;
					int end   = code & 0x1ff80;
					treeSize += (end - start) >> (16 - bits);
				}
			}
			
/* -jr comment this out! doesnt work for dynamic trees and pkzip 2.04g
			if (code != 65536) 
			{
				throw new SharpZipBaseException("Code lengths don't add up properly.");
			}
*/
			/* Now create and fill the extra tables from longest to shortest
			* bit len.  This way the sub trees will be aligned.
			*/
			tree = new short[treeSize];
			int treePtr = 512;
			for (int bits = MAX_BITLEN; bits >= 10; bits--) {
				int end   = code & 0x1ff80;
				code -= blCount[bits] << (16 - bits);
				int start = code & 0x1ff80;
				for (int i = start; i < end; i += 1 << 7) {
					tree[BitReverse(i)] = (short) ((-treePtr << 4) | bits);
					treePtr += 1 << (bits-9);
				}
			}
			
			for (int i = 0; i < codeLengths.Length; i++) {
				int bits = codeLengths[i];
				if (bits == 0) {
					continue;
				}
				code = nextCode[bits];
				int revcode = BitReverse(code);
				if (bits <= 9) {
					do {
						tree[revcode] = (short) ((i << 4) | bits);
						revcode += 1 << bits;
					} while (revcode < 512);
				} else {
					int subTree = tree[revcode & 511];
					int treeLen = 1 << (subTree & 15);
					subTree = -(subTree >> 4);
					do {
						tree[subTree | (revcode >> 9)] = (short) ((i << 4) | bits);
						revcode += 1 << bits;
					} while (revcode < treeLen);
				}
				nextCode[bits] = code + (1 << (16 - bits));
			}
			
		}

		/// <summary>
		/// Reverse the bits of a 16 bit value.
		/// </summary>
		/// <param name="toReverse">Value to reverse bits</param>
		/// <returns>Value with bits reversed</returns>
		public static short BitReverse(int toReverse) 
		{
			return (short) (bit4Reverse[toReverse & 0xF] << 12 | 
			                bit4Reverse[(toReverse >> 4) & 0xF] << 8 | 
			                bit4Reverse[(toReverse >> 8) & 0xF] << 4 |
			                bit4Reverse[toReverse >> 12]);
		}

		/// <summary>
		/// Reads the next symbol from input.  The symbol is encoded using the
		/// huffman tree.
		/// </summary>
		/// <param name="input">
		/// input the input source.
		/// </param>
		/// <returns>
		/// the next symbol, or -1 if not enough input is available.
		/// </returns>
		public int GetSymbol(StreamManipulator input)
		{
			int lookahead, symbol;
			if ((lookahead = input.PeekBits(9)) >= 0) {
				if ((symbol = tree[lookahead]) >= 0) {
					input.DropBits(symbol & 15);
					return symbol >> 4;
				}
				int subtree = -(symbol >> 4);
				int bitlen = symbol & 15;
				if ((lookahead = input.PeekBits(bitlen)) >= 0) {
					symbol = tree[subtree | (lookahead >> 9)];
					input.DropBits(symbol & 15);
					return symbol >> 4;
				} else {
					int bits = input.AvailableBits;
					lookahead = input.PeekBits(bits);
					symbol = tree[subtree | (lookahead >> 9)];
					if ((symbol & 15) <= bits) {
						input.DropBits(symbol & 15);
						return symbol >> 4;
					} else {
						return -1;
					}
				}
			} else {
				int bits = input.AvailableBits;
				lookahead = input.PeekBits(bits);
				symbol = tree[lookahead];
				if (symbol >= 0 && (symbol & 15) <= bits) {
					input.DropBits(symbol & 15);
					return symbol >> 4;
				} else {
					return -1;
				}
			}
		}
	}
}




================================================
File: de4dot.code/SharpZipLib/Zip/Compression/Streams/OutputWindow.cs
================================================
// OutputWindow.cs
//
// Copyright (C) 2001 Mike Krueger
//
// This file was translated from java, it was part of the GNU Classpath
// Copyright (C) 2001 Free Software Foundation, Inc.
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
//
// Linking this library statically or dynamically with other modules is
// making a combined work based on this library.  Thus, the terms and
// conditions of the GNU General Public License cover the whole
// combination.
// 
// As a special exception, the copyright holders of this library give you
// permission to link this library with independent modules to produce an
// executable, regardless of the license terms of these independent
// modules, and to copy and distribute the resulting executable under
// terms of your choice, provided that you also meet, for each linked
// independent module, the terms and conditions of the license of that
// module.  An independent module is a module which is not derived from
// or based on this library.  If you modify this library, you may extend
// this exception to your version of the library, but you are not
// obligated to do so.  If you do not wish to do so, delete this
// exception statement from your version.

using System;


namespace ICSharpCode.SharpZipLib.Zip.Compression.Streams 
{
	
	/// <summary>
	/// Contains the output from the Inflation process.
	/// We need to have a window so that we can refer backwards into the output stream
	/// to repeat stuff.<br/>
	/// Author of the original java version : John Leuner
	/// </summary>
	public class OutputWindow
	{
		#region Constants
		const int WindowSize = 1 << 15;
		const int WindowMask = WindowSize - 1;
		#endregion
		
		#region Instance Fields
		byte[] window = new byte[WindowSize]; //The window is 2^15 bytes
		int windowEnd;
		int windowFilled;
		#endregion
		
		/// <summary>
		/// Write a byte to this output window
		/// </summary>
		/// <param name="value">value to write</param>
		/// <exception cref="InvalidOperationException">
		/// if window is full
		/// </exception>
		public void Write(int value)
		{
			if (windowFilled++ == WindowSize) {
				throw new InvalidOperationException("Window full");
			}
			window[windowEnd++] = (byte) value;
			windowEnd &= WindowMask;
		}
		
		
		private void SlowRepeat(int repStart, int length, int distance)
		{
			while (length-- > 0) {
				window[windowEnd++] = window[repStart++];
				windowEnd &= WindowMask;
				repStart &= WindowMask;
			}
		}
		
		/// <summary>
		/// Append a byte pattern already in the window itself
		/// </summary>
		/// <param name="length">length of pattern to copy</param>
		/// <param name="distance">distance from end of window pattern occurs</param>
		/// <exception cref="InvalidOperationException">
		/// If the repeated data overflows the window
		/// </exception>
		public void Repeat(int length, int distance)
		{
			if ((windowFilled += length) > WindowSize) {
				throw new InvalidOperationException("Window full");
			}
			
			int repStart = (windowEnd - distance) & WindowMask;
			int border = WindowSize - length;
			if ( (repStart <= border) && (windowEnd < border) ) {
				if (length <= distance) {
					System.Array.Copy(window, repStart, window, windowEnd, length);
					windowEnd += length;
				} else {
					// We have to copy manually, since the repeat pattern overlaps.
					while (length-- > 0) {
						window[windowEnd++] = window[repStart++];
					}
				}
			} else {
				SlowRepeat(repStart, length, distance);
			}
		}
		
		/// <summary>
		/// Copy from input manipulator to internal window
		/// </summary>
		/// <param name="input">source of data</param>
		/// <param name="length">length of data to copy</param>
		/// <returns>the number of bytes copied</returns>
		public int CopyStored(StreamManipulator input, int length)
		{
			length = Math.Min(Math.Min(length, WindowSize - windowFilled), input.AvailableBytes);
			int copied;
			
			int tailLen = WindowSize - windowEnd;
			if (length > tailLen) {
				copied = input.CopyBytes(window, windowEnd, tailLen);
				if (copied == tailLen) {
					copied += input.CopyBytes(window, 0, length - tailLen);
				}
			} else {
				copied = input.CopyBytes(window, windowEnd, length);
			}
			
			windowEnd = (windowEnd + copied) & WindowMask;
			windowFilled += copied;
			return copied;
		}
		
		/// <summary>
		/// Copy dictionary to window
		/// </summary>
		/// <param name="dictionary">source dictionary</param>
		/// <param name="offset">offset of start in source dictionary</param>
		/// <param name="length">length of dictionary</param>
		/// <exception cref="InvalidOperationException">
		/// If window isnt empty
		/// </exception>
		public void CopyDict(byte[] dictionary, int offset, int length)
		{
			if ( dictionary == null ) {
				throw new ArgumentNullException("dictionary");
			}

			if (windowFilled > 0) {
				throw new InvalidOperationException();
			}
			
			if (length > WindowSize) {
				offset += length - WindowSize;
				length = WindowSize;
			}
			System.Array.Copy(dictionary, offset, window, 0, length);
			windowEnd = length & WindowMask;
		}

		/// <summary>
		/// Get remaining unfilled space in window
		/// </summary>
		/// <returns>Number of bytes left in window</returns>
		public int GetFreeSpace()
		{
			return WindowSize - windowFilled;
		}
		
		/// <summary>
		/// Get bytes available for output in window
		/// </summary>
		/// <returns>Number of bytes filled</returns>
		public int GetAvailable()
		{
			return windowFilled;
		}

		/// <summary>
		/// Copy contents of window to output
		/// </summary>
		/// <param name="output">buffer to copy to</param>
		/// <param name="offset">offset to start at</param>
		/// <param name="len">number of bytes to count</param>
		/// <returns>The number of bytes copied</returns>
		/// <exception cref="InvalidOperationException">
		/// If a window underflow occurs
		/// </exception>
		public int CopyOutput(byte[] output, int offset, int len)
		{
			int copyEnd = windowEnd;
			if (len > windowFilled) {
				len = windowFilled;
			} else {
				copyEnd = (windowEnd - windowFilled + len) & WindowMask;
			}
			
			int copied = len;
			int tailLen = len - copyEnd;
			
			if (tailLen > 0) {
				System.Array.Copy(window, WindowSize - tailLen, output, offset, tailLen);
				offset += tailLen;
				len = copyEnd;
			}
			System.Array.Copy(window, copyEnd - len, output, offset, len);
			windowFilled -= copied;
			if (windowFilled < 0) {
				throw new InvalidOperationException();
			}
			return copied;
		}

		/// <summary>
		/// Reset by clearing window so <see cref="GetAvailable">GetAvailable</see> returns 0
		/// </summary>
		public void Reset()
		{
			windowFilled = windowEnd = 0;
		}
	}
}



================================================
File: de4dot.code/SharpZipLib/Zip/Compression/Streams/StreamManipulator.cs
================================================
// StreamManipulator.cs
//
// Copyright (C) 2001 Mike Krueger
//
// This file was translated from java, it was part of the GNU Classpath
// Copyright (C) 2001 Free Software Foundation, Inc.
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
//
// Linking this library statically or dynamically with other modules is
// making a combined work based on this library.  Thus, the terms and
// conditions of the GNU General Public License cover the whole
// combination.
// 
// As a special exception, the copyright holders of this library give you
// permission to link this library with independent modules to produce an
// executable, regardless of the license terms of these independent
// modules, and to copy and distribute the resulting executable under
// terms of your choice, provided that you also meet, for each linked
// independent module, the terms and conditions of the license of that
// module.  An independent module is a module which is not derived from
// or based on this library.  If you modify this library, you may extend
// this exception to your version of the library, but you are not
// obligated to do so.  If you do not wish to do so, delete this
// exception statement from your version.

using System;

namespace ICSharpCode.SharpZipLib.Zip.Compression.Streams 
{
	
	/// <summary>
	/// This class allows us to retrieve a specified number of bits from
	/// the input buffer, as well as copy big byte blocks.
	///
	/// It uses an int buffer to store up to 31 bits for direct
	/// manipulation.  This guarantees that we can get at least 16 bits,
	/// but we only need at most 15, so this is all safe.
	///
	/// There are some optimizations in this class, for example, you must
	/// never peek more than 8 bits more than needed, and you must first
	/// peek bits before you may drop them.  This is not a general purpose
	/// class but optimized for the behaviour of the Inflater.
	///
	/// authors of the original java version : John Leuner, Jochen Hoenicke
	/// </summary>
	public class StreamManipulator
	{
		#region Constructors
		/// <summary>
		/// Constructs a default StreamManipulator with all buffers empty
		/// </summary>
		public StreamManipulator()
		{
		}
		#endregion

		/// <summary>
		/// Get the next sequence of bits but don't increase input pointer.  bitCount must be
		/// less or equal 16 and if this call succeeds, you must drop
		/// at least n - 8 bits in the next call.
		/// </summary>
		/// <param name="bitCount">The number of bits to peek.</param>
		/// <returns>
		/// the value of the bits, or -1 if not enough bits available.  */
		/// </returns>
		public int PeekBits(int bitCount)
		{
			if (bitsInBuffer_ < bitCount) {
				if (windowStart_ == windowEnd_) {
					return -1; // ok
				}
				buffer_ |= (uint)((window_[windowStart_++] & 0xff |
								 (window_[windowStart_++] & 0xff) << 8) << bitsInBuffer_);
				bitsInBuffer_ += 16;
			}
			return (int)(buffer_ & ((1 << bitCount) - 1));
		}
		
		/// <summary>
		/// Drops the next n bits from the input.  You should have called PeekBits
		/// with a bigger or equal n before, to make sure that enough bits are in
		/// the bit buffer.
		/// </summary>
		/// <param name="bitCount">The number of bits to drop.</param>
		public void DropBits(int bitCount)
		{
			buffer_ >>= bitCount;
			bitsInBuffer_ -= bitCount;
		}
		
		/// <summary>
		/// Gets the next n bits and increases input pointer.  This is equivalent
		/// to <see cref="PeekBits"/> followed by <see cref="DropBits"/>, except for correct error handling.
		/// </summary>
		/// <param name="bitCount">The number of bits to retrieve.</param>
		/// <returns>
		/// the value of the bits, or -1 if not enough bits available.
		/// </returns>
		public int GetBits(int bitCount)
		{
			int bits = PeekBits(bitCount);
			if (bits >= 0) {
				DropBits(bitCount);
			}
			return bits;
		}
		
		/// <summary>
		/// Gets the number of bits available in the bit buffer.  This must be
		/// only called when a previous PeekBits() returned -1.
		/// </summary>
		/// <returns>
		/// the number of bits available.
		/// </returns>
		public int AvailableBits {
			get {
				return bitsInBuffer_;
			}
		}
		
		/// <summary>
		/// Gets the number of bytes available.
		/// </summary>
		/// <returns>
		/// The number of bytes available.
		/// </returns>
		public int AvailableBytes {
			get {
				return windowEnd_ - windowStart_ + (bitsInBuffer_ >> 3);
			}
		}
		
		/// <summary>
		/// Skips to the next byte boundary.
		/// </summary>
		public void SkipToByteBoundary()
		{
			buffer_ >>= (bitsInBuffer_ & 7);
			bitsInBuffer_ &= ~7;
		}

		/// <summary>
		/// Returns true when SetInput can be called
		/// </summary>
		public bool IsNeedingInput {
			get {
				return windowStart_ == windowEnd_;
			}
		}
		
		/// <summary>
		/// Copies bytes from input buffer to output buffer starting
		/// at output[offset].  You have to make sure, that the buffer is
		/// byte aligned.  If not enough bytes are available, copies fewer
		/// bytes.
		/// </summary>
		/// <param name="output">
		/// The buffer to copy bytes to.
		/// </param>
		/// <param name="offset">
		/// The offset in the buffer at which copying starts
		/// </param>
		/// <param name="length">
		/// The length to copy, 0 is allowed.
		/// </param>
		/// <returns>
		/// The number of bytes copied, 0 if no bytes were available.
		/// </returns>
		/// <exception cref="ArgumentOutOfRangeException">
		/// Length is less than zero
		/// </exception>
		/// <exception cref="InvalidOperationException">
		/// Bit buffer isnt byte aligned
		/// </exception>
		public int CopyBytes(byte[] output, int offset, int length)
		{
			if (length < 0) {
				throw new ArgumentOutOfRangeException("length");
			}

			if ((bitsInBuffer_ & 7) != 0) {
				// bits_in_buffer may only be 0 or a multiple of 8
				throw new InvalidOperationException("Bit buffer is not byte aligned!");
			}
			
			int count = 0;
			while ((bitsInBuffer_ > 0) && (length > 0)) {
				output[offset++] = (byte) buffer_;
				buffer_ >>= 8;
				bitsInBuffer_ -= 8;
				length--;
				count++;
			}
			
			if (length == 0) {
				return count;
			}
			
			int avail = windowEnd_ - windowStart_;
			if (length > avail) {
				length = avail;
			}
			System.Array.Copy(window_, windowStart_, output, offset, length);
			windowStart_ += length;
			
			if (((windowStart_ - windowEnd_) & 1) != 0) {
				// We always want an even number of bytes in input, see peekBits
				buffer_ = (uint)(window_[windowStart_++] & 0xff);
				bitsInBuffer_ = 8;
			}
			return count + length;
		}
		
		/// <summary>
		/// Resets state and empties internal buffers
		/// </summary>
		public void Reset()
		{
			buffer_ = 0;
			windowStart_ = windowEnd_ = bitsInBuffer_ = 0;
		}

		/// <summary>
		/// Add more input for consumption.
		/// Only call when IsNeedingInput returns true
		/// </summary>
		/// <param name="buffer">data to be input</param>
		/// <param name="offset">offset of first byte of input</param>
		/// <param name="count">number of bytes of input to add.</param>
		public void SetInput(byte[] buffer, int offset, int count)
		{
			if ( buffer == null ) {
				throw new ArgumentNullException("buffer");
			}

			if ( offset < 0 ) {
#if NETCF_1_0
				throw new ArgumentOutOfRangeException("offset");
#else
				throw new ArgumentOutOfRangeException("offset", "Cannot be negative");
#endif				
			}

			if ( count < 0 ) {
#if NETCF_1_0
				throw new ArgumentOutOfRangeException("count");
#else
				throw new ArgumentOutOfRangeException("count", "Cannot be negative");
#endif				
			}

			if (windowStart_ < windowEnd_) {
				throw new InvalidOperationException("Old input was not completely processed");
			}
			
			int end = offset + count;
			
			// We want to throw an ArrayIndexOutOfBoundsException early.
			// Note the check also handles integer wrap around.
			if ((offset > end) || (end > buffer.Length) ) {
				throw new ArgumentOutOfRangeException("count");
			}
			
			if ((count & 1) != 0) {
				// We always want an even number of bytes in input, see PeekBits
				buffer_ |= (uint)((buffer[offset++] & 0xff) << bitsInBuffer_);
				bitsInBuffer_ += 8;
			}
			
			window_ = buffer;
			windowStart_ = offset;
			windowEnd_ = end;
		}

		#region Instance Fields
		private byte[] window_;
		private int windowStart_;
		private int windowEnd_;

		private uint buffer_;
		private int bitsInBuffer_;
		#endregion
	}
}



================================================
File: de4dot.code/deobfuscators/AllTypesHelper.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet;

namespace de4dot.code.deobfuscators {
	static class AllTypesHelper {
		public static IEnumerable<TypeDef> Types(IEnumerable<TypeDef> types) {
			var visited = new Dictionary<TypeDef, bool>();
			var stack = new Stack<IEnumerator<TypeDef>>();
			if (types != null)
				stack.Push(types.GetEnumerator());
			while (stack.Count > 0) {
				var enumerator = stack.Pop();
				while (enumerator.MoveNext()) {
					var type = enumerator.Current;
					if (visited.ContainsKey(type))
						continue;
					visited[type] = true;
					yield return type;
					if (type.NestedTypes.Count > 0) {
						stack.Push(enumerator);
						enumerator = type.NestedTypes.GetEnumerator();
					}
				}
			}
		}
	}
}



================================================
File: de4dot.code/deobfuscators/ArrayFinder.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks.cflow;

namespace de4dot.code.deobfuscators {
	public static class ArrayFinder {
		public static List<byte[]> GetArrays(MethodDef method) => GetArrays(method, null);

		public static List<byte[]> GetArrays(MethodDef method, IType arrayElementType) {
			var arrays = new List<byte[]>();
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count; i++) {
				var ary = GetArray(instrs, ref i, out var type);
				if (ary == null)
					break;
				if (arrayElementType != null && !new SigComparer().Equals(type, arrayElementType))
					continue;

				arrays.Add(ary);
			}
			return arrays;
		}

		public static byte[] GetArray(IList<Instruction> instrs, ref int index, out IType type) {
			for (int i = index; i < instrs.Count - 2; i++) {
				var newarr = instrs[i++];
				if (newarr.OpCode.Code != Code.Newarr)
					continue;

				if (instrs[i++].OpCode.Code != Code.Dup)
					continue;

				var ldtoken = instrs[i++];
				if (ldtoken.OpCode.Code != Code.Ldtoken)
					continue;
				var field = ldtoken.Operand as FieldDef;
				if (field == null || field.InitialValue == null)
					continue;

				index = i - 3;
				type = newarr.Operand as IType;
				return field.InitialValue;
			}

			index = instrs.Count;
			type = null;
			return null;
		}

		public static byte[] GetInitializedByteArray(MethodDef method, int arraySize) {
			int newarrIndex = FindNewarr(method, arraySize);
			if (newarrIndex < 0)
				return null;
			return GetInitializedByteArray(arraySize, method, ref newarrIndex);
		}

		public static byte[] GetInitializedByteArray(int arraySize, MethodDef method, ref int newarrIndex) {
			var resultValueArray = GetInitializedArray(arraySize, method, ref newarrIndex, Code.Stelem_I1);

			var resultArray = new byte[resultValueArray.Length];
			for (int i = 0; i < resultArray.Length; i++) {
				var intValue = resultValueArray[i] as Int32Value;
				if (intValue == null || !intValue.AllBitsValid())
					return null;
				resultArray[i] = (byte)intValue.Value;
			}
			return resultArray;
		}

		public static short[] GetInitializedInt16Array(int arraySize, MethodDef method, ref int newarrIndex) {
			var resultValueArray = GetInitializedArray(arraySize, method, ref newarrIndex, Code.Stelem_I2);

			var resultArray = new short[resultValueArray.Length];
			for (int i = 0; i < resultArray.Length; i++) {
				var intValue = resultValueArray[i] as Int32Value;
				if (intValue == null || !intValue.AllBitsValid())
					return null;
				resultArray[i] = (short)intValue.Value;
			}
			return resultArray;
		}

		public static int[] GetInitializedInt32Array(int arraySize, MethodDef method, ref int newarrIndex) {
			var resultValueArray = GetInitializedArray(arraySize, method, ref newarrIndex, Code.Stelem_I4);

			var resultArray = new int[resultValueArray.Length];
			for (int i = 0; i < resultArray.Length; i++) {
				var intValue = resultValueArray[i] as Int32Value;
				if (intValue == null || !intValue.AllBitsValid())
					return null;
				resultArray[i] = (int)intValue.Value;
			}
			return resultArray;
		}

		public static uint[] GetInitializedUInt32Array(int arraySize, MethodDef method, ref int newarrIndex) {
			var resultArray = GetInitializedInt32Array(arraySize, method, ref newarrIndex);
			if (resultArray == null)
				return null;

			var ary = new uint[resultArray.Length];
			for (int i = 0; i < ary.Length; i++)
				ary[i] = (uint)resultArray[i];
			return ary;
		}

		public static Value[] GetInitializedArray(int arraySize, MethodDef method, ref int newarrIndex, Code stelemOpCode) {
			var resultValueArray = new Value[arraySize];

			var emulator = new InstructionEmulator(method);
			var theArray = new UnknownValue();
			emulator.Push(theArray);

			var instructions = method.Body.Instructions;
			int i;
			for (i = newarrIndex + 1; i < instructions.Count; i++) {
				var instr = instructions[i];
				if (instr.OpCode.FlowControl != FlowControl.Next)
					break;
				if (instr.OpCode.Code == Code.Newarr)
					break;
				switch (instr.OpCode.Code) {
				case Code.Newarr:
				case Code.Newobj:
					goto done;

				case Code.Stloc:
				case Code.Stloc_S:
				case Code.Stloc_0:
				case Code.Stloc_1:
				case Code.Stloc_2:
				case Code.Stloc_3:
				case Code.Starg:
				case Code.Starg_S:
				case Code.Stsfld:
				case Code.Stfld:
					if (emulator.Peek() == theArray && i != newarrIndex + 1 && i != newarrIndex + 2)
						goto done;
					break;
				}

				if (instr.OpCode.Code == stelemOpCode) {
					var value = emulator.Pop();
					var index = emulator.Pop() as Int32Value;
					var array = emulator.Pop();
					if (ReferenceEquals(array, theArray) && index != null && index.AllBitsValid()) {
						if (0 <= index.Value && index.Value < resultValueArray.Length)
							resultValueArray[index.Value] = value;
					}
				}
				else
					emulator.Emulate(instr);
			}
done:
			if (i != newarrIndex + 1)
				i--;
			newarrIndex = i;

			return resultValueArray;
		}

		static int FindNewarr(MethodDef method, int arraySize) {
			for (int i = 0; ; i++) {
				if (!FindNewarr(method, ref i, out int size))
					return -1;
				if (size == arraySize)
					return i;
			}
		}

		public static bool FindNewarr(MethodDef method, ref int i, out int size) {
			var instructions = method.Body.Instructions;
			for (; i < instructions.Count; i++) {
				var instr = instructions[i];
				if (instr.OpCode.Code != Code.Newarr || i < 1)
					continue;
				var ldci4 = instructions[i - 1];
				if (!ldci4.IsLdcI4())
					continue;

				size = ldci4.GetLdcI4Value();
				return true;
			}

			size = -1;
			return false;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Blowfish.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;

namespace de4dot.code.deobfuscators {
	public class Blowfish {
		static readonly uint[] Pboxes = new uint[18] {
			0x243F6A88, 0x85A308D3, 0x13198A2E, 0x03707344,
			0xA4093822, 0x299F31D0, 0x082EFA98, 0xEC4E6C89,
			0x452821E6, 0x38D01377, 0xBE5466CF, 0x34E90C6C,
			0xC0AC29B7, 0xC97C50DD, 0x3F84D5B5, 0xB5470917,
			0x9216D5D9, 0x8979FB1B,
		};
		static readonly uint[] Sboxes = new uint[1024] {
			0xD1310BA6, 0x98DFB5AC, 0x2FFD72DB, 0xD01ADFB7,
			0xB8E1AFED, 0x6A267E96, 0xBA7C9045, 0xF12C7F99,
			0x24A19947, 0xB3916CF7, 0x0801F2E2, 0x858EFC16,
			0x636920D8, 0x71574E69, 0xA458FEA3, 0xF4933D7E,
			0x0D95748F, 0x728EB658, 0x718BCD58, 0x82154AEE,
			0x7B54A41D, 0xC25A59B5, 0x9C30D539, 0x2AF26013,
			0xC5D1B023, 0x286085F0, 0xCA417918, 0xB8DB38EF,
			0x8E79DCB0, 0x603A180E, 0x6C9E0E8B, 0xB01E8A3E,
			0xD71577C1, 0xBD314B27, 0x78AF2FDA, 0x55605C60,
			0xE65525F3, 0xAA55AB94, 0x57489862, 0x63E81440,
			0x55CA396A, 0x2AAB10B6, 0xB4CC5C34, 0x1141E8CE,
			0xA15486AF, 0x7C72E993, 0xB3EE1411, 0x636FBC2A,
			0x2BA9C55D, 0x741831F6, 0xCE5C3E16, 0x9B87931E,
			0xAFD6BA33, 0x6C24CF5C, 0x7A325381, 0x28958677,
			0x3B8F4898, 0x6B4BB9AF, 0xC4BFE81B, 0x66282193,
			0x61D809CC, 0xFB21A991, 0x487CAC60, 0x5DEC8032,
			0xEF845D5D, 0xE98575B1, 0xDC262302, 0xEB651B88,
			0x23893E81, 0xD396ACC5, 0x0F6D6FF3, 0x83F44239,
			0x2E0B4482, 0xA4842004, 0x69C8F04A, 0x9E1F9B5E,
			0x21C66842, 0xF6E96C9A, 0x670C9C61, 0xABD388F0,
			0x6A51A0D2, 0xD8542F68, 0x960FA728, 0xAB5133A3,
			0x6EEF0B6C, 0x137A3BE4, 0xBA3BF050, 0x7EFB2A98,
			0xA1F1651D, 0x39AF0176, 0x66CA593E, 0x82430E88,
			0x8CEE8619, 0x456F9FB4, 0x7D84A5C3, 0x3B8B5EBE,
			0xE06F75D8, 0x85C12073, 0x401A449F, 0x56C16AA6,
			0x4ED3AA62, 0x363F7706, 0x1BFEDF72, 0x429B023D,
			0x37D0D724, 0xD00A1248, 0xDB0FEAD3, 0x49F1C09B,
			0x075372C9, 0x80991B7B, 0x25D479D8, 0xF6E8DEF7,
			0xE3FE501A, 0xB6794C3B, 0x976CE0BD, 0x04C006BA,
			0xC1A94FB6, 0x409F60C4, 0x5E5C9EC2, 0x196A2463,
			0x68FB6FAF, 0x3E6C53B5, 0x1339B2EB, 0x3B52EC6F,
			0x6DFC511F, 0x9B30952C, 0xCC814544, 0xAF5EBD09,
			0xBEE3D004, 0xDE334AFD, 0x660F2807, 0x192E4BB3,
			0xC0CBA857, 0x45C8740F, 0xD20B5F39, 0xB9D3FBDB,
			0x5579C0BD, 0x1A60320A, 0xD6A100C6, 0x402C7279,
			0x679F25FE, 0xFB1FA3CC, 0x8EA5E9F8, 0xDB3222F8,
			0x3C7516DF, 0xFD616B15, 0x2F501EC8, 0xAD0552AB,
			0x323DB5FA, 0xFD238760, 0x53317B48, 0x3E00DF82,
			0x9E5C57BB, 0xCA6F8CA0, 0x1A87562E, 0xDF1769DB,
			0xD542A8F6, 0x287EFFC3, 0xAC6732C6, 0x8C4F5573,
			0x695B27B0, 0xBBCA58C8, 0xE1FFA35D, 0xB8F011A0,
			0x10FA3D98, 0xFD2183B8, 0x4AFCB56C, 0x2DD1D35B,
			0x9A53E479, 0xB6F84565, 0xD28E49BC, 0x4BFB9790,
			0xE1DDF2DA, 0xA4CB7E33, 0x62FB1341, 0xCEE4C6E8,
			0xEF20CADA, 0x36774C01, 0xD07E9EFE, 0x2BF11FB4,
			0x95DBDA4D, 0xAE909198, 0xEAAD8E71, 0x6B93D5A0,
			0xD08ED1D0, 0xAFC725E0, 0x8E3C5B2F, 0x8E7594B7,
			0x8FF6E2FB, 0xF2122B64, 0x8888B812, 0x900DF01C,
			0x4FAD5EA0, 0x688FC31C, 0xD1CFF191, 0xB3A8C1AD,
			0x2F2F2218, 0xBE0E1777, 0xEA752DFE, 0x8B021FA1,
			0xE5A0CC0F, 0xB56F74E8, 0x18ACF3D6, 0xCE89E299,
			0xB4A84FE0, 0xFD13E0B7, 0x7CC43B81, 0xD2ADA8D9,
			0x165FA266, 0x80957705, 0x93CC7314, 0x211A1477,
			0xE6AD2065, 0x77B5FA86, 0xC75442F5, 0xFB9D35CF,
			0xEBCDAF0C, 0x7B3E89A0, 0xD6411BD3, 0xAE1E7E49,
			0x00250E2D, 0x2071B35E, 0x226800BB, 0x57B8E0AF,
			0x2464369B, 0xF009B91E, 0x5563911D, 0x59DFA6AA,
			0x78C14389, 0xD95A537F, 0x207D5BA2, 0x02E5B9C5,
			0x83260376, 0x6295CFA9, 0x11C81968, 0x4E734A41,
			0xB3472DCA, 0x7B14A94A, 0x1B510052, 0x9A532915,
			0xD60F573F, 0xBC9BC6E4, 0x2B60A476, 0x81E67400,
			0x08BA6FB5, 0x571BE91F, 0xF296EC6B, 0x2A0DD915,
			0xB6636521, 0xE7B9F9B6, 0xFF34052E, 0xC5855664,
			0x53B02D5D, 0xA99F8FA1, 0x08BA4799, 0x6E85076A,
			0x4B7A70E9, 0xB5B32944, 0xDB75092E, 0xC4192623,
			0xAD6EA6B0, 0x49A7DF7D, 0x9CEE60B8, 0x8FEDB266,
			0xECAA8C71, 0x699A17FF, 0x5664526C, 0xC2B19EE1,
			0x193602A5, 0x75094C29, 0xA0591340, 0xE4183A3E,
			0x3F54989A, 0x5B429D65, 0x6B8FE4D6, 0x99F73FD6,
			0xA1D29C07, 0xEFE830F5, 0x4D2D38E6, 0xF0255DC1,
			0x4CDD2086, 0x8470EB26, 0x6382E9C6, 0x021ECC5E,
			0x09686B3F, 0x3EBAEFC9, 0x3C971814, 0x6B6A70A1,
			0x687F3584, 0x52A0E286, 0xB79C5305, 0xAA500737,
			0x3E07841C, 0x7FDEAE5C, 0x8E7D44EC, 0x5716F2B8,
			0xB03ADA37, 0xF0500C0D, 0xF01C1F04, 0x0200B3FF,
			0xAE0CF51A, 0x3CB574B2, 0x25837A58, 0xDC0921BD,
			0xD19113F9, 0x7CA92FF6, 0x94324773, 0x22F54701,
			0x3AE5E581, 0x37C2DADC, 0xC8B57634, 0x9AF3DDA7,
			0xA9446146, 0x0FD0030E, 0xECC8C73E, 0xA4751E41,
			0xE238CD99, 0x3BEA0E2F, 0x3280BBA1, 0x183EB331,
			0x4E548B38, 0x4F6DB908, 0x6F420D03, 0xF60A04BF,
			0x2CB81290, 0x24977C79, 0x5679B072, 0xBCAF89AF,
			0xDE9A771F, 0xD9930810, 0xB38BAE12, 0xDCCF3F2E,
			0x5512721F, 0x2E6B7124, 0x501ADDE6, 0x9F84CD87,
			0x7A584718, 0x7408DA17, 0xBC9F9ABC, 0xE94B7D8C,
			0xEC7AEC3A, 0xDB851DFA, 0x63094366, 0xC464C3D2,
			0xEF1C1847, 0x3215D908, 0xDD433B37, 0x24C2BA16,
			0x12A14D43, 0x2A65C451, 0x50940002, 0x133AE4DD,
			0x71DFF89E, 0x10314E55, 0x81AC77D6, 0x5F11199B,
			0x043556F1, 0xD7A3C76B, 0x3C11183B, 0x5924A509,
			0xF28FE6ED, 0x97F1FBFA, 0x9EBABF2C, 0x1E153C6E,
			0x86E34570, 0xEAE96FB1, 0x860E5E0A, 0x5A3E2AB3,
			0x771FE71C, 0x4E3D06FA, 0x2965DCB9, 0x99E71D0F,
			0x803E89D6, 0x5266C825, 0x2E4CC978, 0x9C10B36A,
			0xC6150EBA, 0x94E2EA78, 0xA5FC3C53, 0x1E0A2DF4,
			0xF2F74EA7, 0x361D2B3D, 0x1939260F, 0x19C27960,
			0x5223A708, 0xF71312B6, 0xEBADFE6E, 0xEAC31F66,
			0xE3BC4595, 0xA67BC883, 0xB17F37D1, 0x018CFF28,
			0xC332DDEF, 0xBE6C5AA5, 0x65582185, 0x68AB9802,
			0xEECEA50F, 0xDB2F953B, 0x2AEF7DAD, 0x5B6E2F84,
			0x1521B628, 0x29076170, 0xECDD4775, 0x619F1510,
			0x13CCA830, 0xEB61BD96, 0x0334FE1E, 0xAA0363CF,
			0xB5735C90, 0x4C70A239, 0xD59E9E0B, 0xCBAADE14,
			0xEECC86BC, 0x60622CA7, 0x9CAB5CAB, 0xB2F3846E,
			0x648B1EAF, 0x19BDF0CA, 0xA02369B9, 0x655ABB50,
			0x40685A32, 0x3C2AB4B3, 0x319EE9D5, 0xC021B8F7,
			0x9B540B19, 0x875FA099, 0x95F7997E, 0x623D7DA8,
			0xF837889A, 0x97E32D77, 0x11ED935F, 0x16681281,
			0x0E358829, 0xC7E61FD6, 0x96DEDFA1, 0x7858BA99,
			0x57F584A5, 0x1B227263, 0x9B83C3FF, 0x1AC24696,
			0xCDB30AEB, 0x532E3054, 0x8FD948E4, 0x6DBC3128,
			0x58EBF2EF, 0x34C6FFEA, 0xFE28ED61, 0xEE7C3C73,
			0x5D4A14D9, 0xE864B7E3, 0x42105D14, 0x203E13E0,
			0x45EEE2B6, 0xA3AAABEA, 0xDB6C4F15, 0xFACB4FD0,
			0xC742F442, 0xEF6ABBB5, 0x654F3B1D, 0x41CD2105,
			0xD81E799E, 0x86854DC7, 0xE44B476A, 0x3D816250,
			0xCF62A1F2, 0x5B8D2646, 0xFC8883A0, 0xC1C7B6A3,
			0x7F1524C3, 0x69CB7492, 0x47848A0B, 0x5692B285,
			0x095BBF00, 0xAD19489D, 0x1462B174, 0x23820E00,
			0x58428D2A, 0x0C55F5EA, 0x1DADF43E, 0x233F7061,
			0x3372F092, 0x8D937E41, 0xD65FECF1, 0x6C223BDB,
			0x7CDE3759, 0xCBEE7460, 0x4085F2A7, 0xCE77326E,
			0xA6078084, 0x19F8509E, 0xE8EFD855, 0x61D99735,
			0xA969A7AA, 0xC50C06C2, 0x5A04ABFC, 0x800BCADC,
			0x9E447A2E, 0xC3453484, 0xFDD56705, 0x0E1E9EC9,
			0xDB73DBD3, 0x105588CD, 0x675FDA79, 0xE3674340,
			0xC5C43465, 0x713E38D8, 0x3D28F89E, 0xF16DFF20,
			0x153E21E7, 0x8FB03D4A, 0xE6E39F2B, 0xDB83ADF7,
			0xE93D5A68, 0x948140F7, 0xF64C261C, 0x94692934,
			0x411520F7, 0x7602D4F7, 0xBCF46B2E, 0xD4A20068,
			0xD4082471, 0x3320F46A, 0x43B7D4B7, 0x500061AF,
			0x1E39F62E, 0x97244546, 0x14214F74, 0xBF8B8840,
			0x4D95FC1D, 0x96B591AF, 0x70F4DDD3, 0x66A02F45,
			0xBFBC09EC, 0x03BD9785, 0x7FAC6DD0, 0x31CB8504,
			0x96EB27B3, 0x55FD3941, 0xDA2547E6, 0xABCA0A9A,
			0x28507825, 0x530429F4, 0x0A2C86DA, 0xE9B66DFB,
			0x68DC1462, 0xD7486900, 0x680EC0A4, 0x27A18DEE,
			0x4F3FFEA2, 0xE887AD8C, 0xB58CE006, 0x7AF4D6B6,
			0xAACE1E7C, 0xD3375FEC, 0xCE78A399, 0x406B2A42,
			0x20FE9E35, 0xD9F385B9, 0xEE39D7AB, 0x3B124E8B,
			0x1DC9FAF7, 0x4B6D1856, 0x26A36631, 0xEAE397B2,
			0x3A6EFA74, 0xDD5B4332, 0x6841E7F7, 0xCA7820FB,
			0xFB0AF54E, 0xD8FEB397, 0x454056AC, 0xBA489527,
			0x55533A3A, 0x20838D87, 0xFE6BA9B7, 0xD096954B,
			0x55A867BC, 0xA1159A58, 0xCCA92963, 0x99E1DB33,
			0xA62A4A56, 0x3F3125F9, 0x5EF47E1C, 0x9029317C,
			0xFDF8E802, 0x04272F70, 0x80BB155C, 0x05282CE3,
			0x95C11548, 0xE4C66D22, 0x48C1133F, 0xC70F86DC,
			0x07F9C9EE, 0x41041F0F, 0x404779A4, 0x5D886E17,
			0x325F51EB, 0xD59BC0D1, 0xF2BCC18F, 0x41113564,
			0x257B7834, 0x602A9C60, 0xDFF8E8A3, 0x1F636C1B,
			0x0E12B4C2, 0x02E1329E, 0xAF664FD1, 0xCAD18115,
			0x6B2395E0, 0x333E92E1, 0x3B240B62, 0xEEBEB922,
			0x85B2A20E, 0xE6BA0D99, 0xDE720C8C, 0x2DA2F728,
			0xD0127845, 0x95B794FD, 0x647D0862, 0xE7CCF5F0,
			0x5449A36F, 0x877D48FA, 0xC39DFD27, 0xF33E8D1E,
			0x0A476341, 0x992EFF74, 0x3A6F6EAB, 0xF4F8FD37,
			0xA812DC60, 0xA1EBDDF8, 0x991BE14C, 0xDB6E6B0D,
			0xC67B5510, 0x6D672C37, 0x2765D43B, 0xDCD0E804,
			0xF1290DC7, 0xCC00FFA3, 0xB5390F92, 0x690FED0B,
			0x667B9FFB, 0xCEDB7D9C, 0xA091CF0B, 0xD9155EA3,
			0xBB132F88, 0x515BAD24, 0x7B9479BF, 0x763BD6EB,
			0x37392EB3, 0xCC115979, 0x8026E297, 0xF42E312D,
			0x6842ADA7, 0xC66A2B3B, 0x12754CCC, 0x782EF11C,
			0x6A124237, 0xB79251E7, 0x06A1BBE6, 0x4BFB6350,
			0x1A6B1018, 0x11CAEDFA, 0x3D25BDD8, 0xE2E1C3C9,
			0x44421659, 0x0A121386, 0xD90CEC6E, 0xD5ABEA2A,
			0x64AF674E, 0xDA86A85F, 0xBEBFE988, 0x64E4C3FE,
			0x9DBC8057, 0xF0F7C086, 0x60787BF8, 0x6003604D,
			0xD1FD8346, 0xF6381FB0, 0x7745AE04, 0xD736FCCC,
			0x83426B33, 0xF01EAB71, 0xB0804187, 0x3C005E5F,
			0x77A057BE, 0xBDE8AE24, 0x55464299, 0xBF582E61,
			0x4E58F48F, 0xF2DDFDA2, 0xF474EF38, 0x8789BDC2,
			0x5366F9C3, 0xC8B38E74, 0xB475F255, 0x46FCD9B9,
			0x7AEB2661, 0x8B1DDF84, 0x846A0E79, 0x915F95E2,
			0x466E598E, 0x20B45770, 0x8CD55591, 0xC902DE4C,
			0xB90BACE1, 0xBB8205D0, 0x11A86248, 0x7574A99E,
			0xB77F19B6, 0xE0A9DC09, 0x662D09A1, 0xC4324633,
			0xE85A1F02, 0x09F0BE8C, 0x4A99A025, 0x1D6EFE10,
			0x1AB93D1D, 0x0BA5A4DF, 0xA186F20F, 0x2868F169,
			0xDCB7DA83, 0x573906FE, 0xA1E2CE9B, 0x4FCD7F52,
			0x50115E01, 0xA70683FA, 0xA002B5C4, 0x0DE6D027,
			0x9AF88C27, 0x773F8641, 0xC3604C06, 0x61A806B5,
			0xF0177A28, 0xC0F586E0, 0x006058AA, 0x30DC7D62,
			0x11E69ED7, 0x2338EA63, 0x53C2DD94, 0xC2C21634,
			0xBBCBEE56, 0x90BCB6DE, 0xEBFC7DA1, 0xCE591D76,
			0x6F05E409, 0x4B7C0188, 0x39720A3D, 0x7C927C24,
			0x86E3725F, 0x724D9DB9, 0x1AC15BB4, 0xD39EB8FC,
			0xED545578, 0x08FCA5B5, 0xD83D7CD3, 0x4DAD0FC4,
			0x1E50EF5E, 0xB161E6F8, 0xA28514D9, 0x6C51133C,
			0x6FD5C7E7, 0x56E14EC4, 0x362ABFCE, 0xDDC6C837,
			0xD79A3234, 0x92638212, 0x670EFA8E, 0x406000E0,
			0x3A39CE37, 0xD3FAF5CF, 0xABC27737, 0x5AC52D1B,
			0x5CB0679E, 0x4FA33742, 0xD3822740, 0x99BC9BBE,
			0xD5118E9D, 0xBF0F7315, 0xD62D1C7E, 0xC700C47B,
			0xB78C1B6B, 0x21A19045, 0xB26EB1BE, 0x6A366EB4,
			0x5748AB2F, 0xBC946E79, 0xC6A376D2, 0x6549C2C8,
			0x530FF8EE, 0x468DDE7D, 0xD5730A1D, 0x4CD04DC6,
			0x2939BBDB, 0xA9BA4650, 0xAC9526E8, 0xBE5EE304,
			0xA1FAD5F0, 0x6A2D519A, 0x63EF8CE2, 0x9A86EE22,
			0xC089C2B8, 0x43242EF6, 0xA51E03AA, 0x9CF2D0A4,
			0x83C061BA, 0x9BE96A4D, 0x8FE51550, 0xBA645BD6,
			0x2826A2F9, 0xA73A3AE1, 0x4BA99586, 0xEF5562E9,
			0xC72FEFD3, 0xF752F7DA, 0x3F046F69, 0x77FA0A59,
			0x80E4A915, 0x87B08601, 0x9B09E6AD, 0x3B3EE593,
			0xE990FD5A, 0x9E34D797, 0x2CF0B7D9, 0x022B8B51,
			0x96D5AC3A, 0x017DA67D, 0xD1CF3ED6, 0x7C7D2D28,
			0x1F9F25CF, 0xADF2B89B, 0x5AD6B472, 0x5A88F54C,
			0xE029AC71, 0xE019A5E6, 0x47B0ACFD, 0xED93FA9B,
			0xE8D3C48D, 0x283B57CC, 0xF8D56629, 0x79132E28,
			0x785F0191, 0xED756055, 0xF7960E44, 0xE3D35E8C,
			0x15056DD4, 0x88F46DBA, 0x03A16125, 0x0564F0BD,
			0xC3EB9E15, 0x3C9057A2, 0x97271AEC, 0xA93A072A,
			0x1B3F6D9B, 0x1E6321F5, 0xF59C66FB, 0x26DCF319,
			0x7533D928, 0xB155FDF5, 0x03563482, 0x8ABA3CBB,
			0x28517711, 0xC20AD9F8, 0xABCC5167, 0xCCAD925F,
			0x4DE81751, 0x3830DC8E, 0x379D5862, 0x9320F991,
			0xEA7A90C2, 0xFB3E7BCE, 0x5121CE64, 0x774FBE32,
			0xA8B6E37E, 0xC3293D46, 0x48DE5369, 0x6413E680,
			0xA2AE0810, 0xDD6DB224, 0x69852DFD, 0x09072166,
			0xB39A460A, 0x6445C0DD, 0x586CDECF, 0x1C20C8AE,
			0x5BBEF7DD, 0x1B588D40, 0xCCD2017F, 0x6BB4E3BB,
			0xDDA26A7E, 0x3A59FF45, 0x3E350A44, 0xBCB4CDD5,
			0x72EACEA8, 0xFA6484BB, 0x8D6612AE, 0xBF3C6F47,
			0xD29BE463, 0x542F5D9E, 0xAEC2771B, 0xF64E6370,
			0x740E0D8D, 0xE75B1357, 0xF8721671, 0xAF537D5D,
			0x4040CB08, 0x4EB4E2CC, 0x34D2466A, 0x0115AF84,
			0xE1B00428, 0x95983A1D, 0x06B89FB4, 0xCE6EA048,
			0x6F3F3B82, 0x3520AB82, 0x011A1D4B, 0x277227F8,
			0x611560B1, 0xE7933FDC, 0xBB3A792B, 0x344525BD,
			0xA08839E1, 0x51CE794B, 0x2F32C9B7, 0xA01FBAC9,
			0xE01CC87E, 0xBCC7D1F6, 0xCF0111C3, 0xA1E8AAC7,
			0x1A908749, 0xD44FBD9A, 0xD0DADECB, 0xD50ADA38,
			0x0339C32A, 0xC6913667, 0x8DF9317C, 0xE0B12B4F,
			0xF79E59B7, 0x43F5BB3A, 0xF2D519FF, 0x27D9459C,
			0xBF97222C, 0x15E6FC2A, 0x0F91FC71, 0x9B941525,
			0xFAE59361, 0xCEB69CEB, 0xC2A86459, 0x12BAA8D1,
			0xB6C1075E, 0xE3056A0C, 0x10D25065, 0xCB03A442,
			0xE0EC6E0E, 0x1698DB3B, 0x4C98A0BE, 0x3278E964,
			0x9F1F9532, 0xE0D392DF, 0xD3A0342B, 0x8971F21E,
			0x1B0A7441, 0x4BA3348C, 0xC5BE7120, 0xC37632D8,
			0xDF359F8D, 0x9B992F2E, 0xE60B6F47, 0x0FE3F11D,
			0xE54CDA54, 0x1EDAD891, 0xCE6279CF, 0xCD3E7E6F,
			0x1618B166, 0xFD2C1D05, 0x848FD2C5, 0xF6FB2299,
			0xF523F357, 0xA6327623, 0x93A83531, 0x56CCCD02,
			0xACF08162, 0x5A75EBB5, 0x6E163697, 0x88D273CC,
			0xDE966292, 0x81B949D0, 0x4C50901B, 0x71C65614,
			0xE6C6C7BD, 0x327A140A, 0x45E1D006, 0xC3F27B9A,
			0xC9AA53FD, 0x62A80F00, 0xBB25BFE2, 0x35BDD2F6,
			0x71126905, 0xB2040222, 0xB6CBCF7C, 0xCD769C2B,
			0x53113EC0, 0x1640E3D3, 0x38ABBD60, 0x2547ADF0,
			0xBA38209C, 0xF746CE76, 0x77AFA1C5, 0x20756060,
			0x85CBFE4E, 0x8AE88DD8, 0x7AAAF9B0, 0x4CF9AA7E,
			0x1948C25C, 0x02FB8A8C, 0x01C36AE4, 0xD6EBE1F9,
			0x90D4F869, 0xA65CDEA0, 0x3F09252D, 0xC208E69F,
			0xB74E6132, 0xCE77E25B, 0x578FDFE3, 0x3AC372E6,
		};

		protected readonly uint[] P = new uint[18];
		protected readonly uint[] S = new uint[1024];

		public Blowfish() { }
		public Blowfish(byte[] key) => Initialize(key);

		public void Initialize(byte[] key) {
			Array.Copy(Sboxes, S, S.Length);
			int kl = key.Length;
			for (int i = 0, ki = 0; i < 18; i++) {
				P[i] = Pboxes[i] ^ (((uint)key[ki++ % kl] << 24) | ((uint)key[ki++ % kl] << 16) |
							((uint)key[ki++ % kl] << 8) | key[ki++ % kl]);
			}

			uint xl = 0, xr = 0;
			for (int i = 0; i < 18; i += 2) {
				Encrypt(ref xl, ref xr);
				P[i] = xl;
				P[i + 1] = xr;
			}
			for (int i = 0; i < 1024; i += 2) {
				Encrypt(ref xl, ref xr);
				S[i] = xl;
				S[i + 1] = xr;
			}
		}

		public void Encrypt_LE(byte[] data) {
			for (int i = 0; i + 8 <= data.Length; i += 8) {
				uint xl = BitConverter.ToUInt32(data, i);
				uint xr = BitConverter.ToUInt32(data, i + 4);
				Encrypt(ref xl, ref xr);
				data[i] = (byte)xl;
				data[i + 1] = (byte)(xl >> 8);
				data[i + 2] = (byte)(xl >> 16);
				data[i + 3] = (byte)(xl >> 24);
				data[i + 4] = (byte)xr;
				data[i + 5] = (byte)(xr >> 8);
				data[i + 6] = (byte)(xr >> 16);
				data[i + 7] = (byte)(xr >> 24);
			}
		}

		public void Encrypt(byte[] data) {
			for (int i = 0; i + 8 <= data.Length; i += 8) {
				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);
				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);
				Encrypt(ref xl, ref xr);
				data[i] = (byte)(xl >> 24);
				data[i + 1] = (byte)(xl >> 16);
				data[i + 2] = (byte)(xl >> 8);
				data[i + 3] = (byte)xl;
				data[i + 4] = (byte)(xr >> 24);
				data[i + 5] = (byte)(xr >> 16);
				data[i + 6] = (byte)(xr >> 8);
				data[i + 7] = (byte)xr;
			}
		}

		protected virtual void Encrypt(ref uint rxl, ref uint rxr) {
			uint xl = rxl, xr = rxr;
			for (int i = 0; i < 16; i++) {
				xl ^= P[i];
				xr ^= ((S[0 * 256 + (xl >> 24)] + S[1 * 256 + (byte)(xl >> 16)]) ^ S[2 * 256 + (byte)(xl >> 8)]) + S[3 * 256 + (byte)xl];
				uint t = xl;
				xl = xr;
				xr = t;
			}
			rxr = xl ^ P[16];
			rxl = xr ^ P[17];
		}

		public void Decrypt_LE(byte[] data) {
			for (int i = 0; i + 8 <= data.Length; i += 8) {
				uint xl = BitConverter.ToUInt32(data, i);
				uint xr = BitConverter.ToUInt32(data, i + 4);
				Decrypt(ref xl, ref xr);
				data[i] = (byte)xl;
				data[i + 1] = (byte)(xl >> 8);
				data[i + 2] = (byte)(xl >> 16);
				data[i + 3] = (byte)(xl >> 24);
				data[i + 4] = (byte)xr;
				data[i + 5] = (byte)(xr >> 8);
				data[i + 6] = (byte)(xr >> 16);
				data[i + 7] = (byte)(xr >> 24);
			}
		}

		public void Decrypt(byte[] data) {
			for (int i = 0; i + 8 <= data.Length; i += 8) {
				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);
				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);
				Decrypt(ref xl, ref xr);
				data[i] = (byte)(xl >> 24);
				data[i + 1] = (byte)(xl >> 16);
				data[i + 2] = (byte)(xl >> 8);
				data[i + 3] = (byte)xl;
				data[i + 4] = (byte)(xr >> 24);
				data[i + 5] = (byte)(xr >> 16);
				data[i + 6] = (byte)(xr >> 8);
				data[i + 7] = (byte)xr;
			}
		}

		protected virtual void Decrypt(ref uint rxl, ref uint rxr) {
			uint xl = rxl, xr = rxr;
			for (int i = 17; i >= 2; i--) {
				xl ^= P[i];
				xr ^= ((S[0 * 256 + (xl >> 24)] + S[1 * 256 + (byte)(xl >> 16)]) ^ S[2 * 256 + (byte)(xl >> 8)]) + S[3 * 256 + (byte)xl];
				uint t = xl;
				xl = xr;
				xr = t;
			}
			rxr = xl ^ P[1];
			rxl = xr ^ P[0];
		}
	}
}



================================================
File: de4dot.code/deobfuscators/CRC32.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

namespace de4dot.code.deobfuscators {
	public struct CRC32 {
		static readonly uint[] table = new uint[256] {
			0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA,
			0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
			0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
			0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,
			0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE,
			0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
			0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC,
			0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,
			0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
			0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
			0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940,
			0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
			0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116,
			0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
			0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
			0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
			0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A,
			0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
			0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818,
			0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
			0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
			0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,
			0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C,
			0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
			0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2,
			0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,
			0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
			0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,
			0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086,
			0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
			0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4,
			0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,
			0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
			0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,
			0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,
			0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
			0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE,
			0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,
			0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
			0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
			0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252,
			0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
			0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60,
			0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,
			0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
			0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,
			0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04,
			0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
			0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A,
			0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
			0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
			0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,
			0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E,
			0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
			0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C,
			0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
			0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
			0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,
			0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0,
			0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
			0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6,
			0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,
			0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
			0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D,
		};

		uint checkSum;

		public void Initialize() => checkSum = uint.MaxValue;

		public void Hash(byte[] data) {
			if (data == null)
				return;
			foreach (var b in data) {
				int i = (byte)(checkSum ^ b);
				checkSum = (checkSum >> 8) ^ table[i];
			}
		}

		public void Hash(sbyte a) {
			int i = (byte)(checkSum ^ a);
			checkSum = (checkSum >> 8) ^ table[i];
		}

		public void Hash(byte a) {
			int i = (byte)(checkSum ^ a);
			checkSum = (checkSum >> 8) ^ table[i];
		}

		public void Hash(short a) {
			int i = (byte)(checkSum ^ (byte)a);
			checkSum = (checkSum >> 8) ^ table[i];

			i = (byte)(checkSum ^ (byte)(a >> 8));
			checkSum = (checkSum >> 8) ^ table[i];
		}

		public void Hash(ushort a) {
			int i = (byte)(checkSum ^ (byte)a);
			checkSum = (checkSum >> 8) ^ table[i];

			i = (byte)(checkSum ^ (byte)(a >> 8));
			checkSum = (checkSum >> 8) ^ table[i];
		}

		public void Hash(int a) {
			int i = (byte)(checkSum ^ (byte)a);
			checkSum = (checkSum >> 8) ^ table[i];

			i = (byte)(checkSum ^ (byte)(a >> 8));
			checkSum = (checkSum >> 8) ^ table[i];

			i = (byte)(checkSum ^ (byte)(a >> 16));
			checkSum = (checkSum >> 8) ^ table[i];

			i = (byte)(checkSum ^ (byte)(a >> 24));
			checkSum = (checkSum >> 8) ^ table[i];
		}

		public void Hash(uint a) {
			int i = (byte)(checkSum ^ (byte)a);
			checkSum = (checkSum >> 8) ^ table[i];

			i = (byte)(checkSum ^ (byte)(a >> 8));
			checkSum = (checkSum >> 8) ^ table[i];

			i = (byte)(checkSum ^ (byte)(a >> 16));
			checkSum = (checkSum >> 8) ^ table[i];

			i = (byte)(checkSum ^ (byte)(a >> 24));
			checkSum = (checkSum >> 8) ^ table[i];
		}

		public void Hash(long a) {
			int i = (byte)(checkSum ^ (byte)a);
			checkSum = (checkSum >> 8) ^ table[i];

			i = (byte)(checkSum ^ (byte)(a >> 8));
			checkSum = (checkSum >> 8) ^ table[i];

			i = (byte)(checkSum ^ (byte)(a >> 16));
			checkSum = (checkSum >> 8) ^ table[i];

			i = (byte)(checkSum ^ (byte)(a >> 24));
			checkSum = (checkSum >> 8) ^ table[i];

			i = (byte)(checkSum ^ (byte)(a >> 32));
			checkSum = (checkSum >> 8) ^ table[i];

			i = (byte)(checkSum ^ (byte)(a >> 40));
			checkSum = (checkSum >> 8) ^ table[i];

			i = (byte)(checkSum ^ (byte)(a >> 48));
			checkSum = (checkSum >> 8) ^ table[i];

			i = (byte)(checkSum ^ (byte)(a >> 56));
			checkSum = (checkSum >> 8) ^ table[i];
		}

		public void Hash(ulong a) {
			int i = (byte)(checkSum ^ (byte)a);
			checkSum = (checkSum >> 8) ^ table[i];

			i = (byte)(checkSum ^ (byte)(a >> 8));
			checkSum = (checkSum >> 8) ^ table[i];

			i = (byte)(checkSum ^ (byte)(a >> 16));
			checkSum = (checkSum >> 8) ^ table[i];

			i = (byte)(checkSum ^ (byte)(a >> 24));
			checkSum = (checkSum >> 8) ^ table[i];

			i = (byte)(checkSum ^ (byte)(a >> 32));
			checkSum = (checkSum >> 8) ^ table[i];

			i = (byte)(checkSum ^ (byte)(a >> 40));
			checkSum = (checkSum >> 8) ^ table[i];

			i = (byte)(checkSum ^ (byte)(a >> 48));
			checkSum = (checkSum >> 8) ^ table[i];

			i = (byte)(checkSum ^ (byte)(a >> 56));
			checkSum = (checkSum >> 8) ^ table[i];
		}

		public uint GetHash() => ~checkSum;

		public static uint CheckSum(byte[] data) {
			if (data == null)
				return 0;
			uint cs = uint.MaxValue;
			foreach (var b in data) {
				int i = (byte)(cs ^ b);
				cs = (cs >> 8) ^ table[i];
			}
			return ~cs;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/ConstantsReader.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators {
	public class ConstantsReader {
		protected IInstructions instructions;
		protected IList<Local> locals;
		protected Dictionary<Local, int> localsValuesInt32 = new Dictionary<Local, int>();
		protected Dictionary<Local, long> localsValuesInt64 = new Dictionary<Local, long>();
		protected Dictionary<Local, double> localsValuesDouble = new Dictionary<Local, double>();
		bool emulateConvInstrs;

		public IEnumerable<KeyValuePair<Local, int>> Locals32 => localsValuesInt32;
		public IEnumerable<KeyValuePair<Local, long>> Locals64 => localsValuesInt64;
		public IEnumerable<KeyValuePair<Local, double>> LocalsDouble => localsValuesDouble;

		public interface IInstructions {
			int Count { get; }
			Instruction this[int index] { get; }
		}

		class ListInstructions : IInstructions {
			IList<Instruction> instrs;
			public int Count => instrs.Count;
			public Instruction this[int index] => instrs[index];
			public ListInstructions(IList<Instruction> instrs) => this.instrs = instrs;
		}

		class ListInstrs : IInstructions {
			IList<Instr> instrs;
			public int Count => instrs.Count;
			public Instruction this[int index] => instrs[index].Instruction;
			public ListInstrs(IList<Instr> instrs) => this.instrs = instrs;
		}

		public bool EmulateConvInstructions {
			get => emulateConvInstrs;
			set => emulateConvInstrs = value;
		}

		ConstantsReader(IInstructions instructions)
			: this(instructions, true) {
		}

		ConstantsReader(IInstructions instructions, bool emulateConvInstrs) {
			this.instructions = instructions;
			this.emulateConvInstrs = emulateConvInstrs;
		}

		public ConstantsReader(IList<Instruction> instrs)
			: this(new ListInstructions(instrs)) {
		}

		public ConstantsReader(IList<Instruction> instrs, bool emulateConvInstrs)
			: this(new ListInstructions(instrs), emulateConvInstrs) {
		}

		public ConstantsReader(IList<Instr> instrs)
			: this(new ListInstrs(instrs)) {
		}

		public ConstantsReader(IList<Instr> instrs, bool emulateConvInstrs)
			: this(new ListInstrs(instrs), emulateConvInstrs) {
		}

		public ConstantsReader(MethodDef method)
			: this(method.Body.Instructions) => locals = method.Body.Variables;

		public ConstantsReader(IList<Instr> instrs, IList<Local> locals)
			: this(instrs) => this.locals = locals;

		public void SetConstantInt32(Local local, int value) => localsValuesInt32[local] = value;
		public void SetConstantInt32(Local local, uint value) => SetConstantInt32(local, (int)value);
		public void SetConstantInt64(Local local, long value) => localsValuesInt64[local] = value;
		public void SetConstantInt64(Local local, ulong value) => SetConstantInt64(local, (long)value);
		public void SetConstantDouble(Local local, double value) => localsValuesDouble[local] = value;

		public bool GetNextInt32(ref int index, out int val) {
			for (; index < instructions.Count; index++) {
				var instr = instructions[index];
				if (!IsLoadConstantInt32(instr))
					continue;

				return GetInt32(ref index, out val);
			}

			val = 0;
			return false;
		}

		public bool IsLoadConstantInt32(Instruction instr) {
			if (instr.IsLdcI4())
				return true;
			if (instr.IsLdloc())
				return GetLocalConstantInt32(instr, out int tmp);
			if (instr.IsLdarg())
				return GetArgConstantInt32(instr, out int tmp);
			return false;
		}

		public bool IsLoadConstantInt64(Instruction instr) {
			if (instr.OpCode.Code == Code.Ldc_I8)
				return true;
			if (instr.IsLdloc())
				return GetLocalConstantInt64(instr, out long tmp);
			if (instr.IsLdarg())
				return GetArgConstantInt64(instr, out long tmp);
			return false;
		}

		public bool IsLoadConstantDouble(Instruction instr) {
			if (instr.OpCode.Code == Code.Ldc_R8)
				return true;
			if (instr.IsLdloc())
				return GetLocalConstantDouble(instr, out double tmp);
			if (instr.IsLdarg())
				return GetArgConstantDouble(instr, out double tmp);
			return false;
		}

		public bool GetInt16(ref int index, out short val) {
			if (!GetInt32(ref index, out int tmp)) {
				val = 0;
				return false;
			}

			val = (short)tmp;
			return true;
		}

		protected struct ConstantInfo<T> {
			public int index;
			public T constant;
			public ConstantInfo(int index, T constant) {
				this.index = index;
				this.constant = constant;
			}
		}

		protected virtual bool ProcessInstructionInt32(ref int index, Stack<ConstantInfo<int>> stack) => false;
		protected virtual bool ProcessInstructionInt64(ref int index, Stack<ConstantInfo<long>> stack) => false;
		protected virtual bool ProcessInstructionDouble(ref int index, Stack<ConstantInfo<double>> stack) => false;

		public bool GetInt32(ref int index, out int val) {
			val = 0;
			if (index >= instructions.Count)
				return false;

			var stack = new Stack<ConstantInfo<int>>();

			int op1;
			ConstantInfo<int> info1, info2;
			for (; index < instructions.Count; index++) {
				if (ProcessInstructionInt32(ref index, stack)) {
					index--;
					continue;
				}
				var instr = instructions[index];
				switch (instr.OpCode.Code) {
				case Code.Conv_I1:
					if (!emulateConvInstrs || stack.Count < 1)
						goto done;
					stack.Push(new ConstantInfo<int>(index, (sbyte)stack.Pop().constant));
					break;

				case Code.Conv_U1:
					if (!emulateConvInstrs || stack.Count < 1)
						goto done;
					stack.Push(new ConstantInfo<int>(index, (byte)stack.Pop().constant));
					break;

				case Code.Conv_I2:
					if (!emulateConvInstrs || stack.Count < 1)
						goto done;
					stack.Push(new ConstantInfo<int>(index, (short)stack.Pop().constant));
					break;

				case Code.Conv_U2:
					if (!emulateConvInstrs || stack.Count < 1)
						goto done;
					stack.Push(new ConstantInfo<int>(index, (ushort)stack.Pop().constant));
					break;

				case Code.Conv_I4:
				case Code.Conv_U4:
					if (!emulateConvInstrs || stack.Count < 1)
						goto done;
					stack.Push(new ConstantInfo<int>(index, stack.Pop().constant));
					break;

				case Code.Not:
					if (stack.Count < 1)
						goto done;
					stack.Push(new ConstantInfo<int>(index, ~stack.Pop().constant));
					break;

				case Code.Neg:
					if (stack.Count < 1)
						goto done;
					stack.Push(new ConstantInfo<int>(index, -stack.Pop().constant));
					break;

				case Code.Ldloc:
				case Code.Ldloc_S:
				case Code.Ldloc_0:
				case Code.Ldloc_1:
				case Code.Ldloc_2:
				case Code.Ldloc_3:
					if (!GetLocalConstantInt32(instr, out op1))
						goto done;
					stack.Push(new ConstantInfo<int>(index, op1));
					break;

				case Code.Ldarg:
				case Code.Ldarg_S:
				case Code.Ldarg_0:
				case Code.Ldarg_1:
				case Code.Ldarg_2:
				case Code.Ldarg_3:
					if (!GetArgConstantInt32(instr, out op1))
						goto done;
					stack.Push(new ConstantInfo<int>(index, op1));
					break;

				case Code.Ldc_I4:
				case Code.Ldc_I4_S:
				case Code.Ldc_I4_0:
				case Code.Ldc_I4_1:
				case Code.Ldc_I4_2:
				case Code.Ldc_I4_3:
				case Code.Ldc_I4_4:
				case Code.Ldc_I4_5:
				case Code.Ldc_I4_6:
				case Code.Ldc_I4_7:
				case Code.Ldc_I4_8:
				case Code.Ldc_I4_M1:
					stack.Push(new ConstantInfo<int>(index, instr.GetLdcI4Value()));
					break;

				case Code.Add:
					if (stack.Count < 2)
						goto done;
					info2 = stack.Pop();
					info1 = stack.Pop();
					stack.Push(new ConstantInfo<int>(index, info1.constant + info2.constant));
					break;

				case Code.Sub:
					if (stack.Count < 2)
						goto done;
					info2 = stack.Pop();
					info1 = stack.Pop();
					stack.Push(new ConstantInfo<int>(index, info1.constant - info2.constant));
					break;

				case Code.Xor:
					if (stack.Count < 2)
						goto done;
					info2 = stack.Pop();
					info1 = stack.Pop();
					stack.Push(new ConstantInfo<int>(index, info1.constant ^ info2.constant));
					break;

				case Code.Or:
					if (stack.Count < 2)
						goto done;
					info2 = stack.Pop();
					info1 = stack.Pop();
					stack.Push(new ConstantInfo<int>(index, info1.constant | info2.constant));
					break;

				case Code.And:
					if (stack.Count < 2)
						goto done;
					info2 = stack.Pop();
					info1 = stack.Pop();
					stack.Push(new ConstantInfo<int>(index, info1.constant & info2.constant));
					break;

				case Code.Mul:
					if (stack.Count < 2)
						goto done;
					info2 = stack.Pop();
					info1 = stack.Pop();
					stack.Push(new ConstantInfo<int>(index, info1.constant * info2.constant));
					break;

				case Code.Div:
					if (stack.Count < 2)
						goto done;
					info2 = stack.Pop();
					if (info2.constant == 0)
						goto done;
					info1 = stack.Pop();
					stack.Push(new ConstantInfo<int>(index, info1.constant / info2.constant));
					break;

				case Code.Div_Un:
					if (stack.Count < 2)
						goto done;
					info2 = stack.Pop();
					if (info2.constant == 0)
						goto done;
					info1 = stack.Pop();
					stack.Push(new ConstantInfo<int>(index, (int)((uint)info1.constant / (uint)info2.constant)));
					break;

				default:
					goto done;
				}
			}
done:
			if (stack.Count == 0)
				return false;
			while (stack.Count > 1)
				stack.Pop();
			info1 = stack.Pop();
			index = info1.index + 1;
			val = info1.constant;
			return true;
		}

		public bool GetInt64(ref int index, out long val) {
			val = 0;
			if (index >= instructions.Count)
				return false;

			var stack = new Stack<ConstantInfo<long>>();

			long op1;
			ConstantInfo<long> info1, info2;
			for (; index < instructions.Count; index++) {
				if (ProcessInstructionInt64(ref index, stack)) {
					index--;
					continue;
				}
				var instr = instructions[index];
				switch (instr.OpCode.Code) {
				case Code.Conv_I1:
					if (!emulateConvInstrs || stack.Count < 1)
						goto done;
					stack.Push(new ConstantInfo<long>(index, (sbyte)stack.Pop().constant));
					break;

				case Code.Conv_U1:
					if (!emulateConvInstrs || stack.Count < 1)
						goto done;
					stack.Push(new ConstantInfo<long>(index, (byte)stack.Pop().constant));
					break;

				case Code.Conv_I2:
					if (!emulateConvInstrs || stack.Count < 1)
						goto done;
					stack.Push(new ConstantInfo<long>(index, (short)stack.Pop().constant));
					break;

				case Code.Conv_U2:
					if (!emulateConvInstrs || stack.Count < 1)
						goto done;
					stack.Push(new ConstantInfo<long>(index, (ushort)stack.Pop().constant));
					break;

				case Code.Conv_I4:
					if (!emulateConvInstrs || stack.Count < 1)
						goto done;
					stack.Push(new ConstantInfo<long>(index, (int)stack.Pop().constant));
					break;

				case Code.Conv_U4:
					if (!emulateConvInstrs || stack.Count < 1)
						goto done;
					stack.Push(new ConstantInfo<long>(index, (uint)stack.Pop().constant));
					break;

				case Code.Conv_I8:
				case Code.Conv_U8:
					if (!emulateConvInstrs || stack.Count < 1)
						goto done;
					stack.Push(new ConstantInfo<long>(index, stack.Pop().constant));
					break;

				case Code.Not:
					if (stack.Count < 1)
						goto done;
					stack.Push(new ConstantInfo<long>(index, ~stack.Pop().constant));
					break;

				case Code.Neg:
					if (stack.Count < 1)
						goto done;
					stack.Push(new ConstantInfo<long>(index, -stack.Pop().constant));
					break;

				case Code.Ldloc:
				case Code.Ldloc_S:
				case Code.Ldloc_0:
				case Code.Ldloc_1:
				case Code.Ldloc_2:
				case Code.Ldloc_3:
					if (!GetLocalConstantInt64(instr, out op1))
						goto done;
					stack.Push(new ConstantInfo<long>(index, op1));
					break;

				case Code.Ldarg:
				case Code.Ldarg_S:
				case Code.Ldarg_0:
				case Code.Ldarg_1:
				case Code.Ldarg_2:
				case Code.Ldarg_3:
					if (!GetArgConstantInt64(instr, out op1))
						goto done;
					stack.Push(new ConstantInfo<long>(index, op1));
					break;

				case Code.Ldc_I8:
					stack.Push(new ConstantInfo<long>(index, (long)instr.Operand));
					break;

				case Code.Add:
					if (stack.Count < 2)
						goto done;
					info2 = stack.Pop();
					info1 = stack.Pop();
					stack.Push(new ConstantInfo<long>(index, info1.constant + info2.constant));
					break;

				case Code.Sub:
					if (stack.Count < 2)
						goto done;
					info2 = stack.Pop();
					info1 = stack.Pop();
					stack.Push(new ConstantInfo<long>(index, info1.constant - info2.constant));
					break;

				case Code.Xor:
					if (stack.Count < 2)
						goto done;
					info2 = stack.Pop();
					info1 = stack.Pop();
					stack.Push(new ConstantInfo<long>(index, info1.constant ^ info2.constant));
					break;

				case Code.Or:
					if (stack.Count < 2)
						goto done;
					info2 = stack.Pop();
					info1 = stack.Pop();
					stack.Push(new ConstantInfo<long>(index, info1.constant | info2.constant));
					break;

				case Code.And:
					if (stack.Count < 2)
						goto done;
					info2 = stack.Pop();
					info1 = stack.Pop();
					stack.Push(new ConstantInfo<long>(index, info1.constant & info2.constant));
					break;

				case Code.Mul:
					if (stack.Count < 2)
						goto done;
					info2 = stack.Pop();
					info1 = stack.Pop();
					stack.Push(new ConstantInfo<long>(index, info1.constant * info2.constant));
					break;

				case Code.Div:
					if (stack.Count < 2)
						goto done;
					info2 = stack.Pop();
					if (info2.constant == 0)
						goto done;
					info1 = stack.Pop();
					stack.Push(new ConstantInfo<long>(index, info1.constant / info2.constant));
					break;

				case Code.Div_Un:
					if (stack.Count < 2)
						goto done;
					info2 = stack.Pop();
					if (info2.constant == 0)
						goto done;
					info1 = stack.Pop();
					stack.Push(new ConstantInfo<long>(index, (int)((uint)info1.constant / (uint)info2.constant)));
					break;

				default:
					goto done;
				}
			}
done:
			if (stack.Count == 0)
				return false;
			while (stack.Count > 1)
				stack.Pop();
			info1 = stack.Pop();
			index = info1.index + 1;
			val = info1.constant;
			return true;
		}

		public bool GetDouble(ref int index, out double val) {
			val = 0;
			if (index >= instructions.Count)
				return false;

			var stack = new Stack<ConstantInfo<double>>();

			double op1;
			ConstantInfo<double> info1, info2;
			for (; index < instructions.Count; index++) {
				if (ProcessInstructionDouble(ref index, stack)) {
					index--;
					continue;
				}
				var instr = instructions[index];
				switch (instr.OpCode.Code) {
				case Code.Conv_R4:
					if (!emulateConvInstrs || stack.Count < 1)
						goto done;
					stack.Push(new ConstantInfo<double>(index, (float)stack.Pop().constant));
					break;

				case Code.Conv_R8:
					if (!emulateConvInstrs || stack.Count < 1)
						goto done;
					stack.Push(new ConstantInfo<double>(index, stack.Pop().constant));
					break;

				case Code.Neg:
					if (stack.Count < 1)
						goto done;
					stack.Push(new ConstantInfo<double>(index, -stack.Pop().constant));
					break;

				case Code.Ldloc:
				case Code.Ldloc_S:
				case Code.Ldloc_0:
				case Code.Ldloc_1:
				case Code.Ldloc_2:
				case Code.Ldloc_3:
					if (!GetLocalConstantDouble(instr, out op1))
						goto done;
					stack.Push(new ConstantInfo<double>(index, op1));
					break;

				case Code.Ldarg:
				case Code.Ldarg_S:
				case Code.Ldarg_0:
				case Code.Ldarg_1:
				case Code.Ldarg_2:
				case Code.Ldarg_3:
					if (!GetArgConstantDouble(instr, out op1))
						goto done;
					stack.Push(new ConstantInfo<double>(index, op1));
					break;

				case Code.Ldc_R4:
					stack.Push(new ConstantInfo<double>(index, (float)instr.Operand));
					break;

				case Code.Ldc_R8:
					stack.Push(new ConstantInfo<double>(index, (double)instr.Operand));
					break;

				case Code.Add:
					if (stack.Count < 2)
						goto done;
					info2 = stack.Pop();
					info1 = stack.Pop();
					stack.Push(new ConstantInfo<double>(index, info1.constant + info2.constant));
					break;

				case Code.Sub:
					if (stack.Count < 2)
						goto done;
					info2 = stack.Pop();
					info1 = stack.Pop();
					stack.Push(new ConstantInfo<double>(index, info1.constant - info2.constant));
					break;

				case Code.Mul:
					if (stack.Count < 2)
						goto done;
					info2 = stack.Pop();
					info1 = stack.Pop();
					stack.Push(new ConstantInfo<double>(index, info1.constant * info2.constant));
					break;

				case Code.Div:
					if (stack.Count < 2)
						goto done;
					info2 = stack.Pop();
					info1 = stack.Pop();
					stack.Push(new ConstantInfo<double>(index, info1.constant / info2.constant));
					break;

				case Code.Div_Un:
					if (stack.Count < 2)
						goto done;
					info2 = stack.Pop();
					info1 = stack.Pop();
					stack.Push(new ConstantInfo<double>(index, (int)((uint)info1.constant / (uint)info2.constant)));
					break;

				default:
					goto done;
				}
			}
done:
			if (stack.Count == 0)
				return false;
			while (stack.Count > 1)
				stack.Pop();
			info1 = stack.Pop();
			index = info1.index + 1;
			val = info1.constant;
			return true;
		}

		protected virtual bool GetLocalConstantInt32(Instruction instr, out int value) {
			value = 0;
			if (locals == null)
				return false;
			if (!instr.IsLdloc() && !instr.IsStloc())
				return false;
			var local = instr.GetLocal(locals);
			if (local == null)
				return false;
			if (local.Type.ElementType != ElementType.I4 && local.Type.ElementType != ElementType.U4)
				return false;
			return localsValuesInt32.TryGetValue(local, out value);
		}

		protected virtual bool GetArgConstantInt32(Instruction instr, out int value) {
			value = 0;
			return false;
		}

		protected virtual bool GetLocalConstantInt64(Instruction instr, out long value) {
			value = 0;
			if (locals == null)
				return false;
			if (!instr.IsLdloc() && !instr.IsStloc())
				return false;
			var local = instr.GetLocal(locals);
			if (local == null)
				return false;
			if (local.Type.ElementType != ElementType.I8 && local.Type.ElementType != ElementType.U8)
				return false;
			return localsValuesInt64.TryGetValue(local, out value);
		}

		protected virtual bool GetArgConstantInt64(Instruction instr, out long value) {
			value = 0;
			return false;
		}

		protected virtual bool GetLocalConstantDouble(Instruction instr, out double value) {
			value = 0;
			if (locals == null)
				return false;
			if (!instr.IsLdloc() && !instr.IsStloc())
				return false;
			var local = instr.GetLocal(locals);
			if (local == null)
				return false;
			if (local.Type.ElementType != ElementType.R8)
				return false;
			return localsValuesDouble.TryGetValue(local, out value);
		}

		protected virtual bool GetArgConstantDouble(Instruction instr, out double value) {
			value = 0;
			return false;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/DeobUtils.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Security.Cryptography;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using ICSharpCode.SharpZipLib.Zip.Compression;
using de4dot.blocks;

namespace de4dot.code.deobfuscators {
	public static class DeobUtils {
		public static void DecryptAndAddResources(ModuleDef module, string encryptedName, Func<byte[]> decryptResource) {
			Logger.v("Decrypting resources, name: {0}", Utils.ToCsharpString(encryptedName));
			var decryptedResourceData = decryptResource();
			if (decryptedResourceData == null)
				throw new ApplicationException("decryptedResourceData is null");
			var resourceModule = ModuleDefMD.Load(decryptedResourceData);

			Logger.Instance.Indent();
			foreach (var rsrc in resourceModule.Resources) {
				Logger.v("Adding decrypted resource {0}", Utils.ToCsharpString(rsrc.Name));
				module.Resources.Add(rsrc);
			}
			Logger.Instance.DeIndent();
		}

		public static T Lookup<T>(ModuleDefMD module, T def, string errorMessage) where T : class, ICodedToken {
			if (def == null)
				return null;
			var newDef = module.ResolveToken(def.MDToken.Raw) as T;
			if (newDef == null)
				throw new ApplicationException(errorMessage);
			return newDef;
		}

		public static byte[] ReadModule(ModuleDef module) => Utils.ReadFile(module.Location);

		public static bool IsCode(short[] nativeCode, byte[] code) {
			if (nativeCode.Length != code.Length)
				return false;
			for (int i = 0; i < nativeCode.Length; i++) {
				if (nativeCode[i] == -1)
					continue;
				if ((byte)nativeCode[i] != code[i])
					return false;
			}
			return true;
		}

		public static byte[] Md5Sum(byte[] data) => MD5.Create().ComputeHash(data);
		public static byte[] Sha1Sum(byte[] data) => SHA1.Create().ComputeHash(data);
		public static byte[] Sha256Sum(byte[] data) => SHA256.Create().ComputeHash(data);

		public static byte[] AesDecrypt(byte[] data, byte[] key, byte[] iv) {
			using (var aes = new RijndaelManaged { Mode = CipherMode.CBC }) {
				using (var transform = aes.CreateDecryptor(key, iv)) {
					return transform.TransformFinalBlock(data, 0, data.Length);
				}
			}
		}

		public static byte[] Des3Decrypt(byte[] data, byte[] key, byte[] iv) {
			using (var des3 = TripleDES.Create()) {
				using (var transform = des3.CreateDecryptor(key, iv)) {
					return transform.TransformFinalBlock(data, 0, data.Length);
				}
			}
		}

		public static byte[] DesDecrypt(byte[] data, int start, int len, byte[] key, byte[] iv) {
			using (var des = new DESCryptoServiceProvider()) {
				using (var transform = des.CreateDecryptor(key, iv)) {
					return transform.TransformFinalBlock(data, start, len);
				}
			}
		}

		// Code converted from C implementation @ http://en.wikipedia.org/wiki/XXTEA (btea() func)
		public static void XxteaDecrypt(uint[] v, uint[] key) {
			const uint DELTA = 0x9E3779B9;
			int n = v.Length;
			uint rounds = (uint)(6 + 52 / n);
			uint sum = rounds * DELTA;
			uint y = v[0];
			uint z;
			//#define MX (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key[(p & 3) ^ e] ^ z)))
			do {
				int e = (int)((sum >> 2) & 3);
				int p;
				for (p = n - 1; p > 0; p--) {
					z = v[p - 1];
					y = v[p] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key[(p & 3) ^ e] ^ z)));
				}
				z = v[n - 1];
				y = v[0] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key[(p & 3) ^ e] ^ z)));
			} while ((sum -= DELTA) != 0);
		}

		// Code converted from C implementation @ http://en.wikipedia.org/wiki/XTEA (decipher() func)
		public static void XteaDecrypt(ref uint v0, ref uint v1, uint[] key, int rounds) {
			const uint delta = 0x9E3779B9;
			uint sum = (uint)(delta * rounds);
			for (int i = 0; i < rounds; i++) {
				v1 -= (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum + key[(sum >> 11) & 3]);
				sum -= delta;
				v0 -= (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + key[sum & 3]);
			}
		}

		public static string GetExtension(ModuleKind kind) {
			switch (kind) {
			case ModuleKind.Dll:
				return ".dll";
			case ModuleKind.NetModule:
				return ".netmodule";
			case ModuleKind.Console:
			case ModuleKind.Windows:
			default:
				return ".exe";
			}
		}

		public static byte[] Inflate(byte[] data, bool noHeader) =>
			Inflate(data, 0, data.Length, noHeader);

		public static byte[] Inflate(byte[] data, int start, int len, bool noHeader) =>
			Inflate(data, start, len, new Inflater(noHeader));

		public static byte[] Inflate(byte[] data, Inflater inflater) =>
			Inflate(data, 0, data.Length, inflater);

		public static byte[] Inflate(byte[] data, int start, int len, Inflater inflater) {
			var buffer = new byte[0x1000];
			var memStream = new MemoryStream();
			inflater.SetInput(data, start, len);
			while (true) {
				int count = inflater.Inflate(buffer, 0, buffer.Length);
				if (count == 0)
					break;
				memStream.Write(buffer, 0, count);
			}
			return memStream.ToArray();
		}

		public static byte[] Gunzip(Stream input, int decompressedSize) {
			using (var gzip = new GZipStream(input, CompressionMode.Decompress)) {
				var decompressed = new byte[decompressedSize];
				if (gzip.Read(decompressed, 0, decompressedSize) != decompressedSize)
					throw new ApplicationException("Could not gzip decompress");
				return decompressed;
			}
		}

		public static EmbeddedResource GetEmbeddedResourceFromCodeStrings(ModuleDef module, MethodDef method) {
			foreach (var s in DotNetUtils.GetCodeStrings(method)) {
				if (DotNetUtils.GetResource(module, s) is EmbeddedResource resource)
					return resource;
			}
			return null;
		}

		public static int ReadVariableLengthInt32(byte[] data, ref int index) {
			byte b = data[index++];
			if ((b & 0x80) == 0)
				return b;
			if ((b & 0x40) == 0)
				return (((int)b & 0x3F) << 8) + data[index++];
			return (((int)b & 0x1F) << 24) +
					((int)data[index++] << 16) +
					((int)data[index++] << 8) +
					data[index++];
		}

		public static bool HasInteger(MethodDef method, uint value) => HasInteger(method, (int)value);
		public static bool HasInteger(MethodDef method, int value) => IndexOfLdci4Instruction(method, value) >= 0;

		public static int IndexOfLdci4Instruction(MethodDef method, int value) {
			if (method == null || method.Body == null)
				return -1;
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count; i++) {
				var instr = instrs[i];
				if (!instr.IsLdcI4())
					continue;
				if (instr.GetLdcI4Value() == value)
					return i;
			}
			return -1;
		}

		public static IEnumerable<MethodDef> GetInitCctors(ModuleDef module, int maxCctors) {
			var cctor = DotNetUtils.GetModuleTypeCctor(module);
			if (cctor != null)
				yield return cctor;

			var entryPoint = module.EntryPoint;
			if (entryPoint != null) {
				cctor = entryPoint.DeclaringType.FindStaticConstructor();
				if (cctor != null)
					yield return cctor;
			}

			foreach (var type in module.GetTypes()) {
				if (type == module.GlobalType)
					continue;
				cctor = type.FindStaticConstructor();
				if (cctor == null)
					continue;
				yield return cctor;
				if (!type.IsEnum && --maxCctors <= 0)
					break;
			}
		}

		public static List<MethodDef> GetAllResolveHandlers(MethodDef method) {
			var list = new List<MethodDef>();
			if (method == null || method.Body == null)
				return list;
			foreach (var instr in method.Body.Instructions) {
				if (instr.OpCode.Code != Code.Ldftn && instr.OpCode.Code != Code.Ldvirtftn)
					continue;
				var handler = instr.Operand as MethodDef;
				if (handler == null)
					continue;
				if (!DotNetUtils.IsMethod(handler, "System.Reflection.Assembly", "(System.Object,System.ResolveEventArgs)"))
					continue;
				list.Add(handler);
			}
			return list;
		}

		public static MethodDef GetResolveMethod(MethodDef method) {
			var handlers = DeobUtils.GetAllResolveHandlers(method);
			if (handlers.Count == 0)
				return null;
			return handlers[0];
		}
	}
}



================================================
File: de4dot.code/deobfuscators/DeobfuscatorBase.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using dnlib.DotNet.Writer;
using dnlib.PE;
using de4dot.blocks;
using de4dot.blocks.cflow;

namespace de4dot.code.deobfuscators {
	public abstract class DeobfuscatorBase : IDeobfuscator, IModuleWriterListener {
		public const string DEFAULT_VALID_NAME_REGEX = @"^[a-zA-Z_<{$][a-zA-Z_0-9<>{}$.`-]*$";
		public const string DEFAULT_ASIAN_VALID_NAME_REGEX = @"^[\u2E80-\u9FFFa-zA-Z_<{$][\u2E80-\u9FFFa-zA-Z_0-9<>{}$.`-]*$";

		class RemoveInfo<T> {
			public T obj;
			public string reason;
			public RemoveInfo(T obj, string reason) {
				this.obj = obj;
				this.reason = reason;
			}
		}

		OptionsBase optionsBase;
		protected ModuleDefMD module;
		protected StaticStringInliner staticStringInliner = new StaticStringInliner();
		IList<RemoveInfo<TypeDef>> typesToRemove = new List<RemoveInfo<TypeDef>>();
		IList<RemoveInfo<MethodDef>> methodsToRemove = new List<RemoveInfo<MethodDef>>();
		IList<RemoveInfo<FieldDef>> fieldsToRemove = new List<RemoveInfo<FieldDef>>();
		IList<RemoveInfo<TypeDef>> attrsToRemove = new List<RemoveInfo<TypeDef>>();
		IList<RemoveInfo<Resource>> resourcesToRemove = new List<RemoveInfo<Resource>>();
		List<string> namesToPossiblyRemove = new List<string>();
		MethodCallRemover methodCallRemover = new MethodCallRemover();
		byte[] moduleBytes;
		protected InitializedDataCreator initializedDataCreator;
		bool keepTypes;
		MetadataFlags? mdFlags;
		Dictionary<object, bool> objectsThatMustBeKept = new Dictionary<object, bool>();

		protected byte[] ModuleBytes {
			get => moduleBytes;
			set => moduleBytes = value;
		}

		public class OptionsBase : IDeobfuscatorOptions {
			public bool RenameResourcesInCode { get; set; }
			public NameRegexes ValidNameRegex { get; set; }
			public bool DecryptStrings { get; set; }
			public OptionsBase() => RenameResourcesInCode = true;
		}

		public IDeobfuscatorOptions TheOptions => optionsBase;
		public IOperations Operations { get; set; }
		public IDeobfuscatedFile DeobfuscatedFile { get; set; }
		public virtual StringFeatures StringFeatures { get; set; }
		public virtual RenamingOptions RenamingOptions { get; set; }
		public DecrypterType DefaultDecrypterType { get; set; }
		public virtual MetadataFlags MetadataFlags => mdFlags ?? Operations.MetadataFlags;
		public abstract string Type { get; }
		public abstract string TypeLong { get; }
		public abstract string Name { get; }
		protected virtual bool CanInlineMethods => false;

		protected bool KeepTypes {
			get => keepTypes;
			set => keepTypes = value;
		}

		protected bool CanRemoveTypes => !Operations.KeepObfuscatorTypes && !KeepTypes;
		protected bool CanRemoveStringDecrypterType => Operations.DecryptStrings != OpDecryptString.None && staticStringInliner.InlinedAllCalls;

		public virtual IEnumerable<IBlocksDeobfuscator> BlocksDeobfuscators {
			get {
				var list = new List<IBlocksDeobfuscator>();
				if (CanInlineMethods)
					list.Add(new MethodCallInliner(false));
				return list;
			}
		}

		public DeobfuscatorBase(OptionsBase optionsBase) {
			this.optionsBase = optionsBase;
			StringFeatures = StringFeatures.AllowAll;
			DefaultDecrypterType = DecrypterType.Static;
		}

		public virtual byte[] UnpackNativeFile(IPEImage peImage) => null;
		public virtual void Initialize(ModuleDefMD module) => SetModule(module);

		protected void SetModule(ModuleDefMD module) {
			this.module = module;
			initializedDataCreator = new InitializedDataCreator(module);
		}

		protected void PreserveTokensAndTypes() {
			keepTypes = true;
			mdFlags = Operations.MetadataFlags;
			mdFlags |= MetadataFlags.PreserveRids |
						MetadataFlags.PreserveUSOffsets |
						MetadataFlags.PreserveBlobOffsets |
						MetadataFlags.PreserveExtraSignatureData;
		}

		protected virtual bool CheckValidName(string name) => optionsBase.ValidNameRegex.IsMatch(name);

		public virtual int Detect() {
			ScanForObfuscator();
			return DetectInternal();
		}

		protected abstract void ScanForObfuscator();
		protected abstract int DetectInternal();

		public virtual bool GetDecryptedModule(int count, ref byte[] newFileData, ref DumpedMethods dumpedMethods) => false;

		public virtual IDeobfuscator ModuleReloaded(ModuleDefMD module) =>
			throw new ApplicationException("moduleReloaded() must be overridden by the deobfuscator");

		public virtual void DeobfuscateBegin() => ModuleBytes = null;
		public virtual void DeobfuscateMethodBegin(Blocks blocks) { }
		public virtual void DeobfuscateMethodEnd(Blocks blocks) => RemoveMethodCalls(blocks);
		public virtual void DeobfuscateStrings(Blocks blocks) => staticStringInliner.Decrypt(blocks);
		public virtual bool DeobfuscateOther(Blocks blocks) => false;

		public virtual void DeobfuscateEnd() {
			// Make sure the TypeDefCache isn't enabled while we modify types or remove stuff
			bool cacheState = module.EnableTypeDefFindCache;
			module.EnableTypeDefFindCache = false;

			if (CanRemoveTypes) {
				InitializeObjectsToKeepFromVTableFixups();

				RemoveTypesWithInvalidBaseTypes();

				DeleteEmptyCctors();
				DeleteMethods();
				DeleteFields();
				DeleteCustomAttributes();
				DeleteOtherAttributes();
				DeleteTypes();
				DeleteDllResources();
			}

			RestoreBaseType();
			FixMDHeaderVersion();

			module.Mvid = Guid.NewGuid();
			module.EnableTypeDefFindCache = cacheState;
		}

		void InitializeObjectsToKeepFromVTableFixups() {
			var fixups = module.VTableFixups;
			if (fixups == null || fixups.VTables.Count == 0)
				return;

			foreach (var vtable in fixups) {
				if (vtable == null)
					continue;
				foreach (var method in vtable) {
					if (method == null)
						continue;
					objectsThatMustBeKept[method] = true;
				}
			}
		}

		bool MustKeepObject(object o) => o != null && objectsThatMustBeKept.ContainsKey(o);

		static bool IsTypeWithInvalidBaseType(TypeDef moduleType, TypeDef type) =>
			type.BaseType == null && !type.IsInterface && type != moduleType;

		void RestoreBaseType() {
			var moduleType = DotNetUtils.GetModuleType(module);
			foreach (var type in module.GetTypes()) {
				if (!IsTypeWithInvalidBaseType(moduleType, type))
					continue;
				var corSig = module.CorLibTypes.GetCorLibTypeSig(type);
				if (corSig != null && corSig.ElementType == ElementType.Object)
					continue;
				Logger.v("Adding System.Object as base type: {0} ({1:X8})",
							Utils.RemoveNewlines(type),
							type.MDToken.ToInt32());
				type.BaseType = module.CorLibTypes.Object.TypeDefOrRef;
			}
		}

		void FixMDHeaderVersion() {
			// Version 1.1 supports generics but it's a little different. Most tools
			// will have a problem reading the MD tables, so switch to the standard v2.0.
			if (module.TablesHeaderVersion == 0x0101)
				module.TablesHeaderVersion = 0x0200;
		}

		void RemoveTypesWithInvalidBaseTypes() {
			var moduleType = DotNetUtils.GetModuleType(module);
			foreach (var type in module.GetTypes()) {
				if (!IsTypeWithInvalidBaseType(moduleType, type) || MustKeepObject(type))
					continue;
				AddTypeToBeRemoved(type, "Invalid type with no base type (anti-reflection)");
			}
		}

		protected void FixEnumTypes() {
			foreach (var type in module.GetTypes()) {
				if (!type.IsEnum)
					continue;
				foreach (var field in type.Fields) {
					if (field.IsStatic)
						continue;
					field.IsRuntimeSpecialName = true;
					field.IsSpecialName = true;
				}
			}
		}

		protected void FixInterfaces() {
			foreach (var type in module.GetTypes()) {
				if (!type.IsInterface)
					continue;
				type.IsSealed = false;
			}
		}

		public abstract IEnumerable<int> GetStringDecrypterMethods();

		class MethodCallRemover {
			Dictionary<string, MethodDefAndDeclaringTypeDict<bool>> methodNameInfos = new Dictionary<string, MethodDefAndDeclaringTypeDict<bool>>();
			MethodDefAndDeclaringTypeDict<MethodDefAndDeclaringTypeDict<bool>> methodRefInfos = new MethodDefAndDeclaringTypeDict<MethodDefAndDeclaringTypeDict<bool>>();

			void CheckMethod(IMethod methodToBeRemoved) {
				var sig = methodToBeRemoved.MethodSig;
				if (sig.Params.Count != 0)
					throw new ApplicationException($"Method takes params: {methodToBeRemoved}");
				if (sig.RetType.ElementType != ElementType.Void)
					throw new ApplicationException($"Method has a return value: {methodToBeRemoved}");
			}

			public void Add(string method, MethodDef methodToBeRemoved) {
				if (methodToBeRemoved == null)
					return;
				CheckMethod(methodToBeRemoved);

				if (!methodNameInfos.TryGetValue(method, out var dict))
					methodNameInfos[method] = dict = new MethodDefAndDeclaringTypeDict<bool>();
				dict.Add(methodToBeRemoved, true);
			}

			public void Add(MethodDef method, MethodDef methodToBeRemoved) {
				if (method == null || methodToBeRemoved == null)
					return;
				CheckMethod(methodToBeRemoved);

				var dict = methodRefInfos.Find(method);
				if (dict == null)
					methodRefInfos.Add(method, dict = new MethodDefAndDeclaringTypeDict<bool>());
				dict.Add(methodToBeRemoved, true);
			}

			public void RemoveAll(Blocks blocks) {
				var allBlocks = blocks.MethodBlocks.GetAllBlocks();

				RemoveAll(allBlocks, blocks, blocks.Method.Name.String);
				RemoveAll(allBlocks, blocks, blocks.Method);
			}

			void RemoveAll(IList<Block> allBlocks, Blocks blocks, string method) {
				if (!methodNameInfos.TryGetValue(method, out var info))
					return;

				RemoveCalls(allBlocks, blocks, info);
			}

			void RemoveAll(IList<Block> allBlocks, Blocks blocks, MethodDef method) {
				var info = methodRefInfos.Find(method);
				if (info == null)
					return;

				RemoveCalls(allBlocks, blocks, info);
			}

			void RemoveCalls(IList<Block> allBlocks, Blocks blocks, MethodDefAndDeclaringTypeDict<bool> info) {
				var instrsToDelete = new List<int>();
				foreach (var block in allBlocks) {
					instrsToDelete.Clear();
					for (int i = 0; i < block.Instructions.Count; i++) {
						var instr = block.Instructions[i];
						if (instr.OpCode != OpCodes.Call)
							continue;
						var destMethod = instr.Operand as IMethod;
						if (destMethod == null)
							continue;

						if (info.Find(destMethod)) {
							Logger.v("Removed call to {0}", Utils.RemoveNewlines(destMethod));
							instrsToDelete.Add(i);
						}
					}
					block.Remove(instrsToDelete);
				}
			}
		}

		public void AddCctorInitCallToBeRemoved(MethodDef methodToBeRemoved) =>
			methodCallRemover.Add(".cctor", methodToBeRemoved);

		public void AddModuleCctorInitCallToBeRemoved(MethodDef methodToBeRemoved) =>
			methodCallRemover.Add(DotNetUtils.GetModuleTypeCctor(module), methodToBeRemoved);

		public void AddCtorInitCallToBeRemoved(MethodDef methodToBeRemoved) =>
			methodCallRemover.Add(".ctor", methodToBeRemoved);

		public void AddCallToBeRemoved(MethodDef method, MethodDef methodToBeRemoved) =>
			methodCallRemover.Add(method, methodToBeRemoved);

		void RemoveMethodCalls(Blocks blocks) =>
			methodCallRemover.RemoveAll(blocks);

		protected void AddMethodsToBeRemoved(IEnumerable<MethodDef> methods, string reason) {
			foreach (var method in methods)
				AddMethodToBeRemoved(method, reason);
		}

		protected void AddMethodToBeRemoved(MethodDef method, string reason) {
			if (method != null)
				methodsToRemove.Add(new RemoveInfo<MethodDef>(method, reason));
		}

		protected void AddFieldsToBeRemoved(IEnumerable<FieldDef> fields, string reason) {
			foreach (var field in fields)
				AddFieldToBeRemoved(field, reason);
		}

		protected void AddFieldToBeRemoved(FieldDef field, string reason) {
			if (field != null)
				fieldsToRemove.Add(new RemoveInfo<FieldDef>(field, reason));
		}

		protected void AddAttributesToBeRemoved(IEnumerable<TypeDef> attrs, string reason) {
			foreach (var attr in attrs)
				AddAttributeToBeRemoved(attr, reason);
		}

		protected void AddAttributeToBeRemoved(TypeDef attr, string reason) {
			if (attr == null)
				return;
			AddTypeToBeRemoved(attr, reason);
			attrsToRemove.Add(new RemoveInfo<TypeDef>(attr, reason));
		}

		protected void AddTypesToBeRemoved(IEnumerable<TypeDef> types, string reason) {
			foreach (var type in types)
				AddTypeToBeRemoved(type, reason);
		}

		protected void AddTypeToBeRemoved(TypeDef type, string reason) {
			if (type != null)
				typesToRemove.Add(new RemoveInfo<TypeDef>(type, reason));
		}

		protected void AddResourceToBeRemoved(Resource resource, string reason) {
			if (resource != null)
				resourcesToRemove.Add(new RemoveInfo<Resource>(resource, reason));
		}

		void DeleteEmptyCctors() {
			var emptyCctorsToRemove = new List<MethodDef>();
			foreach (var type in module.GetTypes()) {
				var cctor = type.FindStaticConstructor();
				if (cctor != null && DotNetUtils.IsEmpty(cctor) && !MustKeepObject(cctor))
					emptyCctorsToRemove.Add(cctor);
			}

			if (emptyCctorsToRemove.Count == 0)
				return;

			Logger.v("Removing empty .cctor methods");
			Logger.Instance.Indent();
			foreach (var cctor in emptyCctorsToRemove) {
				var type = cctor.DeclaringType;
				if (type == null)
					continue;
				if (type.Methods.Remove(cctor))
					Logger.v("{0:X8}, type: {1} ({2:X8})",
								cctor.MDToken.ToUInt32(),
								Utils.RemoveNewlines(type),
								type.MDToken.ToUInt32());
			}
			Logger.Instance.DeIndent();
		}

		void DeleteMethods() {
			if (methodsToRemove.Count == 0)
				return;

			Logger.v("Removing methods");
			Logger.Instance.Indent();
			foreach (var info in methodsToRemove) {
				var method = info.obj;
				if (method == null || MustKeepObject(method))
					continue;
				var type = method.DeclaringType;
				if (type == null)
					continue;
				if (type.Methods.Remove(method))
					Logger.v("Removed method {0} ({1:X8}) (Type: {2}) (reason: {3})",
								Utils.RemoveNewlines(method),
								method.MDToken.ToUInt32(),
								Utils.RemoveNewlines(type),
								info.reason);
			}
			Logger.Instance.DeIndent();
		}

		void DeleteFields() {
			if (fieldsToRemove.Count == 0)
				return;

			Logger.v("Removing fields");
			Logger.Instance.Indent();
			foreach (var info in fieldsToRemove) {
				var field = info.obj;
				if (field == null || MustKeepObject(field))
					continue;
				var type = field.DeclaringType;
				if (type == null)
					continue;
				if (type.Fields.Remove(field))
					Logger.v("Removed field {0} ({1:X8}) (Type: {2}) (reason: {3})",
								Utils.RemoveNewlines(field),
								field.MDToken.ToUInt32(),
								Utils.RemoveNewlines(type),
								info.reason);
			}
			Logger.Instance.DeIndent();
		}

		void DeleteTypes() {
			var types = module.Types;
			if (types == null || typesToRemove.Count == 0)
				return;

			Logger.v("Removing types");
			Logger.Instance.Indent();
			var moduleType = DotNetUtils.GetModuleType(module);
			foreach (var info in typesToRemove) {
				var typeDef = info.obj;
				if (typeDef == null || typeDef == moduleType || MustKeepObject(typeDef))
					continue;
				bool removed;
				if (typeDef.DeclaringType != null)
					removed = typeDef.DeclaringType.NestedTypes.Remove(typeDef);
				else
					removed = types.Remove(typeDef);
				if (removed)
					Logger.v("Removed type {0} ({1:X8}) (reason: {2})",
								Utils.RemoveNewlines(typeDef),
								typeDef.MDToken.ToUInt32(),
								info.reason);
			}
			Logger.Instance.DeIndent();
		}

		void DeleteCustomAttributes() {
			if (attrsToRemove.Count == 0)
				return;

			Logger.v("Removing custom attributes");
			Logger.Instance.Indent();
			DeleteCustomAttributes(module.CustomAttributes);
			if (module.Assembly != null)
				DeleteCustomAttributes(module.Assembly.CustomAttributes);
			Logger.Instance.DeIndent();
		}

		void DeleteCustomAttributes(IList<CustomAttribute> customAttrs) {
			if (customAttrs == null)
				return;
			foreach (var info in attrsToRemove) {
				var typeDef = info.obj;
				if (typeDef == null)
					continue;
				for (int i = 0; i < customAttrs.Count; i++) {
					if (new SigComparer().Equals(typeDef, customAttrs[i].AttributeType)) {
						customAttrs.RemoveAt(i);
						i--;
						Logger.v("Removed custom attribute {0} ({1:X8}) (reason: {2})",
									Utils.RemoveNewlines(typeDef),
									typeDef.MDToken.ToUInt32(),
									info.reason);
						break;
					}
				}
			}
		}

		void DeleteOtherAttributes() {
			Logger.v("Removing other attributes");
			Logger.Instance.Indent();
			DeleteOtherAttributes(module.CustomAttributes);
			if (module.Assembly != null)
				DeleteOtherAttributes(module.Assembly.CustomAttributes);
			Logger.Instance.DeIndent();
		}

		void DeleteOtherAttributes(IList<CustomAttribute> customAttributes) {
			for (int i = customAttributes.Count - 1; i >= 0; i--) {
				var attr = customAttributes[i].TypeFullName;
				if (attr == "System.Runtime.CompilerServices.SuppressIldasmAttribute") {
					Logger.v("Removed attribute {0}", Utils.RemoveNewlines(attr));
					customAttributes.RemoveAt(i);
				}
			}
		}

		void DeleteDllResources() {
			if (!module.HasResources || resourcesToRemove.Count == 0)
				return;

			Logger.v("Removing resources");
			Logger.Instance.Indent();
			foreach (var info in resourcesToRemove) {
				var resource = info.obj;
				if (resource == null || MustKeepObject(resource))
					continue;
				if (module.Resources.Remove(resource))
					Logger.v("Removed resource {0} (reason: {1})", Utils.ToCsharpString(resource.Name), info.reason);
			}
			Logger.Instance.DeIndent();
		}

		protected void SetInitLocals() {
			foreach (var type in module.GetTypes()) {
				foreach (var method in type.Methods) {
					if (IsFatHeader(method))
						method.Body.InitLocals = true;
				}
			}
		}

		static bool IsFatHeader(MethodDef method) {
			if (method == null || method.Body == null)
				return false;
			var body = method.Body;
			if (body.InitLocals || body.MaxStack > 8)
				return true;
			if (body.Variables.Count > 0)
				return true;
			if (body.ExceptionHandlers.Count > 0)
				return true;
			if (GetCodeSize(method) > 63)
				return true;

			return false;
		}

		static int GetCodeSize(MethodDef method) {
			if (method == null || method.Body == null)
				return 0;
			int size = 0;
			foreach (var instr in method.Body.Instructions)
				size += instr.GetSize();
			return size;
		}

		public override string ToString() => Name;

		protected void FindPossibleNamesToRemove(MethodDef method) {
			if (method == null || !method.HasBody)
				return;

			foreach (var instr in method.Body.Instructions) {
				if (instr.OpCode == OpCodes.Ldstr)
					namesToPossiblyRemove.Add((string)instr.Operand);
			}
		}

		protected void AddResources(string reason) {
			if (!module.HasResources)
				return;

			foreach (var name in namesToPossiblyRemove) {
				foreach (var resource in module.Resources) {
					if (resource.Name == name) {
						AddResourceToBeRemoved(resource, reason);
						break;
					}
				}
			}
		}

		protected bool RemoveProxyDelegates(ProxyCallFixerBase proxyCallFixer) =>
			RemoveProxyDelegates(proxyCallFixer, true);

		protected bool RemoveProxyDelegates(ProxyCallFixerBase proxyCallFixer, bool removeCreators) {
			if (proxyCallFixer.Errors != 0) {
				Logger.v("Not removing proxy delegates and creator type since errors were detected.");
				return false;
			}
			AddTypesToBeRemoved(proxyCallFixer.DelegateTypes, "Proxy delegate type");
			if (removeCreators && proxyCallFixer.RemovedDelegateCreatorCalls > 0) {
				AddTypesToBeRemoved(proxyCallFixer.DelegateCreatorTypes, "Proxy delegate creator type");
				foreach (var tuple in proxyCallFixer.OtherMethods)
					AddMethodToBeRemoved(tuple.Item1, tuple.Item2);
			}
			return true;
		}

		protected Resource GetResource(IEnumerable<string> strings) => DotNetUtils.GetResource(module, strings);

		protected CustomAttribute GetAssemblyAttribute(IType attr) {
			if (module.Assembly == null)
				return null;
			return module.Assembly.CustomAttributes.Find(attr);
		}

		protected CustomAttribute GetModuleAttribute(IType attr) => module.CustomAttributes.Find(attr);

		protected bool HasMetadataStream(string name) {
			foreach (var stream in module.Metadata.AllStreams) {
				if (stream.Name == name)
					return true;
			}
			return false;
		}

		List<T> GetObjectsToRemove<T>(IList<RemoveInfo<T>> removeThese) where T : class, ICodedToken {
			var list = new List<T>(removeThese.Count);
			foreach (var info in removeThese) {
				if (info.obj != null)
					list.Add(info.obj);
			}
			return list;
		}

		protected List<TypeDef> GetTypesToRemove() => GetObjectsToRemove(typesToRemove);
		protected List<MethodDef> GetMethodsToRemove() => GetObjectsToRemove(methodsToRemove);

		public virtual bool IsValidNamespaceName(string ns) {
			if (ns == null)
				return false;
			foreach (var part in ns.Split(new char[] { '.' })) {
				if (!CheckValidName(part))
					return false;
			}
			return true;
		}

		public virtual bool IsValidTypeName(string name) => name != null && CheckValidName(name);
		public virtual bool IsValidMethodName(string name) => name != null && CheckValidName(name);
		public virtual bool IsValidPropertyName(string name) => name != null && CheckValidName(name);
		public virtual bool IsValidEventName(string name) => name != null && CheckValidName(name);
		public virtual bool IsValidFieldName(string name) => name != null && CheckValidName(name);
		public virtual bool IsValidGenericParamName(string name) => name != null && CheckValidName(name);
		public virtual bool IsValidMethodArgName(string name) => name != null && CheckValidName(name);
		public virtual bool IsValidMethodReturnArgName(string name) => string.IsNullOrEmpty(name) || CheckValidName(name);
		public virtual bool IsValidResourceKeyName(string name) => name != null && CheckValidName(name);
		public virtual void OnWriterEvent(ModuleWriterBase writer, ModuleWriterEvent evt) { }
		protected void FindAndRemoveInlinedMethods() => RemoveInlinedMethods(InlinedMethodsFinder.Find(module));
		protected void RemoveInlinedMethods(List<MethodDef> inlinedMethods) =>
			AddMethodsToBeRemoved(new UnusedMethodsFinder(module, inlinedMethods, GetRemovedMethods()).Find(), "Inlined method");

		protected MethodCollection GetRemovedMethods() {
			var removedMethods = new MethodCollection();
			removedMethods.Add(GetMethodsToRemove());
			removedMethods.AddAndNested(GetTypesToRemove());
			return removedMethods;
		}

		protected bool IsTypeCalled(TypeDef decrypterType) {
			if (decrypterType == null)
				return false;

			var decrypterMethods = new MethodCollection();
			decrypterMethods.AddAndNested(decrypterType);

			var removedMethods = GetRemovedMethods();

			foreach (var type in module.GetTypes()) {
				foreach (var method in type.Methods) {
					if (method.Body == null)
						continue;
					if (decrypterMethods.Exists(method))
						break;	// decrypter type / nested type method
					if (removedMethods.Exists(method))
						continue;

					foreach (var instr in method.Body.Instructions) {
						switch (instr.OpCode.Code) {
						case Code.Call:
						case Code.Callvirt:
						case Code.Newobj:
							var calledMethod = instr.Operand as IMethod;
							if (calledMethod == null)
								break;
							if (decrypterMethods.Exists(calledMethod))
								return true;
							break;

						default:
							break;
						}
					}
				}
			}

			return false;
		}

		protected bool HasNativeMethods() {
			if (module.VTableFixups != null)
				return true;
			foreach (var type in module.GetTypes()) {
				foreach (var method in type.Methods) {
					var mb = method.MethodBody;
					if (mb == null)
						continue;
					if (mb is CilBody)
						continue;
					return true;
				}
			}
			return false;
		}

		protected static int ToInt32(bool b) => b ? 1 : 0;

		public void Dispose() {
			Dispose(true);
			GC.SuppressFinalize(this);
		}

		protected virtual void Dispose(bool disposing) { }
	}
}



================================================
File: de4dot.code/deobfuscators/DeobfuscatorInfoBase.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;

namespace de4dot.code.deobfuscators {
	public abstract class DeobfuscatorInfoBase : IDeobfuscatorInfo {
		protected NameRegexOption validNameRegex;

		public DeobfuscatorInfoBase(string nameRegex) =>
			validNameRegex = new NameRegexOption(null, MakeArgName("name"), "Valid name regex pattern", nameRegex ?? DeobfuscatorBase.DEFAULT_VALID_NAME_REGEX);

		protected string MakeArgName(string name) => $"{Type}-{name}";

		public abstract string Type { get; }
		public abstract string Name { get; }
		public abstract IDeobfuscator CreateDeobfuscator();
		protected virtual IEnumerable<Option> GetOptionsInternal() => new List<Option>();

		public IEnumerable<Option> GetOptions() {
			var options = new List<Option>();
			options.Add(validNameRegex);
			options.AddRange(GetOptionsInternal());
			return options;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/ExceptionLoggerRemover.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators {
	public class ExceptionLoggerRemover {
		MethodDefAndDeclaringTypeDict<bool> exceptionLoggerMethods = new MethodDefAndDeclaringTypeDict<bool>();

		public int NumRemovedExceptionLoggers { get; set; }

		public void Add(MethodDef exceptionLogger) => exceptionLoggerMethods.Add(exceptionLogger, true);

		bool Find(Blocks blocks, out TryBlock tryBlock) {
			tryBlock = null;

			foreach (var bb in blocks.MethodBlocks.BaseBlocks) {
				tryBlock = bb as TryBlock;
				if (tryBlock == null)
					continue;
				if (tryBlock.TryHandlerBlocks.Count != 1)
					continue;
				var catchBlock = tryBlock.TryHandlerBlocks[0];
				if (catchBlock.HandlerType != ExceptionHandlerType.Catch ||
					catchBlock.CatchType.FullName != "System.Exception") {
					continue;
				}
				if (catchBlock.BaseBlocks.Count != 1)
					continue;
				var handlerBlock = catchBlock.BaseBlocks[0] as HandlerBlock;
				if (handlerBlock == null)
					continue;

				int calls = 0;
				Instr callInstr = null;
				bool failed = false;
				foreach (var bb2 in handlerBlock.BaseBlocks) {
					var block = bb2 as Block;
					if (block == null) {
						failed = true;
						break;
					}
					foreach (var instr in block.Instructions) {
						switch (instr.OpCode.Code) {
						case Code.Call:
						case Code.Calli:
						case Code.Callvirt:
							calls++;
							callInstr = instr;
							break;
						}
					}
				}
				if (failed || calls != 1 || callInstr.OpCode.Code != Code.Call)
					continue;
				var calledMethod = callInstr.Operand as IMethod;
				if (calledMethod == null)
					continue;
				if (!IsExceptionLogger(calledMethod))
					continue;

				return true;
			}

			return false;
		}

		protected virtual bool IsExceptionLogger(IMethod method) => exceptionLoggerMethods.Find(method);
		protected virtual bool HasExceptionLoggers => exceptionLoggerMethods.Count != 0;

		public bool Remove(Blocks blocks) {
			if (!HasExceptionLoggers)
				return false;

			if (!Find(blocks, out var tryBlock))
				return false;

			blocks.MethodBlocks.RemoveTryBlock(tryBlock);
			NumRemovedExceptionLoggers++;
			return true;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/IDeobfuscatedFile.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

namespace de4dot.code.deobfuscators {
	public interface IDeobfuscatedFile : ISimpleDeobfuscator {
		IDeobfuscatorContext DeobfuscatorContext { get; }
		void CreateAssemblyFile(byte[] data, string assemblyName, string extension);
		void StringDecryptersAdded();
		void SetDeobfuscator(IDeobfuscator deob);
	}
}



================================================
File: de4dot.code/deobfuscators/IDeobfuscator.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.PE;
using dnlib.DotNet;
using dnlib.DotNet.Writer;
using de4dot.blocks;
using de4dot.blocks.cflow;
using de4dot.code.renamer;

namespace de4dot.code.deobfuscators {
	public interface IDeobfuscatorOptions {
		bool RenameResourcesInCode { get; }
	}

	public enum DecrypterType {
		Default,
		None,
		Static,
		Delegate,
		Emulate,
	}

	[Flags]
	public enum StringFeatures {
		AllowNoDecryption = 1,
		AllowStaticDecryption = 2,
		AllowDynamicDecryption = 4,
		AllowAll = AllowNoDecryption | AllowStaticDecryption | AllowDynamicDecryption,
	}

	[Flags]
	public enum RenamingOptions {
		RemoveNamespaceIfOneType = 1,
		RenameResourceKeys = 2,
	}

	public interface IDeobfuscator : INameChecker, IDisposable {
		string Type { get; }
		string TypeLong { get; }
		string Name { get; }
		IDeobfuscatorOptions TheOptions { get; }
		IOperations Operations { get; set; }
		MetadataFlags MetadataFlags { get; }
		StringFeatures StringFeatures { get; }
		RenamingOptions RenamingOptions { get; }
		DecrypterType DefaultDecrypterType { get; }
		IEnumerable<IBlocksDeobfuscator> BlocksDeobfuscators { get; }

		// This is non-null only in detect() and deobfuscateBegin().
		IDeobfuscatedFile DeobfuscatedFile { get; set; }

		// Returns null or the unpacked .NET PE file
		byte[] UnpackNativeFile(IPEImage peImage);

		void Initialize(ModuleDefMD module);

		// Returns 0 if it's not detected, or > 0 if detected (higher value => more likely true).
		// This method is always called.
		int Detect();

		// If the obfuscator has encrypted parts of the file, then this method should return the
		// decrypted file. true is returned if args have been initialized, false otherwise.
		bool GetDecryptedModule(int count, ref byte[] newFileData, ref DumpedMethods dumpedMethods);

		// This is only called if getDecryptedModule() != null, and after the module has been
		// reloaded. Should return a new IDeobfuscator with the same options and the new module.
		IDeobfuscator ModuleReloaded(ModuleDefMD module);

		// Called before all other deobfuscation methods
		void DeobfuscateBegin();

		// Called before the code is deobfuscated
		void DeobfuscateMethodBegin(Blocks blocks);

		// Return true if we should deobfuscate control flow again
		bool DeobfuscateOther(Blocks blocks);

		// Called after deobfuscateMethodBegin() but before deobfuscateMethodEnd()
		void DeobfuscateStrings(Blocks blocks);

		// Called after the code has been deobfuscated
		void DeobfuscateMethodEnd(Blocks blocks);

		// Called after all deobfuscation methods
		void DeobfuscateEnd();

		// Returns all string decrypter method tokens
		IEnumerable<int> GetStringDecrypterMethods();
	}
}



================================================
File: de4dot.code/deobfuscators/IDeobfuscatorInfo.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;

namespace de4dot.code.deobfuscators {
	public interface IDeobfuscatorInfo {
		string Type { get; }
		string Name { get; }
		IDeobfuscator CreateDeobfuscator();
		IEnumerable<Option> GetOptions();
	}
}



================================================
File: de4dot.code/deobfuscators/ISimpleDeobfuscator.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using dnlib.DotNet;

namespace de4dot.code.deobfuscators {
	[Flags]
	public enum SimpleDeobfuscatorFlags : uint {
		Force											= 0x00000001,

		// Hack for Confuser deobfuscator code. That code was written before the
		// constants folder was updated and it now breaks the old Confuser code.
		DisableConstantsFolderExtraInstrs				= 0x00000002,
	}

	public interface ISimpleDeobfuscator {
		void MethodModified(MethodDef method);
		void Deobfuscate(MethodDef method);
		void Deobfuscate(MethodDef method, SimpleDeobfuscatorFlags flags);
		void DecryptStrings(MethodDef method, IDeobfuscator deob);
	}
}



================================================
File: de4dot.code/deobfuscators/InitializedDataCreator.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.IO;
using System.Security.Cryptography;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators {
	public class InitializedDataCreator {
		ModuleDef module;
		Dictionary<long, TypeDef> sizeToArrayType = new Dictionary<long, TypeDef>();
		TypeDef ourType;
		TypeDefOrRefSig valueType;
		int unique = 0;
		MemberRef initializeArrayMethod;

		public MemberRef InitializeArrayMethod => CreateInitializeArrayMethod();
		public InitializedDataCreator(ModuleDef module) => this.module = module;

		MemberRef CreateInitializeArrayMethod() {
			if (initializeArrayMethod == null) {
				var runtimeHelpersType = DotNetUtils.FindOrCreateTypeRef(module, module.CorLibTypes.AssemblyRef, "System.Runtime.CompilerServices", "RuntimeHelpers", false);
				var systemArrayType = DotNetUtils.FindOrCreateTypeRef(module, module.CorLibTypes.AssemblyRef, "System", "Array", false);
				var runtimeFieldHandleType = DotNetUtils.FindOrCreateTypeRef(module, module.CorLibTypes.AssemblyRef, "System", "RuntimeFieldHandle", true);
				var methodSig = MethodSig.CreateStatic(module.CorLibTypes.Void, systemArrayType, runtimeFieldHandleType);
				initializeArrayMethod = module.UpdateRowId(new MemberRefUser(module, "InitializeArray", methodSig, runtimeHelpersType.TypeDefOrRef));
			}
			return initializeArrayMethod;
		}

		public void AddInitializeArrayCode(Block block, int start, int numToRemove, ITypeDefOrRef elementType, byte[] data) {
			int index = start;
			block.Replace(index++, numToRemove, Instruction.CreateLdcI4(data.Length / elementType.ToTypeSig().ElementType.GetPrimitiveSize()));
			block.Insert(index++, OpCodes.Newarr.ToInstruction(elementType));
			block.Insert(index++, OpCodes.Dup.ToInstruction());
			block.Insert(index++, OpCodes.Ldtoken.ToInstruction((IField)Create(data)));
			block.Insert(index++, OpCodes.Call.ToInstruction((IMethod)InitializeArrayMethod));
		}

		void CreateOurType() {
			if (ourType != null)
				return;

			ourType = new TypeDefUser("", $"<PrivateImplementationDetails>{GetModuleId()}", module.CorLibTypes.Object.TypeDefOrRef);
			ourType.Attributes = TypeAttributes.NotPublic | TypeAttributes.AutoLayout |
							TypeAttributes.Class | TypeAttributes.AnsiClass;
			module.UpdateRowId(ourType);
			module.Types.Add(ourType);
		}

		object GetModuleId() {
			var memoryStream = new MemoryStream();
			var writer = new BinaryWriter(memoryStream);
			if (module.Assembly != null)
				writer.Write(module.Assembly.FullName);
			writer.Write((module.Mvid ?? Guid.Empty).ToByteArray());
			var hash = new SHA1Managed().ComputeHash(memoryStream.GetBuffer());
			var guid = new Guid(BitConverter.ToInt32(hash, 0),
								BitConverter.ToInt16(hash, 4),
								BitConverter.ToInt16(hash, 6),
								hash[8], hash[9], hash[10], hash[11],
								hash[12], hash[13], hash[14], hash[15]);
			return guid.ToString("B");
		}

		TypeDef GetArrayType(long size) {
			CreateOurType();

			if (sizeToArrayType.TryGetValue(size, out var arrayType))
				return arrayType;

			if (valueType == null)
				valueType = DotNetUtils.FindOrCreateTypeRef(module, module.CorLibTypes.AssemblyRef, "System", "ValueType", false);
			arrayType = new TypeDefUser("", $"__StaticArrayInitTypeSize={size}", valueType.TypeDefOrRef);
			module.UpdateRowId(arrayType);
			arrayType.Attributes = TypeAttributes.NestedPrivate | TypeAttributes.ExplicitLayout |
							TypeAttributes.Class | TypeAttributes.Sealed | TypeAttributes.AnsiClass;
			ourType.NestedTypes.Add(arrayType);
			sizeToArrayType[size] = arrayType;
			arrayType.ClassLayout = new ClassLayoutUser(1, (uint)size);
			return arrayType;
		}

		public FieldDef Create(byte[] data) {
			var arrayType = GetArrayType(data.LongLength);
			var fieldSig = new FieldSig(new ValueTypeSig(arrayType));
			var attrs = FieldAttributes.Assembly | FieldAttributes.Static;
			var field = new FieldDefUser($"field_{unique++}", fieldSig, attrs);
			module.UpdateRowId(field);
			field.HasFieldRVA = true;
			ourType.Fields.Add(field);
			var iv = new byte[data.Length];
			Array.Copy(data, iv, data.Length);
			field.InitialValue = iv;
			return field;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/InlinedMethodsFinder.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators {
	public static class InlinedMethodsFinder {
		public static List<MethodDef> Find(ModuleDef module) {
			// Not all garbage methods are inlined, possibly because we remove some code that calls
			// the garbage method before the methods inliner has a chance to inline it. Try to find
			// all garbage methods and other code will figure out if there are any calls left.

			var inlinedMethods = new List<MethodDef>();
			foreach (var type in module.GetTypes()) {
				foreach (var method in type.Methods) {
					if (!method.IsStatic)
						continue;
					if (!method.IsAssembly && !method.IsPrivateScope && !method.IsPrivate)
						continue;
					if (method.GenericParameters.Count > 0)
						continue;
					if (method.Name == ".cctor")
						continue;
					if (method.Body == null)
						continue;
					var instrs = method.Body.Instructions;
					if (instrs.Count < 2)
						continue;

					switch (instrs[0].OpCode.Code) {
					case Code.Ldc_I4:
					case Code.Ldc_I4_0:
					case Code.Ldc_I4_1:
					case Code.Ldc_I4_2:
					case Code.Ldc_I4_3:
					case Code.Ldc_I4_4:
					case Code.Ldc_I4_5:
					case Code.Ldc_I4_6:
					case Code.Ldc_I4_7:
					case Code.Ldc_I4_8:
					case Code.Ldc_I4_M1:
					case Code.Ldc_I4_S:
					case Code.Ldc_I8:
					case Code.Ldc_R4:
					case Code.Ldc_R8:
					case Code.Ldftn:
					case Code.Ldnull:
					case Code.Ldstr:
					case Code.Ldtoken:
					case Code.Ldsfld:
					case Code.Ldsflda:
						if (instrs[1].OpCode.Code != Code.Ret)
							continue;
						break;

					case Code.Ldarg:
					case Code.Ldarg_S:
					case Code.Ldarg_0:
					case Code.Ldarg_1:
					case Code.Ldarg_2:
					case Code.Ldarg_3:
					case Code.Ldarga:
					case Code.Ldarga_S:
					case Code.Call:
					case Code.Newobj:
						if (!IsCallMethod(method))
							continue;
						break;

					default:
						continue;
					}

					inlinedMethods.Add(method);
				}
			}

			return inlinedMethods;
		}

		static bool IsCallMethod(MethodDef method) {
			int loadIndex = 0;
			int methodArgsCount = DotNetUtils.GetArgsCount(method);
			var instrs = method.Body.Instructions;
			int i = 0;
			for (; i < instrs.Count && i < methodArgsCount; i++) {
				var instr = instrs[i];
				switch (instr.OpCode.Code) {
				case Code.Ldarg:
				case Code.Ldarg_S:
				case Code.Ldarg_0:
				case Code.Ldarg_1:
				case Code.Ldarg_2:
				case Code.Ldarg_3:
				case Code.Ldarga:
				case Code.Ldarga_S:
					if (instr.GetParameterIndex() != loadIndex)
						return false;
					loadIndex++;
					continue;
				}
				break;
			}
			if (loadIndex != methodArgsCount)
				return false;
			if (i + 1 >= instrs.Count)
				return false;

			switch (instrs[i].OpCode.Code) {
			case Code.Call:
			case Code.Callvirt:
			case Code.Newobj:
			case Code.Ldfld:
			case Code.Ldflda:
			case Code.Ldftn:
			case Code.Ldvirtftn:
				break;
			default:
				return false;
			}
			if (instrs[i + 1].OpCode.Code != Code.Ret)
				return false;

			return true;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/MemberReferenceBuilder.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet;

namespace de4dot.code.deobfuscators {
	public class MemberRefBuilder {
		ModuleDefMD module;
		Dictionary<TypeSig, TypeSig> createdTypes = new Dictionary<TypeSig, TypeSig>(TypeEqualityComparer.Instance);

		public MemberRefBuilder(ModuleDefMD module) => this.module = module;

		public AssemblyRef CorLib => module.CorLibTypes.AssemblyRef;
		public CorLibTypeSig Object => module.CorLibTypes.Object;
		public CorLibTypeSig Void => module.CorLibTypes.Void;
		public CorLibTypeSig Boolean => module.CorLibTypes.Boolean;
		public CorLibTypeSig Char => module.CorLibTypes.Char;
		public CorLibTypeSig SByte => module.CorLibTypes.SByte;
		public CorLibTypeSig Byte => module.CorLibTypes.Byte;
		public CorLibTypeSig Int16 => module.CorLibTypes.Int16;
		public CorLibTypeSig UInt16 => module.CorLibTypes.UInt16;
		public CorLibTypeSig Int32 => module.CorLibTypes.Int32;
		public CorLibTypeSig UInt32 => module.CorLibTypes.UInt32;
		public CorLibTypeSig Int64 => module.CorLibTypes.Int64;
		public CorLibTypeSig UInt64 => module.CorLibTypes.UInt64;
		public CorLibTypeSig Single => module.CorLibTypes.Single;
		public CorLibTypeSig Double => module.CorLibTypes.Double;
		public CorLibTypeSig IntPtr => module.CorLibTypes.IntPtr;
		public CorLibTypeSig UIntPtr => module.CorLibTypes.UIntPtr;
		public CorLibTypeSig String => module.CorLibTypes.String;
		public CorLibTypeSig TypedReference => module.CorLibTypes.TypedReference;

		public ClassSig Type(string ns, string name, string asmSimpleName) => Type(ns, name, FindAssemblyRef(asmSimpleName));
		public ClassSig Type(string ns, string name) => Type(ns, name, CorLib);
		public ClassSig Type(string ns, string name, AssemblyRef asmRef) => (ClassSig)Type(false, ns, name, asmRef);
		public ValueTypeSig ValueType(string ns, string name, string asmSimpleName) => ValueType(ns, name, FindAssemblyRef(asmSimpleName));
		public ValueTypeSig ValueType(string ns, string name) => ValueType(ns, name, CorLib);
		public ValueTypeSig ValueType(string ns, string name, AssemblyRef asmRef) => (ValueTypeSig)Type(true, ns, name, asmRef);

		public ClassOrValueTypeSig Type(bool isValueType, string ns, string name, IResolutionScope resolutionScope) {
			var typeRef = module.UpdateRowId(new TypeRefUser(module, ns, name, resolutionScope));
			ClassOrValueTypeSig type;
			if (isValueType)
				type = new ValueTypeSig(typeRef);
			else
				type = new ClassSig(typeRef);
			return (ClassOrValueTypeSig)Add(type);
		}

		public SZArraySig Array(TypeSig typeRef) => (SZArraySig)Add(new SZArraySig(typeRef));

		TypeSig Add(TypeSig typeRef) {
			if (createdTypes.TryGetValue(typeRef, out var createdTypeRef)) {
				if (createdTypeRef.ElementType != typeRef.ElementType)
					throw new ApplicationException($"Type {createdTypeRef}'s IsValueType is not correct");
				return createdTypeRef;
			}
			createdTypes[typeRef] = typeRef;
			return typeRef;
		}

		public MemberRef InstanceMethod(string name, IMemberRefParent declaringType, TypeSig returnType, params TypeSig[] args) =>
			Method(true, name, declaringType, returnType, args);

		public MemberRef StaticMethod(string name, IMemberRefParent declaringType, TypeSig returnType, params TypeSig[] args) =>
			Method(false, name, declaringType, returnType, args);

		public MemberRef Method(bool isInstance, string name, IMemberRefParent declaringType, TypeSig returnType, params TypeSig[] args) {
			MethodSig sig;
			if (isInstance)
				sig = MethodSig.CreateInstance(returnType, args);
			else
				sig = MethodSig.CreateStatic(returnType, args);
			return module.UpdateRowId(new MemberRefUser(module, name, sig, declaringType));
		}

		AssemblyRef FindAssemblyRef(string asmSimpleName) {
			var asmRef = module.GetAssemblyRef(asmSimpleName);
			if (asmRef == null)
				throw new ApplicationException($"Could not find assembly {asmSimpleName} in assembly references");
			return asmRef;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/MethodBodyParser.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.IO;
using dnlib.IO;

namespace de4dot.code.deobfuscators {
	[Serializable]
	public class InvalidMethodBody : Exception {
		public InvalidMethodBody() {
		}

		public InvalidMethodBody(string msg)
			: base(msg) {
		}
	}

	public class MethodBodyHeader {
		public ushort flags;
		public ushort maxStack;
		public uint codeSize;
		public uint localVarSigTok;
	}

	public static class MethodBodyParser {
		public static MethodBodyHeader ParseMethodBody(ref DataReader reader, out byte[] code, out byte[] extraSections) {
			try {
				return ParseMethodBody2(ref reader, out code, out extraSections);
			}
			catch (Exception ex) when (ex is IOException || ex is ArgumentException) {
				throw new InvalidMethodBody();
			}
		}

		public static bool Verify(byte[] data) {
			var reader = ByteArrayDataReaderFactory.CreateReader(data);
			return Verify(ref reader);
		}

		public static bool Verify(ref DataReader reader) {
			try {
				ParseMethodBody(ref reader, out var code, out var extraSections);
				return true;
			}
			catch (InvalidMethodBody) {
				return false;
			}
		}

		static MethodBodyHeader ParseMethodBody2(ref DataReader reader, out byte[] code, out byte[] extraSections) {
			var mbHeader = new MethodBodyHeader();

			uint codeOffset;
			byte b = Peek(ref reader);
			if ((b & 3) == 2) {
				mbHeader.flags = 2;
				mbHeader.maxStack = 8;
				mbHeader.codeSize = (uint)(reader.ReadByte() >> 2);
				mbHeader.localVarSigTok = 0;
				codeOffset = 1;
			}
			else if ((b & 7) == 3) {
				mbHeader.flags = reader.ReadUInt16();
				codeOffset = (uint)(4 * (mbHeader.flags >> 12));
				if (codeOffset != 12)
					throw new InvalidMethodBody();
				mbHeader.maxStack = reader.ReadUInt16();
				mbHeader.codeSize = reader.ReadUInt32();
				if (mbHeader.codeSize > int.MaxValue)
					throw new InvalidMethodBody();
				mbHeader.localVarSigTok = reader.ReadUInt32();
				if (mbHeader.localVarSigTok != 0 && (mbHeader.localVarSigTok >> 24) != 0x11)
					throw new InvalidMethodBody();
			}
			else
				throw new InvalidMethodBody();

			if (mbHeader.codeSize + codeOffset > reader.Length)
				throw new InvalidMethodBody();
			code = reader.ReadBytes((int)mbHeader.codeSize);

			if ((mbHeader.flags & 8) != 0)
				extraSections = ReadExtraSections2(ref reader);
			else
				extraSections = null;

			return mbHeader;
		}

		static void Align(ref DataReader reader, int alignment) =>
			reader.Position = (reader.Position + (uint)alignment - 1) & ~((uint)alignment - 1);

		public static byte[] ReadExtraSections(ref DataReader reader) {
			try {
				return ReadExtraSections2(ref reader);
			}
			catch (Exception ex) when (ex is IOException || ex is ArgumentException) {
				throw new InvalidMethodBody();
			}
		}

		static byte[] ReadExtraSections2(ref DataReader reader) {
			Align(ref reader, 4);
			int startPos = (int)reader.Position;
			ParseSection(ref reader);
			int size = (int)reader.Position - startPos;
			reader.Position = (uint)startPos;
			return reader.ReadBytes(size);
		}

		static void ParseSection(ref DataReader reader) {
			byte flags;
			do {
				Align(ref reader, 4);

				flags = reader.ReadByte();
				if ((flags & 1) == 0)
					throw new InvalidMethodBody("Not an exception section");
				if ((flags & 0x3E) != 0)
					throw new InvalidMethodBody("Invalid bits set");

				if ((flags & 0x40) != 0) {
					reader.Position--;
					int num = (int)(reader.ReadUInt32() >> 8) / 24;
					reader.Position += (uint)num * 24;
				}
				else {
					int num = reader.ReadByte() / 12;
					reader.Position += 2 + (uint)num * 12;
				}
			} while ((flags & 0x80) != 0);
		}

		static byte Peek(ref DataReader reader) {
			byte b = reader.ReadByte();
			reader.Position--;
			return b;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/MethodCallRestorerBase.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators {
	public class MethodCallRestorerBase {
		protected MemberRefBuilder builder;
		protected ModuleDefMD module;
		MethodDefAndDeclaringTypeDict<NewMethodInfo> oldToNewMethod = new MethodDefAndDeclaringTypeDict<NewMethodInfo>();

		class NewMethodInfo {
			public OpCode opCode;
			public IMethod method;

			public NewMethodInfo(OpCode opCode, IMethod method) {
				this.opCode = opCode;
				this.method = method;
			}
		}

		public MethodCallRestorerBase(ModuleDefMD module) {
			this.module = module;
			builder = new MemberRefBuilder(module);
		}

		public void CreateGetManifestResourceStream1(MethodDef oldMethod) {
			if (oldMethod == null)
				return;
			var assemblyType = builder.Type("System.Reflection", "Assembly", builder.CorLib);
			var streamType = builder.Type("System.IO", "Stream", builder.CorLib);
			var newMethod = builder.InstanceMethod("GetManifestResourceStream", assemblyType.TypeDefOrRef, streamType, builder.String);
			Add(oldMethod, newMethod, OpCodes.Callvirt);
		}

		public void CreateGetManifestResourceStream2(MethodDef oldMethod) {
			if (oldMethod == null)
				return;
			var assemblyType = builder.Type("System.Reflection", "Assembly", builder.CorLib);
			var typeType = builder.Type("System", "Type", builder.CorLib);
			var streamType = builder.Type("System.IO", "Stream", builder.CorLib);
			var newMethod = builder.InstanceMethod("GetManifestResourceStream", assemblyType.TypeDefOrRef, streamType, typeType, builder.String);
			Add(oldMethod, newMethod, OpCodes.Callvirt);
		}

		public void CreateGetManifestResourceNames(MethodDef oldMethod) {
			if (oldMethod == null)
				return;
			var assemblyType = builder.Type("System.Reflection", "Assembly", builder.CorLib);
			var stringArrayType = builder.Array(builder.String);
			var newMethod = builder.InstanceMethod("GetManifestResourceNames", assemblyType.TypeDefOrRef, stringArrayType);
			Add(oldMethod, newMethod, OpCodes.Callvirt);
		}

		public void CreateGetReferencedAssemblies(MethodDef oldMethod) {
			if (oldMethod == null)
				return;
			var assemblyType = builder.Type("System.Reflection", "Assembly", builder.CorLib);
			var asmNameArray = builder.Array(builder.Type("System.Reflection", "AssemblyName", builder.CorLib));
			var newMethod = builder.InstanceMethod("GetReferencedAssemblies", assemblyType.TypeDefOrRef, asmNameArray);
			Add(oldMethod, newMethod, OpCodes.Callvirt);
		}

		public void CreateBitmapCtor(MethodDef oldMethod) {
			if (oldMethod == null)
				return;
			var bitmapType = builder.Type("System.Drawing", "Bitmap", "System.Drawing");
			var typeType = builder.Type("System", "Type", builder.CorLib);
			var newMethod = builder.InstanceMethod(".ctor", bitmapType.TypeDefOrRef, builder.Void, typeType, builder.String);
			Add(oldMethod, newMethod, OpCodes.Newobj);
		}

		public void CreateIconCtor(MethodDef oldMethod) {
			if (oldMethod == null)
				return;
			var iconType = builder.Type("System.Drawing", "Icon", "System.Drawing");
			var typeType = builder.Type("System", "Type", builder.CorLib);
			var newMethod = builder.InstanceMethod(".ctor", iconType.TypeDefOrRef, builder.Void, typeType, builder.String);
			Add(oldMethod, newMethod, OpCodes.Newobj);
		}

		protected void Add(MethodDef oldMethod, IMethod newMethod) => Add(oldMethod, newMethod, OpCodes.Callvirt);

		protected void Add(MethodDef oldMethod, IMethod newMethod, OpCode opCode) {
			if (oldMethod == null)
				return;
			oldToNewMethod.Add(oldMethod, new NewMethodInfo(opCode, newMethod));
		}

		public void Deobfuscate(Blocks blocks) {
			if (oldToNewMethod.Count == 0)
				return;
			foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {
				var instrs = block.Instructions;
				for (int i = 0; i < instrs.Count; i++) {
					var call = instrs[i];
					if (call.OpCode.Code != Code.Call)
						continue;
					var calledMethod = call.Operand as MethodDef;
					if (calledMethod == null)
						continue;

					var newMethodInfo = oldToNewMethod.Find(calledMethod);
					if (newMethodInfo == null)
						continue;

					instrs[i] = new Instr(Instruction.Create(newMethodInfo.opCode, newMethodInfo.method));
				}
			}
		}
	}
}



================================================
File: de4dot.code/deobfuscators/MethodCollection.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet;
using de4dot.blocks;

namespace de4dot.code.deobfuscators {
	public class MethodCollection {
		TypeDefDict<bool> types = new TypeDefDict<bool>();
		MethodDefAndDeclaringTypeDict<bool> methods = new MethodDefAndDeclaringTypeDict<bool>();

		public bool Exists(IMethod method) {
			if (method == null)
				return false;
			if (method.DeclaringType != null && types.Find(method.DeclaringType))
				return true;
			return methods.Find(method);
		}

		public void Add(MethodDef method) => methods.Add(method, true);

		public void Add(IEnumerable<MethodDef> methods) {
			foreach (var method in methods)
				Add(method);
		}

		public void Add(TypeDef type) => types.Add(type, true);

		public void AddAndNested(TypeDef type) {
			Add(type);
			foreach (var t in type.GetTypes())
				Add(t);
		}

		public void AddAndNested(IList<TypeDef> types) {
			foreach (var type in AllTypesHelper.Types(types))
				Add(type);
		}
	}
}



================================================
File: de4dot.code/deobfuscators/MethodStack.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using de4dot.blocks;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace de4dot.code.deobfuscators {
	public class PushedArgs {
		List<Instruction> args;
		int nextIndex;

		public bool CanAddMore => nextIndex >= 0;
		public int NumValidArgs => args.Count - (nextIndex + 1);

		public PushedArgs(int numArgs) {
			nextIndex = numArgs - 1;
			args = new List<Instruction>(numArgs);
			for (int i = 0; i < numArgs; i++)
				args.Add(null);
		}

		public void Add(Instruction instr) => args[nextIndex--] = instr;
		public void Set(int i, Instruction instr) => args[i] = instr;
		internal void Pop() => args[++nextIndex] = null;

		public Instruction Get(int i) {
			if (0 <= i && i < args.Count)
				return args[i];
			return null;
		}

		public Instruction GetEnd(int i) => Get(args.Count - 1 - i);
	}

	public static class MethodStack {
		// May not return all args. The args are returned in reverse order.
		public static PushedArgs GetPushedArgInstructions(IList<Instruction> instructions, int index) {
			try {
				instructions[index].CalculateStackUsage(false, out int pushes, out int pops);
				if (pops != -1)
					return GetPushedArgInstructions(instructions, index, pops);
			}
			catch (System.NullReferenceException) {
				// Here if eg. invalid metadata token in a call instruction (operand is null)
			}
			return new PushedArgs(0);
		}

		// May not return all args. The args are returned in reverse order.
		static PushedArgs GetPushedArgInstructions(IList<Instruction> instructions, int index, int numArgs) {
			var pushedArgs = new PushedArgs(numArgs);
			if (!pushedArgs.CanAddMore) return pushedArgs;

			Dictionary<int, Branch> branches = null;
			var states = new Stack<State>();
			var state = new State(index, null, 0, 0, 1, new HashSet<int>());
			var isBacktrack = false;
			states.Push(state.Clone());
			while (true) {
				while (state.index >= 0) {
					if (branches != null && branches.TryGetValue(state.index, out var branch) && state.visited.Add(state.index)) {
						branch.current = 0;
						var brState = state.Clone();
						brState.branch = branch;
						states.Push(brState);
					}
					if (!isBacktrack)
						state.index--;
					isBacktrack = false;
					var update = UpdateState(instructions, state, pushedArgs);
					if (update == Update.Finish)
						return pushedArgs;
					if (update == Update.Fail)
						break;
				}

				if (states.Count == 0)
					return pushedArgs;

				var prevValidArgs = state.validArgs;
				state = states.Pop();
				if (state.validArgs < prevValidArgs)
					for (int i = state.validArgs + 1; i <= prevValidArgs; i++)
						pushedArgs.Pop();

				if (branches == null)
					branches = GetBranches(instructions);
				else {
					isBacktrack = true;
					state.index = state.branch.Variants[state.branch.current++];
					if (state.branch.current < state.branch.Variants.Count)
						states.Push(state.Clone());
					else
						state.branch = null;
				}
			}

		}

		class Branch {
			public int current;
			public List<int> Variants { get; }
			public Branch() => Variants = new List<int>();
		}

		class State {
			public int index;
			public Branch branch;
			public int validArgs;
			public int skipPushes;
			public int addPushes;
			public HashSet<int> visited;

			public State(int index, Branch branch, int validArgs, int skipPushes, int addPushes, HashSet<int> visited) {
				this.index = index;
				this.branch = branch;
				this.validArgs = validArgs;
				this.skipPushes = skipPushes;
				this.addPushes = addPushes;
				this.visited = visited;
			}

			public State Clone() => new State(index, branch, validArgs, skipPushes, addPushes, new HashSet<int>(visited));
		}

		enum Update { Ok, Fail, Finish };

		private static Update UpdateState(IList<Instruction> instructions, State state, PushedArgs pushedArgs) {
			if (state.index < 0 || state.index >= instructions.Count)
				return Update.Fail;
			var instr = instructions[state.index];
			if (!Instr.IsFallThrough(instr.OpCode))
				return Update.Fail;
			instr.CalculateStackUsage(false, out int pushes, out int pops);
			if (pops == -1)
				return Update.Fail;
			var isDup = instr.OpCode.Code == Code.Dup;
			if (isDup) {
				pushes = 1;
				pops = 0;
			}
			if (pushes > 1)
				return Update.Fail;

			if (state.skipPushes > 0) {
				state.skipPushes -= pushes;
				if (state.skipPushes < 0)
					return Update.Fail;
				state.skipPushes += pops;
			}
			else {
				if (pushes == 1) {
					if (isDup)
						state.addPushes++;
					else {
						for (; state.addPushes > 0; state.addPushes--) {
							pushedArgs.Add(instr);
							state.validArgs++;
							if (!pushedArgs.CanAddMore)
								return Update.Finish;
						}
						state.addPushes = 1;
					}
				}
				state.skipPushes += pops;
			}
			return Update.Ok;
		}

		private static IList<Instruction> CacheInstructions = null;
		private static Dictionary<int, Branch> CacheBranches = null;

		// cache last branches based on instructions object
		private static Dictionary<int, Branch> GetBranches(IList<Instruction> instructions) {
			if (CacheInstructions == instructions) return CacheBranches;
			CacheInstructions = instructions;
			CacheBranches = new Dictionary<int, Branch>();
			for (int b = 0; b < instructions.Count; b++) {
				var br = instructions[b];
				if (br.Operand is Instruction target) {
					var t = instructions.IndexOf(target);
					if (!CacheBranches.TryGetValue(t, out var branch)) {
						branch = new Branch();
						CacheBranches.Add(t, branch);
					}
					branch.Variants.Add(b);
				}
			}
			return CacheBranches;
		}

		public static TypeSig GetLoadedType(MethodDef method, IList<Instruction> instructions, int instrIndex) =>
			GetLoadedType(method, instructions, instrIndex, 0, out bool wasNewobj);
		public static TypeSig GetLoadedType(MethodDef method, IList<Instruction> instructions, int instrIndex, int argIndexFromEnd) =>
			GetLoadedType(method, instructions, instrIndex, argIndexFromEnd, out bool wasNewobj);
		public static TypeSig GetLoadedType(MethodDef method, IList<Instruction> instructions, int instrIndex, out bool wasNewobj) =>
			GetLoadedType(method, instructions, instrIndex, 0, out wasNewobj);

		public static TypeSig GetLoadedType(MethodDef method, IList<Instruction> instructions, int instrIndex, int argIndexFromEnd, out bool wasNewobj) {
			wasNewobj = false;
			var pushedArgs = MethodStack.GetPushedArgInstructions(instructions, instrIndex);
			var pushInstr = pushedArgs.GetEnd(argIndexFromEnd);
			if (pushInstr == null)
				return null;

			TypeSig type;
			Local local;
			var corLibTypes = method.DeclaringType.Module.CorLibTypes;
			switch (pushInstr.OpCode.Code) {
			case Code.Ldstr:
				type = corLibTypes.String;
				break;

			case Code.Conv_I:
			case Code.Conv_Ovf_I:
			case Code.Conv_Ovf_I_Un:
				type = corLibTypes.IntPtr;
				break;

			case Code.Conv_U:
			case Code.Conv_Ovf_U:
			case Code.Conv_Ovf_U_Un:
				type = corLibTypes.UIntPtr;
				break;

			case Code.Conv_I8:
			case Code.Conv_Ovf_I8:
			case Code.Conv_Ovf_I8_Un:
				type = corLibTypes.Int64;
				break;

			case Code.Conv_U8:
			case Code.Conv_Ovf_U8:
			case Code.Conv_Ovf_U8_Un:
				type = corLibTypes.UInt64;
				break;

			case Code.Conv_R8:
			case Code.Ldc_R8:
			case Code.Ldelem_R8:
			case Code.Ldind_R8:
				type = corLibTypes.Double;
				break;

			case Code.Call:
			case Code.Calli:
			case Code.Callvirt:
				var calledMethod = pushInstr.Operand as IMethod;
				if (calledMethod == null)
					return null;
				type = calledMethod.MethodSig.GetRetType();
				break;

			case Code.Newarr:
				var type2 = pushInstr.Operand as ITypeDefOrRef;
				if (type2 == null)
					return null;
				type = new SZArraySig(type2.ToTypeSig());
				wasNewobj = true;
				break;

			case Code.Newobj:
				var ctor = pushInstr.Operand as IMethod;
				if (ctor == null)
					return null;
				type = ctor.DeclaringType.ToTypeSig();
				wasNewobj = true;
				break;

			case Code.Castclass:
			case Code.Isinst:
			case Code.Unbox_Any:
			case Code.Ldelem:
			case Code.Ldobj:
				type = (pushInstr.Operand as ITypeDefOrRef).ToTypeSig();
				break;

			case Code.Ldarg:
			case Code.Ldarg_S:
			case Code.Ldarg_0:
			case Code.Ldarg_1:
			case Code.Ldarg_2:
			case Code.Ldarg_3:
				type = pushInstr.GetArgumentType(method.MethodSig, method.DeclaringType);
				break;

			case Code.Ldloc:
			case Code.Ldloc_S:
			case Code.Ldloc_0:
			case Code.Ldloc_1:
			case Code.Ldloc_2:
			case Code.Ldloc_3:
				local = pushInstr.GetLocal(method.Body.Variables);
				if (local == null)
					return null;
				type = local.Type.RemovePinned();
				break;

			case Code.Ldloca:
			case Code.Ldloca_S:
				local = pushInstr.Operand as Local;
				if (local == null)
					return null;
				type = CreateByRefType(local.Type.RemovePinned());
				break;

			case Code.Ldarga:
			case Code.Ldarga_S:
				type = CreateByRefType(pushInstr.GetArgumentType(method.MethodSig, method.DeclaringType));
				break;

			case Code.Ldfld:
			case Code.Ldsfld:
				var field = pushInstr.Operand as IField;
				if (field == null || field.FieldSig == null)
					return null;
				type = field.FieldSig.GetFieldType();
				break;

			case Code.Ldflda:
			case Code.Ldsflda:
				var field2 = pushInstr.Operand as IField;
				if (field2 == null || field2.FieldSig == null)
					return null;
				type = CreateByRefType(field2.FieldSig.GetFieldType());
				break;

			case Code.Ldelema:
			case Code.Unbox:
				type = CreateByRefType(pushInstr.Operand as ITypeDefOrRef);
				break;

			default:
				return null;
			}

			return type;
		}

		static ByRefSig CreateByRefType(ITypeDefOrRef elementType) {
			if (elementType == null)
				return null;
			return new ByRefSig(elementType.ToTypeSig());
		}

		static ByRefSig CreateByRefType(TypeSig elementType) {
			if (elementType == null)
				return null;
			return new ByRefSig(elementType);
		}

	}
}



================================================
File: de4dot.code/deobfuscators/MethodsDecrypter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Runtime.Remoting;
using dnlib.DotNet;
using AssemblyData;
using de4dot.code.AssemblyClient;
using de4dot.blocks;
using de4dot.mdecrypt;

namespace de4dot.code.deobfuscators {
	public static class MethodsDecrypter {
		public static DumpedMethods Decrypt(ModuleDef module, byte[] moduleCctorBytes) =>
			Decrypt(NewProcessAssemblyClientFactory.GetServerClrVersion(module), module.Location, moduleCctorBytes);

		public static DumpedMethods Decrypt(ServerClrVersion serverVersion, string filename, byte[] moduleCctorBytes) {
			Exception lastEx = null;
			for (int i = 0; i < 5; i++) {
				try {
					return Decrypt2(serverVersion, filename, moduleCctorBytes);
				}
				catch (RemotingException ex) {
					lastEx = ex;
					continue;
				}
			}
			throw lastEx;
		}

		static DumpedMethods Decrypt2(ServerClrVersion serverVersion, string filename, byte[] moduleCctorBytes) {
			using (var client = new NewProcessAssemblyClientFactory(serverVersion).Create(AssemblyServiceType.MethodDecrypter)) {
				client.Connect();
				client.WaitConnected();
				var info = new DecryptMethodsInfo();
				info.moduleCctorBytes = moduleCctorBytes;
				client.MethodDecrypterService.InstallCompileMethod(info);
				client.MethodDecrypterService.LoadObfuscator(filename);
				return client.MethodDecrypterService.DecryptMethods();
			}
		}
	}
}



================================================
File: de4dot.code/deobfuscators/MyPEImage.cs
================================================
using System;
using System.Collections.Generic;
using dnlib.IO;
using dnlib.PE;
using dnlib.DotNet.MD;
using de4dot.blocks;

namespace de4dot.code.deobfuscators {
	public sealed class MyPEImage : IDisposable {
		IPEImage peImage;
		byte[] peImageData;
		Metadata metadata;
		bool dnFileInitialized;
		ImageSectionHeader dotNetSection;
		bool ownPeImage;

		public Metadata Metadata {
			get {
				if (dnFileInitialized)
					return metadata;
				dnFileInitialized = true;

				var dotNetDir = peImage.ImageNTHeaders.OptionalHeader.DataDirectories[14];
				if (dotNetDir.VirtualAddress != 0 && dotNetDir.Size >= 0x48) {
					metadata = MetadataFactory.CreateMetadata(peImage, false);
					dotNetSection = FindSection(dotNetDir.VirtualAddress);
				}
				return metadata;
			}
		}

		public ImageCor20Header Cor20Header => Metadata.ImageCor20Header;

		public DataReader Reader;

		public IPEImage PEImage => peImage;
		public ImageFileHeader FileHeader => peImage.ImageNTHeaders.FileHeader;
		public IImageOptionalHeader OptionalHeader => peImage.ImageNTHeaders.OptionalHeader;
		public IList<ImageSectionHeader> Sections => peImage.ImageSectionHeaders;
		public uint Length => (uint)Reader.Length;
		public MyPEImage(IPEImage peImage) => Initialize(peImage);

		public MyPEImage(byte[] peImageData) {
			ownPeImage = true;
			this.peImageData = peImageData;
			Initialize(new PEImage(peImageData));
		}

		void Initialize(IPEImage peImage) {
			this.peImage = peImage;
			Reader = peImage.CreateReader();
		}

		public ImageSectionHeader FindSection(RVA rva) {
			foreach (var section in peImage.ImageSectionHeaders) {
				if (section.VirtualAddress <= rva && rva < section.VirtualAddress + Math.Max(section.VirtualSize, section.SizeOfRawData))
					return section;
			}
			return null;
		}

		public ImageSectionHeader FindSection(string name) {
			foreach (var section in peImage.ImageSectionHeaders) {
				if (section.DisplayName == name)
					return section;
			}
			return null;
		}

		public void ReadMethodTableRowTo(DumpedMethod dm, uint rid) {
			dm.token = 0x06000000 + rid;
			if (!Metadata.TablesStream.TryReadMethodRow(rid, out var row))
				throw new ArgumentException("Invalid Method rid");
			dm.mdRVA = row.RVA;
			dm.mdImplFlags = row.ImplFlags;
			dm.mdFlags = row.Flags;
			dm.mdName = row.Name;
			dm.mdSignature = row.Signature;
			dm.mdParamList = row.ParamList;
		}

		public void UpdateMethodHeaderInfo(DumpedMethod dm, MethodBodyHeader mbHeader) {
			dm.mhFlags = mbHeader.flags;
			dm.mhMaxStack = mbHeader.maxStack;
			dm.mhCodeSize = dm.code == null ? 0 : (uint)dm.code.Length;
			dm.mhLocalVarSigTok = mbHeader.localVarSigTok;
		}

		public uint RvaToOffset(uint rva) => (uint)peImage.ToFileOffset((RVA)rva);

		static bool IsInside(ImageSectionHeader section, uint offset, uint length) =>
			offset >= section.PointerToRawData && offset + length <= section.PointerToRawData + section.SizeOfRawData;

		public void WriteUInt32(uint rva, uint data) => OffsetWriteUInt32(RvaToOffset(rva), data);
		public void WriteUInt16(uint rva, ushort data) => OffsetWriteUInt16(RvaToOffset(rva), data);
		public byte ReadByte(uint rva) => OffsetReadByte(RvaToOffset(rva));
		public int ReadInt32(uint rva) => (int)OffsetReadUInt32(RvaToOffset(rva));
		public ushort ReadUInt16(uint rva) => OffsetReadUInt16(RvaToOffset(rva));
		public byte[] ReadBytes(uint rva, int size) => OffsetReadBytes(RvaToOffset(rva), size);

		public void OffsetWriteUInt32(uint offset, uint val) {
			peImageData[offset + 0] = (byte)val;
			peImageData[offset + 1] = (byte)(val >> 8);
			peImageData[offset + 2] = (byte)(val >> 16);
			peImageData[offset + 3] = (byte)(val >> 24);
		}

		public void OffsetWriteUInt16(uint offset, ushort val) {
			peImageData[offset + 0] = (byte)val;
			peImageData[offset + 1] = (byte)(val >> 8);
		}

		public uint OffsetReadUInt32(uint offset) {
			Reader.Position = offset;
			return Reader.ReadUInt32();
		}

		public ushort OffsetReadUInt16(uint offset) {
			Reader.Position = offset;
			return Reader.ReadUInt16();
		}

		public byte OffsetReadByte(uint offset) {
			Reader.Position = offset;
			return Reader.ReadByte();
		}

		public byte[] OffsetReadBytes(uint offset, int size) {
			Reader.Position = offset;
			return Reader.ReadBytes(size);
		}

		public void OffsetWrite(uint offset, byte[] data) =>
			Array.Copy(data, 0, peImageData, offset, data.Length);
		bool Intersect(uint offset1, uint length1, uint offset2, uint length2) =>
			!(offset1 + length1 <= offset2 || offset2 + length2 <= offset1);
		bool Intersect(uint offset, uint length, IFileSection location) =>
			Intersect(offset, length, (uint)location.StartOffset, (uint)(location.EndOffset - location.StartOffset));

		public bool DotNetSafeWriteOffset(uint offset, byte[] data) {
			if (Metadata != null) {
				uint length = (uint)data.Length;

				if (!IsInside(dotNetSection, offset, length))
					return false;
				if (Intersect(offset, length, Metadata.ImageCor20Header))
					return false;
				if (Intersect(offset, length, Metadata.MetadataHeader))
					return false;
			}

			OffsetWrite(offset, data);
			return true;
		}

		public bool DotNetSafeWrite(uint rva, byte[] data) =>
			DotNetSafeWriteOffset((uint)peImage.ToFileOffset((RVA)rva), data);

		public void Dispose() {
			if (ownPeImage) {
				if (metadata != null)
					metadata.Dispose();
				if (peImage != null)
					peImage.Dispose();
			}

			metadata = null;
			peImage = null;
			Reader = default;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/NullStream.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.IO;

namespace de4dot.code.deobfuscators {
	public class NullStream : Stream {
		long offset = 0;
		long length = 0;

		public override bool CanRead => false;
		public override bool CanSeek => true;
		public override bool CanWrite => true;
		public override void Flush() { }
		public override long Length => length;

		public override long Position {
			get => offset;
			set => offset = value;
		}

		public override int Read(byte[] buffer, int offset, int count) => throw new NotImplementedException();

		public override long Seek(long offset, SeekOrigin origin) {
			switch (origin) {
			case SeekOrigin.Begin:
				this.offset = offset;
				break;

			case SeekOrigin.Current:
				this.offset += offset;
				break;

			case SeekOrigin.End:
				this.offset = length + offset;
				break;

			default:
				throw new NotSupportedException();
			}

			return this.offset;
		}

		public override void SetLength(long value) => length = value;

		public override void Write(byte[] buffer, int offset, int count) {
			this.offset += count;
			if (this.offset > length)
				length = this.offset;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Operations.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using dnlib.DotNet.Writer;
using de4dot.code.renamer;

namespace de4dot.code.deobfuscators {
	public enum OpDecryptString {
		None,
		Static,
		Dynamic,
	}

	public interface IOperations {
		bool KeepObfuscatorTypes { get; }
		MetadataFlags MetadataFlags { get; }
		RenamerFlags RenamerFlags { get; }
		OpDecryptString DecryptStrings { get; }
	}

	public class Operations : IOperations {
		public bool KeepObfuscatorTypes { get; set; }
		public MetadataFlags MetadataFlags { get; set; }
		public RenamerFlags RenamerFlags { get; set; }
		public OpDecryptString DecryptStrings { get; set; }
	}
}



================================================
File: de4dot.code/deobfuscators/ProxyCallFixerBase.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators {
	public abstract class ProxyCallFixerBase {
		protected ModuleDefMD module;
		protected List<MethodDef> delegateCreatorMethods = new List<MethodDef>();
		protected Dictionary<TypeDef, bool> delegateTypesDict = new Dictionary<TypeDef, bool>();
		protected int errors = 0;

		public int Errors => errors;

		protected class DelegateInfo {
			public IMethod methodRef;	// Method we should call
			public FieldDef field;		// Field holding the Delegate instance
			public OpCode callOpcode;
			public DelegateInfo(FieldDef field, IMethod methodRef, OpCode callOpcode) {
				this.field = field;
				this.methodRef = methodRef;
				this.callOpcode = callOpcode;
			}
		}

		public int RemovedDelegateCreatorCalls { get; set; }
		public IEnumerable<TypeDef> DelegateTypes => delegateTypesDict.Keys;

		public IEnumerable<TypeDef> DelegateCreatorTypes {
			get {
				foreach (var method in delegateCreatorMethods)
					yield return method.DeclaringType;
			}
		}

		public virtual IEnumerable<Tuple<MethodDef, string>> OtherMethods => new List<Tuple<MethodDef, string>>();
		public bool Detected => delegateCreatorMethods.Count != 0;
		protected ProxyCallFixerBase(ModuleDefMD module) => this.module = module;

		protected ProxyCallFixerBase(ModuleDefMD module, ProxyCallFixerBase oldOne) {
			this.module = module;
			foreach (var method in oldOne.delegateCreatorMethods)
				delegateCreatorMethods.Add(Lookup(method, "Could not find delegate creator method"));
			foreach (var kv in oldOne.delegateTypesDict)
				delegateTypesDict[Lookup(kv.Key, "Could not find delegate type")] = kv.Value;
		}

		protected DelegateInfo Copy(DelegateInfo di) {
			var method = Lookup(di.methodRef, "Could not find method ref");
			var field = Lookup(di.field, "Could not find delegate field");
			return new DelegateInfo(field, method, di.callOpcode);
		}

		protected T Lookup<T>(T def, string errorMessage) where T : class, ICodedToken =>
			DeobUtils.Lookup(module, def, errorMessage);

		protected void SetDelegateCreatorMethod(MethodDef delegateCreatorMethod) {
			if (delegateCreatorMethod == null)
				return;
			delegateCreatorMethods.Add(delegateCreatorMethod);
		}

		protected bool IsDelegateCreatorMethod(MethodDef method) {
			foreach (var m in delegateCreatorMethods) {
				if (m == method)
					return true;
			}
			return false;
		}

		protected virtual IEnumerable<TypeDef> GetDelegateTypes() {
			foreach (var type in module.Types) {
				if (type.BaseType == null || type.BaseType.FullName != "System.MulticastDelegate")
					continue;

				yield return type;
			}
		}

		protected class BlockInstr {
			public Block Block { get; set; }
			public int Index { get; set; }
		}

		protected class RemoveInfo {
			public int Index { get; set; }
			public DelegateInfo DelegateInfo { get; set; }
			public bool IsCall => DelegateInfo != null;
		}

		protected virtual bool ProxyCallIsObfuscated => false;

		public void Deobfuscate(Blocks blocks) {
			if (blocks.Method.DeclaringType != null && delegateTypesDict.ContainsKey(blocks.Method.DeclaringType))
				return;
			var allBlocks = blocks.MethodBlocks.GetAllBlocks();
			int loops = ProxyCallIsObfuscated ? 50 : 1;
			for (int i = 0; i < loops; i++) {
				if (!Deobfuscate(blocks, allBlocks))
					break;
			}
			DeobfuscateEnd(blocks, allBlocks);
		}

		protected abstract bool Deobfuscate(Blocks blocks, IList<Block> allBlocks);

		protected virtual void DeobfuscateEnd(Blocks blocks, IList<Block> allBlocks) {
		}

		protected static void Add(Dictionary<Block, List<RemoveInfo>> removeInfos, Block block, int index, DelegateInfo di) {
			if (!removeInfos.TryGetValue(block, out var list))
				removeInfos[block] = list = new List<RemoveInfo>();
			list.Add(new RemoveInfo {
				Index = index,
				DelegateInfo = di,
			});
		}

		protected bool FixProxyCalls(MethodDef method, Dictionary<Block, List<RemoveInfo>> removeInfos) {
			var gpContext = GenericParamContext.Create(method);
			foreach (var block in removeInfos.Keys) {
				var list = removeInfos[block];
				var removeIndexes = new List<int>(list.Count);
				foreach (var info in list) {
					if (info.IsCall) {
						var opcode = info.DelegateInfo.callOpcode;
						var newInstr = Instruction.Create(opcode, ReResolve(info.DelegateInfo.methodRef, gpContext));
						block.Replace(info.Index, 1, newInstr);
					}
					else
						removeIndexes.Add(info.Index);
				}
				if (removeIndexes.Count > 0)
					block.Remove(removeIndexes);
			}

			return removeInfos.Count > 0;
		}

		IMethod ReResolve(IMethod method, GenericParamContext gpContext) {
			if (method.IsMethodSpec || method.IsMemberRef)
				method = module.ResolveToken(method.MDToken.Raw, gpContext) as IMethod ?? method;
			return method;
		}
	}

	// Fixes proxy calls that call the delegate inline in the code, eg.:
	//		ldsfld delegate_instance
	//		...push args...
	//		call Invoke
	public abstract class ProxyCallFixer1 : ProxyCallFixerBase {
		FieldDefAndDeclaringTypeDict<DelegateInfo> fieldToDelegateInfo = new FieldDefAndDeclaringTypeDict<DelegateInfo>();

		protected ProxyCallFixer1(ModuleDefMD module)
			: base(module) {
		}

		protected ProxyCallFixer1(ModuleDefMD module, ProxyCallFixer1 oldOne)
			: base(module, oldOne) {
			foreach (var key in oldOne.fieldToDelegateInfo.GetKeys())
				fieldToDelegateInfo.Add(Lookup(key, "Could not find field"), Copy(oldOne.fieldToDelegateInfo.Find(key)));
		}

		protected void AddDelegateInfo(DelegateInfo di) => fieldToDelegateInfo.Add(di.field, di);

		protected DelegateInfo GetDelegateInfo(IField field) {
			if (field == null)
				return null;
			return fieldToDelegateInfo.Find(field);
		}

		public void Find() {
			if (delegateCreatorMethods.Count == 0)
				return;

			Logger.v("Finding all proxy delegates");
			foreach (var tmp in GetDelegateTypes()) {
				var type = tmp;
				var cctor = type.FindStaticConstructor();
				if (cctor == null || !cctor.HasBody)
					continue;
				if (!type.HasFields)
					continue;

				object context = CheckCctor(ref type, cctor);
				if (context == null)
					continue;

				Logger.v("Found proxy delegate: {0} ({1:X8})", Utils.RemoveNewlines(type), type.MDToken.ToUInt32());
				RemovedDelegateCreatorCalls++;

				Logger.Instance.Indent();
				foreach (var field in type.Fields) {
					if (!field.IsStatic)
						continue;

					GetCallInfo(context, field, out var calledMethod, out var callOpcode);

					if (calledMethod == null)
						continue;
					AddDelegateInfo(new DelegateInfo(field, calledMethod, callOpcode));
					Logger.v("Field: {0}, Opcode: {1}, Method: {2} ({3:X8})",
								Utils.RemoveNewlines(field.Name),
								callOpcode,
								Utils.RemoveNewlines(calledMethod),
								calledMethod.MDToken.Raw);
				}
				Logger.Instance.DeIndent();
				delegateTypesDict[type] = true;
			}
		}

		protected abstract object CheckCctor(ref TypeDef type, MethodDef cctor);
		protected abstract void GetCallInfo(object context, FieldDef field, out IMethod calledMethod, out OpCode callOpcode);

		protected override bool Deobfuscate(Blocks blocks, IList<Block> allBlocks) {
			var removeInfos = new Dictionary<Block, List<RemoveInfo>>();

			foreach (var block in allBlocks) {
				var instrs = block.Instructions;
				for (int i = 0; i < instrs.Count; i++) {
					var instr = instrs[i];
					if (instr.OpCode != OpCodes.Ldsfld)
						continue;

					var di = GetDelegateInfo(instr.Operand as IField);
					if (di == null)
						continue;

					var callInfo = FindProxyCall(di, block, i);
					if (callInfo != null) {
						Add(removeInfos, block, i, null);
						Add(removeInfos, callInfo.Block, callInfo.Index, di);
					}
					else {
						errors++;
						Logger.w("Could not fix proxy call. Method: {0} ({1:X8}), Proxy type: {2} ({3:X8})",
							Utils.RemoveNewlines(blocks.Method),
							blocks.Method.MDToken.ToInt32(),
							Utils.RemoveNewlines(di.field.DeclaringType),
							di.field.DeclaringType.MDToken.ToInt32());
					}
				}
			}

			return FixProxyCalls(blocks.Method, removeInfos);
		}

		protected virtual BlockInstr FindProxyCall(DelegateInfo di, Block block, int index) =>
			FindProxyCall(di, block, index, new Dictionary<Block, bool>(), 1);

		BlockInstr FindProxyCall(DelegateInfo di, Block block, int index, Dictionary<Block, bool> visited, int stack) {
			if (visited.ContainsKey(block))
				return null;
			if (index <= 0)
				visited[block] = true;

			var instrs = block.Instructions;
			for (int i = index + 1; i < instrs.Count; i++) {
				if (stack <= 0)
					return null;
				var instr = instrs[i];
				instr.Instruction.UpdateStack(ref stack, false);
				if (stack < 0)
					return null;

				if (instr.OpCode != OpCodes.Call && instr.OpCode != OpCodes.Callvirt) {
					if (stack <= 0)
						return null;
					continue;
				}
				var calledMethod = instr.Operand as IMethod;
				if (calledMethod == null)
					return null;
				if (stack != (DotNetUtils.HasReturnValue(calledMethod) ? 1 : 0))
					continue;
				if (calledMethod.Name != "Invoke")
					return null;

				return new BlockInstr {
					Block = block,
					Index = i,
				};
			}
			if (stack <= 0)
				return null;

			foreach (var target in block.GetTargets()) {
				var info = FindProxyCall(di, target, -1, visited, stack);
				if (info != null)
					return info;
			}

			return null;
		}

		protected override void DeobfuscateEnd(Blocks blocks, IList<Block> allBlocks) =>
			FixBrokenCalls(blocks.Method, allBlocks);

		// The obfuscator could be buggy and call a proxy delegate without pushing the
		// instance field. SA has done it, so let's fix it.
		void FixBrokenCalls(MethodDef obfuscatedMethod, IList<Block> allBlocks) {
			foreach (var block in allBlocks) {
				var instrs = block.Instructions;
				for (int i = 0; i < instrs.Count; i++) {
					var call = instrs[i];
					if (call.OpCode != OpCodes.Call && call.OpCode != OpCodes.Callvirt)
						continue;
					var methodRef = call.Operand as IMethod;
					if (methodRef == null || methodRef.Name != "Invoke")
						continue;
					var method = DotNetUtils.GetMethod2(module, methodRef);
					if (method == null || method.DeclaringType == null)
						continue;
					if (!delegateTypesDict.ContainsKey(method.DeclaringType))
						continue;

					// Oooops!!! The obfuscator is buggy. Well, let's hope it is, or it's my code. ;)

					Logger.w("Holy obfuscator bugs, Batman! Found a proxy delegate call with no instance push in {0:X8}. Replacing it with a throw...", obfuscatedMethod.MDToken.ToInt32());
					block.Insert(i, OpCodes.Ldnull.ToInstruction());
					block.Replace(i + 1, 1, OpCodes.Throw.ToInstruction());
					i++;
				}
			}
		}
	}

	// Fixes proxy calls that call a static method which then calls
	// Invoke() on a delegate instance, eg.:
	//		...push args...
	//		call static method
	public abstract class ProxyCallFixer2 : ProxyCallFixerBase {
		MethodDefAndDeclaringTypeDict<DelegateInfo> proxyMethodToDelegateInfo = new MethodDefAndDeclaringTypeDict<DelegateInfo>();

		protected ProxyCallFixer2(ModuleDefMD module)
			: base(module) {
		}

		protected ProxyCallFixer2(ModuleDefMD module, ProxyCallFixer2 oldOne)
			: base(module, oldOne) {
			foreach (var oldMethod in oldOne.proxyMethodToDelegateInfo.GetKeys()) {
				var oldDi = oldOne.proxyMethodToDelegateInfo.Find(oldMethod);
				var method = Lookup(oldMethod, "Could not find proxy method");
				proxyMethodToDelegateInfo.Add(method, Copy(oldDi));
			}
		}

		public void Find() {
			if (delegateCreatorMethods.Count == 0)
				return;

			Logger.v("Finding all proxy delegates");
			Find2();
		}

		protected void Find2() {
			foreach (var type in GetDelegateTypes()) {
				var cctor = type.FindStaticConstructor();
				if (cctor == null || !cctor.HasBody)
					continue;
				if (!type.HasFields)
					continue;

				object context = CheckCctor(type, cctor);
				if (context == null)
					continue;

				Logger.v("Found proxy delegate: {0} ({1:X8})", Utils.RemoveNewlines(type), type.MDToken.ToUInt32());
				RemovedDelegateCreatorCalls++;
				var fieldToMethod = GetFieldToMethodDictionary(type);

				Logger.Instance.Indent();
				foreach (var field in type.Fields) {
					if (!fieldToMethod.TryGetValue(field, out var proxyMethod))
						continue;

					GetCallInfo(context, field, out var calledMethod, out var callOpcode);

					if (calledMethod == null)
						continue;
					Add(proxyMethod, new DelegateInfo(field, calledMethod, callOpcode));
					Logger.v("Field: {0}, Opcode: {1}, Method: {2} ({3:X8})",
								Utils.RemoveNewlines(field.Name),
								callOpcode,
								Utils.RemoveNewlines(calledMethod),
								calledMethod.MDToken.ToUInt32());
				}
				Logger.Instance.DeIndent();
				delegateTypesDict[type] = true;
			}
		}

		protected void Add(MethodDef method, DelegateInfo di) => proxyMethodToDelegateInfo.Add(method, di);
		protected abstract object CheckCctor(TypeDef type, MethodDef cctor);
		protected abstract void GetCallInfo(object context, FieldDef field, out IMethod calledMethod, out OpCode callOpcode);

		Dictionary<FieldDef, MethodDef> GetFieldToMethodDictionary(TypeDef type) {
			var dict = new Dictionary<FieldDef, MethodDef>();
			foreach (var method in type.Methods) {
				if (!method.IsStatic || !method.HasBody || method.Name == ".cctor")
					continue;

				var instructions = method.Body.Instructions;
				for (int i = 0; i < instructions.Count; i++) {
					var instr = instructions[i];
					if (instr.OpCode.Code != Code.Ldsfld)
						continue;
					var field = instr.Operand as FieldDef;
					if (field == null)
						continue;

					dict[field] = method;
					break;
				}
			}
			return dict;
		}

		protected override bool Deobfuscate(Blocks blocks, IList<Block> allBlocks) {
			var removeInfos = new Dictionary<Block, List<RemoveInfo>>();

			foreach (var block in allBlocks) {
				var instrs = block.Instructions;
				for (int i = 0; i < instrs.Count; i++) {
					var instr = instrs[i];
					if (instr.OpCode != OpCodes.Call)
						continue;

					var method = instr.Operand as IMethod;
					if (method == null)
						continue;
					var di = proxyMethodToDelegateInfo.Find(method);
					if (di == null)
						continue;
					Add(removeInfos, block, i, di);
				}
			}

			return FixProxyCalls(blocks.Method, removeInfos);
		}
	}

	// Fixes proxy calls that call a static method with the instance of
	// a delegate as the last arg, which then calls the Invoke method.
	//		...push args...
	//		ldsfld delegate instance
	//		call static method
	public abstract class ProxyCallFixer3 : ProxyCallFixer1 {
		protected ProxyCallFixer3(ModuleDefMD module)
			: base(module) {
		}

		protected ProxyCallFixer3(ModuleDefMD module, ProxyCallFixer3 oldOne)
			: base(module, oldOne) {
		}

		protected override BlockInstr FindProxyCall(DelegateInfo di, Block block, int index) {
			index++;
			if (index >= block.Instructions.Count)
				return null;
			var calledMethod = GetCalledMethod(block.Instructions[index]);
			if (calledMethod == null)
				return null;
			return new BlockInstr {
				Block = block,
				Index = index,
			};
		}

		static IMethod GetCalledMethod(Instr instr) {
			if (instr.OpCode.Code != Code.Call)
				return null;
			return instr.Operand as IMethod;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/QuickLZ.cs
================================================
// QuickLZ data compression library
// Copyright (C) 2006-2011 Lasse Mikkel Reinhold
// lar@quicklz.com
//
// QuickLZ can be used for free under the GPL 1, 2 or 3 license (where anything 
// released into public must be open source) or under a commercial license if such 
// has been acquired (see http://www.quicklz.com/order.html). The commercial license 
// does not cover derived or ported versions created by third parties under GPL.

// Port of QuickLZ to C# by de4dot@gmail.com. This code is most likely not working now.

using System;

namespace de4dot.code.deobfuscators {
	public class QuickLZBase {
		protected static uint Read32(byte[] data, int index) => BitConverter.ToUInt32(data, index);

		// Can't use Array.Copy() when data overlaps so here's one that works
		protected static void Copy(byte[] src, int srcIndex, byte[] dst, int dstIndex, int size) {
			for (int i = 0; i < size; i++)
				dst[dstIndex++] = src[srcIndex++];
		}

		static int[] indexInc = new int[] { 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0 };
		public static void Decompress(byte[] inData, int inIndex, byte[] outData) {
			int decompressedLength = outData.Length;
			int outIndex = 0;
			uint val1 = 1;
			uint count;
			int size;

			while (true) {
				if (val1 == 1) {
					val1 = Read32(inData, inIndex);
					inIndex += 4;
				}
				uint val2 = Read32(inData, inIndex);
				if ((val1 & 1) == 1) {
					val1 >>= 1;
					if ((val2 & 3) == 0) {
						count = (val2 & 0xFF) >> 2;
						Copy(outData, (int)(outIndex - count), outData, outIndex, 3);
						outIndex += 3;
						inIndex++;
					}
					else if ((val2 & 2) == 0) {
						count = (val2 & 0xFFFF) >> 2;
						Copy(outData, (int)(outIndex - count), outData, outIndex, 3);
						outIndex += 3;
						inIndex += 2;
					}
					else if ((val2 & 1) == 0) {
						size = (int)((val2 >> 2) & 0x0F) + 3;
						count = (val2 & 0xFFFF) >> 6;
						Copy(outData, (int)(outIndex - count), outData, outIndex, size);
						outIndex += size;
						inIndex += 2;
					}
					else if ((val2 & 4) == 0) {
						size = (int)((val2 >> 3) & 0x1F) + 3;
						count = (val2 & 0xFFFFFF) >> 8;
						Copy(outData, (int)(outIndex - count), outData, outIndex, size);
						outIndex += size;
						inIndex += 3;
					}
					else if ((val2 & 8) == 0) {
						count = val2 >> 15;
						if (count != 0) {
							size = (int)((val2 >> 4) & 0x07FF) + 3;
							inIndex += 4;
						}
						else {
							size = (int)Read32(inData, inIndex + 4);
							count = Read32(inData, inIndex + 8);
							inIndex += 12;
						}
						Copy(outData, (int)(outIndex - count), outData, outIndex, size);
						outIndex += size;
					}
					else {
						byte b = (byte)(val2 >> 16);
						size = (int)(val2 >> 4) & 0x0FFF;
						if (size == 0) {
							size = (int)Read32(inData, inIndex + 3);
							inIndex += 7;
						}
						else
							inIndex += 3;
						for (int i = 0; i < size; i++)
							outData[outIndex++] = b;
					}
				}
				else {
					Copy(inData, inIndex, outData, outIndex, 4);
					int index = (int)(val1 & 0x0F);
					outIndex += indexInc[index];
					inIndex += indexInc[index];
					val1 >>= indexInc[index];
					if (outIndex >= decompressedLength - 4)
						break;
				}
			}
			while (outIndex < decompressedLength) {
				if (val1 == 1) {
					inIndex += 4;
					val1 = 0x80000000;
				}
				outData[outIndex++] = inData[inIndex++];
				val1 >>= 1;
			}
		}
	}

	public class QuickLZ : QuickLZBase {
		static int DEFAULT_QCLZ_SIG = 0x5A4C4351;	// "QCLZ"

		public static bool IsCompressed(byte[] data) {
			if (data.Length < 4)
				return false;
			return BitConverter.ToInt32(data, 0) == DEFAULT_QCLZ_SIG;
		}

		public static byte[] Decompress(byte[] inData) => Decompress(inData, DEFAULT_QCLZ_SIG);

		public static byte[] Decompress(byte[] inData, int sig) {
			/*int mode =*/ BitConverter.ToInt32(inData, 4);
			int compressedLength = BitConverter.ToInt32(inData, 8);
			int decompressedLength = BitConverter.ToInt32(inData, 12);
			bool isDataCompressed = BitConverter.ToInt32(inData, 16) == 1;
			int headerLength = 32;
			if (BitConverter.ToInt32(inData, 0) != sig || BitConverter.ToInt32(inData, compressedLength - 4) != sig)
				throw new ApplicationException("No QCLZ sig");

			byte[] outData = new byte[decompressedLength];

			if (!isDataCompressed) {
				Copy(inData, headerLength, outData, 0, decompressedLength);
				return outData;
			}

			Decompress(inData, headerLength, outData);
			return outData;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/RandomNameChecker.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;

namespace de4dot.code.deobfuscators {
	public static class RandomNameChecker {
		static Regex noUpper = new Regex(@"^[^A-Z]+$");
		static Regex allUpper = new Regex(@"^[A-Z]+$");

		public static bool IsNonRandom(string name) {
			if (name.Length < 5)
				return true;
			if (noUpper.IsMatch(name))
				return true;
			if (allUpper.IsMatch(name))
				return true;

			for (int i = 0; i < name.Length - 1; i++) {
				if (IsDigit(name[i]))
					return false;
				if (i > 0 && IsUpper(name[i]) && IsUpper(name[i - 1]))
					return false;
			}

			var words = GetCamelWords(name);
			int vowels = 0;
			foreach (var word in words) {
				if (word.Length > 1 && HasVowel(word))
					vowels++;
			}
			switch (words.Count) {
			case 1:
				return vowels == words.Count;
			case 2:
			case 3:
				return vowels >= 1;
			case 4:
			case 5:
				return vowels >= 2;
			case 6:
				return vowels >= 3;
			case 7:
				return vowels >= 4;
			default:
				return vowels >= words.Count - 4;
			}
		}

		static bool HasVowel(string s) {
			foreach (var c in s) {
				switch (c) {
				case 'A':
				case 'a':
				case 'E':
				case 'e':
				case 'I':
				case 'i':
				case 'O':
				case 'o':
				case 'U':
				case 'u':
				case 'Y':
				case 'y':
					return true;
				}
			}
			return false;
		}

		static List<string> GetCamelWords(string name) {
			var words = new List<string>();
			var sb = new StringBuilder();

			for (int i = 0; i < name.Length; i++) {
				char c = name[i];
				if (IsUpper(c)) {
					if (sb.Length > 0)
						words.Add(sb.ToString());
					sb.Length = 0;
				}
				sb.Append(c);
			}
			if (sb.Length > 0)
				words.Add(sb.ToString());

			return words;
		}

		// Returns true if random, false if unknown
		public static bool IsRandom(string name) {
			int len = name.Length;
			if (len < 5)
				return false;

			var typeWords = GetTypeWords(name);

			if (CountNumbers(typeWords, 2))
				return true;

			CountTypeWords(typeWords, out int lower, out int upper, out int digits);
			if (upper >= 3)
				return true;
			bool hasTwoUpperWords = upper == 2;

			foreach (var word in typeWords) {
				if (word.Length > 1 && IsDigit(word[0]))
					return true;
			}

			// Check for: lower, digit, lower
			for (int i = 2; i < typeWords.Count; i++) {
				if (IsDigit(typeWords[i - 1][0]) && IsLower(typeWords[i - 2][0]) && IsLower(typeWords[i][0]))
					return true;
			}

			if (hasTwoUpperWords && HasDigit(name))
				return true;

			// Check if it ends in lower, upper, digit
			if (IsLower(name[len - 3]) && IsUpper(name[len - 2]) && IsDigit(name[len - 1]))
				return true;

			return false;
		}

		static bool HasDigit(string s) {
			foreach (var c in s) {
				if (IsDigit(c))
					return true;
			}
			return false;
		}

		static List<string> GetTypeWords(string s) {
			var words = new List<string>();
			var sb = new StringBuilder();

			for (int i = 0; i < s.Length; ) {
				if (IsDigit(s[i])) {
					sb.Length = 0;
					while (i < s.Length && IsDigit(s[i]))
						sb.Append(s[i++]);
					words.Add(sb.ToString());
				}
				else if (IsUpper(s[i])) {
					sb.Length = 0;
					while (i < s.Length && IsUpper(s[i]))
						sb.Append(s[i++]);
					words.Add(sb.ToString());
				}
				else if (IsLower(s[i])) {
					sb.Length = 0;
					while (i < s.Length && IsLower(s[i]))
						sb.Append(s[i++]);
					words.Add(sb.ToString());
				}
				else {
					sb.Length = 0;
					while (i < s.Length) {
						if (IsDigit(s[i]) || IsUpper(s[i]) || IsLower(s[i]))
							break;
						sb.Append(s[i++]);
					}
					words.Add(sb.ToString());
				}
			}

			return words;
		}

		static bool CountNumbers(List<string> words, int numbers) {
			int num = 0;
			foreach (var word in words) {
				if (string.IsNullOrEmpty(word))
					continue;
				if (IsDigit(word[0]) && ++num >= numbers)
					return true;
			}
			return false;
		}

		// 2+ chars only
		static void CountTypeWords(List<string> words, out int lower, out int upper, out int digits) {
			lower = 0;
			upper = 0;
			digits = 0;

			foreach (var word in words) {
				if (word.Length <= 1)
					continue;
				char c = word[0];
				if (IsDigit(c))
					digits++;
				else if (IsLower(c))
					lower++;
				else if (IsUpper(c))
					upper++;
			}
		}

		static bool IsLower(char c) => 'a' <= c && c <= 'z';
		static bool IsUpper(char c) => 'A' <= c && c <= 'Z';
		static bool IsDigit(char c) => '0' <= c && c <= '9';
	}
}



================================================
File: de4dot.code/deobfuscators/StringCounts.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace de4dot.code.deobfuscators {
	public class StringCounts {
		Dictionary<string, int> strings = new Dictionary<string, int>(StringComparer.Ordinal);

		public IEnumerable<string> Strings => strings.Keys;
		public int NumStrings => strings.Count;

		public void Add(string s) {
			strings.TryGetValue(s, out int count);
			strings[s] = count + 1;
		}

		public bool Exists(string s) {
			if (s == null)
				return false;
			return strings.ContainsKey(s);
		}

		public bool All(IList<string> list) {
			foreach (var s in list) {
				if (!Exists(s))
					return false;
			}
			return true;
		}

		public bool Exactly(IList<string> list) => list.Count == strings.Count && All(list);

		public int Count(string s) {
			strings.TryGetValue(s, out int count);
			return count;
		}
	}

	public class FieldTypes : StringCounts {
		public FieldTypes(TypeDef type) => Initialize(type.Fields);
		public FieldTypes(IEnumerable<FieldDef> fields) => Initialize(fields);

		void Initialize(IEnumerable<FieldDef> fields) {
			if (fields == null)
				return;
			foreach (var field in fields) {
				var type = field.FieldSig.GetFieldType();
				if (type != null)
					Add(type.FullName);
			}
		}
	}

	public class LocalTypes : StringCounts {
		public LocalTypes(MethodDef method) {
			if (method != null && method.Body != null)
				Initialize(method.Body.Variables);
		}

		public LocalTypes(IEnumerable<Local> locals) => Initialize(locals);

		void Initialize(IEnumerable<Local> locals) {
			if (locals == null)
				return;
			foreach (var local in locals)
				Add(local.Type.FullName);
		}
	}
}



================================================
File: de4dot.code/deobfuscators/TypesRestorer.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators {
	// Restore the type of all fields / parameters that have had their type turned into object.
	// This thing requires a lot more code than I have time to do now (similar to symbol renaming)
	// so it will be a basic implementation only.
	public abstract class TypesRestorerBase {
		ModuleDef module;
		List<MethodDef> allMethods;
		Dictionary<Parameter, TypeInfo<Parameter>> argInfos = new Dictionary<Parameter, TypeInfo<Parameter>>();
		TypeInfo<Parameter> methodReturnInfo;
		Dictionary<IField, TypeInfo<FieldDef>> fieldWrites = new Dictionary<IField, TypeInfo<FieldDef>>(FieldEqualityComparer.CompareDeclaringTypes);
		Dictionary<int, UpdatedMethod> updatedMethods = new Dictionary<int, UpdatedMethod>();
		Dictionary<int, UpdatedField> updatedFields = new Dictionary<int, UpdatedField>();

		class UpdatedMethod {
			public int token;
			public TypeSig[] newArgTypes;
			public TypeSig newReturnType;

			public UpdatedMethod(MethodDef method) {
				token = method.MDToken.ToInt32();
				newArgTypes = new TypeSig[DotNetUtils.GetArgsCount(method)];
			}
		}

		class UpdatedField {
			public int token;
			public TypeSig newFieldType;
			public UpdatedField(FieldDef field) => token = field.MDToken.ToInt32();
		}

		class TypeInfo<T> {
			Dictionary<TypeSig, bool> types = new Dictionary<TypeSig, bool>(TypeEqualityComparer.Instance);
			public TypeSig newType = null;
			public T arg;
			bool newobjTypes;

			public Dictionary<TypeSig, bool> Types => types;
			public TypeInfo(T arg) => this.arg = arg;
			public void Add(TypeSig type) => Add(type, false);

			public void Add(TypeSig type, bool wasNewobj) {
				if (wasNewobj) {
					if (!newobjTypes)
						Clear();
					newobjTypes = true;
				}
				else if (newobjTypes)
					return;
				types[type] = true;
			}

			public void Clear() => types.Clear();

			public bool UpdateNewType(ModuleDef module) {
				if (types.Count == 0)
					return false;

				TypeSig theNewType = null;
				foreach (var key in types.Keys) {
					if (theNewType == null) {
						theNewType = key;
						continue;
					}
					theNewType = GetCommonBaseClass(module, theNewType, key);
					if (theNewType == null)
						break;
				}
				if (theNewType == null)
					return false;
				if (new SigComparer().Equals(theNewType, newType))
					return false;

				newType = theNewType;
				return true;
			}
		}

		public TypesRestorerBase(ModuleDef module) => this.module = module;

		UpdatedMethod GetUpdatedMethod(MethodDef method) {
			int token = method.MDToken.ToInt32();
			if (updatedMethods.TryGetValue(token, out var updatedMethod))
				return updatedMethod;
			return updatedMethods[token] = new UpdatedMethod(method);
		}

		UpdatedField GetUpdatedField(FieldDef field) {
			int token = field.MDToken.ToInt32();
			if (updatedFields.TryGetValue(token, out var updatedField))
				return updatedField;
			return updatedFields[token] = new UpdatedField(field);
		}

		public void Deobfuscate() {
			allMethods = new List<MethodDef>();

			AddAllMethods();
			AddAllFields();

			DeobfuscateLoop();

			RestoreFieldTypes();
			RestoreMethodTypes();
		}

		void AddAllMethods() {
			foreach (var type in module.GetTypes())
				AddMethods(type.Methods);
		}

		void AddMethods(IEnumerable<MethodDef> methods) => allMethods.AddRange(methods);
		void AddMethod(MethodDef method) => allMethods.Add(method);

		void AddAllFields() {
			foreach (var type in module.GetTypes()) {
				foreach (var field in type.Fields) {
					if (!IsUnknownType(field))
						continue;

					fieldWrites[field] = new TypeInfo<FieldDef>(field);
				}
			}
		}

		void DeobfuscateLoop() {
			for (int i = 0; i < 10; i++) {
				bool modified = false;
				modified |= DeobfuscateFields();
				modified |= DeobfuscateMethods();
				if (!modified)
					break;
			}
		}

		void RestoreFieldTypes() {
			var fields = new List<UpdatedField>(updatedFields.Values);
			if (fields.Count == 0)
				return;

			Logger.v("Changing field types to real type");
			fields.Sort((a, b) => a.token.CompareTo(b.token));
			Logger.Instance.Indent();
			foreach (var updatedField in fields)
				Logger.v("Field {0:X8}: type {1} ({2:X8})", updatedField.token, Utils.RemoveNewlines(updatedField.newFieldType.FullName), updatedField.newFieldType.MDToken.ToInt32());
			Logger.Instance.DeIndent();
		}

		void RestoreMethodTypes() {
			var methods = new List<UpdatedMethod>(updatedMethods.Values);
			if (methods.Count == 0)
				return;

			Logger.v("Changing method args and return types to real type");
			methods.Sort((a, b) => a.token.CompareTo(b.token));
			Logger.Instance.Indent();
			foreach (var updatedMethod in methods) {
				Logger.v("Method {0:X8}", updatedMethod.token);
				Logger.Instance.Indent();
				if (updatedMethod.newReturnType != null) {
					Logger.v("ret: {0} ({1:X8})",
							Utils.RemoveNewlines(updatedMethod.newReturnType.FullName),
							updatedMethod.newReturnType.MDToken.ToInt32());
				}
				for (int i = 0; i < updatedMethod.newArgTypes.Length; i++) {
					var updatedArg = updatedMethod.newArgTypes[i];
					if (updatedArg == null)
						continue;
					Logger.v("arg {0}: {1} ({2:X8})",
							i,
							Utils.RemoveNewlines(updatedArg.FullName),
							updatedArg.MDToken.ToInt32());
				}
				Logger.Instance.DeIndent();
			}
			Logger.Instance.DeIndent();
		}

		bool DeobfuscateMethods() {
			bool modified = false;
			foreach (var method in allMethods) {
				methodReturnInfo = new TypeInfo<Parameter>(method.Parameters.ReturnParameter);
				DeobfuscateMethod(method);

				if (methodReturnInfo.UpdateNewType(module)) {
					GetUpdatedMethod(method).newReturnType = methodReturnInfo.newType;
					method.MethodSig.RetType = methodReturnInfo.newType;
					modified = true;
				}

				foreach (var info in argInfos.Values) {
					if (info.UpdateNewType(module)) {
						GetUpdatedMethod(method).newArgTypes[info.arg.Index] = info.newType;
						info.arg.Type = info.newType;
						modified = true;
					}
				}
			}
			return modified;
		}

		static int SortTypeInfos(TypeInfo<Parameter> a, TypeInfo<Parameter> b) {
			if (a.arg.Method.MDToken.ToInt32() < b.arg.Method.MDToken.ToInt32()) return -1;
			if (a.arg.Method.MDToken.ToInt32() > b.arg.Method.MDToken.ToInt32()) return 1;

			return a.arg.Index.CompareTo(b.arg.Index);
		}

		void DeobfuscateMethod(MethodDef method) {
			if (!method.IsStatic || method.Body == null)
				return;

			bool fixReturnType = IsUnknownType(method.MethodSig.GetRetType());

			argInfos.Clear();
			foreach (var arg in method.Parameters) {
				if (arg.IsHiddenThisParameter)
					continue;
				if (!IsUnknownType(arg))
					continue;
				argInfos[arg] = new TypeInfo<Parameter>(arg);
			}
			if (argInfos.Count == 0 && !fixReturnType)
				return;

			var methodParams = method.Parameters;
			PushedArgs pushedArgs;
			var instructions = method.Body.Instructions;
			for (int i = 0; i < instructions.Count; i++) {
				var instr = instructions[i];
				switch (instr.OpCode.Code) {
				case Code.Ret:
					if (!fixReturnType)
						break;
					bool wasNewobj;
					var type = GetLoadedType(method, method, instructions, i, out wasNewobj);
					if (type == null)
						break;
					methodReturnInfo.Add(type);
					break;

				case Code.Call:
				case Code.Calli:
				case Code.Callvirt:
				case Code.Newobj:
					pushedArgs = MethodStack.GetPushedArgInstructions(instructions, i);
					var calledMethod = instr.Operand as IMethod;
					if (calledMethod == null)
						break;
					var calledMethodParams = DotNetUtils.GetArgs(calledMethod);
					for (int j = 0; j < pushedArgs.NumValidArgs; j++) {
						int calledMethodParamIndex = calledMethodParams.Count - j - 1;
						var ldInstr = pushedArgs.GetEnd(j);
						switch (ldInstr.OpCode.Code) {
						case Code.Ldarg:
						case Code.Ldarg_S:
						case Code.Ldarg_0:
						case Code.Ldarg_1:
						case Code.Ldarg_2:
						case Code.Ldarg_3:
							AddMethodArgType(method, GetParameter(methodParams, ldInstr), DotNetUtils.GetArg(calledMethodParams, calledMethodParamIndex));
							break;

						default:
							break;
						}
					}
					break;

				case Code.Castclass:
					pushedArgs = MethodStack.GetPushedArgInstructions(instructions, i);
					if (pushedArgs.NumValidArgs < 1)
						break;
					AddMethodArgType(method, GetParameter(methodParams, pushedArgs.GetEnd(0)), instr.Operand as ITypeDefOrRef);
					break;

				case Code.Stloc:
				case Code.Stloc_S:
				case Code.Stloc_0:
				case Code.Stloc_1:
				case Code.Stloc_2:
				case Code.Stloc_3:
					pushedArgs = MethodStack.GetPushedArgInstructions(instructions, i);
					if (pushedArgs.NumValidArgs < 1)
						break;
					AddMethodArgType(method, GetParameter(methodParams, pushedArgs.GetEnd(0)), instr.GetLocal(method.Body.Variables));
					break;

				case Code.Stsfld:
					pushedArgs = MethodStack.GetPushedArgInstructions(instructions, i);
					if (pushedArgs.NumValidArgs < 1)
						break;
					AddMethodArgType(method, GetParameter(methodParams, pushedArgs.GetEnd(0)), instr.Operand as IField);
					break;

				case Code.Stfld:
					pushedArgs = MethodStack.GetPushedArgInstructions(instructions, i);
					if (pushedArgs.NumValidArgs >= 1) {
						var field = instr.Operand as IField;
						AddMethodArgType(method, GetParameter(methodParams, pushedArgs.GetEnd(0)), field);
						if (pushedArgs.NumValidArgs >= 2 && field != null)
							AddMethodArgType(method, GetParameter(methodParams, pushedArgs.GetEnd(1)), field.DeclaringType);
					}
					break;

				case Code.Ldfld:
				case Code.Ldflda:
					pushedArgs = MethodStack.GetPushedArgInstructions(instructions, i);
					if (pushedArgs.NumValidArgs < 1)
						break;
					AddMethodArgType(method, GetParameter(methodParams, pushedArgs.GetEnd(0)), instr.Operand as IField);
					break;

				//TODO: For better results, these should be checked:
				case Code.Starg:
				case Code.Starg_S:

				case Code.Ldelema:
				case Code.Ldelem:
				case Code.Ldelem_I:
				case Code.Ldelem_I1:
				case Code.Ldelem_I2:
				case Code.Ldelem_I4:
				case Code.Ldelem_I8:
				case Code.Ldelem_R4:
				case Code.Ldelem_R8:
				case Code.Ldelem_Ref:
				case Code.Ldelem_U1:
				case Code.Ldelem_U2:
				case Code.Ldelem_U4:

				case Code.Ldind_I:
				case Code.Ldind_I1:
				case Code.Ldind_I2:
				case Code.Ldind_I4:
				case Code.Ldind_I8:
				case Code.Ldind_R4:
				case Code.Ldind_R8:
				case Code.Ldind_Ref:
				case Code.Ldind_U1:
				case Code.Ldind_U2:
				case Code.Ldind_U4:

				case Code.Ldobj:

				case Code.Stelem:
				case Code.Stelem_I:
				case Code.Stelem_I1:
				case Code.Stelem_I2:
				case Code.Stelem_I4:
				case Code.Stelem_I8:
				case Code.Stelem_R4:
				case Code.Stelem_R8:
				case Code.Stelem_Ref:

				case Code.Stind_I:
				case Code.Stind_I1:
				case Code.Stind_I2:
				case Code.Stind_I4:
				case Code.Stind_I8:
				case Code.Stind_R4:
				case Code.Stind_R8:
				case Code.Stind_Ref:

				case Code.Stobj:
				default:
					break;
				}
			}
		}

		static Parameter GetParameter(IList<Parameter> parameters, Instruction instr) {
			switch (instr.OpCode.Code) {
			case Code.Ldarg:
			case Code.Ldarg_S:
			case Code.Ldarg_0:
			case Code.Ldarg_1:
			case Code.Ldarg_2:
			case Code.Ldarg_3:
				return instr.GetParameter(parameters);

			default:
				return null;
			}
		}

		bool AddMethodArgType(IGenericParameterProvider gpp, Parameter methodParam, IField field) {
			if (field == null)
				return false;
			return AddMethodArgType(gpp, methodParam, field.FieldSig.GetFieldType());
		}

		bool AddMethodArgType(IGenericParameterProvider gpp, Parameter methodParam, Local otherLocal) {
			if (otherLocal == null)
				return false;
			return AddMethodArgType(gpp, methodParam, otherLocal.Type);
		}

		bool AddMethodArgType(IGenericParameterProvider gpp, Parameter methodParam, Parameter otherParam) {
			if (otherParam == null)
				return false;
			return AddMethodArgType(gpp, methodParam, otherParam.Type);
		}

		bool AddMethodArgType(IGenericParameterProvider gpp, Parameter methodParam, ITypeDefOrRef type) =>
			AddMethodArgType(gpp, methodParam, type.ToTypeSig());

		bool AddMethodArgType(IGenericParameterProvider gpp, Parameter methodParam, TypeSig type) {
			if (methodParam == null || type == null)
				return false;

			if (!IsValidType(gpp, type))
				return false;

			if (!argInfos.TryGetValue(methodParam, out var info))
				return false;
			if (info.Types.ContainsKey(type))
				return false;

			info.Add(type);
			return true;
		}

		bool DeobfuscateFields() {
			foreach (var info in fieldWrites.Values)
				info.Clear();

			foreach (var method in allMethods) {
				if (method.Body == null)
					continue;
				var instructions = method.Body.Instructions;
				for (int i = 0; i < instructions.Count; i++) {
					var instr = instructions[i];
					TypeSig fieldType = null;
					TypeInfo<FieldDef> info = null;
					IField field;
					switch (instr.OpCode.Code) {
					case Code.Stfld:
					case Code.Stsfld:
						field = instr.Operand as IField;
						if (field == null)
							continue;
						if (!fieldWrites.TryGetValue(field, out info))
							continue;
						bool wasNewobj;
						fieldType = GetLoadedType(info.arg.DeclaringType, method, instructions, i, out wasNewobj);
						if (fieldType == null)
							continue;
						info.Add(fieldType, wasNewobj);
						break;

					case Code.Call:
					case Code.Calli:
					case Code.Callvirt:
					case Code.Newobj:
						var pushedArgs = MethodStack.GetPushedArgInstructions(instructions, i);
						var calledMethod = instr.Operand as IMethod;
						if (calledMethod == null)
							continue;
						var calledMethodDefOrRef = calledMethod as IMethodDefOrRef;
						var calledMethodSpec = calledMethod as MethodSpec;
						if (calledMethodSpec != null)
							calledMethodDefOrRef = calledMethodSpec.Method;
						if (calledMethodDefOrRef == null)
							continue;

						IList<TypeSig> calledMethodArgs = DotNetUtils.GetArgs(calledMethodDefOrRef);
						calledMethodArgs = DotNetUtils.ReplaceGenericParameters(calledMethodDefOrRef.DeclaringType.TryGetGenericInstSig(), calledMethodSpec, calledMethodArgs);
						for (int j = 0; j < pushedArgs.NumValidArgs; j++) {
							var pushInstr = pushedArgs.GetEnd(j);
							if (pushInstr.OpCode.Code != Code.Ldfld && pushInstr.OpCode.Code != Code.Ldsfld)
								continue;

							field = pushInstr.Operand as IField;
							if (field == null)
								continue;
							if (!fieldWrites.TryGetValue(field, out info))
								continue;
							fieldType = calledMethodArgs[calledMethodArgs.Count - 1 - j];
							if (!IsValidType(info.arg.DeclaringType, fieldType))
								continue;
							info.Add(fieldType);
						}
						break;

					default:
						continue;
					}
				}
			}

			bool modified = false;
			var removeThese = new List<FieldDef>();
			foreach (var info in fieldWrites.Values) {
				if (info.UpdateNewType(module)) {
					removeThese.Add(info.arg);
					GetUpdatedField(info.arg).newFieldType = info.newType;
					info.arg.FieldSig.Type = info.newType;
					modified = true;
				}
			}
			foreach (var field in removeThese)
				fieldWrites.Remove(field);
			return modified;
		}

		TypeSig GetLoadedType(IGenericParameterProvider gpp, MethodDef method, IList<Instruction> instructions, int instrIndex, out bool wasNewobj) {
			var fieldType = MethodStack.GetLoadedType(method, instructions, instrIndex, out wasNewobj);
			if (fieldType == null || !IsValidType(gpp, fieldType))
				return null;
			return fieldType;
		}

		protected virtual bool IsValidType(IGenericParameterProvider gpp, TypeSig type) {
			if (type == null)
				return false;
			if (type.ElementType == ElementType.Void)
				return false;

			while (type != null) {
				switch (type.ElementType) {
				case ElementType.GenericInst:
					foreach (var ga in ((GenericInstSig)type).GenericArguments) {
						if (!IsValidType(gpp, ga))
							return false;
					}
					break;

				case ElementType.SZArray:
				case ElementType.Array:
				case ElementType.Ptr:
				case ElementType.Class:
				case ElementType.ValueType:
				case ElementType.Void:
				case ElementType.Boolean:
				case ElementType.Char:
				case ElementType.I1:
				case ElementType.U1:
				case ElementType.I2:
				case ElementType.U2:
				case ElementType.I4:
				case ElementType.U4:
				case ElementType.I8:
				case ElementType.U8:
				case ElementType.R4:
				case ElementType.R8:
				case ElementType.TypedByRef:
				case ElementType.I:
				case ElementType.U:
				case ElementType.String:
				case ElementType.Object:
					break;

				case ElementType.Var:
				case ElementType.MVar:
					// TODO: Return false for now. We don't know whether the Var is a Var in
					// this type or from some other type.
					return false;

				case ElementType.ByRef:
				case ElementType.FnPtr:
				case ElementType.CModOpt:
				case ElementType.CModReqd:
				case ElementType.Pinned:
				case ElementType.Sentinel:
				case ElementType.ValueArray:
				case ElementType.R:
				case ElementType.End:
				case ElementType.Internal:
				case ElementType.Module:
				default:
					return false;
				}

				if (type.Next == null)
					break;
				type = type.Next;
			}

			return type != null;
		}

		protected abstract bool IsUnknownType(object o);

		static TypeSig GetCommonBaseClass(ModuleDef module, TypeSig a, TypeSig b) {
			if (DotNetUtils.IsDelegate(a) && DotNetUtils.DerivesFromDelegate(module.Find(b.ToTypeDefOrRef())))
				return b;
			if (DotNetUtils.IsDelegate(b) && DotNetUtils.DerivesFromDelegate(module.Find(a.ToTypeDefOrRef())))
				return a;
			return null;	//TODO:
		}
	}

	public class TypesRestorer : TypesRestorerBase {
		public TypesRestorer(ModuleDef module)
			: base(module) {
		}

		protected override bool IsValidType(IGenericParameterProvider gpp, TypeSig type) {
			if (type == null)
				return false;
			if (type.IsValueType)
				return false;
			if (type.ElementType == ElementType.Object)
				return false;
			return base.IsValidType(gpp, type);
		}

		protected override bool IsUnknownType(object o) {
			if (o is Parameter arg)
				return arg.Type.GetElementType() == ElementType.Object;

			if (o is FieldDef field)
				return field.FieldSig.GetFieldType().GetElementType() == ElementType.Object;

			if (o is TypeSig sig)
				return sig.ElementType == ElementType.Object;

			throw new ApplicationException($"Unknown type: {o.GetType()}");
		}
	}
}



================================================
File: de4dot.code/deobfuscators/UnpackedFile.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

namespace de4dot.code.deobfuscators {
	public class UnpackedFile {
		public string filename;
		public byte[] data;

		public UnpackedFile(string filename, byte[] data) {
			this.filename = filename;
			this.data = data;
		}

		public override string ToString() => $"{data.Length:X8} - {filename}";
	}
}



================================================
File: de4dot.code/deobfuscators/UnusedMethodsFinder.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators {
	public class UnusedMethodsFinder {
		ModuleDef module;
		MethodCollection removedMethods;
		Dictionary<MethodDef, bool> possiblyUnusedMethods = new Dictionary<MethodDef, bool>();
		Stack<MethodDef> notUnusedStack = new Stack<MethodDef>();

		public UnusedMethodsFinder(ModuleDef module, IEnumerable<MethodDef> possiblyUnusedMethods, MethodCollection removedMethods) {
			this.module = module;
			this.removedMethods = removedMethods;
			foreach (var method in possiblyUnusedMethods) {
				if (method != module.ManagedEntryPoint && !removedMethods.Exists(method))
					this.possiblyUnusedMethods[method] = true;
			}
		}

		public IEnumerable<MethodDef> Find() {
			if (possiblyUnusedMethods.Count == 0)
				return possiblyUnusedMethods.Keys;

			foreach (var type in module.GetTypes()) {
				foreach (var method in type.Methods)
					Check(method);
			}

			while (notUnusedStack.Count > 0) {
				var method = notUnusedStack.Pop();
				if (!possiblyUnusedMethods.Remove(method))
					continue;
				Check(method);
			}

			return possiblyUnusedMethods.Keys;
		}

		void Check(MethodDef method) {
			if (method.Body == null)
				return;
			if (possiblyUnusedMethods.ContainsKey(method))
				return;
			if (removedMethods.Exists(method))
				return;

			foreach (var instr in method.Body.Instructions) {
				switch (instr.OpCode.Code) {
				case Code.Call:
				case Code.Calli:
				case Code.Callvirt:
				case Code.Newobj:
				case Code.Ldtoken:
				case Code.Ldftn:
				case Code.Ldvirtftn:
					break;
				default:
					continue;
				}

				var calledMethod = DotNetUtils.GetMethod2(module, instr.Operand as IMethod);
				if (calledMethod == null)
					continue;
				if (possiblyUnusedMethods.ContainsKey(calledMethod))
					notUnusedStack.Push(calledMethod);
			}
		}
	}
}



================================================
File: de4dot.code/deobfuscators/ValueInlinerBase.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators {
	public abstract class ValueInlinerBase<TValue> : MethodReturnValueInliner {
		MethodDefAndDeclaringTypeDict<Func<MethodDef, MethodSpec, object[], object>> decrypterMethods = new MethodDefAndDeclaringTypeDict<Func<MethodDef, MethodSpec, object[], object>>();
		bool removeUnbox = false;

		class MyCallResult : CallResult {
			public IMethod methodRef;
			public MethodSpec gim;
			public MyCallResult(Block block, int callEndIndex, IMethod method, MethodSpec gim)
				: base(block, callEndIndex) {
				methodRef = method;
				this.gim = gim;
			}
		}

		public bool RemoveUnbox {
			get => removeUnbox;
			set => removeUnbox = value;
		}

		public override bool HasHandlers => decrypterMethods.Count != 0;
		public IEnumerable<MethodDef> Methods => decrypterMethods.GetKeys();

		public void Add(MethodDef method, Func<MethodDef, MethodSpec, object[], object> handler) {
			if (method == null)
				return;
			if (decrypterMethods.Find(method) != null)
				throw new ApplicationException($"Handler for method {method.MDToken.ToInt32():X8} has already been added");
			if (method != null)
				decrypterMethods.Add(method, handler);
		}

		protected override void InlineAllCalls() {
			foreach (var tmp in callResults) {
				var callResult = (MyCallResult)tmp;
				var handler = decrypterMethods.Find(callResult.methodRef);
				callResult.returnValue = handler((MethodDef)callResult.methodRef, callResult.gim, callResult.args);
			}
		}

		protected override CallResult CreateCallResult(IMethod method, MethodSpec gim, Block block, int callInstrIndex) {
			if (decrypterMethods.Find(method) == null)
				return null;
			return new MyCallResult(block, callInstrIndex, method, gim);
		}

		protected bool RemoveUnboxInstruction(Block block, int index, string unboxType) {
			if (!removeUnbox)
				return false;
			var instrs = block.Instructions;
			if (index >= instrs.Count)
				return false;
			var unbox = instrs[index];
			if (unbox.OpCode.Code != Code.Unbox_Any)
				return false;
			var type = unbox.Operand as ITypeDefOrRef;
			if (type == null || type.FullName != unboxType)
				return false;
			block.Remove(index, 1);
			return true;
		}
	}

	public class BooleanValueInliner : ValueInlinerBase<bool> {
		protected override void InlineReturnValues(IList<CallResult> callResults) {
			foreach (var callResult in callResults) {
				var block = callResult.block;
				int num = callResult.callEndIndex - callResult.callStartIndex + 1;

				block.Replace(callResult.callStartIndex, num, Instruction.CreateLdcI4((bool)callResult.returnValue ? 1 : 0));
				RemoveUnboxInstruction(block, callResult.callStartIndex + 1, "System.Boolean");
				Logger.v("Decrypted boolean: {0}", callResult.returnValue);
			}
		}
	}

	public class Int32ValueInliner : ValueInlinerBase<int> {
		protected override void InlineReturnValues(IList<CallResult> callResults) {
			foreach (var callResult in callResults) {
				var block = callResult.block;
				int num = callResult.callEndIndex - callResult.callStartIndex + 1;

				block.Replace(callResult.callStartIndex, num, Instruction.CreateLdcI4((int)callResult.returnValue));
				RemoveUnboxInstruction(block, callResult.callStartIndex + 1, "System.Int32");
				Logger.v("Decrypted int32: {0}", callResult.returnValue);
			}
		}
	}

	public class Int64ValueInliner : ValueInlinerBase<long> {
		protected override void InlineReturnValues(IList<CallResult> callResults) {
			foreach (var callResult in callResults) {
				var block = callResult.block;
				int num = callResult.callEndIndex - callResult.callStartIndex + 1;

				block.Replace(callResult.callStartIndex, num, OpCodes.Ldc_I8.ToInstruction((long)callResult.returnValue));
				RemoveUnboxInstruction(block, callResult.callStartIndex + 1, "System.Int64");
				Logger.v("Decrypted int64: {0}", callResult.returnValue);
			}
		}
	}

	public class SingleValueInliner : ValueInlinerBase<float> {
		protected override void InlineReturnValues(IList<CallResult> callResults) {
			foreach (var callResult in callResults) {
				var block = callResult.block;
				int num = callResult.callEndIndex - callResult.callStartIndex + 1;

				block.Replace(callResult.callStartIndex, num, OpCodes.Ldc_R4.ToInstruction((float)callResult.returnValue));
				RemoveUnboxInstruction(block, callResult.callStartIndex + 1, "System.Single");
				Logger.v("Decrypted single: {0}", callResult.returnValue);
			}
		}
	}

	public class DoubleValueInliner : ValueInlinerBase<double> {
		protected override void InlineReturnValues(IList<CallResult> callResults) {
			foreach (var callResult in callResults) {
				var block = callResult.block;
				int num = callResult.callEndIndex - callResult.callStartIndex + 1;

				block.Replace(callResult.callStartIndex, num, OpCodes.Ldc_R8.ToInstruction((double)callResult.returnValue));
				RemoveUnboxInstruction(block, callResult.callStartIndex + 1, "System.Double");
				Logger.v("Decrypted double: {0}", callResult.returnValue);
			}
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Agile_NET/CliSecureRtType.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Agile_NET {
	class CliSecureRtType {
		ModuleDefMD module;
		TypeDef cliSecureRtType;
		MethodDef postInitializeMethod;
		MethodDef initializeMethod;
		Dictionary<StringDecrypterInfo, bool> stringDecrypterInfos = new Dictionary<StringDecrypterInfo, bool>();
		MethodDef loadMethod;
		bool foundSig;

		public bool Detected => foundSig || cliSecureRtType != null;
		public TypeDef Type => cliSecureRtType;
		public IEnumerable<StringDecrypterInfo> StringDecrypterInfos => stringDecrypterInfos.Keys;
		public MethodDef PostInitializeMethod => postInitializeMethod;
		public MethodDef InitializeMethod => initializeMethod;
		public MethodDef LoadMethod => loadMethod;
		public CliSecureRtType(ModuleDefMD module) => this.module = module;

		public CliSecureRtType(ModuleDefMD module, CliSecureRtType oldOne) {
			this.module = module;
			cliSecureRtType = Lookup(oldOne.cliSecureRtType, "Could not find CliSecureRt type");
			postInitializeMethod = Lookup(oldOne.postInitializeMethod, "Could not find postInitializeMethod method");
			initializeMethod = Lookup(oldOne.initializeMethod, "Could not find initializeMethod method");
			foreach (var info in oldOne.stringDecrypterInfos.Keys) {
				var m = Lookup(info.Method, "Could not find string decrypter method");
				var f = Lookup(info.Field, "Could not find string decrypter field");
				stringDecrypterInfos[new StringDecrypterInfo(m, f)] = true;
			}
			loadMethod = Lookup(oldOne.loadMethod, "Could not find loadMethod method");
			foundSig = oldOne.foundSig;
		}

		T Lookup<T>(T def, string errorMessage) where T : class, ICodedToken => DeobUtils.Lookup(module, def, errorMessage);

		public void Find(byte[] moduleBytes) {
			if (cliSecureRtType != null)
				return;
			if (Find2())
				return;
			if (Find3())
				return;
			FindNativeCode(moduleBytes);
		}

		static readonly string[] requiredFields1 = new string[] {
			"System.Boolean",
		};
		bool Find2() {
			foreach (var cctor in DeobUtils.GetInitCctors(module, 3)) {
				foreach (var calledMethod in DotNetUtils.GetCalledMethods(module, cctor)) {
					var type = calledMethod.DeclaringType;
					if (type.IsPublic)
						continue;
					var fieldTypes = new FieldTypes(type);
					if (!fieldTypes.All(requiredFields1))
						continue;
					if (!HasInitializeMethod(type, "_Initialize") && !HasInitializeMethod(type, "_Initialize64"))
						continue;

					initializeMethod = calledMethod;
					postInitializeMethod = FindMethod(type, "System.Void", "PostInitialize", "()");
					loadMethod = FindMethod(type, "System.IntPtr", "Load", "()");
					cliSecureRtType = type;
					FindStringDecrypters();
					return true;
				}
			}

			return false;
		}

		void FindStringDecrypters() => AddStringDecrypterMethod(FindStringDecrypterMethod(cliSecureRtType));

		void AddStringDecrypterMethod(MethodDef method) {
			if (method != null)
				stringDecrypterInfos[new StringDecrypterInfo(method)] = true;
		}

		static string[] requiredFields6 = new string[] {
			"System.Byte[]",
		};
		static string[] requiredFields7 = new string[] {
			"System.Byte[]",
			"System.Collections.Hashtable",
		};
		bool Find3() {
			foreach (var type in module.Types) {
				if (type.Fields.Count < 1 || type.Fields.Count > 2)
					continue;
				var fieldTypes = new FieldTypes(type);
				if (!fieldTypes.Exactly(requiredFields6) && !fieldTypes.Exactly(requiredFields7))
					continue;
				if (type.Methods.Count != 2)
					continue;
				if (type.FindStaticConstructor() == null)
					continue;
				var cs = type.FindMethod("cs");
				if (cs == null)
					continue;

				AddStringDecrypterMethod(cs);
				cliSecureRtType = type;
				return true;
			}

			return false;
		}

		static MethodDef FindStringDecrypterMethod(TypeDef type) {
			foreach (var method in type.Methods) {
				if (method.Body == null || !method.IsStatic)
					continue;
				if (!DotNetUtils.IsMethod(method, "System.String", "(System.String)"))
					continue;

				return method;
			}

			return null;
		}

		static MethodDef FindMethod(TypeDef type, string returnType, string name, string parameters) {
			var methodName = returnType + " " + type.FullName + "::" + name + parameters;
			foreach (var method in type.Methods) {
				if (method.Body == null || !method.IsStatic)
					continue;
				if (method.FullName != methodName)
					continue;

				return method;
			}

			return null;
		}

		static bool HasInitializeMethod(TypeDef type, string name) {
			var method = DotNetUtils.GetPInvokeMethod(type, name);
			if (method == null)
				return false;
			var sig = method.MethodSig;
			if (sig.Params.Count != 1)
				return false;
			if (sig.Params[0].GetElementType() != ElementType.I)
				return false;
			var retType = sig.RetType.GetElementType();
			if (retType != ElementType.Void && retType != ElementType.I4)
				return false;
			return true;
		}

		bool FindNativeCode(byte[] moduleBytes) {
			var bytes = moduleBytes ?? DeobUtils.ReadModule(module);
			using (var peImage = new MyPEImage(bytes))
				return foundSig = MethodsDecrypter.Detect(peImage);
		}

		public bool IsAtLeastVersion50() => DotNetUtils.HasPinvokeMethod(cliSecureRtType, "LoadLibraryA");

		public void FindStringDecrypterMethod() {
			if (cliSecureRtType != null)
				return;

			foreach (var type in module.Types) {
				if (type.Fields.Count != 0)
					continue;
				if (type.Methods.Count != 1)
					continue;
				var cs = type.Methods[0];
				if (!IsOldStringDecrypterMethod(cs))
					continue;

				cliSecureRtType = type;
				AddStringDecrypterMethod(cs);
				return;
			}
		}

		static bool IsOldStringDecrypterMethod(MethodDef method) {
			if (method == null || method.Body == null || !method.IsStatic)
				return false;
			if (!DotNetUtils.IsMethod(method, "System.String", "(System.String)"))
				return false;
			if (!DeobUtils.HasInteger(method, 0xFF))
				return false;

			return true;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Agile_NET/CsBlowfish.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

namespace de4dot.code.deobfuscators.Agile_NET {
	class CsBlowfish : Blowfish {
		public CsBlowfish() {
		}

		public CsBlowfish(byte[] key)
			: base(key) {
		}

		protected override void Encrypt(ref uint rxl, ref uint rxr) {
			uint xl = rxl, xr = rxr;
			for (int i = 0; i < 16; i++) {
				xl ^= P[i];
				uint t = xl;
				xl = (xl >> 24) ^ xr;
				xr = t;
			}
			rxr = xl ^ P[16];
			rxl = xr ^ P[17];
		}

		protected override void Decrypt(ref uint rxl, ref uint rxr) {
			uint xl = rxl, xr = rxr;
			for (int i = 17; i >= 2; i--) {
				xl ^= P[i];
				uint t = xl;
				xl = (xl >> 24) ^ xr;
				xr = t;
			}
			rxr = xl ^ P[1];
			rxl = xr ^ P[0];
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Agile_NET/Deobfuscator.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.PE;
using dnlib.DotNet;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Agile_NET {
	public class DeobfuscatorInfo : DeobfuscatorInfoBase {
		public const string THE_NAME = "Agile.NET";
		public const string THE_TYPE = "an";
		const string DEFAULT_REGEX = DeobfuscatorBase.DEFAULT_ASIAN_VALID_NAME_REGEX;
		BoolOption decryptMethods;
		BoolOption decryptResources;
		BoolOption removeStackFrameHelper;
		BoolOption restoreVmCode;
		BoolOption setInitLocals;

		public DeobfuscatorInfo()
			: base(DEFAULT_REGEX) {
			decryptMethods = new BoolOption(null, MakeArgName("methods"), "Decrypt methods", true);
			decryptResources = new BoolOption(null, MakeArgName("rsrc"), "Decrypt resources", true);
			removeStackFrameHelper = new BoolOption(null, MakeArgName("stack"), "Remove all StackFrameHelper code", true);
			restoreVmCode = new BoolOption(null, MakeArgName("vm"), "Restore VM code", true);
			setInitLocals = new BoolOption(null, MakeArgName("initlocals"), "Set initlocals in method header", true);
		}

		public override string Name => THE_NAME;
		public override string Type => THE_TYPE;

		public override IDeobfuscator CreateDeobfuscator() =>
			new Deobfuscator(new Deobfuscator.Options {
				ValidNameRegex = validNameRegex.Get(),
				DecryptMethods = decryptMethods.Get(),
				DecryptResources = decryptResources.Get(),
				RemoveStackFrameHelper = removeStackFrameHelper.Get(),
				RestoreVmCode = restoreVmCode.Get(),
				SetInitLocals = setInitLocals.Get(),
			});

		protected override IEnumerable<Option> GetOptionsInternal() =>
			new List<Option>() {
				decryptMethods,
				decryptResources,
				removeStackFrameHelper,
				restoreVmCode,
				setInitLocals,
			};
	}

	class Deobfuscator : DeobfuscatorBase {
		Options options;
		string obfuscatorName = DeobfuscatorInfo.THE_NAME;

		List<TypeDef> cliSecureAttributes = new List<TypeDef>();
		ProxyCallFixer proxyCallFixer;
		CliSecureRtType cliSecureRtType;
		StringDecrypter stringDecrypter;
		ResourceDecrypter resourceDecrypter;

		StackFrameHelper stackFrameHelper;
		vm.v1.Csvm csvmV1;
		vm.v2.Csvm csvmV2;

		internal class Options : OptionsBase {
			public bool DecryptMethods { get; set; }
			public bool DecryptResources { get; set; }
			public bool RemoveStackFrameHelper { get; set; }
			public bool RestoreVmCode { get; set; }
			public bool SetInitLocals { get; set; }
		}

		public override string Type => DeobfuscatorInfo.THE_TYPE;
		public override string TypeLong => DeobfuscatorInfo.THE_NAME;
		public override string Name => obfuscatorName;
		public Deobfuscator(Options options) : base(options) => this.options = options;
		public override void Initialize(ModuleDefMD module) => base.Initialize(module);
		public override byte[] UnpackNativeFile(IPEImage peImage) => UnpackNativeFile1(peImage) ?? UnpackNativeFile2(peImage);

		// Old CS versions
		byte[] UnpackNativeFile1(IPEImage peImage) {
			const int dataDirNum = 6;	// debug dir
			const int dotNetDirNum = 14;

			var optHeader = peImage.ImageNTHeaders.OptionalHeader;
			if (optHeader.DataDirectories[dataDirNum].VirtualAddress == 0)
				return null;
			if (optHeader.DataDirectories[dataDirNum].Size != 0x48)
				return null;

			var fileData = peImage.CreateReader().ToArray();
			long dataDirBaseOffset = (long)optHeader.DataDirectories[0].StartOffset;
			int dataDir = (int)dataDirBaseOffset + dataDirNum * 8;
			int dotNetDir = (int)dataDirBaseOffset + dotNetDirNum * 8;
			WriteUInt32(fileData, dotNetDir, BitConverter.ToUInt32(fileData, dataDir));
			WriteUInt32(fileData, dotNetDir + 4, BitConverter.ToUInt32(fileData, dataDir + 4));
			WriteUInt32(fileData, dataDir, 0);
			WriteUInt32(fileData, dataDir + 4, 0);
			ModuleBytes = fileData;
			return fileData;
		}

		// CS 1.x
		byte[] UnpackNativeFile2(IPEImage peImage) {
			var data = peImage.FindWin32ResourceData("ASSEMBLY", 101, 0);
			if (data == null)
				return null;

			return ModuleBytes = data.CreateReader().ToArray();
		}

		static void WriteUInt32(byte[] data, int offset, uint value) {
			data[offset] = (byte)value;
			data[offset + 1] = (byte)(value >> 8);
			data[offset + 2] = (byte)(value >> 16);
			data[offset + 3] = (byte)(value >> 24);
		}

		protected override int DetectInternal() {
			int val = 0;

			int sum = ToInt32(cliSecureRtType.Detected) +
					ToInt32(stringDecrypter.Detected) +
					ToInt32(proxyCallFixer.Detected) +
					ToInt32(resourceDecrypter.Detected) +
					ToInt32(csvmV1.Detected || csvmV2.Detected);
			if (sum > 0)
				val += 100 + 10 * (sum - 1);
			if (cliSecureAttributes.Count != 0)
				val += 10;

			return val;
		}

		protected override void ScanForObfuscator() {
			FindCliSecureAttribute();
			cliSecureRtType = new CliSecureRtType(module);
			cliSecureRtType.Find(ModuleBytes);
			stringDecrypter = new StringDecrypter(module, cliSecureRtType.StringDecrypterInfos);
			stringDecrypter.Find();
			resourceDecrypter = new ResourceDecrypter(module);
			resourceDecrypter.Find();
			proxyCallFixer = new ProxyCallFixer(module);
			proxyCallFixer.FindDelegateCreator();
			csvmV1 = new vm.v1.Csvm(DeobfuscatedFile.DeobfuscatorContext, module);
			csvmV1.Find();
			csvmV2 = new vm.v2.Csvm(DeobfuscatedFile.DeobfuscatorContext, module);
			csvmV2.Find();
		}

		void FindCliSecureAttribute() {
			obfuscatorName = "CliSecure";
			foreach (var type in module.Types) {
				if (Utils.StartsWith(type.FullName, "SecureTeam.Attributes.ObfuscatedByCliSecureAttribute", StringComparison.Ordinal)) {
					cliSecureAttributes.Add(type);
					obfuscatorName = "CliSecure";
				}
				else if (Utils.StartsWith(type.FullName, "SecureTeam.Attributes.ObfuscatedByAgileDotNetAttribute", StringComparison.Ordinal)) {
					cliSecureAttributes.Add(type);
					obfuscatorName = "Agile.NET";
				}
			}
		}

		public override bool GetDecryptedModule(int count, ref byte[] newFileData, ref DumpedMethods dumpedMethods) {
			if (count != 0 || !options.DecryptMethods)
				return false;

			byte[] fileData = ModuleBytes ?? DeobUtils.ReadModule(module);
			using (var peImage = new MyPEImage(fileData)) {
				if (!new MethodsDecrypter().Decrypt(peImage, module, cliSecureRtType, ref dumpedMethods)) {
					Logger.v("Methods aren't encrypted or invalid signature");
					return false;
				}
			}

			newFileData = fileData;
			return true;
		}

		public override IDeobfuscator ModuleReloaded(ModuleDefMD module) {
			var newOne = new Deobfuscator(options);
			newOne.SetModule(module);
			newOne.cliSecureAttributes = Lookup(module, cliSecureAttributes, "Could not find CliSecure attribute");
			newOne.cliSecureRtType = new CliSecureRtType(module, cliSecureRtType);
			newOne.stringDecrypter = new StringDecrypter(module, stringDecrypter);
			newOne.resourceDecrypter = new ResourceDecrypter(module, resourceDecrypter);
			newOne.proxyCallFixer = new ProxyCallFixer(module, proxyCallFixer);
			newOne.csvmV1 = new vm.v1.Csvm(DeobfuscatedFile.DeobfuscatorContext, module, csvmV1);
			newOne.csvmV2 = new vm.v2.Csvm(DeobfuscatedFile.DeobfuscatorContext, module, csvmV2);
			return newOne;
		}

		static List<TypeDef> Lookup(ModuleDefMD module, List<TypeDef> types, string errorMsg) {
			var list = new List<TypeDef>(types.Count);
			foreach (var type in types)
				list.Add(DeobUtils.Lookup(module, type, errorMsg));
			return list;
		}

		public override void DeobfuscateBegin() {
			base.DeobfuscateBegin();

			cliSecureRtType.FindStringDecrypterMethod();
			stringDecrypter.AddDecrypterInfos(cliSecureRtType.StringDecrypterInfos);
			stringDecrypter.Initialize();

			AddAttributesToBeRemoved(cliSecureAttributes, "Obfuscator attribute");

			if (options.DecryptResources) {
				DecryptResources(resourceDecrypter);
				AddCctorInitCallToBeRemoved(resourceDecrypter.RsrcRrrMethod);
			}

			stackFrameHelper = new StackFrameHelper(module);
			stackFrameHelper.Find();

			foreach (var type in module.Types) {
				if (type.FullName == "InitializeDelegate" && DotNetUtils.DerivesFromDelegate(type))
					AddTypeToBeRemoved(type, "Obfuscator type");
			}

			proxyCallFixer.Find();

			foreach (var info in stringDecrypter.StringDecrypterInfos)
				staticStringInliner.Add(info.Method, (method, gim, args) => stringDecrypter.Decrypt((string)args[0]));
			DeobfuscatedFile.StringDecryptersAdded();

			if (options.DecryptMethods) {
				AddCctorInitCallToBeRemoved(cliSecureRtType.InitializeMethod);
				AddCctorInitCallToBeRemoved(cliSecureRtType.PostInitializeMethod);
				FindPossibleNamesToRemove(cliSecureRtType.LoadMethod);
			}

			if (options.RestoreVmCode && (csvmV1.Detected || csvmV2.Detected)) {
				if (csvmV1.Detected && csvmV1.Restore())
					AddResourceToBeRemoved(csvmV1.Resource, "CSVM data resource");
				else if (csvmV2.Detected && csvmV2.Restore())
					AddResourceToBeRemoved(csvmV2.Resource, "CSVM data resource");
				else {
					Logger.e("Couldn't restore VM methods. Use --dont-rename or it will not run");
					PreserveTokensAndTypes();
				}
			}
		}

		void DecryptResources(ResourceDecrypter resourceDecrypter) {
			var rsrc = resourceDecrypter.MergeResources();
			if (rsrc == null)
				return;
			AddResourceToBeRemoved(rsrc, "Encrypted resources");
			AddTypeToBeRemoved(resourceDecrypter.Type, "Resource decrypter type");
		}

		public override void DeobfuscateMethodEnd(Blocks blocks) {
			if (Operations.DecryptStrings != OpDecryptString.None)
				stringDecrypter.Deobfuscate(blocks);
			proxyCallFixer.Deobfuscate(blocks);
			RemoveStackFrameHelperCode(blocks);
			base.DeobfuscateMethodEnd(blocks);
		}

		public override void DeobfuscateEnd() {
			if (options.SetInitLocals)
				SetInitLocals();
			RemoveProxyDelegates(proxyCallFixer);
			if (options.RemoveStackFrameHelper) {
				if (stackFrameHelper.ExceptionLoggerRemover.NumRemovedExceptionLoggers > 0)
					AddTypeToBeRemoved(stackFrameHelper.Type, "StackFrameHelper type");
			}
			if (CanRemoveStringDecrypterType) {
				AddTypeToBeRemoved(stringDecrypter.Type, "String decrypter type");
				foreach (var info in stringDecrypter.StringDecrypterInfos) {
					if (info.Method.DeclaringType != cliSecureRtType.Type)
						AddMethodToBeRemoved(info.Method, "String decrypter method");
					if (info.Field != null && info.Field.DeclaringType != stringDecrypter.Type)
						AddFieldToBeRemoved(info.Field, "String decrypter field");
				}
				if (options.DecryptMethods)
					AddTypeToBeRemoved(cliSecureRtType.Type ?? stringDecrypter.KeyArrayFieldType, "Obfuscator type");
			}
			if (options.DecryptMethods) {
				AddResources("Obfuscator protection files");
			}

			base.DeobfuscateEnd();

			// Call hasNativeMethods() after all types/methods/etc have been removed since
			// some of the removed methods could be native methods
			if (!module.IsILOnly && !HasNativeMethods())
				module.IsILOnly = true;
		}

		public override IEnumerable<int> GetStringDecrypterMethods() {
			var list = new List<int>();
			foreach (var info in stringDecrypter.StringDecrypterInfos)
				list.Add(info.Method.MDToken.ToInt32());
			return list;
		}

		void RemoveStackFrameHelperCode(Blocks blocks) {
			if (!options.RemoveStackFrameHelper)
				return;
			if (stackFrameHelper.ExceptionLoggerRemover.Remove(blocks))
				Logger.v("Removed StackFrameHelper code");
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Agile_NET/MethodsDecrypter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.IO;
using dnlib.IO;
using dnlib.PE;
using dnlib.DotNet;
using dnlib.DotNet.MD;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Agile_NET {
	class CodeHeader {
		public byte[] signature;
		public byte[] decryptionKey;
		public uint totalCodeSize;
		public uint numMethods;
		public uint methodDefTableOffset;	// Relative to start of metadata
		public uint methodDefElemSize;
	}

	struct MethodInfo {
		public uint codeOffs, codeSize, flags, localVarSigTok;

		public MethodInfo(uint codeOffs, uint codeSize, uint flags, uint localVarSigTok) {
			this.codeOffs = codeOffs;
			this.codeSize = codeSize;
			this.flags = flags;
			this.localVarSigTok = localVarSigTok;
		}

		public override string ToString() => $"{codeOffs:X8} {codeSize:X8} {flags:X8} {localVarSigTok:X8}";
	}

	class MethodsDecrypter {
		static readonly byte[] oldSignature    = new byte[16] { 0x1F, 0x68, 0x9D, 0x2B, 0x07, 0x4A, 0xA6, 0x4A, 0x92, 0xBB, 0x31, 0x7E, 0x60, 0x7F, 0xD7, 0xCD };
		static readonly byte[] normalSignature = new byte[16] { 0x08, 0x44, 0x65, 0xE1, 0x8C, 0x82, 0x13, 0x4C, 0x9C, 0x85, 0xB4, 0x17, 0xDA, 0x51, 0xAD, 0x25 };
		static readonly byte[] proSignature    = new byte[16] { 0x68, 0xA0, 0xBB, 0x60, 0x13, 0x65, 0x5F, 0x41, 0xAE, 0x42, 0xAB, 0x42, 0x9B, 0x6B, 0x4E, 0xC1 };

		enum SigType {
			Unknown,
			Old,
			Normal,
			Pro,
		}

		MyPEImage peImage;
		ModuleDefMD module;
		CliSecureRtType csRtType;
		CodeHeader codeHeader = new CodeHeader();
		IDecrypter decrypter;
		SigType sigType;

		interface IDecrypter {
			MethodBodyHeader Decrypt(MethodInfo methodInfo, out byte[] code, out byte[] extraSections);
		}

		abstract class DecrypterBase : IDecrypter {
			protected readonly MyPEImage peImage;
			protected readonly CodeHeader codeHeader;
			protected readonly uint endOfMetadata;

			public DecrypterBase(MyPEImage peImage, CodeHeader codeHeader) {
				this.peImage = peImage;
				this.codeHeader = codeHeader;
				var mdDir = peImage.Cor20Header.Metadata;
				endOfMetadata = peImage.RvaToOffset((uint)mdDir.VirtualAddress + mdDir.Size);
			}

			public abstract MethodBodyHeader Decrypt(MethodInfo methodInfo, out byte[] code, out byte[] extraSections);

			protected MethodBodyHeader GetCodeBytes(byte[] methodBody, out byte[] code, out byte[] extraSections) {
				var reader = ByteArrayDataReaderFactory.CreateReader(methodBody);
				return MethodBodyParser.ParseMethodBody(ref reader, out code, out extraSections);
			}
		}

		// CS 1.1 (could be other versions too)
		class Decrypter10 {
			MyPEImage peImage;
			CsBlowfish blowfish;

			public Decrypter10(MyPEImage peImage, byte[] key) {
				this.peImage = peImage;
				blowfish = new CsBlowfish(key);
			}

			public MethodBodyHeader Decrypt(uint bodyOffset, out byte[] code, out byte[] extraSections) {
				peImage.Reader.Position = bodyOffset;
				var mbHeader = MethodBodyParser.ParseMethodBody(ref peImage.Reader, out code, out extraSections);
				blowfish.Decrypt(code);
				return mbHeader;
			}
		}

		// CS 3.0 (could be other versions too)
		class Decrypter30 : DecrypterBase {
			public Decrypter30(MyPEImage peImage, CodeHeader codeHeader)
				: base(peImage, codeHeader) {
			}

			public override MethodBodyHeader Decrypt(MethodInfo methodInfo, out byte[] code, out byte[] extraSections) {
				peImage.Reader.Position = peImage.RvaToOffset(methodInfo.codeOffs);
				return MethodBodyParser.ParseMethodBody(ref peImage.Reader, out code, out extraSections);
			}
		}

		// CS 4.0 (could be other versions too)
		class Decrypter40 : DecrypterBase {
			public Decrypter40(MyPEImage peImage, CodeHeader codeHeader)
				: base(peImage, codeHeader) {
			}

			public override MethodBodyHeader Decrypt(MethodInfo methodInfo, out byte[] code, out byte[] extraSections) {
				peImage.Reader.Position = endOfMetadata + methodInfo.codeOffs;
				return MethodBodyParser.ParseMethodBody(ref peImage.Reader, out code, out extraSections);
			}
		}

		// CS 4.5 (could be other versions too)
		class Decrypter45 : DecrypterBase {
			public Decrypter45(MyPEImage peImage, CodeHeader codeHeader)
				: base(peImage, codeHeader) {
			}

			public override MethodBodyHeader Decrypt(MethodInfo methodInfo, out byte[] code, out byte[] extraSections) {
				var data = peImage.OffsetReadBytes(endOfMetadata + methodInfo.codeOffs, (int)methodInfo.codeSize);
				for (int i = 0; i < data.Length; i++) {
					byte b = data[i];
					b ^= codeHeader.decryptionKey[(methodInfo.codeOffs - 0x28 + i) % 16];
					data[i] = b;
				}
				return GetCodeBytes(data, out code, out extraSections);
			}
		}

		// CS 5.0+
		class Decrypter5 : DecrypterBase {
			readonly uint codeHeaderSize;

			public Decrypter5(MyPEImage peImage, CodeHeader codeHeader, uint codeHeaderSize)
				: base(peImage, codeHeader) => this.codeHeaderSize = codeHeaderSize;

			public override MethodBodyHeader Decrypt(MethodInfo methodInfo, out byte[] code, out byte[] extraSections) {
				byte[] data = peImage.OffsetReadBytes(endOfMetadata + methodInfo.codeOffs, (int)methodInfo.codeSize);
				for (int i = 0; i < data.Length; i++) {
					byte b = data[i];
					b ^= codeHeader.decryptionKey[(methodInfo.codeOffs - codeHeaderSize + i) % 16];
					b ^= codeHeader.decryptionKey[(methodInfo.codeOffs - codeHeaderSize + i + 7) % 16];
					data[i] = b;
				}
				return GetCodeBytes(data, out code, out extraSections);
			}
		}

		// CS 5.4+. Used when the anti-debugger protection is enabled
		class ProDecrypter : DecrypterBase {
			readonly uint[] key = new uint[4];

			public ProDecrypter(MyPEImage peImage, CodeHeader codeHeader)
				: base(peImage, codeHeader) {
				for (int i = 0; i < 4; i++)
					key[i] = ReadUInt32_be(codeHeader.decryptionKey, i * 4);
			}

			public override MethodBodyHeader Decrypt(MethodInfo methodInfo, out byte[] code, out byte[] extraSections) {
				byte[] data = peImage.OffsetReadBytes(endOfMetadata + methodInfo.codeOffs, (int)methodInfo.codeSize);

				int numQwords = (int)(methodInfo.codeSize / 8);
				for (int i = 0; i < numQwords; i++) {
					int offset = i * 8;
					uint q0 = ReadUInt32_be(data, offset);
					uint q1 = ReadUInt32_be(data, offset + 4);

					const uint magic = 0x9E3779B8;
					uint val = 0xC6EF3700;	// magic * 0x20
					for (int j = 0; j < 32; j++) {
						q1 -= ((q0 << 4) + key[2]) ^ (val + q0) ^ ((q0 >> 5) + key[3]);
						q0 -= ((q1 << 4) + key[0]) ^ (val + q1) ^ ((q1 >> 5) + key[1]);
						val -= magic;
					}

					WriteUInt32_be(data, offset, q0);
					WriteUInt32_be(data, offset + 4, q1);
				}

				return GetCodeBytes(data, out code, out extraSections);
			}

			static uint ReadUInt32_be(byte[] data, int offset) =>
				(uint)((data[offset] << 24) +
						(data[offset + 1] << 16) +
						(data[offset + 2] << 8) +
						data[offset + 3]);

			static void WriteUInt32_be(byte[] data, int offset, uint value) {
				data[offset] = (byte)(value >> 24);
				data[offset + 1] = (byte)(value >> 16);
				data[offset + 2] = (byte)(value >> 8);
				data[offset + 3] = (byte)value;
			}
		}

		interface ICsHeader {
			IDecrypter CreateDecrypter();
			List<MethodInfo> GetMethodInfos(uint codeHeaderOffset);
			void PatchMethodTable(MDTable methodDefTable, IList<MethodInfo> methodInfos);
		}

		abstract class CsHeaderBase : ICsHeader {
			protected readonly MethodsDecrypter methodsDecrypter;
			protected readonly uint codeHeaderSize;

			public CsHeaderBase(MethodsDecrypter methodsDecrypter, uint codeHeaderSize) {
				this.methodsDecrypter = methodsDecrypter;
				this.codeHeaderSize = codeHeaderSize;
			}

			public abstract IDecrypter CreateDecrypter();

			public virtual void PatchMethodTable(MDTable methodDefTable, IList<MethodInfo> methodInfos) {
			}

			public abstract List<MethodInfo> GetMethodInfos(uint codeHeaderOffset);

			protected List<MethodInfo> GetMethodInfos1(uint codeHeaderOffset) {
				uint offset = codeHeaderOffset + methodsDecrypter.codeHeader.totalCodeSize + codeHeaderSize;
				var methodInfos = new List<MethodInfo>((int)methodsDecrypter.codeHeader.numMethods);
				for (int i = 0; i < (int)methodsDecrypter.codeHeader.numMethods; i++, offset += 4) {
					uint codeOffs = methodsDecrypter.peImage.OffsetReadUInt32(offset);
					methodInfos.Add(new MethodInfo(codeOffs, 0, 0, 0));
				}
				return methodInfos;
			}

			protected List<MethodInfo> GetMethodInfos2(uint codeHeaderOffset) {
				uint offset = codeHeaderOffset + methodsDecrypter.codeHeader.totalCodeSize + codeHeaderSize;
				var methodInfos = new List<MethodInfo>((int)methodsDecrypter.codeHeader.numMethods);
				for (int i = 0; i < (int)methodsDecrypter.codeHeader.numMethods; i++, offset += 8) {
					uint codeOffs = methodsDecrypter.peImage.OffsetReadUInt32(offset);
					uint codeSize = methodsDecrypter.peImage.OffsetReadUInt32(offset + 4);
					methodInfos.Add(new MethodInfo(codeOffs, codeSize, 0, 0));
				}
				return methodInfos;
			}

			protected List<MethodInfo> GetMethodInfos4(uint codeHeaderOffset) {
				uint offset = codeHeaderOffset + methodsDecrypter.codeHeader.totalCodeSize + codeHeaderSize;
				var methodInfos = new List<MethodInfo>((int)methodsDecrypter.codeHeader.numMethods);
				for (int i = 0; i < (int)methodsDecrypter.codeHeader.numMethods; i++, offset += 16) {
					uint codeOffs = methodsDecrypter.peImage.OffsetReadUInt32(offset);
					uint codeSize = methodsDecrypter.peImage.OffsetReadUInt32(offset + 4);
					uint flags = methodsDecrypter.peImage.OffsetReadUInt32(offset + 8);
					uint localVarSigTok = methodsDecrypter.peImage.OffsetReadUInt32(offset + 12);
					methodInfos.Add(new MethodInfo(codeOffs, codeSize, flags, localVarSigTok));
				}
				return methodInfos;
			}
		}

		// CS 3.0 (could be other versions too)
		class CsHeader30 : CsHeaderBase {
			public CsHeader30(MethodsDecrypter methodsDecrypter)
				: base(methodsDecrypter, 0x28) {
			}

			public override IDecrypter CreateDecrypter() => new Decrypter30(methodsDecrypter.peImage, methodsDecrypter.codeHeader);
			public override List<MethodInfo> GetMethodInfos(uint codeHeaderOffset) => GetMethodInfos1(codeHeaderOffset);
		}

		// CS 4.0 (could be other versions too)
		class CsHeader40 : CsHeaderBase {
			public CsHeader40(MethodsDecrypter methodsDecrypter)
				: base(methodsDecrypter, 0x28) {
			}

			public override IDecrypter CreateDecrypter() => new Decrypter40(methodsDecrypter.peImage, methodsDecrypter.codeHeader);
			public override List<MethodInfo> GetMethodInfos(uint codeHeaderOffset) => GetMethodInfos1(codeHeaderOffset);
		}

		// CS 4.5 (could be other versions too)
		class CsHeader45 : CsHeaderBase {
			public CsHeader45(MethodsDecrypter methodsDecrypter)
				: base(methodsDecrypter, 0x28) {
			}

			public override IDecrypter CreateDecrypter() => new Decrypter45(methodsDecrypter.peImage, methodsDecrypter.codeHeader);
			public override List<MethodInfo> GetMethodInfos(uint codeHeaderOffset) => GetMethodInfos2(codeHeaderOffset);
		}

		// CS 5.0+
		class CsHeader5 : CsHeaderBase {
			public CsHeader5(MethodsDecrypter methodsDecrypter, uint codeHeaderSize)
				: base(methodsDecrypter, codeHeaderSize) {
			}

			public override IDecrypter CreateDecrypter() {
				switch (GetSigType(methodsDecrypter.codeHeader.signature)) {
				case SigType.Normal:
					return new Decrypter5(methodsDecrypter.peImage, methodsDecrypter.codeHeader, codeHeaderSize);

				case SigType.Pro:
					return new ProDecrypter(methodsDecrypter.peImage, methodsDecrypter.codeHeader);

				case SigType.Unknown:
				default:
					throw new ArgumentException("sig");
				}
			}

			public override List<MethodInfo> GetMethodInfos(uint codeHeaderOffset) {
				if (codeHeaderSize == 0x28)
					return GetMethodInfos2(codeHeaderOffset);
				return GetMethodInfos4(codeHeaderOffset);
			}

			public override void PatchMethodTable(MDTable methodDefTable, IList<MethodInfo> methodInfos) {
				uint offset = (uint)methodDefTable.StartOffset - methodDefTable.RowSize;
				foreach (var methodInfo in methodInfos) {
					offset += methodDefTable.RowSize;
					if (methodInfo.flags == 0 || methodInfo.codeOffs == 0)
						continue;
					uint rva = methodsDecrypter.peImage.OffsetReadUInt32(offset);
					methodsDecrypter.peImage.WriteUInt16(rva, (ushort)methodInfo.flags);
					methodsDecrypter.peImage.WriteUInt32(rva + 8, methodInfo.localVarSigTok);
				}
			}
		}

		enum CsHeaderVersion {
			Unknown,
			V10,
			V30,
			V40,
			V45,
			V50,	// 5.0, possibly also 5.1
			V52,	// 5.2+ (or maybe 5.1+)
		}

		List<CsHeaderVersion> GetCsHeaderVersions(uint codeHeaderOffset, MDTable methodDefTable) {
			if (sigType == SigType.Old)
				return new List<CsHeaderVersion> { CsHeaderVersion.V10 };
			if (!IsOldHeader(methodDefTable))
				return new List<CsHeaderVersion> { CsHeaderVersion.V52 };
			if (csRtType.IsAtLeastVersion50())
				return new List<CsHeaderVersion> { CsHeaderVersion.V50 };
			if (IsCsHeader40(codeHeaderOffset)) {
				return new List<CsHeaderVersion> {
					CsHeaderVersion.V40,
					CsHeaderVersion.V30,
				};
			}
			return new List<CsHeaderVersion> {
				CsHeaderVersion.V45,
				CsHeaderVersion.V50,
			};
		}

		bool IsCsHeader40(uint codeHeaderOffset) {
			try {
				uint offset = codeHeaderOffset + codeHeader.totalCodeSize + 0x28;
				uint prevCodeOffs = 0;
				for (int i = 0; i < (int)codeHeader.numMethods; i++, offset += 4) {
					uint codeOffs = peImage.OffsetReadUInt32(offset);
					if (prevCodeOffs != 0 && codeOffs != 0 && codeOffs < prevCodeOffs)
						return false;
					if (codeOffs != 0)
						prevCodeOffs = codeOffs;
				}

				return true;
			}
			catch (Exception ex) when (ex is IOException || ex is ArgumentException) {
				return false;
			}
		}

		bool IsOldHeader(MDTable methodDefTable) {
			if (methodDefTable.RowSize != codeHeader.methodDefElemSize)
				return true;
			if ((uint)methodDefTable.StartOffset - peImage.RvaToOffset((uint)peImage.Cor20Header.Metadata.VirtualAddress) != codeHeader.methodDefTableOffset)
				return true;

			return false;
		}

		ICsHeader CreateCsHeader(CsHeaderVersion version) {
			switch (version) {
			case CsHeaderVersion.V30: return new CsHeader30(this);
			case CsHeaderVersion.V40: return new CsHeader40(this);
			case CsHeaderVersion.V45: return new CsHeader45(this);
			case CsHeaderVersion.V50: return new CsHeader5(this, 0x28);
			case CsHeaderVersion.V52: return new CsHeader5(this, 0x30);
			default: throw new ApplicationException("Unknown CS header");
			}
		}

		enum DecryptResult {
			NotEncrypted,
			Decrypted,
			Error,
		}

		public bool Decrypt(MyPEImage peImage, ModuleDefMD module, CliSecureRtType csRtType, ref DumpedMethods dumpedMethods) {
			this.peImage = peImage;
			this.csRtType = csRtType;
			this.module = module;

			switch (Decrypt2(ref dumpedMethods)) {
			case DecryptResult.Decrypted: return true;
			case DecryptResult.NotEncrypted: return false;

			case DecryptResult.Error:
				Logger.n("Using dynamic method decryption");
				byte[] moduleCctorBytes = GetModuleCctorBytes(csRtType);
				dumpedMethods = de4dot.code.deobfuscators.MethodsDecrypter.Decrypt(module, moduleCctorBytes);
				return true;

			default:
				throw new ApplicationException("Invalid DecryptResult");
			}
		}

		static byte[] GetModuleCctorBytes(CliSecureRtType csRtType) {
			var initMethod = csRtType.InitializeMethod;
			if (initMethod == null)
				return null;
			uint initToken = initMethod.MDToken.ToUInt32();
			var moduleCctorBytes = new byte[6];
			moduleCctorBytes[0] = 0x28;	// call
			moduleCctorBytes[1] = (byte)initToken;
			moduleCctorBytes[2] = (byte)(initToken >> 8);
			moduleCctorBytes[3] = (byte)(initToken >> 16);
			moduleCctorBytes[4] = (byte)(initToken >> 24);
			moduleCctorBytes[5] = 0x2A;	// ret
			return moduleCctorBytes;
		}

		static uint GetCodeHeaderOffset(MyPEImage peImage) =>
			peImage.RvaToOffset((uint)peImage.Cor20Header.Metadata.VirtualAddress + peImage.Cor20Header.Metadata.Size);

		static string[] sections = new string[] {
			".text", ".rsrc", ".data", ".rdata",
		};
		static uint GetOldCodeHeaderOffset(MyPEImage peImage) {
			var sect = GetLastOf(peImage, sections);
			if (sect == null || sect.VirtualSize < 0x100)
				return 0;
			return peImage.RvaToOffset((uint)sect.VirtualAddress + sect.VirtualSize - 0x100);
		}

		static ImageSectionHeader GetLastOf(MyPEImage peImage, string[] sections) {
			ImageSectionHeader sect = null;
			foreach (var name in sections) {
				var sect2 = peImage.FindSection(name);
				if (sect2 == null)
					continue;
				if (sect == null || sect2.VirtualAddress > sect.VirtualAddress)
					sect = sect2;
			}
			return sect;
		}

		DecryptResult Decrypt2(ref DumpedMethods dumpedMethods) {
			uint codeHeaderOffset = InitializeCodeHeader();
			if (sigType == SigType.Unknown)
				return DecryptResult.NotEncrypted;

			var methodDefTable = peImage.Metadata.TablesStream.MethodTable;

			foreach (var version in GetCsHeaderVersions(codeHeaderOffset, methodDefTable)) {
				try {
					if (version == CsHeaderVersion.V10)
						DecryptMethodsOld(methodDefTable, ref dumpedMethods);
					else
						DecryptMethods(codeHeaderOffset, methodDefTable, CreateCsHeader(version), ref dumpedMethods);
					return DecryptResult.Decrypted;
				}
				catch {
				}
			}

			return DecryptResult.Error;
		}

		uint InitializeCodeHeader() {
			uint codeHeaderOffset = GetCodeHeaderOffset(peImage);
			ReadCodeHeader(codeHeaderOffset);
			sigType = GetSigType(codeHeader.signature);

			if (sigType == SigType.Unknown) {
				codeHeaderOffset = GetOldCodeHeaderOffset(peImage);
				if (codeHeaderOffset != 0) {
					ReadCodeHeader(codeHeaderOffset);
					sigType = GetSigType(codeHeader.signature);
				}
			}

			return codeHeaderOffset;
		}

		void DecryptMethodsOld(MDTable methodDefTable, ref DumpedMethods dumpedMethods) {
			dumpedMethods = new DumpedMethods();
			var decrypter = new Decrypter10(peImage, codeHeader.decryptionKey);
			for (uint rid = 1; rid <= methodDefTable.Rows; rid++) {
				var dm = new DumpedMethod();

				var method = (MethodDef)module.ResolveMethod(rid);
				if (method == null || method.DeclaringType == module.GlobalType)
					continue;

				peImage.ReadMethodTableRowTo(dm, rid);
				if (dm.mdRVA == 0)
					continue;
				uint bodyOffset = peImage.RvaToOffset(dm.mdRVA);

				var mbHeader = decrypter.Decrypt(bodyOffset, out dm.code, out dm.extraSections);
				peImage.UpdateMethodHeaderInfo(dm, mbHeader);

				dumpedMethods.Add(dm);
			}
		}

		void DecryptMethods(uint codeHeaderOffset, MDTable methodDefTable, ICsHeader csHeader, ref DumpedMethods dumpedMethods) {
			var methodInfos = csHeader.GetMethodInfos(codeHeaderOffset);
			csHeader.PatchMethodTable(methodDefTable, methodInfos);

			dumpedMethods = new DumpedMethods();
			decrypter = csHeader.CreateDecrypter();
			for (uint rid = 1; rid <= (uint)methodInfos.Count; rid++) {
				var methodInfo = methodInfos[(int)rid - 1];
				if (methodInfo.codeOffs == 0)
					continue;

				var dm = new DumpedMethod();
				peImage.ReadMethodTableRowTo(dm, rid);

				var mbHeader = decrypter.Decrypt(methodInfo, out dm.code, out dm.extraSections);
				peImage.UpdateMethodHeaderInfo(dm, mbHeader);

				dumpedMethods.Add(dm);
			}
		}

		void ReadCodeHeader(uint offset) {
			codeHeader.signature = peImage.OffsetReadBytes(offset, 16);
			codeHeader.decryptionKey = peImage.OffsetReadBytes(offset + 0x10, 16);
			codeHeader.totalCodeSize = peImage.OffsetReadUInt32(offset + 0x20);
			codeHeader.numMethods = peImage.OffsetReadUInt32(offset + 0x24);
			codeHeader.methodDefTableOffset = peImage.OffsetReadUInt32(offset + 0x28);
			codeHeader.methodDefElemSize = peImage.OffsetReadUInt32(offset + 0x2C);
		}

		static SigType GetSigType(byte[] sig) {
			if (Utils.Compare(sig, normalSignature))
				return SigType.Normal;
			else if (Utils.Compare(sig, proSignature))
				return SigType.Pro;
			else if (Utils.Compare(sig, oldSignature))
				return SigType.Old;
			return SigType.Unknown;
		}

		static bool IsValidSignature(byte[] signature) => GetSigType(signature) != SigType.Unknown;

		public static bool Detect(MyPEImage peImage) {
			try {
				uint codeHeaderOffset = GetCodeHeaderOffset(peImage);
				if (IsValidSignature(peImage.OffsetReadBytes(codeHeaderOffset, 16)))
					return true;
			}
			catch {
			}

			try {
				uint codeHeaderOffset = GetOldCodeHeaderOffset(peImage);
				if (codeHeaderOffset != 0 && IsValidSignature(peImage.OffsetReadBytes(codeHeaderOffset, 16)))
					return true;
			}
			catch {
			}

			return false;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Agile_NET/ProxyCallFixer.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace de4dot.code.deobfuscators.Agile_NET {
	class ProxyCallFixer : ProxyCallFixer1 {
		public ProxyCallFixer(ModuleDefMD module)
			: base(module) {
		}

		public ProxyCallFixer(ModuleDefMD module, ProxyCallFixer oldOne)
			: base(module) {
			foreach (var method in oldOne.delegateCreatorMethods)
				SetDelegateCreatorMethod(Lookup(method, "Could not find delegate creator method"));
		}

		public void FindDelegateCreator() {
			foreach (var type in module.Types) {
				var methodName = "System.Void " + type.FullName + "::icgd(System.Int32)";
				foreach (var method in type.Methods) {
					if (method.FullName == methodName) {
						SetDelegateCreatorMethod(method);
						return;
					}
				}
			}
		}

		protected override object CheckCctor(ref TypeDef type, MethodDef cctor) {
			var instrs = cctor.Body.Instructions;
			if (instrs.Count != 3)
				return null;
			if (!instrs[0].IsLdcI4())
				return null;
			if (instrs[1].OpCode != OpCodes.Call || !IsDelegateCreatorMethod(instrs[1].Operand as MethodDef))
				return null;
			if (instrs[2].OpCode != OpCodes.Ret)
				return null;

			int delegateToken = 0x02000001 + instrs[0].GetLdcI4Value();
			if (type.MDToken.ToInt32() != delegateToken) {
				Logger.w("Delegate token is not current type");
				return null;
			}

			return new object();
		}

		protected override void GetCallInfo(object context, FieldDef field, out IMethod calledMethod, out OpCode callOpcode) {
			var name = field.Name.String;
			callOpcode = OpCodes.Call;
			if (name.EndsWith("%", StringComparison.Ordinal)) {
				callOpcode = OpCodes.Callvirt;
				name = name.TrimEnd(new char[] { '%' });
			}
			byte[] value = Convert.FromBase64String(name);
			int methodIndex = BitConverter.ToInt32(value, 0);	// 0-based memberRef index
			var mr = module.ResolveMemberRef((uint)methodIndex + 1);
			if (mr == null || !mr.IsMethodRef)
				throw new ApplicationException($"Invalid MemberRef index: {methodIndex}");
			calledMethod = mr;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Agile_NET/ResourceDecrypter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.IO;
using System.Security.Cryptography;
using System.Text;
using dnlib.DotNet;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Agile_NET {
	class ResourceDecrypter {
		ModuleDefMD module;
		TypeDef rsrcType;
		MethodDef rsrcRrrMethod;
		MethodDef rsrcResolveMethod;

		public bool Detected => rsrcType != null;
		public TypeDef Type => rsrcType;
		public MethodDef RsrcRrrMethod => rsrcRrrMethod;
		public ResourceDecrypter(ModuleDefMD module) => this.module = module;

		public ResourceDecrypter(ModuleDefMD module, ResourceDecrypter oldOne) {
			this.module = module;
			rsrcType = Lookup(oldOne.rsrcType, "Could not find rsrcType");
			rsrcRrrMethod = Lookup(oldOne.rsrcRrrMethod, "Could not find rsrcRrrMethod");
			rsrcResolveMethod = Lookup(oldOne.rsrcResolveMethod, "Could not find rsrcResolveMethod");
		}

		T Lookup<T>(T def, string errorMessage) where T : class, ICodedToken => DeobUtils.Lookup(module, def, errorMessage);
		public void Find() => FindResourceType();

		static readonly string[] requiredFields1 = new string[] {
			"System.Reflection.Assembly",
			"System.String[]",
		};
		static readonly string[] requiredFields2 = new string[] {
			"System.Reflection.Assembly",
			"System.String[]",
			"System.Collections.Hashtable",
		};
		void FindResourceType() {
			var cctor = DotNetUtils.GetModuleTypeCctor(module);
			if (cctor == null)
				return;

			foreach (var calledMethod in DotNetUtils.GetCalledMethods(module, cctor)) {
				if (!calledMethod.IsStatic || calledMethod.Body == null)
					continue;
				if (!DotNetUtils.IsMethod(calledMethod, "System.Void", "()"))
					continue;
				var type = calledMethod.DeclaringType;
				var fieldTypes = new FieldTypes(type);
				if (!fieldTypes.Exactly(requiredFields1) &&
					!fieldTypes.Exactly(requiredFields2))
					continue;

				var resolveHandler = DotNetUtils.GetMethod(type, "System.Reflection.Assembly", "(System.Object,System.ResolveEventArgs)");
				var decryptMethod = DotNetUtils.GetMethod(type, "System.Byte[]", "(System.IO.Stream)");
				if (resolveHandler == null || !resolveHandler.IsStatic)
					continue;
				if (decryptMethod == null || !decryptMethod.IsStatic)
					continue;

				rsrcType = type;
				rsrcRrrMethod = calledMethod;
				rsrcResolveMethod = resolveHandler;
				return;
			}
		}

		public EmbeddedResource MergeResources() {
			if (rsrcResolveMethod == null)
				return null;
			var resource = DotNetUtils.GetResource(module, DotNetUtils.GetCodeStrings(rsrcResolveMethod)) as EmbeddedResource;
			if (resource == null)
				return null;
			DeobUtils.DecryptAndAddResources(module, resource.Name.String, () => DecryptResource(resource));
			return resource;
		}

		byte[] DecryptResource(EmbeddedResource resource) {
			var reader = resource.CreateReader();
			reader.Position = 0;
			var key = reader.ReadSerializedString();
			var data = reader.ReadRemainingBytes();
			var cryptoTransform = new DESCryptoServiceProvider {
				Key = Encoding.ASCII.GetBytes(key),
				IV = Encoding.ASCII.GetBytes(key),
			}.CreateDecryptor();
			var memStream = new MemoryStream(data);
			using (var reader2 = new BinaryReader(new CryptoStream(memStream, cryptoTransform, CryptoStreamMode.Read))) {
				return reader2.ReadBytes((int)memStream.Length);
			}
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Agile_NET/StackFrameHelper.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using dnlib.DotNet;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Agile_NET {
	class StackFrameHelper {
		ModuleDefMD module;
		TypeDef stackFrameHelperType;
		ExceptionLoggerRemover exceptionLoggerRemover = new ExceptionLoggerRemover();

		public TypeDef Type => stackFrameHelperType;
		public ExceptionLoggerRemover ExceptionLoggerRemover => exceptionLoggerRemover;
		public StackFrameHelper(ModuleDefMD module) => this.module = module;

		public void Find() {
			foreach (var type in module.Types) {
				if (!type.HasMethods)
					continue;
				if (type.Methods.Count > 3)
					continue;

				MethodDef errorMethod = null;
				foreach (var method in type.Methods) {
					if (method.Name == ".ctor")
						continue;	// .ctor is allowed
					if (method.Name == ".cctor")
						continue;	// .cctor is allowed
					var sig = method.MethodSig;
					if (sig != null && method.IsStatic && method.HasBody &&
						sig.Params.Count == 2 && !method.HasGenericParameters &&
						!DotNetUtils.HasReturnValue(method) &&
						sig.Params[0].GetFullName() == "System.Exception" &&
						sig.Params[1].GetFullName() == "System.Object[]") {
						errorMethod = method;
					}
					else
						break;
				}
				if (errorMethod != null) {
					stackFrameHelperType = type;
					exceptionLoggerRemover.Add(errorMethod);
					return;
				}
			}
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Agile_NET/StringDecrypter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Agile_NET {
	class StringDecrypter {
		ModuleDefMD module;
		TypeDef stringDecrypterType;
		FieldDef keyInitField;
		FieldDef keyArrayField;
		Dictionary<StringDecrypterInfo, bool> stringDecrypterInfos = new Dictionary<StringDecrypterInfo, bool>();
		byte[] stringDecrypterKey;

		public bool Detected => stringDecrypterInfos.Count != 0;
		public TypeDef Type => stringDecrypterType;
		public TypeDef KeyArrayFieldType => keyArrayField?.DeclaringType;
		public IEnumerable<StringDecrypterInfo> StringDecrypterInfos => stringDecrypterInfos.Keys;

		public StringDecrypter(ModuleDefMD module, IEnumerable<StringDecrypterInfo> stringDecrypterMethods) {
			this.module = module;
			foreach (var sdm in stringDecrypterMethods)
				stringDecrypterInfos[sdm] = true;
		}

		public StringDecrypter(ModuleDefMD module, StringDecrypter oldOne) {
			this.module = module;
			stringDecrypterType = Lookup(oldOne.stringDecrypterType, "Could not find stringDecrypterType");
			keyInitField = Lookup(oldOne.keyInitField, "Could not find key init field");
			keyArrayField = Lookup(oldOne.keyArrayField, "Could not find key array field");
			foreach (var info in oldOne.stringDecrypterInfos.Keys) {
				var m = Lookup(info.Method, "Could not find string decrypter method");
				var f = Lookup(info.Field, "Could not find string decrypter field");
				stringDecrypterInfos[new StringDecrypterInfo(m, f)] = true;
			}
			stringDecrypterKey = oldOne.stringDecrypterKey;
		}

		T Lookup<T>(T def, string errorMessage) where T : class, ICodedToken => DeobUtils.Lookup(module, def, errorMessage);

		public void AddDecrypterInfos(IEnumerable<StringDecrypterInfo> infos) {
			foreach (var info in infos)
				stringDecrypterInfos[info] = true;
		}

		public void Find() {
			stringDecrypterKey = new byte[1] { 0xFF };
			foreach (var type in module.Types) {
				if (type.FullName == "<D234>" || type.FullName == "<ClassD234>") {
					stringDecrypterType = type;
					foreach (var field in type.Fields) {
						if (field.FullName == "<D234> <D234>::345" || field.FullName == "<ClassD234>/D234 <ClassD234>::345") {
							keyInitField = field;
							stringDecrypterKey = field.InitialValue;
							break;
						}
					}
					break;
				}
			}
		}

		public void Initialize() {
			if (keyInitField == null)
				return;

			foreach (var type in module.Types) {
				var cctor = type.FindStaticConstructor();
				if (cctor == null)
					continue;
				keyArrayField = GetKeyArrayField(cctor, keyInitField);
				if (keyArrayField != null)
					break;
			}
			if (keyArrayField == null)
				return;

			foreach (var type in module.GetTypes()) {
				var method = FindStringDecrypters(type, keyArrayField, out var field);
				if (method == null)
					continue;

				stringDecrypterInfos[new StringDecrypterInfo(method, field)] = true;
			}
		}

		static FieldDef GetKeyArrayField(MethodDef method, FieldDef keyInitField) {
			if (method == null || method.Body == null)
				return null;
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count; i++) {
				if (instrs[i].OpCode.Code != Code.Ldtoken)
					continue;

				i++;
				for (; i < instrs.Count; i++) {
					var instr = instrs[i];
					if (instr.OpCode.Code != Code.Stsfld)
						continue;
					var field = instr.Operand as FieldDef;
					if (field == null || !field.IsStatic || field.DeclaringType != method.DeclaringType)
						continue;
					if (field.FieldSig.GetFieldType().GetFullName() != "System.Byte[]")
						continue;
					return field;
				}
			}
			return null;
		}

		static MethodDef FindStringDecrypters(TypeDef type, FieldDef keyArrayField, out FieldDef field) {
			FieldDef foundField = null;
			foreach (var method in type.Methods) {
				if (!method.IsAssembly || !method.IsStatic)
					continue;
				if (!DotNetUtils.IsMethod(method, "System.String", "(System.String)"))
					continue;
				if (!method.HasBody)
					continue;

				bool accessedArrayField = false;
				foreach (var instr in method.Body.Instructions) {
					var f = instr.Operand as FieldDef;
					accessedArrayField |= f == keyArrayField;
					if (f == null || f == keyArrayField || f == foundField)
						continue;
					if (DotNetUtils.DerivesFromDelegate(f.DeclaringType))
						continue;
					if (f.FieldSig.GetFieldType().GetFullName() != "System.Collections.Hashtable" ||
						foundField != null)
						goto exit;
					foundField = f;
				}
				if (!accessedArrayField)
					continue;

				field = foundField;
				return method;
			}

exit: ;
			field = null;
			return null;
		}

		public void Deobfuscate(Blocks blocks) {
			if (!blocks.Method.IsStaticConstructor)
				return;

			var decrypterFields = new Dictionary<FieldDef, bool>(stringDecrypterInfos.Count);
			foreach (var info in stringDecrypterInfos.Keys) {
				if (info.Field != null)
					decrypterFields[info.Field] = true;
			}

			foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {
				var instrs = block.Instructions;
				for (int i = instrs.Count - 2; i >= 0; i--) {
					var newobj = instrs[i];
					if (newobj.OpCode.Code != Code.Newobj)
						continue;
					var ctor = newobj.Operand as IMethod;
					if (ctor == null || ctor.FullName != "System.Void System.Collections.Hashtable::.ctor()")
						continue;
					var stsfld = instrs[i + 1];
					if (stsfld.OpCode.Code != Code.Stsfld)
						continue;
					var field = stsfld.Operand as FieldDef;
					if (field == null || !decrypterFields.ContainsKey(field))
						continue;

					block.Remove(i, 2);
				}
			}
		}

		public string Decrypt(string es) {
			if (stringDecrypterKey == null)
				throw new ApplicationException("Trying to decrypt strings when stringDecrypterKey is null (could not find it!)");
			char[] buf = new char[es.Length];
			for (int i = 0; i < es.Length; i++)
				buf[i] = (char)(es[i] ^ stringDecrypterKey[i % stringDecrypterKey.Length]);
			return new string(buf);
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Agile_NET/StringDecrypterInfo.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using dnlib.DotNet;

namespace de4dot.code.deobfuscators.Agile_NET {
	class StringDecrypterInfo {
		public readonly MethodDef Method;
		public readonly FieldDef Field;

		public StringDecrypterInfo(MethodDef method)
			: this(method, null) {
		}

		public StringDecrypterInfo(MethodDef method, FieldDef field) {
			Method = method;
			Field = field;
		}

		public override int GetHashCode() {
			int hash = 0;
			if (Method != null)
				hash ^= Method.GetHashCode();
			if (Field != null)
				hash ^= Field.GetHashCode();
			return hash;
		}

		public override bool Equals(object obj) {
			var other = obj as StringDecrypterInfo;
			return other != null &&
				Method == other.Method &&
				Field == other.Field;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Agile_NET/vm/CilOperandInstructionRestorer.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace de4dot.code.deobfuscators.Agile_NET.vm {
	// Tries to restore the operands of the following CIL instructions:
	//	ldelema, ldelem.*, stelem.*, ldobj, stobj
	class CilOperandInstructionRestorer {
		MethodDef method;

		public bool Restore(MethodDef method) {
			this.method = method;
			bool atLeastOneFailed = false;

			if (method == null || method.Body == null)
				return !atLeastOneFailed;

			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count; i++) {
				var instr = instrs[i];
				if (instr.Operand != null)
					continue;

				TypeSig operandType = null, operandTypeTmp;
				OpCode newOpCode = null;
				SZArraySig arrayType;
				switch (instr.OpCode.Code) {
				case Code.Ldelem:
					arrayType = MethodStack.GetLoadedType(method, instrs, i, 1) as SZArraySig;
					if (arrayType == null)
						break;
					operandTypeTmp = arrayType.Next;
					if (operandTypeTmp == null)
						newOpCode = OpCodes.Ldelem_Ref;
					else {
						switch (operandTypeTmp.ElementType) {
						case ElementType.Boolean: newOpCode = OpCodes.Ldelem_I1; break;
						case ElementType.Char: newOpCode = OpCodes.Ldelem_U2; break;
						case ElementType.I:  newOpCode = OpCodes.Ldelem_I; break;
						case ElementType.I1: newOpCode = OpCodes.Ldelem_I1; break;
						case ElementType.I2: newOpCode = OpCodes.Ldelem_I2; break;
						case ElementType.I4: newOpCode = OpCodes.Ldelem_I4; break;
						case ElementType.I8: newOpCode = OpCodes.Ldelem_I8; break;
						case ElementType.U:  newOpCode = OpCodes.Ldelem_I; break;
						case ElementType.U1: newOpCode = OpCodes.Ldelem_U1; break;
						case ElementType.U2: newOpCode = OpCodes.Ldelem_U2; break;
						case ElementType.U4: newOpCode = OpCodes.Ldelem_U4; break;
						case ElementType.U8: newOpCode = OpCodes.Ldelem_I8; break;
						case ElementType.R4: newOpCode = OpCodes.Ldelem_R4; break;
						case ElementType.R8: newOpCode = OpCodes.Ldelem_R8; break;
						default:             newOpCode = OpCodes.Ldelem_Ref; break;
						//TODO: Ldelem
						}
					}
					break;

				case Code.Stelem:
					arrayType = MethodStack.GetLoadedType(method, instrs, i, 2) as SZArraySig;
					if (arrayType == null)
						break;
					operandTypeTmp = arrayType.Next;
					if (operandTypeTmp == null)
						newOpCode = OpCodes.Stelem_Ref;
					else {
						switch (operandTypeTmp.ElementType) {
						case ElementType.U:
						case ElementType.I:  newOpCode = OpCodes.Stelem_I; break;
						case ElementType.Boolean:
						case ElementType.U1:
						case ElementType.I1: newOpCode = OpCodes.Stelem_I1; break;
						case ElementType.Char:
						case ElementType.U2:
						case ElementType.I2: newOpCode = OpCodes.Stelem_I2; break;
						case ElementType.U4:
						case ElementType.I4: newOpCode = OpCodes.Stelem_I4; break;
						case ElementType.U8:
						case ElementType.I8: newOpCode = OpCodes.Stelem_I8; break;
						case ElementType.R4: newOpCode = OpCodes.Stelem_R4; break;
						case ElementType.R8: newOpCode = OpCodes.Stelem_R8; break;
						default: newOpCode = OpCodes.Stelem_Ref; break;
						//TODO: Stelem
						}
					}
					break;

				case Code.Ldelema:
					arrayType = MethodStack.GetLoadedType(method, instrs, i, 1) as SZArraySig;
					if (arrayType == null)
						break;
					operandType = arrayType.Next;
					if (!operandType.IsValueType) {
						newOpCode = OpCodes.Ldelem_Ref;
						operandType = null;
					}
					break;

				case Code.Ldobj:
					operandType = GetPtrElementType(MethodStack.GetLoadedType(method, instrs, i, 0));
					break;

				case Code.Stobj:
					operandType = MethodStack.GetLoadedType(method, instrs, i, 0);
					if (!IsValidType(operandType))
						operandType = GetPtrElementType(MethodStack.GetLoadedType(method, instrs, i, 1));
					break;

				default:
					continue;
				}
				if (newOpCode == null && !IsValidType(operandType)) {
					atLeastOneFailed = true;
					continue;
				}

				instr.Operand = operandType.ToTypeDefOrRef();
				if (newOpCode != null)
					instr.OpCode = newOpCode;
			}

			return !atLeastOneFailed;
		}

		static TypeSig GetPtrElementType(TypeSig type) {
			if (type == null)
				return null;
			if (type.IsPointer || type.IsByRef)
				return type.Next;
			return null;
		}

		bool IsValidType(TypeSig type) {
			type = type.RemovePinnedAndModifiers();
			if (type == null)
				return false;
			if (type.ElementType == ElementType.Void)
				return false;

			while (type != null) {
				switch (type.ElementType) {
				case ElementType.SZArray:
				case ElementType.Array:
				case ElementType.GenericInst:
				case ElementType.Ptr:
				case ElementType.Class:
				case ElementType.ValueType:
				case ElementType.FnPtr:
				case ElementType.Void:
				case ElementType.Boolean:
				case ElementType.Char:
				case ElementType.I1:
				case ElementType.U1:
				case ElementType.I2:
				case ElementType.U2:
				case ElementType.I4:
				case ElementType.U4:
				case ElementType.I8:
				case ElementType.U8:
				case ElementType.R4:
				case ElementType.R8:
				case ElementType.TypedByRef:
				case ElementType.I:
				case ElementType.U:
				case ElementType.String:
				case ElementType.Object:
					break;

				case ElementType.MVar:
					var gmvar = (GenericMVar)type;
					if (gmvar.Number >= method.MethodSig.GetGenParamCount())
						return false;
					break;

				case ElementType.Var:
					var gvar = (GenericVar)type;
					var dt = method.DeclaringType;
					if (dt == null || gvar.Number >= dt.GenericParameters.Count)
						return false;
					break;

				case ElementType.ByRef:
				case ElementType.CModOpt:
				case ElementType.CModReqd:
				case ElementType.Pinned:
				case ElementType.Sentinel:
				case ElementType.ValueArray:
				case ElementType.R:
				case ElementType.End:
				case ElementType.Internal:
				case ElementType.Module:
				default:
					return false;
				}
				if (type.Next == null)
					break;
				type = type.Next;
			}

			return type != null;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Agile_NET/vm/CsvmDataReader.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.IO;

namespace de4dot.code.deobfuscators.Agile_NET.vm {
	class CsvmDataReader {
		DataReader reader;

		public CsvmDataReader(DataReader reader) {
			reader.Position = 0;
			this.reader = reader;
		}

		public List<CsvmMethodData> Read() {
			int numMethods = reader.ReadInt32();
			if (numMethods < 0)
				throw new ApplicationException("Invalid number of methods");
			var methods = new List<CsvmMethodData>(numMethods);

			for (int i = 0; i < numMethods; i++) {
				var csvmMethod = new CsvmMethodData();
				csvmMethod.Guid = new Guid(reader.ReadBytes(16));
				csvmMethod.Token = reader.ReadInt32();
				csvmMethod.Locals = reader.ReadBytes(reader.ReadInt32());
				csvmMethod.Instructions = reader.ReadBytes(reader.ReadInt32());
				csvmMethod.Exceptions = reader.ReadBytes(reader.ReadInt32());
				methods.Add(csvmMethod);
			}

			return methods;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Agile_NET/vm/CsvmMethodData.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;

namespace de4dot.code.deobfuscators.Agile_NET.vm {
	class CsvmMethodData {
		public Guid Guid { get; set; }
		public int Token { get; set; }
		public byte[] Locals { get; set; }
		public byte[] Instructions { get; set; }
		public byte[] Exceptions { get; set; }
		public override string ToString() => $"{Token:X8} - {Guid}";
	}
}



================================================
File: de4dot.code/deobfuscators/Agile_NET/vm/CsvmToCilMethodConverterBase.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.IO;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Agile_NET.vm {
	abstract class CsvmToCilMethodConverterBase {
		readonly IDeobfuscatorContext deobfuscatorContext;
		readonly protected ModuleDefMD module;
		readonly CilOperandInstructionRestorer operandRestorer = new CilOperandInstructionRestorer();
		readonly Dictionary<Instruction, int> cilToVmIndex = new Dictionary<Instruction, int>();
		readonly Dictionary<int, Instruction> vmIndexToCil = new Dictionary<int, Instruction>();

		public CsvmToCilMethodConverterBase(IDeobfuscatorContext deobfuscatorContext, ModuleDefMD module) {
			this.deobfuscatorContext = deobfuscatorContext;
			this.module = module;
		}

		protected void SetCilToVmIndex(Instruction instr, int vmIndex) => cilToVmIndex[instr] = vmIndex;
		protected void SetVmIndexToCil(Instruction instr, int vmIndex) => vmIndexToCil[vmIndex] = instr;

		public void Convert(MethodDef cilMethod, CsvmMethodData csvmMethod) {
			cilToVmIndex.Clear();
			vmIndexToCil.Clear();

			var newInstructions = ReadInstructions(cilMethod, csvmMethod);
			/*var newLocals =*/ ReadLocals(cilMethod, csvmMethod);
			var newExceptions = ReadExceptions(cilMethod, csvmMethod);

			FixInstructionOperands(newInstructions);
			FixLocals(newInstructions, cilMethod.Body.Variables);
			FixArgs(newInstructions, cilMethod);

			DotNetUtils.RestoreBody(cilMethod, newInstructions, newExceptions);

			if (!operandRestorer.Restore(cilMethod))
				Logger.w("Failed to restore one or more instruction operands in CSVM method {0:X8}", cilMethod.MDToken.ToInt32());
			RestoreConstrainedPrefix(cilMethod);
		}

		void FixLocals(IList<Instruction> instrs, IList<Local> locals) {
			foreach (var instr in instrs) {
				var op = instr.Operand as LocalOperand;
				if (op == null)
					continue;

				UpdateLocalInstruction(instr, locals[op.Local], op.Local);
			}
		}

		static void UpdateLocalInstruction(Instruction instr, Local local, int index) {
			object operand = null;
			OpCode opcode;

			switch (instr.OpCode.Code) {
			case Code.Ldloc_S:
			case Code.Ldloc:
				if (index == 0)
					opcode = OpCodes.Ldloc_0;
				else if (index == 1)
					opcode = OpCodes.Ldloc_1;
				else if (index == 2)
					opcode = OpCodes.Ldloc_2;
				else if (index == 3)
					opcode = OpCodes.Ldloc_3;
				else if (byte.MinValue <= index && index <= byte.MaxValue) {
					opcode = OpCodes.Ldloc_S;
					operand = local;
				}
				else {
					opcode = OpCodes.Ldloc;
					operand = local;
				}
				break;

			case Code.Stloc:
			case Code.Stloc_S:
				if (index == 0)
					opcode = OpCodes.Stloc_0;
				else if (index == 1)
					opcode = OpCodes.Stloc_1;
				else if (index == 2)
					opcode = OpCodes.Stloc_2;
				else if (index == 3)
					opcode = OpCodes.Stloc_3;
				else if (byte.MinValue <= index && index <= byte.MaxValue) {
					opcode = OpCodes.Stloc_S;
					operand = local;
				}
				else {
					opcode = OpCodes.Stloc;
					operand = local;
				}
				break;

			case Code.Ldloca:
			case Code.Ldloca_S:
				if (byte.MinValue <= index && index <= byte.MaxValue) {
					opcode = OpCodes.Ldloca_S;
					operand = local;
				}
				else {
					opcode = OpCodes.Ldloca;
					operand = local;
				}
				break;

			default:
				throw new ApplicationException("Invalid opcode");
			}

			instr.OpCode = opcode;
			instr.Operand = operand;
		}

		void FixArgs(IList<Instruction> instrs, MethodDef method) {
			foreach (var instr in instrs) {
				var op = instr.Operand as ArgOperand;
				if (op == null)
					continue;

				UpdateArgInstruction(instr, method.Parameters[op.Arg], op.Arg);
			}
		}

		static void UpdateArgInstruction(Instruction instr, Parameter arg, int index) {
			switch (instr.OpCode.Code) {
			case Code.Ldarg:
			case Code.Ldarg_S:
				if (index == 0) {
					instr.OpCode = OpCodes.Ldarg_0;
					instr.Operand = null;
				}
				else if (index == 1) {
					instr.OpCode = OpCodes.Ldarg_1;
					instr.Operand = null;
				}
				else if (index == 2) {
					instr.OpCode = OpCodes.Ldarg_2;
					instr.Operand = null;
				}
				else if (index == 3) {
					instr.OpCode = OpCodes.Ldarg_3;
					instr.Operand = null;
				}
				else if (byte.MinValue <= index && index <= byte.MaxValue) {
					instr.OpCode = OpCodes.Ldarg_S;
					instr.Operand = arg;
				}
				else {
					instr.OpCode = OpCodes.Ldarg;
					instr.Operand = arg;
				}
				break;

			case Code.Starg:
			case Code.Starg_S:
				if (byte.MinValue <= index && index <= byte.MaxValue) {
					instr.OpCode = OpCodes.Starg_S;
					instr.Operand = arg;
				}
				else {
					instr.OpCode = OpCodes.Starg;
					instr.Operand = arg;
				}
				break;

			case Code.Ldarga:
			case Code.Ldarga_S:
				if (byte.MinValue <= index && index <= byte.MaxValue) {
					instr.OpCode = OpCodes.Ldarga_S;
					instr.Operand = arg;
				}
				else {
					instr.OpCode = OpCodes.Ldarga;
					instr.Operand = arg;
				}
				break;

			default:
				throw new ApplicationException("Invalid opcode");
			}
		}

		protected abstract List<Instruction> ReadInstructions(MethodDef cilMethod, CsvmMethodData csvmMethod);

		protected static int GetInstructionSize(Instruction instr) {
			var opcode = instr.OpCode;
			if (opcode == null)
				return 5;	// Load store/field
			var op = instr.Operand as SwitchTargetDisplOperand;
			if (op == null)
				return instr.GetSize();
			return instr.OpCode.Size + (op.TargetDisplacements.Length + 1) * 4;
		}

		List<Local> ReadLocals(MethodDef cilMethod, CsvmMethodData csvmMethod) {
			var locals = new List<Local>();
			var reader = new BinaryReader(new MemoryStream(csvmMethod.Locals));

			if (csvmMethod.Locals.Length == 0)
				return locals;

			// v6.0.0.5 sometimes duplicates the last two locals so only check for a negative value.
			int numLocals = reader.ReadInt32();
			if (numLocals < 0)
				throw new ApplicationException("Invalid number of locals");

			var gpContext = GenericParamContext.Create(cilMethod);
			for (int i = 0; i < numLocals; i++)
				locals.Add(new Local(ReadTypeRef(reader, gpContext)));

			return locals;
		}

		TypeSig ReadTypeRef(BinaryReader reader, GenericParamContext gpContext) {
			var etype = (ElementType)reader.ReadInt32();
			switch (etype) {
			case ElementType.Void: return module.CorLibTypes.Void;
			case ElementType.Boolean: return module.CorLibTypes.Boolean;
			case ElementType.Char: return module.CorLibTypes.Char;
			case ElementType.I1: return module.CorLibTypes.SByte;
			case ElementType.U1: return module.CorLibTypes.Byte;
			case ElementType.I2: return module.CorLibTypes.Int16;
			case ElementType.U2: return module.CorLibTypes.UInt16;
			case ElementType.I4: return module.CorLibTypes.Int32;
			case ElementType.U4: return module.CorLibTypes.UInt32;
			case ElementType.I8: return module.CorLibTypes.Int64;
			case ElementType.U8: return module.CorLibTypes.UInt64;
			case ElementType.R4: return module.CorLibTypes.Single;
			case ElementType.R8: return module.CorLibTypes.Double;
			case ElementType.String: return module.CorLibTypes.String;
			case ElementType.TypedByRef: return module.CorLibTypes.TypedReference;
			case ElementType.I: return module.CorLibTypes.IntPtr;
			case ElementType.U: return module.CorLibTypes.UIntPtr;
			case ElementType.Object: return module.CorLibTypes.Object;

			case ElementType.ValueType:
			case ElementType.Var:
			case ElementType.MVar:
				return (module.ResolveToken(reader.ReadUInt32(), gpContext) as ITypeDefOrRef).ToTypeSig();

			case ElementType.GenericInst:
				etype = (ElementType)reader.ReadInt32();
				if (etype == ElementType.ValueType)
					return (module.ResolveToken(reader.ReadUInt32(), gpContext) as ITypeDefOrRef).ToTypeSig();
				// ElementType.Class
				return module.CorLibTypes.Object;

			case ElementType.Ptr:
			case ElementType.Class:
			case ElementType.Array:
			case ElementType.FnPtr:
			case ElementType.SZArray:
			case ElementType.ByRef:
			case ElementType.CModReqd:
			case ElementType.CModOpt:
			case ElementType.Internal:
			case ElementType.Sentinel:
			case ElementType.Pinned:
			default:
				return module.CorLibTypes.Object;
			}
		}

		List<ExceptionHandler> ReadExceptions(MethodDef cilMethod, CsvmMethodData csvmMethod) {
			var reader = new BinaryReader(new MemoryStream(csvmMethod.Exceptions));
			var ehs = new List<ExceptionHandler>();

			if (reader.BaseStream.Length == 0)
				return ehs;

			int numExceptions = reader.ReadInt32();
			if (numExceptions < 0)
				throw new ApplicationException("Invalid number of exception handlers");

			var gpContext = GenericParamContext.Create(cilMethod);
			for (int i = 0; i < numExceptions; i++) {
				var eh = new ExceptionHandler((ExceptionHandlerType)reader.ReadInt32());
				eh.TryStart = GetInstruction(reader.ReadInt32());
				eh.TryEnd = GetInstructionEnd(reader.ReadInt32());
				eh.HandlerStart = GetInstruction(reader.ReadInt32());
				eh.HandlerEnd = GetInstructionEnd(reader.ReadInt32());
				if (eh.HandlerType == ExceptionHandlerType.Catch)
					eh.CatchType = module.ResolveToken(reader.ReadUInt32(), gpContext) as ITypeDefOrRef;
				else if (eh.HandlerType == ExceptionHandlerType.Filter)
					eh.FilterStart = GetInstruction(reader.ReadInt32());

				ehs.Add(eh);
			}

			return ehs;
		}

		Instruction GetInstruction(int vmIndex) => vmIndexToCil[vmIndex];

		Instruction GetInstructionEnd(int vmIndex) {
			vmIndex++;
			vmIndexToCil.TryGetValue(vmIndex, out var instr);
			return instr;
		}

		Instruction GetInstruction(Instruction source, int displ) {
			int vmIndex = cilToVmIndex[source];
			return vmIndexToCil[vmIndex + displ];
		}

		void FixInstructionOperands(IList<Instruction> instrs) {
			foreach (var instr in instrs) {
				if (instr.Operand is IVmOperand op)
					instr.Operand = FixOperand(instrs, instr, op);
			}
		}

		object FixOperand(IList<Instruction> instrs, Instruction instr, IVmOperand vmOperand) {
			if (vmOperand is TargetDisplOperand)
				return GetInstruction(instr, ((TargetDisplOperand)vmOperand).Displacement);

			if (vmOperand is SwitchTargetDisplOperand) {
				var targetDispls = ((SwitchTargetDisplOperand)vmOperand).TargetDisplacements;
				var targets = new Instruction[targetDispls.Length];
				for (int i = 0; i < targets.Length; i++)
					targets[i] = GetInstruction(instr, targetDispls[i]);
				return targets;
			}

			if (vmOperand is ArgOperand || vmOperand is LocalOperand)
				return vmOperand;

			if (vmOperand is FieldInstructionOperand fieldInfo)
				return FixLoadStoreFieldInstruction(instr, fieldInfo.Field, fieldInfo.StaticOpCode, fieldInfo.InstanceOpCode);

			throw new ApplicationException($"Unknown operand type: {vmOperand.GetType()}");
		}

		IField FixLoadStoreFieldInstruction(Instruction instr, IField fieldRef, OpCode staticInstr, OpCode instanceInstr) {
			var field = deobfuscatorContext.ResolveField(fieldRef);
			bool isStatic;
			if (field == null) {
				Logger.w("Could not resolve field {0:X8}. Assuming it's not static.", fieldRef == null ? 0 : fieldRef.MDToken.Raw);
				isStatic = false;
			}
			else
				isStatic = field.IsStatic;
			instr.OpCode = isStatic ? staticInstr : instanceInstr;
			return fieldRef;
		}

		static void RestoreConstrainedPrefix(MethodDef method) {
			if (method == null || method.Body == null)
				return;

			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count; i++) {
				var instr = instrs[i];
				if (instr.OpCode.Code != Code.Callvirt)
					continue;

				var calledMethod = instr.Operand as IMethod;
				if (calledMethod == null)
					continue;
				var sig = calledMethod.MethodSig;
				if (sig == null || !sig.HasThis)
					continue;
				var thisType = MethodStack.GetLoadedType(method, instrs, i, sig.Params.Count) as ByRefSig;
				if (thisType == null)
					continue;
				if (HasPrefix(instrs, i, Code.Constrained))
					continue;
				instrs.Insert(i, OpCodes.Constrained.ToInstruction(thisType.Next.ToTypeDefOrRef()));
				i++;
			}
		}

		static bool HasPrefix(IList<Instruction> instrs, int index, Code prefix) {
			index--;
			for (; index >= 0; index--) {
				var instr = instrs[index];
				if (instr.OpCode.OpCodeType != OpCodeType.Prefix)
					break;
				if (instr.OpCode.Code == prefix)
					return true;
			}
			return false;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Agile_NET/vm/VmOperand.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace de4dot.code.deobfuscators.Agile_NET.vm {
	interface IVmOperand {
	}

	class TargetDisplOperand : IVmOperand {
		public readonly int Displacement;   // number of VM instructions from current VM instr
		public TargetDisplOperand(int displacement) => Displacement = displacement;
	}

	class SwitchTargetDisplOperand : IVmOperand {
		public readonly int[] TargetDisplacements;  // number of VM instructions from current VM instr
		public SwitchTargetDisplOperand(int[] targetDisplacements) => TargetDisplacements = targetDisplacements;
	}

	class ArgOperand : IVmOperand {
		public readonly ushort Arg;
		public ArgOperand(ushort arg) => Arg = arg;
	}

	class LocalOperand : IVmOperand {
		public readonly ushort Local;
		public LocalOperand(ushort local) => Local = local;
	}

	class FieldInstructionOperand : IVmOperand {
		public readonly OpCode StaticOpCode;
		public readonly OpCode InstanceOpCode;
		public readonly IField Field;

		public FieldInstructionOperand(OpCode staticOpCode, OpCode instanceOpCode, IField field) {
			StaticOpCode = staticOpCode;
			InstanceOpCode = instanceOpCode;
			Field = field;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Agile_NET/vm/v1/Csvm.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.IO;
using dnlib.DotNet;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Agile_NET.vm.v1 {
	class Csvm {
		IDeobfuscatorContext deobfuscatorContext;
		ModuleDefMD module;
		EmbeddedResource resource;
		AssemblyRef vmAssemblyRef;

		public bool Detected => resource != null && vmAssemblyRef != null;
		public EmbeddedResource Resource => Detected ? resource : null;

		public Csvm(IDeobfuscatorContext deobfuscatorContext, ModuleDefMD module) {
			this.deobfuscatorContext = deobfuscatorContext;
			this.module = module;
		}

		public Csvm(IDeobfuscatorContext deobfuscatorContext, ModuleDefMD module, Csvm oldOne) {
			this.deobfuscatorContext = deobfuscatorContext;
			this.module = module;
			if (oldOne.resource != null)
				resource = (EmbeddedResource)module.Resources[oldOne.module.Resources.IndexOf(oldOne.resource)];
			if (oldOne.vmAssemblyRef != null)
				vmAssemblyRef = module.ResolveAssemblyRef(oldOne.vmAssemblyRef.Rid);
		}

		public void Find() {
			resource = FindCsvmResource();
			vmAssemblyRef = FindVmAssemblyRef();
		}

		AssemblyRef FindVmAssemblyRef() {
			foreach (var memberRef in module.GetMemberRefs()) {
				var sig = memberRef.MethodSig;
				if (sig == null)
					continue;
				if (sig.RetType.GetElementType() != ElementType.Object)
					continue;
				if (sig.Params.Count != 2)
					continue;
				if (memberRef.Name != "RunMethod")
					continue;
				if (memberRef.FullName == "System.Object VMRuntime.Libraries.CSVMRuntime::RunMethod(System.String,System.Object[])")
					return memberRef.DeclaringType.Scope as AssemblyRef;
			}
			return null;
		}

		EmbeddedResource FindCsvmResource() => DotNetUtils.GetResource(module, "_CSVM") as EmbeddedResource;

		public bool Restore() {
			if (!Detected)
				return true;

			int oldIndent = Logger.Instance.IndentLevel;
			try {
				Restore2();
				return true;
			}
			catch {
				return false;
			}
			finally {
				Logger.Instance.IndentLevel = oldIndent;
			}
		}

		void Restore2() {
			Logger.v("Restoring CSVM methods");
			Logger.Instance.Indent();

			var opcodeDetector = GetVmOpCodeHandlerDetector();
			var csvmMethods = new CsvmDataReader(resource.CreateReader()).Read();
			var converter = new CsvmToCilMethodConverter(deobfuscatorContext, module, opcodeDetector);
			var methodPrinter = new MethodPrinter();
			foreach (var csvmMethod in csvmMethods) {
				var cilMethod = module.ResolveToken(csvmMethod.Token) as MethodDef;
				if (cilMethod == null)
					throw new ApplicationException($"Could not find method {csvmMethod.Token:X8}");
				converter.Convert(cilMethod, csvmMethod);
				Logger.v("Restored method {0:X8}", cilMethod.MDToken.ToInt32());
				PrintMethod(methodPrinter, cilMethod);
			}
			Logger.Instance.DeIndent();
			Logger.n("Restored {0} CSVM methods", csvmMethods.Count);
		}

		static void PrintMethod(MethodPrinter methodPrinter, MethodDef method) {
			const LoggerEvent dumpLogLevel = LoggerEvent.Verbose;
			if (Logger.Instance.IgnoresEvent(dumpLogLevel))
				return;

			Logger.Instance.Indent();

			Logger.v("Locals:");
			Logger.Instance.Indent();
			for (int i = 0; i < method.Body.Variables.Count; i++)
				Logger.v("#{0}: {1}", i, method.Body.Variables[i].Type);
			Logger.Instance.DeIndent();

			Logger.v("Code:");
			Logger.Instance.Indent();
			methodPrinter.Print(dumpLogLevel, method.Body.Instructions, method.Body.ExceptionHandlers);
			Logger.Instance.DeIndent();

			Logger.Instance.DeIndent();
		}

		VmOpCodeHandlerDetector GetVmOpCodeHandlerDetector() {
			var vmFilename = vmAssemblyRef.Name + ".dll";
			var vmModulePath = Path.Combine(Path.GetDirectoryName(module.Location), vmFilename);
			Logger.v("CSVM filename: {0}", vmFilename);

			var dataKey = "cs cached VmOpCodeHandlerDetector v1";
			var dict = (Dictionary<string, VmOpCodeHandlerDetector>)deobfuscatorContext.GetData(dataKey);
			if (dict == null)
				deobfuscatorContext.SetData(dataKey, dict = new Dictionary<string, VmOpCodeHandlerDetector>(StringComparer.OrdinalIgnoreCase));
			if (dict.TryGetValue(vmModulePath, out var detector))
				return detector;
			dict[vmModulePath] = detector = new VmOpCodeHandlerDetector(ModuleDefMD.Load(vmModulePath));

			detector.FindHandlers();
			Logger.v("CSVM opcodes:");
			Logger.Instance.Indent();
			for (int i = 0; i < detector.Handlers.Count; i++)
				Logger.v("{0:X4}: {1}", i, detector.Handlers[i].Name);
			Logger.Instance.DeIndent();

			return detector;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Agile_NET/vm/v1/CsvmToCilMethodConverter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using System.IO;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace de4dot.code.deobfuscators.Agile_NET.vm.v1 {
	class CsvmToCilMethodConverter : CsvmToCilMethodConverterBase {
		VmOpCodeHandlerDetector opCodeDetector;

		public CsvmToCilMethodConverter(IDeobfuscatorContext deobfuscatorContext, ModuleDefMD module, VmOpCodeHandlerDetector opCodeDetector)
			: base(deobfuscatorContext, module) => this.opCodeDetector = opCodeDetector;

		protected override List<Instruction> ReadInstructions(MethodDef cilMethod, CsvmMethodData csvmMethod) {
			var gpContext = GenericParamContext.Create(cilMethod);
			var reader = new BinaryReader(new MemoryStream(csvmMethod.Instructions));
			var instrs = new List<Instruction>();
			uint offset = 0;
			while (reader.BaseStream.Position < reader.BaseStream.Length) {
				int vmOpCode = reader.ReadUInt16();
				var instr = opCodeDetector.Handlers[vmOpCode].Read(reader, module, gpContext);
				instr.Offset = offset;
				offset += (uint)GetInstructionSize(instr);
				SetCilToVmIndex(instr, instrs.Count);
				SetVmIndexToCil(instr, instrs.Count);
				instrs.Add(instr);
			}
			return instrs;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Agile_NET/vm/v1/FieldsInfo.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet;

namespace de4dot.code.deobfuscators.Agile_NET.vm.v1 {
	class FieldsInfo {
		public static readonly object EnumType = new object();
		Dictionary<string, int> fieldTypes = new Dictionary<string, int>(StringComparer.Ordinal);
		int numEnums = 0;

		public FieldsInfo(TypeDef type)
			: this(type.Fields) {
		}

		public FieldsInfo(IEnumerable<FieldDef> fields) {
			foreach (var field in fields) {
				var fieldTypeDef = field.FieldSig.GetFieldType().TryGetTypeDef();
				if (fieldTypeDef != null && fieldTypeDef.IsEnum)
					AddEnum();
				else
					Add(field.FieldSig.GetFieldType());
			}
		}

		public FieldsInfo(object[] fieldTypes) {
			foreach (var o in fieldTypes) {
				if (o == EnumType)
					AddEnum();
				else
					Add((string)o);
			}
		}

		void Add(TypeSig type) => Add(type.GetFullName());

		void Add(string typeFullName) {
			fieldTypes.TryGetValue(typeFullName, out int count);
			fieldTypes[typeFullName] = count + 1;
		}

		void AddEnum() => numEnums++;

		public bool IsSame(FieldsInfo other) {
			if (numEnums != other.numEnums)
				return false;
			if (fieldTypes.Count != other.fieldTypes.Count)
				return false;
			foreach (var kv in fieldTypes) {
				if (!other.fieldTypes.TryGetValue(kv.Key, out int num))
					return false;
				if (kv.Value != num)
					return false;
			}
			return true;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Agile_NET/vm/v1/OpCodeHandler.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.IO;
using de4dot.blocks;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace de4dot.code.deobfuscators.Agile_NET.vm.v1 {
	partial class OpCodeHandler {
		public string Name { get; set; }
		public OpCodeHandlerSigInfo OpCodeHandlerSigInfo { get; set; }
		public Predicate<UnknownHandlerInfo> Check { get; set; }
		public Func<BinaryReader, IInstructionOperandResolver, GenericParamContext, Instruction> Read { get; set; }

		public bool Detect(UnknownHandlerInfo info) {
			var sigInfo = OpCodeHandlerSigInfo;

			if (!Compare(sigInfo.NumStaticMethods, info.NumStaticMethods))
				return false;
			if (!Compare(sigInfo.NumInstanceMethods, info.NumInstanceMethods))
				return false;
			if (!Compare(sigInfo.NumVirtualMethods, info.NumVirtualMethods))
				return false;
			if (!Compare(sigInfo.NumCtors, info.NumCtors))
				return false;
			if (!Compare(sigInfo.ExecuteMethodThrows, info.ExecuteMethodThrows))
				return false;
			if (!Compare(sigInfo.ExecuteMethodPops, info.ExecuteMethodPops))
				return false;
			if (!info.HasSameFieldTypes(sigInfo.RequiredFieldTypes))
				return false;
			if (sigInfo.ExecuteMethodLocals != null && !new LocalTypes(info.ExecuteMethod).All(sigInfo.ExecuteMethodLocals))
				return false;

			if (Check != null)
				return Check(info);
			return true;
		}

		static bool Compare(int? val1, int val2) {
			if (!val1.HasValue)
				return true;
			return val1.Value == val2;
		}

		public override string ToString() => Name;
	}

	static partial class OpCodeHandlers {
		static Instruction arithmetic_read(BinaryReader reader, IInstructionOperandResolver resolver, GenericParamContext gpContext) {
			switch (reader.ReadByte()) {
			case 0: return OpCodes.Add.ToInstruction();
			case 1: return OpCodes.Add_Ovf.ToInstruction();
			case 2: return OpCodes.Add_Ovf_Un.ToInstruction();
			case 3: return OpCodes.Sub.ToInstruction();
			case 4: return OpCodes.Sub_Ovf.ToInstruction();
			case 5: return OpCodes.Sub_Ovf_Un.ToInstruction();
			case 6: return OpCodes.Mul.ToInstruction();
			case 7: return OpCodes.Mul_Ovf.ToInstruction();
			case 8: return OpCodes.Mul_Ovf_Un.ToInstruction();
			case 9: return OpCodes.Div.ToInstruction();
			case 10: return OpCodes.Div_Un.ToInstruction();
			case 11: return OpCodes.Rem.ToInstruction();
			case 12: return OpCodes.Rem_Un.ToInstruction();
			default: throw new ApplicationException("Invalid opcode");
			}
		}

		static bool newarr_check(UnknownHandlerInfo info) =>
			DotNetUtils.CallsMethod(info.ExecuteMethod, "System.Type System.Reflection.Module::ResolveType(System.Int32)");

		static Instruction newarr_read(BinaryReader reader, IInstructionOperandResolver resolver, GenericParamContext gpContext) =>
			new Instruction(OpCodes.Newarr, resolver.ResolveToken(reader.ReadUInt32(), gpContext));

		static Instruction box_read(BinaryReader reader, IInstructionOperandResolver resolver, GenericParamContext gpContext) {
			var instr = new Instruction();
			switch (reader.ReadByte()) {
			case 0: instr.OpCode = OpCodes.Box; break;
			case 1: instr.OpCode = OpCodes.Unbox_Any; break;
			default: throw new ApplicationException("Invalid opcode");
			}
			instr.Operand = resolver.ResolveToken(reader.ReadUInt32(), gpContext);
			return instr;
		}

		static Instruction call_read(BinaryReader reader, IInstructionOperandResolver resolver, GenericParamContext gpContext) {
			var instr = new Instruction();
			switch (reader.ReadByte()) {
			case 0: instr.OpCode = OpCodes.Newobj; break;
			case 1: instr.OpCode = OpCodes.Call; break;
			case 2: instr.OpCode = OpCodes.Callvirt; break;
			default: throw new ApplicationException("Invalid opcode");
			}
			instr.Operand = resolver.ResolveToken(reader.ReadUInt32(), gpContext);
			return instr;
		}

		static Instruction cast_read(BinaryReader reader, IInstructionOperandResolver resolver, GenericParamContext gpContext) {
			var instr = new Instruction();
			switch (reader.ReadByte()) {
			case 0: instr.OpCode = OpCodes.Castclass; break;
			case 1: instr.OpCode = OpCodes.Isinst; break;
			default: throw new ApplicationException("Invalid opcode");
			}
			instr.Operand = resolver.ResolveToken(reader.ReadUInt32(), gpContext);
			return instr;
		}

		static Instruction compare_read(BinaryReader reader, IInstructionOperandResolver resolver, GenericParamContext gpContext) {
			int type = reader.ReadByte();
			var instr = new Instruction();
			switch (type) {
			case 0: instr.OpCode = OpCodes.Br; break;
			case 1: instr.OpCode = OpCodes.Brtrue; break;
			case 2: instr.OpCode = OpCodes.Brfalse; break;
			case 3: instr.OpCode = OpCodes.Beq; break;
			case 4: instr.OpCode = OpCodes.Bge; break;
			case 5: instr.OpCode = OpCodes.Bgt; break;
			case 6: instr.OpCode = OpCodes.Ble; break;
			case 7: instr.OpCode = OpCodes.Blt; break;
			case 8: instr.OpCode = OpCodes.Bne_Un; break;
			case 9: instr.OpCode = OpCodes.Bge_Un; break;
			case 10: instr.OpCode = OpCodes.Bgt_Un; break;
			case 11: instr.OpCode = OpCodes.Ble_Un; break;
			case 12: instr.OpCode = OpCodes.Blt_Un; break;
			case 13: instr.OpCode = OpCodes.Ceq; break;
			case 14: instr.OpCode = OpCodes.Cgt; break;
			case 15: instr.OpCode = OpCodes.Clt; break;
			case 16: instr.OpCode = OpCodes.Cgt_Un; break;
			case 17: instr.OpCode = OpCodes.Clt_Un; break;
			default: throw new ApplicationException("Invalid opcode");
			}
			if (type < 13)
				instr.Operand = new TargetDisplOperand(reader.ReadInt32());

			return instr;
		}

		class InstructionInfo1 {
			public byte Type { get; set; }
			public bool Second { get; set; }
			public bool Third { get; set; }
			public OpCode OpCode { get; set; }
		}
		static List<InstructionInfo1> instructionInfos1 = new List<InstructionInfo1> {
			new InstructionInfo1 { Type = 0, Second = false, Third = false, OpCode = OpCodes.Conv_I1 },
			new InstructionInfo1 { Type = 1, Second = false, Third = false, OpCode = OpCodes.Conv_I2 },
			new InstructionInfo1 { Type = 2, Second = false, Third = false, OpCode = OpCodes.Conv_I4 },
			new InstructionInfo1 { Type = 3, Second = false, Third = false, OpCode = OpCodes.Conv_I8 },
			new InstructionInfo1 { Type = 4, Second = false, Third = false, OpCode = OpCodes.Conv_R4 },
			new InstructionInfo1 { Type = 5, Second = false, Third = false, OpCode = OpCodes.Conv_R8 },
			new InstructionInfo1 { Type = 6, Second = false, Third = false, OpCode = OpCodes.Conv_U1 },
			new InstructionInfo1 { Type = 7, Second = false, Third = false, OpCode = OpCodes.Conv_U2 },
			new InstructionInfo1 { Type = 8, Second = false, Third = false, OpCode = OpCodes.Conv_U4 },
			new InstructionInfo1 { Type = 9, Second = false, Third = false, OpCode = OpCodes.Conv_U8 },
			new InstructionInfo1 { Type = 10, Second = false, Third = false, OpCode = OpCodes.Conv_I },
			new InstructionInfo1 { Type = 11, Second = false, Third = false, OpCode = OpCodes.Conv_U },

			new InstructionInfo1 { Type = 0, Second = true, Third = false, OpCode = OpCodes.Conv_Ovf_I1 },
			new InstructionInfo1 { Type = 1, Second = true, Third = false, OpCode = OpCodes.Conv_Ovf_I2 },
			new InstructionInfo1 { Type = 2, Second = true, Third = false, OpCode = OpCodes.Conv_Ovf_I4 },
			new InstructionInfo1 { Type = 3, Second = true, Third = false, OpCode = OpCodes.Conv_Ovf_I8 },
			new InstructionInfo1 { Type = 6, Second = true, Third = false, OpCode = OpCodes.Conv_Ovf_U1 },
			new InstructionInfo1 { Type = 7, Second = true, Third = false, OpCode = OpCodes.Conv_Ovf_U2 },
			new InstructionInfo1 { Type = 8, Second = true, Third = false, OpCode = OpCodes.Conv_Ovf_U4 },
			new InstructionInfo1 { Type = 9, Second = true, Third = false, OpCode = OpCodes.Conv_Ovf_U8 },
			new InstructionInfo1 { Type = 10, Second = true, Third = false, OpCode = OpCodes.Conv_Ovf_I },
			new InstructionInfo1 { Type = 11, Second = true, Third = false, OpCode = OpCodes.Conv_Ovf_U },

			new InstructionInfo1 { Type = 0, Second = true, Third = true, OpCode = OpCodes.Conv_Ovf_I1_Un },
			new InstructionInfo1 { Type = 1, Second = true, Third = true, OpCode = OpCodes.Conv_Ovf_I2_Un },
			new InstructionInfo1 { Type = 2, Second = true, Third = true, OpCode = OpCodes.Conv_Ovf_I4_Un },
			new InstructionInfo1 { Type = 3, Second = true, Third = true, OpCode = OpCodes.Conv_Ovf_I8_Un },
			new InstructionInfo1 { Type = 6, Second = true, Third = true, OpCode = OpCodes.Conv_Ovf_U1_Un },
			new InstructionInfo1 { Type = 7, Second = true, Third = true, OpCode = OpCodes.Conv_Ovf_U2_Un },
			new InstructionInfo1 { Type = 8, Second = true, Third = true, OpCode = OpCodes.Conv_Ovf_U4_Un },
			new InstructionInfo1 { Type = 9, Second = true, Third = true, OpCode = OpCodes.Conv_Ovf_U8_Un },
			new InstructionInfo1 { Type = 10, Second = true, Third = true, OpCode = OpCodes.Conv_Ovf_I_Un },
			new InstructionInfo1 { Type = 11, Second = true, Third = true, OpCode = OpCodes.Conv_Ovf_U_Un },
			new InstructionInfo1 { Type = 12, Second = true, Third = true, OpCode = OpCodes.Conv_R_Un },
		};
		static Instruction convert_read(BinaryReader reader, IInstructionOperandResolver resolver, GenericParamContext gpContext) {
			byte type = reader.ReadByte();
			bool second = reader.ReadBoolean();
			bool third = reader.ReadBoolean();

			Instruction instr = null;
			foreach (var info in instructionInfos1) {
				if (type != info.Type || info.Second != second || info.Third != third)
					continue;

				instr = new Instruction(info.OpCode);
				break;
			}
			if (instr == null)
				throw new ApplicationException("Invalid opcode");

			return instr;
		}

		static Instruction dup_read(BinaryReader reader, IInstructionOperandResolver resolver, GenericParamContext gpContext) {
			switch (reader.ReadByte()) {
			case 0: return OpCodes.Dup.ToInstruction();
			case 1: return OpCodes.Pop.ToInstruction();
			default: throw new ApplicationException("Invalid opcode");
			}
		}

		class InstructionInfo2 {
			public bool First { get; set; }
			public bool Second { get; set; }
			public int Value { get; set; }
			public OpCode OpCode { get; set; }
		}
		static List<InstructionInfo2> instructionInfos2 = new List<InstructionInfo2> {
			new InstructionInfo2 { First = false, Second = true, Value = 24, OpCode = OpCodes.Stelem_I },
			new InstructionInfo2 { First = false, Second = true, Value = 4, OpCode = OpCodes.Stelem_I1 },
			new InstructionInfo2 { First = false, Second = true, Value = 6, OpCode = OpCodes.Stelem_I2 },
			new InstructionInfo2 { First = false, Second = true, Value = 8, OpCode = OpCodes.Stelem_I4 },
			new InstructionInfo2 { First = false, Second = true, Value = 10, OpCode = OpCodes.Stelem_I8 },
			new InstructionInfo2 { First = false, Second = true, Value = 12, OpCode = OpCodes.Stelem_R4 },
			new InstructionInfo2 { First = false, Second = true, Value = 13, OpCode = OpCodes.Stelem_R8 },
			new InstructionInfo2 { First = false, Second = true, Value = 28, OpCode = OpCodes.Stelem_Ref },
			new InstructionInfo2 { First = false, Second = false, Value = 0, OpCode = OpCodes.Stelem },

			new InstructionInfo2 { First = true, Second = true, Value = 24, OpCode = OpCodes.Ldelem_I },
			new InstructionInfo2 { First = true, Second = true, Value = 4, OpCode = OpCodes.Ldelem_I1 },
			new InstructionInfo2 { First = true, Second = true, Value = 6, OpCode = OpCodes.Ldelem_I2 },
			new InstructionInfo2 { First = true, Second = true, Value = 8, OpCode = OpCodes.Ldelem_I4 },
			new InstructionInfo2 { First = true, Second = true, Value = 10, OpCode = OpCodes.Ldelem_I8 },
			new InstructionInfo2 { First = true, Second = true, Value = 5, OpCode = OpCodes.Ldelem_U1 },
			new InstructionInfo2 { First = true, Second = true, Value = 7, OpCode = OpCodes.Ldelem_U2 },
			new InstructionInfo2 { First = true, Second = true, Value = 9, OpCode = OpCodes.Ldelem_U4 },
			new InstructionInfo2 { First = true, Second = true, Value = 12, OpCode = OpCodes.Ldelem_R4 },
			new InstructionInfo2 { First = true, Second = true, Value = 13, OpCode = OpCodes.Ldelem_R8 },
			new InstructionInfo2 { First = true, Second = true, Value = 28, OpCode = OpCodes.Ldelem_Ref },
			new InstructionInfo2 { First = true, Second = false, Value = 0, OpCode = OpCodes.Ldelem },
		};
		static Instruction ldelem_read(BinaryReader reader, IInstructionOperandResolver resolver, GenericParamContext gpContext) {
			Instruction instr = null;
			bool first = reader.ReadBoolean();
			bool second = reader.ReadBoolean();
			int value = reader.ReadInt32();
			foreach (var info in instructionInfos2) {
				if (info.First != first || info.Second != second)
					continue;
				if (second && value != info.Value)
					continue;

				if (second)
					instr = new Instruction(info.OpCode);
				else
					instr = new Instruction(info.OpCode, resolver.ResolveToken((uint)value, gpContext));
				break;
			}
			if (instr == null)
				throw new ApplicationException("Invalid opcode");

			return instr;
		}

		static bool endfinally_check(UnknownHandlerInfo info) =>
			DotNetUtils.CallsMethod(info.ExecuteMethod, "System.Reflection.MethodInfo System.Type::GetMethod(System.String,System.Reflection.BindingFlags)");

		static Instruction endfinally_read(BinaryReader reader, IInstructionOperandResolver resolver, GenericParamContext gpContext) =>
			OpCodes.Endfinally.ToInstruction();

		static Instruction ldfld_read(BinaryReader reader, IInstructionOperandResolver resolver, GenericParamContext gpContext) {
			byte b = reader.ReadByte();
			var field = resolver.ResolveToken(reader.ReadUInt32(), gpContext) as IField;
			switch (b) {
			case 0: return new Instruction(null, new FieldInstructionOperand(OpCodes.Ldsfld, OpCodes.Ldfld, field));
			case 1: return new Instruction(null, new FieldInstructionOperand(OpCodes.Ldsflda, OpCodes.Ldflda, field));
			case 2: return new Instruction(null, new FieldInstructionOperand(OpCodes.Stsfld, OpCodes.Stfld, field));
			default: throw new ApplicationException("Invalid opcode");
			}
		}

		static Instruction initobj_read(BinaryReader reader, IInstructionOperandResolver resolver, GenericParamContext gpContext) =>
			new Instruction(OpCodes.Initobj, resolver.ResolveToken(reader.ReadUInt32(), gpContext));

		static Instruction ldloc_read(BinaryReader reader, IInstructionOperandResolver resolver, GenericParamContext gpContext) {
			bool isLdarg = reader.ReadBoolean();
			ushort index = reader.ReadUInt16();

			var instr = new Instruction();
			if (isLdarg) {
				instr.OpCode = OpCodes.Ldarg;
				instr.Operand = new ArgOperand(index);
			}
			else {
				instr.OpCode = OpCodes.Ldloc;
				instr.Operand = new LocalOperand(index);
			}

			return instr;
		}

		static Instruction ldloca_read(BinaryReader reader, IInstructionOperandResolver resolver, GenericParamContext gpContext) {
			var instr = new Instruction();
			if (reader.ReadBoolean()) {
				instr.OpCode = OpCodes.Ldarga;
				instr.Operand = new ArgOperand(reader.ReadUInt16());
			}
			else {
				instr.OpCode = OpCodes.Ldloca;
				instr.Operand = new LocalOperand(reader.ReadUInt16());
			}

			return instr;
		}

		static Instruction ldelema_read(BinaryReader reader, IInstructionOperandResolver resolver, GenericParamContext gpContext) =>
			new Instruction(OpCodes.Ldelema, null);

		static Instruction ldlen_read(BinaryReader reader, IInstructionOperandResolver resolver, GenericParamContext gpContext) =>
			OpCodes.Ldlen.ToInstruction();

		static Instruction ldobj_read(BinaryReader reader, IInstructionOperandResolver resolver, GenericParamContext gpContext) =>
			new Instruction(OpCodes.Ldobj, null);

		static Instruction ldstr_read(BinaryReader reader, IInstructionOperandResolver resolver, GenericParamContext gpContext) =>
			OpCodes.Ldstr.ToInstruction(reader.ReadString());

		static bool ldtoken_check(UnknownHandlerInfo info) =>
			DotNetUtils.CallsMethod(info.ExecuteMethod, "System.Reflection.MemberInfo System.Reflection.Module::ResolveMember(System.Int32)");

		static Instruction ldtoken_read(BinaryReader reader, IInstructionOperandResolver resolver, GenericParamContext gpContext) =>
			new Instruction(OpCodes.Ldtoken, resolver.ResolveToken(reader.ReadUInt32(), gpContext));

		static bool leave_check(UnknownHandlerInfo info) =>
			!DotNetUtils.CallsMethod(info.ExecuteMethod, "System.Reflection.MethodBase System.Reflection.Module::ResolveMethod(System.Int32)") &&
			!DotNetUtils.CallsMethod(info.ExecuteMethod, "System.Type System.Reflection.Module::ResolveType(System.Int32)") &&
			!DotNetUtils.CallsMethod(info.ExecuteMethod, "System.Reflection.MemberInfo System.Reflection.Module::ResolveMember(System.Int32)");

		static Instruction leave_read(BinaryReader reader, IInstructionOperandResolver resolver, GenericParamContext gpContext) {
			int displacement = reader.ReadInt32();
			return new Instruction(OpCodes.Leave, new TargetDisplOperand(displacement));
		}

		static Instruction ldc_read(BinaryReader reader, IInstructionOperandResolver resolver, GenericParamContext gpContext) {
			switch ((ElementType)reader.ReadByte()) {
			case ElementType.I4: return Instruction.CreateLdcI4(reader.ReadInt32());
			case ElementType.I8: return OpCodes.Ldc_I8.ToInstruction(reader.ReadInt64());
			case ElementType.R4: return OpCodes.Ldc_R4.ToInstruction(reader.ReadSingle());
			case ElementType.R8: return OpCodes.Ldc_R8.ToInstruction(reader.ReadDouble());
			case ElementType.Object: return OpCodes.Ldnull.ToInstruction();
			default: throw new ApplicationException("Invalid opcode");
			}
		}

		static Instruction ldftn_read(BinaryReader reader, IInstructionOperandResolver resolver, GenericParamContext gpContext) {
			byte code = reader.ReadByte();
			uint token = reader.ReadUInt32();

			switch (code) {
			case 0:
				return new Instruction(OpCodes.Ldftn, resolver.ResolveToken(token, gpContext));

			case 1:
				reader.ReadInt32();	// token of newobj .ctor
				return new Instruction(OpCodes.Ldvirtftn, resolver.ResolveToken(token, gpContext));

			default:
				throw new ApplicationException("Invalid opcode");
			}
		}

		static Instruction logical_read(BinaryReader reader, IInstructionOperandResolver resolver, GenericParamContext gpContext) {
			switch (reader.ReadByte()) {
			case 0: return OpCodes.And.ToInstruction();
			case 1: return OpCodes.Or.ToInstruction();
			case 2: return OpCodes.Xor.ToInstruction();
			case 3: return OpCodes.Shl.ToInstruction();
			case 4: return OpCodes.Shr.ToInstruction();
			case 5: return OpCodes.Shr_Un.ToInstruction();
			default: throw new ApplicationException("Invalid opcode");
			}
		}

		static bool nop_check(UnknownHandlerInfo info) => IsEmptyMethod(info.ReadMethod) && IsEmptyMethod(info.ExecuteMethod);

		static bool IsEmptyMethod(MethodDef method) {
			foreach (var instr in method.Body.Instructions) {
				if (instr.OpCode.Code == Code.Ret)
					return true;
				if (instr.OpCode.Code != Code.Nop)
					break;
			}
			return false;
		}

		static Instruction nop_read(BinaryReader reader, IInstructionOperandResolver resolver, GenericParamContext gpContext) =>
			OpCodes.Nop.ToInstruction();

		static bool ret_check(UnknownHandlerInfo info) =>
			DotNetUtils.CallsMethod(info.ExecuteMethod, "System.Reflection.MethodBase System.Reflection.Module::ResolveMethod(System.Int32)");

		static Instruction ret_read(BinaryReader reader, IInstructionOperandResolver resolver, GenericParamContext gpContext) {
			reader.ReadInt32();	// token of current method
			return OpCodes.Ret.ToInstruction();
		}

		static bool rethrow_check(UnknownHandlerInfo info) => info.ExecuteMethod.Body.Variables.Count == 0;
		static Instruction rethrow_read(BinaryReader reader, IInstructionOperandResolver resolver, GenericParamContext gpContext) =>
			OpCodes.Rethrow.ToInstruction();

		static Instruction stloc_read(BinaryReader reader, IInstructionOperandResolver resolver, GenericParamContext gpContext) {
			bool isStarg = reader.ReadBoolean();
			ushort index = reader.ReadUInt16();

			var instr = new Instruction();
			if (isStarg) {
				instr.OpCode = OpCodes.Starg;
				instr.Operand = new ArgOperand(index);
			}
			else {
				instr.OpCode = OpCodes.Stloc;
				instr.Operand = new LocalOperand(index);
				reader.ReadInt32();	// ElementType of local
			}

			return instr;
		}

		static Instruction stobj_read(BinaryReader reader, IInstructionOperandResolver resolver, GenericParamContext gpContext) =>
			new Instruction(OpCodes.Stobj, null);

		static Instruction switch_read(BinaryReader reader, IInstructionOperandResolver resolver, GenericParamContext gpContext) {
			int numTargets = reader.ReadInt32();
			int[] targetDispls = new int[numTargets];
			for (int i = 0; i < targetDispls.Length; i++)
				targetDispls[i] = reader.ReadInt32();
			return new Instruction(OpCodes.Switch, new SwitchTargetDisplOperand(targetDispls));
		}

		static bool throw_check(UnknownHandlerInfo info) =>
			!DotNetUtils.CallsMethod(info.ExecuteMethod, "System.Reflection.MethodInfo System.Type::GetMethod(System.String,System.Reflection.BindingFlags)");

		static Instruction throw_read(BinaryReader reader, IInstructionOperandResolver resolver, GenericParamContext gpContext) =>
			OpCodes.Throw.ToInstruction();

		static Instruction neg_read(BinaryReader reader, IInstructionOperandResolver resolver, GenericParamContext gpContext) {
			switch (reader.ReadByte()) {
			case 0: return OpCodes.Neg.ToInstruction();
			case 1: return OpCodes.Not.ToInstruction();
			default: throw new ApplicationException("Invalid opcode");
			}
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Agile_NET/vm/v1/OpCodeHandlers.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

namespace de4dot.code.deobfuscators.Agile_NET.vm.v1 {
	static partial class OpCodeHandlers {
		public static readonly OpCodeHandler[][] Handlers = new OpCodeHandler[][] {
			new OpCodeHandler[] {
				new OpCodeHandler {
					Name = "arithmetic",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							FieldsInfo.EnumType,
						},
						NumStaticMethods = 0,
						NumInstanceMethods = 14,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = arithmetic_read,
				},

				new OpCodeHandler {
					Name = "newarr",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							"System.UInt32",
						},
						ExecuteMethodLocals = new string[] {
							"System.Object",
							"System.Int32",
							"System.Type",
							"System.IntPtr",
						},
						ExecuteMethodThrows = 0,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = newarr_check,
					Read = newarr_read,
				},

				new OpCodeHandler {
					Name = "box/unbox",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							FieldsInfo.EnumType,
							"System.UInt32",
						},
						NumStaticMethods = 0,
						NumInstanceMethods = 2,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = box_read,
				},

				new OpCodeHandler {
					Name = "call",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							"System.Collections.Generic.Dictionary`2<System.String,System.Int32>",
							"System.Collections.Generic.Dictionary`2<System.Reflection.MethodInfo,System.Reflection.Emit.DynamicMethod>",
							"System.Reflection.MethodBase",
							"System.UInt32",
							FieldsInfo.EnumType,
						},
						NumStaticMethods = 2,
						NumInstanceMethods = 4,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = call_read,
				},

				new OpCodeHandler {
					Name = "cast",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							"System.UInt32",
							FieldsInfo.EnumType,
						},
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 2,
					},
					Check = null,
					Read = cast_read,
				},

				new OpCodeHandler {
					Name = "compare",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							"System.Int32",
							FieldsInfo.EnumType,
						},
						NumStaticMethods = 1,
						NumInstanceMethods = 7,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = compare_read,
				},

				new OpCodeHandler {
					Name = "convert",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							FieldsInfo.EnumType,
							"System.Boolean",
							"System.Boolean",
						},
						NumStaticMethods = 0,
						NumInstanceMethods = 13,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = convert_read,
				},

				new OpCodeHandler {
					Name = "dup/pop",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							FieldsInfo.EnumType,
						},
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = dup_read,
				},

				new OpCodeHandler {
					Name = "ldelem/stelem",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							"System.Boolean",
							"System.Boolean",
							FieldsInfo.EnumType,
							"System.UInt32",
						},
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = ldelem_read,
				},

				new OpCodeHandler {
					Name = "endfinally",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[0],
						ExecuteMethodThrows = 2,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = endfinally_check,
					Read = endfinally_read,
				},

				new OpCodeHandler {
					Name = "load/store field",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							"System.UInt32",
							FieldsInfo.EnumType,
						},
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = ldfld_read,
				},

				new OpCodeHandler {
					Name = "initobj",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							"System.UInt32",
						},
						ExecuteMethodLocals = new string[] {
							"System.Type",
						},
						ExecuteMethodThrows = 1,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = initobj_read,
				},

				new OpCodeHandler {
					Name = "load local/arg",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							"System.Boolean",
							"System.UInt16",
						},
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = ldloc_read,
				},

				new OpCodeHandler {
					Name = "load local/arg address",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							"System.Boolean",
							"System.UInt32",
						},
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = ldloca_read,
				},

				new OpCodeHandler {
					Name = "ldelema",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[0],
						ExecuteMethodLocals = new string[] {
							"System.Int32",
							"System.Array",
						},
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = ldelema_read,
				},

				new OpCodeHandler {
					Name = "ldlen",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[0],
						ExecuteMethodLocals = new string[] {
							"System.Array",
							"System.Object",
						},
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = ldlen_read,
				},

				new OpCodeHandler {
					Name = "ldobj",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[0],
						ExecuteMethodThrows = 1,
						ExecuteMethodPops = 1,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = ldobj_read,
				},

				new OpCodeHandler {
					Name = "ldstr",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							"System.String",
						},
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = ldstr_read,
				},

				new OpCodeHandler {
					Name = "ldtoken",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							"System.UInt32",
						},
						ExecuteMethodLocals = new string[] {
							"System.Object",
							"System.Reflection.MemberInfo",
						},
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = ldtoken_check,
					Read = ldtoken_read,
				},

				new OpCodeHandler {
					Name = "leave",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							"System.Int32",
						},
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = leave_check,
					Read = leave_read,
				},

				new OpCodeHandler {
					Name = "load constant",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							"System.Object",
						},
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = ldc_read,
				},

				new OpCodeHandler {
					Name = "load func",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							FieldsInfo.EnumType,
							"System.UInt32",
							"System.UInt32",
						},
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = ldftn_read,
				},

				new OpCodeHandler {
					Name = "logical",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							FieldsInfo.EnumType,
						},
						NumStaticMethods = 0,
						NumInstanceMethods = 6,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = logical_read,
				},

				new OpCodeHandler {
					Name = "nop",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[0],
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = nop_check,
					Read = nop_read,
				},

				new OpCodeHandler {
					Name = "ret",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							"System.UInt32",
						},
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = ret_check,
					Read = ret_read,
				},

				new OpCodeHandler {
					Name = "rethrow",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[0],
						ExecuteMethodThrows = 1,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = rethrow_check,
					Read = rethrow_read,
				},

				new OpCodeHandler {
					Name = "store local/arg",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							"System.Boolean",
							"System.UInt16",
							FieldsInfo.EnumType,
						},
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = stloc_read,
				},

				new OpCodeHandler {
					Name = "stobj",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[0],
						ExecuteMethodThrows = 1,
						ExecuteMethodPops = 2,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = stobj_read,
				},

				new OpCodeHandler {
					Name = "switch",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							"System.UInt32",
							"System.Int32[]",
						},
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = switch_read,
				},

				new OpCodeHandler {
					Name = "throw",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[0],
						ExecuteMethodLocals = new string[] {
							"System.Object",
						},
						ExecuteMethodThrows = 2,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = throw_check,
					Read = throw_read,
				},

				new OpCodeHandler {
					Name = "neg/not",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							FieldsInfo.EnumType,
						},
						NumStaticMethods = 0,
						NumInstanceMethods = 2,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = neg_read,
				},
			},

			new OpCodeHandler[] {
				new OpCodeHandler {
					Name = "arithmetic",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							FieldsInfo.EnumType,
							"System.Boolean",
						},
						ExecuteMethodLocals = new string[] {
							"System.Object",
							"System.Boolean",
						},
						ExecuteMethodThrows = 1,
						ExecuteMethodPops = 2,
						NumStaticMethods = 0,
						NumInstanceMethods = 14,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = arithmetic_read,
				},

				new OpCodeHandler {
					Name = "box/unbox",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							FieldsInfo.EnumType,
							"System.UInt32",
							FieldsInfo.EnumType,
						},
						ExecuteMethodLocals = new string[] {
							"System.Object",
							"System.Type",
							"System.Boolean",
						},
						ExecuteMethodThrows = 0,
						ExecuteMethodPops = 2,
						NumStaticMethods = 0,
						NumInstanceMethods = 2,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = box_read,
				},

				new OpCodeHandler {
					Name = "call",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							"System.Collections.Generic.Dictionary`2<System.String,System.Int32>",
							"System.Collections.Generic.Dictionary`2<System.Reflection.MethodInfo,System.Reflection.Emit.DynamicMethod>",
							"System.Reflection.MethodBase",
							"System.UInt32",
							FieldsInfo.EnumType,
							FieldsInfo.EnumType,
							"System.Boolean",
						},
						ExecuteMethodLocals = new string[] {
							"System.Boolean",
							"System.Object",
							"System.Reflection.ParameterInfo[]",
							"System.Int32",
							"System.Object[]",
							"System.Reflection.ConstructorInfo",
							"System.Reflection.MethodInfo",
						},
						ExecuteMethodThrows = 1,
						ExecuteMethodPops = 2,
						NumStaticMethods = 2,
						NumInstanceMethods = 4,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = call_read,
				},

				new OpCodeHandler {
					Name = "cast",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							"System.UInt32",
							FieldsInfo.EnumType,
							"System.Reflection.MethodBase",
						},
						ExecuteMethodLocals = new string[] {
							"System.Type",
							"System.Object",
							"System.Boolean",
						},
						ExecuteMethodThrows = 1,
						ExecuteMethodPops = 1,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 2,
					},
					Check = null,
					Read = cast_read,
				},

				new OpCodeHandler {
					Name = "compare",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							"System.Int32",
							FieldsInfo.EnumType,
						},
						ExecuteMethodLocals = new string[] {
							"System.Int32",
							"System.Object",
							"System.Boolean",
						},
						ExecuteMethodThrows = 1,
						ExecuteMethodPops = 2,
						NumStaticMethods = 1,
						NumInstanceMethods = 7,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = compare_read,
				},

				new OpCodeHandler {
					Name = "convert",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							FieldsInfo.EnumType,
							"System.Boolean",
							"System.Boolean",
							"System.UInt32",
						},
						ExecuteMethodLocals = new string[] {
							"System.Object",
							"System.Boolean",
						},
						ExecuteMethodThrows = 0,
						ExecuteMethodPops = 1,
						NumStaticMethods = 0,
						NumInstanceMethods = 13,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = convert_read,
				},

				new OpCodeHandler {
					Name = "dup/pop",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							FieldsInfo.EnumType,
						},
						ExecuteMethodThrows = 0,
						ExecuteMethodPops = 1,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = dup_read,
				},

				new OpCodeHandler {
					Name = "endfinally",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							"System.UInt32",
						},
						ExecuteMethodLocals = new string[] {
							"System.Int32",
						},
						ExecuteMethodThrows = 2,
						ExecuteMethodPops = 0,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = endfinally_check,
					Read = endfinally_read,
				},

				new OpCodeHandler {
					Name = "initobj",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							"System.UInt32",
							"System.Boolean",
						},
						ExecuteMethodLocals = new string[] {
							"System.Type",
							"System.Boolean",
						},
						ExecuteMethodThrows = 1,
						ExecuteMethodPops = 1,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = initobj_read,
				},

				new OpCodeHandler {
					Name = "ldelem/stelem",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							"System.Boolean",
							"System.Boolean",
							FieldsInfo.EnumType,
							"System.UInt32",
						},
						ExecuteMethodLocals = new string[] {
							"System.Int32",
							"System.Array",
							"System.Object",
							"System.Type",
							"System.Boolean",
						},
						ExecuteMethodThrows = 0,
						ExecuteMethodPops = 5,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = ldelem_read,
				},

				new OpCodeHandler {
					Name = "ldelema",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[0],
						ExecuteMethodLocals = new string[] {
							"System.Int32",
							"System.Array",
						},
						ExecuteMethodThrows = 0,
						ExecuteMethodPops = 2,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = ldelema_read,
				},

				new OpCodeHandler {
					Name = "ldlen",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[0],
						ExecuteMethodLocals = new string[] {
							"System.Array",
							"System.Object",
							"System.Boolean",
						},
						ExecuteMethodThrows = 0,
						ExecuteMethodPops = 1,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = ldlen_read,
				},

				new OpCodeHandler {
					Name = "ldobj",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[0],
						ExecuteMethodLocals = new string[] {
							"System.Boolean",
						},
						ExecuteMethodThrows = 1,
						ExecuteMethodPops = 1,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = ldobj_read,
				},

				new OpCodeHandler {
					Name = "ldstr",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							"System.String",
						},
						ExecuteMethodThrows = 0,
						ExecuteMethodPops = 0,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = ldstr_read,
				},

				new OpCodeHandler {
					Name = "ldtoken",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							"System.UInt32",
						},
						ExecuteMethodLocals = new string[] {
							"System.Object",
							"System.Reflection.MemberInfo",
							"System.Boolean",
						},
						ExecuteMethodThrows = 1,
						ExecuteMethodPops = 0,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = ldtoken_check,
					Read = ldtoken_read,
				},

				new OpCodeHandler {
					Name = "leave",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							"System.Int32",
						},
						ExecuteMethodLocals = new string[] {
							"System.Int32",
							"System.Boolean",
						},
						ExecuteMethodThrows = 0,
						ExecuteMethodPops = 0,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = leave_check,
					Read = leave_read,
				},

				new OpCodeHandler {
					Name = "load constant",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							"System.Object",
							"System.Boolean",
							"System.UInt16",
						},
						ExecuteMethodLocals = new string[] {
							"System.Boolean",
						},
						ExecuteMethodThrows = 0,
						ExecuteMethodPops = 1,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = ldc_read,
				},

				new OpCodeHandler {
					Name = "load func",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							FieldsInfo.EnumType,
							"System.UInt32",
							"System.UInt32",
						},
						ExecuteMethodLocals = new string[] {
							"System.Reflection.MethodBase",
							"System.IntPtr",
							"System.Type",
							"System.Delegate",
							"System.RuntimeMethodHandle",
						},
						ExecuteMethodThrows = 0,
						ExecuteMethodPops = 1,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = ldftn_read,
				},

				new OpCodeHandler {
					Name = "load local/arg",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							"System.Boolean",
							"System.UInt16",
							"System.Boolean",
						},
						ExecuteMethodLocals = new string[] {
							"System.Boolean",
						},
						ExecuteMethodThrows = 0,
						ExecuteMethodPops = 0,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = ldloc_read,
				},

				new OpCodeHandler {
					Name = "load local/arg address",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							"System.Boolean",
							"System.UInt32",
						},
						ExecuteMethodLocals = new string[] {
							"System.Array",
							"System.Boolean",
						},
						ExecuteMethodThrows = 0,
						ExecuteMethodPops = 0,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = ldloca_read,
				},

				new OpCodeHandler {
					Name = "load/store field",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							"System.UInt32",
							FieldsInfo.EnumType,
						},
						ExecuteMethodLocals = new string[] {
							"System.Reflection.FieldInfo",
							"System.Object",
							"System.Boolean",
						},
						ExecuteMethodThrows = 0,
						ExecuteMethodPops = 4,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = ldfld_read,
				},

				new OpCodeHandler {
					Name = "logical",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							FieldsInfo.EnumType,
							FieldsInfo.EnumType,
						},
						ExecuteMethodLocals = new string[] {
							"System.Object",
							"System.Boolean",
						},
						ExecuteMethodThrows = 1,
						ExecuteMethodPops = 2,
						NumStaticMethods = 0,
						NumInstanceMethods = 6,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = logical_read,
				},

				new OpCodeHandler {
					Name = "neg/not",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							FieldsInfo.EnumType,
						},
						ExecuteMethodLocals = new string[] {
							"System.Object",
						},
						ExecuteMethodThrows = 1,
						ExecuteMethodPops = 1,
						NumStaticMethods = 0,
						NumInstanceMethods = 2,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = neg_read,
				},

				new OpCodeHandler {
					Name = "newarr",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							"System.UInt32",
						},
						ExecuteMethodLocals = new string[] {
							"System.Object",
							"System.Int32",
							"System.Type",
							"System.Boolean",
							"System.IntPtr",
						},
						ExecuteMethodThrows = 0,
						ExecuteMethodPops = 1,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = newarr_check,
					Read = newarr_read,
				},

				new OpCodeHandler {
					Name = "nop",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[0],
						ExecuteMethodThrows = 0,
						ExecuteMethodPops = 0,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = nop_check,
					Read = nop_read,
				},

				new OpCodeHandler {
					Name = "ret",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							"System.UInt32",
						},
						ExecuteMethodLocals = new string[] {
							"System.Reflection.MethodInfo",
							"System.Type",
							"System.Object",
							"System.Boolean",
						},
						ExecuteMethodThrows = 0,
						ExecuteMethodPops = 1,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = ret_check,
					Read = ret_read,
				},

				new OpCodeHandler {
					Name = "rethrow",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[0],
						ExecuteMethodThrows = 1,
						ExecuteMethodPops = 0,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = rethrow_check,
					Read = rethrow_read,
				},

				new OpCodeHandler {
					Name = "stobj",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[0],
						ExecuteMethodLocals = new string[] {
							"System.Boolean",
						},
						ExecuteMethodThrows = 1,
						ExecuteMethodPops = 2,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = stobj_read,
				},

				new OpCodeHandler {
					Name = "store local/arg",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							"System.Boolean",
							"System.UInt16",
							FieldsInfo.EnumType,
						},
						ExecuteMethodLocals = new string[] {
							"System.Object",
							"System.Boolean",
						},
						ExecuteMethodThrows = 0,
						ExecuteMethodPops = 1,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = stloc_read,
				},

				new OpCodeHandler {
					Name = "switch",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							"System.UInt32",
							"System.Int32[]",
						},
						ExecuteMethodLocals = new string[] {
							"System.Int32",
							"System.Boolean",
						},
						ExecuteMethodThrows = 0,
						ExecuteMethodPops = 1,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = switch_read,
				},

				new OpCodeHandler {
					Name = "throw",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[0],
						ExecuteMethodLocals = new string[] {
							"System.Object",
							"System.Boolean",
						},
						ExecuteMethodThrows = 2,
						ExecuteMethodPops = 1,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = throw_check,
					Read = throw_read,
				},
			},

			new OpCodeHandler[] {
				new OpCodeHandler {
					Name = "arithmetic",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							FieldsInfo.EnumType,
							"System.Double",
						},
						ExecuteMethodLocals = new string[] {
							"System.Object",
							"System.Boolean",
						},
						ExecuteMethodThrows = 1,
						ExecuteMethodPops = 2,
						NumStaticMethods = 0,
						NumInstanceMethods = 14,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = arithmetic_read,
				},

				new OpCodeHandler {
					Name = "box/unbox",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							FieldsInfo.EnumType,
							"System.UInt32",
							FieldsInfo.EnumType,
						},
						ExecuteMethodLocals = new string[] {
							"System.Object",
							"System.Type",
							"System.Boolean",
						},
						ExecuteMethodThrows = 0,
						ExecuteMethodPops = 2,
						NumStaticMethods = 0,
						NumInstanceMethods = 2,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = box_read,
				},

				new OpCodeHandler {
					Name = "call",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							"System.Collections.Generic.Dictionary`2<System.Reflection.Module,System.Collections.Generic.Dictionary`2<System.Int32,System.Reflection.MethodBase>>",
							"System.Collections.Generic.Dictionary`2<System.String,System.Int32>",
							"System.Collections.Generic.Dictionary`2<System.Reflection.MethodInfo,System.Reflection.Emit.DynamicMethod>",
							"System.Reflection.MethodBase",
							"System.UInt32",
							FieldsInfo.EnumType,
							FieldsInfo.EnumType,
							"System.Boolean",
						},
						ExecuteMethodLocals = new string[] {
							"System.Boolean",
							"System.Reflection.Module",
							"System.Collections.Generic.Dictionary`2<System.Int32,System.Reflection.MethodBase>",
							"System.Object",
							"System.Reflection.ParameterInfo[]",
							"System.Int32",
							"System.Object[]",
							"System.Reflection.ConstructorInfo",
							"System.Reflection.MethodInfo",
							"System.Collections.Generic.Dictionary`2<System.Reflection.Module,System.Collections.Generic.Dictionary`2<System.Int32,System.Reflection.MethodBase>>",
						},
						ExecuteMethodThrows = 1,
						ExecuteMethodPops = 2,
						NumStaticMethods = 2,
						NumInstanceMethods = 4,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = call_read,
				},

				new OpCodeHandler {
					Name = "cast",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							"System.UInt32",
							FieldsInfo.EnumType,
							"System.Reflection.MethodBase",
						},
						ExecuteMethodLocals = new string[] {
							"System.Type",
							"System.Object",
							"System.Boolean",
						},
						ExecuteMethodThrows = 1,
						ExecuteMethodPops = 1,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 2,
					},
					Check = null,
					Read = cast_read,
				},

				new OpCodeHandler {
					Name = "compare",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							"System.Int32",
							FieldsInfo.EnumType,
						},
						ExecuteMethodLocals = new string[] {
							"System.Int32",
							"System.Object",
							"System.Boolean",
						},
						ExecuteMethodThrows = 1,
						ExecuteMethodPops = 2,
						NumStaticMethods = 1,
						NumInstanceMethods = 7,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = compare_read,
				},

				new OpCodeHandler {
					Name = "convert",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							FieldsInfo.EnumType,
							"System.Boolean",
							"System.Boolean",
							"System.UInt16",
						},
						ExecuteMethodLocals = new string[] {
							"System.Object",
							"System.Boolean",
						},
						ExecuteMethodThrows = 0,
						ExecuteMethodPops = 1,
						NumStaticMethods = 0,
						NumInstanceMethods = 13,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = convert_read,
				},

				new OpCodeHandler {
					Name = "dup/pop",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							FieldsInfo.EnumType,
						},
						ExecuteMethodThrows = 0,
						ExecuteMethodPops = 1,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = dup_read,
				},

				new OpCodeHandler {
					Name = "endfinally",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							"System.UInt32",
						},
						ExecuteMethodLocals = new string[] {
							"System.Int32",
						},
						ExecuteMethodThrows = 2,
						ExecuteMethodPops = 0,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = endfinally_check,
					Read = endfinally_read,
				},

				new OpCodeHandler {
					Name = "initobj",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							"System.UInt32",
							"System.Double",
						},
						ExecuteMethodLocals = new string[] {
							"System.Type",
							"System.Boolean",
						},
						ExecuteMethodThrows = 1,
						ExecuteMethodPops = 1,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = initobj_read,
				},

				new OpCodeHandler {
					Name = "ldelem/stelem",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							"System.Boolean",
							"System.Boolean",
							FieldsInfo.EnumType,
							"System.UInt32",
						},
						ExecuteMethodLocals = new string[] {
							"System.Int32",
							"System.Array",
							"System.Object",
							"System.Type",
							"System.Boolean",
						},
						ExecuteMethodThrows = 0,
						ExecuteMethodPops = 5,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = ldelem_read,
				},

				new OpCodeHandler {
					Name = "ldelema",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[0],
						ExecuteMethodLocals = new string[] {
							"System.Int32",
							"System.Array",
						},
						ExecuteMethodThrows = 0,
						ExecuteMethodPops = 2,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = ldelema_read,
				},

				new OpCodeHandler {
					Name = "ldlen",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[0],
						ExecuteMethodLocals = new string[] {
							"System.Array",
							"System.Object",
							"System.Boolean",
						},
						ExecuteMethodThrows = 0,
						ExecuteMethodPops = 1,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = ldlen_read,
				},

				new OpCodeHandler {
					Name = "ldobj",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[0],
						ExecuteMethodLocals = new string[] {
							"System.Boolean",
						},
						ExecuteMethodThrows = 1,
						ExecuteMethodPops = 1,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = ldobj_read,
				},

				new OpCodeHandler {
					Name = "ldstr",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							"System.String",
						},
						ExecuteMethodThrows = 0,
						ExecuteMethodPops = 0,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = ldstr_read,
				},

				new OpCodeHandler {
					Name = "ldtoken",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							"System.UInt32",
						},
						ExecuteMethodLocals = new string[] {
							"System.Object",
							"System.Reflection.MemberInfo",
							"System.Boolean",
						},
						ExecuteMethodThrows = 1,
						ExecuteMethodPops = 0,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = ldtoken_check,
					Read = ldtoken_read,
				},

				new OpCodeHandler {
					Name = "leave",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							"System.Int32",
						},
						ExecuteMethodLocals = new string[] {
							"System.Int32",
							"System.Boolean",
						},
						ExecuteMethodThrows = 0,
						ExecuteMethodPops = 0,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = leave_check,
					Read = leave_read,
				},

				new OpCodeHandler {
					Name = "load constant",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							"System.Object",
							"System.Double",
							"System.UInt16",
						},
						ExecuteMethodLocals = new string[] {
							"System.Boolean",
						},
						ExecuteMethodThrows = 0,
						ExecuteMethodPops = 1,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = ldc_read,
				},

				new OpCodeHandler {
					Name = "load func",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							FieldsInfo.EnumType,
							"System.UInt32",
							"System.UInt32",
						},
						ExecuteMethodLocals = new string[] {
							"System.Reflection.MethodBase",
							"System.IntPtr",
							"System.Type",
							"System.Delegate",
							"System.RuntimeMethodHandle",
						},
						ExecuteMethodThrows = 0,
						ExecuteMethodPops = 1,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = ldftn_read,
				},

				new OpCodeHandler {
					Name = "load local/arg",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							"System.Boolean",
							"System.UInt16",
							"System.UInt32",
						},
						ExecuteMethodLocals = new string[] {
							"System.Boolean",
						},
						ExecuteMethodThrows = 0,
						ExecuteMethodPops = 0,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = ldloc_read,
				},

				new OpCodeHandler {
					Name = "load local/arg address",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							"System.Boolean",
							"System.UInt32",
						},
						ExecuteMethodLocals = new string[] {
							"System.Array",
							"System.Boolean",
						},
						ExecuteMethodThrows = 0,
						ExecuteMethodPops = 0,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = ldloca_read,
				},

				new OpCodeHandler {
					Name = "load/store field",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							"System.UInt32",
							FieldsInfo.EnumType,
						},
						ExecuteMethodLocals = new string[] {
							"System.Reflection.FieldInfo",
							"System.Object",
							"System.Boolean",
						},
						ExecuteMethodThrows = 0,
						ExecuteMethodPops = 4,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = ldfld_read,
				},

				new OpCodeHandler {
					Name = "logical",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							FieldsInfo.EnumType,
							FieldsInfo.EnumType,
						},
						ExecuteMethodLocals = new string[] {
							"System.Object",
							"System.Boolean",
						},
						ExecuteMethodThrows = 1,
						ExecuteMethodPops = 2,
						NumStaticMethods = 0,
						NumInstanceMethods = 6,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = logical_read,
				},

				new OpCodeHandler {
					Name = "neg/not",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							FieldsInfo.EnumType,
						},
						ExecuteMethodLocals = new string[] {
							"System.Object",
						},
						ExecuteMethodThrows = 1,
						ExecuteMethodPops = 1,
						NumStaticMethods = 0,
						NumInstanceMethods = 2,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = neg_read,
				},

				new OpCodeHandler {
					Name = "newarr",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							"System.UInt32",
						},
						ExecuteMethodLocals = new string[] {
							"System.Object",
							"System.Int32",
							"System.Type",
							"System.Boolean",
							"System.IntPtr",
						},
						ExecuteMethodThrows = 0,
						ExecuteMethodPops = 1,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = newarr_check,
					Read = newarr_read,
				},

				new OpCodeHandler {
					Name = "nop",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[0],
						ExecuteMethodThrows = 0,
						ExecuteMethodPops = 0,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = nop_check,
					Read = nop_read,
				},

				new OpCodeHandler {
					Name = "ret",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							"System.UInt32",
						},
						ExecuteMethodLocals = new string[] {
							"System.Reflection.MethodInfo",
							"System.Type",
							"System.Object",
							"System.Boolean",
						},
						ExecuteMethodThrows = 0,
						ExecuteMethodPops = 1,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = ret_check,
					Read = ret_read,
				},

				new OpCodeHandler {
					Name = "rethrow",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[0],
						ExecuteMethodThrows = 1,
						ExecuteMethodPops = 0,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = rethrow_check,
					Read = rethrow_read,
				},

				new OpCodeHandler {
					Name = "stobj",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[0],
						ExecuteMethodLocals = new string[] {
							"System.Boolean",
						},
						ExecuteMethodThrows = 1,
						ExecuteMethodPops = 2,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = stobj_read,
				},

				new OpCodeHandler {
					Name = "store local/arg",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							"System.Boolean",
							"System.UInt16",
							FieldsInfo.EnumType,
						},
						ExecuteMethodLocals = new string[] {
							"System.Object",
							"System.Boolean",
						},
						ExecuteMethodThrows = 0,
						ExecuteMethodPops = 1,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = stloc_read,
				},

				new OpCodeHandler {
					Name = "switch",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[] {
							"System.UInt32",
							"System.Int32[]",
						},
						ExecuteMethodLocals = new string[] {
							"System.Int32",
							"System.Boolean",
						},
						ExecuteMethodThrows = 0,
						ExecuteMethodPops = 1,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = null,
					Read = switch_read,
				},

				new OpCodeHandler {
					Name = "throw",
					OpCodeHandlerSigInfo = new OpCodeHandlerSigInfo {
						RequiredFieldTypes = new object[0],
						ExecuteMethodLocals = new string[] {
							"System.Object",
							"System.Boolean",
						},
						ExecuteMethodThrows = 2,
						ExecuteMethodPops = 1,
						NumStaticMethods = 0,
						NumInstanceMethods = 0,
						NumVirtualMethods = 2,
						NumCtors = 1,
					},
					Check = throw_check,
					Read = throw_read,
				},
			},
		};
	}
}



================================================
File: de4dot.code/deobfuscators/Agile_NET/vm/v1/UnknownHandlerInfo.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Agile_NET.vm.v1 {
	class UnknownHandlerInfo {
		TypeDef type;
		CsvmInfo csvmInfo;
		FieldsInfo fieldsInfo;
		MethodDef readMethod, executeMethod;
		int numStaticMethods, numInstanceMethods, numVirtualMethods, numCtors;
		int executeMethodThrows, executeMethodPops;

		public MethodDef ReadMethod => readMethod;
		public MethodDef ExecuteMethod => executeMethod;
		public int NumStaticMethods => numStaticMethods;
		public int NumInstanceMethods => numInstanceMethods;
		public int NumVirtualMethods => numVirtualMethods;
		public int ExecuteMethodThrows => executeMethodThrows;
		public int ExecuteMethodPops => executeMethodPops;
		public int NumCtors => numCtors;

		public UnknownHandlerInfo(TypeDef type, CsvmInfo csvmInfo) {
			this.type = type;
			this.csvmInfo = csvmInfo;
			fieldsInfo = new FieldsInfo(GetFields(type));
			CountMethods();
			FindOverrideMethods();
			executeMethodThrows = CountThrows(executeMethod);
			executeMethodPops = CountPops(executeMethod);
		}

		static internal IEnumerable<FieldDef> GetFields(TypeDef type) {
			var typeFields = new FieldDefAndDeclaringTypeDict<FieldDef>();
			foreach (var field in type.Fields)
				typeFields.Add(field, field);
			var realFields = new Dictionary<FieldDef, bool>();
			foreach (var method in type.Methods) {
				if (method.Body == null)
					continue;
				foreach (var instr in method.Body.Instructions) {
					var fieldRef = instr.Operand as IField;
					if (fieldRef == null)
						continue;
					var field = typeFields.Find(fieldRef);
					if (field == null)
						continue;
					realFields[field] = true;
				}
			}
			return realFields.Keys;
		}

		void CountMethods() {
			foreach (var method in type.Methods) {
				if (method.Name == ".cctor") {
				}
				else if (method.Name == ".ctor")
					numCtors++;
				else if (method.IsStatic)
					numStaticMethods++;
				else if (method.IsVirtual)
					numVirtualMethods++;
				else
					numInstanceMethods++;
			}
		}

		void FindOverrideMethods() {
			foreach (var method in type.Methods) {
				if (!method.IsVirtual)
					continue;
				if (DotNetUtils.IsMethod(method, "System.Void", "(System.IO.BinaryReader)")) {
					if (readMethod != null)
						throw new ApplicationException("Found another read method");
					readMethod = method;
				}
				else if (!DotNetUtils.HasReturnValue(method) && method.MethodSig.GetParamCount() == 1) {
					if (executeMethod != null)
						throw new ApplicationException("Found another execute method");
					executeMethod = method;
				}
			}

			if (readMethod == null)
				throw new ApplicationException("Could not find read method");
			if (executeMethod == null)
				throw new ApplicationException("Could not find execute method");
		}

		static int CountThrows(MethodDef method) {
			int count = 0;
			foreach (var instr in method.Body.Instructions) {
				if (instr.OpCode.Code == Code.Throw)
					count++;
			}
			return count;
		}

		int CountPops(MethodDef method) {
			int count = 0;
			foreach (var instr in method.Body.Instructions) {
				if (instr.OpCode.Code != Code.Call && instr.OpCode.Code != Code.Callvirt)
					continue;
				var calledMethod = instr.Operand as IMethod;
				if (!MethodEqualityComparer.CompareDeclaringTypes.Equals(calledMethod, csvmInfo.PopMethod))
					continue;

				count++;
			}
			return count;
		}

		public bool HasSameFieldTypes(object[] fieldTypes) => new FieldsInfo(fieldTypes).IsSame(fieldsInfo);
	}
}



================================================
File: de4dot.code/deobfuscators/Agile_NET/vm/v1/VmOpCodeHandlerDetector.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks.cflow;

namespace de4dot.code.deobfuscators.Agile_NET.vm.v1 {
	class OpCodeHandlerSigInfo {
		public object[] RequiredFieldTypes { get; set; }
		public string[] ExecuteMethodLocals { get; set; }
		public int? ExecuteMethodThrows { get; set; }
		public int? ExecuteMethodPops { get; set; }
		public int? NumStaticMethods { get; set; }
		public int? NumInstanceMethods { get; set; }
		public int? NumVirtualMethods { get; set; }
		public int? NumCtors { get; set; }
	}

	class CsvmInfo {
		public TypeDef StackValue { get; set; }
		public TypeDef Stack { get; set; }
		public MethodDef PopMethod { get; set; }
		public MethodDef PeekMethod { get; set; }
	}

	class VmOpCodeHandlerDetector {
		ModuleDefMD module;
		List<OpCodeHandler> opCodeHandlers;

		public List<OpCodeHandler> Handlers => opCodeHandlers;
		public VmOpCodeHandlerDetector(ModuleDefMD module) => this.module = module;

		public void FindHandlers() {
			if (opCodeHandlers != null)
				return;
			var vmHandlerTypes = FindVmHandlerTypes();
			if (vmHandlerTypes == null)
				throw new ApplicationException("Could not find CSVM opcode handler types");

			DetectHandlers(vmHandlerTypes, CreateCsvmInfo());
		}

		internal CsvmInfo CreateCsvmInfo() {
			var csvmInfo = new CsvmInfo();
			csvmInfo.StackValue = FindStackValueType();
			csvmInfo.Stack = FindStackType(csvmInfo.StackValue);
			InitStackTypeMethods(csvmInfo);
			return csvmInfo;
		}

		TypeDef FindStackValueType() {
			foreach (var type in module.Types) {
				if (IsStackType(type))
					return type;
			}
			return null;
		}

		static bool IsStackType(TypeDef type) {
			if (type.Fields.Count != 2)
				return false;

			int enumTypes = 0;
			int objectTypes = 0;
			foreach (var field in type.Fields) {
				var fieldType = field.FieldSig.GetFieldType().TryGetTypeDef();
				if (fieldType != null && fieldType.IsEnum)
					enumTypes++;
				if (field.FieldSig.GetFieldType().GetElementType() == ElementType.Object)
					objectTypes++;
			}
			if (enumTypes != 1 || objectTypes != 1)
				return false;

			return true;
		}

		TypeDef FindStackType(TypeDef stackValueType) {
			foreach (var type in module.Types) {
				if (IsStackType(type, stackValueType))
					return type;
			}
			return null;
		}

		bool IsStackType(TypeDef type, TypeDef stackValueType) {
			if (type.Interfaces.Count != 2)
				return false;
			if (!ImplementsInterface(type, "System.Collections.ICollection"))
				return false;
			if (!ImplementsInterface(type, "System.Collections.IEnumerable"))
				return false;
			if (type.NestedTypes.Count == 0)
				return false;

			int stackValueTypes = 0;
			int int32Types = 0;
			int objectTypes = 0;
			foreach (var field in type.Fields) {
				if (field.IsLiteral)
					continue;
				var fieldType = field.FieldSig.GetFieldType();
				if (fieldType == null)
					continue;
				if (fieldType.IsSZArray && fieldType.Next.TryGetTypeDef() == stackValueType)
					stackValueTypes++;
				if (fieldType.ElementType == ElementType.I4)
					int32Types++;
				if (fieldType.ElementType == ElementType.Object)
					objectTypes++;
			}
			if (stackValueTypes != 2 || int32Types != 2 || objectTypes != 1)
				return false;

			return true;
		}

		static bool ImplementsInterface(TypeDef type, string ifaceName) {
			foreach (var iface in type.Interfaces) {
				if (iface.Interface.FullName == ifaceName)
					return true;
			}
			return false;
		}

		void InitStackTypeMethods(CsvmInfo csvmInfo) {
			foreach (var method in csvmInfo.Stack.Methods) {
				var sig = method.MethodSig;
				if (sig != null && sig.Params.Count == 0 && sig.RetType.TryGetTypeDef() == csvmInfo.StackValue) {
					if (HasAdd(method))
						csvmInfo.PopMethod = method;
					else
						csvmInfo.PeekMethod = method;
				}
			}
		}

		static bool HasAdd(MethodDef method) {
			foreach (var instr in method.Body.Instructions) {
				if (instr.OpCode.Code == Code.Add)
					return true;
			}
			return false;
		}

		List<TypeDef> FindVmHandlerTypes() {
			var requiredFields = new string[] {
				null,
				"System.Collections.Generic.Dictionary`2<System.UInt16,System.Type>",
				"System.UInt16",
			};
			var cflowDeobfuscator = new CflowDeobfuscator();
			foreach (var type in module.Types) {
				var cctor = type.FindStaticConstructor();
				if (cctor == null)
					continue;
				requiredFields[0] = type.FullName;
				if (!new FieldTypes(type).Exactly(requiredFields))
					continue;

				cflowDeobfuscator.Deobfuscate(cctor);
				var handlers = FindVmHandlerTypes(cctor);
				if (handlers.Count != 31)
					continue;

				return handlers;
			}

			return null;
		}

		static List<TypeDef> FindVmHandlerTypes(MethodDef method) {
			var list = new List<TypeDef>();

			foreach (var instr in method.Body.Instructions) {
				if (instr.OpCode.Code != Code.Ldtoken)
					continue;
				var type = instr.Operand as TypeDef;
				if (type == null)
					continue;

				list.Add(type);
			}

			return list;
		}

		void DetectHandlers(List<TypeDef> handlerTypes, CsvmInfo csvmInfo) {
			opCodeHandlers = new List<OpCodeHandler>();
			var detected = new List<OpCodeHandler>();

			foreach (var handlersList in OpCodeHandlers.Handlers) {
				opCodeHandlers.Clear();

				foreach (var handlerType in handlerTypes) {
					var info = new UnknownHandlerInfo(handlerType, csvmInfo);
					detected.Clear();
					foreach (var opCodeHandler in handlersList) {
						if (opCodeHandler.Detect(info))
							detected.Add(opCodeHandler);
					}
					if (detected.Count != 1)
						goto next;
					opCodeHandlers.Add(detected[0]);
				}
				if (new List<OpCodeHandler>(Utils.Unique(opCodeHandlers)).Count == opCodeHandlers.Count)
					return;
next: ;
			}
			throw new ApplicationException("Could not detect all VM opcode handlers");
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Agile_NET/vm/v2/CSVM1.bin
================================================
[Non-text file]


================================================
File: de4dot.code/deobfuscators/Agile_NET/vm/v2/CSVM2.bin
================================================
[Non-text file]


================================================
File: de4dot.code/deobfuscators/Agile_NET/vm/v2/CSVM3.bin
================================================
[Non-text file]


================================================
File: de4dot.code/deobfuscators/Agile_NET/vm/v2/CSVM4.bin
================================================
[Non-text file]


================================================
File: de4dot.code/deobfuscators/Agile_NET/vm/v2/CSVM5.bin
================================================
[Non-text file]


================================================
File: de4dot.code/deobfuscators/Agile_NET/vm/v2/CSVM6.bin
================================================
[Non-text file]


================================================
File: de4dot.code/deobfuscators/Agile_NET/vm/v2/CompositeHandlerDetector.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;

namespace de4dot.code.deobfuscators.Agile_NET.vm.v2 {
	class CompositeHandlerDetector {
		readonly List<MethodSigInfo> handlers;

		public CompositeHandlerDetector(IList<MethodSigInfo> handlers) {
			this.handlers = new List<MethodSigInfo>(handlers);

			this.handlers.Sort((a, b) => {
				int r = b.BlockSigInfos.Count.CompareTo(a.BlockSigInfos.Count);
				if (r != 0)
					return r;
				return b.BlockSigInfos[0].Hashes.Count.CompareTo(a.BlockSigInfos[0].Hashes.Count);
			});
		}

		struct MatchState {
			public HandlerState OtherState;
			public HandlerState CompositeState;

			public MatchState(HandlerState OtherState, HandlerState CompositeState) {
				this.OtherState = OtherState;
				this.CompositeState = CompositeState;
			}
		}

		struct HandlerState {
			public readonly List<BlockSigInfo> BlockSigInfos;
			public readonly int BlockIndex;
			public int HashIndex;

			public HandlerState(List<BlockSigInfo> blockSigInfos, int blockIndex, int hashIndex) {
				BlockSigInfos = blockSigInfos;
				BlockIndex = blockIndex;
				HashIndex = hashIndex;
			}

			public HandlerState Clone() => new HandlerState(BlockSigInfos, BlockIndex, HashIndex);
		}

		struct FindHandlerState {
			public HandlerState CompositeState;
			public readonly Dictionary<int, bool> VisitedCompositeBlocks;
			public bool Done;

			public FindHandlerState(HandlerState compositeState) {
				CompositeState = compositeState;
				VisitedCompositeBlocks = new Dictionary<int, bool>();
				Done = false;
			}

			public FindHandlerState(HandlerState compositeState, Dictionary<int, bool> visitedCompositeBlocks, bool done) {
				CompositeState = compositeState;
				VisitedCompositeBlocks = new Dictionary<int, bool>(visitedCompositeBlocks);
				Done = done;
			}

			public FindHandlerState Clone() => new FindHandlerState(CompositeState.Clone(), VisitedCompositeBlocks, Done);
		}

		public bool FindHandlers(CompositeOpCodeHandler composite) {
			composite.TypeCodes.Clear();
			var compositeExecState = new FindHandlerState(new HandlerState(composite.BlockSigInfos, 0, 0));
			while (!compositeExecState.Done) {
				var handler = FindHandlerMethod(ref compositeExecState);
				if (handler == null)
					return false;

				composite.TypeCodes.Add(handler.TypeCode);
			}
			return composite.TypeCodes.Count != 0;
		}

		MethodSigInfo FindHandlerMethod(ref FindHandlerState findExecState) {
			foreach (var handler in handlers) {
				var findExecStateNew = findExecState.Clone();
				if (!Matches(handler.BlockSigInfos, ref findExecStateNew))
					continue;

				findExecState = findExecStateNew;
				return handler;
			}
			return null;
		}

		Stack<MatchState> stack = new Stack<MatchState>();
		bool Matches(List<BlockSigInfo> handler, ref FindHandlerState findState) {
			HandlerState? nextState = null;
			stack.Clear();
			stack.Push(new MatchState(new HandlerState(handler, 0, 0), findState.CompositeState));
			while (stack.Count > 0) {
				var matchState = stack.Pop();

				if (matchState.CompositeState.HashIndex == 0) {
					if (findState.VisitedCompositeBlocks.ContainsKey(matchState.CompositeState.BlockIndex))
						continue;
					findState.VisitedCompositeBlocks[matchState.CompositeState.BlockIndex] = true;
				}
				else {
					if (!findState.VisitedCompositeBlocks.ContainsKey(matchState.CompositeState.BlockIndex))
						throw new ApplicationException("Block hasn't been visited");
				}

				if (!Compare(ref matchState.OtherState, ref matchState.CompositeState))
					return false;

				var hblock = matchState.OtherState.BlockSigInfos[matchState.OtherState.BlockIndex];
				var hinstrs = hblock.Hashes;
				int hi = matchState.OtherState.HashIndex;
				var cblock = matchState.CompositeState.BlockSigInfos[matchState.CompositeState.BlockIndex];
				var cinstrs = cblock.Hashes;
				int ci = matchState.CompositeState.HashIndex;
				if (hi < hinstrs.Count)
					return false;

				if (ci < cinstrs.Count) {
					if (hblock.Targets.Count != 0)
						return false;
					if (hblock.EndsInRet) {
						if (nextState != null)
							return false;
						nextState = matchState.CompositeState;
					}
				}
				else {
					if (cblock.Targets.Count != hblock.Targets.Count)
						return false;
					if (cblock.HasFallThrough != hblock.HasFallThrough)
						return false;

					for (int i = 0; i < cblock.Targets.Count; i++) {
						var hs = new HandlerState(handler, hblock.Targets[i], 0);
						var cs = new HandlerState(findState.CompositeState.BlockSigInfos, cblock.Targets[i], 0);
						stack.Push(new MatchState(hs, cs));
					}
				}
			}

			if (nextState == null && findState.VisitedCompositeBlocks.Count != findState.CompositeState.BlockSigInfos.Count)
				nextState = GetNextHandlerState(ref findState);
			if (nextState == null) {
				if (findState.VisitedCompositeBlocks.Count != findState.CompositeState.BlockSigInfos.Count)
					return false;
				findState.Done = true;
				return true;
			}
			else {
				if (findState.CompositeState.BlockIndex == nextState.Value.BlockIndex &&
					findState.CompositeState.HashIndex == nextState.Value.HashIndex)
					return false;
				findState.CompositeState = nextState.Value;
				if (findState.CompositeState.HashIndex == 0)
					findState.VisitedCompositeBlocks.Remove(findState.CompositeState.BlockIndex);
				return true;
			}
		}

		static HandlerState? GetNextHandlerState(ref FindHandlerState findState) {
			for (int i = 0; i < findState.CompositeState.BlockSigInfos.Count; i++) {
				if (findState.VisitedCompositeBlocks.ContainsKey(i))
					continue;
				return new HandlerState(findState.CompositeState.BlockSigInfos, i, 0);
			}

			return null;
		}

		static bool Compare(ref HandlerState handler, ref HandlerState composite) {
			var hhashes = handler.BlockSigInfos[handler.BlockIndex].Hashes;
			int hi = handler.HashIndex;
			var chashes = composite.BlockSigInfos[composite.BlockIndex].Hashes;
			int ci = composite.HashIndex;

			while (true) {
				if (hi >= hhashes.Count && ci >= chashes.Count)
					break;

				if (hi >= hhashes.Count) {
					if (handler.BlockSigInfos[handler.BlockIndex].EndsInRet)
						break;
				}

				if (hi >= hhashes.Count || ci >= chashes.Count)
					return false;

				var hhash = hhashes[hi++];
				var chash = chashes[ci++];

				if (chash != hhash)
					return false;
			}

			handler.HashIndex = hi;
			composite.HashIndex = ci;
			return true;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Agile_NET/vm/v2/CompositeOpCodeHandler.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;

namespace de4dot.code.deobfuscators.Agile_NET.vm.v2 {
	class CompositeOpCodeHandler {
		public List<BlockSigInfo> BlockSigInfos { get; private set; }
		public List<HandlerTypeCode> TypeCodes { get; private set; }

		public CompositeOpCodeHandler(List<BlockSigInfo> blockSigInfos) {
			BlockSigInfos = blockSigInfos;
			TypeCodes = new List<HandlerTypeCode>();
		}

		public override string ToString() => OpCodeHandlerInfo.GetCompositeName(TypeCodes);
	}
}



================================================
File: de4dot.code/deobfuscators/Agile_NET/vm/v2/Csvm.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.IO;
using dnlib.DotNet;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Agile_NET.vm.v2 {
	class Csvm {
		IDeobfuscatorContext deobfuscatorContext;
		ModuleDefMD module;
		EmbeddedResource resource;
		AssemblyRef vmAssemblyRef;

		public bool Detected => resource != null && vmAssemblyRef != null;
		public EmbeddedResource Resource => Detected ? resource : null;

		public Csvm(IDeobfuscatorContext deobfuscatorContext, ModuleDefMD module) {
			this.deobfuscatorContext = deobfuscatorContext;
			this.module = module;
		}

		public Csvm(IDeobfuscatorContext deobfuscatorContext, ModuleDefMD module, Csvm oldOne) {
			this.deobfuscatorContext = deobfuscatorContext;
			this.module = module;
			if (oldOne.resource != null)
				resource = (EmbeddedResource)module.Resources[oldOne.module.Resources.IndexOf(oldOne.resource)];
			if (oldOne.vmAssemblyRef != null)
				vmAssemblyRef = module.ResolveAssemblyRef(oldOne.vmAssemblyRef.Rid);
		}

		public void Find() {
			resource = FindCsvmResource();
			vmAssemblyRef = FindVmAssemblyRef();
		}

		AssemblyRef FindVmAssemblyRef() {
			foreach (var memberRef in module.GetMemberRefs()) {
				var sig = memberRef.MethodSig;
				if (sig == null)
					continue;
				if (sig.RetType.GetElementType() != ElementType.Object)
					continue;
				if (sig.Params.Count != 2)
					continue;
				if (memberRef.Name != "RunMethod")
					continue;
				if (memberRef.FullName == "System.Object VMRuntime.Libraries.CSVMRuntime::RunMethod(System.String,System.Object[])")
					return memberRef.DeclaringType.Scope as AssemblyRef;
			}
			return null;
		}

		EmbeddedResource FindCsvmResource() => DotNetUtils.GetResource(module, "_CSVM") as EmbeddedResource;

		public bool Restore() {
			if (!Detected)
				return true;

			int oldIndent = Logger.Instance.IndentLevel;
			try {
				Restore2();
				return true;
			}
			catch {
				return false;
			}
			finally {
				Logger.Instance.IndentLevel = oldIndent;
			}
		}

		void Restore2() {
			Logger.n("Restoring CSVM methods");
			Logger.Instance.Indent();

			var opcodeDetector = GetVmOpCodeHandlerDetector();
			var csvmMethods = new CsvmDataReader(resource.CreateReader()).Read();
			var converter = new CsvmToCilMethodConverter(deobfuscatorContext, module, opcodeDetector);
			var methodPrinter = new MethodPrinter();
			foreach (var csvmMethod in csvmMethods) {
				var cilMethod = module.ResolveToken(csvmMethod.Token) as MethodDef;
				if (cilMethod == null)
					throw new ApplicationException($"Could not find method {csvmMethod.Token:X8}");
				converter.Convert(cilMethod, csvmMethod);
				Logger.v("Restored method {0:X8}", cilMethod.MDToken.ToInt32());
				PrintMethod(methodPrinter, cilMethod);
			}
			Logger.Instance.DeIndent();
			Logger.n("Restored {0} CSVM methods", csvmMethods.Count);
		}

		static void PrintMethod(MethodPrinter methodPrinter, MethodDef method) {
			const LoggerEvent dumpLogLevel = LoggerEvent.Verbose;
			if (Logger.Instance.IgnoresEvent(dumpLogLevel))
				return;

			Logger.Instance.Indent();

			Logger.v("Locals:");
			Logger.Instance.Indent();
			for (int i = 0; i < method.Body.Variables.Count; i++)
				Logger.v("#{0}: {1}", i, method.Body.Variables[i].Type);
			Logger.Instance.DeIndent();

			Logger.v("Code:");
			Logger.Instance.Indent();
			methodPrinter.Print(dumpLogLevel, method.Body.Instructions, method.Body.ExceptionHandlers);
			Logger.Instance.DeIndent();

			Logger.Instance.DeIndent();
		}

		VmOpCodeHandlerDetector GetVmOpCodeHandlerDetector() {
			var vmFilename = vmAssemblyRef.Name + ".dll";
			var vmModulePath = Path.Combine(Path.GetDirectoryName(module.Location), vmFilename);
			Logger.v("CSVM filename: {0}", vmFilename);

			var dataKey = "cs cached VmOpCodeHandlerDetector v2";
			var dict = (Dictionary<string, VmOpCodeHandlerDetector>)deobfuscatorContext.GetData(dataKey);
			if (dict == null)
				deobfuscatorContext.SetData(dataKey, dict = new Dictionary<string, VmOpCodeHandlerDetector>(StringComparer.OrdinalIgnoreCase));
			if (dict.TryGetValue(vmModulePath, out var detector))
				return detector;
			dict[vmModulePath] = detector = new VmOpCodeHandlerDetector(ModuleDefMD.Load(vmModulePath));

			detector.FindHandlers();
			Logger.v("CSVM opcodes: {0}", detector.Handlers.Count);
			Logger.Instance.Indent();
			for (int i = 0; i < detector.Handlers.Count; i++)
				Logger.v("{0:X4}: {1}", i, detector.Handlers[i]);
			Logger.Instance.DeIndent();

			return detector;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Agile_NET/vm/v2/CsvmInfo.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Agile_NET.vm.v2 {
	class CsvmInfo {
		ModuleDef module;

		public TypeDef VmHandlerBaseType;

		public MethodDef LogicalOpShrUn;
		public MethodDef LogicalOpShl;
		public MethodDef LogicalOpShr;
		public MethodDef LogicalOpAnd;
		public MethodDef LogicalOpXor;
		public MethodDef LogicalOpOr;

		public MethodDef CompareLt;
		public MethodDef CompareLte;
		public MethodDef CompareGt;
		public MethodDef CompareGte;
		public MethodDef CompareEq;
		public MethodDef CompareEqz;

		public MethodDef ArithmeticSubOvfUn;
		public MethodDef ArithmeticMulOvfUn;
		public MethodDef ArithmeticRemUn;
		public MethodDef ArithmeticRem;
		public MethodDef ArithmeticDivUn;
		public MethodDef ArithmeticDiv;
		public MethodDef ArithmeticMul;
		public MethodDef ArithmeticMulOvf;
		public MethodDef ArithmeticSub;
		public MethodDef ArithmeticSubOvf;
		public MethodDef ArithmeticAddOvfUn;
		public MethodDef ArithmeticAddOvf;
		public MethodDef ArithmeticAdd;

		public MethodDef UnaryNot;
		public MethodDef UnaryNeg;

		public MethodDef ArgsGet;
		public MethodDef ArgsSet;
		public MethodDef LocalsGet;
		public MethodDef LocalsSet;

		public CsvmInfo(ModuleDef module) => this.module = module;

		public bool Initialize() =>
			FindVmHandlerBase() &&
			FindLocalOpsMethods() &&
			FindComparerMethods() &&
			FindArithmeticMethods() &&
			FindUnaryOpsMethods() &&
			FindArgsLocals();

		public bool FindVmHandlerBase() {
			foreach (var type in module.Types) {
				if (!type.IsPublic || !type.IsAbstract)
					continue;
				if (type.HasProperties || type.HasEvents)
					continue;
				if (type.BaseType == null || type.BaseType.FullName != "System.Object")
					continue;
				if (CountVirtual(type) != 2)
					continue;

				VmHandlerBaseType = type;
				return true;
			}

			return false;
		}

		public bool FindLocalOpsMethods() {
			foreach (var type in module.Types) {
				if (type.BaseType == null || type.BaseType.FullName != "System.Object")
					continue;
				if (type.Methods.Count != 6 && type.Methods.Count != 7)
					continue;
				LogicalOpShrUn = FindLogicalOpMethodShrUn(type);
				if (LogicalOpShrUn == null)
					continue;
				LogicalOpShl = FindLogicalOpMethodShl(type);
				LogicalOpShr = FindLogicalOpMethodShr(type);
				LogicalOpAnd = FindLogicalOpMethodAnd(type);
				LogicalOpXor = FindLogicalOpMethodXor(type);
				LogicalOpOr = FindLogicalOpMethodOr(type);
				if (LogicalOpShrUn != null && LogicalOpShl != null &&
					LogicalOpShr != null && LogicalOpAnd != null &&
					LogicalOpXor != null && LogicalOpOr != null)
					return true;
			}

			return false;
		}

		MethodDef FindLogicalOpMethodShrUn(TypeDef type) => FindLogicalOpMethod(type, ElementType.U4, ElementType.I4, ElementType.U4, Code.Shr_Un);
		MethodDef FindLogicalOpMethodShl(TypeDef type) => FindLogicalOpMethod(type, ElementType.I4, ElementType.I4, ElementType.I4, Code.Shl);
		MethodDef FindLogicalOpMethodShr(TypeDef type) => FindLogicalOpMethod(type, ElementType.I4, ElementType.I4, ElementType.I4, Code.Shr);

		MethodDef FindLogicalOpMethod(TypeDef type, ElementType e1, ElementType e2, ElementType e3, Code code) {
			foreach (var method in type.Methods) {
				if (!CheckLogicalMethodSig(method))
					continue;
				if (method.Body == null)
					continue;
				var instrs = method.Body.Instructions;
				for (int i = 0; i < instrs.Count - 7; i++) {
					var ldarg0 = instrs[i];
					if (!ldarg0.IsLdarg() || ldarg0.GetParameterIndex() != 0)
						continue;
					if (!CheckUnboxAny(instrs[i + 1], e1))
						continue;
					var ldarg1 = instrs[i + 2];
					if (!ldarg1.IsLdarg() || ldarg1.GetParameterIndex() != 1)
						continue;
					if (!CheckUnboxAny(instrs[i + 3], e2))
						continue;
					var ldci4 = instrs[i + 4];
					if (!ldci4.IsLdcI4() || ldci4.GetLdcI4Value() != 0x1F)
						continue;
					if (instrs[i + 5].OpCode.Code != Code.And)
						continue;
					if (instrs[i + 6].OpCode.Code != code)
						continue;
					if (!CheckBox(instrs[i + 7], e3))
						continue;

					return method;
				}
			}

			return null;
		}

		MethodDef FindLogicalOpMethodAnd(TypeDef type) => FindLogicalOpMethod(type, Code.And);
		MethodDef FindLogicalOpMethodXor(TypeDef type) => FindLogicalOpMethod(type, Code.Xor);
		MethodDef FindLogicalOpMethodOr(TypeDef type) => FindLogicalOpMethod(type, Code.Or);

		MethodDef FindLogicalOpMethod(TypeDef type, Code code) {
			foreach (var method in type.Methods) {
				if (!CheckLogicalMethodSig(method))
					continue;
				if (method.Body == null)
					continue;
				var instrs = method.Body.Instructions;
				for (int i = 0; i < instrs.Count - 5; i++) {
					var ldarg0 = instrs[i];
					if (!ldarg0.IsLdarg() || ldarg0.GetParameterIndex() != 0)
						continue;
					if (!CheckUnboxAny(instrs[i + 1], ElementType.I4))
						continue;
					var ldarg1 = instrs[i + 2];
					if (!ldarg1.IsLdarg() || ldarg1.GetParameterIndex() != 1)
						continue;
					if (!CheckUnboxAny(instrs[i + 3], ElementType.I4))
						continue;
					if (instrs[i + 4].OpCode.Code != code)
						continue;
					if (!CheckBox(instrs[i + 5], ElementType.I4))
						continue;

					return method;
				}
			}

			return null;
		}

		static bool CheckLogicalMethodSig(MethodDef method) =>
			method != null &&
			method.IsStatic &&
			method.MethodSig.GetParamCount() == 2 &&
			method.MethodSig.RetType.GetElementType() == ElementType.Object &&
			method.MethodSig.Params[0].GetElementType() == ElementType.Object &&
			method.MethodSig.Params[1].GetElementType() == ElementType.Object;

		public bool FindComparerMethods() {
			foreach (var type in module.Types) {
				if (type.BaseType == null || type.BaseType.FullName != "System.Object")
					continue;
				if (type.Methods.Count != 9)
					continue;
				CompareLt = FindCompareLt(type);
				if (CompareLt == null)
					continue;
				CompareLte = FindCompareLte(type);
				CompareGt = FindCompareGt(type);
				CompareGte = FindCompareGte(type);
				CompareEq = FindCompareEq(type);
				CompareEqz = FindCompareEqz(type);
				if (CompareLt != null && CompareLte != null &&
					CompareGt != null && CompareGte != null &&
					CompareEq != null && CompareEqz != null)
					return true;
			}

			return false;
		}

		MethodDef FindCompareLt(TypeDef type) => FindCompareMethod(type, Code.Clt, false);
		MethodDef FindCompareLte(TypeDef type) => FindCompareMethod(type, Code.Cgt, true);
		MethodDef FindCompareGt(TypeDef type) => FindCompareMethod(type, Code.Cgt, false);
		MethodDef FindCompareGte(TypeDef type) => FindCompareMethod(type, Code.Clt, true);

		MethodDef FindCompareMethod(TypeDef type, Code code, bool invert) {
			foreach (var method in type.Methods) {
				if (!CheckCompareMethodSig(method))
					continue;
				if (method.Body == null)
					continue;
				var instrs = method.Body.Instructions;
				int end = instrs.Count - 6;
				if (invert)
					end -= 2;
				for (int i = 0; i < end; i++) {
					int index = i;
					var ldarg0 = instrs[index++];
					if (!ldarg0.IsLdarg() || ldarg0.GetParameterIndex() != 0)
						continue;
					if (!CheckUnboxAny(instrs[index++], ElementType.I4))
						continue;
					var ldarg1 = instrs[index++];
					if (!ldarg1.IsLdarg() || ldarg1.GetParameterIndex() != 1)
						continue;
					if (!CheckUnboxAny(instrs[index++], ElementType.I4))
						continue;
					if (instrs[index++].OpCode.Code != code)
						continue;
					if (invert) {
						var ldci4 = instrs[index++];
						if (!ldci4.IsLdcI4() || ldci4.GetLdcI4Value() != 0)
							continue;
						if (instrs[index++].OpCode.Code != Code.Ceq)
							continue;
					}
					if (!instrs[index++].IsStloc())
						continue;

					return method;
				}
			}

			return null;
		}

		static bool CheckCompareMethodSig(MethodDef method) {
			if (method == null || !method.IsStatic)
				return false;
			var sig = method.MethodSig;
			if (sig == null || sig.GetParamCount() != 3)
				return false;
			if (sig.RetType.GetElementType() != ElementType.Boolean)
				return false;
			if (sig.Params[0].GetElementType() != ElementType.Object)
				return false;
			if (sig.Params[1].GetElementType() != ElementType.Object)
				return false;
			var arg2 = sig.Params[2] as ValueTypeSig;
			if (arg2 == null || arg2.TypeDef == null || !arg2.TypeDef.IsEnum)
				return false;

			return true;
		}

		MethodDef FindCompareEq(TypeDef type) {
			foreach (var method in type.Methods) {
				if (!CheckCompareEqMethodSig(method))
					continue;
				if (method.Body == null)
					continue;
				var instrs = method.Body.Instructions;
				for (int i = 0; i < instrs.Count - 5; i++) {
					var ldarg0 = instrs[i];
					if (!ldarg0.IsLdarg() || ldarg0.GetParameterIndex() != 0)
						continue;
					if (!CheckUnboxAny(instrs[i + 1], ElementType.I4))
						continue;
					var ldarg1 = instrs[i + 2];
					if (!ldarg1.IsLdarg() || ldarg1.GetParameterIndex() != 1)
						continue;
					if (!CheckUnboxAny(instrs[i + 3], ElementType.I4))
						continue;
					if (instrs[i + 4].OpCode.Code != Code.Ceq)
						continue;
					if (!instrs[i + 5].IsStloc())
						continue;

					return method;
				}
			}

			return null;
		}

		static bool CheckCompareEqMethodSig(MethodDef method) =>
			method != null &&
			method.IsStatic &&
			method.MethodSig.GetParamCount() == 2 &&
			method.MethodSig.RetType.GetElementType() == ElementType.Boolean &&
			method.MethodSig.Params[0].GetElementType() == ElementType.Object &&
			method.MethodSig.Params[1].GetElementType() == ElementType.Object;

		MethodDef FindCompareEqz(TypeDef type) {
			foreach (var method in type.Methods) {
				if (!CheckCompareEqzMethodSig(method))
					continue;
				if (method.Body == null)
					continue;
				var instrs = method.Body.Instructions;
				for (int i = 0; i < instrs.Count - 4; i++) {
					var ldarg0 = instrs[i];
					if (!ldarg0.IsLdarg() || ldarg0.GetParameterIndex() != 0)
						continue;
					if (!CheckUnboxAny(instrs[i + 1], ElementType.I4))
						continue;
					var ldci4 = instrs[i + 2];
					if (!ldci4.IsLdcI4() || ldci4.GetLdcI4Value() != 0)
						continue;
					if (instrs[i + 3].OpCode.Code != Code.Ceq)
						continue;
					if (!instrs[i + 4].IsStloc())
						continue;

					return method;
				}
			}

			return null;
		}

		static bool CheckCompareEqzMethodSig(MethodDef method) =>
			method != null &&
			method.IsStatic &&
			method.MethodSig.GetParamCount() == 1 &&
			method.MethodSig.RetType.GetElementType() == ElementType.Boolean &&
			method.MethodSig.Params[0].GetElementType() == ElementType.Object;

		public bool FindArithmeticMethods() {
			foreach (var type in module.Types) {
				if (type.BaseType == null || type.BaseType.FullName != "System.Object")
					continue;
				if (type.Methods.Count != 15)
					continue;
				ArithmeticSubOvfUn = FindArithmeticSubOvfUn(type);
				if (ArithmeticSubOvfUn == null)
					continue;
				ArithmeticMulOvfUn = FindArithmeticMulOvfUn(type);
				ArithmeticRemUn = FindArithmeticRemUn(type);
				ArithmeticRem = FindArithmeticRem(type);
				ArithmeticDivUn = FindArithmeticDivUn(type);
				ArithmeticDiv = FindArithmeticDiv(type);
				ArithmeticMul = FindArithmeticMul(type);
				ArithmeticMulOvf = FindArithmeticMulOvf(type);
				ArithmeticSub = FindArithmeticSub(type);
				ArithmeticSubOvf = FindArithmeticSubOvf(type);
				ArithmeticAddOvfUn = FindArithmeticAddOvfUn(type);
				ArithmeticAddOvf = FindArithmeticAddOvf(type);
				ArithmeticAdd = FindArithmeticAdd(type);

				if (ArithmeticSubOvfUn != null && ArithmeticMulOvfUn != null &&
					ArithmeticRemUn != null && ArithmeticRem != null &&
					ArithmeticDivUn != null && ArithmeticDiv != null &&
					ArithmeticMul != null && ArithmeticMulOvf != null &&
					ArithmeticSub != null && ArithmeticSubOvf != null &&
					ArithmeticAddOvfUn != null && ArithmeticAddOvf != null &&
					ArithmeticAdd != null)
					return true;
			}

			return false;
		}

		MethodDef FindArithmeticSubOvfUn(TypeDef type) => FindArithmeticOpUn(type, Code.Sub_Ovf_Un);
		MethodDef FindArithmeticMulOvfUn(TypeDef type) => FindArithmeticOpUn(type, Code.Mul_Ovf_Un);
		MethodDef FindArithmeticAddOvfUn(TypeDef type) => FindArithmeticOpUn(type, Code.Add_Ovf_Un);

		MethodDef FindArithmeticOpUn(TypeDef type, Code code) {
			foreach (var method in type.Methods) {
				if (!CheckArithmeticUnMethodSig(method))
					continue;
				if (method.Body == null)
					continue;
				var instrs = method.Body.Instructions;
				for (int i = 0; i < instrs.Count - 8; i++) {
					var ldarg0 = instrs[i];
					if (!ldarg0.IsLdarg() || ldarg0.GetParameterIndex() != 0)
						continue;
					if (!CheckCallvirt(instrs[i + 1], "System.Int32", "()"))
						continue;
					if (instrs[i + 2].OpCode.Code != Code.Conv_Ovf_U4)
						continue;
					var ldarg1 = instrs[i + 3];
					if (!ldarg1.IsLdarg() || ldarg1.GetParameterIndex() != 1)
						continue;
					if (!CheckCallvirt(instrs[i + 4], "System.Int32", "()"))
						continue;
					if (instrs[i + 5].OpCode.Code != Code.Conv_Ovf_U4)
						continue;
					if (instrs[i + 6].OpCode.Code != code)
						continue;
					if (!CheckBox(instrs[i + 7], ElementType.U4))
						continue;
					if (!instrs[i + 8].IsStloc())
						continue;

					return method;
				}
			}

			return null;
		}

		static bool CheckArithmeticUnMethodSig(MethodDef method) =>
			method != null &&
			method.IsStatic &&
			method.MethodSig.GetParamCount() == 2 &&
			method.MethodSig.RetType.GetElementType() == ElementType.Object &&
			method.MethodSig.Params[0].GetElementType() == ElementType.Class &&
			method.MethodSig.Params[1].GetElementType() == ElementType.Class;

		MethodDef FindArithmeticRemUn(TypeDef type) => FindArithmeticDivOrRemUn(type, Code.Rem_Un);
		MethodDef FindArithmeticDivUn(TypeDef type) => FindArithmeticDivOrRemUn(type, Code.Div_Un);

		MethodDef FindArithmeticDivOrRemUn(TypeDef type, Code code) {
			foreach (var method in type.Methods) {
				if (!CheckArithmeticUnMethodSig(method))
					continue;
				if (method.Body == null)
					continue;
				var instrs = method.Body.Instructions;
				for (int i = 0; i < instrs.Count - 7; i++) {
					var ldarg0 = instrs[i];
					if (!ldarg0.IsLdarg() || ldarg0.GetParameterIndex() != 0)
						continue;
					if (!CheckCallvirt(instrs[i + 1], "System.Int32", "()"))
						continue;
					var ldarg1 = instrs[i + 2];
					if (!ldarg1.IsLdarg() || ldarg1.GetParameterIndex() != 1)
						continue;
					if (!CheckCallvirt(instrs[i + 3], "System.Int32", "()"))
						continue;
					if (instrs[i + 4].OpCode.Code != code)
						continue;
					if (!CheckBox(instrs[i + 5], ElementType.U4))
						continue;
					if (!instrs[i + 6].IsStloc())
						continue;

					return method;
				}
			}

			return null;
		}

		MethodDef FindArithmeticRem(TypeDef type) => FindArithmeticOther(type, Code.Rem);
		MethodDef FindArithmeticDiv(TypeDef type) => FindArithmeticOther(type, Code.Div);
		MethodDef FindArithmeticMul(TypeDef type) => FindArithmeticOther(type, Code.Mul);
		MethodDef FindArithmeticMulOvf(TypeDef type) => FindArithmeticOther(type, Code.Mul_Ovf);
		MethodDef FindArithmeticSub(TypeDef type) => FindArithmeticOther(type, Code.Sub);
		MethodDef FindArithmeticSubOvf(TypeDef type) => FindArithmeticOther(type, Code.Sub_Ovf);
		MethodDef FindArithmeticAdd(TypeDef type) => FindArithmeticOther(type, Code.Add);
		MethodDef FindArithmeticAddOvf(TypeDef type) => FindArithmeticOther(type, Code.Add_Ovf);

		MethodDef FindArithmeticOther(TypeDef type, Code code) {
			foreach (var method in type.Methods) {
				if (!CheckArithmeticOtherMethodSig(method))
					continue;
				if (method.Body == null)
					continue;
				var instrs = method.Body.Instructions;
				for (int i = 0; i < instrs.Count - 6; i++) {
					var ldarg0 = instrs[i];
					if (!ldarg0.IsLdarg() || ldarg0.GetParameterIndex() != 0)
						continue;
					if (!CheckUnboxAny(instrs[i + 1], ElementType.I4))
						continue;
					var ldarg1 = instrs[i + 2];
					if (!ldarg1.IsLdarg() || ldarg1.GetParameterIndex() != 1)
						continue;
					if (!CheckUnboxAny(instrs[i + 3], ElementType.I4))
						continue;
					if (instrs[i + 4].OpCode.Code != code)
						continue;
					if (!CheckBox(instrs[i + 5], ElementType.I4))
						continue;

					return method;
				}
			}

			return null;
		}

		static bool CheckArithmeticOtherMethodSig(MethodDef method) =>
			method != null &&
			method.IsStatic &&
			method.MethodSig.GetParamCount() == 2 &&
			method.MethodSig.RetType.GetElementType() == ElementType.Object &&
			method.MethodSig.Params[0].GetElementType() == ElementType.Object &&
			method.MethodSig.Params[1].GetElementType() == ElementType.Object;

		public bool FindUnaryOpsMethods() {
			UnaryNot = FindUnaryOpMethod1(Code.Not);
			UnaryNeg = FindUnaryOpMethod1(Code.Neg);
			if (UnaryNot != null && UnaryNeg != null)
				return true;

			return FindUnaryOpMethod2();
		}

		MethodDef FindUnaryOpMethod1(Code code) {
			foreach (var type in module.Types) {
				if (type.BaseType != VmHandlerBaseType)
					continue;
				if (type.Methods.Count != 4)
					continue;
				var method = FindUnaryMethod(type, code);
				if (method != null)
					return method;
			}
			return null;
		}

		bool FindUnaryOpMethod2() {
			foreach (var type in module.Types) {
				if (type.BaseType == null || type.BaseType.FullName != "System.Object")
					continue;
				if (type.Methods.Count != 3)
					continue;

				UnaryNot = FindUnaryMethod(type, Code.Not);
				UnaryNeg = FindUnaryMethod(type, Code.Neg);
				if (UnaryNot != null && UnaryNeg != null)
					return true;
			}
			return false;
		}

		MethodDef FindUnaryMethod(TypeDef type, Code code) {
			foreach (var method in type.Methods) {
				if (!IsUnsaryMethod(method, code))
					continue;

				return method;
			}
			return null;
		}

		bool IsUnsaryMethod(MethodDef method, Code code) {
			if (!method.HasBody || !method.IsStatic)
				return false;
			if (!DotNetUtils.IsMethod(method, "System.Object", "(System.Object)"))
				return false;
			if (CountThrows(method) != 1)
				return false;
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 4; i++) {
				var ldarg = instrs[i];
				if (!ldarg.IsLdarg() || ldarg.GetParameterIndex() != 0)
					continue;
				if (!CheckUnboxAny(instrs[i + 1], ElementType.I4))
					continue;
				if (instrs[i + 2].OpCode.Code != code)
					continue;
				if (!CheckBox(instrs[i + 3], ElementType.I4))
					continue;
				if (!instrs[i + 4].IsStloc())
					continue;

				return true;
			}

			return false;
		}

		static int CountThrows(MethodDef method) {
			if (method == null || method.Body == null)
				return 0;
			int count = 0;
			foreach (var instr in method.Body.Instructions) {
				if (instr.OpCode.Code == Code.Throw)
					count++;
			}
			return count;
		}

		public bool FindArgsLocals() {
			var vmState = FindVmState();
			if (vmState == null)
				return false;

			var ctor = vmState.FindMethod(".ctor");
			return FindArgsLocals(ctor, 1, out ArgsGet, out ArgsSet) &&
				FindArgsLocals(ctor, 2, out LocalsGet, out LocalsSet);
		}

		TypeDef FindVmState() {
			if (VmHandlerBaseType == null)
				return null;
			foreach (var method in VmHandlerBaseType.Methods) {
				if (method.IsStatic || !method.IsAbstract)
					continue;
				if (method.Parameters.Count != 2)
					continue;
				var arg1 = method.Parameters[1].Type.TryGetTypeDef();
				if (arg1 == null)
					continue;

				return arg1;
			}
			return null;
		}

		static bool FindArgsLocals(MethodDef ctor, int arg, out MethodDef getter, out MethodDef setter) {
			getter = null;
			setter = null;
			if (ctor == null || !ctor.HasBody)
				return false;

			setter = FindSetter(ctor, arg);
			if (setter == null)
				return false;

			var propField = GetPropField(setter);
			if (propField == null)
				return false;

			getter = FindGetter(ctor.DeclaringType, propField);
			return getter != null;
		}

		static MethodDef FindSetter(MethodDef ctor, int arg) {
			if (ctor == null || !ctor.HasBody)
				return null;

			var instrs = ctor.Body.Instructions;
			for (int i = 0; i < instrs.Count - 1; i++) {
				var ldarg = instrs[i];
				if (!ldarg.IsLdarg() || ldarg.GetParameterIndex() != arg)
					continue;
				var call = instrs[i + 1];
				if (call.OpCode.Code != Code.Call)
					continue;
				var method = call.Operand as MethodDef;
				if (method == null)
					continue;
				if (method.DeclaringType != ctor.DeclaringType)
					continue;

				return method;
			}

			return null;
		}

		static FieldDef GetPropField(MethodDef method) {
			if (method == null || !method.HasBody)
				return null;

			foreach (var instr in method.Body.Instructions) {
				if (instr.OpCode.Code != Code.Stfld)
					continue;
				var field = instr.Operand as FieldDef;
				if (field == null || field.DeclaringType != method.DeclaringType)
					continue;

				return field;
			}

			return null;
		}

		static MethodDef FindGetter(TypeDef type, FieldDef propField) {
			foreach (var method in type.Methods) {
				if (method.IsStatic || !method.HasBody)
					continue;
				foreach (var instr in method.Body.Instructions) {
					if (instr.OpCode.Code != Code.Ldfld)
						continue;
					if (instr.Operand != propField)
						continue;

					return method;
				}
			}

			return null;
		}

		static bool CheckCallvirt(Instruction instr, string returnType, string parameters) {
			if (instr.OpCode.Code != Code.Callvirt)
				return false;
			return DotNetUtils.IsMethod(instr.Operand as IMethod, returnType, parameters);
		}

		bool CheckUnboxAny(Instruction instr, ElementType expectedType) {
			if (instr == null || instr.OpCode.Code != Code.Unbox_Any)
				return false;
			var typeSig = module.CorLibTypes.GetCorLibTypeSig(instr.Operand as ITypeDefOrRef);
			return typeSig.GetElementType() == expectedType;
		}

		bool CheckBox(Instruction instr, ElementType expectedType) {
			if (instr == null || instr.OpCode.Code != Code.Box)
				return false;
			var typeSig = module.CorLibTypes.GetCorLibTypeSig(instr.Operand as ITypeDefOrRef);
			return typeSig.GetElementType() == expectedType;
		}

		static int CountVirtual(TypeDef type) {
			int count = 0;
			foreach (var method in type.Methods) {
				if (method.IsVirtual)
					count++;
			}
			return count;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Agile_NET/vm/v2/CsvmResources.Designer.cs
================================================
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace de4dot.code.deobfuscators.Agile_NET.vm.v2 {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class CsvmResources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal CsvmResources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("de4dot.code.deobfuscators.Agile_NET.vm.v2.CsvmResources", typeof(CsvmResources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Byte[].
        /// </summary>
        internal static byte[] CSVM1 {
            get {
                object obj = ResourceManager.GetObject("CSVM1", resourceCulture);
                return ((byte[])(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Byte[].
        /// </summary>
        internal static byte[] CSVM2 {
            get {
                object obj = ResourceManager.GetObject("CSVM2", resourceCulture);
                return ((byte[])(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Byte[].
        /// </summary>
        internal static byte[] CSVM3 {
            get {
                object obj = ResourceManager.GetObject("CSVM3", resourceCulture);
                return ((byte[])(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Byte[].
        /// </summary>
        internal static byte[] CSVM4 {
            get {
                object obj = ResourceManager.GetObject("CSVM4", resourceCulture);
                return ((byte[])(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Byte[].
        /// </summary>
        internal static byte[] CSVM5 {
            get {
                object obj = ResourceManager.GetObject("CSVM5", resourceCulture);
                return ((byte[])(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Byte[].
        /// </summary>
        internal static byte[] CSVM6 {
            get {
                object obj = ResourceManager.GetObject("CSVM6", resourceCulture);
                return ((byte[])(obj));
            }
        }
    }
}



================================================
File: de4dot.code/deobfuscators/Agile_NET/vm/v2/CsvmResources.resx
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <assembly alias="System.Windows.Forms" name="System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />
  <data name="CSVM1" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>CSVM1.bin;System.Byte[], mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="CSVM2" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>CSVM2.bin;System.Byte[], mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="CSVM3" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>CSVM3.bin;System.Byte[], mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="CSVM4" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>CSVM4.bin;System.Byte[], mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="CSVM5" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>CSVM5.bin;System.Byte[], mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="CSVM6" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>CSVM6.bin;System.Byte[], mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
</root>



================================================
File: de4dot.code/deobfuscators/Agile_NET/vm/v2/CsvmToCilMethodConverter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using System.IO;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace de4dot.code.deobfuscators.Agile_NET.vm.v2 {
	class CsvmToCilMethodConverter : CsvmToCilMethodConverterBase {
		VmOpCodeHandlerDetector opCodeDetector;

		public CsvmToCilMethodConverter(IDeobfuscatorContext deobfuscatorContext, ModuleDefMD module, VmOpCodeHandlerDetector opCodeDetector)
			: base(deobfuscatorContext, module) => this.opCodeDetector = opCodeDetector;

		protected override List<Instruction> ReadInstructions(MethodDef cilMethod, CsvmMethodData csvmMethod) {
			var reader = new BinaryReader(new MemoryStream(csvmMethod.Instructions));
			var instrs = new List<Instruction>();
			var gpContext = GenericParamContext.Create(cilMethod);
			var handlerInfoReader = new OpCodeHandlerInfoReader(module, gpContext);

			int numVmInstrs = reader.ReadInt32();
			var vmInstrs = new ushort[numVmInstrs];
			for (int i = 0; i < numVmInstrs; i++)
				vmInstrs[i] = reader.ReadUInt16();

			uint offset = 0;
			for (int vmInstrIndex = 0; vmInstrIndex < numVmInstrs; vmInstrIndex++) {
				var composite = opCodeDetector.Handlers[vmInstrs[vmInstrIndex]];
				IList<HandlerTypeCode> handlerInfos = composite.HandlerTypeCodes;
				if (handlerInfos.Count == 0)
					handlerInfos = new HandlerTypeCode[] { HandlerTypeCode.Nop };
				for (int hi = 0; hi < handlerInfos.Count; hi++) {
					var instr = handlerInfoReader.Read(handlerInfos[hi], reader);
					instr.Offset = offset;
					offset += (uint)GetInstructionSize(instr);
					SetCilToVmIndex(instr, vmInstrIndex);
					if (hi == 0)
						SetVmIndexToCil(instr, vmInstrIndex);
					instrs.Add(instr);
				}
			}

			return instrs;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Agile_NET/vm/v2/HandlerTypeCode.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

namespace de4dot.code.deobfuscators.Agile_NET.vm.v2 {
	// These constants are hard coded. Don't change the values (i.e., only append if more are needed)
	enum HandlerTypeCode {
		Add,
		Add_Ovf,
		Add_Ovf_Un,
		And,
		Beq,
		Bge,
		Bge_Un,
		Bgt,
		Bgt_Un,
		Ble,
		Ble_Un,
		Blt,
		Blt_Un,
		Bne_Un,
		Box,
		Br,
		Brfalse,
		Brtrue,
		Call,
		Callvirt,
		Castclass,
		Ceq,
		Cgt,
		Cgt_Un,
		Clt,
		Clt_Un,
		Conv,
		Div,
		Div_Un,
		Dup,
		Endfinally,
		Initobj,
		Isinst,
		Ldarg,
		Ldarga,
		Ldc,
		Ldelem,
		Ldelema,
		Ldfld_Ldsfld,
		Ldflda_Ldsflda,
		Ldftn,
		Ldlen,
		Ldloc,
		Ldloca,
		Ldobj,
		Ldstr,
		Ldtoken,
		Ldvirtftn,
		Leave,
		Mul,
		Mul_Ovf,
		Mul_Ovf_Un,
		Neg,
		Newarr,
		Newobj,
		Nop,
		Not,
		Or,
		Pop,
		Rem,
		Rem_Un,
		Ret,
		Rethrow,
		Shl,
		Shr,
		Shr_Un,
		Starg,
		Stelem,
		Stfld_Stsfld,
		Stloc,
		Stobj,
		Sub,
		Sub_Ovf,
		Sub_Ovf_Un,
		Switch,
		Throw,
		Unbox_Any,
		Xor,
	}
}



================================================
File: de4dot.code/deobfuscators/Agile_NET/vm/v2/OpCodeHandlerInfo.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Text;

namespace de4dot.code.deobfuscators.Agile_NET.vm.v2 {
	class OpCodeHandlerInfo {
		public HandlerTypeCode TypeCode { get; private set; }
		public string Name { get; private set; }

		public OpCodeHandlerInfo(HandlerTypeCode typeCode) {
			TypeCode = typeCode;
			Name = GetHandlerName(typeCode);
		}

		public override string ToString() => Name;

		public static string GetCompositeName(IList<HandlerTypeCode> typeCodes) {
			if (typeCodes.Count == 0)
				return "<nothing>";
			var sb = new StringBuilder();
			foreach (var typeCode in typeCodes) {
				if (sb.Length != 0)
					sb.Append(", ");
				sb.Append(GetHandlerName(typeCode));
			}
			return sb.ToString();
		}

		public static string GetHandlerName(HandlerTypeCode code) {
			switch (code) {
			case HandlerTypeCode.Add:			return "add";
			case HandlerTypeCode.Add_Ovf:		return "add.ovf";
			case HandlerTypeCode.Add_Ovf_Un:	return "add.ovf.un";
			case HandlerTypeCode.And:			return "and";
			case HandlerTypeCode.Beq:			return "beq";
			case HandlerTypeCode.Bge:			return "bge";
			case HandlerTypeCode.Bge_Un:		return "bge.un";
			case HandlerTypeCode.Bgt:			return "bgt";
			case HandlerTypeCode.Bgt_Un:		return "bgt.un";
			case HandlerTypeCode.Ble:			return "ble";
			case HandlerTypeCode.Ble_Un:		return "ble.un";
			case HandlerTypeCode.Blt:			return "blt";
			case HandlerTypeCode.Blt_Un:		return "blt.un";
			case HandlerTypeCode.Bne_Un:		return "bne.un";
			case HandlerTypeCode.Box:			return "box";
			case HandlerTypeCode.Br:			return "br";
			case HandlerTypeCode.Brfalse:		return "brfalse";
			case HandlerTypeCode.Brtrue:		return "brtrue";
			case HandlerTypeCode.Call:			return "call";
			case HandlerTypeCode.Callvirt:		return "callvirt";
			case HandlerTypeCode.Castclass:		return "castclass";
			case HandlerTypeCode.Ceq:			return "ceq";
			case HandlerTypeCode.Cgt:			return "cgt";
			case HandlerTypeCode.Cgt_Un:		return "cgt.un";
			case HandlerTypeCode.Clt:			return "clt";
			case HandlerTypeCode.Clt_Un:		return "clt.un";
			case HandlerTypeCode.Conv:			return "conv";
			case HandlerTypeCode.Div:			return "div";
			case HandlerTypeCode.Div_Un:		return "div.un";
			case HandlerTypeCode.Dup:			return "dup";
			case HandlerTypeCode.Endfinally:	return "endfinally";
			case HandlerTypeCode.Initobj:		return "initobj";
			case HandlerTypeCode.Isinst:		return "isinst";
			case HandlerTypeCode.Ldarg:			return "ldarg";
			case HandlerTypeCode.Ldarga:		return "ldarga";
			case HandlerTypeCode.Ldc:			return "ldc";
			case HandlerTypeCode.Ldelem:		return "ldelem";
			case HandlerTypeCode.Ldelema:		return "ldelema";
			case HandlerTypeCode.Ldfld_Ldsfld:	return "ldfld/ldsfld";
			case HandlerTypeCode.Ldflda_Ldsflda:return "ldflda/ldsflda";
			case HandlerTypeCode.Ldftn:			return "ldftn";
			case HandlerTypeCode.Ldlen:			return "ldlen";
			case HandlerTypeCode.Ldloc:			return "ldloc";
			case HandlerTypeCode.Ldloca:		return "ldloca";
			case HandlerTypeCode.Ldobj:			return "ldobj";
			case HandlerTypeCode.Ldstr:			return "ldstr";
			case HandlerTypeCode.Ldtoken:		return "ldtoken";
			case HandlerTypeCode.Ldvirtftn:		return "ldvirtftn";
			case HandlerTypeCode.Leave:			return "leave";
			case HandlerTypeCode.Mul:			return "mul";
			case HandlerTypeCode.Mul_Ovf:		return "mul.ovf";
			case HandlerTypeCode.Mul_Ovf_Un:	return "mul.ovf.un";
			case HandlerTypeCode.Neg:			return "neg";
			case HandlerTypeCode.Newarr:		return "newarr";
			case HandlerTypeCode.Newobj:		return "newobj";
			case HandlerTypeCode.Nop:			return "nop";
			case HandlerTypeCode.Not:			return "not";
			case HandlerTypeCode.Or:			return "or";
			case HandlerTypeCode.Pop:			return "pop";
			case HandlerTypeCode.Rem:			return "rem";
			case HandlerTypeCode.Rem_Un:		return "rem.un";
			case HandlerTypeCode.Ret:			return "ret";
			case HandlerTypeCode.Rethrow:		return "rethrow";
			case HandlerTypeCode.Shl:			return "shl";
			case HandlerTypeCode.Shr:			return "shr";
			case HandlerTypeCode.Shr_Un:		return "shr.un";
			case HandlerTypeCode.Starg:			return "starg";
			case HandlerTypeCode.Stelem:		return "stelem";
			case HandlerTypeCode.Stfld_Stsfld:	return "stfld/stsfld";
			case HandlerTypeCode.Stloc:			return "stloc";
			case HandlerTypeCode.Stobj:			return "stobj";
			case HandlerTypeCode.Sub:			return "sub";
			case HandlerTypeCode.Sub_Ovf:		return "sub.ovf";
			case HandlerTypeCode.Sub_Ovf_Un:	return "sub.ovf.un";
			case HandlerTypeCode.Switch:		return "switch";
			case HandlerTypeCode.Throw:			return "throw";
			case HandlerTypeCode.Unbox_Any:		return "unbox.any";
			case HandlerTypeCode.Xor:			return "xor";
			default: throw new ApplicationException("Invalid handler type code");
			}
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Agile_NET/vm/v2/OpCodeHandlerInfoReader.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.IO;
using dnlib.DotNet.Emit;
using dnlib.DotNet;

namespace de4dot.code.deobfuscators.Agile_NET.vm.v2 {
	class OpCodeHandlerInfoReader {
		IInstructionOperandResolver resolver;
		Dictionary<HandlerTypeCode, Func<BinaryReader, Instruction>> readHandlers;
		readonly GenericParamContext gpContext;

		public OpCodeHandlerInfoReader(IInstructionOperandResolver resolver, GenericParamContext gpContext) {
			this.resolver = resolver;
			this.gpContext = gpContext;
			readHandlers = new Dictionary<HandlerTypeCode, Func<BinaryReader, Instruction>> {
				{ HandlerTypeCode.Add,			Handler_Add },
				{ HandlerTypeCode.Add_Ovf,		Handler_Add_Ovf },
				{ HandlerTypeCode.Add_Ovf_Un,	Handler_Add_Ovf_Un },
				{ HandlerTypeCode.And,			Handler_And },
				{ HandlerTypeCode.Beq,			Handler_Beq },
				{ HandlerTypeCode.Bge,			Handler_Bge },
				{ HandlerTypeCode.Bge_Un,		Handler_Bge_Un },
				{ HandlerTypeCode.Bgt,			Handler_Bgt },
				{ HandlerTypeCode.Bgt_Un,		Handler_Bgt_Un },
				{ HandlerTypeCode.Ble,			Handler_Ble },
				{ HandlerTypeCode.Ble_Un,		Handler_Ble_Un },
				{ HandlerTypeCode.Blt,			Handler_Blt },
				{ HandlerTypeCode.Blt_Un,		Handler_Blt_Un },
				{ HandlerTypeCode.Bne_Un,		Handler_Bne_Un },
				{ HandlerTypeCode.Box,			Handler_Box },
				{ HandlerTypeCode.Br,			Handler_Br },
				{ HandlerTypeCode.Brfalse,		Handler_Brfalse },
				{ HandlerTypeCode.Brtrue,		Handler_Brtrue },
				{ HandlerTypeCode.Call,			Handler_Call },
				{ HandlerTypeCode.Callvirt,		Handler_Callvirt },
				{ HandlerTypeCode.Castclass,	Handler_Castclass },
				{ HandlerTypeCode.Ceq,			Handler_Ceq },
				{ HandlerTypeCode.Cgt,			Handler_Cgt },
				{ HandlerTypeCode.Cgt_Un,		Handler_Cgt_Un },
				{ HandlerTypeCode.Clt,			Handler_Clt },
				{ HandlerTypeCode.Clt_Un,		Handler_Clt_Un },
				{ HandlerTypeCode.Conv,			Handler_Conv },
				{ HandlerTypeCode.Div,			Handler_Div },
				{ HandlerTypeCode.Div_Un,		Handler_Div_Un },
				{ HandlerTypeCode.Dup,			Handler_Dup },
				{ HandlerTypeCode.Endfinally,	Handler_Endfinally },
				{ HandlerTypeCode.Initobj,		Handler_Initobj },
				{ HandlerTypeCode.Isinst,		Handler_Isinst },
				{ HandlerTypeCode.Ldarg,		Handler_Ldarg },
				{ HandlerTypeCode.Ldarga,		Handler_Ldarga },
				{ HandlerTypeCode.Ldc,			Handler_Ldc },
				{ HandlerTypeCode.Ldelem,		Handler_Ldelem },
				{ HandlerTypeCode.Ldelema,		Handler_Ldelema },
				{ HandlerTypeCode.Ldfld_Ldsfld,	Handler_Ldfld_Ldsfld },
				{ HandlerTypeCode.Ldflda_Ldsflda, Handler_Ldflda_Ldsflda },
				{ HandlerTypeCode.Ldftn,		Handler_Ldftn },
				{ HandlerTypeCode.Ldlen,		Handler_Ldlen },
				{ HandlerTypeCode.Ldloc,		Handler_Ldloc },
				{ HandlerTypeCode.Ldloca,		Handler_Ldloca },
				{ HandlerTypeCode.Ldobj,		Handler_Ldobj },
				{ HandlerTypeCode.Ldstr,		Handler_Ldstr },
				{ HandlerTypeCode.Ldtoken,		Handler_Ldtoken },
				{ HandlerTypeCode.Ldvirtftn,	Handler_Ldvirtftn },
				{ HandlerTypeCode.Leave,		Handler_Leave },
				{ HandlerTypeCode.Mul,			Handler_Mul },
				{ HandlerTypeCode.Mul_Ovf,		Handler_Mul_Ovf },
				{ HandlerTypeCode.Mul_Ovf_Un,	Handler_Mul_Ovf_Un },
				{ HandlerTypeCode.Neg,			Handler_Neg },
				{ HandlerTypeCode.Newarr,		Handler_Newarr },
				{ HandlerTypeCode.Newobj,		Handler_Newobj },
				{ HandlerTypeCode.Nop,			Handler_Nop },
				{ HandlerTypeCode.Not,			Handler_Not },
				{ HandlerTypeCode.Or,			Handler_Or },
				{ HandlerTypeCode.Pop,			Handler_Pop },
				{ HandlerTypeCode.Rem,			Handler_Rem },
				{ HandlerTypeCode.Rem_Un,		Handler_Rem_Un },
				{ HandlerTypeCode.Ret,			Handler_Ret },
				{ HandlerTypeCode.Rethrow,		Handler_Rethrow },
				{ HandlerTypeCode.Shl,			Handler_Shl },
				{ HandlerTypeCode.Shr,			Handler_Shr },
				{ HandlerTypeCode.Shr_Un,		Handler_Shr_Un },
				{ HandlerTypeCode.Starg,		Handler_Starg },
				{ HandlerTypeCode.Stelem,		Handler_Stelem },
				{ HandlerTypeCode.Stfld_Stsfld,	Handler_Stfld_Stsfld },
				{ HandlerTypeCode.Stloc,		Handler_Stloc },
				{ HandlerTypeCode.Stobj,		Handler_Stobj },
				{ HandlerTypeCode.Sub,			Handler_Sub },
				{ HandlerTypeCode.Sub_Ovf,		Handler_Sub_Ovf },
				{ HandlerTypeCode.Sub_Ovf_Un,	Handler_Sub_Ovf_Un },
				{ HandlerTypeCode.Switch,		Handler_Switch },
				{ HandlerTypeCode.Throw,		Handler_Throw },
				{ HandlerTypeCode.Unbox_Any,	Handler_Unbox_Any },
				{ HandlerTypeCode.Xor,			Handler_Xor },
			};
		}

		public Instruction Read(HandlerTypeCode typeCode, BinaryReader reader) {
			if (!readHandlers.TryGetValue(typeCode, out var readHandler))
				throw new ApplicationException("Invalid handler type");
			return readHandler(reader);
		}

		Instruction Handler_Add(BinaryReader reader) => OpCodes.Add.ToInstruction();
		Instruction Handler_Add_Ovf(BinaryReader reader) => OpCodes.Add_Ovf.ToInstruction();
		Instruction Handler_Add_Ovf_Un(BinaryReader reader) => OpCodes.Add_Ovf_Un.ToInstruction();
		Instruction Handler_And(BinaryReader reader) => OpCodes.And.ToInstruction();
		Instruction Handler_Beq(BinaryReader reader) => new Instruction(OpCodes.Beq, new TargetDisplOperand(reader.ReadInt32()));
		Instruction Handler_Bge(BinaryReader reader) => new Instruction(OpCodes.Bge, new TargetDisplOperand(reader.ReadInt32()));
		Instruction Handler_Bge_Un(BinaryReader reader) => new Instruction(OpCodes.Bge_Un, new TargetDisplOperand(reader.ReadInt32()));
		Instruction Handler_Bgt(BinaryReader reader) => new Instruction(OpCodes.Bgt, new TargetDisplOperand(reader.ReadInt32()));
		Instruction Handler_Bgt_Un(BinaryReader reader) => new Instruction(OpCodes.Bgt_Un, new TargetDisplOperand(reader.ReadInt32()));
		Instruction Handler_Ble(BinaryReader reader) => new Instruction(OpCodes.Ble, new TargetDisplOperand(reader.ReadInt32()));
		Instruction Handler_Ble_Un(BinaryReader reader) => new Instruction(OpCodes.Ble_Un, new TargetDisplOperand(reader.ReadInt32()));
		Instruction Handler_Blt(BinaryReader reader) => new Instruction(OpCodes.Blt, new TargetDisplOperand(reader.ReadInt32()));
		Instruction Handler_Blt_Un(BinaryReader reader) => new Instruction(OpCodes.Blt_Un, new TargetDisplOperand(reader.ReadInt32()));
		Instruction Handler_Bne_Un(BinaryReader reader) => new Instruction(OpCodes.Bne_Un, new TargetDisplOperand(reader.ReadInt32()));
		Instruction Handler_Box(BinaryReader reader) => OpCodes.Box.ToInstruction(resolver.ResolveToken(reader.ReadUInt32(), gpContext) as ITypeDefOrRef);
		Instruction Handler_Br(BinaryReader reader) => new Instruction(OpCodes.Br, new TargetDisplOperand(reader.ReadInt32()));
		Instruction Handler_Brfalse(BinaryReader reader) => new Instruction(OpCodes.Brfalse, new TargetDisplOperand(reader.ReadInt32()));
		Instruction Handler_Brtrue(BinaryReader reader) => new Instruction(OpCodes.Brtrue, new TargetDisplOperand(reader.ReadInt32()));
		Instruction Handler_Call(BinaryReader reader) => OpCodes.Call.ToInstruction(resolver.ResolveToken(reader.ReadUInt32(), gpContext) as IMethod);
		Instruction Handler_Callvirt(BinaryReader reader) => OpCodes.Callvirt.ToInstruction(resolver.ResolveToken(reader.ReadUInt32(), gpContext) as IMethod);
		Instruction Handler_Castclass(BinaryReader reader) => OpCodes.Castclass.ToInstruction(resolver.ResolveToken(reader.ReadUInt32(), gpContext) as ITypeDefOrRef);
		Instruction Handler_Ceq(BinaryReader reader) => OpCodes.Ceq.ToInstruction();
		Instruction Handler_Cgt(BinaryReader reader) => OpCodes.Cgt.ToInstruction();
		Instruction Handler_Cgt_Un(BinaryReader reader) => OpCodes.Cgt_Un.ToInstruction();
		Instruction Handler_Clt(BinaryReader reader) => OpCodes.Clt.ToInstruction();
		Instruction Handler_Clt_Un(BinaryReader reader) => OpCodes.Clt_Un.ToInstruction();

		class ConvInfo {
			public byte Type { get; private set; }
			public bool Second { get; private set; }
			public bool Third { get; private set; }
			public OpCode OpCode { get; private set; }
			public ConvInfo(byte type, bool second, bool third, OpCode opCode) {
				Type = type;
				Second = second;
				Third = third;
				OpCode = opCode;
			}
		}
		readonly static List<ConvInfo> instructionInfos1 = new List<ConvInfo> {
			new ConvInfo(0, false, false, OpCodes.Conv_I1),
			new ConvInfo(1, false, false, OpCodes.Conv_I2),
			new ConvInfo(2, false, false, OpCodes.Conv_I4),
			new ConvInfo(3, false, false, OpCodes.Conv_I8),
			new ConvInfo(4, false, false, OpCodes.Conv_R4),
			new ConvInfo(5, false, false, OpCodes.Conv_R8),
			new ConvInfo(6, false, false, OpCodes.Conv_U1),
			new ConvInfo(7, false, false, OpCodes.Conv_U2),
			new ConvInfo(8, false, false, OpCodes.Conv_U4),
			new ConvInfo(9, false, false, OpCodes.Conv_U8),
			new ConvInfo(10, false, false, OpCodes.Conv_I),
			new ConvInfo(11, false, false, OpCodes.Conv_U),

			new ConvInfo(0, true, false, OpCodes.Conv_Ovf_I1),
			new ConvInfo(1, true, false, OpCodes.Conv_Ovf_I2),
			new ConvInfo(2, true, false, OpCodes.Conv_Ovf_I4),
			new ConvInfo(3, true, false, OpCodes.Conv_Ovf_I8),
			new ConvInfo(6, true, false, OpCodes.Conv_Ovf_U1),
			new ConvInfo(7, true, false, OpCodes.Conv_Ovf_U2),
			new ConvInfo(8, true, false, OpCodes.Conv_Ovf_U4),
			new ConvInfo(9, true, false, OpCodes.Conv_Ovf_U8),
			new ConvInfo(10, true, false, OpCodes.Conv_Ovf_I),
			new ConvInfo(11, true, false, OpCodes.Conv_Ovf_U),

			new ConvInfo(0, true, true, OpCodes.Conv_Ovf_I1_Un),
			new ConvInfo(1, true, true, OpCodes.Conv_Ovf_I2_Un),
			new ConvInfo(2, true, true, OpCodes.Conv_Ovf_I4_Un),
			new ConvInfo(3, true, true, OpCodes.Conv_Ovf_I8_Un),
			new ConvInfo(6, true, true, OpCodes.Conv_Ovf_U1_Un),
			new ConvInfo(7, true, true, OpCodes.Conv_Ovf_U2_Un),
			new ConvInfo(8, true, true, OpCodes.Conv_Ovf_U4_Un),
			new ConvInfo(9, true, true, OpCodes.Conv_Ovf_U8_Un),
			new ConvInfo(10, true, true, OpCodes.Conv_Ovf_I_Un),
			new ConvInfo(11, true, true, OpCodes.Conv_Ovf_U_Un),
			new ConvInfo(12, true, true, OpCodes.Conv_R_Un),
		};
		Instruction Handler_Conv(BinaryReader reader) {
			byte type = reader.ReadByte();
			bool second = reader.ReadBoolean();
			bool third = reader.ReadBoolean();

			Instruction instr = null;
			foreach (var info in instructionInfos1) {
				if (type != info.Type || info.Second != second || info.Third != third)
					continue;

				instr = new Instruction { OpCode = info.OpCode };
				break;
			}
			if (instr == null)
				throw new ApplicationException("Invalid opcode");

			return instr;
		}

		Instruction Handler_Div(BinaryReader reader) => OpCodes.Div.ToInstruction();
		Instruction Handler_Div_Un(BinaryReader reader) => OpCodes.Div_Un.ToInstruction();
		Instruction Handler_Dup(BinaryReader reader) => OpCodes.Dup.ToInstruction();
		Instruction Handler_Endfinally(BinaryReader reader) => OpCodes.Endfinally.ToInstruction();
		Instruction Handler_Initobj(BinaryReader reader) => OpCodes.Initobj.ToInstruction(resolver.ResolveToken(reader.ReadUInt32(), gpContext) as ITypeDefOrRef);
		Instruction Handler_Isinst(BinaryReader reader) => OpCodes.Isinst.ToInstruction(resolver.ResolveToken(reader.ReadUInt32(), gpContext) as ITypeDefOrRef);
		Instruction Handler_Ldarg(BinaryReader reader) => new Instruction(OpCodes.Ldarg, new ArgOperand(reader.ReadUInt16()));
		Instruction Handler_Ldarga(BinaryReader reader) => new Instruction(OpCodes.Ldarga, new ArgOperand(reader.ReadUInt16()));

		Instruction Handler_Ldc(BinaryReader reader) {
			switch ((ElementType)reader.ReadByte()) {
			case ElementType.I4:		return Instruction.CreateLdcI4(reader.ReadInt32());
			case ElementType.I8:		return OpCodes.Ldc_I8.ToInstruction(reader.ReadInt64());
			case ElementType.R4:		return OpCodes.Ldc_R4.ToInstruction(reader.ReadSingle());
			case ElementType.R8:		return OpCodes.Ldc_R8.ToInstruction(reader.ReadDouble());
			case ElementType.Object:	return OpCodes.Ldnull.ToInstruction();
			default: throw new ApplicationException("Invalid instruction");
			}
		}

		Instruction Handler_Ldelem(BinaryReader reader) => new Instruction(OpCodes.Ldelem, null);
		Instruction Handler_Ldelema(BinaryReader reader) => new Instruction(OpCodes.Ldelema, null);

		Instruction Handler_Ldfld_Ldsfld(BinaryReader reader) {
			var field = resolver.ResolveToken(reader.ReadUInt32(), gpContext) as IField;
			return new Instruction(null, new FieldInstructionOperand(OpCodes.Ldsfld, OpCodes.Ldfld, field));
		}

		Instruction Handler_Ldflda_Ldsflda(BinaryReader reader) {
			var field = resolver.ResolveToken(reader.ReadUInt32(), gpContext) as IField;
			return new Instruction(null, new FieldInstructionOperand(OpCodes.Ldsflda, OpCodes.Ldflda, field));
		}

		Instruction Handler_Ldftn(BinaryReader reader) => OpCodes.Ldftn.ToInstruction(resolver.ResolveToken(reader.ReadUInt32(), gpContext) as IMethod);
		Instruction Handler_Ldlen(BinaryReader reader) => OpCodes.Ldlen.ToInstruction();
		Instruction Handler_Ldloc(BinaryReader reader) => new Instruction(OpCodes.Ldloc, new LocalOperand(reader.ReadUInt16()));
		Instruction Handler_Ldloca(BinaryReader reader) => new Instruction(OpCodes.Ldloca, new LocalOperand(reader.ReadUInt16()));
		Instruction Handler_Ldobj(BinaryReader reader) => new Instruction(OpCodes.Ldobj, null);
		Instruction Handler_Ldstr(BinaryReader reader) => OpCodes.Ldstr.ToInstruction(reader.ReadString());
		Instruction Handler_Ldtoken(BinaryReader reader) => OpCodes.Ldtoken.ToInstruction(resolver.ResolveToken(reader.ReadUInt32(), gpContext) as ITokenOperand);

		Instruction Handler_Ldvirtftn(BinaryReader reader) {
			var method = resolver.ResolveToken(reader.ReadUInt32(), gpContext) as IMethod;
			reader.ReadUInt32();
			return OpCodes.Ldvirtftn.ToInstruction(method);
		}

		Instruction Handler_Leave(BinaryReader reader) => new Instruction(OpCodes.Leave, new TargetDisplOperand(reader.ReadInt32()));
		Instruction Handler_Mul(BinaryReader reader) => OpCodes.Mul.ToInstruction();
		Instruction Handler_Mul_Ovf(BinaryReader reader) => OpCodes.Mul_Ovf.ToInstruction();
		Instruction Handler_Mul_Ovf_Un(BinaryReader reader) => OpCodes.Mul_Ovf_Un.ToInstruction();
		Instruction Handler_Neg(BinaryReader reader) => OpCodes.Neg.ToInstruction();
		Instruction Handler_Newarr(BinaryReader reader) => OpCodes.Newarr.ToInstruction(resolver.ResolveToken(reader.ReadUInt32(), gpContext) as ITypeDefOrRef);
		Instruction Handler_Newobj(BinaryReader reader) => OpCodes.Newobj.ToInstruction(resolver.ResolveToken(reader.ReadUInt32(), gpContext) as IMethod);
		Instruction Handler_Nop(BinaryReader reader) => OpCodes.Nop.ToInstruction();
		Instruction Handler_Not(BinaryReader reader) => OpCodes.Not.ToInstruction();
		Instruction Handler_Or(BinaryReader reader) => OpCodes.Or.ToInstruction();
		Instruction Handler_Pop(BinaryReader reader) => OpCodes.Pop.ToInstruction();
		Instruction Handler_Rem(BinaryReader reader) => OpCodes.Rem.ToInstruction();
		Instruction Handler_Rem_Un(BinaryReader reader) => OpCodes.Rem_Un.ToInstruction();

		Instruction Handler_Ret(BinaryReader reader) {
			/*var method =*/ resolver.ResolveToken(reader.ReadUInt32(), gpContext) /*as IMethod*/;
			return OpCodes.Ret.ToInstruction();
		}

		Instruction Handler_Rethrow(BinaryReader reader) => OpCodes.Rethrow.ToInstruction();
		Instruction Handler_Shl(BinaryReader reader) => OpCodes.Shl.ToInstruction();
		Instruction Handler_Shr(BinaryReader reader) => OpCodes.Shr.ToInstruction();
		Instruction Handler_Shr_Un(BinaryReader reader) => OpCodes.Shr_Un.ToInstruction();
		Instruction Handler_Starg(BinaryReader reader) => new Instruction(OpCodes.Starg, new ArgOperand(reader.ReadUInt16()));
		Instruction Handler_Stelem(BinaryReader reader) => new Instruction(OpCodes.Stelem, null);

		Instruction Handler_Stfld_Stsfld(BinaryReader reader) {
			var field = resolver.ResolveToken(reader.ReadUInt32(), gpContext) as IField;
			return new Instruction(null, new FieldInstructionOperand(OpCodes.Stsfld, OpCodes.Stfld, field));
		}

		Instruction Handler_Stloc(BinaryReader reader) {
			ushort loc = reader.ReadUInt16();
			/*var etype = (ElementType)*/reader.ReadInt32();
			return new Instruction(OpCodes.Stloc, new LocalOperand(loc));
		}

		Instruction Handler_Stobj(BinaryReader reader) => new Instruction(OpCodes.Stobj, null);
		Instruction Handler_Sub(BinaryReader reader) => OpCodes.Sub.ToInstruction();
		Instruction Handler_Sub_Ovf(BinaryReader reader) => OpCodes.Sub_Ovf.ToInstruction();
		Instruction Handler_Sub_Ovf_Un(BinaryReader reader) => OpCodes.Sub_Ovf_Un.ToInstruction();

		Instruction Handler_Switch(BinaryReader reader) {
			int size = reader.ReadInt32();
			var offsets = new int[size];
			for (int i = 0; i < size; i++)
				offsets[i] = reader.ReadInt32();
			return new Instruction(OpCodes.Switch, new SwitchTargetDisplOperand(offsets));
		}

		Instruction Handler_Throw(BinaryReader reader) => OpCodes.Throw.ToInstruction();
		Instruction Handler_Unbox_Any(BinaryReader reader) => OpCodes.Unbox_Any.ToInstruction(resolver.ResolveToken(reader.ReadUInt32(), gpContext) as ITypeDefOrRef);
		Instruction Handler_Xor(BinaryReader reader) => OpCodes.Xor.ToInstruction();
	}
}



================================================
File: de4dot.code/deobfuscators/Agile_NET/vm/v2/OpCodeHandlerInfos.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using System.IO;

namespace de4dot.code.deobfuscators.Agile_NET.vm.v2 {
	static class OpCodeHandlerInfos {
		public static void Write(BinaryWriter writer, List<MethodSigInfo> handlerInfos) {
			writer.Write(1);
			writer.Write(handlerInfos.Count);
			foreach (var handler in handlerInfos) {
				writer.Write((int)handler.TypeCode);
				writer.Write(handler.BlockSigInfos.Count);
				foreach (var info in handler.BlockSigInfos) {
					writer.Write(info.Targets.Count);
					foreach (var target in info.Targets)
						writer.Write(target);
					writer.Write(info.Hashes.Count);
					foreach (var hash in info.Hashes)
						writer.Write((uint)hash);
					writer.Write(info.HasFallThrough);
					writer.Write(info.EndsInRet);
				}
			}
		}

		public static List<MethodSigInfo> Read(BinaryReader reader) {
			if (reader.ReadInt32() != 1)
				throw new InvalidDataException();
			int numHandlers = reader.ReadInt32();
			var list = new List<MethodSigInfo>(numHandlers);
			for (int i = 0; i < numHandlers; i++) {
				var typeCode = (HandlerTypeCode)reader.ReadInt32();
				int numBlocks = reader.ReadInt32();
				var blocks = new List<BlockSigInfo>(numBlocks);
				for (int j = 0; j < numBlocks; j++) {
					int numTargets = reader.ReadInt32();
					var targets = new List<int>(numTargets);
					for (int k = 0; k < numTargets; k++)
						targets.Add(reader.ReadInt32());
					var numHashes = reader.ReadInt32();
					var hashes = new List<BlockElementHash>(numHashes);
					for (int k = 0; k < numHashes; k++)
						hashes.Add((BlockElementHash)reader.ReadInt32());
					var block = new BlockSigInfo(hashes, targets) {
						HasFallThrough = reader.ReadBoolean(),
						EndsInRet = reader.ReadBoolean(),
					};
					blocks.Add(block);
				}
				list.Add(new MethodSigInfo(blocks, typeCode));
			}
			return list;
		}

		public static readonly IList<MethodSigInfo>[] HandlerInfos = new IList<MethodSigInfo>[] {
			ReadOpCodeHandlerInfos(CsvmResources.CSVM1),
			ReadOpCodeHandlerInfos(CsvmResources.CSVM2),
			ReadOpCodeHandlerInfos(CsvmResources.CSVM3),
			ReadOpCodeHandlerInfos(CsvmResources.CSVM4),
			ReadOpCodeHandlerInfos(CsvmResources.CSVM5),
			ReadOpCodeHandlerInfos(CsvmResources.CSVM6),

		};

		static IList<MethodSigInfo> ReadOpCodeHandlerInfos(byte[] data) =>
			OpCodeHandlerInfos.Read(new BinaryReader(new MemoryStream(data)));
	}
}



================================================
File: de4dot.code/deobfuscators/Agile_NET/vm/v2/SigCreator.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using System.Text;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Agile_NET.vm.v2 {
	class MethodSigInfo {
		public HandlerTypeCode TypeCode { get; set; }
		public List<BlockSigInfo> BlockSigInfos { get; private set; }

		public MethodSigInfo(List<BlockSigInfo> blockSigInfos) => BlockSigInfos = blockSigInfos;

		public MethodSigInfo(List<BlockSigInfo> blockSigInfos, HandlerTypeCode typeCode) {
			BlockSigInfos = blockSigInfos;
			TypeCode = typeCode;
		}

		public override string ToString() => OpCodeHandlerInfo.GetHandlerName(TypeCode);
	}

	class BlockSigInfo {
		readonly List<int> targets;

		public List<BlockElementHash> Hashes { get; private set; }
		public List<int> Targets => targets;
		public bool HasFallThrough { get; set; }
		public bool EndsInRet { get; set; }

		public BlockSigInfo() {
			targets = new List<int>();
			Hashes = new List<BlockElementHash>();
		}

		public BlockSigInfo(List<BlockElementHash> hashes, List<int> targets) {
			Hashes = hashes;
			this.targets = targets;
		}
	}

	enum BlockElementHash : int {
	}

	class SigCreator {
		const int BASE_INDEX = 0x40000000;
		Blocks blocks;
		Dictionary<object, int> objToId = new Dictionary<object, int>();
		CRC32 hasher = new CRC32();

		public SigCreator() {
		}

		public void AddId(object key, int id) {
			if (key != null)
				objToId[key] = id;
		}

		int? GetId(object key) {
			if (key == null)
				return null;

			if (objToId.TryGetValue(key, out int id))
				return id;
			return null;
		}

		public List<BlockSigInfo> Create(MethodDef method) {
			blocks = new Blocks(method);
			var allBlocks = blocks.MethodBlocks.GetAllBlocks();

			var blockInfos = new List<BlockSigInfo>(allBlocks.Count);
			foreach (var block in allBlocks) {
				var blockInfo = new BlockSigInfo {
					HasFallThrough = block.FallThrough != null,
					EndsInRet = block.LastInstr.OpCode.Code == Code.Ret,
				};
				blockInfos.Add(blockInfo);
				var instrs = block.Instructions;
				for (int i = 0; i < instrs.Count; i++) {
					var info = CalculateHash(instrs, ref i);
					if (info != null)
						blockInfo.Hashes.Add(info.Value);
				}
			}

			for (int i = 0; i < blockInfos.Count; i++) {
				var block = allBlocks[i];
				var blockInfo = blockInfos[i];

				if (block.FallThrough != null)
					blockInfo.Targets.Add(allBlocks.IndexOf(block.FallThrough));
				if (block.Targets != null) {
					foreach (var target in block.Targets)
						blockInfo.Targets.Add(allBlocks.IndexOf(target));
				}
			}

			return blockInfos;
		}

		BlockElementHash? CalculateHash(IList<Instr> instrs, ref int index) {
			hasher.Initialize();
			var instr = instrs[index];
			switch (instr.OpCode.Code) {
			case Code.Beq:
			case Code.Beq_S:
				return GetHash(BASE_INDEX + 0);

			case Code.Bge:
			case Code.Bge_S:
				return GetHash(BASE_INDEX + 1);

			case Code.Bge_Un:
			case Code.Bge_Un_S:
				return GetHash(BASE_INDEX + 2);

			case Code.Bgt:
			case Code.Bgt_S:
				return GetHash(BASE_INDEX + 3);

			case Code.Bgt_Un:
			case Code.Bgt_Un_S:
				return GetHash(BASE_INDEX + 4);

			case Code.Ble:
			case Code.Ble_S:
				return GetHash(BASE_INDEX + 5);

			case Code.Ble_Un:
			case Code.Ble_Un_S:
				return GetHash(BASE_INDEX + 6);

			case Code.Blt:
			case Code.Blt_S:
				return GetHash(BASE_INDEX + 7);

			case Code.Blt_Un:
			case Code.Blt_Un_S:
				return GetHash(BASE_INDEX + 8);

			case Code.Bne_Un:
			case Code.Bne_Un_S:
				return GetHash(BASE_INDEX + 9);

			case Code.Brfalse:
			case Code.Brfalse_S:
				return GetHash(BASE_INDEX + 10);

			case Code.Brtrue:
			case Code.Brtrue_S:
				return GetHash(BASE_INDEX + 11);

			case Code.Switch:
				return GetHash(BASE_INDEX + 12);

			case Code.Ceq:
				return GetHash(BASE_INDEX + 13);

			case Code.Cgt:
				return GetHash(BASE_INDEX + 14);

			case Code.Cgt_Un:
				return GetHash(BASE_INDEX + 15);

			case Code.Clt:
				return GetHash(BASE_INDEX + 16);

			case Code.Clt_Un:
				return GetHash(BASE_INDEX + 17);

			case Code.Ldc_I4:
			case Code.Ldc_I4_0:
			case Code.Ldc_I4_1:
			case Code.Ldc_I4_2:
			case Code.Ldc_I4_3:
			case Code.Ldc_I4_4:
			case Code.Ldc_I4_5:
			case Code.Ldc_I4_6:
			case Code.Ldc_I4_7:
			case Code.Ldc_I4_8:
			case Code.Ldc_I4_M1:
			case Code.Ldc_I4_S:
				return GetHash(instr.GetLdcI4Value());

			case Code.Ldstr:
				return GetHash(instr.Operand as string);

			case Code.Rethrow:
				return GetHash(BASE_INDEX + 18);

			case Code.Throw:
				return GetHash(BASE_INDEX + 19);

			case Code.Call:
			case Code.Callvirt:
				Hash(instr.Operand);
				return (BlockElementHash)hasher.GetHash();

			case Code.Ldfld:
				var field = instr.Operand as FieldDef;
				if (!IsTypeField(field))
					return null;
				if (index + 1 >= instrs.Count || !instrs[index + 1].IsLdcI4())
					return null;
				index++;
				return GetHash(GetFieldId(field));

			default:
				break;
			}
			return null;
		}

		bool IsTypeField(FieldDef fd) => fd != null && fd.DeclaringType == blocks.Method.DeclaringType;

		static int GetFieldId(FieldDef fd) {
			if (fd == null)
				return int.MinValue;
			var fieldType = fd.FieldSig.GetFieldType();
			if (fieldType == null)
				return int.MinValue + 1;

			int result = BASE_INDEX + 0x1000;
			for (int i = 0; i < 100; i++) {
				result += (int)fieldType.ElementType;
				if (fieldType.Next == null)
					break;
				result += 0x100;
				fieldType = fieldType.Next;
			}

			var td = fieldType.TryGetTypeDef();
			if (td != null && td.IsEnum)
				return result + 0x10000000;
			return result;
		}

		void Hash(object op) {
			if (op is MethodDef md) {
				Hash(md);
				return;
			}

			if (op is MemberRef mr) {
				Hash(mr);
				return;
			}

			if (op is TypeDef td) {
				Hash(td);
				return;
			}

			if (op is TypeRef tr) {
				Hash(tr);
				return;
			}

			if (op is TypeSpec ts) {
				Hash(ts);
				return;
			}

			if (op is FieldSig fsig) {
				Hash(fsig);
				return;
			}

			if (op is MethodSig msig) {
				Hash(msig);
				return;
			}

			if (op is GenericInstMethodSig gsig) {
				Hash(gsig);
				return;
			}

			if (op is AssemblyRef asmRef) {
				Hash(asmRef);
				return;
			}

			if (op is TypeSig tsig) {
				Hash(tsig);
				return;
			}

			return;
		}

		void Hash(TypeSig sig) => Hash(sig, 0);

		void Hash(TypeSig sig, int level) {
			if (sig == null)
				return;
			if (level++ > 20)
				return;

			hasher.Hash((byte)0x41);
			var etype = sig.GetElementType();
			hasher.Hash((byte)etype);
			switch (etype) {
			case ElementType.Ptr:
			case ElementType.ByRef:
			case ElementType.SZArray:
			case ElementType.Pinned:
				Hash(sig.Next, level);
				break;

			case ElementType.Array:
				var arySig = (ArraySig)sig;
				hasher.Hash(arySig.Rank);
				hasher.Hash(arySig.Sizes.Count);
				hasher.Hash(arySig.LowerBounds.Count);
				Hash(sig.Next, level);
				break;

			case ElementType.CModReqd:
			case ElementType.CModOpt:
				Hash(((ModifierSig)sig).Modifier);
				Hash(sig.Next, level);
				break;

			case ElementType.ValueArray:
				hasher.Hash(((ValueArraySig)sig).Size);
				Hash(sig.Next, level);
				break;

			case ElementType.Module:
				hasher.Hash(((ModuleSig)sig).Index);
				Hash(sig.Next, level);
				break;

			case ElementType.GenericInst:
				var gis = (GenericInstSig)sig;
				Hash(gis.GenericType, level);
				foreach (var ga in gis.GenericArguments)
					Hash(ga, level);
				Hash(sig.Next, level);
				break;

			case ElementType.FnPtr:
				Hash(((FnPtrSig)sig).Signature);
				break;

			case ElementType.Var:
			case ElementType.MVar:
				hasher.Hash(((GenericSig)sig).Number);
				break;

			case ElementType.ValueType:
			case ElementType.Class:
				Hash(((TypeDefOrRefSig)sig).TypeDefOrRef);
				break;

			case ElementType.End:
			case ElementType.Void:
			case ElementType.Boolean:
			case ElementType.Char:
			case ElementType.I1:
			case ElementType.U1:
			case ElementType.I2:
			case ElementType.U2:
			case ElementType.I4:
			case ElementType.U4:
			case ElementType.I8:
			case ElementType.U8:
			case ElementType.R4:
			case ElementType.R8:
			case ElementType.String:
			case ElementType.TypedByRef:
			case ElementType.I:
			case ElementType.U:
			case ElementType.R:
			case ElementType.Object:
			case ElementType.Internal:
			case ElementType.Sentinel:
			default:
				break;
			}
		}

		void Hash(MethodDef md) {
			if (md == null)
				return;

			var attrMask1 = MethodImplAttributes.CodeTypeMask | MethodImplAttributes.ManagedMask |
							MethodImplAttributes.ForwardRef | MethodImplAttributes.PreserveSig |
							MethodImplAttributes.InternalCall;
			hasher.Hash((ushort)(md == null ? 0 : md.ImplAttributes & attrMask1));
			var attrMask2 = MethodAttributes.Static | MethodAttributes.Virtual |
							MethodAttributes.HideBySig | MethodAttributes.VtableLayoutMask |
							MethodAttributes.CheckAccessOnOverride | MethodAttributes.Abstract |
							MethodAttributes.SpecialName | MethodAttributes.PinvokeImpl |
							MethodAttributes.UnmanagedExport | MethodAttributes.RTSpecialName;
			hasher.Hash((ushort)(md.Attributes & attrMask2));
			Hash(md.Signature);
			hasher.Hash(md.ParamDefs.Count);
			hasher.Hash(md.GenericParameters.Count);
			hasher.Hash(md.HasImplMap ? 1 : 0);

			var id = GetId(md);
			if (id != null)
				hasher.Hash(id.Value);
		}

		void Hash(MemberRef mr) {
			if (mr == null)
				return;

			Hash(mr.Class);
			if (IsFromNonObfuscatedAssembly(mr.Class))
				Hash(mr.Name);
			Hash(mr.Signature);
		}

		void Hash(TypeDef td) {
			if (td == null)
				return;

			Hash(td.BaseType);
			var attrMask = TypeAttributes.LayoutMask | TypeAttributes.ClassSemanticsMask |
							TypeAttributes.Abstract | TypeAttributes.SpecialName |
							TypeAttributes.Import | TypeAttributes.WindowsRuntime |
							TypeAttributes.StringFormatMask | TypeAttributes.RTSpecialName;
			hasher.Hash((uint)(td.Attributes & attrMask));
			hasher.Hash(td.GenericParameters.Count);
			hasher.Hash(td.Interfaces.Count);
			foreach (var iface in td.Interfaces)
				Hash(iface.Interface);
			var id = GetId(td);
			if (id != null)
				hasher.Hash(id.Value);
		}

		void Hash(TypeRef tr) {
			if (tr == null)
				return;

			Hash(tr.ResolutionScope);
			if (IsFromNonObfuscatedAssembly(tr)) {
				Hash(tr.Namespace);
				Hash(tr.Name);
			}
		}

		void Hash(TypeSpec ts) {
			if (ts == null)
				return;

			Hash(ts.TypeSig);
		}

		void Hash(FieldSig sig) {
			if (sig == null)
				return;

			hasher.Hash((byte)sig.GetCallingConvention());
			Hash(sig.GetFieldType());
		}

		void Hash(MethodSig sig) {
			if (sig == null)
				return;

			hasher.Hash((byte)sig.GetCallingConvention());
			Hash(sig.GetRetType());
			foreach (var p in sig.GetParams())
				Hash(p);
			hasher.Hash(sig.GetParamCount());
			if (sig.GetParamsAfterSentinel() != null) {
				foreach (var p in sig.GetParamsAfterSentinel())
					Hash(p);
			}
		}

		void Hash(GenericInstMethodSig sig) {
			if (sig == null)
				return;

			hasher.Hash((byte)sig.GetCallingConvention());
			foreach (var ga in sig.GetGenericArguments())
				Hash(ga);
		}

		void Hash(AssemblyRef asmRef) {
			if (asmRef == null)
				return;

			bool canWriteAsm = IsNonObfuscatedAssembly(asmRef);
			hasher.Hash(canWriteAsm ? 1 : 0);
			if (canWriteAsm) {
				bool hasPk = !PublicKeyBase.IsNullOrEmpty2(asmRef.PublicKeyOrToken);
				if (hasPk)
					hasher.Hash(PublicKeyBase.ToPublicKeyToken(asmRef.PublicKeyOrToken).Data);
				Hash(asmRef.Name);
				Hash(asmRef.Culture);
			}
		}

		void Hash(string s) {
			if (s != null)
				hasher.Hash(Encoding.UTF8.GetBytes(s));
		}

		BlockElementHash GetHash(int val) {
			hasher.Hash(val);
			return (BlockElementHash)hasher.GetHash();
		}

		BlockElementHash GetHash(string s) {
			Hash(s);
			return (BlockElementHash)hasher.GetHash();
		}

		static bool IsFromNonObfuscatedAssembly(IMemberRefParent mrp) => IsFromNonObfuscatedAssembly(mrp as TypeRef);

		static bool IsFromNonObfuscatedAssembly(TypeRef tr) {
			if (tr == null)
				return false;

			for (int i = 0; i < 100; i++) {
				if (tr.ResolutionScope is AssemblyRef asmRef)
					return IsNonObfuscatedAssembly(asmRef);

				if (tr.ResolutionScope is TypeRef tr2) {
					tr = tr2;
					continue;
				}

				break;
			}

			return false;
		}

		static bool IsNonObfuscatedAssembly(IAssembly asm) {
			if (asm == null)
				return false;

			// The only external asm refs it uses...
			if (asm.Name != "mscorlib" && asm.Name != "System")
				return false;

			return true;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Agile_NET/vm/v2/VmOpCode.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;

namespace de4dot.code.deobfuscators.Agile_NET.vm.v2 {
	class VmOpCode {
		public List<HandlerTypeCode> HandlerTypeCodes { get; private set; }

		public VmOpCode(List<HandlerTypeCode> opCodeHandlerInfos) {
			HandlerTypeCodes = new List<HandlerTypeCode>(opCodeHandlerInfos.Count);
			HandlerTypeCodes.AddRange(opCodeHandlerInfos);
		}

		public override string ToString() => OpCodeHandlerInfo.GetCompositeName(HandlerTypeCodes);
	}
}



================================================
File: de4dot.code/deobfuscators/Agile_NET/vm/v2/VmOpCodeHandlerDetector.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;
using de4dot.blocks.cflow;

namespace de4dot.code.deobfuscators.Agile_NET.vm.v2 {
	class MyDeobfuscator {
		CliSecureRtType cliSecureRtType;
		StringDecrypter stringDecrypter;
		StaticStringInliner staticStringInliner = new StaticStringInliner();

		public MyDeobfuscator(ModuleDefMD module) {
			cliSecureRtType = new CliSecureRtType(module);
			cliSecureRtType.Find(null);
			stringDecrypter = new StringDecrypter(module, cliSecureRtType.StringDecrypterInfos);
			stringDecrypter.Find();
			cliSecureRtType.FindStringDecrypterMethod();
			stringDecrypter.AddDecrypterInfos(cliSecureRtType.StringDecrypterInfos);
			stringDecrypter.Initialize();
			foreach (var info in stringDecrypter.StringDecrypterInfos)
				staticStringInliner.Add(info.Method, (method, gim, args) => stringDecrypter.Decrypt((string)args[0]));
		}

		void RestoreMethod(Blocks blocks) {
			blocks.GetCode(out var allInstructions, out var allExceptionHandlers);
			DotNetUtils.RestoreBody(blocks.Method, allInstructions, allExceptionHandlers);
		}

		public void DecryptStrings(MethodDef method) {
			var blocks = new Blocks(method);
			DecryptStrings(blocks);
			RestoreMethod(blocks);
		}

		public void DecryptStrings(Blocks blocks) => staticStringInliner.Decrypt(blocks);
		public void Deobfuscate(MethodDef method) => DecryptStrings(method);
	}

	class VmOpCodeHandlerDetector {
		const int NUM_HANDLERS = 78;
		ModuleDefMD module;
		List<VmOpCode> vmOpCodes;
		MyDeobfuscator deobfuscator;

		public IList<VmOpCode> Handlers => vmOpCodes;
		public VmOpCodeHandlerDetector(ModuleDefMD module) => this.module = module;

		public void FindHandlers() {
			if (vmOpCodes != null)
				return;

			deobfuscator = new MyDeobfuscator(module);
			var csvmInfo = new CsvmInfo(module);
			csvmInfo.Initialize();
			var vmHandlerTypes = FindVmHandlerTypes();
			if (vmHandlerTypes == null)
				throw new ApplicationException("Could not find CSVM opcode handler types");

			var composites = CreateCompositeOpCodeHandlers(csvmInfo, vmHandlerTypes);
			foreach (var handlerInfos in OpCodeHandlerInfos.HandlerInfos) {
				if (!DetectCompositeHandlers(composites, handlerInfos))
					continue;

				vmOpCodes = CreateVmOpCodes(composites);
				break;
			}
			if (vmOpCodes == null)
				throw new ApplicationException("Could not find any/all CSVM handlers");
		}

		static List<VmOpCode> CreateVmOpCodes(IList<CompositeOpCodeHandler> composites) {
			var list = new List<VmOpCode>(composites.Count);
			foreach (var composite in composites)
				list.Add(new VmOpCode(composite.TypeCodes));
			return list;
		}

		bool DetectCompositeHandlers(IEnumerable<CompositeOpCodeHandler> composites, IList<MethodSigInfo> handlerInfos) {
			var detector = new CompositeHandlerDetector(handlerInfos);
			foreach (var composite in composites) {
				if (!detector.FindHandlers(composite))
					return false;
			}
			return true;
		}

		static MethodDef SimplifyInstructions(MethodDef method) {
			if (method.Body == null)
				return method;
			method.Body.SimplifyMacros(method.Parameters);
			return method;
		}

		List<CompositeOpCodeHandler> CreateCompositeOpCodeHandlers(CsvmInfo csvmInfo, List<TypeDef> handlers) {
			var list = new List<CompositeOpCodeHandler>(handlers.Count);

			var sigCreator = CreateSigCreator(csvmInfo);
			foreach (var handler in handlers)
				list.Add(new CompositeOpCodeHandler(sigCreator.Create(GetExecMethod(handler))));

			return list;
		}

		MethodDef GetExecMethod(TypeDef type) => GetExecMethod(deobfuscator, type);

		static MethodDef GetExecMethod(MyDeobfuscator deobfuscator, TypeDef type) {
			GetReadAndExecMethods(type, out var readMethod, out var execMethod);
			deobfuscator.Deobfuscate(execMethod);
			SimplifyInstructions(execMethod);
			return execMethod;
		}

		static SigCreator CreateSigCreator(CsvmInfo csvmInfo) {
			var creator = new SigCreator();

			creator.AddId(csvmInfo.LogicalOpShrUn, 1);
			creator.AddId(csvmInfo.LogicalOpShl, 2);
			creator.AddId(csvmInfo.LogicalOpShr, 3);
			creator.AddId(csvmInfo.LogicalOpAnd, 4);
			creator.AddId(csvmInfo.LogicalOpXor, 5);
			creator.AddId(csvmInfo.LogicalOpOr, 6);

			creator.AddId(csvmInfo.CompareLt, 7);
			creator.AddId(csvmInfo.CompareLte, 8);
			creator.AddId(csvmInfo.CompareGt, 9);
			creator.AddId(csvmInfo.CompareGte, 10);
			creator.AddId(csvmInfo.CompareEq, 11);
			creator.AddId(csvmInfo.CompareEqz, 12);

			creator.AddId(csvmInfo.ArithmeticSubOvfUn, 13);
			creator.AddId(csvmInfo.ArithmeticMulOvfUn, 14);
			creator.AddId(csvmInfo.ArithmeticRemUn, 15);
			creator.AddId(csvmInfo.ArithmeticRem, 16);
			creator.AddId(csvmInfo.ArithmeticDivUn, 17);
			creator.AddId(csvmInfo.ArithmeticDiv, 18);
			creator.AddId(csvmInfo.ArithmeticMul, 19);
			creator.AddId(csvmInfo.ArithmeticMulOvf, 20);
			creator.AddId(csvmInfo.ArithmeticSub, 21);
			creator.AddId(csvmInfo.ArithmeticSubOvf, 22);
			creator.AddId(csvmInfo.ArithmeticAddOvfUn, 23);
			creator.AddId(csvmInfo.ArithmeticAddOvf, 24);
			creator.AddId(csvmInfo.ArithmeticAdd, 25);

			creator.AddId(csvmInfo.UnaryNot, 26);
			creator.AddId(csvmInfo.UnaryNeg, 27);

			creator.AddId(csvmInfo.ArgsGet, 28);
			creator.AddId(csvmInfo.ArgsSet, 29);
			creator.AddId(csvmInfo.LocalsGet, 30);
			creator.AddId(csvmInfo.LocalsSet, 31);

			AddTypeId(creator, csvmInfo.LogicalOpShrUn, 32);
			AddTypeId(creator, csvmInfo.CompareLt, 33);
			AddTypeId(creator, csvmInfo.ArithmeticSubOvfUn, 34);
			AddTypeId(creator, csvmInfo.UnaryNot, 35);
			AddTypeId(creator, csvmInfo.ArgsGet, 36);

			return creator;
		}

		static void AddTypeId(SigCreator creator, MethodDef method, int id) {
			if (method != null)
				creator.AddId(method.DeclaringType, id);
		}

		static void GetReadAndExecMethods(TypeDef handler, out MethodDef readMethod, out MethodDef execMethod) {
			readMethod = execMethod = null;
			foreach (var method in handler.Methods) {
				if (!method.IsVirtual)
					continue;
				if (DotNetUtils.IsMethod(method, "System.Void", "(System.IO.BinaryReader)")) {
					if (readMethod != null)
						throw new ApplicationException("Found another read method");
					readMethod = method;
				}
				else if (!DotNetUtils.HasReturnValue(method) && method.MethodSig.GetParamCount() == 1) {
					if (execMethod != null)
						throw new ApplicationException("Found another execute method");
					execMethod = method;
				}
			}

			if (readMethod == null)
				throw new ApplicationException("Could not find read method");
			if (execMethod == null)
				throw new ApplicationException("Could not find execute method");
		}

		IEnumerable<TypeDef> GetVmHandlerTypes(TypeDef baseType) {
			foreach (var type in module.Types) {
				if (type.BaseType == baseType)
					yield return type;
			}
		}

		List<TypeDef> FindBasicVmHandlerTypes(CsvmInfo csvmInfo) {
			var list = new List<TypeDef>();
			if (csvmInfo.VmHandlerBaseType == null)
				return list;
			foreach (var type in module.Types) {
				if (list.Count == NUM_HANDLERS)
					break;
				if (type.BaseType == csvmInfo.VmHandlerBaseType)
					list.Add(type);
			}
			return list;
		}

		List<TypeDef> FindVmHandlerTypes() {
			var requiredFields = new string[] {
				null,
				"System.Collections.Generic.Dictionary`2<System.UInt16,System.Type>",
				"System.UInt16",
			};
			var cflowDeobfuscator = new CflowDeobfuscator();
			foreach (var type in module.Types) {
				var cctor = type.FindStaticConstructor();
				if (cctor == null)
					continue;
				requiredFields[0] = type.FullName;
				var fieldTypes = new FieldTypes(type);
				if (!fieldTypes.All(requiredFields))
					continue;

				cflowDeobfuscator.Deobfuscate(cctor);
				var handlers = FindVmHandlerTypes(cctor);

				return handlers;
			}

			return null;
		}

		static List<TypeDef> FindVmHandlerTypes(MethodDef method) {
			var list = new List<TypeDef>();

			foreach (var instr in method.Body.Instructions) {
				if (instr.OpCode.Code != Code.Ldtoken)
					continue;
				var type = instr.Operand as TypeDef;
				if (type == null)
					continue;

				list.Add(type);
			}

			return list;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Babel_NET/AssemblyResolver.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.IO;
using dnlib.DotNet;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Babel_NET {
	class AssemblyResolver {
		ModuleDefMD module;
		ResourceDecrypter resourceDecrypter;
		TypeDef resolverType;
		MethodDef registerMethod;
		EmbeddedResource encryptedResource;
		EmbeddedAssemblyInfo[] embeddedAssemblyInfos = new EmbeddedAssemblyInfo[0];

		public class EmbeddedAssemblyInfo {
			public string fullname;
			public string extension;
			public byte[] data;

			public EmbeddedAssemblyInfo(string fullName, string extension, byte[] data) {
				fullname = fullName;
				this.extension = extension;
				this.data = data;
			}
		}

		public bool Detected => resolverType != null;
		public TypeDef Type => resolverType;
		public MethodDef InitMethod => registerMethod;
		public EmbeddedResource EncryptedResource => encryptedResource;
		public EmbeddedAssemblyInfo[] EmbeddedAssemblyInfos => embeddedAssemblyInfos;

		public AssemblyResolver(ModuleDefMD module, ResourceDecrypter resourceDecrypter) {
			this.module = module;
			this.resourceDecrypter = resourceDecrypter;
		}

		public void Find() {
			var requiredTypes = new string[] {
				"System.Object",
				"System.Int32",
				"System.Collections.Hashtable",
			};
			foreach (var type in module.Types) {
				if (type.HasEvents)
					continue;
				if (!new FieldTypes(type).Exactly(requiredTypes))
					continue;

				if (!BabelUtils.FindRegisterMethod(type, out var regMethod, out var handler))
					continue;

				var decryptMethod = FindDecryptMethod(type);
				if (decryptMethod == null)
					throw new ApplicationException("Couldn't find resource type decrypt method");
				resourceDecrypter.DecryptMethod = ResourceDecrypter.FindDecrypterMethod(decryptMethod);

				resolverType = type;
				registerMethod = regMethod;
				return;
			}
		}

		static MethodDef FindDecryptMethod(TypeDef type) {
			foreach (var method in type.Methods) {
				if (!DotNetUtils.IsMethod(method, "System.Void", "(System.IO.Stream)"))
					continue;
				return method;
			}
			return null;
		}

		public void Initialize(ISimpleDeobfuscator simpleDeobfuscator, IDeobfuscator deob) {
			if (resolverType == null)
				return;

			encryptedResource = BabelUtils.FindEmbeddedResource(module, resolverType, simpleDeobfuscator, deob);
			if (encryptedResource == null) {
				Logger.w("Could not find embedded assemblies resource");
				return;
			}

			var decrypted = resourceDecrypter.Decrypt(encryptedResource.CreateReader().ToArray());
			var reader = new BinaryReader(new MemoryStream(decrypted));
			int numAssemblies = reader.ReadInt32();
			embeddedAssemblyInfos = new EmbeddedAssemblyInfo[numAssemblies];
			for (int i = 0; i < numAssemblies; i++) {
				string name = reader.ReadString();
				var data = reader.ReadBytes(reader.ReadInt32());
				var mod = ModuleDefMD.Load(data);
				embeddedAssemblyInfos[i] = new EmbeddedAssemblyInfo(name, DeobUtils.GetExtension(mod.Kind), data);
			}
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Babel_NET/BabelInflater.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using ICSharpCode.SharpZipLib;
using ICSharpCode.SharpZipLib.Zip.Compression;

namespace de4dot.code.deobfuscators.Babel_NET {
	class BabelInflater : Inflater {
		int magic;

		public BabelInflater(bool noHeader, int magic) : base(noHeader) => this.magic = magic;

		protected override bool ReadHeader(ref bool isLastBlock, out int blockType) {
			const int numBits = 4;

			int type = input.PeekBits(numBits);
			if (type < 0) {
				blockType = -1;
				return false;
			}
			input.DropBits(numBits);

			if ((type & 1) != 0)
				isLastBlock = true;
			switch (type >> 1) {
			case 1: blockType = STORED_BLOCK; break;
			case 5: blockType = STATIC_TREES; break;
			case 6: blockType = DYN_TREES; break;
			default: throw new SharpZipBaseException("Unknown block type: " + type);
			}
			return true;
		}

		protected override bool DecodeStoredLength() {
			if ((uncomprLen = input.PeekBits(16)) < 0)
				return false;
			input.DropBits(16);

			uncomprLen ^= magic;

			return true;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Babel_NET/BabelMethodCallInliner.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;
using de4dot.blocks.cflow;

namespace de4dot.code.deobfuscators.Babel_NET {
	class BabelMethodCallInliner : MethodCallInlinerBase, IBranchHandler {
		InstructionEmulator emulator;
		BranchEmulator branchEmulator;
		int emulateIndex;
		IList<Instruction> instructions;

		public BabelMethodCallInliner() {
			emulator = new InstructionEmulator();
			branchEmulator = new BranchEmulator(emulator, this);
		}

		public static List<MethodDef> Find(ModuleDefMD module, IEnumerable<MethodDef> notInlinedMethods) {
			var notInlinedMethodsDict = new Dictionary<MethodDef, bool>();
			foreach (var method in notInlinedMethods)
				notInlinedMethodsDict[method] = true;

			var inlinedMethods = new List<MethodDef>();

			foreach (var type in module.GetTypes()) {
				foreach (var method in type.Methods) {
					if (!notInlinedMethodsDict.ContainsKey(method) && CanInline(method))
						inlinedMethods.Add(method);
				}
			}

			return inlinedMethods;
		}

		void IBranchHandler.HandleNormal(int stackArgs, bool isTaken) {
			if (!isTaken)
				emulateIndex++;
			else
				emulateIndex = instructions.IndexOf((Instruction)instructions[emulateIndex].Operand);
		}

		bool IBranchHandler.HandleSwitch(Int32Value switchIndex) {
			if (!switchIndex.AllBitsValid())
				return false;
			var instr = instructions[emulateIndex];
			var targets = (Instruction[])instr.Operand;
			if (switchIndex.Value >= 0 && switchIndex.Value < targets.Length)
				emulateIndex = instructions.IndexOf(targets[switchIndex.Value]);
			else
				emulateIndex++;
			return true;
		}

		protected override bool DeobfuscateInternal() {
			bool modified = false;
			var instructions = block.Instructions;
			for (int i = 0; i < instructions.Count; i++) {
				var instr = instructions[i].Instruction;
				if (instr.OpCode.Code == Code.Call)
					modified |= InlineMethod(instr, i);
			}
			instructions = null;
			return modified;
		}

		static bool CanInline(MethodDef method) {
			if (!DotNetUtils.IsMethod(method, "System.Int32", "(System.Int32)"))
				return false;
			if (!method.IsAssembly)
				return false;
			if (method.MethodSig.GetGenParamCount() > 0)
				return false;

			return method.IsStatic;
		}

		bool CanInline2(MethodDef method) => CanInline(method) && method != blocks.Method;

		bool InlineMethod(Instruction callInstr, int instrIndex) {
			var methodToInline = callInstr.Operand as MethodDef;
			if (methodToInline == null)
				return false;

			if (!CanInline2(methodToInline))
				return false;
			var body = methodToInline.Body;
			if (body == null)
				return false;

			if (instrIndex == 0)
				return false;

			var ldci4 = block.Instructions[instrIndex - 1];
			if (!ldci4.IsLdcI4())
				return false;
			if (!GetNewValue(methodToInline, ldci4.GetLdcI4Value(), out int newValue))
				return false;

			block.Instructions[instrIndex - 1] = new Instr(OpCodes.Nop.ToInstruction());
			block.Instructions[instrIndex] = new Instr(Instruction.CreateLdcI4(newValue));
			return true;
		}

		bool GetNewValue(MethodDef method, int arg, out int newValue) {
			newValue = 0;
			emulator.Initialize(method);
			emulator.SetArg(method.Parameters[0], new Int32Value(arg));

			Instruction instr;
			emulateIndex = 0;
			instructions = method.Body.Instructions;
			int counter = 0;
			while (true) {
				if (counter++ >= 50)
					return false;
				if (emulateIndex < 0 || emulateIndex >= instructions.Count)
					return false;
				instr = instructions[emulateIndex];
				switch (instr.OpCode.Code) {
				case Code.Ldarg:
				case Code.Ldarg_S:
				case Code.Ldarg_0:
				case Code.Ldarg_1:
				case Code.Ldarg_2:
				case Code.Ldarg_3:
				case Code.Stloc:
				case Code.Stloc_S:
				case Code.Stloc_0:
				case Code.Stloc_1:
				case Code.Stloc_2:
				case Code.Stloc_3:
				case Code.Ldloc:
				case Code.Ldloc_S:
				case Code.Ldloc_0:
				case Code.Ldloc_1:
				case Code.Ldloc_2:
				case Code.Ldloc_3:
				case Code.Ldc_I4:
				case Code.Ldc_I4_0:
				case Code.Ldc_I4_1:
				case Code.Ldc_I4_2:
				case Code.Ldc_I4_3:
				case Code.Ldc_I4_4:
				case Code.Ldc_I4_5:
				case Code.Ldc_I4_6:
				case Code.Ldc_I4_7:
				case Code.Ldc_I4_8:
				case Code.Ldc_I4_M1:
				case Code.Ldc_I4_S:
				case Code.Add:
				case Code.Sub:
				case Code.Xor:
				case Code.Or:
				case Code.Nop:
				case Code.Dup:
				case Code.Mul:
				case Code.Rem:
				case Code.Div:
					emulator.Emulate(instr);
					emulateIndex++;
					break;

				case Code.Br:
				case Code.Br_S:
				case Code.Beq:
				case Code.Beq_S:
				case Code.Bge:
				case Code.Bge_S:
				case Code.Bge_Un:
				case Code.Bge_Un_S:
				case Code.Bgt:
				case Code.Bgt_S:
				case Code.Bgt_Un:
				case Code.Bgt_Un_S:
				case Code.Ble:
				case Code.Ble_S:
				case Code.Ble_Un:
				case Code.Ble_Un_S:
				case Code.Blt:
				case Code.Blt_S:
				case Code.Blt_Un:
				case Code.Blt_Un_S:
				case Code.Bne_Un:
				case Code.Bne_Un_S:
				case Code.Brfalse:
				case Code.Brfalse_S:
				case Code.Brtrue:
				case Code.Brtrue_S:
				case Code.Switch:
					if (!branchEmulator.Emulate(instr))
						return false;
					break;

				case Code.Ret:
					var retValue = emulator.Pop();
					if (!retValue.IsInt32())
						return false;
					var retValue2 = (Int32Value)retValue;
					if (!retValue2.AllBitsValid())
						return false;
					newValue = retValue2.Value;
					return true;

				default:
					if (instr.OpCode.OpCodeType != OpCodeType.Prefix)
						return false;
					emulateIndex++;
					break;
				}
			}
		}

		protected override bool IsCompatibleType(int paramIndex, IType origType, IType newType) {
			if (new SigComparer(SigComparerOptions.IgnoreModifiers).Equals(origType, newType))
				return true;
			if (IsValueType(newType) || IsValueType(origType))
				return false;
			return newType.FullName == "System.Object";
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Babel_NET/BabelUtils.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using System.Text;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;
using System;

namespace de4dot.code.deobfuscators.Babel_NET {
	static class BabelUtils {
		public static EmbeddedResource FindEmbeddedResource(ModuleDefMD module, TypeDef decrypterType) =>
			FindEmbeddedResource(module, decrypterType, (method) => { });

		public static EmbeddedResource FindEmbeddedResource(ModuleDefMD module, TypeDef decrypterType, ISimpleDeobfuscator simpleDeobfuscator, IDeobfuscator deob) =>
			FindEmbeddedResource(module, decrypterType, (method) => {
				simpleDeobfuscator.Deobfuscate(method);
				simpleDeobfuscator.DecryptStrings(method, deob);
			});

		public static EmbeddedResource FindEmbeddedResource(ModuleDefMD module, TypeDef decrypterType, Action<MethodDef> fixMethod) {
			foreach (var method in decrypterType.Methods) {
				if (!DotNetUtils.IsMethod(method, "System.String", "()"))
					continue;
				if (!method.IsStatic)
					continue;
				fixMethod(method);
				var resource = FindEmbeddedResource1(module, method) ?? FindEmbeddedResource2(module, method);
				if (resource != null)
					return resource;
			}
			return null;
		}

		static EmbeddedResource FindEmbeddedResource1(ModuleDefMD module, MethodDef method) {
			foreach (var s in DotNetUtils.GetCodeStrings(method)) {
				if (DotNetUtils.GetResource(module, s) is EmbeddedResource resource)
					return resource;
			}
			return null;
		}

		static EmbeddedResource FindEmbeddedResource2(ModuleDefMD module, MethodDef method) {
			var strings = new List<string>(DotNetUtils.GetCodeStrings(method));
			if (strings.Count != 1)
				return null;
			var encryptedString = strings[0];

			if (!GetXorKey2(method, out int xorKey))
				return null;

			var sb = new StringBuilder(encryptedString.Length);
			foreach (var c in encryptedString)
				sb.Append((char)(c ^ xorKey));
			return DotNetUtils.GetResource(module, sb.ToString()) as EmbeddedResource;
		}

		static bool GetXorKey2(MethodDef method, out int xorKey) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 2; i++) {
				var ldelem = instrs[i];
				if (ldelem.OpCode.Code != Code.Ldelem_U2)
					continue;

				var ldci4 = instrs[i + 1];
				if (!ldci4.IsLdcI4())
					continue;

				if (instrs[i + 2].OpCode.Code != Code.Xor)
					continue;

				xorKey = ldci4.GetLdcI4Value();
				return true;
			}

			xorKey = 0;
			return false;
		}

		public static bool FindRegisterMethod(TypeDef type, out MethodDef regMethod, out MethodDef handler) {
			foreach (var method in type.Methods) {
				if (!method.IsStatic || method.Body == null)
					continue;
				if (method.Body.ExceptionHandlers.Count != 1)
					continue;

				foreach (var instr in method.Body.Instructions) {
					if (instr.OpCode.Code != Code.Ldftn)
						continue;
					var handlerRef = instr.Operand as IMethod;
					if (handlerRef == null)
						continue;
					if (!DotNetUtils.IsMethod(handlerRef, "System.Reflection.Assembly", "(System.Object,System.ResolveEventArgs)"))
						continue;
					if (!new SigComparer().Equals(type, handlerRef.DeclaringType))
						continue;
					handler = DotNetUtils.GetMethod(type, handlerRef);
					if (handler == null)
						continue;
					if (handler.Body == null || handler.Body.ExceptionHandlers.Count != 1)
						continue;

					regMethod = method;
					return true;
				}
			}

			regMethod = null;
			handler = null;
			return false;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Babel_NET/ConstantsDecrypter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.Serialization.Formatters.Binary;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Babel_NET {
	class ConstantsDecrypter {
		ModuleDefMD module;
		ResourceDecrypter resourceDecrypter;
		InitializedDataCreator initializedDataCreator;
		TypeDef decrypterType;
		MethodDef int32Decrypter;
		MethodDef int64Decrypter;
		MethodDef singleDecrypter;
		MethodDef doubleDecrypter;
		MethodDef arrayDecrypter;
		EmbeddedResource encryptedResource;
		int[] decryptedInts;
		long[] decryptedLongs;
		float[] decryptedFloats;
		double[] decryptedDoubles;

		public bool Detected => decrypterType != null;
		public bool CanDecrypt => encryptedResource != null;
		public Resource Resource => encryptedResource;
		public TypeDef Type => decrypterType;
		public MethodDef Int32Decrypter => int32Decrypter;
		public MethodDef Int64Decrypter => int64Decrypter;
		public MethodDef SingleDecrypter => singleDecrypter;
		public MethodDef DoubleDecrypter => doubleDecrypter;
		public MethodDef ArrayDecrypter => arrayDecrypter;

		public ConstantsDecrypter(ModuleDefMD module, ResourceDecrypter resourceDecrypter, InitializedDataCreator initializedDataCreator) {
			this.module = module;
			this.resourceDecrypter = resourceDecrypter;
			this.initializedDataCreator = initializedDataCreator;
		}

		public void Find() {
			foreach (var type in module.Types) {
				if (!IsConstantDecrypter(type))
					continue;

				int32Decrypter = DotNetUtils.GetMethod(type, "System.Int32", "(System.Int32)");
				int64Decrypter = DotNetUtils.GetMethod(type, "System.Int64", "(System.Int32)");
				singleDecrypter = DotNetUtils.GetMethod(type, "System.Single", "(System.Int32)");
				doubleDecrypter = DotNetUtils.GetMethod(type, "System.Double", "(System.Int32)");
				arrayDecrypter = DotNetUtils.GetMethod(type, "System.Array", "(System.Byte[])");
				decrypterType = type;
				return;
			}
		}

		bool IsConstantDecrypter(TypeDef type) {
			if (type.HasEvents)
				return false;
			if (type.NestedTypes.Count != 1)
				return false;

			var nested = type.NestedTypes[0];
			if (!CheckNestedFields(nested))
				return false;

			resourceDecrypter.DecryptMethod = ResourceDecrypter.FindDecrypterMethod(nested.FindMethod(".ctor"));

			if (DotNetUtils.GetMethod(type, "System.Int32", "(System.Int32)") == null)
				return false;
			if (DotNetUtils.GetMethod(type, "System.Int64", "(System.Int32)") == null)
				return false;
			if (DotNetUtils.GetMethod(type, "System.Single", "(System.Int32)") == null)
				return false;
			if (DotNetUtils.GetMethod(type, "System.Double", "(System.Int32)") == null)
				return false;
			if (DotNetUtils.GetMethod(type, "System.Array", "(System.Byte[])") == null)
				return false;

			return true;
		}

		static string[] requiredTypes = new string[] {
			"System.Int32[]",
			"System.Int64[]",
			"System.Single[]",
			"System.Double[]",
		};
		bool CheckNestedFields(TypeDef nested) {
			if (!new FieldTypes(nested).All(requiredTypes))
				return false;
			foreach (var field in nested.Fields) {
				if (new SigComparer().Equals(nested, field.FieldSig.GetFieldType()))
					return true;
			}
			return false;
		}

		public void Initialize(ISimpleDeobfuscator simpleDeobfuscator, IDeobfuscator deob) {
			if (decrypterType == null)
				return;

			encryptedResource = BabelUtils.FindEmbeddedResource(module, decrypterType, simpleDeobfuscator, deob);
			if (encryptedResource == null) {
				Logger.w("Could not find encrypted constants resource");
				return;
			}

			var decrypted = resourceDecrypter.Decrypt(encryptedResource.CreateReader().ToArray());
			var reader = new BinaryReader(new MemoryStream(decrypted));
			int count;

			count = reader.ReadInt32();
			decryptedInts = new int[count];
			while (count-- > 0)
				decryptedInts[count] = reader.ReadInt32();

			count = reader.ReadInt32();
			decryptedLongs = new long[count];
			while (count-- > 0)
				decryptedLongs[count] = reader.ReadInt64();

			count = reader.ReadInt32();
			decryptedFloats = new float[count];
			while (count-- > 0)
				decryptedFloats[count] = reader.ReadSingle();

			count = reader.ReadInt32();
			decryptedDoubles = new double[count];
			while (count-- > 0)
				decryptedDoubles[count] = reader.ReadDouble();
		}

		public int DecryptInt32(int index) => decryptedInts[index];
		public long DecryptInt64(int index) => decryptedLongs[index];
		public float DecryptSingle(int index) => decryptedFloats[index];
		public double DecryptDouble(int index) => decryptedDoubles[index];

		struct ArrayInfo {
			public FieldDef encryptedField;
			public SZArraySig arrayType;
			public int start, len;

			public ArrayInfo(int start, int len, FieldDef encryptedField, SZArraySig arrayType) {
				this.start = start;
				this.len = len;
				this.encryptedField = encryptedField;
				this.arrayType = arrayType;
			}
		}

		public void Deobfuscate(Blocks blocks) {
			if (arrayDecrypter == null)
				return;

			var infos = new List<ArrayInfo>();
			foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {
				var instrs = block.Instructions;
				infos.Clear();
				for (int i = 0; i < instrs.Count - 6; i++) {
					int index = i;

					var ldci4 = instrs[index++];
					if (!ldci4.IsLdcI4())
						continue;

					var newarr = instrs[index++];
					if (newarr.OpCode.Code != Code.Newarr)
						continue;
					if (newarr.Operand == null || newarr.Operand.ToString() != "System.Byte")
						continue;

					if (instrs[index++].OpCode.Code != Code.Dup)
						continue;

					var ldtoken = instrs[index++];
					if (ldtoken.OpCode.Code != Code.Ldtoken)
						continue;
					var field = ldtoken.Operand as FieldDef;
					if (field == null)
						continue;

					var call1 = instrs[index++];
					if (call1.OpCode.Code != Code.Call && call1.OpCode.Code != Code.Callvirt)
						continue;
					if (!DotNetUtils.IsMethod(call1.Operand as IMethod, "System.Void", "(System.Array,System.RuntimeFieldHandle)"))
						continue;

					var call2 = instrs[index++];
					if (call2.OpCode.Code != Code.Call && call2.OpCode.Code != Code.Callvirt)
						continue;
					if (!MethodEqualityComparer.CompareDeclaringTypes.Equals(call2.Operand as IMethod, arrayDecrypter))
						continue;

					var castclass = instrs[index++];
					if (castclass.OpCode.Code != Code.Castclass)
						continue;
					var arrayType = (castclass.Operand as ITypeDefOrRef).TryGetSZArraySig();
					if (arrayType == null)
						continue;
					if (arrayType.Next.ElementType.GetPrimitiveSize() == -1) {
						Logger.w("Can't decrypt non-primitive type array in method {0:X8}", blocks.Method.MDToken.ToInt32());
						continue;
					}

					infos.Add(new ArrayInfo(i, index - i, field, arrayType));
				}

				infos.Reverse();
				foreach (var info in infos) {
					var elemSize = info.arrayType.Next.ElementType.GetPrimitiveSize();
					var decrypted = DecryptArray(info.encryptedField.InitialValue, elemSize);

					initializedDataCreator.AddInitializeArrayCode(block, info.start, info.len, info.arrayType.Next.ToTypeDefOrRef(), decrypted);
					Logger.v("Decrypted {0} array: {1} elements", info.arrayType.Next.ToString(), decrypted.Length / elemSize);
				}
			}
		}

		byte[] DecryptArray(byte[] encryptedData, int elemSize) {
			var decrypted = resourceDecrypter.Decrypt(encryptedData);
			var ary = (Array)new BinaryFormatter().Deserialize(new MemoryStream(decrypted));
			if (ary is byte[])
				return (byte[])ary;
			var newAry = new byte[ary.Length * elemSize];
			Buffer.BlockCopy(ary, 0, newAry, 0, newAry.Length);
			return newAry;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Babel_NET/Deobfuscator.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using System.Text.RegularExpressions;
using dnlib.DotNet;
using de4dot.blocks;
using de4dot.blocks.cflow;

namespace de4dot.code.deobfuscators.Babel_NET {
	public class DeobfuscatorInfo : DeobfuscatorInfoBase {
		public const string THE_NAME = "Babel .NET";
		public const string THE_TYPE = "bl";
		const string DEFAULT_REGEX = DeobfuscatorBase.DEFAULT_ASIAN_VALID_NAME_REGEX;
		BoolOption inlineMethods;
		BoolOption removeInlinedMethods;
		BoolOption decryptMethods;
		BoolOption decryptResources;
		BoolOption decryptConstants;
		BoolOption dumpEmbeddedAssemblies;

		public DeobfuscatorInfo()
			: base(DEFAULT_REGEX) {
			inlineMethods = new BoolOption(null, MakeArgName("inline"), "Inline short methods", true);
			removeInlinedMethods = new BoolOption(null, MakeArgName("remove-inlined"), "Remove inlined methods", true);
			decryptMethods = new BoolOption(null, MakeArgName("methods"), "Decrypt methods", true);
			decryptResources = new BoolOption(null, MakeArgName("rsrc"), "Decrypt resources", true);
			decryptConstants = new BoolOption(null, MakeArgName("consts"), "Decrypt constants and arrays", true);
			dumpEmbeddedAssemblies = new BoolOption(null, MakeArgName("embedded"), "Dump embedded assemblies", true);
		}

		public override string Name => THE_NAME;
		public override string Type => THE_TYPE;

		public override IDeobfuscator CreateDeobfuscator() =>
			new Deobfuscator(new Deobfuscator.Options {
				ValidNameRegex = validNameRegex.Get(),
				InlineMethods = inlineMethods.Get(),
				RemoveInlinedMethods = removeInlinedMethods.Get(),
				DecryptMethods = decryptMethods.Get(),
				DecryptResources = decryptResources.Get(),
				DecryptConstants = decryptConstants.Get(),
				DumpEmbeddedAssemblies = dumpEmbeddedAssemblies.Get(),
			});

		protected override IEnumerable<Option> GetOptionsInternal() =>
			new List<Option>() {
				inlineMethods,
				removeInlinedMethods,
				decryptMethods,
				decryptResources,
				decryptConstants,
				dumpEmbeddedAssemblies,
			};
	}

	class Deobfuscator : DeobfuscatorBase {
		Options options;
		bool foundBabelAttribute = false;
		string obfuscatorName = DeobfuscatorInfo.THE_NAME;
		bool startedDeobfuscating = false;

		ResourceResolver resourceResolver;
		AssemblyResolver assemblyResolver;
		StringDecrypter stringDecrypter;
		ConstantsDecrypter constantsDecrypter;
		Int32ValueInliner int32ValueInliner;
		Int64ValueInliner int64ValueInliner;
		SingleValueInliner singleValueInliner;
		DoubleValueInliner doubleValueInliner;
		ProxyCallFixer proxyCallFixer;
		MethodsDecrypter methodsDecrypter;

		internal class Options : OptionsBase {
			public bool InlineMethods { get; set; }
			public bool RemoveInlinedMethods { get; set; }
			public bool DecryptMethods { get; set; }
			public bool DecryptResources { get; set; }
			public bool DecryptConstants { get; set; }
			public bool DumpEmbeddedAssemblies { get; set; }
		}

		public override string Type => DeobfuscatorInfo.THE_TYPE;
		public override string TypeLong => DeobfuscatorInfo.THE_NAME;
		public override string Name => obfuscatorName;
		protected override bool CanInlineMethods => startedDeobfuscating ? options.InlineMethods : true;

		public override IEnumerable<IBlocksDeobfuscator> BlocksDeobfuscators {
			get {
				var list = new List<IBlocksDeobfuscator>();
				if (CanInlineMethods)
					list.Add(new BabelMethodCallInliner());
				return list;
			}
		}

		public Deobfuscator(Options options) : base(options) => this.options = options;
		public override void Initialize(ModuleDefMD module) => base.Initialize(module);

		protected override int DetectInternal() {
			int val = 0;

			int sum = ToInt32(resourceResolver.Detected) +
					ToInt32(assemblyResolver.Detected) +
					ToInt32(stringDecrypter.Detected) +
					ToInt32(constantsDecrypter.Detected) +
					ToInt32(proxyCallFixer.Detected) +
					ToInt32(methodsDecrypter.Detected) +
					ToInt32(HasMetadataStream("Babel"));
			if (sum > 0)
				val += 100 + 10 * (sum - 1);
			if (foundBabelAttribute)
				val += 10;

			return val;
		}

		protected override void ScanForObfuscator() {
			FindBabelAttribute();
			var resourceDecrypterCreator = new ResourceDecrypterCreator(module, DeobfuscatedFile);
			resourceResolver = new ResourceResolver(module, resourceDecrypterCreator.Create(), DeobfuscatedFile);
			resourceResolver.Find();
			assemblyResolver = new AssemblyResolver(module, resourceDecrypterCreator.Create());
			assemblyResolver.Find();
			stringDecrypter = new StringDecrypter(module, resourceDecrypterCreator.Create());
			stringDecrypter.Find(DeobfuscatedFile);
			constantsDecrypter = new ConstantsDecrypter(module, resourceDecrypterCreator.Create(), initializedDataCreator);
			constantsDecrypter.Find();
			proxyCallFixer = new ProxyCallFixer(module);
			proxyCallFixer.FindDelegateCreator();
			methodsDecrypter = new MethodsDecrypter(module, resourceDecrypterCreator.Create(), DeobfuscatedFile.DeobfuscatorContext);
			methodsDecrypter.Find();
		}

		void FindBabelAttribute() {
			foreach (var type in module.Types) {
				if (type.FullName == "BabelAttribute" || type.FullName == "BabelObfuscatorAttribute") {
					foundBabelAttribute = true;
					CheckVersion(type);
					AddAttributeToBeRemoved(type, "Obfuscator attribute");
					return;
				}
			}
		}

		void CheckVersion(TypeDef attr) {
			var versionField = attr.FindField("Version");
			if (versionField != null && versionField.IsLiteral && versionField.Constant != null && versionField.Constant.Value is string) {
				var val = Regex.Match((string)versionField.Constant.Value, @"^(\d+\.\d+\.\d+\.\d+)$");
				if (val.Groups.Count < 2)
					return;
				obfuscatorName = $"{DeobfuscatorInfo.THE_NAME} {val.Groups[1].ToString()}";
				return;
			}
		}

		public override void DeobfuscateBegin() {
			base.DeobfuscateBegin();

			if (options.DecryptResources) {
				AddCctorInitCallToBeRemoved(resourceResolver.InitMethod);
				AddTypeToBeRemoved(resourceResolver.Type, "Resource resolver type");
			}

			DecryptResources();
			stringDecrypter.Initialize();

			if (Operations.DecryptStrings != OpDecryptString.None) {
				if (stringDecrypter.Resource != null)
					Logger.v("Adding string decrypter. Resource: {0}", Utils.ToCsharpString(stringDecrypter.Resource.Name));
				staticStringInliner.Add(stringDecrypter.DecryptMethod, (method, gim, args) => {
					return stringDecrypter.Decrypt(args);
				});
				DeobfuscatedFile.StringDecryptersAdded();
			}

			if (options.DumpEmbeddedAssemblies) {
				assemblyResolver.Initialize(DeobfuscatedFile, this);

				// Need to dump the assemblies before decrypting methods in case there's a reference
				// in the encrypted code to one of these assemblies.
				DumpEmbeddedAssemblies();
			}

			if (options.DecryptMethods) {
				methodsDecrypter.Initialize(DeobfuscatedFile, this);
				methodsDecrypter.Decrypt();
			}

			if (options.DecryptConstants) {
				constantsDecrypter.Initialize(DeobfuscatedFile, this);

				AddTypeToBeRemoved(constantsDecrypter.Type, "Constants decrypter type");
				AddResourceToBeRemoved(constantsDecrypter.Resource, "Encrypted constants");
				int32ValueInliner = new Int32ValueInliner();
				int32ValueInliner.Add(constantsDecrypter.Int32Decrypter, (method, gim, args) => constantsDecrypter.DecryptInt32((int)args[0]));
				int64ValueInliner = new Int64ValueInliner();
				int64ValueInliner.Add(constantsDecrypter.Int64Decrypter, (method, gim, args) => constantsDecrypter.DecryptInt64((int)args[0]));
				singleValueInliner = new SingleValueInliner();
				singleValueInliner.Add(constantsDecrypter.SingleDecrypter, (method, gim, args) => constantsDecrypter.DecryptSingle((int)args[0]));
				doubleValueInliner = new DoubleValueInliner();
				doubleValueInliner.Add(constantsDecrypter.DoubleDecrypter, (method, gim, args) => constantsDecrypter.DecryptDouble((int)args[0]));
			}

			proxyCallFixer.Find();
			startedDeobfuscating = true;
		}

		void DumpEmbeddedAssemblies() {
			if (!options.DumpEmbeddedAssemblies)
				return;
			foreach (var info in assemblyResolver.EmbeddedAssemblyInfos)
				DeobfuscatedFile.CreateAssemblyFile(info.data, Utils.GetAssemblySimpleName(info.fullname), info.extension);
			AddTypeToBeRemoved(assemblyResolver.Type, "Assembly resolver type");
			AddCctorInitCallToBeRemoved(assemblyResolver.InitMethod);
			AddResourceToBeRemoved(assemblyResolver.EncryptedResource, "Embedded encrypted assemblies");
		}

		void DecryptResources() {
			if (!options.DecryptResources)
				return;
			var rsrc = resourceResolver.MergeResources();
			if (rsrc == null)
				return;
			AddResourceToBeRemoved(rsrc, "Encrypted resources");
		}

		public override void DeobfuscateMethodEnd(Blocks blocks) {
			proxyCallFixer.Deobfuscate(blocks);
			if (options.DecryptConstants) {
				int32ValueInliner.Decrypt(blocks);
				int64ValueInliner.Decrypt(blocks);
				singleValueInliner.Decrypt(blocks);
				doubleValueInliner.Decrypt(blocks);
				constantsDecrypter.Deobfuscate(blocks);
			}
			base.DeobfuscateMethodEnd(blocks);
		}

		public override void DeobfuscateEnd() {
			RemoveInlinedMethods();
			if (CanRemoveStringDecrypterType) {
				AddResourceToBeRemoved(stringDecrypter.Resource, "Encrypted strings");
				AddTypeToBeRemoved(stringDecrypter.Type, "String decrypter type");
			}

			RemoveProxyDelegates(proxyCallFixer);
			base.DeobfuscateEnd();
		}

		void RemoveInlinedMethods() {
			if (!options.InlineMethods || !options.RemoveInlinedMethods)
				return;
			RemoveInlinedMethods(BabelMethodCallInliner.Find(module, staticStringInliner.Methods));
		}

		public override IEnumerable<int> GetStringDecrypterMethods() {
			var list = new List<int>();
			if (stringDecrypter.DecryptMethod != null)
				list.Add(stringDecrypter.DecryptMethod.MDToken.ToInt32());
			return list;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Babel_NET/ImageReader.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Text;
using dnlib.IO;
using dnlib.DotNet;
using de4dot.blocks;

using CR = System.Runtime.InteropServices;
using DR = dnlib.DotNet;

namespace de4dot.code.deobfuscators.Babel_NET {
	class ImageReader {
		static int METHODS_SIG			= 0x0000BEBA;
		static int METADATA_SIG			= 0x0100BEBA;
		static int METHOD_NAMES_SIG		= 0x0200BEBA;
		static int ASSEMBLY_NAMES_SIG	= 0x0201BEBA;
		static int TYPEREFS_SIG			= 0x0202BEBA;
		static int STRINGS_SIG			= 0x0203BEBA;

		enum TypeId : byte {
			TypeRef = 0,
			GenericInstance = 1,
			Pointer = 2,
			Array = 3,
			ByRef = 4,
		}

		ModuleDefMD module;
		internal DataReader reader;
		string[] strings;
		AssemblyRef[] assemblyNames;
		Dictionary<string, int> methodOffsets;
		List<TypeSig> typeRefs;
		MemberRefConverter memberRefConverter;

		public ImageReader(IDeobfuscatorContext deobfuscatorContext, ModuleDefMD module, byte[] data) {
			this.module = module;
			reader = ByteArrayDataReaderFactory.CreateReader(data);
			memberRefConverter = new MemberRefConverter(module);
		}

		public bool Initialize() {
			if (reader.ReadInt32() != METHODS_SIG)
				return false;

			int metadataOffset = GetMetadataOffset();
			if (metadataOffset < 0)
				return false;
			uint pos = (uint)metadataOffset + 4;
			reader.Position = pos;
			int version = reader.ReadInt16();	// major, minor
			if (version == 0x0001) {
				InitializeV10();
				return true;
			}

			reader.Position = pos;
			InitializeV55();
			return true;
		}

		void InitializeV10() {
			reader.ReadInt16();
			int methodNamesOffset = (int)reader.ReadInt64();
			int typeRefsOffset = (int)reader.ReadInt64();
			int assemblyRefsOffset = (int)reader.ReadInt64();
			int stringsOffset = (int)reader.ReadInt64();

			InitializeStrings(stringsOffset);
			InitializeAssemblyNames(assemblyRefsOffset);
			InitializeMethodNames(methodNamesOffset);
			InitializeTypeRefs(typeRefsOffset);
		}

		void InitializeV55() {
			int methodNamesOffset = (int)reader.ReadInt64() ^ METADATA_SIG;
			int typeRefsOffset = (int)reader.ReadInt64() ^ (METADATA_SIG << 1);
			int assemblyRefsOffset = (int)reader.ReadInt64() ^ ((METADATA_SIG << 1) + 1);
			int stringsOffset = (int)reader.ReadInt64() ^ (((METADATA_SIG << 1) + 1) << 1);

			InitializeStrings(stringsOffset);
			InitializeAssemblyNames(assemblyRefsOffset);
			InitializeMethodNames(methodNamesOffset);
			InitializeTypeRefs(typeRefsOffset);
		}

		public void Restore(string name, MethodDef method) {
			var babelMethod = GetMethod(name);
			var body = method.Body;

			body.MaxStack = babelMethod.MaxStack;
			body.InitLocals = babelMethod.InitLocals;

			body.Variables.Clear();
			foreach (var local in babelMethod.Locals)
				body.Variables.Add(local);

			var toNewOperand = new Dictionary<object, object>();
			if (babelMethod.ThisParameter != null)
				toNewOperand[babelMethod.ThisParameter] = method.Parameters[0];
			for (int i = 0; i < babelMethod.Parameters.Length; i++)
				toNewOperand[babelMethod.Parameters[i]] = method.Parameters[i + method.Parameters.MethodSigIndexBase];

			body.Instructions.Clear();
			foreach (var instr in babelMethod.Instructions) {
				if (instr.Operand != null && toNewOperand.TryGetValue(instr.Operand, out object newOperand))
					instr.Operand = newOperand;
				body.Instructions.Add(instr);
			}

			body.ExceptionHandlers.Clear();
			foreach (var eh in babelMethod.ExceptionHandlers)
				body.ExceptionHandlers.Add(eh);
		}

		BabelMethodDef GetMethod(string name) {
			int offset = methodOffsets[name];
			methodOffsets.Remove(name);
			reader.Position = (uint)offset;
			return new MethodDefReader(this).Read();
		}

		public string ReadString() => strings[ReadVariableLengthInt32()];
		public TypeSig ReadTypeSig() => typeRefs[ReadVariableLengthInt32()];

		public TypeSig[] ReadTypeSigs() {
			var refs = new TypeSig[ReadVariableLengthInt32()];
			for (int i = 0; i < refs.Length; i++)
				refs[i] = ReadTypeSig();
			return refs;
		}

		public IField ReadFieldRef() {
			var name = ReadString();
			var declaringType = ReadTypeSig();

			var fields = GetFields(Resolve(declaringType), name);
			if (fields == null || fields.Count != 1)
				throw new ApplicationException($"Couldn't find one field named '{name}' in type {Utils.RemoveNewlines(declaringType)}");

			return memberRefConverter.Convert(fields[0]);
		}

		static List<FieldDef> GetFields(TypeDef type, string name) {
			if (type == null)
				return null;
			return new List<FieldDef>(type.FindFields(name));
		}

		public IMethod ReadMethodRef() {
			var babelMethodRef = new MethodRefReader(this).Read();

			var method = GetMethodRef(babelMethodRef);
			if (method == null)
				throw new ApplicationException($"Could not find method '{Utils.RemoveNewlines(babelMethodRef.Name)}' in type '{Utils.RemoveNewlines(babelMethodRef.DeclaringType)}'");

			var git = babelMethodRef.DeclaringType.ToGenericInstSig();
			if (git == null)
				return method;

			var mr = new MemberRefUser(module, method.Name, method.MethodSig.Clone(), babelMethodRef.DeclaringType.ToTypeDefOrRef());
			return module.UpdateRowId(mr);
		}

		IMethod GetMethodRef(BabelMethodreference babelMethodRef) {
			var declaringType = Resolve(babelMethodRef.DeclaringType);
			if (declaringType == null)
				return null;

			var methods = GetMethods(declaringType, babelMethodRef);
			if (methods.Count != 1)
				throw new ApplicationException($"Couldn't find one method named '{babelMethodRef.Name}' in type {Utils.RemoveNewlines(declaringType)}");

			return methods[0];
		}

		List<IMethod> GetMethods(TypeDef declaringType, BabelMethodreference babelMethodRef) {
			var methods = new List<IMethod>();

			var gis = babelMethodRef.DeclaringType as GenericInstSig;
			var gim = babelMethodRef.GenericArguments;
			foreach (var method in declaringType.Methods) {
				if (CompareMethod(GenericArgsSubstitutor.Create(method, gis, gim), babelMethodRef)) {
					if (!babelMethodRef.IsGenericMethod)
						methods.Add(memberRefConverter.Convert(method));
					else {
						var gim2 = new GenericInstMethodSig(babelMethodRef.GenericArguments);
						var ms = module.UpdateRowId(new MethodSpecUser(memberRefConverter.Convert(method), gim2));
						methods.Add(ms);
					}
				}
			}

			return methods;
		}

		bool CompareMethod(IMethod method, BabelMethodreference babelMethodRef) {
			var sig = method.MethodSig;
			if (sig.Params.Count != babelMethodRef.Parameters.Length)
				return false;
			if (method.Name != babelMethodRef.Name)
				return false;
			if (sig.HasThis != babelMethodRef.HasThis)
				return false;
			if (sig.GenParamCount != babelMethodRef.GenericArguments.Length)
				return false;

			if (!new SigComparer().Equals(sig.RetType, babelMethodRef.ReturnType))
				return false;

			for (int i = 0; i < babelMethodRef.Parameters.Length; i++) {
				if (!new SigComparer().Equals(sig.Params[i], babelMethodRef.Parameters[i].Type))
					return false;
			}

			return true;
		}

		TypeDef Resolve(TypeSig type) {
			type = type.RemovePinnedAndModifiers();

			if (type is GenericInstSig gis)
				type = gis.GenericType;

			var tdrs = type as TypeDefOrRefSig;
			if (tdrs == null)
				return null;

			var td = tdrs.TypeDef;
			if (td != null)
				return td;

			var tr = tdrs.TypeRef;
			if (tr != null)
				return tr.Resolve();

			return null;
		}

		public MethodSig ReadCallSite() {
			var returnType = ReadTypeSig();
			var paramTypes = ReadTypeSigs();
			var callingConvention = (CR.CallingConvention)reader.ReadInt32();

			return new MethodSig(ConvertCallingConvention(callingConvention), 0, returnType, paramTypes);
		}

		static DR.CallingConvention ConvertCallingConvention(CR.CallingConvention callingConvention) {
			switch (callingConvention) {
			case CR.CallingConvention.Winapi:	return DR.CallingConvention.Default;
			case CR.CallingConvention.Cdecl:	return DR.CallingConvention.C;
			case CR.CallingConvention.StdCall:	return DR.CallingConvention.StdCall;
			case CR.CallingConvention.ThisCall:	return DR.CallingConvention.ThisCall;
			case CR.CallingConvention.FastCall:	return DR.CallingConvention.FastCall;
			default: throw new ApplicationException($"Unknown CallingConvention {callingConvention}");
			}
		}

		void InitializeStrings(int headerOffset) {
			reader.Position = (uint)headerOffset;
			if (reader.ReadInt32() != STRINGS_SIG)
				throw new ApplicationException("Invalid strings sig");

			strings = new string[ReadVariableLengthInt32()];
			for (int i = 0; i < strings.Length; i++)
				strings[i] = reader.ReadSerializedString();
		}

		void InitializeAssemblyNames(int headerOffset) {
			reader.Position = (uint)headerOffset;
			if (reader.ReadInt32() != ASSEMBLY_NAMES_SIG)
				throw new ApplicationException("Invalid assembly names sig");

			assemblyNames = new AssemblyRef[ReadVariableLengthInt32()];
			for (int i = 0; i < assemblyNames.Length; i++)
				assemblyNames[i] = module.UpdateRowId(new AssemblyRefUser(new AssemblyNameInfo(ReadString())));
		}

		void InitializeMethodNames(int headerOffset) {
			reader.Position = (uint)headerOffset;
			if (reader.ReadInt32() != METHOD_NAMES_SIG)
				throw new ApplicationException("Invalid methods sig");

			int numMethods = ReadVariableLengthInt32();
			methodOffsets = new Dictionary<string, int>(numMethods, StringComparer.Ordinal);
			for (int i = 0; i < numMethods; i++) {
				var methodName = ReadString();
				methodOffsets[methodName] = ReadVariableLengthInt32();
			}
		}

		void InitializeTypeRefs(int headerOffset) {
			reader.Position = (uint)headerOffset;
			if (reader.ReadInt32() != TYPEREFS_SIG)
				throw new ApplicationException("Invalid typerefs sig");

			int numTypeRefs = reader.ReadInt32();
			typeRefs = new List<TypeSig>(numTypeRefs + 1);
			typeRefs.Add(null);
			var genericArgFixes = new Dictionary<GenericInstSig, List<int>>();
			for (int i = 0; i < numTypeRefs; i++) {
				var typeId = (TypeId)reader.ReadByte();
				switch (typeId) {
				case TypeId.TypeRef:
					typeRefs.Add(ReadTypeRef());
					break;

				case TypeId.GenericInstance:
					List<int> genericArgs;
					var git = ReadGenericInstanceType(out genericArgs);
					typeRefs.Add(git);
					genericArgFixes[git] = genericArgs;
					break;

				case TypeId.Pointer:
					typeRefs.Add(ReadPointerType());
					break;

				case TypeId.Array:
					typeRefs.Add(ReadArrayType());
					break;

				case TypeId.ByRef:
					typeRefs.Add(ReadByRefType());
					break;

				default:
					throw new ApplicationException($"Unknown type id {(int)typeId}");
				}
			}

			foreach (var kv in genericArgFixes) {
				var git = kv.Key;
				foreach (var typeNum in kv.Value)
					git.GenericArguments.Add(typeRefs[typeNum]);
			}
		}

		TypeSig ReadTypeRef() {
			ParseReflectionTypeName(ReadString(), out string ns, out string name);
			var asmRef = assemblyNames[ReadVariableLengthInt32()];
			var declaringType = ReadTypeSig();
			var typeRef = new TypeRefUser(module, ns, name);
			if (declaringType != null)
				typeRef.ResolutionScope = GetTypeRef(declaringType);
			else
				typeRef.ResolutionScope = asmRef;

			return memberRefConverter.Convert(typeRef);
		}

		TypeRef GetTypeRef(TypeSig type) {
			var tdr = type as TypeDefOrRefSig;
			if (tdr == null)
				throw new ApplicationException("Not a type ref");
			if (tdr.TypeRef != null)
				return tdr.TypeRef;
			var td = tdr.TypeDef;
			if (td != null)
				return new Importer(module).Import(td) as TypeRef;
			throw new ApplicationException("Not a type ref");
		}

		static void ParseReflectionTypeName(string fullName, out string ns, out string name) {
			int index = GetLastChar(fullName, '.');
			if (index < 0) {
				ns = "";
				name = fullName;
			}
			else {
				ns = UnEscape(fullName.Substring(0, index));
				name = fullName.Substring(index + 1);
			}

			index = GetLastChar(name, '+');
			if (index < 0)
				name = UnEscape(name);
			else {
				ns = "";
				name = UnEscape(name.Substring(index + 1));
			}
		}

		static int GetLastChar(string name, char c) {
			if (string.IsNullOrEmpty(name))
				return -1;
			int index = name.Length - 1;
			while (true) {
				index = name.LastIndexOf(c, index);
				if (index < 0)
					return -1;
				if (index == 0)
					return index;
				if (name[index - 1] != '\\')
					return index;
				index--;
			}
		}

		static string UnEscape(string s) {
			var sb = new StringBuilder(s.Length);
			for (int i = 0; i < s.Length; i++) {
				if (s[i] == '\\' && i + 1 < s.Length)
					i++;
				sb.Append(s[i]);
			}
			return sb.ToString();
		}

		GenericInstSig ReadGenericInstanceType(out List<int> genericArgs) {
			var git = new GenericInstSig(ReadTypeSig() as ClassOrValueTypeSig);
			int numArgs = ReadVariableLengthInt32();
			genericArgs = new List<int>(numArgs);
			for (int i = 0; i < numArgs; i++)
				genericArgs.Add(ReadVariableLengthInt32());
			return git;
		}

		PtrSig ReadPointerType() => new PtrSig(ReadTypeSig());

		TypeSig ReadArrayType() {
			var typeSig = ReadTypeSig();
			int rank = ReadVariableLengthInt32();
			if (rank == 1)
				return new SZArraySig(typeSig);
			return new ArraySig(typeSig, rank);
		}

		ByRefSig ReadByRefType() => new ByRefSig(ReadTypeSig());

		public uint ReadVariableLengthUInt32() => reader.ReadCompressedUInt32();
		public int ReadVariableLengthInt32() => (int)reader.ReadCompressedUInt32();

		int GetMetadataOffset() {
			reader.Position = reader.Length - 4;
			for (int i = 0; i < 30; i++) {
				if (reader.ReadInt32() == METADATA_SIG)
					return (int)reader.Position - 4;
				reader.Position -= 8;
			}
			return -1;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Babel_NET/InflaterCreator.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using ICSharpCode.SharpZipLib.Zip.Compression;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Babel_NET {
	class InflaterCreator {
		public static Inflater Create(MethodDef method, bool noHeader) => Create(FindInflaterType(method), noHeader);

		public static Inflater Create(TypeDef inflaterType, bool noHeader) {
			if (inflaterType == null)
				return CreateNormal(noHeader);
			var initHeaderMethod = FindInitHeaderMethod(inflaterType);
			if (initHeaderMethod == null)
				return CreateNormal(noHeader, "Could not find inflater init header method");
			var magic = GetMagic(initHeaderMethod);
			if (!magic.HasValue)
				return CreateNormal(noHeader);
			return new BabelInflater(noHeader, magic.Value);
		}

		static Inflater CreateNormal(bool noHeader) => CreateNormal(noHeader, null);

		static Inflater CreateNormal(bool noHeader, string errorMessage) {
			if (errorMessage != null)
				Logger.w("{0}", errorMessage);
			return new Inflater(noHeader);
		}

		static TypeDef FindInflaterType(MethodDef method) {
			if (method == null || method.Body == null)
				return null;
			foreach (var instr in method.Body.Instructions) {
				if (instr.OpCode.Code != Code.Call)
					continue;
				var calledMethod = instr.Operand as MethodDef;
				if (calledMethod == null || !calledMethod.IsStatic)
					continue;

				var type = calledMethod.DeclaringType;
				foreach (var nested in type.NestedTypes) {
					if (DeobUtils.HasInteger(nested.FindMethod(".ctor"), 0x8001))
						return type;
				}
			}

			return null;
		}

		static MethodDef FindInitHeaderMethod(TypeDef inflaterType) {
			foreach (var nested in inflaterType.NestedTypes) {
				var method = FindInitHeaderMethod2(nested);
				if (method != null)
					return method;
			}
			return null;
		}

		static MethodDef FindInitHeaderMethod2(TypeDef nested) {
			foreach (var method in nested.Methods) {
				if (method.IsStatic || method.Body == null)
					continue;
				if (!DotNetUtils.IsMethod(method, "System.Boolean", "()"))
					continue;

				return method;
			}

			return null;
		}

		static int? GetMagic(MethodDef method) {
			if (method == null || method.Body == null)
				return null;
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 3; i++) {
				var ldci4_1 = instrs[i];
				if (!ldci4_1.IsLdcI4() || ldci4_1.GetLdcI4Value() != 16)
					continue;

				var callvirt = instrs[i + 1];
				if (callvirt.OpCode.Code != Code.Callvirt)
					continue;

				var ldci4_2 = instrs[i + 2];
				if (!ldci4_2.IsLdcI4())
					continue;

				if (instrs[i + 3].OpCode.Code != Code.Xor)
					continue;

				return ldci4_2.GetLdcI4Value();
			}

			return null;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Babel_NET/MemberReferenceConverter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using dnlib.DotNet;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Babel_NET {
	// Converts type references/definitions in one module to this module
	class MemberRefConverter {
		ModuleDefMD module;

		public ModuleDefMD Module => module;
		public MemberRefConverter(ModuleDefMD module) => this.module = module;

		bool IsInOurModule(IMemberRef memberRef) => memberRef.Module == module;
		Importer CreateImporter() => new Importer(module, ImporterOptions.TryToUseTypeDefs);
		public TypeSig Convert(TypeRef typeRef) => CreateImporter().Import(typeRef).ToTypeSig();
		ITypeDefOrRef Convert(ITypeDefOrRef tdr) => (ITypeDefOrRef)CreateImporter().Import(tdr);
		TypeSig Convert2(TypeSig ts) => CreateImporter().Import(ts);
		public TypeSig Convert(TypeSig ts) => CreateImporter().Import(ts);

		public IField Convert(IField fieldRef) {
			if (IsInOurModule(fieldRef))
				return TryGetFieldDef(fieldRef);
			return CreateImporter().Import(fieldRef);
		}

		public IMethodDefOrRef Convert(IMethod methodRef) {
			if (!(methodRef is MemberRef || methodRef is MethodDef) || methodRef.MethodSig == null)
				throw new ApplicationException("Invalid method reference type");
			if (IsInOurModule(methodRef))
				return (IMethodDefOrRef)TryGetMethodDef(methodRef);
			return (IMethodDefOrRef)CreateImporter().Import(methodRef);
		}

		public IField TryGetFieldDef(IField fieldRef) {
			if (fieldRef is FieldDef fieldDef)
				return fieldDef;

			var declaringType = DotNetUtils.GetType(module, fieldRef.DeclaringType);
			if (declaringType == null)
				return fieldRef;
			return DotNetUtils.GetField(declaringType, fieldRef);
		}

		public IMethod TryGetMethodDef(IMethod methodRef) {
			if (methodRef is MethodDef methodDef)
				return methodDef;

			var declaringType = DotNetUtils.GetType(module, methodRef.DeclaringType);
			if (declaringType == null)
				return methodRef;
			return DotNetUtils.GetMethod(declaringType, methodRef);
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Babel_NET/MethodBodyReader.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace de4dot.code.deobfuscators.Babel_NET {
	class MethodBodyReader : MethodBodyReaderBase {
		ImageReader imageReader;
		public int Flags2 { get; set; }
		public ushort MaxStack { get; set; }
		public MethodBodyReader(ImageReader imageReader) : base(imageReader.reader) => this.imageReader = imageReader;

		public void Read(IList<Parameter> parameters) {
			this.parameters = parameters;
			Flags2 = imageReader.reader.ReadInt16();
			MaxStack = imageReader.reader.ReadUInt16();
			SetLocals(imageReader.ReadTypeSigs());
			int len = imageReader.ReadVariableLengthInt32();
			reader.Position = imageReader.reader.Position;
			ReadInstructions(len);
			imageReader.reader.Position = reader.Position;
			ReadExceptionHandlers(imageReader.ReadVariableLengthInt32());
			reader.Position = imageReader.reader.Position;
		}

		protected override IField ReadInlineField(Instruction instr) {
			imageReader.reader.Position = reader.Position;
			var res = imageReader.ReadFieldRef();
			reader.Position = imageReader.reader.Position;
			return res;
		}

		protected override IMethod ReadInlineMethod(Instruction instr) {
			imageReader.reader.Position = reader.Position;
			var res = imageReader.ReadMethodRef();
			reader.Position = imageReader.reader.Position;
			return res;
		}

		protected override MethodSig ReadInlineSig(Instruction instr) {
			imageReader.reader.Position = reader.Position;
			var res = imageReader.ReadCallSite();
			reader.Position = imageReader.reader.Position;
			return res;
		}

		protected override string ReadInlineString(Instruction instr) {
			imageReader.reader.Position = reader.Position;
			var res = imageReader.ReadString();
			reader.Position = imageReader.reader.Position;
			return res;
		}

		protected override ITokenOperand ReadInlineTok(Instruction instr) {
			imageReader.reader.Position = reader.Position;
			ITokenOperand res;
			switch (imageReader.reader.ReadByte()) {
			case 0: res = imageReader.ReadTypeSig().ToTypeDefOrRef(); break;
			case 1: res = imageReader.ReadFieldRef(); break;
			case 2: res = imageReader.ReadMethodRef(); break;
			default: throw new ApplicationException("Unknown token type");
			}
			reader.Position = imageReader.reader.Position;
			return res;
		}

		protected override ITypeDefOrRef ReadInlineType(Instruction instr) {
			imageReader.reader.Position = reader.Position;
			var res = imageReader.ReadTypeSig().ToTypeDefOrRef();
			reader.Position = imageReader.reader.Position;
			return res;
		}

		void ReadExceptionHandlers(int numExceptionHandlers) {
			exceptionHandlers = new List<ExceptionHandler>(numExceptionHandlers);
			for (int i = 0; i < numExceptionHandlers; i++)
				Add(ReadExceptionHandler());
		}

		ExceptionHandler ReadExceptionHandler() {
			var ehType = (ExceptionHandlerType)imageReader.reader.ReadByte();
			uint tryOffset = imageReader.ReadVariableLengthUInt32();
			uint tryLength = imageReader.ReadVariableLengthUInt32();
			uint handlerOffset = imageReader.ReadVariableLengthUInt32();
			uint handlerLength = imageReader.ReadVariableLengthUInt32();
			var catchType = imageReader.ReadTypeSig().ToTypeDefOrRef();
			uint filterOffset = imageReader.ReadVariableLengthUInt32();

			var eh = new ExceptionHandler(ehType);
			eh.TryStart = GetInstructionThrow(tryOffset);
			eh.TryEnd = GetInstruction(tryOffset + tryLength);
			if (ehType == ExceptionHandlerType.Filter)
				eh.FilterStart = GetInstructionThrow(filterOffset);
			eh.HandlerStart = GetInstructionThrow(handlerOffset);
			eh.HandlerEnd = GetInstruction(handlerOffset + handlerLength);
			eh.CatchType = catchType;
			return eh;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Babel_NET/MethodReferenceReader.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace de4dot.code.deobfuscators.Babel_NET {
	class BabelMethodreference {
		public string Name { get; set; }
		public TypeSig DeclaringType { get; set; }
		public TypeSig ReturnType { get; set; }
		public Parameter[] Parameters { get; set; }
		public TypeSig[] GenericArguments { get; set; }
		public int Flags { get; set; }
		public bool HasThis => (Flags & 1) != 0;
		public bool IsGenericMethod => (Flags & 2) != 0;
	}

	class BabelMethodDef : BabelMethodreference {
		Parameter thisParameter;

		public int Flags2 { get; set; }
		public ushort MaxStack { get; set; }
		public IList<Local> Locals { get; set; }
		public IList<Instruction> Instructions { get; set; }
		public IList<ExceptionHandler> ExceptionHandlers { get; set; }
		public bool IsStatic => (Flags2 & 0x10) != 0;
		public bool RequiresFatExceptionHandler => (Flags2 & 0x20) != 0;
		public bool InitLocals => (Flags2 & 0x40) != 0;
		public bool CacheMethod => (Flags2 & 0x80) != 0;

		public Parameter ThisParameter {
			get {
				if (!HasThis)
					return null;
				if (thisParameter != null)
					return thisParameter;
				return thisParameter = new Parameter(0, Parameter.HIDDEN_THIS_METHOD_SIG_INDEX, DeclaringType);
			}
		}

		public void SetBody(MethodBodyReader mbr) {
			Flags2 = mbr.Flags2;
			MaxStack = mbr.MaxStack;
			Locals = mbr.Locals;
			Instructions = mbr.Instructions;
			ExceptionHandlers = mbr.ExceptionHandlers;
		}

		public IList<Parameter> GetRealParameters() {
			if (ThisParameter == null)
				return Parameters;
			var parameters = new Parameter[Parameters.Length + 1];
			parameters[0] = ThisParameter;
			Array.Copy(Parameters, 0, parameters, 1, Parameters.Length);
			return parameters;
		}
	}

	class MethodRefReader {
		ImageReader imageReader;
		BabelMethodreference bmr;

		public MethodRefReader(ImageReader imageReader)
			: this(imageReader, new BabelMethodreference()) {
		}

		public MethodRefReader(ImageReader imageReader, BabelMethodreference bmr) {
			this.imageReader = imageReader;
			this.bmr = bmr;
		}

		public BabelMethodreference Read() {
			bmr.Name = imageReader.ReadString();
			bmr.DeclaringType = imageReader.ReadTypeSig();
			bmr.ReturnType = imageReader.ReadTypeSig();
			var argTypes = imageReader.ReadTypeSigs();
			bmr.Flags = imageReader.reader.ReadByte();
			if (bmr.IsGenericMethod)
				bmr.GenericArguments = imageReader.ReadTypeSigs();
			else
				bmr.GenericArguments = new TypeSig[0];
			bmr.Parameters = ReadParameters(argTypes, bmr.HasThis);
			return bmr;
		}

		Parameter[] ReadParameters(IList<TypeSig> argTypes, bool hasThis) {
			var ps = new Parameter[argTypes.Count];
			int bi = hasThis ? 1 : 0;
			for (int i = 0; i < ps.Length; i++)
				ps[i] = new Parameter(bi + i, i, argTypes[i]);
			return ps;
		}
	}

	class MethodDefReader {
		MethodRefReader methodRefReader;
		MethodBodyReader methodBodyReader;
		BabelMethodDef bmd;

		public MethodDefReader(ImageReader imageReader) {
			bmd = new BabelMethodDef();
			methodRefReader = new MethodRefReader(imageReader, bmd);
			methodBodyReader = new MethodBodyReader(imageReader);
		}

		public BabelMethodDef Read() {
			methodRefReader.Read();
			methodBodyReader.Read(bmd.GetRealParameters());
			bmd.SetBody(methodBodyReader);
			return bmd;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Babel_NET/MethodsDecrypter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.IO;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Babel_NET {
	class MethodsDecrypter {
		ModuleDefMD module;
		ResourceDecrypter resourceDecrypter;
		IDeobfuscatorContext deobfuscatorContext;
		Dictionary<string, ImageReader> imageReaders = new Dictionary<string, ImageReader>(StringComparer.Ordinal);
		TypeDef methodsDecrypterCreator;
		TypeDef methodsDecrypter;
		MethodDef decryptExecuteMethod;
		EmbeddedResource encryptedResource;

		public bool Detected => methodsDecrypterCreator != null;

		public MethodsDecrypter(ModuleDefMD module, ResourceDecrypter resourceDecrypter, IDeobfuscatorContext deobfuscatorContext) {
			this.module = module;
			this.resourceDecrypter = resourceDecrypter;
			this.deobfuscatorContext = deobfuscatorContext;
		}

		public void Find() {
			var requiredFields = new string[] {
				"System.Threading.ReaderWriterLock",
				"System.Collections.Hashtable",
			};
			foreach (var type in module.GetTypes()) {
				var fieldTypes = new FieldTypes(type);
				if (!fieldTypes.All(requiredFields))
					continue;
				if (type.FindMethod("Finalize") == null)
					continue;
				var executeMethod = DotNetUtils.GetMethod(type, "System.Object", "(System.String,System.Object[])");
				if (executeMethod == null || !executeMethod.IsStatic || executeMethod.Body == null)
					continue;

				var decrypterType = FindMethodsDecrypterType(type);
				if (decrypterType == null)
					continue;

				resourceDecrypter.DecryptMethod = FindDecryptMethod(decrypterType);

				methodsDecrypterCreator = type;
				methodsDecrypter = decrypterType;
				decryptExecuteMethod = executeMethod;
				return;
			}
		}

		static MethodDef FindDecryptMethod(TypeDef type) {
			foreach (var method in type.Methods) {
				var decryptMethod = ResourceDecrypter.FindDecrypterMethod(method);
				if (decryptMethod != null)
					return decryptMethod;
			}
			return null;
		}

		TypeDef FindMethodsDecrypterType(TypeDef type) {
			foreach (var field in type.Fields) {
				var fieldType = DotNetUtils.GetType(module, field.FieldSig.GetFieldType());
				if (fieldType == null)
					continue;
				if (fieldType.FindMethod("Finalize") == null)
					continue;
				if (!new FieldTypes(fieldType).Exists("System.Collections.Hashtable"))
					continue;
				if (DotNetUtils.GetMethod(fieldType, "System.String", "()") == null)
					continue;

				return fieldType;
			}

			return null;
		}

		public void Initialize(ISimpleDeobfuscator simpleDeobfuscator, IDeobfuscator deob) {
			if (methodsDecrypter == null)
				return;

			encryptedResource = BabelUtils.FindEmbeddedResource(module, methodsDecrypter, simpleDeobfuscator, deob);
			if (encryptedResource != null)
				AddImageReader("", resourceDecrypter.Decrypt(encryptedResource.CreateReader().ToArray()));
		}

		ImageReader AddImageReader(string name, byte[] data) {
			var imageReader = new ImageReader(deobfuscatorContext, module, data);
			if (!imageReader.Initialize()) {
				Logger.w("Could not read encrypted methods");
				return null;
			}
			if (imageReaders.ContainsKey(name))
				throw new ApplicationException($"ImageReader for name '{name}' already exists");
			imageReaders[name] = imageReader;
			return imageReader;
		}

		class EncryptInfo {
			public string encryptedMethodName;
			public string feature;
			public MethodDef method;

			public string FullName {
				get {
					if (string.IsNullOrEmpty(feature))
						return encryptedMethodName;
					return $"{feature}:{encryptedMethodName}";
				}
			}

			public EncryptInfo(string encryptedMethodName, string feature, MethodDef method) {
				this.encryptedMethodName = encryptedMethodName;
				this.feature = feature;
				this.method = method;
			}

			public override string ToString() {
				if (feature != "")
					return $"{feature}:{encryptedMethodName} {method.MDToken.ToInt32():X8}";
				else
					return $"{encryptedMethodName} {method.MDToken.ToInt32():X8}";
			}
		}

		public void Decrypt() {
			int numNonDecryptedMethods = 0;
			int totalEncryptedMethods = 0;
			foreach (var info in GetEncryptedMethods()) {
				totalEncryptedMethods++;
				var imageReader = GetImageReader(info.feature);
				if (imageReader == null) {
					numNonDecryptedMethods++;
					continue;
				}
				Logger.v("Decrypting method {0:X8}", info.method.MDToken.ToInt32());
				imageReader.Restore(info.FullName, info.method);
			}
			if (numNonDecryptedMethods > 0)
				Logger.w("{0}/{1} methods not decrypted", numNonDecryptedMethods, totalEncryptedMethods);
		}

		ImageReader GetImageReader(string feature) {
			if (imageReaders.TryGetValue(feature, out var imageReader))
				return imageReader;

			return CreateImageReader(feature);
		}

		ImageReader CreateImageReader(string feature) {
			if (string.IsNullOrEmpty(feature))
				return null;

			try {
				var encrypted = File.ReadAllBytes(GetFile(Path.GetDirectoryName(module.Location), feature));
				var decrypted = resourceDecrypter.Decrypt(encrypted);
				return AddImageReader(feature, decrypted);
			}
			catch {
				return null;
			}
		}

		static string GetFile(string dir, string name) {
			try {
				var di = new DirectoryInfo(dir);
				foreach (var file in di.GetFiles()) {
					if (Utils.StartsWith(file.Name, name, StringComparison.OrdinalIgnoreCase))
						return file.FullName;
				}
			}
			catch {
			}
			return null;
		}

		List<EncryptInfo> GetEncryptedMethods() {
			var infos = new List<EncryptInfo>();

			foreach (var type in module.GetTypes()) {
				foreach (var method in type.Methods) {
					if (CheckEncryptedMethod(method, out var info))
						infos.Add(info);
				}
			}

			return infos;
		}

		bool CheckEncryptedMethod(MethodDef method, out EncryptInfo info) {
			info = null;
			if (method.Body == null)
				return false;
			if (!CallsExecuteMethod(method))
				return false;

			var strings = DotNetUtils.GetCodeStrings(method);
			if (strings.Count != 1)
				throw new ApplicationException("Could not find name of encrypted method");

			string feature = "";
			string name = strings[0];
			int index = name.IndexOf(':');
			if (index >= 0) {
				feature = name.Substring(0, index);
				name = name.Substring(index + 1);
			}

			info = new EncryptInfo(name, feature, method);
			return true;
		}

		bool CallsExecuteMethod(MethodDef method) {
			foreach (var instr in method.Body.Instructions) {
				if (instr.OpCode.Code != Code.Call && instr.OpCode.Code != Code.Callvirt)
					continue;
				if (MethodEqualityComparer.CompareDeclaringTypes.Equals(decryptExecuteMethod, instr.Operand as IMethod))
					return true;
			}
			return false;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Babel_NET/ProxyCallFixer.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Babel_NET {
	class ProxyCallFixer : ProxyCallFixer2 {
		MethodDefAndDeclaringTypeDict<ProxyCreatorType> methodToType = new MethodDefAndDeclaringTypeDict<ProxyCreatorType>();

		public ProxyCallFixer(ModuleDefMD module)
			: base(module) {
		}

		enum ProxyCreatorType {
			None,
			CallOrCallvirt,
			Newobj,
		}

		class Context {
			public ITypeDefOrRef delegateType;
			public int methodToken;
			public int declaringTypeToken;
			public ProxyCreatorType proxyCreatorType;
			public Context(ITypeDefOrRef delegateType, int methodToken, int declaringTypeToken, ProxyCreatorType proxyCreatorType) {
				this.delegateType = delegateType;
				this.methodToken = methodToken;
				this.declaringTypeToken = declaringTypeToken;
				this.proxyCreatorType = proxyCreatorType;
			}
		}

		protected override bool ProxyCallIsObfuscated => true;

		protected override object CheckCctor(TypeDef type, MethodDef cctor) {
			var instructions = cctor.Body.Instructions;
			for (int i = 0; i < instructions.Count; i++) {
				ITypeDefOrRef delegateType;
				IField delegateField;
				IMethod createMethod;
				int methodToken, declaringTypeToken;
				var instrs = DotNetUtils.GetInstructions(instructions, i, OpCodes.Ldtoken, OpCodes.Ldc_I4, OpCodes.Ldc_I4, OpCodes.Ldtoken, OpCodes.Call);
				if (instrs != null) {
					delegateType = instrs[0].Operand as ITypeDefOrRef;
					methodToken = instrs[1].GetLdcI4Value();
					declaringTypeToken = instrs[2].GetLdcI4Value();
					delegateField = instrs[3].Operand as IField;
					createMethod = instrs[4].Operand as IMethod;
				}
				else if ((instrs = DotNetUtils.GetInstructions(instructions, i, OpCodes.Ldtoken, OpCodes.Ldc_I4, OpCodes.Ldtoken, OpCodes.Call)) != null) {
					delegateType = instrs[0].Operand as ITypeDefOrRef;
					methodToken = instrs[1].GetLdcI4Value();
					declaringTypeToken = -1;
					delegateField = instrs[2].Operand as IField;
					createMethod = instrs[3].Operand as IMethod;
				}
				else
					continue;

				if (delegateType == null)
					continue;
				if (delegateField == null)
					continue;
				if (createMethod == null)
					continue;
				var proxyCreatorType = methodToType.Find(createMethod);
				if (proxyCreatorType == ProxyCreatorType.None)
					continue;

				return new Context(delegateType, methodToken, declaringTypeToken, proxyCreatorType);
			}

			return null;
		}

		protected override void GetCallInfo(object context, FieldDef field, out IMethod calledMethod, out OpCode callOpcode) {
			var ctx = (Context)context;

			switch (ctx.proxyCreatorType) {
			case ProxyCreatorType.CallOrCallvirt:
				callOpcode = field.IsAssembly ? OpCodes.Callvirt : OpCodes.Call;
				break;
			case ProxyCreatorType.Newobj:
				callOpcode = OpCodes.Newobj;
				break;
			default:
				throw new ApplicationException($"Invalid proxy creator type: {ctx.proxyCreatorType}");
			}

			var method = module.ResolveToken(ctx.methodToken) as IMethod;
			if (method.MethodSig == null)
				method = null;
			calledMethod = method;
		}

		public void FindDelegateCreator() {
			var requiredTypes = new string[] {
				"System.ModuleHandle",
			};
			foreach (var type in module.Types) {
				if (!new FieldTypes(type).Exactly(requiredTypes))
					continue;

				foreach (var method in type.Methods) {
					if (!method.IsStatic || method.Body == null)
						continue;
					if (!DotNetUtils.IsMethod(method, "System.Void", "(System.RuntimeTypeHandle,System.Int32,System.RuntimeFieldHandle)") &&
						!DotNetUtils.IsMethod(method, "System.Void", "(System.RuntimeTypeHandle,System.Int32,System.Int32,System.RuntimeFieldHandle)"))
						continue;
					var creatorType = GetProxyCreatorType(method);
					if (creatorType == ProxyCreatorType.None)
						continue;

					methodToType.Add(method, creatorType);
					SetDelegateCreatorMethod(method);
				}

				if (methodToType.Count == 0)
					continue;

				return;
			}
		}

		ProxyCreatorType GetProxyCreatorType(MethodDef methodToCheck) {
			foreach (var calledMethod in DotNetUtils.GetCalledMethods(module, methodToCheck)) {
				if (!calledMethod.IsStatic || calledMethod.Body == null)
					continue;
				if (!new SigComparer().Equals(methodToCheck.DeclaringType, calledMethod.DeclaringType))
					continue;
				if (DotNetUtils.IsMethod(calledMethod, "System.Void", "(System.Reflection.FieldInfo,System.Type,System.Reflection.MethodInfo)"))
					return ProxyCreatorType.CallOrCallvirt;
				if (DotNetUtils.IsMethod(calledMethod, "System.Void", "(System.Reflection.FieldInfo,System.Type,System.Reflection.ConstructorInfo)"))
					return ProxyCreatorType.Newobj;
			}
			return ProxyCreatorType.None;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Babel_NET/ResourceDecrypter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.IO;
using ICSharpCode.SharpZipLib.Zip.Compression;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Babel_NET {
	class ResourceDecrypterCreator {
		ModuleDefMD module;
		ISimpleDeobfuscator simpleDeobfuscator;

		public ResourceDecrypterCreator(ModuleDefMD module, ISimpleDeobfuscator simpleDeobfuscator) {
			this.module = module;
			this.simpleDeobfuscator = simpleDeobfuscator;
		}

		public ResourceDecrypter Create() => new ResourceDecrypter(module, simpleDeobfuscator);
	}

	class ResourceDecrypter {
		ModuleDefMD module;
		ISimpleDeobfuscator simpleDeobfuscator;
		MethodDef decryptMethod;
		IDecrypter decrypter;

		public ResourceDecrypter(ModuleDefMD module, ISimpleDeobfuscator simpleDeobfuscator) {
			this.module = module;
			this.simpleDeobfuscator = simpleDeobfuscator;
		}

		interface IDecrypter {
			byte[] Decrypt(byte[] encryptedData);
		}

		// v3.0
		class Decrypter1 : IDecrypter {
			ModuleDefMD module;

			public Decrypter1(ModuleDefMD module) => this.module = module;

			public byte[] Decrypt(byte[] encryptedData) {
				var reader = new BinaryReader(new MemoryStream(encryptedData));
				bool isCompressed = GetHeaderData(reader, out var key, out var iv);
				var data = DeobUtils.DesDecrypt(encryptedData,
										(int)reader.BaseStream.Position,
										(int)(reader.BaseStream.Length - reader.BaseStream.Position),
										key, iv);
				if (isCompressed)
					data = DeobUtils.Inflate(data, true);
				return data;
			}

			bool GetHeaderData(BinaryReader reader, out byte[] key, out byte[] iv) {
				iv = reader.ReadBytes(reader.ReadByte());
				bool hasEmbeddedKey = reader.ReadBoolean();
				if (hasEmbeddedKey)
					key = reader.ReadBytes(reader.ReadByte());
				else {
					key = new byte[reader.ReadByte()];
					Array.Copy(module.Assembly.PublicKey.Data, 0, key, 0, key.Length);
				}

				reader.ReadBytes(reader.ReadInt32());	// hash
				return true;
			}
		}

		// v3.5+
		class Decrypter2 : IDecrypter {
			ModuleDefMD module;

			public Decrypter2(ModuleDefMD module) => this.module = module;

			public byte[] Decrypt(byte[] encryptedData) {
				int index = 0;
				bool isCompressed = GetKeyIv(GetHeaderData(encryptedData, ref index), out var key, out var iv);
				var data = DeobUtils.DesDecrypt(encryptedData, index, encryptedData.Length - index, key, iv);
				if (isCompressed)
					data = DeobUtils.Inflate(data, true);
				return data;
			}

			byte[] GetHeaderData(byte[] encryptedData, ref int index) {
				bool xorDecrypt = encryptedData[index++] != 0;
				var headerData = new byte[BitConverter.ToUInt16(encryptedData, index)];
				Array.Copy(encryptedData, index + 2, headerData, 0, headerData.Length);
				index += headerData.Length + 2;
				if (!xorDecrypt)
					return headerData;

				var key = new byte[8];
				Array.Copy(encryptedData, index, key, 0, key.Length);
				index += key.Length;
				for (int i = 0; i < headerData.Length; i++)
					headerData[i] ^= key[i % key.Length];
				return headerData;
			}

			bool GetKeyIv(byte[] headerData, out byte[] key, out byte[] iv) {
				var reader = new BinaryReader(new MemoryStream(headerData));

				// 3.0 - 3.5 don't have this field
				if (headerData[(int)reader.BaseStream.Position] != 8) {
					/*var license =*/ reader.ReadString();
				}

				// 4.2 (and earlier?) always compress the data
				bool isCompressed = true;
				if (headerData[(int)reader.BaseStream.Position] != 8)
					isCompressed = reader.ReadBoolean();

				iv = reader.ReadBytes(reader.ReadByte());
				bool hasEmbeddedKey = reader.ReadBoolean();
				if (hasEmbeddedKey)
					key = reader.ReadBytes(reader.ReadByte());
				else {
					key = new byte[reader.ReadByte()];
					Array.Copy(module.Assembly.PublicKey.Data, 12, key, 0, key.Length);
					key[5] |= 0x80;
				}
				return isCompressed;
			}
		}

		// v5.0+ retail
		class Decrypter3 : IDecrypter {
			ModuleDefMD module;
			Inflater inflater;

			public Decrypter3(ModuleDefMD module, MethodDef decryptMethod) {
				this.module = module;
				inflater = InflaterCreator.Create(decryptMethod, true);
			}

			public byte[] Decrypt(byte[] encryptedData) {
				int index = 0;
				bool isCompressed = GetKeyIv(GetHeaderData(encryptedData, ref index), out var key, out var iv);
				var data = DeobUtils.DesDecrypt(encryptedData, index, encryptedData.Length - index, key, iv);
				if (isCompressed)
					data = DeobUtils.Inflate(data, inflater);
				return data;
			}

			byte[] GetHeaderData(byte[] encryptedData, ref int index) {
				bool xorDecrypt = encryptedData[index++] != 0;
				var headerData = new byte[BitConverter.ToUInt16(encryptedData, index)];
				Array.Copy(encryptedData, index + 2, headerData, 0, headerData.Length);
				index += headerData.Length + 2;
				if (!xorDecrypt)
					return headerData;

				var key = new byte[6];
				Array.Copy(encryptedData, index, key, 0, key.Length);
				index += key.Length;
				for (int i = 0; i < headerData.Length; i++)
					headerData[i] ^= key[i % key.Length];
				return headerData;
			}

			bool GetKeyIv(byte[] headerData, out byte[] key, out byte[] iv) {
				var reader = new BinaryReader(new MemoryStream(headerData));

				/*var license =*/ reader.ReadString();
				bool isCompressed = reader.ReadBoolean();

				/*var unkData =*/ reader.ReadBytes(reader.ReadInt32());

				bool hasEmbeddedKey = reader.ReadBoolean();

				iv = reader.ReadBytes(reader.ReadByte());
				if (hasEmbeddedKey)
					key = reader.ReadBytes(reader.ReadByte());
				else {
					key = new byte[reader.ReadByte()];
					Array.Copy(module.Assembly.PublicKey.Data, 12, key, 0, key.Length);
					key[5] |= 0x80;
				}
				return isCompressed;
			}
		}

		public MethodDef DecryptMethod {
			set {
				if (value == null)
					return;
				if (decryptMethod == null) {
					decryptMethod = value;
					simpleDeobfuscator.Deobfuscate(decryptMethod);
				}
				else if (decryptMethod != value)
					throw new ApplicationException("Found another decrypter method");
			}
		}

		public static MethodDef FindDecrypterMethod(MethodDef method) {
			if (method == null || method.Body == null)
				return null;

			foreach (var instr in method.Body.Instructions) {
				if (instr.OpCode.Code != Code.Call)
					continue;
				var calledMethod = instr.Operand as MethodDef;
				if (calledMethod == null || !calledMethod.IsStatic || calledMethod.Body == null)
					continue;
				if (!DotNetUtils.IsMethod(calledMethod, "System.IO.MemoryStream", "(System.IO.Stream)"))
					continue;

				return calledMethod;
			}

			return null;
		}

		public byte[] Decrypt(byte[] encryptedData) {
			if (decrypter == null)
				decrypter = CreateDecrypter(encryptedData);
			return decrypter.Decrypt(encryptedData);
		}

		IDecrypter CreateDecrypter(byte[] encryptedData) {
			if (decryptMethod != null && DeobUtils.HasInteger(decryptMethod, 6))
				return new Decrypter3(module, decryptMethod);
			if (IsV30(encryptedData))
				return new Decrypter1(module);
			return new Decrypter2(module);
		}

		static bool IsV30(byte[] data) => data.Length > 10 && data[0] == 8 && data[9] <= 1 && data[10] == 8;
	}
}



================================================
File: de4dot.code/deobfuscators/Babel_NET/ResourceResolver.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.IO;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Babel_NET {
	class ResourceResolver {
		ModuleDefMD module;
		ResourceDecrypter resourceDecrypter;
		ISimpleDeobfuscator simpleDeobfuscator;
		TypeDef resolverType;
		MethodDef registerMethod;
		EmbeddedResource encryptedResource;
		bool hasXorKeys;
		int xorKey1, xorKey2;

		public bool Detected => resolverType != null;
		public TypeDef Type => resolverType;
		public MethodDef InitMethod => registerMethod;

		public ResourceResolver(ModuleDefMD module, ResourceDecrypter resourceDecrypter, ISimpleDeobfuscator simpleDeobfuscator) {
			this.module = module;
			this.resourceDecrypter = resourceDecrypter;
			this.simpleDeobfuscator = simpleDeobfuscator;
		}

		public void Find() {
			var requiredTypes = new string[] {
				"System.Reflection.Assembly",
				"System.Object",
				"System.Int32",
				"System.String[]",
			};
			foreach (var type in module.Types) {
				if (type.HasEvents)
					continue;
				if (!new FieldTypes(type).All(requiredTypes))
					continue;

				if (!BabelUtils.FindRegisterMethod(type, out var regMethod, out var handler))
					continue;

				var resource = BabelUtils.FindEmbeddedResource(module, type);
				if (resource == null)
					continue;

				var decryptMethod = FindDecryptMethod(type);
				if (decryptMethod == null)
					throw new ApplicationException("Couldn't find resource type decrypt method");
				resourceDecrypter.DecryptMethod = ResourceDecrypter.FindDecrypterMethod(decryptMethod);
				InitXorKeys(decryptMethod);

				resolverType = type;
				registerMethod = regMethod;
				encryptedResource = resource;
				return;
			}
		}

		static MethodDef FindDecryptMethod(TypeDef type) {
			foreach (var method in type.Methods) {
				if (!DotNetUtils.IsMethod(method, "System.Reflection.Assembly", "(System.IO.Stream)"))
					continue;
				return method;
			}
			return null;
		}

		void InitXorKeys(MethodDef method) {
			simpleDeobfuscator.Deobfuscate(method);
			var ints = new List<int>();
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count; i++) {
				var callvirt = instrs[i];
				if (callvirt.OpCode.Code != Code.Callvirt)
					continue;
				var calledMethod = callvirt.Operand as IMethod;
				if (calledMethod == null)
					continue;
				if (calledMethod.FullName != "System.Int32 System.IO.BinaryReader::ReadInt32()")
					continue;

				var ldci4 = instrs[i + 1];
				if (!ldci4.IsLdcI4())
					continue;

				if (instrs[i + 2].OpCode.Code != Code.Xor)
					continue;

				ints.Add(ldci4.GetLdcI4Value());
			}

			if (ints.Count == 2) {
				hasXorKeys = true;
				xorKey1 = ints[0];
				xorKey2 = ints[1];
			}
		}

		public EmbeddedResource MergeResources() {
			if (encryptedResource == null)
				return null;
			DeobUtils.DecryptAndAddResources(module, encryptedResource.Name.String, () => DecryptResourceAssembly());
			var result = encryptedResource;
			encryptedResource = null;
			return result;
		}

		byte[] DecryptResourceAssembly() {
			var decrypted = resourceDecrypter.Decrypt(encryptedResource.CreateReader().ToArray());
			var reader = new BinaryReader(new MemoryStream(decrypted));

			int numResources = reader.ReadInt32() ^ xorKey1;
			for (int i = 0; i < numResources; i++)
				reader.ReadString();

			int len;
			if (hasXorKeys)
				len = reader.ReadInt32() ^ xorKey2;
			else
				len = (int)(reader.BaseStream.Length - reader.BaseStream.Position);
			return reader.ReadBytes(len);
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Babel_NET/StringDecrypter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;
using de4dot.blocks.cflow;

namespace de4dot.code.deobfuscators.Babel_NET {
	class StringDecrypter {
		ModuleDefMD module;
		ResourceDecrypter resourceDecrypter;
		ISimpleDeobfuscator simpleDeobfuscator;
		TypeDef decrypterType;
		EmbeddedResource encryptedResource;
		IDecrypterInfo decrypterInfo;

		interface IDecrypterInfo {
			MethodDef Decrypter { get; }
			bool NeedsResource { get; }
			void Initialize(ModuleDefMD module, EmbeddedResource resource);
			string Decrypt(object[] args);
		}

		// Babel .NET 2.x
		class DecrypterInfoV1 : IDecrypterInfo {
			public MethodDef Decrypter { get; set; }
			public bool NeedsResource => false;
			public void Initialize(ModuleDefMD module, EmbeddedResource resource) { }
			public string Decrypt(object[] args) => Decrypt((string)args[0], (int)args[1]);

			string Decrypt(string s, int k) {
				var sb = new StringBuilder(s.Length);
				foreach (var c in s)
					sb.Append((char)(c ^ k));
				return sb.ToString();
			}
		}

		class DecrypterInfoV2 : IDecrypterInfo {
			byte[] key;

			public MethodDef Decrypter { get; set; }
			public bool NeedsResource => true;

			public void Initialize(ModuleDefMD module, EmbeddedResource resource) {
				key = resource.CreateReader().ToArray();
				if (key.Length != 0x100)
					throw new ApplicationException($"Unknown key length: {key.Length}");
			}

			public string Decrypt(object[] args) => Decrypt((string)args[0], (int)args[1]);

			string Decrypt(string s, int k) {
				var sb = new StringBuilder(s.Length);
				byte b = key[(byte)k];
				foreach (var c in s)
					sb.Append((char)(c ^ (b | k)));
				return sb.ToString();
			}
		}

		class DecrypterInfoV3 : IDecrypterInfo {
			Dictionary<int, string> offsetToString = new Dictionary<int, string>();
			ResourceDecrypter resourceDecrypter;
			InstructionEmulator emulator = new InstructionEmulator();

			public IList<Instruction> OffsetCalcInstructions { get; set; }
			public MethodDef Decrypter { get; set; }
			public bool NeedsResource => true;

			public DecrypterInfoV3(ResourceDecrypter resourceDecrypter) => this.resourceDecrypter = resourceDecrypter;

			public void Initialize(ModuleDefMD module, EmbeddedResource resource) {
				var decrypted = resourceDecrypter.Decrypt(resource.CreateReader().ToArray());
				var reader = new BinaryReader(new MemoryStream(decrypted));
				while (reader.BaseStream.Position < reader.BaseStream.Length)
					offsetToString[GetOffset((int)reader.BaseStream.Position)] = reader.ReadString();
			}

			MethodDef dummyMethod;
			int GetOffset(int offset) {
				if (OffsetCalcInstructions == null || OffsetCalcInstructions.Count == 0)
					return offset;
				if (dummyMethod == null) {
					dummyMethod = new MethodDefUser();
					dummyMethod.Body = new CilBody();
				}
				emulator.Initialize(dummyMethod);
				emulator.Push(new Int32Value(offset));
				foreach (var instr in OffsetCalcInstructions)
					emulator.Emulate(instr);
				return ((Int32Value)emulator.Pop()).Value;
			}

			public string Decrypt(object[] args) => Decrypt((int)args[0]);
			string Decrypt(int offset) => offsetToString[offset];
		}

		public bool Detected => decrypterType != null;
		public TypeDef Type => decrypterType;
		public MethodDef DecryptMethod => decrypterInfo?.Decrypter;
		public EmbeddedResource Resource => encryptedResource;

		public StringDecrypter(ModuleDefMD module, ResourceDecrypter resourceDecrypter) {
			this.module = module;
			this.resourceDecrypter = resourceDecrypter;
		}

		public void Find(ISimpleDeobfuscator simpleDeobfuscator) {
			this.simpleDeobfuscator = simpleDeobfuscator;
			foreach (var type in module.Types) {
				var info = CheckDecrypterType(type);
				if (info == null)
					continue;

				decrypterType = type;
				decrypterInfo = info;
				return;
			}
		}

		IDecrypterInfo CheckDecrypterType(TypeDef type) {
			if (type.HasEvents)
				return null;
			if (type.NestedTypes.Count > 2)
				return null;
			if (type.Fields.Count > 1)
				return null;

			foreach (var nested in type.NestedTypes) {
				var info = CheckNested(type, nested);
				if (info != null)
					return info;
			}

			return CheckDecrypterTypeBabel2x(type);
		}

		IDecrypterInfo CheckDecrypterTypeBabel2x(TypeDef type) {
			if (type.HasEvents || type.HasProperties || type.HasNestedTypes)
				return null;
			if (type.HasFields || type.Methods.Count != 1)
				return null;
			var decrypter = type.Methods[0];
			if (!CheckDecryptMethodBabel2x(decrypter))
				return null;

			return new DecrypterInfoV1 { Decrypter = decrypter };
		}

		bool CheckDecryptMethodBabel2x(MethodDef method) {
			if (!method.IsStatic || !method.IsPublic)
				return false;
			if (method.Body == null)
				return false;
			if (method.Name == ".cctor")
				return false;
			if (!DotNetUtils.IsMethod(method, "System.String", "(System.String,System.Int32)"))
				return false;

			int stringLength = 0, stringToCharArray = 0, stringCtor = 0;
			foreach (var instr in method.Body.Instructions) {
				var calledMethod = instr.Operand as IMethod;
				if (calledMethod == null)
					continue;

				switch (instr.OpCode.Code) {
				case Code.Call:
				case Code.Callvirt:
					if (calledMethod.FullName == "System.Int32 System.String::get_Length()")
						stringLength++;
					else if (calledMethod.FullName == "System.Char[] System.String::ToCharArray()")
						stringToCharArray++;
					else
						return false;
					break;

				case Code.Newobj:
					if (calledMethod.FullName == "System.Void System.String::.ctor(System.Char[])")
						stringCtor++;
					else
						return false;
					break;

				default:
					continue;
				}
			}

			return stringLength == 1 && stringToCharArray == 1 && stringCtor == 1;
		}

		IDecrypterInfo CheckNested(TypeDef type, TypeDef nested) {
			if (nested.HasProperties || nested.HasEvents)
				return null;

			if (nested.FindMethod(".ctor") == null)
				return null;

			if (nested.Fields.Count == 1 || nested.Fields.Count == 3) {
				// 4.0+

				if (!HasFieldType(nested.Fields, nested))
					return null;

				var decrypterBuilderMethod = DotNetUtils.GetMethod(nested, "System.Reflection.Emit.MethodBuilder", "(System.Reflection.Emit.TypeBuilder)");
				if (decrypterBuilderMethod == null)
					return null;

				resourceDecrypter.DecryptMethod = ResourceDecrypter.FindDecrypterMethod(nested.FindMethod(".ctor"));

				var nestedDecrypter = DotNetUtils.GetMethod(nested, "System.String", "(System.Int32)");
				if (nestedDecrypter == null || nestedDecrypter.IsStatic)
					return null;
				var decrypter = DotNetUtils.GetMethod(type, "System.String", "(System.Int32)");
				if (decrypter == null || !decrypter.IsStatic)
					return null;

				simpleDeobfuscator.Deobfuscate(decrypterBuilderMethod);
				return new DecrypterInfoV3(resourceDecrypter) {
					Decrypter = decrypter,
					OffsetCalcInstructions = GetOffsetCalcInstructions(decrypterBuilderMethod),
				};
			}
			else if (nested.Fields.Count == 2) {
				// 3.0 - 3.5

				if (CheckFields(nested, "System.Collections.Hashtable", nested)) {
					// 3.0 - 3.5
					var nestedDecrypter = DotNetUtils.GetMethod(nested, "System.String", "(System.Int32)");
					if (nestedDecrypter == null || nestedDecrypter.IsStatic)
						return null;
					var decrypter = DotNetUtils.GetMethod(type, "System.String", "(System.Int32)");
					if (decrypter == null || !decrypter.IsStatic)
						return null;

					resourceDecrypter.DecryptMethod = ResourceDecrypter.FindDecrypterMethod(nested.FindMethod(".ctor"));

					return new DecrypterInfoV3(resourceDecrypter) { Decrypter = decrypter };
				}
				else if (CheckFields(nested, "System.Byte[]", nested)) {
					// 3.0
					var nestedDecrypter = DotNetUtils.GetMethod(nested, "System.String", "(System.String,System.Int32)");
					if (nestedDecrypter == null || nestedDecrypter.IsStatic)
						return null;
					var decrypter = DotNetUtils.GetMethod(type, "System.String", "(System.String,System.Int32)");
					if (decrypter == null || !decrypter.IsStatic)
						return null;

					return new DecrypterInfoV2 { Decrypter = decrypter };
				}
				else
					return null;
			}

			return null;
		}

		class ReflectionToDNLibMethodCreator {
			MethodDef method;
			List<Instruction> instructions = new List<Instruction>();
			InstructionEmulator emulator;
			int index;

			class UserValue : UnknownValue {
				public readonly object obj;
				public UserValue(object obj) => this.obj = obj;
				public override string ToString() {
					if (obj == null)
						return "<null>";
					return obj.ToString();
				}
			}

			public List<Instruction> Instructions => instructions;

			public ReflectionToDNLibMethodCreator(MethodDef method) {
				this.method = method;
				emulator = new InstructionEmulator(method);
			}

			public bool Create() {
				int arrayIndex;
				Value array;
				object value;
				while (true) {
					var instr = method.Body.Instructions[index];
					switch (instr.OpCode.Code) {
					case Code.Ret:
						return true;

					case Code.Newarr:
						var arrayType = (ITypeDefOrRef)instr.Operand;
						int arrayCount = ((Int32Value)emulator.Pop()).Value;
						if (arrayType.FullName == "System.Char")
							emulator.Push(new UserValue(new char[arrayCount]));
						else
							emulator.Push(new UnknownValue());
						break;

					case Code.Call:
					case Code.Callvirt:
						if (!DoCall(instr))
							return false;
						break;

					case Code.Ldelem_U1:
						arrayIndex = ((Int32Value)emulator.Pop()).Value;
						array = (Value)emulator.Pop();
						if (array is UserValue)
							emulator.Push(new Int32Value(((byte[])((UserValue)array).obj)[arrayIndex]));
						else
							emulator.Push(Int32Value.CreateUnknownUInt8());
						break;

					case Code.Stelem_I1:
						value = emulator.Pop();
						arrayIndex = ((Int32Value)emulator.Pop()).Value;
						array = (Value)emulator.Pop();
						if (array is UserValue)
							((byte[])((UserValue)array).obj)[arrayIndex] = (byte)((Int32Value)value).Value;
						break;

					case Code.Stelem_I2:
						value = emulator.Pop();
						arrayIndex = ((Int32Value)emulator.Pop()).Value;
						array = (Value)emulator.Pop();
						if (array is UserValue)
							((char[])((UserValue)array).obj)[arrayIndex] = (char)((Int32Value)value).Value;
						break;

					case Code.Ldelem_Ref:
						arrayIndex = ((Int32Value)emulator.Pop()).Value;
						array = (Value)emulator.Pop();
						var userValue = array as UserValue;
						if (userValue != null && userValue.obj is string[])
							emulator.Push(new StringValue(((string[])userValue.obj)[arrayIndex]));
						else
							emulator.Push(new UnknownValue());
						break;

					case Code.Ldsfld:
						emulator.Push(new UserValue((IField)instr.Operand));
						break;

					default:
						emulator.Emulate(instr);
						break;
					}

					index++;
				}
			}

			bool DoCall(Instruction instr) {
				var calledMethod = (IMethod)instr.Operand;
				var sig = calledMethod.MethodSig;
				var fn = calledMethod.FullName;
				if (fn == "System.Byte[] System.Convert::FromBase64String(System.String)") {
					emulator.Push(new UserValue(Convert.FromBase64String(((StringValue)emulator.Pop()).value)));
					return true;
				}
				else if (fn == "System.String System.Text.Encoding::GetString(System.Byte[])") {
					emulator.Push(new StringValue(Encoding.UTF8.GetString((byte[])((UserValue)emulator.Pop()).obj)));
					return true;
				}
				else if (fn == "System.Int32 System.Int32::Parse(System.String)") {
					emulator.Push(new Int32Value(int.Parse(((StringValue)emulator.Pop()).value)));
					return true;
				}
				else if (fn == "System.String[] System.String::Split(System.Char[])") {
					var ary = (char[])((UserValue)emulator.Pop()).obj;
					var s = ((StringValue)emulator.Pop()).value;
					emulator.Push(new UserValue(s.Split(ary)));
					return true;
				}
				else if (sig != null && sig.HasThis && calledMethod.DeclaringType.FullName == "System.Reflection.Emit.ILGenerator" && calledMethod.Name == "Emit") {
					Value operand = null;
					if (calledMethod.MethodSig.GetParamCount() == 2)
						operand = emulator.Pop();
					var opcode = ReflectionToOpCode((IField)((UserValue)emulator.Pop()).obj);
					emulator.Pop();	// the this ptr
					AddInstruction(new Instruction {
						OpCode = opcode,
						Operand = CreateDNLibOperand(opcode, operand),
					});
					return true;
				}
				else {
					emulator.Emulate(instr);
					return true;
				}
			}

			object CreateDNLibOperand(OpCode opcode, Value op) {
				if (op is Int32Value)
					return ((Int32Value)op).Value;
				if (op is StringValue)
					return ((StringValue)op).value;
				return null;
			}

			void AddInstruction(Instruction instr) => instructions.Add(instr);

			static OpCode ReflectionToOpCode(IField reflectionField) {
				var field = typeof(OpCodes).GetField(reflectionField.Name.String);
				if (field == null || field.FieldType != typeof(OpCode))
					return null;
				return (OpCode)field.GetValue(null);
			}
		}

		static List<Instruction> GetOffsetCalcInstructions(MethodDef method) {
			var creator = new ReflectionToDNLibMethodCreator(method);
			creator.Create();
			var instrs = creator.Instructions;

			int index = 0;

			index = FindInstruction(instrs, index, OpCodes.Conv_I4);
			if (index < 0)
				return null;
			int startInstr = ++index;

			index = FindInstruction(instrs, index, OpCodes.Box);
			if (index < 0)
				return null;
			int endInstr = index - 1;

			var transformInstructions = new List<Instruction>();
			for (int i = startInstr; i <= endInstr; i++)
				transformInstructions.Add(instrs[i]);
			return transformInstructions;
		}

		static int FindInstruction(IList<Instruction> instrs, int index, OpCode opcode) {
			if (index < 0)
				return -1;
			for (int i = index; i < instrs.Count; i++) {
				if (instrs[i].OpCode == opcode)
					return i;
			}
			return -1;
		}

		static bool HasFieldType(IEnumerable<FieldDef> fields, TypeDef fieldType) {
			foreach (var field in fields) {
				if (new SigComparer().Equals(field.FieldSig.GetFieldType(), fieldType))
					return true;
			}
			return false;
		}

		static int GetOffsetMagic(MethodDef method) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 4; i++) {
				int index = i;

				var ldsfld1 = instrs[index++];
				if (ldsfld1.OpCode.Code != Code.Ldsfld)
					continue;

				var ldci4 = instrs[index++];
				if (!ldci4.IsLdcI4())
					continue;

				var callvirt = instrs[index++];
				if (callvirt.OpCode.Code != Code.Callvirt)
					continue;
				var calledMethod = callvirt.Operand as IMethod;
				if (calledMethod == null)
					continue;
				if (calledMethod.FullName != "System.Void System.Reflection.Emit.ILGenerator::Emit(System.Reflection.Emit.OpCode,System.Int32)")
					continue;

				if (!instrs[index++].IsLdloc())
					continue;

				var ldsfld2 = instrs[index++];
				if (ldsfld2.OpCode.Code != Code.Ldsfld)
					continue;
				var field = ldsfld2.Operand as IField;
				if (field == null)
					continue;
				if (field.FullName != "System.Reflection.Emit.OpCode System.Reflection.Emit.OpCodes::Xor")
					continue;

				// Here if Babel.NET 5.5
				return ldci4.GetLdcI4Value();
			}

			// Here if Babel.NET <= 5.0
			return 0;
		}

		bool CheckFields(TypeDef type, string fieldType1, TypeDef fieldType2) {
			if (type.Fields.Count != 2)
				return false;
			if (type.Fields[0].FieldSig.GetFieldType().GetFullName() != fieldType1 &&
				type.Fields[1].FieldSig.GetFieldType().GetFullName() != fieldType1)
				return false;
			if (!new SigComparer().Equals(type.Fields[0].FieldSig.GetFieldType(), fieldType2) &&
				!new SigComparer().Equals(type.Fields[1].FieldSig.GetFieldType(), fieldType2))
				return false;
			return true;
		}

		public void Initialize() {
			if (decrypterType == null)
				return;
			if (encryptedResource != null)
				return;

			if (decrypterInfo.NeedsResource) {
				encryptedResource = BabelUtils.FindEmbeddedResource(module, decrypterType);
				if (encryptedResource == null)
					return;
			}

			decrypterInfo.Initialize(module, encryptedResource);
		}

		public string Decrypt(object[] args) => decrypterInfo.Decrypt(args);
	}
}



================================================
File: de4dot.code/deobfuscators/CodeFort/AssemblyData.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Reflection.Emit;
using System.Text;

namespace de4dot.code.deobfuscators.CodeFort {
	interface ICFType {
		Type Get(SerializedTypes serializedTypes);
	}

	static class ITypeCreator {
		public static ICFType Create(string name) => new StringType(name);
		public static ICFType Create(Type type) => new ExistingType(type);
	}

	class StringType : ICFType {
		readonly string name;
		public StringType(string name) => this.name = name;
		public Type Get(SerializedTypes serializedTypes) => serializedTypes.GetBuilderType(name);
		public override string ToString() => name;
	}

	class ExistingType : ICFType {
		readonly Type type;
		public ExistingType(Type type) => this.type = type;
		public Type Get(SerializedTypes serializedTypes) => type;
		public override string ToString() => type.ToString();
	}

	class GenericType : ICFType {
		ICFType type;
		ICFType[] genericArgs;

		public GenericType(string type, ICFType[] genericArgs)
			: this(ITypeCreator.Create(type), genericArgs) {
		}

		public GenericType(Type type, ICFType[] genericArgs)
			: this(ITypeCreator.Create(type), genericArgs) {
		}

		public GenericType(ICFType type, ICFType[] genericArgs) {
			this.type = type;
			this.genericArgs = genericArgs;
		}

		public Type Get(SerializedTypes serializedTypes) {
			var genericType = type.Get(serializedTypes);
			var types = new List<Type>(genericArgs.Length);
			foreach (var ga in genericArgs)
				types.Add(ga.Get(serializedTypes));
			return genericType.MakeGenericType(types.ToArray());
		}

		public override string ToString() {
			var sb = new StringBuilder();
			sb.Append(GetTypeName());
			if (genericArgs != null && genericArgs.Length > 0) {
				sb.Append('<');
				for (int i = 0; i < genericArgs.Length; i++) {
					if (i != 0)
						sb.Append(',');
					sb.Append(genericArgs[i].ToString());
				}
				sb.Append('>');
			}
			return sb.ToString();
		}

		string GetTypeName() {
			var typeName = type.ToString();
			int index = typeName.LastIndexOf('`');
			if (index < 0)
				return typeName;
			return typeName.Substring(0, index);
		}
	}

	class ListType : GenericType {
		public ListType(string type)
			: this(ITypeCreator.Create(type)) {
		}

		public ListType(Type type)
			: this(ITypeCreator.Create(type)) {
		}

		public ListType(ICFType type)
			: base(typeof(List<>), new ICFType[] { type }) {
		}
	}

	class TypeInfoBase {
		public readonly string name;
		public readonly string dcNamespace;
		public readonly string dcName;

		protected TypeInfoBase(string name, string dcNamespace, string dcName) {
			this.name = name;
			this.dcNamespace = dcNamespace;
			this.dcName = dcName;
		}

		public override string ToString() {
			if (!string.IsNullOrEmpty(dcNamespace))
				return $"{name} - {dcNamespace}.{dcName}";
			return $"{name} - {dcName}";
		}
	}

	class TypeInfo : TypeInfoBase {
		public readonly ICFType baseType;
		public readonly TypeFieldInfo[] fieldInfos;

		public TypeInfo(string name, string dcName, TypeFieldInfo[] fieldInfos)
			: this(name, "", dcName, fieldInfos) {
		}

		public TypeInfo(string name, string dcNamespace, string dcName, TypeFieldInfo[] fieldInfos)
			: this(ITypeCreator.Create(typeof(object)), name, dcNamespace, dcName, fieldInfos) {
		}

		public TypeInfo(ICFType baseType, string name, string dcName, TypeFieldInfo[] fieldInfos)
			: this(baseType, name, "", dcName, fieldInfos) {
		}

		public TypeInfo(ICFType baseType, string name, string dcNamespace, string dcName, TypeFieldInfo[] fieldInfos)
			: base(name, dcNamespace, dcName) {
			this.baseType = baseType;
			this.fieldInfos = fieldInfos;
		}
	}

	class TypeFieldInfo {
		public readonly ICFType type;
		public readonly string name;
		public readonly string dmName;

		public TypeFieldInfo(string type, string name, string dmName)
			: this(ITypeCreator.Create(type), name, dmName) {
		}

		public TypeFieldInfo(Type type, string name, string dmName)
			: this(ITypeCreator.Create(type), name, dmName) {
		}

		public TypeFieldInfo(ICFType type, string name, string dmName) {
			this.type = type;
			this.name = name;
			this.dmName = dmName;
		}

		public override string ToString() => $"{type} {name} - {dmName}";
	}

	class EnumInfo : TypeInfoBase {
		public readonly EnumFieldInfo[] fieldInfos;
		public readonly Type underlyingType = typeof(int);

		public EnumInfo(string name, string dcName, EnumFieldInfo[] fieldInfos)
			: this(name, "", dcName, fieldInfos) {
		}

		public EnumInfo(string name, string dcNamespace, string dcName, EnumFieldInfo[] fieldInfos)
			: base(name, dcNamespace, dcName) => this.fieldInfos = fieldInfos;
	}

	class EnumFieldInfo {
		public readonly int value;
		public readonly string name;
		public readonly string emValue;

		public EnumFieldInfo(int value, string name, string emValue) {
			this.value = value;
			this.name = name;
			this.emValue = emValue;
		}

		public override string ToString() => $"({value}) {name} - {emValue}";
	}

	class SerializedTypes {
		const string serializationAssemblyname = "System.Runtime.Serialization, Version=3.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

		static readonly EnumInfo[] enumInfos = new EnumInfo[] {
			new EnumInfo("InstructionType", "a", new EnumFieldInfo[] {
				new EnumFieldInfo(0, "BeginCatchBlock", "1"),
				new EnumFieldInfo(1, "BeginExceptFilterBlock", "2"),
				new EnumFieldInfo(2, "BeginExceptionBlock", "3"),
				new EnumFieldInfo(3, "BeginFaultBlock", "4"),
				new EnumFieldInfo(4, "BeginFinallyBlock", "5"),
				new EnumFieldInfo(5, "BeginScope", "6"),
				new EnumFieldInfo(6, "LocalVariable", "7"),
				new EnumFieldInfo(7, "Label", "8"),
				new EnumFieldInfo(8, "NoOperand", "A"),
				new EnumFieldInfo(9, "ByteOperand", "B"),
				new EnumFieldInfo(10, "ConstructorOperand", "C"),
				new EnumFieldInfo(11, "DoubleOperand", "D"),
				new EnumFieldInfo(12, "FieldOperand", "E"),
				new EnumFieldInfo(13, "SingleOperand", "F"),
				new EnumFieldInfo(14, "Int32Operand", "G"),
				new EnumFieldInfo(15, "TargetOperand", "H"),
				new EnumFieldInfo(16, "TargetsOperand", "I"),
				new EnumFieldInfo(17, "LocalOperand", "J"),
				new EnumFieldInfo(18, "Int64Operand", "K"),
				new EnumFieldInfo(19, "MethodOperand", "L"),
				new EnumFieldInfo(20, "SByteOperand", "M"),
				new EnumFieldInfo(21, "Int16Operand", "N"),
				new EnumFieldInfo(22, "StringOperand", "O"),
				new EnumFieldInfo(23, "TypeOperand", "P"),
				new EnumFieldInfo(24, "EndExceptionBlock", "b"),
				new EnumFieldInfo(25, "EndScope", "c"),
				new EnumFieldInfo(26, "MarkLabel", "d"),
				new EnumFieldInfo(27, "NotImpl1", "e"),
				new EnumFieldInfo(28, "ThrowException", "f"),
				new EnumFieldInfo(29, "NotImpl2", "g"),
			}),

			new EnumInfo("MemberTypes1", "l", new EnumFieldInfo[] {
				new EnumFieldInfo(0, "Constructor", "1"),
				new EnumFieldInfo(1, "TypeInitializer", "7"),
				new EnumFieldInfo(2, "Method", "2"),
				new EnumFieldInfo(3, "Field", "3"),
				new EnumFieldInfo(4, "Property", "4"),
				new EnumFieldInfo(5, "Event", "5"),
				new EnumFieldInfo(6, "NestedType", "6"),
			}),
		};

		static readonly TypeInfo[] typeInfos = new TypeInfo[] {
			new TypeInfo("AllTypes", "b", new TypeFieldInfo[] {
				new TypeFieldInfo(new ListType("TypeDef"), "Types", "T"),
			}),

			new TypeInfo("Instruction", "c", new TypeFieldInfo[] {
				new TypeFieldInfo(typeof(object), "Operand", "A"),
				new TypeFieldInfo("InstructionType", "InstructionType", "K"),
				new TypeFieldInfo(typeof(string), "OpCode", "O"),
			}),

			new TypeInfo("InstructionLabel", "d", new TypeFieldInfo[] {
			}),

			new TypeInfo("LocalVariable", "e", new TypeFieldInfo[] {
				new TypeFieldInfo(typeof(bool), "IsPinned", "P"),
				new TypeFieldInfo("TypeRef", "VariableType", "T"),
			}),

			new TypeInfo("TypeRef", "f", new TypeFieldInfo[] {
				new TypeFieldInfo("AssemblyRef", "AssemblyRef", "A"),
				new TypeFieldInfo(typeof(string), "ReflectionTypeFullName", "F"),
				new TypeFieldInfo(new ListType("TypeRef"), "GenericArguments", "G"),
				new TypeFieldInfo("TypeDef", "InternalBaseType", "I"),
				new TypeFieldInfo(typeof(int?), "ArrayDimensions", "V"),
			}),

			new TypeInfo("AssemblyRef", "g", new TypeFieldInfo[] {
				new TypeFieldInfo(typeof(string), "Name", "N"),
			}),

			new TypeInfo("MemberRef", "h", new TypeFieldInfo[] {
				new TypeFieldInfo(typeof(int), "BindingFlags", "B"),
				new TypeFieldInfo("TypeRef", "DeclaringType", "C"),
				new TypeFieldInfo("MemberTypes1", "MemberTypes1", "K"),
				new TypeFieldInfo("MemberDef", "MemberDef", "M"),
				new TypeFieldInfo(typeof(string), "Name", "N"),
				new TypeFieldInfo("TypeRef", "ReturnType", "T"),
			}),

			new TypeInfo(ITypeCreator.Create("MemberRef"), "MethodRef", "i", new TypeFieldInfo[] {
				new TypeFieldInfo(new ListType("ParameterRef"), "Parameters", "P"),
				new TypeFieldInfo(typeof(int), "CallingConventions", "V"),
			}),

			new TypeInfo("ParameterRef", "j", new TypeFieldInfo[] {
				new TypeFieldInfo("TypeRef", "TypeRef", "T"),
			}),

			new TypeInfo("TypeDef", "k", new TypeFieldInfo[] {
				new TypeFieldInfo(typeof(int), "TypeAttributes", "A"),
				new TypeFieldInfo("TypeRef", "BaseType", "B"),
				new TypeFieldInfo(new ListType("TypeDef"), "NestedTypes", "E"),
				new TypeFieldInfo(new ListType("MemberDef"), "Members", "M"),
				new TypeFieldInfo(typeof(string), "Name", "N"),
			}),

			new TypeInfo("MemberDef", "m", new TypeFieldInfo[] {
				new TypeFieldInfo(typeof(int), "Attributes", "B"),
				new TypeFieldInfo("MemberTypes1", "MemberTypes1", "K"),
				new TypeFieldInfo(typeof(string), "Name", "N"),
				new TypeFieldInfo("TypeRef", "Type", "T"),
			}),

			new TypeInfo(ITypeCreator.Create("MemberDef"), "PropertyDef", "n", new TypeFieldInfo[] {
				new TypeFieldInfo("MethodDef", "GetMethod", "G"),
				new TypeFieldInfo(new ListType("ParameterDef"), "ParameterTypes", "P"),
				new TypeFieldInfo("MethodDef", "SetMethod", "S"),
			}),

			new TypeInfo(ITypeCreator.Create("MemberDef"), "EventDef", "o", new TypeFieldInfo[] {
				new TypeFieldInfo("MethodDef", "AddOnMethod", "A"),
				new TypeFieldInfo("MethodDef", "RemoveOnMethod", "R"),
			}),

			new TypeInfo(ITypeCreator.Create("MemberDef"), "MethodDef", "p", new TypeFieldInfo[] {
				new TypeFieldInfo(new ListType("Instruction"), "Instructions", "A"),
				new TypeFieldInfo(typeof(CallingConventions), "CallingConventions", "C"),
				new TypeFieldInfo(typeof(MethodImplAttributes), "MethodImplAttributes", "I"),
				new TypeFieldInfo(new ListType("ParameterDef"), "ParameterTypes", "P"),
			}),

			new TypeInfo("ParameterDef", "q", new TypeFieldInfo[] {
				new TypeFieldInfo(typeof(string), "Name", "N"),
				new TypeFieldInfo("TypeRef", "TypeRef", "T"),
			}),
		};

		class PropertyInfoCreator {
			Type type;
			List<PropertyInfo> properties = new List<PropertyInfo>();
			List<object> values = new List<object>();

			public PropertyInfo[] Properties => properties.ToArray();
			public object[] Values => values.ToArray();
			public PropertyInfoCreator(Type type) => this.type = type;

			public void Add(string propertyName, object value) {
				var prop = type.GetProperty(propertyName);
				if (prop == null)
					throw new ApplicationException($"Could not find property {propertyName} (type {type})");
				properties.Add(prop);
				values.Add(value);
			}
		}

		ModuleBuilder moduleBuilder;
		Dictionary<string, EnumBuilder> enumBuilders = new Dictionary<string, EnumBuilder>(StringComparer.Ordinal);
		Dictionary<string, TypeBuilder> typeBuilders = new Dictionary<string, TypeBuilder>(StringComparer.Ordinal);
		Dictionary<string, Type> createdTypes = new Dictionary<string, Type>(StringComparer.Ordinal);

		public SerializedTypes(ModuleBuilder moduleBuilder) {
			this.moduleBuilder = moduleBuilder;
			CreateTypeBuilders();
			InitializeEnums();
			InitializeTypes();
			CreateTypes();
		}

		void CreateTypeBuilders() {
			foreach (var info in enumInfos)
				Add(info.name, moduleBuilder.DefineEnum(info.name, TypeAttributes.Public, info.underlyingType));
			foreach (var info in typeInfos)
				Add(info.name, moduleBuilder.DefineType(info.name, TypeAttributes.Public, info.baseType.Get(this)));
		}

		CustomAttributeBuilder CreateDataContractAttribute(string ns, string name, bool isReference) {
			var dcAttr = Type.GetType("System.Runtime.Serialization.DataContractAttribute," + serializationAssemblyname);
			var ctor = dcAttr.GetConstructor(Type.EmptyTypes);
			var propCreator = new PropertyInfoCreator(dcAttr);
			propCreator.Add("Namespace", ns);
			propCreator.Add("Name", name);
			propCreator.Add("IsReference", isReference);
			return new CustomAttributeBuilder(ctor, new object[0], propCreator.Properties, propCreator.Values);
		}

		CustomAttributeBuilder CreateEnumMemberAttribute(string value) {
			var emAttr = Type.GetType("System.Runtime.Serialization.EnumMemberAttribute," + serializationAssemblyname);
			var ctor = emAttr.GetConstructor(Type.EmptyTypes);
			var propCreator = new PropertyInfoCreator(emAttr);
			propCreator.Add("Value", value);
			return new CustomAttributeBuilder(ctor, new object[0], propCreator.Properties, propCreator.Values);
		}

		CustomAttributeBuilder CreateDataMemberAttribute(string name, bool emitDefaultValue) {
			var dmAttr = Type.GetType("System.Runtime.Serialization.DataMemberAttribute," + serializationAssemblyname);
			var ctor = dmAttr.GetConstructor(Type.EmptyTypes);
			var propCreator = new PropertyInfoCreator(dmAttr);
			propCreator.Add("Name", name);
			propCreator.Add("EmitDefaultValue", emitDefaultValue);
			return new CustomAttributeBuilder(ctor, new object[0], propCreator.Properties, propCreator.Values);
		}

		void Add(string name, EnumBuilder builder) {
			if (enumBuilders.ContainsKey(name))
				throw new ApplicationException($"Enum {name} already exists");
			enumBuilders[name] = builder;
		}

		void Add(string name, TypeBuilder builder) {
			if (typeBuilders.ContainsKey(name))
				throw new ApplicationException($"Type {name} already exists");
			typeBuilders[name] = builder;
		}

		void InitializeEnums() {
			foreach (var info in enumInfos) {
				var builder = enumBuilders[info.name];
				builder.SetCustomAttribute(CreateDataContractAttribute(info.dcNamespace, info.dcName, false));
				foreach (var fieldInfo in info.fieldInfos) {
					var fieldBuilder = builder.DefineLiteral(fieldInfo.name, fieldInfo.value);
					fieldBuilder.SetCustomAttribute(CreateEnumMemberAttribute(fieldInfo.emValue));
				}
			}
		}

		void InitializeTypes() {
			foreach (var info in typeInfos) {
				var builder = typeBuilders[info.name];
				builder.SetCustomAttribute(CreateDataContractAttribute(info.dcNamespace, info.dcName, true));
				foreach (var fieldInfo in info.fieldInfos) {
					var fieldBuilder = builder.DefineField(fieldInfo.name, fieldInfo.type.Get(this), FieldAttributes.Public);
					fieldBuilder.SetCustomAttribute(CreateDataMemberAttribute(fieldInfo.dmName, false));
				}
			}
		}

		void CreateTypes() {
			foreach (var info in enumInfos) {
				var builder = enumBuilders[info.name];
#if NETFRAMEWORK
				var type = builder.CreateType();
#else
				var type = builder.CreateTypeInfo();
#endif
				createdTypes[info.name] = type;
			}
			foreach (var info in typeInfos)
				createdTypes[info.name] = typeBuilders[info.name].CreateType();
			moduleBuilder = null;
			enumBuilders = null;
			typeBuilders = null;
		}

		public Type GetBuilderType(string name) {
			if (enumBuilders.TryGetValue(name, out var enumBuilder))
				return enumBuilder;

			if (typeBuilders.TryGetValue(name, out var typeBuilder))
				return typeBuilder;

			throw new ApplicationException($"Could not find type {name}");
		}

		Type GetType(string name) => createdTypes[name];

		public object Deserialize(byte[] data) {
			var serializerType = Type.GetType("System.Runtime.Serialization.DataContractSerializer," + serializationAssemblyname);
			if (serializerType == null)
				throw new ApplicationException("You need .NET 3.0 or later to decrypt the assembly");
			var quotasType = Type.GetType("System.Xml.XmlDictionaryReaderQuotas," + serializationAssemblyname);
			var serializerCtor = serializerType.GetConstructor(new Type[] { typeof(Type), typeof(IEnumerable<Type>) });
			var serializer = serializerCtor.Invoke(new object[] { GetType("AllTypes"), new Type[] {
				GetType("MemberTypes1"),
				GetType("Instruction"),
				GetType("InstructionType"),
				GetType("InstructionLabel"),
				GetType("LocalVariable"),
				GetType("ParameterDef"),
				GetType("TypeDef"),
				GetType("MemberDef"),
				GetType("MethodDef"),
				GetType("EventDef"),
				GetType("PropertyDef"),
				GetType("ParameterRef"),
				GetType("TypeRef"),
				GetType("MemberRef"),
				GetType("MethodRef"),
			}});

			var xmlReaderType = Type.GetType("System.Xml.XmlDictionaryReader," + serializationAssemblyname);
			var createReaderMethod = xmlReaderType.GetMethod("CreateBinaryReader", new Type[] { typeof(Stream), quotasType });
			var xmlReader = createReaderMethod.Invoke(null, new object[] {
				new MemoryStream(data),
				quotasType.InvokeMember("Max", BindingFlags.GetProperty, null, null, new object[0]),
			});
			using ((IDisposable)xmlReader) {
				var readObjectMethod = serializerType.GetMethod("ReadObject", new Type[] { xmlReaderType });
				return readObjectMethod.Invoke(serializer, new object[] { xmlReader });
			}
		}
	}
}



================================================
File: de4dot.code/deobfuscators/CodeFort/AssemblyDecrypter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.IO;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.CodeFort {
	class AssemblyDecrypter {
		ModuleDefMD module;
		EmbeddedResource assemblyEncryptedResource;
		PasswordInfo embedPassword;
		MethodDef embedInitMethod;
		MethodDef embedResolverMethod;

		public class AssemblyInfo {
			public readonly byte[] data;
			public readonly EmbeddedResource resource;
			public readonly string asmFullName;
			public readonly string asmSimpleName;
			public readonly string extension;

			public AssemblyInfo(byte[] data, EmbeddedResource resource, string asmFullName, string asmSimpleName, string extension) {
				this.data = data;
				this.resource = resource;
				this.asmFullName = asmFullName;
				this.asmSimpleName = asmSimpleName;
				this.extension = extension;
			}

			public override string ToString() => asmFullName;
		}

		public bool EncryptedDetected => assemblyEncryptedResource != null;
		public bool MainAssemblyHasAssemblyResolver => embedInitMethod != null;
		public bool Detected => EncryptedDetected || MainAssemblyHasAssemblyResolver;
		public TypeDef Type => embedInitMethod?.DeclaringType;
		public MethodDef InitMethod => embedInitMethod;

		public AssemblyDecrypter(ModuleDefMD module) => this.module = module;

		public AssemblyDecrypter(ModuleDefMD module, AssemblyDecrypter oldOne) {
			this.module = module;
			embedPassword = oldOne.embedPassword;
		}

		public void Find() {
			if (FindEncrypted())
				return;
			FindEmbedded();
		}

		static readonly string[] encryptedRequiredLocals = new string[] {
			"System.Byte",
			"System.Byte[]",
			"System.Int32",
			"System.IO.BinaryReader",
			"System.IO.MemoryStream",
			"System.IO.Stream",
			"System.Object[]",
			"System.Reflection.Assembly",
			"System.Type[]",
		};
		bool FindEncrypted() {
			var ep = module.EntryPoint;
			if (ep == null || ep.Body == null)
				return false;
			if (!DotNetUtils.IsMethod(ep, "System.Void", "(System.String[])"))
				return false;
			var initMethod = CheckCalledMethods(ep);
			if (initMethod == null || !new LocalTypes(initMethod).All(encryptedRequiredLocals))
				return false;
			var resource = GetResource();
			if (resource == null)
				return false;

			assemblyEncryptedResource = resource;
			return true;
		}

		MethodDef CheckCalledMethods(MethodDef method) {
			int calls = 0;
			TypeDef type = null;
			MethodDef initMethod = null;
			foreach (var calledMethod in DotNetUtils.GetCalledMethods(module, method)) {
				calls++;
				if (type != null && calledMethod.DeclaringType != type)
					return null;
				type = calledMethod.DeclaringType;
				if (initMethod == null)
					initMethod = calledMethod;
			}
			if (calls != 2)
				return null;
			return initMethod;
		}

		EmbeddedResource GetResource() => DotNetUtils.GetResource(module, "_") as EmbeddedResource;
		bool FindEmbedded() => FindEmbedded(DotNetUtils.GetModuleTypeCctor(module)) || FindEmbedded(module.EntryPoint);

		bool FindEmbedded(MethodDef method) {
			if (method == null || method.Body == null)
				return false;
			foreach (var calledMethod in DotNetUtils.GetCalledMethods(module, method)) {
				var resolver = CheckInitMethod(calledMethod);
				if (resolver == null)
					continue;
				if (!CheckType(calledMethod.DeclaringType))
					continue;

				embedInitMethod = calledMethod;
				embedResolverMethod = resolver;
				return true;
			}

			return false;
		}

		MethodDef CheckInitMethod(MethodDef method) {
			if (method == null || !method.IsStatic || method.Body == null)
				return null;
			if (!DotNetUtils.IsMethod(method, "System.Void", "()"))
				return null;

			var resolver = DeobUtils.GetResolveMethod(method);
			if (resolver == null || resolver.DeclaringType != method.DeclaringType)
				return null;

			return resolver;
		}

		bool CheckType(TypeDef type) {
			if (DotNetUtils.GetMethod(type, "System.Byte[]", "(System.Byte[],System.String,System.String,System.Int32,System.String,System.Int32)") == null)
				return false;
			if (DotNetUtils.GetMethod(type, "System.String", "(System.String)") == null)
				return false;
			if (DotNetUtils.GetMethod(type, "System.Byte[]", "(System.Reflection.Assembly,System.String)") == null)
				return false;
			if (DotNetUtils.GetMethod(type, "System.Void", "(System.IO.Stream,System.IO.Stream)") == null)
				return false;

			return true;
		}

		public byte[] Decrypt() {
			if (assemblyEncryptedResource == null)
				return null;

			var reader = new BinaryReader(assemblyEncryptedResource.CreateReader().AsStream());
			var encryptedData = DeobUtils.Gunzip(reader.BaseStream, reader.ReadInt32());
			reader = new BinaryReader(new MemoryStream(encryptedData));
			var serializedData = reader.ReadBytes(reader.ReadInt32());
			for (int i = 0; i < serializedData.Length; i++)
				serializedData[i] ^= 0xAD;
			var encryptedAssembly = reader.ReadBytes((int)(reader.BaseStream.Length - reader.BaseStream.Position));

			var passwordFinder = new PasswordFinder(serializedData);
			passwordFinder.Find(out var mainAsmPassword, out embedPassword);

			return Decrypt(mainAsmPassword, encryptedAssembly);
		}

		static byte[] Decrypt(PasswordInfo password, byte[] data) {
			const int iterations = 2;
			const int numBits = 0x100;
			var key = new Rfc2898DeriveBytes(password.passphrase, Encoding.UTF8.GetBytes(password.salt), iterations).GetBytes(numBits / 8);
			return DeobUtils.AesDecrypt(data, key, Encoding.UTF8.GetBytes(password.iv));
		}

		static byte[] Gunzip(byte[] data) {
			var reader = new BinaryReader(new MemoryStream(data));
			return DeobUtils.Gunzip(reader.BaseStream, reader.ReadInt32());
		}

		public List<AssemblyInfo> GetAssemblyInfos(ISimpleDeobfuscator simpleDeobfuscator, IDeobfuscator deob) {
			var infos = new List<AssemblyInfo>();

			if (embedResolverMethod != null) {
				simpleDeobfuscator.Deobfuscate(embedResolverMethod);
				simpleDeobfuscator.DecryptStrings(embedResolverMethod, deob);
				embedPassword = GetEmbedPassword(embedResolverMethod);
			}

			if (embedPassword == null)
				return infos;

			foreach (var rsrc in module.Resources) {
				var resource = rsrc as EmbeddedResource;
				if (resource == null)
					continue;
				if (!Regex.IsMatch(resource.Name.String, "^cfd_([0-9a-f]{2})+_$"))
					continue;

				var asmData = Decrypt(embedPassword, Gunzip(resource.CreateReader().ToArray()));
				var mod = ModuleDefMD.Load(asmData);
				infos.Add(new AssemblyInfo(asmData, resource, mod.Assembly.FullName, mod.Assembly.Name.String, DeobUtils.GetExtension(mod.Kind)));
			}

			return infos;
		}

		static PasswordInfo GetEmbedPassword(MethodDef method) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 3; i++) {
				int index = i;

				var ldstr1 = instrs[index++];
				if (ldstr1.OpCode.Code != Code.Ldstr)
					continue;
				var passphrase = GetString(ldstr1, instrs, ref index);

				var ldstr2 = instrs[index++];
				if (ldstr2.OpCode.Code != Code.Ldstr)
					continue;
				var salt = GetString(ldstr2, instrs, ref index);

				var ldci4 = instrs[index++];
				if (!ldci4.IsLdcI4())
					continue;

				var ldstr3 = instrs[index++];
				if (ldstr3.OpCode.Code != Code.Ldstr)
					continue;
				var iv = GetString(ldstr3, instrs, ref index);

				return new PasswordInfo(passphrase, salt, iv);
			}

			return null;
		}

		static string GetString(Instruction ldstr, IList<Instruction> instrs, ref int index) {
			var s = (string)ldstr.Operand;
			if (index >= instrs.Count)
				return s;
			var call = instrs[index];
			if (call.OpCode.Code != Code.Call && call.OpCode.Code != Code.Callvirt)
				return s;
			index++;
			var calledMethod = call.Operand as IMethod;
			if (calledMethod.Name.String == "ToUpper")
				return s.ToUpper();
			if (calledMethod.Name.String == "ToLower")
				return s.ToLower();
			throw new ApplicationException($"Unknown method {calledMethod}");
		}
	}
}



================================================
File: de4dot.code/deobfuscators/CodeFort/CfMethodCallInliner.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using dnlib.DotNet;
using de4dot.blocks.cflow;

namespace de4dot.code.deobfuscators.CodeFort {
	class CfMethodCallInliner : MethodCallInliner {
		ProxyCallFixer proxyCallFixer;
		public CfMethodCallInliner(ProxyCallFixer proxyCallFixer) : base(false) => this.proxyCallFixer = proxyCallFixer;
		protected override bool CanInline(MethodDef method) => proxyCallFixer.IsProxyTargetMethod(method);
		protected override bool IsCompatibleType(int paramIndex, IType origType, IType newType) => true;
	}
}



================================================
File: de4dot.code/deobfuscators/CodeFort/Deobfuscator.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.CodeFort {
	public class DeobfuscatorInfo : DeobfuscatorInfoBase {
		public const string THE_NAME = "CodeFort";
		public const string THE_TYPE = "cf";
		const string DEFAULT_REGEX = @"!^[a-zA-Z]{1,3}$&!^[_<>{}$.`-]$&" + DeobfuscatorBase.DEFAULT_ASIAN_VALID_NAME_REGEX;
		BoolOption dumpEmbeddedAssemblies;

		public DeobfuscatorInfo() : base(DEFAULT_REGEX) =>
			dumpEmbeddedAssemblies = new BoolOption(null, MakeArgName("embedded"), "Dump embedded assemblies", true);

		public override string Name => THE_NAME;
		public override string Type => THE_TYPE;

		public override IDeobfuscator CreateDeobfuscator() =>
			new Deobfuscator(new Deobfuscator.Options {
				ValidNameRegex = validNameRegex.Get(),
				DumpEmbeddedAssemblies = dumpEmbeddedAssemblies.Get(),
			});

		protected override IEnumerable<Option> GetOptionsInternal() =>
			new List<Option>() {
				dumpEmbeddedAssemblies,
			};
	}

	class Deobfuscator : DeobfuscatorBase {
		Options options;
		ProxyCallFixer proxyCallFixer;
		StringDecrypter stringDecrypter;
		AssemblyDecrypter assemblyDecrypter;
		CfMethodCallInliner cfMethodCallInliner;

		internal class Options : OptionsBase {
			public bool DumpEmbeddedAssemblies { get; set; }
		}

		public override string Type => DeobfuscatorInfo.THE_TYPE;
		public override string TypeLong => DeobfuscatorInfo.THE_NAME;
		public override string Name => DeobfuscatorInfo.THE_NAME;

		public Deobfuscator(Options options) : base(options) => this.options = options;

		protected override int DetectInternal() {
			int val = 0;

			int sum = ToInt32(proxyCallFixer.Detected) +
					ToInt32(stringDecrypter.Detected) +
					ToInt32(assemblyDecrypter.Detected);
			if (sum > 0)
				val += 100 + 10 * (sum - 1);

			return val;
		}

		protected override void ScanForObfuscator() {
			proxyCallFixer = new ProxyCallFixer(module);
			proxyCallFixer.FindDelegateCreator();
			stringDecrypter = new StringDecrypter(module);
			stringDecrypter.Find();
			assemblyDecrypter = new AssemblyDecrypter(module);
			assemblyDecrypter.Find();
		}

		public override bool GetDecryptedModule(int count, ref byte[] newFileData, ref DumpedMethods dumpedMethods) {
			if (count != 0 || !assemblyDecrypter.EncryptedDetected)
				return false;

			newFileData = assemblyDecrypter.Decrypt();
			return newFileData != null;
		}

		public override IDeobfuscator ModuleReloaded(ModuleDefMD module) {
			var newOne = new Deobfuscator(options);
			newOne.SetModule(module);
			newOne.proxyCallFixer = new ProxyCallFixer(module);
			newOne.proxyCallFixer.FindDelegateCreator();
			newOne.stringDecrypter = new StringDecrypter(module);
			newOne.stringDecrypter.Find();
			newOne.assemblyDecrypter = new AssemblyDecrypter(module, assemblyDecrypter);
			newOne.assemblyDecrypter.Find();
			return newOne;
		}

		public override void DeobfuscateBegin() {
			base.DeobfuscateBegin();

			staticStringInliner.Add(stringDecrypter.Method, (method, gim, args) => stringDecrypter.Decrypt((string)args[0]));
			DeobfuscatedFile.StringDecryptersAdded();

			proxyCallFixer.Find();
			cfMethodCallInliner = new CfMethodCallInliner(proxyCallFixer);

			DumpEmbeddedAssemblies();
		}

		void DumpEmbeddedAssemblies() {
			if (assemblyDecrypter.MainAssemblyHasAssemblyResolver && !options.DumpEmbeddedAssemblies)
				return;
			foreach (var info in assemblyDecrypter.GetAssemblyInfos(DeobfuscatedFile, this)) {
				DeobfuscatedFile.CreateAssemblyFile(info.data, info.asmSimpleName, info.extension);
				AddResourceToBeRemoved(info.resource, $"Embedded assembly: {info.asmFullName}");
			}
			AddCctorInitCallToBeRemoved(assemblyDecrypter.InitMethod);
			AddCallToBeRemoved(module.EntryPoint, assemblyDecrypter.InitMethod);
			AddTypeToBeRemoved(assemblyDecrypter.Type, "Assembly resolver type");
		}

		public override void DeobfuscateMethodEnd(Blocks blocks) {
			proxyCallFixer.Deobfuscate(blocks);
			InlineMethods(blocks);
			base.DeobfuscateMethodEnd(blocks);
		}

		void InlineMethods(Blocks blocks) {
			cfMethodCallInliner.DeobfuscateBegin(blocks);
			cfMethodCallInliner.Deobfuscate(blocks.MethodBlocks.GetAllBlocks());
		}

		public override void DeobfuscateEnd() {
			RemoveProxyDelegates(proxyCallFixer);
			AddTypeToBeRemoved(proxyCallFixer.ProxyMethodsType, "Type with proxy methods");
			if (CanRemoveStringDecrypterType)
				AddTypeToBeRemoved(stringDecrypter.Type, "String decrypter type");
			base.DeobfuscateEnd();
		}

		public override IEnumerable<int> GetStringDecrypterMethods() {
			var list = new List<int>();
			if (stringDecrypter.Method != null)
				list.Add(stringDecrypter.Method.MDToken.ToInt32());
			return list;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/CodeFort/PasswordFinder.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Reflection;
using System.Reflection.Emit;

namespace de4dot.code.deobfuscators.CodeFort {
	class PasswordInfo {
		public string passphrase;
		public string salt;
		public string iv;

		public PasswordInfo(string passphrase, string salt, string iv) {
			this.passphrase = passphrase;
			this.salt = salt;
			this.iv = iv;
		}

		public override string ToString() => $"P:{passphrase}, S:{salt}, I:{iv}";
	}

	class PasswordFinder {
		byte[] serializedData;
		System.Collections.IList asmTypes;

		class Obj {
			object obj;

			public Obj(object obj) => this.obj = obj;
			public string Name => (string)ReadField("Name");
			public List<Obj> Members => GetList("Members");
			public List<Obj> Instructions => GetList("Instructions");
			public object Operand => ReadField("Operand");
			public string OpCode => (string)ReadField("OpCode");
			public Obj MemberDef => new Obj(ReadField("MemberDef"));
			protected object ReadField(string name) => PasswordFinder.ReadField(obj, name);

			public Obj FindMethod(string name) {
				foreach (var member in Members) {
					if (member.obj.GetType().ToString() != "MethodDef")
						continue;
					if (member.Name != name)
						continue;

					return member;
				}

				throw new ApplicationException($"Could not find method {name}");
			}

			List<Obj> GetList(string name) => ConvertList((System.Collections.IList)ReadField(name));

			static List<Obj> ConvertList(System.Collections.IList inList) {
				var outList = new List<Obj>(inList.Count);
				foreach (var e in inList)
					outList.Add(new Obj(e));
				return outList;
			}

			public override string ToString() => Name;
		}

		public PasswordFinder(byte[] serializedData) => this.serializedData = serializedData;
		static object ReadField(object instance, string name) => instance.GetType().GetField(name).GetValue(instance);
		static System.Collections.IList ToList(object obj) => (System.Collections.IList)obj;

		public void Find(out PasswordInfo mainAsmPassword, out PasswordInfo embedPassword) {
			var asmName = new AssemblyName("asm");
			const AssemblyBuilderAccess BuilderAccess = AssemblyBuilderAccess.Run;
#if NETFRAMEWORK
			var asmBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(asmName, BuilderAccess);
#else
			var asmBuilder = AssemblyBuilder.DefineDynamicAssembly(asmName, BuilderAccess);
#endif
			var moduleBuilder = asmBuilder.DefineDynamicModule("mod");
			var serializedTypes = new SerializedTypes(moduleBuilder);
			var allTypes = serializedTypes.Deserialize(serializedData);
			asmTypes = ToList(ReadField(allTypes, "Types"));

			mainAsmPassword = FindMainAssemblyPassword();
			embedPassword = FindEmbedPassword();
		}

		Obj FindType(string name) {
			foreach (var tmp in asmTypes) {
				var type = new Obj(tmp);
				if (type.Name == name)
					return type;
			}
			return null;
		}

		PasswordInfo FindMainAssemblyPassword() {
			var type = FindType("BootstrapDynArguments");
			var cctor = type.FindMethod(".cctor");
			var instrs = cctor.Instructions;
			var passphrase = FindStringStoreValue(instrs, "KeyPassphrase");
			var salt = FindStringStoreValue(instrs, "KeySaltValue");
			var iv = FindStringStoreValue(instrs, "KeyIV");
			return new PasswordInfo(passphrase, salt, iv);
		}

		static string FindStringStoreValue(List<Obj> instrs, string fieldName) {
			for (int i = 0; i < instrs.Count - 1; i++) {
				var ldstr = instrs[i];
				if (ldstr.OpCode != "ldstr")
					continue;
				var stsfld = instrs[i + 1];
				if (stsfld.OpCode != "stsfld")
					continue;
				var memberRef = new Obj(stsfld.Operand);
				if (memberRef.MemberDef == null)
					continue;
				if (memberRef.MemberDef.Name != fieldName)
					continue;

				return (string)ldstr.Operand;
			}

			return null;
		}

		PasswordInfo FindEmbedPassword() {
			var type = FindType("CilEmbeddingHelper");
			if (type == null)
				return null;
			var method = type.FindMethod("CurrentDomain_AssemblyResolve");
			var instrs = method.Instructions;
			for (int i = 0; i < instrs.Count - 3; i++) {
				int index = i;

				var ldstr1 = instrs[index++];
				if (ldstr1.OpCode != "ldstr")
					continue;
				var passphrase = GetString(ldstr1, instrs, ref index);

				var ldstr2 = instrs[index++];
				if (ldstr2.OpCode != "ldstr")
					continue;
				var salt = GetString(ldstr2, instrs, ref index);

				var ldc = instrs[index++];
				if (!ldc.OpCode.StartsWith("ldc.i4"))
					continue;

				var ldstr3 = instrs[index++];
				if (ldstr3.OpCode != "ldstr")
					continue;
				var iv = GetString(ldstr3, instrs, ref index);

				return new PasswordInfo(passphrase, salt, iv);
			}

			return null;
		}

		static string GetString(Obj ldstr, List<Obj> instrs, ref int index) {
			var s = (string)ldstr.Operand;
			if (index >= instrs.Count)
				return s;
			var call = instrs[index];
			if (call.OpCode != "call" && call.OpCode != "callvirt")
				return s;
			index++;
			var op = new Obj(call.Operand);
			if (op.Name == "ToUpper")
				return s.ToUpper();
			if (op.Name == "ToLower")
				return s.ToLower();
			throw new ApplicationException($"Unknown method {op.Name}");
		}
	}
}



================================================
File: de4dot.code/deobfuscators/CodeFort/ProxyCallFixer.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.CodeFort {
	class ProxyCallFixer : ProxyCallFixer3 {
		MethodDefAndDeclaringTypeDict<bool> proxyTargetMethods = new MethodDefAndDeclaringTypeDict<bool>();
		TypeDef proxyMethodsType;

		public TypeDef ProxyMethodsType => proxyMethodsType;
		public ProxyCallFixer(ModuleDefMD module) : base(module) { }
		public bool IsProxyTargetMethod(IMethod method) => proxyTargetMethods.Find(method);

		public void FindDelegateCreator() {
			foreach (var type in module.Types) {
				var creatorMethod = CheckType(type);
				if (creatorMethod == null)
					continue;

				SetDelegateCreatorMethod(creatorMethod);
				return;
			}
		}

		static MethodDef CheckType(TypeDef type) {
			if (type.Fields.Count != 1)
				return null;
			if (type.Fields[0].FieldSig.GetFieldType().GetFullName() != "System.Reflection.Module")
				return null;
			return CheckMethods(type);
		}

		static MethodDef CheckMethods(TypeDef type) {
			if (type.Methods.Count != 3)
				return null;

			MethodDef creatorMethod = null;
			foreach (var method in type.Methods) {
				if (method.Name == ".cctor")
					continue;
				if (DotNetUtils.IsMethod(method, "System.Void", "(System.Int32)")) {
					creatorMethod = method;
					continue;
				}
				if (DotNetUtils.IsMethod(method, "System.MulticastDelegate", "(System.Type,System.Reflection.MethodInfo,System.Int32)"))
					continue;

				return null;
			}
			return creatorMethod;
		}

		protected override object CheckCctor(ref TypeDef type, MethodDef cctor) {
			var instrs = cctor.Body.Instructions;
			if (instrs.Count != 3)
				return null;
			var ldci4 = instrs[0];
			if (!ldci4.IsLdcI4())
				return null;
			var call = instrs[1];
			if (call.OpCode.Code != Code.Call)
				return null;
			if (!IsDelegateCreatorMethod(call.Operand as MethodDef))
				return null;
			int rid = ldci4.GetLdcI4Value();
			if (cctor.DeclaringType.Rid != rid)
				throw new ApplicationException("Invalid rid");
			return rid;
		}

		protected override void GetCallInfo(object context, FieldDef field, out IMethod calledMethod, out OpCode callOpcode) {
			uint rid = 0;
			foreach (var c in field.Name.String)
				rid = (rid << 4) + (uint)HexToInt((char)((byte)c + 0x2F));
			rid &= 0x00FFFFFF;
			calledMethod = module.ResolveMemberRef(rid);
			var calledMethodDef = DotNetUtils.GetMethod2(module, calledMethod);
			if (calledMethodDef != null) {
				proxyMethodsType = calledMethodDef.DeclaringType;
				proxyTargetMethods.Add(calledMethodDef, true);
				calledMethod = calledMethodDef;
			}
			callOpcode = OpCodes.Call;
		}

		static int HexToInt(char c) {
			if ('0' <= c && c <= '9')
				return c - '0';
			if ('a' <= c && c <= 'f')
				return c - 'a' + 10;
			if ('A' <= c && c <= 'F')
				return c - 'A' + 10;
			throw new ApplicationException("Invalid hex digit");
		}
	}
}



================================================
File: de4dot.code/deobfuscators/CodeFort/StringDecrypter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Text;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.CodeFort {
	class StringDecrypter {
		ModuleDefMD module;
		MethodDef decryptMethod;

		public bool Detected => decryptMethod != null;
		public MethodDef Method => decryptMethod;
		public TypeDef Type => decryptMethod?.DeclaringType;
		public StringDecrypter(ModuleDefMD module) => this.module = module;

		public void Find() {
			foreach (var type in module.Types) {
				var method = CheckType(type);
				if (method == null)
					continue;

				decryptMethod = method;
			}
		}

		static MethodDef CheckType(TypeDef type) {
			if (type.HasFields)
				return null;
			return CheckMethods(type);
		}

		static MethodDef CheckMethods(TypeDef type) {
			MethodDef decryptMethod = null;
			foreach (var method in type.Methods) {
				if (method.Name == ".cctor")
					continue;
				if (!method.IsStatic || method.Body == null)
					return null;
				if (!DotNetUtils.IsMethod(method, "System.String", "(System.String)"))
					return null;
				if (!HasDouble(method, 3992.0))
					return null;

				decryptMethod = method;
			}
			return decryptMethod;
		}

		static bool HasDouble(MethodDef method, double value) {
			if (method == null || method.Body == null)
				return false;
			foreach (var instr in method.Body.Instructions) {
				if (instr.OpCode.Code != Code.Ldc_R8)
					continue;
				if ((double)instr.Operand == value)
					return true;
			}
			return false;
		}

		public string Decrypt(string s) {
			var bytes = new byte[s.Length];
			for (int i = 0; i < s.Length; i++)
				bytes[i] = (byte)(s[i] ^ 0x3F);
			return Encoding.UTF8.GetString(bytes);
		}
	}
}



================================================
File: de4dot.code/deobfuscators/CodeVeil/AssemblyResolver.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using System.Xml;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.CodeVeil {
	class AssemblyResolver {
		ModuleDefMD module;
		EmbeddedResource bundleData;
		EmbeddedResource bundleXmlFile;
		TypeDef bundleType;
		TypeDef assemblyManagerType;
		TypeDef bundleStreamProviderIFace;
		TypeDef xmlParserType;
		TypeDef bundledAssemblyType;
		TypeDef streamProviderType;
		List<AssemblyInfo> infos = new List<AssemblyInfo>();

		public class AssemblyInfo {
			public string fullName;
			public string simpleName;
			public string extension;
			public byte[] data;

			public AssemblyInfo(string fullName, string extension, byte[] data) {
				this.fullName = fullName;
				simpleName = Utils.GetAssemblySimpleName(fullName);
				this.extension = extension;
				this.data = data;
			}

			public override string ToString() => fullName;
		}

		public bool CanRemoveTypes =>
			bundleType != null &&
			assemblyManagerType != null &&
			bundleStreamProviderIFace != null &&
			xmlParserType != null &&
			bundledAssemblyType != null &&
			streamProviderType != null;

		public IEnumerable<TypeDef> BundleTypes {
			get {
				var list = new List<TypeDef>();
				if (!CanRemoveTypes)
					return list;

				list.Add(bundleType);
				list.Add(assemblyManagerType);
				list.Add(bundleStreamProviderIFace);
				list.Add(xmlParserType);
				list.Add(bundledAssemblyType);
				list.Add(streamProviderType);

				return list;
			}
		}

		public IEnumerable<AssemblyInfo> AssemblyInfos => infos;
		public EmbeddedResource BundleDataResource => bundleData;
		public EmbeddedResource BundleXmlFileResource => bundleXmlFile;
		public AssemblyResolver(ModuleDefMD module) => this.module = module;

		public void Initialize() {
			if (!FindTypeAndResources())
				return;

			FindEmbeddedAssemblies();
		}

		bool FindTypeAndResources() {
			var bundleDataTmp = DotNetUtils.GetResource(module, ".bundle.dat") as EmbeddedResource;
			var bundleXmlFileTmp = DotNetUtils.GetResource(module, ".bundle.manifest") as EmbeddedResource;
			if (bundleDataTmp == null || bundleXmlFileTmp == null)
				return false;

			var bundleTypeTmp = FindBundleType();
			if (bundleTypeTmp == null)
				return false;

			bundleData = bundleDataTmp;
			bundleXmlFile = bundleXmlFileTmp;
			bundleType = bundleTypeTmp;
			FindOtherTypes();
			return true;
		}

		void FindEmbeddedAssemblies() {
			var data = bundleData.CreateReader().ToArray();

			var doc = new XmlDocument();
			doc.Load(XmlReader.Create(bundleXmlFile.CreateReader().AsStream()));
			var manifest = doc.DocumentElement;
			if (manifest.Name.ToLowerInvariant() != "manifest") {
				Logger.w("Could not find Manifest element");
				return;
			}
			foreach (var tmp in manifest.ChildNodes) {
				var assemblyElem = tmp as XmlElement;
				if (assemblyElem == null)
					continue;

				if (assemblyElem.Name.ToLowerInvariant() != "assembly") {
					Logger.w("Unknown element: {0}", assemblyElem.Name);
					continue;
				}

				int offset = GetAttributeValueInt32(assemblyElem, "offset");
				if (offset < 0) {
					Logger.w("Could not find offset attribute");
					continue;
				}

				var assemblyData = DeobUtils.Inflate(data, offset, data.Length - offset, true);
				var mod = ModuleDefMD.Load(assemblyData);
				infos.Add(new AssemblyInfo(mod.Assembly.FullName, DeobUtils.GetExtension(mod.Kind), assemblyData));
			}
		}

		static int GetAttributeValueInt32(XmlElement elem, string attrName) {
			var str = elem.GetAttribute(attrName);
			if (string.IsNullOrEmpty(str))
				return -1;

			if (!int.TryParse(str, out int value))
				return -1;

			return value;
		}

		TypeDef FindBundleType() {
			foreach (var type in module.Types) {
				if (type.Namespace != "")
					continue;
				if (type.Fields.Count != 2)
					continue;

				var ctor = type.FindMethod(".ctor");
				if (ctor == null || !ctor.IsPrivate)
					continue;
				if (!DotNetUtils.IsMethod(ctor, "System.Void", "(System.Reflection.Assembly)"))
					continue;

				var initMethodTmp = FindInitMethod(type);
				if (initMethodTmp == null)
					continue;
				var getTempFilenameMethod = FindGetTempFilenameMethod(type);
				if (getTempFilenameMethod == null)
					continue;

				return type;
			}

			return null;
		}

		MethodDef FindInitMethod(TypeDef type) {
			foreach (var method in type.Methods) {
				if (!method.IsStatic || method.Body == null)
					continue;
				if (!method.IsPublic && !method.IsAssembly)
					continue;
				if (!DotNetUtils.IsMethod(method, "System.Void", "(System.Reflection.Assembly)"))
					continue;

				return method;
			}

			return null;
		}

		MethodDef FindGetTempFilenameMethod(TypeDef type) {
			foreach (var method in type.Methods) {
				if (method.IsStatic || method.Body == null)
					continue;
				if (!method.IsPublic && !method.IsAssembly)
					continue;
				if (!DotNetUtils.IsMethod(method, "System.String", "(System.String)"))
					continue;

				return method;
			}

			return null;
		}

		void FindOtherTypes() {
			FindAssemblyManagerType();
			FindXmlParserType();
			FindStreamProviderType();
		}

		void FindAssemblyManagerType() {
			if (bundleType == null)
				return;

			foreach (var field in bundleType.Fields) {
				var type = field.FieldSig.GetFieldType().TryGetTypeDef();
				if (type == null)
					continue;
				if (type == bundleType)
					continue;
				if (type.Fields.Count != 2)
					continue;

				var ctor = type.FindMethod(".ctor");
				if (ctor == null)
					continue;
				var sig = ctor.MethodSig;
				if (sig == null || sig.Params.Count != 2)
					continue;
				var iface = sig.Params[1].TryGetTypeDef();
				if (iface == null || !iface.IsInterface)
					continue;

				assemblyManagerType = type;
				bundleStreamProviderIFace = iface;
				return;
			}
		}

		void FindXmlParserType() {
			if (assemblyManagerType == null)
				return;
			foreach (var field in assemblyManagerType.Fields) {
				var type = field.FieldSig.GetFieldType().TryGetTypeDef();
				if (type == null || type.IsInterface)
					continue;
				var ctor = type.FindMethod(".ctor");
				if (!DotNetUtils.IsMethod(ctor, "System.Void", "()"))
					continue;
				if (type.Fields.Count != 1)
					continue;
				var git = type.Fields[0].FieldSig.GetFieldType().ToGenericInstSig();
				if (git == null)
					continue;
				if (git.GenericType.FullName != "System.Collections.Generic.List`1")
					continue;
				if (git.GenericArguments.Count != 1)
					continue;
				var type2 = git.GenericArguments[0].TryGetTypeDef();
				if (type2 == null)
					continue;

				xmlParserType = type;
				bundledAssemblyType = type2;
				return;
			}
		}

		void FindStreamProviderType() {
			if (bundleType == null)
				return;
			var ctor = bundleType.FindMethod(".ctor");
			if (!DotNetUtils.IsMethod(ctor, "System.Void", "(System.Reflection.Assembly)"))
				return;
			foreach (var instr in ctor.Body.Instructions) {
				if (instr.OpCode.Code != Code.Newobj)
					continue;
				var newobjCtor = instr.Operand as MethodDef;
				if (newobjCtor == null)
					continue;
				if (newobjCtor.DeclaringType == assemblyManagerType)
					continue;
				if (!DotNetUtils.IsMethod(newobjCtor, "System.Void", "(System.Reflection.Assembly,System.String)"))
					continue;
				var type = newobjCtor.DeclaringType;
				if (type.Interfaces.Count != 1)
					continue;
				if (type.Interfaces[0].Interface != bundleStreamProviderIFace)
					continue;

				streamProviderType = type;
				return;
			}
		}
	}
}



================================================
File: de4dot.code/deobfuscators/CodeVeil/DataReaderUtils.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Text;
using dnlib.IO;

namespace de4dot.code.deobfuscators.CodeVeil {
	static class DataReaderUtils {
		public static char[] ReadChars(ref DataReader reader, int length) {
			var chars = new char[length];
			for (int i = 0; i < length; i++)
				chars[i] = ReadChar(ref reader);
			return chars;
		}

		public static char ReadChar(ref DataReader reader) => ReadChar(ref reader, Encoding.UTF8);

		static char ReadChar(ref DataReader reader, Encoding encoding) {
			var decoder = encoding.GetDecoder();
			bool twoBytes = encoding is UnicodeEncoding;
			byte[] bytes = new byte[2];
			char[] chars = new char[1];
			while (true) {
				bytes[0] = reader.ReadByte();
				if (twoBytes)
					bytes[1] = reader.ReadByte();
				int x = decoder.GetChars(bytes, 0, twoBytes ? 2 : 1, chars, 0);
				if (x != 0)
					break;
			}
			return chars[0];
		}
	}
}



================================================
File: de4dot.code/deobfuscators/CodeVeil/Deobfuscator.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.CodeVeil {
	public class DeobfuscatorInfo : DeobfuscatorInfoBase {
		public const string THE_NAME = "CodeVeil";
		public const string THE_TYPE = "cv";
		const string DEFAULT_REGEX = @"!^[A-Za-z]{1,2}$&" + DeobfuscatorBase.DEFAULT_ASIAN_VALID_NAME_REGEX;

		public DeobfuscatorInfo()
			: base(DEFAULT_REGEX) {
		}

		public override string Name => THE_NAME;
		public override string Type => THE_TYPE;

		public override IDeobfuscator CreateDeobfuscator() =>
			new Deobfuscator(new Deobfuscator.Options {
				ValidNameRegex = validNameRegex.Get(),
			});

		protected override IEnumerable<Option> GetOptionsInternal() => new List<Option>();
	}

	class Deobfuscator : DeobfuscatorBase {
		Options options;
		string obfuscatorName = DeobfuscatorInfo.THE_NAME;

		MainType mainType;
		MethodsDecrypter methodsDecrypter;
		ProxyCallFixer proxyCallFixer;
		StringDecrypter stringDecrypter;
		AssemblyResolver assemblyResolver;
		TypeDef killType;
		ResourceDecrypter resourceDecrypter;

		internal class Options : OptionsBase {
		}

		public override string Type => DeobfuscatorInfo.THE_TYPE;
		public override string TypeLong => DeobfuscatorInfo.THE_NAME;
		public override string Name => obfuscatorName;

		public Deobfuscator(Options options)
			: base(options) {
			this.options = options;
			StringFeatures = StringFeatures.AllowStaticDecryption | StringFeatures.AllowDynamicDecryption;
		}

		protected override int DetectInternal() {
			int val = 0;

			int sum = ToInt32(mainType.Detected) +
					ToInt32(methodsDecrypter.Detected) +
					ToInt32(stringDecrypter.Detected) +
					ToInt32(proxyCallFixer.Detected);
			if (sum > 0)
				val += 100 + 10 * (sum - 1);

			return val;
		}

		protected override void ScanForObfuscator() {
			FindKillType();
			mainType = new MainType(module);
			mainType.Find();
			proxyCallFixer = new ProxyCallFixer(module, mainType);
			proxyCallFixer.FindDelegateCreator();
			methodsDecrypter = new MethodsDecrypter(mainType);
			methodsDecrypter.Find();
			stringDecrypter = new StringDecrypter(module, mainType);
			stringDecrypter.Find();
			var version = DetectVersion();
			if (!string.IsNullOrEmpty(version))
				obfuscatorName = obfuscatorName + " " + version;
		}

		string DetectVersion() {
			if (mainType.Detected) {
				switch (mainType.Version) {
				case ObfuscatorVersion.Unknown:
					return null;

				case ObfuscatorVersion.V3:
					return "3.x";

				case ObfuscatorVersion.V4_0:
					return "4.0";

				case ObfuscatorVersion.V4_1:
					return "4.1";

				case ObfuscatorVersion.V5_0:
					return "5.0";

				default:
					throw new ApplicationException("Unknown version");
				}
			}

			return null;
		}

		void FindKillType() {
			foreach (var type in module.Types) {
				if (type.FullName == "____KILL") {
					killType = type;
					break;
				}
			}
		}

		public override bool GetDecryptedModule(int count, ref byte[] newFileData, ref DumpedMethods dumpedMethods) {
			if (count != 0 || !methodsDecrypter.Detected)
				return false;

			var fileData = DeobUtils.ReadModule(module);
			if (!methodsDecrypter.Decrypt(fileData, ref dumpedMethods))
				return false;

			newFileData = fileData;
			return true;
		}

		public override IDeobfuscator ModuleReloaded(ModuleDefMD module) {
			var newOne = new Deobfuscator(options);
			newOne.SetModule(module);
			newOne.mainType = new MainType(module, mainType);
			newOne.methodsDecrypter = new MethodsDecrypter(mainType, methodsDecrypter);
			newOne.stringDecrypter = new StringDecrypter(module, newOne.mainType, stringDecrypter);
			newOne.proxyCallFixer = new ProxyCallFixer(module, newOne.mainType, proxyCallFixer);
			newOne.killType = DeobUtils.Lookup(module, killType, "Could not find KILL type");
			return newOne;
		}

		public override void DeobfuscateBegin() {
			base.DeobfuscateBegin();

			AddTypeToBeRemoved(killType, "KILL type");

			mainType.Initialize();
			foreach (var initMethod in mainType.OtherInitMethods) {
				AddCctorInitCallToBeRemoved(initMethod);
				AddCtorInitCallToBeRemoved(initMethod);
			}

			if (Operations.DecryptStrings != OpDecryptString.None) {
				stringDecrypter.Initialize();
				staticStringInliner.Add(stringDecrypter.DecryptMethod, (method, gim, args) => {
					return stringDecrypter.Decrypt((int)args[0]);
				});
				DeobfuscatedFile.StringDecryptersAdded();
				AddModuleCctorInitCallToBeRemoved(stringDecrypter.InitMethod);
				AddCallToBeRemoved(mainType.GetInitStringDecrypterMethod(stringDecrypter.InitMethod), stringDecrypter.InitMethod);
			}

			assemblyResolver = new AssemblyResolver(module);
			assemblyResolver.Initialize();
			DumpEmbeddedAssemblies();

			RemoveTamperDetection();

			proxyCallFixer.Initialize();
			proxyCallFixer.Find();

			resourceDecrypter = new ResourceDecrypter(module);
			resourceDecrypter.Initialize();
			resourceDecrypter.Decrypt();
			if (resourceDecrypter.CanRemoveTypes) {
				AddTypeToBeRemoved(resourceDecrypter.ResourceFlagsType, "Obfuscator ResourceFlags type");
				AddTypeToBeRemoved(resourceDecrypter.ResType, "Obfuscator Res type");
				AddTypeToBeRemoved(resourceDecrypter.ResourceEnumeratorType, "Obfuscator ResourceEnumerator type");
				AddTypeToBeRemoved(resourceDecrypter.EncryptedResourceReaderType, "Obfuscator EncryptedResourceReader type");
				AddTypeToBeRemoved(resourceDecrypter.EncryptedResourceSetType, "Obfuscator EncryptedResourceSet type");
				AddTypeToBeRemoved(resourceDecrypter.EncryptedResourceStreamType, "Obfuscator EncryptedResourceStream type");
			}
		}

		void RemoveTamperDetection() {
			var tamperDetection = new TamperDetection(module, mainType);
			tamperDetection.Initialize();
			foreach (var tamperDetectionMethod in tamperDetection.Methods)
				AddCctorInitCallToBeRemoved(tamperDetectionMethod);
			AddTypeToBeRemoved(tamperDetection.Type, "Tamper detection type");
		}

		void DumpEmbeddedAssemblies() {
			foreach (var info in assemblyResolver.AssemblyInfos)
				DeobfuscatedFile.CreateAssemblyFile(info.data, info.simpleName, info.extension);
			AddResourceToBeRemoved(assemblyResolver.BundleDataResource, "Embedded assemblies resource");
			AddResourceToBeRemoved(assemblyResolver.BundleXmlFileResource, "Embedded assemblies XML file resource");
			AddTypesToBeRemoved(assemblyResolver.BundleTypes, "Obfuscator assembly bundle types");
		}

		public override void DeobfuscateMethodBegin(Blocks blocks) {
			proxyCallFixer.Deobfuscate(blocks);
			base.DeobfuscateMethodBegin(blocks);
		}

		public override void DeobfuscateMethodEnd(Blocks blocks) {
			mainType.RemoveInitCall(blocks);
			resourceDecrypter.Deobfuscate(blocks);
			base.DeobfuscateMethodEnd(blocks);
		}

		public override void DeobfuscateEnd() {
			bool canRemoveProxyTypes = proxyCallFixer.CanRemoveTypes;

			if (CanRemoveStringDecrypterType)
				AddTypeToBeRemoved(stringDecrypter.Type, "String decrypter type");

			if (!mainType.Detected) {
			}
			else if (mainType.Version >= ObfuscatorVersion.V5_0) {
				if (!proxyCallFixer.FoundProxyType || canRemoveProxyTypes)
					AddTypeToBeRemoved(mainType.Type, "Main CV type");
			}
			else {
				var type = mainType.Type;
				if (!type.HasNestedTypes && !type.HasProperties && !type.HasEvents && !type.HasFields)
					AddTypeToBeRemoved(type, "Main CV type");
				else {
					foreach (var method in type.Methods)
						AddMethodToBeRemoved(method, "CV main type method");
				}
			}

			RemoveProxyDelegates(proxyCallFixer, canRemoveProxyTypes);
			if (canRemoveProxyTypes) {
				AddTypeToBeRemoved(proxyCallFixer.IlGeneratorType, "Obfuscator proxy method ILGenerator type");
				AddTypeToBeRemoved(proxyCallFixer.FieldInfoType, "Obfuscator proxy method FieldInfo type");
				AddTypeToBeRemoved(proxyCallFixer.MethodInfoType, "Obfuscator proxy method MethodInfo type");
			}

			AddMethodsToBeRemoved(InvalidMethodsFinder.FindAll(module), "Anti-reflection method");

			base.DeobfuscateEnd();
		}

		public override IEnumerable<int> GetStringDecrypterMethods() {
			var list = new List<int>();
			if (stringDecrypter.DecryptMethod != null)
				list.Add(stringDecrypter.DecryptMethod.MDToken.ToInt32());
			return list;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/CodeVeil/ErexResourceReader.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.IO;
using dnlib.IO;

namespace de4dot.code.deobfuscators.CodeVeil {
	class ErexResourceReader {
		DataReader reader;
		uint[] key;

		public ErexResourceReader(ref DataReader reader) => this.reader = reader;

		public byte[] Decrypt() {
			if (reader.ReadUInt32() != 0x58455245)
				throw new InvalidDataException("Invalid EREX sig");
			if (reader.ReadInt32() > 1)
				throw new ApplicationException("Invalid EREX file");

			byte flags = reader.ReadByte();
			bool isEncrypted = (flags & 1) != 0;
			bool isDeflated = (flags & 2) != 0;

			int length = reader.ReadInt32();
			if (length < 0)
				throw new ApplicationException("Invalid length");

			if (isEncrypted)
				ReadKey();

			if (isDeflated)
				reader = Inflate(length);

			if (isEncrypted)
				reader = Decrypt(length);

			return reader.ReadBytes(length);
		}

		void ReadKey() {
			key = new uint[reader.ReadByte()];
			for (int i = 0; i < key.Length; i++)
				key[i] = reader.ReadUInt32();
		}

		DataReader Inflate(int length) {
			var data = reader.ReadRemainingBytes();
			return ByteArrayDataReaderFactory.CreateReader(DeobUtils.Inflate(data, true));
		}

		DataReader Decrypt(int length) {
			var block = new uint[4];
			var decrypted = new byte[16];

			var outStream = new MemoryStream(length);
			while (reader.Position < reader.Length) {
				block[0] = reader.ReadUInt32();
				block[1] = reader.ReadUInt32();
				block[2] = reader.ReadUInt32();
				block[3] = reader.ReadUInt32();
				DeobUtils.XxteaDecrypt(block, key);
				Buffer.BlockCopy(block, 0, decrypted, 0, decrypted.Length);
				outStream.Write(decrypted, 0, decrypted.Length);
			}

			return ByteArrayDataReaderFactory.CreateReader(outStream.ToArray());
		}
	}
}



================================================
File: de4dot.code/deobfuscators/CodeVeil/InvalidDataException.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;

namespace de4dot.code.deobfuscators.CodeVeil {
	[Serializable]
	class InvalidDataException : Exception {
		public InvalidDataException(string msg)
			: base(msg) {
		}
	}
}



================================================
File: de4dot.code/deobfuscators/CodeVeil/InvalidMethodsFinder.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet;

namespace de4dot.code.deobfuscators.CodeVeil {
	class InvalidMethodsFinder {
		public static List<MethodDef> FindAll(ModuleDefMD module) {
			var list = new List<MethodDef>();
			foreach (var type in module.GetTypes()) {
				foreach (var method in type.Methods) {
					if (IsInvalidMethod(method))
						list.Add(method);
				}
			}
			return list;
		}

		public static bool IsInvalidMethod(MethodDef method) {
			if (method == null || method.IsStatic)
				return false;
			var sig = method.MethodSig;
			if (sig == null || sig.Params.Count != 0)
				return false;
			if (sig.RetType == null)
				return true;
			var retType = sig.RetType as GenericSig;
			if (retType == null)
				return false;

			if (retType.IsMethodVar)
				return retType.Number >= sig.GenParamCount;
			var dt = method.DeclaringType;
			return dt == null || retType.Number >= dt.GenericParameters.Count;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/CodeVeil/MainType.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.CodeVeil {
	// Detects the type CV adds to the assembly that gets called from <Module>::.cctor.
	class MainType {
		ModuleDefMD module;
		TypeDef theType;
		MethodDef initMethod;
		MethodDef tamperCheckMethod;
		ObfuscatorVersion obfuscatorVersion = ObfuscatorVersion.Unknown;
		List<uint> rvas = new List<uint>();	// _stub and _executive
		List<MethodDef> otherInitMethods = new List<MethodDef>();

		public bool Detected => theType != null;
		public ObfuscatorVersion Version => obfuscatorVersion;
		public TypeDef Type => theType;
		public MethodDef InitMethod => initMethod;
		public List<MethodDef> OtherInitMethods => otherInitMethods;
		public MethodDef TamperCheckMethod => tamperCheckMethod;
		public List<uint> Rvas => rvas;

		public MainType(ModuleDefMD module) => this.module = module;

		public MainType(ModuleDefMD module, MainType oldOne) {
			this.module = module;
			theType = Lookup(oldOne.theType, "Could not find main type");
			initMethod = Lookup(oldOne.initMethod, "Could not find main type init method");
			tamperCheckMethod = Lookup(oldOne.tamperCheckMethod, "Could not find tamper detection method");
			obfuscatorVersion = oldOne.obfuscatorVersion;
			rvas = oldOne.rvas;
			foreach (var otherInitMethod in otherInitMethods)
				otherInitMethods.Add(Lookup(otherInitMethod, "Could not find otherInitMethod"));
		}

		T Lookup<T>(T def, string errorMessage) where T : class, ICodedToken =>
			DeobUtils.Lookup(module, def, errorMessage);

		public void Find() {
			var cctor = DotNetUtils.GetModuleTypeCctor(module);
			if (cctor == null)
				return;

			var instrs = cctor.Body.Instructions;
			for (int i = 0; i < instrs.Count - 2; i++) {
				var ldci4_1 = instrs[i];
				if (!ldci4_1.IsLdcI4())
					continue;

				var ldci4_2 = instrs[i + 1];
				if (!ldci4_2.IsLdcI4())
					continue;

				var call = instrs[i + 2];
				if (call.OpCode.Code != Code.Call)
					continue;
				var initMethodTmp = call.Operand as MethodDef;
				if (!CheckInitMethod(initMethodTmp, out var obfuscatorVersionTmp))
					continue;
				if (!CheckMethodsType(initMethodTmp.DeclaringType))
					continue;

				obfuscatorVersion = obfuscatorVersionTmp;
				theType = initMethodTmp.DeclaringType;
				initMethod = initMethodTmp;
				break;
			}
		}

		static string[] fieldTypesV5 = new string[] {
			"System.Byte[]",
			"System.Collections.Generic.List`1<System.Delegate>",
			"System.Runtime.InteropServices.GCHandle",
		};
		bool CheckInitMethod(MethodDef initMethod, out ObfuscatorVersion obfuscatorVersionTmp) {
			obfuscatorVersionTmp = ObfuscatorVersion.Unknown;

			if (initMethod == null)
				return false;
			if (initMethod.Body == null)
				return false;
			if (!initMethod.IsStatic)
				return false;
			if (!DotNetUtils.IsMethod(initMethod, "System.Void", "(System.Boolean,System.Boolean)"))
				return false;

			if (HasCodeString(initMethod, "E_FullTrust")) {
				if (DotNetUtils.GetPInvokeMethod(initMethod.DeclaringType, "user32", "CallWindowProcW") != null)
					obfuscatorVersionTmp = ObfuscatorVersion.V4_1;
				else
					obfuscatorVersionTmp = ObfuscatorVersion.V4_0;
			}
			else if (HasCodeString(initMethod, "Full Trust Required"))
				obfuscatorVersionTmp = ObfuscatorVersion.V3;
			else if (initMethod.DeclaringType.HasNestedTypes && new FieldTypes(initMethod.DeclaringType).All(fieldTypesV5))
				obfuscatorVersionTmp = ObfuscatorVersion.V5_0;
			else
				return false;

			return true;
		}

		static bool HasCodeString(MethodDef method, string str) {
			foreach (var s in DotNetUtils.GetCodeStrings(method)) {
				if (s == str)
					return true;
			}
			return false;
		}

		bool CheckMethodsType(TypeDef type) {
			rvas = new List<uint>();

			var fields = GetRvaFields(type);
			if (fields.Count < 2)	// RVAs for executive and stub are always present if encrypted methods
				return true;

			foreach (var field in fields)
				rvas.Add((uint)field.RVA);
			return true;
		}

		static List<FieldDef> GetRvaFields(TypeDef type) {
			var fields = new List<FieldDef>();
			foreach (var field in type.Fields) {
				var etype = field.FieldSig.GetFieldType().GetElementType();
				if (etype != ElementType.U1 && etype != ElementType.U4)
					continue;
				if (field.RVA == 0)
					continue;

				fields.Add(field);
			}
			return fields;
		}

		public void Initialize() {
			if (theType == null)
				return;

			tamperCheckMethod = FindTamperCheckMethod();
			otherInitMethods = FindOtherInitMethods();
		}

		MethodDef FindTamperCheckMethod() {
			foreach (var method in theType.Methods) {
				if (!method.IsStatic || method.Body == null)
					continue;
				if (!DotNetUtils.IsMethod(method, "System.Void", "(System.Reflection.Assembly,System.UInt64)"))
					continue;

				return method;
			}

			return null;
		}

		List<MethodDef> FindOtherInitMethods() {
			var list = new List<MethodDef>();
			foreach (var method in theType.Methods) {
				if (!method.IsStatic)
					continue;
				if (method.Name == ".cctor")
					continue;
				if (!DotNetUtils.IsMethod(method, "System.Void", "()"))
					continue;

				list.Add(method);
			}
			return list;
		}

		public MethodDef GetInitStringDecrypterMethod(MethodDef stringDecrypterInitMethod) {
			if (stringDecrypterInitMethod == null)
				return null;
			if (theType == null)
				return null;

			foreach (var method in theType.Methods) {
				if (!method.IsStatic || method.Body == null)
					continue;
				if (CallsMethod(method, stringDecrypterInitMethod))
					return method;
			}
			return null;
		}

		bool CallsMethod(MethodDef methodToCheck, MethodDef calledMethod) {
			foreach (var method in DotNetUtils.GetCalledMethods(module, methodToCheck)) {
				if (method == calledMethod)
					return true;
			}
			return false;
		}

		public void RemoveInitCall(Blocks blocks) {
			if (initMethod == null || theType == null)
				return;
			if (blocks.Method.Name != ".cctor")
				return;
			if (blocks.Method.DeclaringType != DotNetUtils.GetModuleType(module))
				return;

			foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {
				var instrs = block.Instructions;
				for (int i = 0; i < instrs.Count - 2; i++) {
					if (!instrs[i].IsLdcI4())
						continue;
					if (!instrs[i + 1].IsLdcI4())
						continue;
					var call = instrs[i + 2];
					if (call.OpCode.Code != Code.Call)
						continue;
					if (call.Operand != initMethod)
						continue;

					block.Remove(i, 3);
					return;
				}
			}
		}
	}
}



================================================
File: de4dot.code/deobfuscators/CodeVeil/MethodsDecrypter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using dnlib.IO;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.CodeVeil {
	class MethodsDecrypter {
		MainType mainType;
		IDecrypter decrypter;

		interface IDecrypter {
			void Initialize(byte[] methodsData);
			bool Decrypt(ref DataReader fileDataReader, DumpedMethod dm);
		}

		class Decrypter : IDecrypter {
			DataReader methodsDataReader;

			public virtual void Initialize(byte[] methodsData) => methodsDataReader = ByteArrayDataReaderFactory.CreateReader(methodsData);

			public virtual bool Decrypt(ref DataReader fileDataReader, DumpedMethod dm) {
				if (fileDataReader.ReadByte() != 0x2A)
					return false;	// Not a RET
				methodsDataReader.Position = fileDataReader.ReadCompressedUInt32();

				dm.mhCodeSize = methodsDataReader.ReadCompressedUInt32();
				dm.code = methodsDataReader.ReadBytes((int)dm.mhCodeSize);
				if ((dm.mhFlags & 8) != 0)
					dm.extraSections = MethodBodyParser.ReadExtraSections(ref methodsDataReader);

				if (!DecryptCode(dm))
					return false;

				return true;
			}

			protected virtual bool DecryptCode(DumpedMethod dm) => true;
		}

		class DecrypterV5 : Decrypter {
			byte[] decryptKey;

			public override void Initialize(byte[] methodsData) {
				var data = DeobUtils.Inflate(methodsData, true);
				decryptKey = BitConverter.GetBytes(BitConverter.ToUInt32(data, 0));

				var newMethodsData = new byte[data.Length - 4];
				Array.Copy(data, 4, newMethodsData, 0, newMethodsData.Length);
				base.Initialize(newMethodsData);
			}

			protected override bool DecryptCode(DumpedMethod dm) {
				var code = dm.code;
				for (int i = 0; i < code.Length; i++) {
					for (int j = 0; j < 4 && i + j < code.Length; j++)
						code[i + j] ^= decryptKey[j];
				}

				return true;
			}
		}

		public bool Detected => decrypter != null;
		public MethodsDecrypter(MainType mainType) => this.mainType = mainType;
		public MethodsDecrypter(MainType mainType, MethodsDecrypter oldOne) => this.mainType = mainType;

		public void Find() {
			if (!mainType.Detected)
				return;

			switch (mainType.Version) {
			case ObfuscatorVersion.Unknown:
				break;

			case ObfuscatorVersion.V3:
			case ObfuscatorVersion.V4_0:
			case ObfuscatorVersion.V4_1:
				decrypter = new Decrypter();
				break;

			case ObfuscatorVersion.V5_0:
				decrypter = new DecrypterV5();
				break;

			default:
				throw new ApplicationException("Unknown version");
			}
		}

		public bool Decrypt(byte[] fileData, ref DumpedMethods dumpedMethods) {
			if (decrypter == null)
				return false;

			using (var peImage = new MyPEImage(fileData)) {
				if (peImage.Sections.Count <= 0)
					return false;

				var methodsData = FindMethodsData(peImage, fileData);
				if (methodsData == null)
					return false;

				decrypter.Initialize(methodsData);

				dumpedMethods = CreateDumpedMethods(peImage, fileData, methodsData);
				if (dumpedMethods == null)
					return false;
			}

			return true;
		}

		DumpedMethods CreateDumpedMethods(MyPEImage peImage, byte[] fileData, byte[] methodsData) {
			var dumpedMethods = new DumpedMethods();

			/*var methodsDataReader = ByteArrayDataReaderFactory.CreateReader(methodsData);*/
			var fileDataReader = ByteArrayDataReaderFactory.CreateReader(fileData);

			var methodDef = peImage.Metadata.TablesStream.MethodTable;
			for (uint rid = 1; rid <= methodDef.Rows; rid++) {
				var dm = new DumpedMethod();

				peImage.ReadMethodTableRowTo(dm, rid);
				if (dm.mdRVA == 0)
					continue;
				uint bodyOffset = peImage.RvaToOffset(dm.mdRVA);

				byte b = peImage.OffsetReadByte(bodyOffset);
				uint codeOffset;
				if ((b & 3) == 2) {
					if (b != 2)
						continue;	// not zero byte code size

					dm.mhFlags = 2;
					dm.mhMaxStack = 8;
					dm.mhLocalVarSigTok = 0;
					codeOffset = bodyOffset + 1;
				}
				else {
					if (peImage.OffsetReadUInt32(bodyOffset + 4) != 0)
						continue;	// not zero byte code size

					dm.mhFlags = peImage.OffsetReadUInt16(bodyOffset);
					dm.mhMaxStack = peImage.OffsetReadUInt16(bodyOffset + 2);
					dm.mhLocalVarSigTok = peImage.OffsetReadUInt32(bodyOffset + 8);
					codeOffset = bodyOffset + (uint)(dm.mhFlags >> 12) * 4;
				}
				fileDataReader.Position = codeOffset;

				if (!decrypter.Decrypt(ref fileDataReader, dm))
					continue;

				dumpedMethods.Add(dm);
			}

			return dumpedMethods;
		}

		// xor eax, eax / inc eax / pop esi edi edx ecx ebx / leave / ret 0Ch or 10h
		static byte[] initializeMethodEnd = new byte[] {
			0x33, 0xC0, 0x40, 0x5E, 0x5F, 0x5A, 0x59, 0x5B, 0xC9, 0xC2,
		};
		byte[] FindMethodsData(MyPEImage peImage, byte[] fileData) {
			var section = peImage.Sections[0];

			var reader = ByteArrayDataReaderFactory.CreateReader(fileData);

			const int RVA_EXECUTIVE_OFFSET = 1 * 4;
			const int ENC_CODE_OFFSET = 6 * 4;
			int lastOffset = Math.Min(fileData.Length, (int)(section.PointerToRawData + section.SizeOfRawData));
			for (int offset = GetStartOffset(peImage); offset < lastOffset; ) {
				offset = FindSig(fileData, offset, lastOffset, initializeMethodEnd);
				if (offset < 0)
					return null;
				offset += initializeMethodEnd.Length;

				short retImm16 = BitConverter.ToInt16(fileData, offset);
				if (retImm16 != 0x0C && retImm16 != 0x10)
					continue;
				offset += 2;
				if (offset + ENC_CODE_OFFSET + 4 > lastOffset)
					return null;

				// rva is 0 when the assembly has been embedded
				uint rva = BitConverter.ToUInt32(fileData, offset + RVA_EXECUTIVE_OFFSET);
				if (rva != 0 && mainType.Rvas.IndexOf(rva) < 0)
					continue;

				int relOffs = BitConverter.ToInt32(fileData, offset + ENC_CODE_OFFSET);
				if (relOffs <= 0 || relOffs >= section.SizeOfRawData)
					continue;
				reader.Position = section.PointerToRawData + (uint)relOffs;

				int size = (int)reader.ReadCompressedUInt32();
				int endOffset = relOffs + size;
				if (endOffset < relOffs || endOffset > section.SizeOfRawData)
					continue;

				return reader.ReadBytes(size);
			}

			return null;
		}

		int GetStartOffset(MyPEImage peImage) {
			int minOffset = int.MaxValue;
			foreach (var rva in mainType.Rvas) {
				int rvaOffs = (int)peImage.RvaToOffset((uint)rva);
				if (rvaOffs < minOffset)
					minOffset = rvaOffs;
			}
			return minOffset == int.MaxValue ? 0 : minOffset;
		}

		static int FindSig(byte[] fileData, int offset, int lastOffset, byte[] sig) {
			for (int i = offset; i < lastOffset - sig.Length + 1; i++) {
				if (fileData[i] != sig[0])
					continue;
				if (Compare(fileData, i + 1, sig, 1, sig.Length - 1))
					return i;
			}
			return -1;
		}

		static bool Compare(byte[] a1, int i1, byte[] a2, int i2, int len) {
			for (int i = 0; i < len; i++) {
				if (a1[i1++] != a2[i2++])
					return false;
			}
			return true;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/CodeVeil/ObfuscatorVersion.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

namespace de4dot.code.deobfuscators.CodeVeil {
	enum ObfuscatorVersion {
		Unknown,
		V3,
		V4_0,
		V4_1,
		V5_0,
	}
}



================================================
File: de4dot.code/deobfuscators/CodeVeil/ProxyCallFixer.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.IO;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.CodeVeil {
	class ProxyCallFixer : ProxyCallFixer1 {
		MainType mainType;
		Info info = new Info();
		DataReader reader;

		class Info {
			public TypeDef proxyType;
			public MethodDef initMethod;
			public FieldDef dataField;
			public TypeDef ilgeneratorType;
			public TypeDef fieldInfoType;
			public TypeDef methodInfoType;
		}

		class Context {
			public int offset;
			public Context(int offset) => this.offset = offset;
		}

		public bool FoundProxyType => info.proxyType != null;

		public bool CanRemoveTypes =>
			info.proxyType != null &&
			info.ilgeneratorType != null &&
			info.fieldInfoType != null &&
			info.methodInfoType != null;

		public TypeDef IlGeneratorType => info.ilgeneratorType;
		public TypeDef FieldInfoType => info.fieldInfoType;
		public TypeDef MethodInfoType => info.methodInfoType;
		public ProxyCallFixer(ModuleDefMD module, MainType mainType) : base(module) => this.mainType = mainType;

		public ProxyCallFixer(ModuleDefMD module, MainType mainType, ProxyCallFixer oldOne)
			: base(module, oldOne) {
			this.mainType = mainType;
			info.proxyType = Lookup(oldOne.info.proxyType, "Could not find proxyType");
			info.initMethod = Lookup(oldOne.info.initMethod, "Could not find initMethod");
			info.dataField = Lookup(oldOne.info.dataField, "Could not find dataField");
			info.ilgeneratorType = Lookup(oldOne.info.ilgeneratorType, "Could not find ilgeneratorType");
			info.fieldInfoType = Lookup(oldOne.info.fieldInfoType, "Could not find fieldInfoType");
			info.methodInfoType = Lookup(oldOne.info.methodInfoType, "Could not find methodInfoType");
		}

		protected override object CheckCctor(ref TypeDef type, MethodDef cctor) {
			var instrs = cctor.Body.Instructions;
			for (int i = 0; i < instrs.Count - 1; i++) {
				var ldci4 = instrs[i];
				if (!ldci4.IsLdcI4())
					continue;

				var call = instrs[i + 1];
				if (call.OpCode.Code != Code.Call)
					continue;
				if (call.Operand != info.initMethod)
					continue;

				int offset = ldci4.GetLdcI4Value();
				reader.Position = (uint)offset;
				uint rid = reader.ReadCompressedUInt32();
				if (rid != type.Rid)
					throw new ApplicationException("Invalid RID");
				return string.Empty;	// It's non-null
			}
			return null;
		}

		protected override void GetCallInfo(object context, FieldDef field, out IMethod calledMethod, out OpCode callOpcode) {
			byte flags = reader.ReadByte();

			int methodToken = 0x06000000 + ((flags & 0x3F) << 24) + (int)reader.ReadCompressedUInt32();
			int genericTypeToken = (flags & 0x40) == 0 ? -1 : 0x1B000000 + (int)reader.ReadCompressedUInt32();
			callOpcode = (flags & 0x80) != 0 ? OpCodes.Callvirt : OpCodes.Call;

			calledMethod = module.ResolveToken(methodToken) as IMethod;
			if (calledMethod == null)
				throw new ApplicationException("Could not find method");
			if (genericTypeToken != -1 && calledMethod.DeclaringType.MDToken.ToInt32() != genericTypeToken)
				throw new ApplicationException("Invalid declaring type token");
		}

		public void FindDelegateCreator() {
			if (!mainType.Detected)
				return;

			var infoTmp = new Info();
			if (!InitializeInfo(infoTmp, mainType.Type))
				return;

			info = infoTmp;
			SetDelegateCreatorMethod(info.initMethod);
		}

		bool InitializeInfo(Info infoTmp, TypeDef type) {
			foreach (var dtype in type.NestedTypes) {
				var cctor = dtype.FindMethod(".cctor");
				if (cctor == null)
					continue;
				if (!InitProxyType(infoTmp, cctor))
					continue;

				return true;
			}

			return false;
		}

		bool InitProxyType(Info infoTmp, MethodDef method) {
			foreach (var calledMethod in DotNetUtils.GetCalledMethods(module, method)) {
				if (!calledMethod.IsStatic)
					continue;
				if (!DotNetUtils.IsMethod(calledMethod, "System.Void", "(System.Int32)"))
					continue;
				if (!CheckProxyType(infoTmp, calledMethod.DeclaringType))
					continue;

				infoTmp.proxyType = calledMethod.DeclaringType;
				infoTmp.initMethod = calledMethod;
				return true;
			}
			return false;
		}

		static string[] requiredFields = new string[] {
			"System.Byte[]",
			"System.Int32",
			"System.ModuleHandle",
			"System.Reflection.Emit.OpCode",
			"System.Reflection.Emit.OpCode[]",
		};
		bool CheckProxyType(Info infoTmp, TypeDef type) {
			if (type.NestedTypes.Count != 1)
				return false;

			if (!new FieldTypes(type).All(requiredFields))
				return false;

			var fields = GetRvaFields(type);
			if (fields.Count != 1)
				return false;
			var field = fields[0];
			var fieldType = DotNetUtils.GetType(module, field.FieldSig.GetFieldType());
			if (type.NestedTypes.IndexOf(fieldType) < 0)
				return false;
			if (field.InitialValue == null || field.InitialValue.Length == 0)
				return false;

			infoTmp.dataField = field;
			return true;
		}

		static List<FieldDef> GetRvaFields(TypeDef type) {
			var fields = new List<FieldDef>();
			foreach (var field in type.Fields) {
				if (field.RVA != 0)
					fields.Add(field);
			}
			return fields;
		}

		protected override IEnumerable<TypeDef> GetDelegateTypes() {
			if (!mainType.Detected)
				return new List<TypeDef>();
			return mainType.Type.NestedTypes;
		}

		public void Initialize() {
			if (info.dataField == null)
				return;

			FindOtherTypes();

			var decompressed = DeobUtils.Inflate(info.dataField.InitialValue, true);
			reader = ByteArrayDataReaderFactory.CreateReader(decompressed);
			info.dataField.FieldSig.Type = module.CorLibTypes.Byte;
			info.dataField.InitialValue = new byte[1];
			info.dataField.RVA = 0;
		}

		void FindOtherTypes() {
			if (info.proxyType == null)
				return;

			foreach (var method in info.proxyType.Methods) {
				var sig = method.MethodSig;
				if (sig == null || sig.Params.Count != 4)
					continue;

				if (sig.Params[2].GetFullName() != "System.Type[]")
					continue;
				var methodType = sig.Params[0].TryGetTypeDef();
				var fieldType = sig.Params[1].TryGetTypeDef();
				var ilgType = sig.Params[3].TryGetTypeDef();
				if (!CheckMethodType(methodType))
					continue;
				if (!CheckFieldType(fieldType))
					continue;
				if (!CheckIlGeneratorType(ilgType))
					continue;

				info.ilgeneratorType = ilgType;
				info.methodInfoType = methodType;
				info.fieldInfoType = fieldType;
			}
		}

		bool CheckMethodType(TypeDef type) {
			if (type == null || type.BaseType == null || type.BaseType.FullName != "System.Object")
				return false;
			if (type.Fields.Count != 1)
				return false;
			if (DotNetUtils.GetField(type, "System.Reflection.MethodInfo") == null)
				return false;

			return true;
		}

		bool CheckFieldType(TypeDef type) {
			if (type == null || type.BaseType == null || type.BaseType.FullName != "System.Object")
				return false;
			if (DotNetUtils.GetField(type, "System.Reflection.FieldInfo") == null)
				return false;

			return true;
		}

		bool CheckIlGeneratorType(TypeDef type) {
			if (type == null || type.BaseType == null || type.BaseType.FullName != "System.Object")
				return false;
			if (type.Fields.Count != 1)
				return false;
			if (DotNetUtils.GetField(type, "System.Reflection.Emit.ILGenerator") == null)
				return false;

			return true;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/CodeVeil/ResourceConverter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Drawing;
using System.IO;
using System.Runtime.Serialization;
using dnlib.DotNet;
using dnlib.DotNet.Resources;

namespace de4dot.code.deobfuscators.CodeVeil {
	class ResourceConverter {
		ModuleDefMD module;
		ResourceInfo[] infos;
		MyResourceDataFactory dataCreator;

		sealed class MyResourceDataFactory : ResourceDataFactory {
			public MyResourceDataFactory(ModuleDef module)
				: base(module) {
			}

			protected override string GetAssemblyFullName(string simpleName) {
				var asm = TheAssemblyResolver.Instance.Resolve(new AssemblyNameInfo(simpleName), Module);
				return asm?.FullName;
			}
		}

		public ResourceConverter(ModuleDefMD module, ResourceInfo[] infos) {
			this.module = module;
			dataCreator = new MyResourceDataFactory(module);
			this.infos = infos;
		}

		public byte[] Convert() {
			var resources = new ResourceElementSet();
			foreach (var info in infos)
				resources.Add(Convert(info));

			var memStream = new MemoryStream();
			ResourceWriter.Write(module, memStream, resources);
			return memStream.ToArray();
		}

		ResourceElement Convert(ResourceInfo info) {
			var reader = info.dataReader;
			reader.Position = (uint)info.offset;

			IResourceData resourceData;
			int type = (info.flags & 0x7F);
			switch (type) {
			case 1:		// bool
				resourceData = dataCreator.Create(reader.ReadBoolean());
				break;

			case 2:		// byte
				resourceData = dataCreator.Create(reader.ReadByte());
				break;

			case 3:		// byte[]
				resourceData = dataCreator.Create(reader.ReadBytes(info.length));
				break;

			case 4:		// char[]
				resourceData = new CharArrayResourceData(dataCreator.CreateUserResourceType(CharArrayResourceData.ReflectionTypeName), DataReaderUtils.ReadChars(ref reader, info.length));
				break;

			case 5:		// sbyte
				resourceData = dataCreator.Create(reader.ReadSByte());
				break;

			case 6:		// char
				resourceData = dataCreator.Create(DataReaderUtils.ReadChar(ref reader));
				break;

			case 7:		// decimal
				resourceData = dataCreator.Create(reader.ReadDecimal());
				break;

			case 8:		// double
				resourceData = dataCreator.Create(reader.ReadDouble());
				break;

			case 9:		// short
				resourceData = dataCreator.Create(reader.ReadInt16());
				break;

			case 10:	// int
				resourceData = dataCreator.Create(reader.ReadInt32());
				break;

			case 11:	// long
				resourceData = dataCreator.Create(reader.ReadInt64());
				break;

			case 12:	// float
				resourceData = dataCreator.Create(reader.ReadSingle());
				break;

			case 13:	// string
				resourceData = dataCreator.Create(reader.ReadSerializedString());
				break;

			case 14:	// ushort
				resourceData = dataCreator.Create(reader.ReadUInt16());
				break;

			case 15:	// uint
				resourceData = dataCreator.Create(reader.ReadUInt32());
				break;

			case 16:	// ulong
				resourceData = dataCreator.Create(reader.ReadUInt64());
				break;

			case 17:	// DateTime
				resourceData = dataCreator.Create(DateTime.FromBinary(reader.ReadInt64()));
				break;

			case 18:	// TimeSpan
				resourceData = dataCreator.Create(TimeSpan.FromTicks(reader.ReadInt64()));
				break;

			case 19:	// Icon
				resourceData = new IconResourceData(dataCreator.CreateUserResourceType(IconResourceData.ReflectionTypeName), reader.ReadBytes(info.length));
				break;

			case 20:	// Image
				resourceData = new ImageResourceData(dataCreator.CreateUserResourceType(ImageResourceData.ReflectionTypeName), reader.ReadBytes(info.length));
				break;

			case 31:	// binary
				resourceData = dataCreator.CreateSerialized(reader.ReadBytes(info.length));
				break;

			case 21:	// Point (CV doesn't restore this type)
			default:
				throw new Exception("Unknown type");
			}

			return new ResourceElement() {
				Name = info.name,
				ResourceData = resourceData,
			};
		}
	}

	class CharArrayResourceData : UserResourceData {
		public static readonly string ReflectionTypeName = "System.Char[],mscorlib";
		char[] data;
		public CharArrayResourceData(UserResourceType type, char[] data) : base(type) => this.data = data;
		public override void WriteData(BinaryWriter writer, IFormatter formatter) => formatter.Serialize(writer.BaseStream, data);
		public override string ToString() => $"char[]: Length: {data.Length}";
	}

	class IconResourceData : UserResourceData {
		public static readonly string ReflectionTypeName = "System.Drawing.Icon,System.Drawing";
		Icon icon;
		public IconResourceData(UserResourceType type, byte[] data) : base(type) => icon = new Icon(new MemoryStream(data));
		public override void WriteData(BinaryWriter writer, IFormatter formatter) => formatter.Serialize(writer.BaseStream, icon);
		public override string ToString() => $"Icon: {icon}";
	}

	class ImageResourceData : UserResourceData {
		public static readonly string ReflectionTypeName = "System.Drawing.Bitmap,System.Drawing";
		Bitmap bitmap;
		public ImageResourceData(UserResourceType type, byte[] data) : base(type) => bitmap = new Bitmap(Image.FromStream(new MemoryStream(data)));
		public override void WriteData(BinaryWriter writer, IFormatter formatter) => formatter.Serialize(writer.BaseStream, bitmap);
		public override string ToString() => "Bitmap";
	}
}



================================================
File: de4dot.code/deobfuscators/CodeVeil/ResourceDecrypter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using dnlib.IO;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.CodeVeil {
	class ResourceDecrypter {
		ModuleDefMD module;
		TypeDef encryptedResourceStreamType;
		TypeDef encryptedResourceSetType;
		MethodDef encryptedResourceSet_GetDefaultReader;
		TypeDef encryptedResourceReaderType;
		GenericInstSig encryptedResourceReaderTypeDict;
		TypeDef resType;
		MethodDef resTypeCtor;
		TypeDef resourceFlagsType;
		TypeDef resourceEnumeratorType;
		MethodCallRestorerBase methodsRestorer;

		public bool CanRemoveTypes =>
			EncryptedResourceStreamType != null &&
			EncryptedResourceSetType != null &&
			EncryptedResourceReaderType != null &&
			ResType != null &&
			ResourceFlagsType != null &&
			ResourceEnumeratorType != null;

		public TypeDef EncryptedResourceStreamType => encryptedResourceStreamType;
		public TypeDef EncryptedResourceSetType => encryptedResourceSetType;
		public TypeDef EncryptedResourceReaderType => encryptedResourceReaderType;
		public TypeDef ResType => resType;
		public TypeDef ResourceFlagsType => resourceFlagsType;
		public TypeDef ResourceEnumeratorType => resourceEnumeratorType;
		public ResourceDecrypter(ModuleDefMD module) => this.module = module;

		public void Initialize() {
			methodsRestorer = new MethodCallRestorerBase(module);
			FindEncryptedResourceStreamType();
			FindEncryptedResourceSet();
			FindEncryptedResourceReader();
			FindResType();
			FindResourceFlags();
			FindResourceEnumerator();
		}

		void FindResourceEnumerator() {
			if (encryptedResourceReaderType == null)
				return;

			var resourceEnumeratorType_fields = new string[] {
				"System.Collections.DictionaryEntry",
				"System.Collections.IDictionaryEnumerator",
				"System.Boolean",
				encryptedResourceReaderType.FullName,
			};
			foreach (var type in module.Types) {
				if (type.Namespace != "")
					continue;
				if (type.BaseType == null || type.BaseType.FullName != "System.Object")
					continue;
				if (!HasInterface(type, "System.Collections.IDictionaryEnumerator"))
					continue;
				if (!new FieldTypes(type).All(resourceEnumeratorType_fields))
					continue;
				var ctor = type.FindMethod(".ctor");
				if (ctor == null)
					continue;
				var sig = ctor.MethodSig;
				if (sig == null || sig.Params.Count != 1)
					continue;
				if (sig.Params[0].TryGetTypeDef() != encryptedResourceReaderType)
					continue;

				resourceEnumeratorType = type;
				return;
			}
		}

		void FindResourceFlags() {
			if (resTypeCtor == null)
				return;
			var sig = resTypeCtor.MethodSig;
			if (sig == null || sig.Params.Count != 4)
				return;
			var type = sig.Params[2].TryGetTypeDef();
			if (type == null || !type.IsEnum)
				return;

			resourceFlagsType = type;
		}

		/*static string[] resType_fields = new string[] {
			"System.Int32",
			"System.Object",
			"System.String",
		};*/
		void FindResType() {
			if (encryptedResourceReaderTypeDict == null)
				return;
			var type = encryptedResourceReaderTypeDict.GenericArguments[1].TryGetTypeDef();
			if (type == null)
				return;
			if (type.BaseType == null || type.BaseType.FullName != "System.Object")
				return;
			var ctor = type.FindMethod(".ctor");
			if (ctor == null)
				return;
			var sig = ctor.MethodSig;
			if (sig == null || sig.Params.Count != 4)
				return;

			resTypeCtor = ctor;
			resType = type;
		}

		static string[] encryptedResourceReaderType_fields = new string[] {
			"System.Boolean",
			"System.Int32",
			"System.Int64",
			"System.IO.BinaryReader",
			"System.Runtime.Serialization.Formatters.Binary.BinaryFormatter",
		};
		void FindEncryptedResourceReader() {
			var type = GetTypeFromCode(encryptedResourceSet_GetDefaultReader);
			if (type == null)
				return;
			if (type.BaseType == null || !HasInterface(type, "System.Resources.IResourceReader"))
				return;
			if (!new FieldTypes(type).All(encryptedResourceReaderType_fields))
				return;
			var dictType = GetDlxResDict(type);
			if (dictType == null)
				return;
			if (FindXxteaMethod(type) == null)
				return;

			encryptedResourceReaderType = type;
			encryptedResourceReaderTypeDict = dictType;
		}

		static bool HasInterface(TypeDef type, string interfaceFullName) {
			foreach (var iface in type.Interfaces) {
				if (iface.Interface.FullName == interfaceFullName)
					return true;
			}
			return false;
		}

		static GenericInstSig GetDlxResDict(TypeDef type) {
			foreach (var field in type.Fields) {
				var fieldType = field.FieldSig.GetFieldType().ToGenericInstSig();
				if (fieldType == null)
					continue;
				if (fieldType.GenericType.FullName != "System.Collections.Generic.Dictionary`2")
					continue;
				if (fieldType.GenericArguments.Count != 2)
					continue;
				if (fieldType.GenericArguments[0].FullName != "System.String")
					continue;
				if (fieldType.GenericArguments[1].TryGetTypeDef() == null)
					continue;
				return fieldType;
			}
			return null;
		}

		static TypeDef GetTypeFromCode(MethodDef method) {
			if (method == null || method.Body == null)
				return null;
			foreach (var instr in method.Body.Instructions) {
				if (instr.OpCode.Code != Code.Ldtoken)
					continue;
				if (instr.Operand is TypeDef type)
					return type;
			}

			return null;
		}

		void FindEncryptedResourceSet() {
			foreach (var type in module.Types) {
				if (type.Namespace != "")
					continue;
				if (type.BaseType == null || type.BaseType.FullName != "System.Resources.ResourceSet")
					continue;
				var ctor = type.FindMethod(".ctor");
				if (!DotNetUtils.IsMethod(ctor, "System.Void", "(System.Resources.IResourceReader)"))
					continue;
				var method = type.FindMethod("GetDefaultReader");
				if (!DotNetUtils.IsMethod(method, "System.Type", "()"))
					continue;
				if (method.Body == null || method.IsStatic || !method.IsVirtual)
					continue;

				encryptedResourceSet_GetDefaultReader = method;
				encryptedResourceSetType = type;
				return;
			}
		}

		static string[] encryptedResourceStreamType_fields = new string[] {
			"System.Byte",
			"System.Byte[]",
			"System.Boolean",
			"System.Int32",
			"System.Int64",
			"System.IO.MemoryStream",
			"System.IO.Stream",
			"System.UInt32[]",
		};
		void FindEncryptedResourceStreamType() {
			foreach (var type in module.Types) {
				if (type.Namespace != "")
					continue;
				if (type.BaseType == null || type.BaseType.FullName != "System.IO.Stream")
					continue;
				var ctor = type.FindMethod(".ctor");
				if (!DotNetUtils.IsMethod(ctor, "System.Void", "(System.IO.Stream)"))
					continue;
				if (!new FieldTypes(type).All(encryptedResourceStreamType_fields))
					continue;
				if (FindXxteaMethod(type) == null)
					continue;

				if (!FindManifestResourceStreamMethods(type, out var getManifestResourceStreamMethodTmp1, out var getManifestResourceStreamMethodTmp2))
					continue;

				methodsRestorer.CreateGetManifestResourceStream1(getManifestResourceStreamMethodTmp1);
				methodsRestorer.CreateGetManifestResourceStream2(getManifestResourceStreamMethodTmp2);
				encryptedResourceStreamType = type;
				return;
			}
		}

		static MethodDef FindXxteaMethod(TypeDef type) {
			foreach (var method in type.Methods) {
				if (!method.IsPrivate || method.IsStatic || method.Body == null)
					continue;
				if (DotNetUtils.IsMethod(method, "System.Void", "(System.UInt32[],System.UInt32[])")) {
					if (!DeobUtils.HasInteger(method, 0x9E3779B9))
						continue;
				}
				else if (DotNetUtils.IsMethod(method, "System.Void", "(System.UInt32[],System.UInt32[],System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)")) {
					// Here if 5.0. 0x9E3779B9 is passed to it as the last arg.
				}
				else
					continue;
				if (!DeobUtils.HasInteger(method, 52))
					continue;

				return method;
			}
			return null;
		}

		static bool FindManifestResourceStreamMethods(TypeDef type, out MethodDef getManifestResourceStreamMethodTmp1, out MethodDef getManifestResourceStreamMethodTmp2) {
			getManifestResourceStreamMethodTmp1 = null;
			getManifestResourceStreamMethodTmp2 = null;
			foreach (var method in type.Methods) {
				if (!method.IsStatic || method.Body == null)
					continue;
				if (DotNetUtils.IsMethod(method, "System.IO.Stream", "(System.Reflection.Assembly,System.String)"))
					getManifestResourceStreamMethodTmp1 = method;
				else if (DotNetUtils.IsMethod(method, "System.IO.Stream", "(System.Reflection.Assembly,System.Type,System.String)"))
					getManifestResourceStreamMethodTmp2 = method;
			}
			return getManifestResourceStreamMethodTmp1 != null && getManifestResourceStreamMethodTmp2 != null;
		}

		public void Decrypt() {
			for (int i = 0; i < module.Resources.Count; i++) {
				var resource = module.Resources[i] as EmbeddedResource;
				if (resource == null)
					continue;

				var rsrcReader = resource.CreateReader();
				var decrypted = Decrypt(ref rsrcReader);
				if (decrypted == null)
					continue;

				Logger.v("Decrypted resource {0}", Utils.ToCsharpString(resource.Name));
				module.Resources[i] = new EmbeddedResource(resource.Name, decrypted, resource.Attributes);
			}
		}

		byte[] Decrypt(ref DataReader reader) {
			try {
				reader.Position = 0;
				uint sig = reader.ReadUInt32();
				reader.Position = 0;
				if (sig == 0xBEEFCACE)
					return DecryptBeefcace(ref reader);
				if (sig == 0x58455245)
					return DecryptErex(ref reader);
				return null;
			}
			catch (InvalidDataException) {
				return null;
			}
			catch (Exception ex) {
				Logger.w("Got an exception when decrypting resources: {0} - {1}", ex.GetType(), ex.Message);
				return null;
			}
		}

		byte[] DecryptBeefcace(ref DataReader reader) {
			var resourceReader = new ResourceReader(ref reader);
			return new ResourceConverter(module, resourceReader.Read()).Convert();
		}

		byte[] DecryptErex(ref DataReader reader) => new ErexResourceReader(ref reader).Decrypt();

		public void Deobfuscate(Blocks blocks) {
			if (encryptedResourceStreamType == null)
				return;

			methodsRestorer.Deobfuscate(blocks);
		}
	}
}



================================================
File: de4dot.code/deobfuscators/CodeVeil/ResourceInfo.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using dnlib.IO;

namespace de4dot.code.deobfuscators.CodeVeil {
	class ResourceInfo {
		public string name;
		public byte flags;
		public int offset;
		public int length;
		public DataReader dataReader;
		public ResourceInfo(string name, byte flags, int offset, int length) {
			this.name = name;
			this.flags = flags;
			this.offset = offset;
			this.length = length;
		}
		public override string ToString() => $"{flags:X2} {offset:X8} {length} {name}";
	}
}



================================================
File: de4dot.code/deobfuscators/CodeVeil/ResourceReader.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Text;
using dnlib.IO;

namespace de4dot.code.deobfuscators.CodeVeil {
	class ResourceReader {
		DataReader reader;
		string resourceReader;
		string resourceSet;

		public string ResourceReaderName => resourceReader;
		public string ResourceSetName => resourceSet;
		public ResourceReader(ref DataReader reader) => this.reader = reader;

		public ResourceInfo[] Read() {
			if (reader.ReadUInt32() != 0xBEEFCACE)
				throw new InvalidDataException("Invalid magic");
			if (reader.ReadUInt32() <= 0)
				throw new InvalidDataException("Invalid number");
			reader.ReadUInt32();
			resourceReader = reader.ReadSerializedString();
			if (Utils.StartsWith(resourceReader, "System.Resources.ResourceReader", StringComparison.Ordinal))
				throw new InvalidDataException("Resource isn't encrypted");
			resourceSet = reader.ReadSerializedString();
			if (reader.ReadByte() != 1)
				throw new ApplicationException("Invalid version");

			int flags = reader.ReadByte();
			if ((flags & 0xFC) != 0)
				throw new ApplicationException("Invalid flags");
			bool inflateData = (flags & 1) != 0;
			bool encrypted = (flags & 2) != 0;

			int numResources = reader.ReadInt32();
			if (numResources < 0)
				throw new ApplicationException("Invalid number of resources");

			var infos = new ResourceInfo[numResources];
			for (int i = 0; i < numResources; i++) {
				var resourceName = ReadResourceName(ref reader, encrypted);
				int offset = reader.ReadInt32();
				byte resourceFlags = reader.ReadByte();
				int resourceLength = (resourceFlags & 0x80) == 0 ? -1 : reader.ReadInt32();
				infos[i] = new ResourceInfo(resourceName, resourceFlags, offset, resourceLength);
			}

			var dataReader = reader;
			if (encrypted) {
				var key = new uint[4];
				key[0] = dataReader.ReadUInt32();
				key[1] = dataReader.ReadUInt32();
				int numDwords = dataReader.ReadInt32();
				if (numDwords < 0 || numDwords >= 0x40000000)
					throw new ApplicationException("Invalid number of encrypted dwords");
				var encryptedData = new uint[numDwords];
				for (int i = 0; i < numDwords; i++)
					encryptedData[i] = dataReader.ReadUInt32();
				key[2] = dataReader.ReadUInt32();
				key[3] = dataReader.ReadUInt32();
				DeobUtils.XxteaDecrypt(encryptedData, key);
				byte[] decryptedData = new byte[encryptedData.Length * 4];
				Buffer.BlockCopy(encryptedData, 0, decryptedData, 0, decryptedData.Length);
				dataReader = ByteArrayDataReaderFactory.CreateReader(decryptedData);
			}

			if (inflateData) {
				var data = dataReader.ReadRemainingBytes();
				data = DeobUtils.Inflate(data, true);
				dataReader = ByteArrayDataReaderFactory.CreateReader(data);
			}

			foreach (var info in infos)
				info.dataReader = dataReader;

			return infos;
		}

		static string ReadResourceName(ref DataReader reader, bool encrypted) {
			if (!encrypted)
				return reader.ReadSerializedString();

			int len = reader.ReadInt32();
			if (len < 0)
				throw new ApplicationException("Invalid string length");
			var sb = new StringBuilder(len);
			for (int i = 0; i < len; i++)
				sb.Append((char)Rol3(DataReaderUtils.ReadChar(ref reader)));
			return sb.ToString();
		}

		static char Rol3(char c) {
			ushort s = (ushort)c;
			return (char)((s << 3) | (s >> (16 - 3)));
		}
	}
}



================================================
File: de4dot.code/deobfuscators/CodeVeil/StringDecrypter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using dnlib.IO;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.CodeVeil {
	class StringDecrypter {
		ModuleDefMD module;
		MainType mainType;
		TypeDef decrypterType;
		FieldDef stringDataField;
		MethodDef initMethod;
		MethodDef decrypterMethod;
		string[] decryptedStrings;

		public bool Detected => decrypterType != null;
		public TypeDef Type => decrypterType;
		public MethodDef InitMethod => initMethod;
		public MethodDef DecryptMethod => decrypterMethod;

		public StringDecrypter(ModuleDefMD module, MainType mainType) {
			this.module = module;
			this.mainType = mainType;
		}

		public StringDecrypter(ModuleDefMD module, MainType mainType, StringDecrypter oldOne) {
			this.module = module;
			this.mainType = mainType;
			decrypterType = Lookup(oldOne.decrypterType, "Could not find string decrypter type");
			stringDataField = Lookup(oldOne.stringDataField, "Could not find string data field");
			initMethod = Lookup(oldOne.initMethod, "Could not find string decrypter init method");
			decrypterMethod = Lookup(oldOne.decrypterMethod, "Could not find string decrypter method");
		}

		T Lookup<T>(T def, string errorMessage) where T : class, ICodedToken =>
			DeobUtils.Lookup(module, def, errorMessage);

		public void Find() {
			var cctor = DotNetUtils.GetModuleTypeCctor(module);
			if (cctor == null)
				return;

			// V3-V4 calls string decrypter init method in <Module>::.cctor().
			if (Find(cctor))
				return;

			FindV5(cctor);
		}

		bool Find(MethodDef method) {
			if (method == null || method.Body == null || !method.IsStatic)
				return false;

			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count; i++) {
				var call = instrs[i];
				if (call.OpCode.Code != Code.Call)
					continue;
				var initMethodTmp = call.Operand as MethodDef;
				if (initMethodTmp == null || initMethodTmp.Body == null || !initMethodTmp.IsStatic)
					continue;
				if (!DotNetUtils.IsMethod(initMethodTmp, "System.Void", "()"))
					continue;
				if (!CheckType(initMethodTmp.DeclaringType))
					continue;

				decrypterType = initMethodTmp.DeclaringType;
				initMethod = initMethodTmp;
				return true;
			}

			return false;
		}

		// The main decrypter type calls the string decrypter init method inside its init method
		void FindV5(MethodDef method) {
			if (!mainType.Detected)
				return;
			foreach (var calledMethod in DotNetUtils.GetCalledMethods(module, mainType.InitMethod)) {
				if (Find(calledMethod))
					return;
			}
		}

		bool CheckType(TypeDef type) {
			if (!type.HasNestedTypes)
				return false;

			var stringDataFieldTmp = CheckFields(type);
			if (stringDataFieldTmp == null)
				return false;
			var fieldType = DotNetUtils.GetType(module, stringDataFieldTmp.FieldSig.GetFieldType());
			if (fieldType == null || type.NestedTypes.IndexOf(fieldType) < 0)
				return false;

			var decrypterMethodTmp = GetDecrypterMethod(type);
			if (decrypterMethodTmp == null)
				return false;

			stringDataField = stringDataFieldTmp;
			decrypterMethod = decrypterMethodTmp;
			return true;
		}

		static MethodDef GetDecrypterMethod(TypeDef type) {
			MethodDef foundMethod = null;
			foreach (var method in type.Methods) {
				if (method.Body == null || !method.IsStatic)
					continue;
				if (!DotNetUtils.IsMethod(method, "System.String", "(System.Int32)"))
					continue;
				if (foundMethod != null)
					return null;
				foundMethod = method;
			}
			return foundMethod;
		}

		static string[] requiredFields = new string[] {
			"System.Byte[]",
			"System.Int32",
			"System.Int32[]",
			"System.String[]",
			"System.UInt32[]",
		};
		FieldDef CheckFields(TypeDef type) {
			if (!new FieldTypes(type).All(requiredFields))
				return null;

			FieldDef stringData = null;
			foreach (var field in type.Fields) {
				if (field.RVA != 0) {
					if (stringData != null)
						return null;
					stringData = field;
					continue;
				}
			}

			if (stringData == null)
				return null;

			var data = stringData.InitialValue;
			if (data == null || data.Length == 0 || data.Length % 4 != 0)
				return null;

			return stringData;
		}

		public void Initialize() {
			if (initMethod == null || stringDataField == null)
				return;

			var key = GetKey(initMethod);
			if (key == null)
				throw new ApplicationException("Could not find string decrypter key");

			DecryptStrings(key);

			stringDataField.FieldSig.Type = module.CorLibTypes.Byte;
			stringDataField.InitialValue = new byte[1];
			stringDataField.RVA = 0;
		}

		static uint[] GetKey(MethodDef method) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 1; i++) {
				var ldci4 = instrs[i];
				if (!ldci4.IsLdcI4())
					continue;
				if (ldci4.GetLdcI4Value() != 4)
					continue;

				if (instrs[i + 1].OpCode.Code != Code.Newarr)
					continue;

				i++;
				var key = ArrayFinder.GetInitializedUInt32Array(4, method, ref i);
				if (key == null)
					continue;

				return key;
			}
			return null;
		}

		void DecryptStrings(uint[] key) {
			var data = stringDataField.InitialValue;

			var encryptedData = new uint[data.Length / 4];
			Buffer.BlockCopy(data, 0, encryptedData, 0, data.Length);
			DeobUtils.XxteaDecrypt(encryptedData, key);
			var decryptedData = new byte[data.Length];
			Buffer.BlockCopy(encryptedData, 0, decryptedData, 0, data.Length);

			var inflated = DeobUtils.Inflate(decryptedData, 0, decryptedData.Length, true);
			var reader = ByteArrayDataReaderFactory.CreateReader(inflated);
			/*int deflatedLength = (int)*/reader.ReadCompressedUInt32();
			int numStrings = (int)reader.ReadCompressedUInt32();
			decryptedStrings = new string[numStrings];
			var offsets = new int[numStrings];
			for (int i = 0; i < numStrings; i++)
				offsets[i] = (int)reader.ReadCompressedUInt32();
			int startOffset = (int)reader.Position;
			for (int i = 0; i < numStrings; i++) {
				reader.Position = (uint)(startOffset + offsets[i]);
				decryptedStrings[i] = reader.ReadSerializedString();
			}
		}

		public string Decrypt(int index) => decryptedStrings[index];
	}
}



================================================
File: de4dot.code/deobfuscators/CodeVeil/TamperDetection.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.CodeVeil {
	class TamperDetection {
		ModuleDefMD module;
		MainType mainType;
		TypeDef tamperDetectionType;
		List<MethodDef> tamperDetectionMethods = new List<MethodDef>();

		public TypeDef Type => tamperDetectionType;
		public List<MethodDef> Methods => tamperDetectionMethods;

		public TamperDetection(ModuleDefMD module, MainType mainType) {
			this.module = module;
			this.mainType = mainType;
		}

		public void Initialize() {
			if (!mainType.Detected)
				return;

			if (mainType.TamperCheckMethod == null)
				return;

			FindTamperDetectionTypes();
		}

		void FindTamperDetectionTypes() {
			foreach (var type in module.Types) {
				if (!type.HasNestedTypes)
					continue;
				if ((type.Attributes & ~TypeAttributes.Sealed) != 0)
					continue;

				if (!CheckTamperDetectionClasses(type.NestedTypes))
					continue;

				tamperDetectionType = type;
				FindTamperDetectionMethods();
				return;
			}
		}

		void FindTamperDetectionMethods() {
			foreach (var type in tamperDetectionType.NestedTypes) {
				foreach (var method in type.Methods) {
					if (!method.IsStatic || method.Body == null)
						continue;
					if (method.Name == ".cctor")
						continue;
					if (DotNetUtils.IsMethod(method, "System.Void", "()"))
						tamperDetectionMethods.Add(method);
				}
			}
		}

		bool CheckTamperDetectionClasses(IEnumerable<TypeDef> types) {
			foreach (var type in types) {
				if (!IsTamperDetectionClass(type))
					return false;
			}
			return true;
		}

		bool IsTamperDetectionClass(TypeDef type) {
			if (type.BaseType == null || type.BaseType.FullName != "System.Object")
				return false;
			if ((type.Attributes & ~TypeAttributes.Sealed) != TypeAttributes.NestedAssembly)
				return false;

			MethodDef cctor = null, initMethod = null;
			foreach (var method in type.Methods) {
				if (InvalidMethodsFinder.IsInvalidMethod(method))
					continue;
				if (!method.IsStatic || method.Body == null)
					return false;
				if (method.Name == ".cctor")
					cctor = method;
				else if (DotNetUtils.IsMethod(method, "System.Void", "()"))
					initMethod = method;
			}
			if (cctor == null || initMethod == null)
				return false;

			if (!CallsMainTypeTamperCheckMethod(cctor))
				return false;

			return true;
		}

		bool CallsMainTypeTamperCheckMethod(MethodDef method) {
			foreach (var calledMethod in DotNetUtils.GetCalledMethods(module, method)) {
				if (calledMethod == mainType.TamperCheckMethod)
					return true;
			}

			var instructions = method.Body.Instructions;
			for (int i = 0; i < instructions.Count; i++) {
				var instrs = DotNetUtils.GetInstructions(instructions, i, OpCodes.Ldtoken, OpCodes.Call, OpCodes.Call, OpCodes.Ldc_I8, OpCodes.Call);
				if (instrs == null)
					continue;

				if (!CheckInvokeCall(instrs[1], "System.Type", "(System.RuntimeTypeHandle)"))
					continue;
				if (!CheckInvokeCall(instrs[2], "System.Reflection.Assembly", "(System.Object)"))
					continue;
				if (!CheckInvokeCall(instrs[4], "System.Void", "(System.Reflection.Assembly,System.UInt64)"))
					continue;

				return true;
			}

			return false;
		}

		static bool CheckInvokeCall(Instruction instr, string returnType, string parameters) {
			var method = instr.Operand as MethodDef;
			if (method == null)
				return false;
			if (method.Name != "Invoke")
				return false;
			return DotNetUtils.IsMethod(method, returnType, parameters);
		}
	}
}



================================================
File: de4dot.code/deobfuscators/CodeWall/AssemblyDecrypter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.IO;
using System.Security.Cryptography;
using System.Text;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;
using dnlib.DotNet.Resources;

namespace de4dot.code.deobfuscators.CodeWall {
	class AssemblyDecrypter {
		ModuleDefMD module;
		ISimpleDeobfuscator simpleDeobfuscator;
		IDeobfuscator deob;
		List<AssemblyInfo> assemblyInfos = new List<AssemblyInfo>();
		string entryPointAssemblyKey;
		string resourcePassword;
		string resourceSalt;
		EmbeddedResource assemblyResource;
		ModuleDefMD resourceModule;

		public class AssemblyInfo {
			public readonly byte[] data;
			public readonly string extension;
			public readonly string assemblyFullName;
			public readonly string assemblySimpleName;
			public readonly bool isEntryPointAssembly;

			public AssemblyInfo(byte[] data, string extension, string assemblyFullName, string assemblySimpleName, bool isEntryPointAssembly) {
				this.data = data;
				this.extension = extension;
				this.assemblyFullName = assemblyFullName;
				this.assemblySimpleName = assemblySimpleName;
				this.isEntryPointAssembly = isEntryPointAssembly;
			}

			public override string ToString() => assemblyFullName;
		}

		public IEnumerable<AssemblyInfo> AssemblyInfos => assemblyInfos;

		public AssemblyDecrypter(ModuleDefMD module, ISimpleDeobfuscator simpleDeobfuscator, IDeobfuscator deob) {
			this.module = module;
			this.simpleDeobfuscator = simpleDeobfuscator;
			this.deob = deob;
		}

		public void Find() {
			var method = module.EntryPoint;
			if (!CheckEntryPoint(method))
				return;

			var mainKey = GetMainResourceKey(method, out var decryptAssemblyMethod);
			if (mainKey == null)
				return;

			DeobfuscateAll(decryptAssemblyMethod);
			var resource = GetResource(decryptAssemblyMethod, out var theResourceModule);
			if (resource == null)
				return;
			if (!GetPassword(decryptAssemblyMethod, out string password, out string salt))
				return;

			entryPointAssemblyKey = mainKey;
			resourcePassword = password;
			resourceSalt = salt;
			assemblyResource = resource;
			resourceModule = theResourceModule;
			DecryptAllAssemblies();
		}

		static readonly string[] requiredLocals = new string[] {
			"System.AppDomain",
			"System.DateTime",
		};
		bool CheckEntryPoint(MethodDef method) {
			if (method == null)
				return false;
			if (!new LocalTypes(method).All(requiredLocals))
				return false;
			var handlers = DeobUtils.GetAllResolveHandlers(method);
			if (handlers.Count != 1)
				return false;

			return true;
		}

		void DeobfuscateAll(MethodDef method) {
			simpleDeobfuscator.Deobfuscate(method);
			simpleDeobfuscator.DecryptStrings(method, deob);
		}

		string GetMainResourceKey(MethodDef method, out MethodDef decryptAssemblyMethod) {
			foreach (var calledMethod in DotNetUtils.GetCalledMethods(module, method)) {
				if (!calledMethod.IsStatic || calledMethod.Body == null)
					continue;
				if (!DotNetUtils.IsMethod(calledMethod, "System.Void", "(System.String[])"))
					continue;

				DeobfuscateAll(calledMethod);
				string keyInfo = GetMainResourceKeyInfo(calledMethod, out decryptAssemblyMethod);
				if (keyInfo == null)
					continue;
				return BitConverter.ToString(new MD5CryptoServiceProvider().ComputeHash(new ASCIIEncoding().GetBytes(keyInfo))).Replace("-", "");
			}

			decryptAssemblyMethod = null;
			return null;
		}

		string GetMainResourceKeyInfo(MethodDef method, out MethodDef decryptAssemblyMethod) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 1; i++) {
				var ldstr = instrs[i];
				if (ldstr.OpCode.Code != Code.Ldstr)
					continue;
				var call = instrs[i + 1];
				if (call.OpCode.Code != Code.Call)
					continue;
				var calledMethod = call.Operand as MethodDef;
				if (calledMethod == null)
					continue;

				decryptAssemblyMethod = calledMethod;
				return (string)ldstr.Operand;
			}
			decryptAssemblyMethod = null;
			return null;
		}

		EmbeddedResource GetResource(MethodDef method, out ModuleDefMD theResourceModule) {
			string resourceDllFileName = null;
			theResourceModule = module;
			foreach (var s in DotNetUtils.GetCodeStrings(method)) {
				if (s.Length > 0 && s[0] == '\\')
					resourceDllFileName = s;
				if (DotNetUtils.GetResource(theResourceModule, s + ".resources") is EmbeddedResource resource)
					return resource;
			}

			if (resourceDllFileName == null)
				return null;
			// Here if CW 2.x
			theResourceModule = GetResourceModule(resourceDllFileName);
			if (theResourceModule == null)
				return null;
			foreach (var s in DotNetUtils.GetCodeStrings(method)) {
				if (DotNetUtils.GetResource(theResourceModule, s + ".resources") is EmbeddedResource resource)
					return resource;
			}

			theResourceModule = null;
			return null;
		}

		ModuleDefMD GetResourceModule(string name) {
			try {
				var resourceDllFileName = Path.Combine(Path.GetDirectoryName(module.Location), name.Substring(1));
				return ModuleDefMD.Load(resourceDllFileName);
			}
			catch {
				return null;
			}
		}

		bool GetPassword(MethodDef method, out string password, out string salt) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 1; i++) {
				var ldstr1 = instrs[i];
				if (ldstr1.OpCode.Code != Code.Ldstr)
					continue;
				var ldstr2 = instrs[i + 1];
				if (ldstr2.OpCode.Code != Code.Ldstr)
					continue;

				password = (string)ldstr1.Operand;
				salt = (string)ldstr2.Operand;
				if (password == null || salt == null)
					continue;
				return true;
			}

			password = null;
			salt = null;
			return false;
		}

		void DecryptAllAssemblies() {
			if (assemblyResource == null)
				return;
			var resourceSet = ResourceReader.Read(resourceModule, assemblyResource.CreateReader());
			foreach (var resourceElement in resourceSet.ResourceElements) {
				if (resourceElement.ResourceData.Code != ResourceTypeCode.ByteArray)
					throw new ApplicationException("Invalid resource");
				var resourceData = (BuiltInResourceData)resourceElement.ResourceData;
				var assemblyData = Decrypt((byte[])resourceData.Data);
				var theModule = ModuleDefMD.Load(assemblyData);
				bool isMain = resourceElement.Name == entryPointAssemblyKey;
				assemblyInfos.Add(new AssemblyInfo(assemblyData, DeobUtils.GetExtension(theModule.Kind), theModule.Assembly.FullName, theModule.Assembly.Name.String, isMain));
			}
		}

		byte[] Decrypt(byte[] encrypted) {
			var keyGenerator = new PasswordDeriveBytes(resourcePassword, Encoding.ASCII.GetBytes(resourceSalt));
			return DeobUtils.Inflate(DeobUtils.AesDecrypt(encrypted, keyGenerator.GetBytes(32), keyGenerator.GetBytes(16)), false);
		}

		public AssemblyInfo FindMain(string asmFullName) {
			foreach (var asmInfo in assemblyInfos) {
				if (asmInfo.isEntryPointAssembly && asmInfo.assemblyFullName == asmFullName)
					return asmInfo;
			}
			return null;
		}

		public AssemblyInfo FindMain() {
			foreach (var asmInfo in assemblyInfos) {
				if (asmInfo.isEntryPointAssembly)
					return asmInfo;
			}
			return null;
		}

		public void Remove(AssemblyInfo asmInfo) => assemblyInfos.Remove(asmInfo);
	}
}



================================================
File: de4dot.code/deobfuscators/CodeWall/Deobfuscator.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.CodeWall {
	public class DeobfuscatorInfo : DeobfuscatorInfoBase {
		public const string THE_NAME = "CodeWall";
		public const string THE_TYPE = "cw";
		const string DEFAULT_REGEX = @"!^[0-9A-F]{32}$&!^[_<>{}$.`-]$&" + DeobfuscatorBase.DEFAULT_ASIAN_VALID_NAME_REGEX;
		BoolOption dumpEmbeddedAssemblies;
		BoolOption decryptMainAsm;

		public DeobfuscatorInfo()
			: base(DEFAULT_REGEX) {
			dumpEmbeddedAssemblies = new BoolOption(null, MakeArgName("embedded"), "Dump embedded assemblies", true);
			decryptMainAsm = new BoolOption(null, MakeArgName("decrypt-main"), "Decrypt main embedded assembly", true);
		}

		public override string Name => THE_NAME;
		public override string Type => THE_TYPE;

		public override IDeobfuscator CreateDeobfuscator() =>
			new Deobfuscator(new Deobfuscator.Options {
				ValidNameRegex = validNameRegex.Get(),
				DumpEmbeddedAssemblies = dumpEmbeddedAssemblies.Get(),
				DecryptMainAsm = decryptMainAsm.Get(),
			});

		protected override IEnumerable<Option> GetOptionsInternal() =>
			new List<Option>() {
				dumpEmbeddedAssemblies,
				decryptMainAsm,
			};
	}

	class Deobfuscator : DeobfuscatorBase {
		Options options;
		MethodsDecrypter methodsDecrypter;
		StringDecrypter stringDecrypter;
		AssemblyDecrypter assemblyDecrypter;
		string obfuscatorName = DeobfuscatorInfo.THE_NAME;

		internal class Options : OptionsBase {
			public bool DumpEmbeddedAssemblies { get; set; }
			public bool DecryptMainAsm { get; set; }
		}

		public override string Type => DeobfuscatorInfo.THE_TYPE;
		public override string TypeLong => DeobfuscatorInfo.THE_NAME;
		public override string Name => obfuscatorName;
		public Deobfuscator(Options options) : base(options) => this.options = options;

		protected override int DetectInternal() {
			int val = 0;

			int sum = ToInt32(methodsDecrypter.Detected) +
					ToInt32(stringDecrypter.Detected);
			if (sum > 0)
				val += 100 + 10 * (sum - 1);

			// If methods are encrypted, and more than one obfuscator has been used, then CW
			// was most likely the last obfuscator used. Increment val so the user doesn't have
			// to force CW.
			if (methodsDecrypter.Detected)
				val += 50;

			return val;
		}

		protected override void ScanForObfuscator() {
			methodsDecrypter = new MethodsDecrypter(module);
			methodsDecrypter.Find();
			stringDecrypter = new StringDecrypter(module);
			stringDecrypter.Find();
			var version = DetectVersion();
			if (version != null)
				obfuscatorName = DeobfuscatorInfo.THE_NAME + " " + version;
		}

		string DetectVersion() {
			if (stringDecrypter.Detected) {
				switch (stringDecrypter.TheVersion) {
				case StringDecrypter.Version.V30: return "v3.0 - v3.5";
				case StringDecrypter.Version.V36: return "v3.6 - v4.1";
				}
			}

			if (methodsDecrypter.Detected)
				return "v3.0 - v4.1";

			return null;
		}

		[Flags]
		enum DecryptState {
			CanDecryptMethods = 1,
			CanGetMainAssembly = 2,
		}
		DecryptState decryptState = DecryptState.CanDecryptMethods | DecryptState.CanGetMainAssembly;
		public override bool GetDecryptedModule(int count, ref byte[] newFileData, ref DumpedMethods dumpedMethods) {
			if ((decryptState & DecryptState.CanDecryptMethods) != 0) {
				if (DecryptModule(ref newFileData, ref dumpedMethods)) {
					ModuleBytes = newFileData;
					decryptState &= ~DecryptState.CanDecryptMethods;
					return true;
				}
			}

			if (options.DecryptMainAsm && (decryptState & DecryptState.CanGetMainAssembly) != 0) {
				newFileData = GetMainAssemblyBytes();
				if (newFileData != null) {
					ModuleBytes = newFileData;
					decryptState &= ~DecryptState.CanGetMainAssembly;
					decryptState |= DecryptState.CanDecryptMethods;
					return true;
				}
			}

			return false;
		}

		bool DecryptModule(ref byte[] newFileData, ref DumpedMethods dumpedMethods) {
			if (!methodsDecrypter.Detected)
				return false;

			byte[] fileData = ModuleBytes ?? DeobUtils.ReadModule(module);
			using (var peImage = new MyPEImage(fileData)) {
				if (!methodsDecrypter.Decrypt(peImage, ref dumpedMethods))
					return false;
			}

			newFileData = fileData;
			return true;
		}

		byte[] GetMainAssemblyBytes() {
			try {
				InitializeStringDecrypter();
				InitializeAssemblyDecrypter();
			}
			catch {
				return null;
			}

			var asm = module.Assembly;
			if (asm == null || assemblyDecrypter == null)
				return null;
			var asmInfo = assemblyDecrypter.FindMain(asm.FullName) ?? assemblyDecrypter.FindMain();
			if (asmInfo == null)
				return null;

			assemblyDecrypter.Remove(asmInfo);
			return asmInfo.data;
		}

		public override IDeobfuscator ModuleReloaded(ModuleDefMD module) {
			var newOne = new Deobfuscator(options);
			newOne.SetModule(module);
			newOne.methodsDecrypter = new MethodsDecrypter(module);
			newOne.methodsDecrypter.Find();
			newOne.stringDecrypter = new StringDecrypter(module);
			newOne.stringDecrypter.Find();
			newOne.assemblyDecrypter = assemblyDecrypter;
			newOne.ModuleBytes = ModuleBytes;
			newOne.decryptState = decryptState;
			return newOne;
		}

		public override void DeobfuscateBegin() {
			base.DeobfuscateBegin();

			InitializeStringDecrypter();
			InitializeAssemblyDecrypter();
			DumpEmbeddedAssemblies();
		}

		bool hasInitializedStringDecrypter = false;
		void InitializeStringDecrypter() {
			if (hasInitializedStringDecrypter)
				return;
			stringDecrypter.Initialize(DeobfuscatedFile);
			foreach (var info in stringDecrypter.Infos)
				staticStringInliner.Add(info.Method, (method, gim, args) => stringDecrypter.Decrypt(method, (int)args[0], (int)args[1], (int)args[2]));
			DeobfuscatedFile.StringDecryptersAdded();
			hasInitializedStringDecrypter = true;
		}

		void InitializeAssemblyDecrypter() {
			if (!options.DumpEmbeddedAssemblies || assemblyDecrypter != null)
				return;
			assemblyDecrypter = new AssemblyDecrypter(module, DeobfuscatedFile, this);
			assemblyDecrypter.Find();
		}

		void DumpEmbeddedAssemblies() {
			if (assemblyDecrypter == null)
				return;
			foreach (var info in assemblyDecrypter.AssemblyInfos) {
				var asmName = info.assemblySimpleName;
				if (info.isEntryPointAssembly)
					asmName += "_real";
				DeobfuscatedFile.CreateAssemblyFile(info.data, asmName, info.extension);
			}
		}

		public override void DeobfuscateMethodEnd(Blocks blocks) {
			methodsDecrypter.Deobfuscate(blocks);
			base.DeobfuscateMethodEnd(blocks);
		}

		public override void DeobfuscateEnd() {
			if (CanRemoveStringDecrypterType) {
				foreach (var info in stringDecrypter.Infos) {
					AddResourceToBeRemoved(info.Resource, "Encrypted strings");
					AddTypeToBeRemoved(info.Type, "String decrypter type");
				}
			}
			base.DeobfuscateEnd();
		}

		public override IEnumerable<int> GetStringDecrypterMethods() {
			var list = new List<int>();
			foreach (var info in stringDecrypter.Infos)
				list.Add(info.Method.MDToken.ToInt32());
			return list;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/CodeWall/KeyGenerator.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using de4dot.code.deobfuscators.CodeWall.randomc;

namespace de4dot.code.deobfuscators.CodeWall {
	class KeyGenerator {
		CRandomMersenne mersenne;
		CRandomMother mother;

		public KeyGenerator(int seed) {
			mersenne = new CRandomMersenne(seed);
			mother = new CRandomMother(seed);
		}

		uint Random() => (mersenne.BRandom() >> 1) ^ (uint)Math.Abs((int)(mother.Random() * int.MinValue));

		public byte[] Generate(int size) {
			var key = new byte[size];
			for (int i = 0; i < size; i++)
				key[i] = (byte)Random();
			return key;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/CodeWall/MethodsDecrypter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.CodeWall {
	class MethodsDecrypter {
		static readonly byte[] newCodeHeader = new byte[6] { 0x2B, 4, 0, 0, 0, 0 };
		static readonly byte[] decryptKey = new byte[10] { 0x8D, 0xB5, 0x2C, 0x3A, 0x1F, 0xC7, 0x31, 0xC3, 0xCD, 0x47 };

		ModuleDefMD module;
		IMethod initMethod;

		public bool Detected => initMethod != null;
		public MethodsDecrypter(ModuleDefMD module) => this.module = module;

		public void Find() {
			foreach (var cctor in DeobUtils.GetInitCctors(module, 3)) {
				if (CheckCctor(cctor))
					return;
			}
		}

		bool CheckCctor(MethodDef method) {
			if (method == null || method.Body == null)
				return false;

			foreach (var instr in method.Body.Instructions) {
				if (instr.OpCode.Code != Code.Call)
					continue;
				var calledMethod = instr.Operand as IMethod;
				if (calledMethod == null)
					continue;
				if (calledMethod.DeclaringType.Scope == module)
					return false;
				if (calledMethod.FullName != "System.Void Q::X()")
					return false;

				initMethod = calledMethod;
				return true;
			}
			return false;
		}

		public bool Decrypt(MyPEImage peImage, ref DumpedMethods dumpedMethods) {
			dumpedMethods = new DumpedMethods();

			bool decrypted = false;

			var methodDef = peImage.Metadata.TablesStream.MethodTable;
			for (uint rid = 1; rid <= methodDef.Rows; rid++) {
				var dm = new DumpedMethod();
				peImage.ReadMethodTableRowTo(dm, rid);

				if (dm.mdRVA == 0)
					continue;
				uint bodyOffset = peImage.RvaToOffset(dm.mdRVA);

				peImage.Reader.Position = bodyOffset;
				var mbHeader = MethodBodyParser.ParseMethodBody(ref peImage.Reader, out dm.code, out dm.extraSections);
				peImage.UpdateMethodHeaderInfo(dm, mbHeader);

				if (dm.code.Length < 6 || dm.code[0] != 0x2A || dm.code[1] != 0x2A)
					continue;

				int seed = BitConverter.ToInt32(dm.code, 2);
				Array.Copy(newCodeHeader, dm.code, newCodeHeader.Length);
				if (seed == 0)
					Decrypt(dm.code);
				else
					Decrypt(dm.code, seed);

				dumpedMethods.Add(dm);
				decrypted = true;
			}

			return decrypted;
		}

		void Decrypt(byte[] data) {
			for (int i = 6; i < data.Length; i++)
				data[i] ^= decryptKey[i % decryptKey.Length];
		}

		void Decrypt(byte[] data, int seed) {
			var key = new KeyGenerator(seed).Generate(data.Length);
			for (int i = 6; i < data.Length; i++)
				data[i] ^= key[i];
		}

		public void Deobfuscate(Blocks blocks) {
			if (initMethod == null)
				return;
			if (blocks.Method.Name != ".cctor")
				return;

			foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {
				var instrs = block.Instructions;
				for (int i = 0; i < instrs.Count; i++) {
					var instr = instrs[i];
					if (instr.OpCode.Code != Code.Call)
						continue;
					var calledMethod = instr.Operand as IMethod;
					if (!MethodEqualityComparer.CompareDeclaringTypes.Equals(calledMethod, initMethod))
						continue;
					block.Remove(i, 1);
					i--;
				}
			}
		}
	}
}



================================================
File: de4dot.code/deobfuscators/CodeWall/StringDecrypter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Text;
using dnlib.IO;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.CodeWall {
	class StringDecrypter {
		ModuleDefMD module;
		MethodDefAndDeclaringTypeDict<StringEncrypterInfo> stringEncrypterInfos = new MethodDefAndDeclaringTypeDict<StringEncrypterInfo>();
		Version version;

		public enum Version {
			Unknown,
			V30,	// 3.0 - 3.5
			V36,	// 3.6 - 4.1
		}

		public class StringEncrypterInfo {
			MethodDef method;

			public TypeDef Type => method.DeclaringType;
			public MethodDef Method => method;
			public EmbeddedResource Resource { get; set; }
			public int Magic1 { get; set; }
			public int Magic2 { get; set; }
			public int Magic3 { get; set; }
			public DataReader Reader;

			public StringEncrypterInfo(MethodDef method) => this.method = method;

			public string Decrypt(int magic1, int magic2, int magic3) {
				int dataLen = magic3 ^ Magic3;
				var key = GetKey(magic1 ^ Magic1, dataLen);
				Reader.Position = (uint)GetDataOffset(magic2);
				var data = Reader.ReadBytes(dataLen);
				for (int i = 0; i < dataLen; i++)
					data[i] ^= key[i];
				return Encoding.Unicode.GetString(data);
			}

			byte[] GetKey(int seed, int keyLen) {
				var random = new Random(seed);
				var key = new byte[keyLen];
				random.NextBytes(key);
				return key;
			}

			int GetDataOffset(int magic2) {
				var pkt = GetPublicKeyToken();
				if (pkt == null)
					return magic2 ^ Magic2;
				else
					return magic2 ^ BitConverter.ToInt32(pkt, 0) ^ BitConverter.ToInt32(pkt, 4);
			}

			byte[] GetPublicKeyToken() {
				var module = method.Module;
				if (module.Assembly == null || PublicKeyBase.IsNullOrEmpty2(module.Assembly.PublicKey))
					return null;
				return module.Assembly.PublicKeyToken.Data;
			}

			public override string ToString() => $"{Method.MDToken.ToInt32():X8} M1:{Magic1:X8} M2:{Magic2:X8} M3:{Magic3:X8}";
		}

		public bool Detected => stringEncrypterInfos.Count != 0;
		public Version TheVersion => version;

		public IEnumerable<StringEncrypterInfo> Infos {
			get {
				var list = new List<StringEncrypterInfo>();
				foreach (var info in stringEncrypterInfos.GetValues()) {
					if (info.Resource != null)
						list.Add(info);
				}
				return list;
			}
		}

		public StringDecrypter(ModuleDefMD module) => this.module = module;

		public void Find() {
			foreach (var type in module.Types) {
				var decrypterVersion = CheckType(type, out var decrypterMethod);
				if (decrypterVersion == Version.Unknown)
					continue;
				version = decrypterVersion;
				stringEncrypterInfos.Add(decrypterMethod, new StringEncrypterInfo(decrypterMethod));
			}
		}

		Version CheckType(TypeDef type, out MethodDef decrypterMethod) {
			MethodDef method;

			if ((method = CheckTypeV30(type)) != null) {
				decrypterMethod = method;
				return Version.V30;
			}

			if ((method = CheckTypeV36(type)) != null) {
				decrypterMethod = method;
				return Version.V36;
			}

			decrypterMethod = null;
			return Version.Unknown;
		}

		static readonly string[] requiredTypes_v30 = new string[] {
			"System.Collections.Generic.Dictionary`2<System.Int32,System.String>",
		};
		static readonly string[] requiredLocals_v30 = new string[] {
			"System.Int32",
			"System.Byte[]",
			"System.Reflection.Assembly",
			"System.IO.Stream",
			"System.Random",
			"System.String",
		};
		MethodDef CheckTypeV30(TypeDef type) {
			var decrypterMethod = CheckMethodsV30(type);
			if (decrypterMethod == null)
				return null;
			if (!new FieldTypes(type).Exactly(requiredTypes_v30))
				return null;
			if (!new LocalTypes(decrypterMethod).Exactly(requiredLocals_v30))
				return null;

			return decrypterMethod;
		}

		static MethodDef CheckMethodsV30(TypeDef type) {
			if (type.Methods.Count < 1 || type.Methods.Count > 2)
				return null;

			MethodDef decrypterMethod = null;
			//MethodDef cctor = null;
			foreach (var method in type.Methods) {
				if (method.Name == ".cctor") {
					//cctor = method;
					continue;
				}
				if (decrypterMethod != null)
					return null;
				if (!DotNetUtils.IsMethod(method, "System.String", "(System.Int32,System.Int32,System.Int32)"))
					return null;
				decrypterMethod = method;
			}
			if (decrypterMethod == null || !decrypterMethod.IsStatic)
				return null;
			return decrypterMethod;
		}

		static readonly string[] requiredTypes_v36 = new string[] {
			"System.Object",
			"System.Collections.Generic.Dictionary`2<System.Int32,System.String>",
		};
		static readonly string[] requiredLocals_v36 = new string[] {
			"System.Int32",
			"System.Byte[]",
			"System.Reflection.Assembly",
			"System.IO.Stream",
			"System.Random",
			"System.String",
			"System.Object",
		};
		MethodDef CheckTypeV36(TypeDef type) {
			var decrypterMethod = CheckMethodsV36(type);
			if (decrypterMethod == null)
				return null;
			if (!new FieldTypes(type).Exactly(requiredTypes_v36))
				return null;
			if (!new LocalTypes(decrypterMethod).Exactly(requiredLocals_v36))
				return null;

			return decrypterMethod;
		}

		static MethodDef CheckMethodsV36(TypeDef type) {
			if (type.Methods.Count != 2)
				return null;

			MethodDef decrypterMethod = null;
			MethodDef cctor = null;
			foreach (var method in type.Methods) {
				if (method.Name == ".cctor") {
					cctor = method;
					continue;
				}
				if (decrypterMethod != null)
					return null;
				if (!DotNetUtils.IsMethod(method, "System.String", "(System.Int32,System.Int32,System.Int32)"))
					return null;
				decrypterMethod = method;
			}
			if (cctor == null)
				return null;
			if (decrypterMethod == null || !decrypterMethod.IsStatic)
				return null;
			return decrypterMethod;
		}

		public void Initialize(ISimpleDeobfuscator simpleDeobfuscator) {
			foreach (var info in stringEncrypterInfos.GetValues()) {
				simpleDeobfuscator.Deobfuscate(info.Method);
				info.Resource = FindResource(info.Method);
				if (info.Resource == null) {
					Logger.w("Could not find encrypted strings resource (Method {0:X8})", info.Method.MDToken.ToInt32());
					continue;
				}
				info.Magic1 = FindMagic1(info.Method);
				info.Magic2 = FindMagic2(info.Method);
				info.Magic3 = FindMagic3(info.Method);
				info.Reader = info.Resource.CreateReader();
				info.Reader.Position = 0;
			}
		}

		EmbeddedResource FindResource(MethodDef method) =>
			DotNetUtils.GetResource(module, DotNetUtils.GetCodeStrings(method)) as EmbeddedResource;

		static int FindMagic1(MethodDef method) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 2; i++) {
				var ldarg = instrs[i];
				if (!ldarg.IsLdarg() || ldarg.GetParameterIndex() != 0)
					continue;
				var ldci4 = instrs[i + 1];
				if (!ldci4.IsLdcI4())
					continue;
				if (instrs[i + 2].OpCode.Code != Code.Xor)
					continue;
				return ldci4.GetLdcI4Value();
			}
			throw new ApplicationException("Could not find magic1");
		}

		static int FindMagic2(MethodDef method) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 2; i++) {
				var ldloc = instrs[i];
				if (!ldloc.IsLdloc())
					continue;
				var ldci4 = instrs[i + 1];
				if (!ldci4.IsLdcI4())
					continue;
				if (instrs[i + 2].OpCode.Code != Code.Xor)
					continue;
				return ldci4.GetLdcI4Value();
			}
			throw new ApplicationException("Could not find magic2");
		}

		static int FindMagic3(MethodDef method) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 2; i++) {
				var ldarg = instrs[i];
				if (!ldarg.IsLdarg() || ldarg.GetParameterIndex() != 2)
					continue;
				var ldci4 = instrs[i + 1];
				if (!ldci4.IsLdcI4())
					continue;
				if (instrs[i + 2].OpCode.Code != Code.Xor)
					continue;
				return ldci4.GetLdcI4Value();
			}
			throw new ApplicationException("Could not find magic3");
		}

		public string Decrypt(MethodDef method, int magic1, int magic2, int magic3) {
			var info = stringEncrypterInfos.Find(method);
			return info.Decrypt(magic1, magic2, magic3);
		}
	}
}



================================================
File: de4dot.code/deobfuscators/CodeWall/randomc/CRandomMersenne.cs
================================================
/**************************   mersenne.cpp   **********************************
* Author:        Agner Fog
* Date created:  2001
* Last modified: 2008-11-16
* Project:       randomc.h
* Platform:      Any C++
* Description:
* Random Number generator of type 'Mersenne Twister'
*
* This random number generator is described in the article by
* M. Matsumoto & T. Nishimura, in:
* ACM Transactions on Modeling and Computer Simulation,
* vol. 8, no. 1, 1998, pp. 3-30.
* Details on the initialization scheme can be found at
* http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html
*
* Further documentation:
* The file ran-instructions.pdf contains further documentation and 
* instructions.
*
* Copyright 2001-2008 by Agner Fog. 
* GNU General Public License http://www.gnu.org/licenses/gpl.html
*******************************************************************************/

// Only the methods I need have been ported to C#...

namespace de4dot.code.deobfuscators.CodeWall.randomc {
	class CRandomMersenne {
		const int MERS_N = 624;
		const int MERS_M = 397;
		const int MERS_R = 31;
		const int MERS_U = 11;
		const int MERS_S = 7;
		const int MERS_T = 15;
		const int MERS_L = 18;
		const uint MERS_A = 0x9908B0DF;
		const uint MERS_B = 0x9D2C5680;
		const uint MERS_C = 0xEFC60000;

		uint[] mt = new uint[MERS_N];	// State vector
		int mti;						// Index into mt

		public CRandomMersenne() {
		}

		public CRandomMersenne(int seed) => RandomInit(seed);

		void Init0(int seed) {
			// Seed generator
			const uint factor = 1812433253;
			mt[0] = (uint)seed;
			for (mti = 1; mti < MERS_N; mti++) {
				mt[mti] = (factor * (mt[mti - 1] ^ (mt[mti - 1] >> 30)) + (uint)mti);
			}
		}

		public void RandomInit(int seed) {
			// Initialize and seed
			Init0(seed);

			// Randomize some more
			for (int i = 0; i < 37; i++) BRandom();
		}

		static uint[] mag01 = new uint[2] { 0, MERS_A };
		public uint BRandom() {
			// Generate 32 random bits
			uint y;

			if (mti >= MERS_N) {
				// Generate MERS_N words at one time
				const uint LOWER_MASK = (1U << MERS_R) - 1;		// Lower MERS_R bits
				const uint UPPER_MASK = 0xFFFFFFFF << MERS_R;	// Upper (32 - MERS_R) bits

				int kk;
				for (kk = 0; kk < MERS_N - MERS_M; kk++) {
					y = (mt[kk] & UPPER_MASK) | (mt[kk + 1] & LOWER_MASK);
					mt[kk] = mt[kk + MERS_M] ^ (y >> 1) ^ mag01[y & 1];
				}

				for (; kk < MERS_N - 1; kk++) {
					y = (mt[kk] & UPPER_MASK) | (mt[kk + 1] & LOWER_MASK);
					mt[kk] = mt[kk + (MERS_M - MERS_N)] ^ (y >> 1) ^ mag01[y & 1];
				}

				y = (mt[MERS_N - 1] & UPPER_MASK) | (mt[0] & LOWER_MASK);
				mt[MERS_N - 1] = mt[MERS_M - 1] ^ (y >> 1) ^ mag01[y & 1];
				mti = 0;
			}
			y = mt[mti++];

			// Tempering (May be omitted):
			y ^= y >> MERS_U;
			y ^= (y << MERS_S) & MERS_B;
			y ^= (y << MERS_T) & MERS_C;
			y ^= y >> MERS_L;

			return y;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/CodeWall/randomc/CRandomMother.cs
================================================
/**************************   mother.cpp   ************************************
* Author:        Agner Fog
* Date created:  1999
* Last modified: 2008-11-16
* Project:       randomc.h
* Platform:      This implementation uses 64-bit integers for intermediate calculations.
*                Works only on compilers that support 64-bit integers.
* Description:
* Random Number generator of type 'Mother-Of-All generator'.
*
* This is a multiply-with-carry type of random number generator
* invented by George Marsaglia.  The algorithm is:             
* S = 2111111111*X[n-4] + 1492*X[n-3] + 1776*X[n-2] + 5115*X[n-1] + C
* X[n] = S modulo 2^32
* C = floor(S / 2^32)
*
* Further documentation:
* The file ran-instructions.pdf contains further documentation and 
* instructions.
*
* Copyright 1999-2008 by Agner Fog. 
* GNU General Public License http://www.gnu.org/licenses/gpl.html
******************************************************************************/

// Only the methods I need have been ported to C#...

namespace de4dot.code.deobfuscators.CodeWall.randomc {
	class CRandomMother {
		uint[] x = new uint[5];             // History buffer

		public CRandomMother(int seed) => RandomInit(seed);

		// this function initializes the random number generator:
		public void RandomInit(int seed) {
			int i;
			uint s = (uint)seed;
			// make random numbers and put them into the buffer
			for (i = 0; i < 5; i++) {
				s = s * 29943829 - 1;
				x[i] = s;
			}
			// randomize some more
			for (i = 0; i < 19; i++) BRandom();
		}

		// Output random bits
		public uint BRandom() {
			ulong sum;
			sum = (ulong)2111111111UL * (ulong)x[3] +
			   (ulong)1492 * (ulong)(x[2]) +
			   (ulong)1776 * (ulong)(x[1]) +
			   (ulong)5115 * (ulong)(x[0]) +
			   (ulong)x[4];
			x[3] = x[2]; x[2] = x[1]; x[1] = x[0];
			x[4] = (uint)(sum >> 32);			// Carry
			x[0] = (uint)sum;					// Low 32 bits of sum
			return x[0];
		}

		// returns a random number between 0 and 1:
		public double Random() => (double)BRandom() * (1.0 / (65536.0 * 65536.0));
	}
}



================================================
File: de4dot.code/deobfuscators/Confuser/AntiDebugger.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Confuser {
	class AntiDebugger : IVersionProvider {
		ModuleDefMD module;
		MethodDef initMethod;
		ConfuserVersion version = ConfuserVersion.Unknown;

		enum ConfuserVersion {
			Unknown,
			v14_r57588_normal,
			v14_r57588_safe,
			v14_r60785_normal,
			v16_r61954_normal,
			v16_r61954_safe,
			v17_r73822_normal,
			v17_r73822_safe,
			v17_r74021_normal,
			v17_r74021_safe,
			v19_r76119_safe,
			v19_r78363_normal,
			v19_r78363_safe,
		}

		public MethodDef InitMethod => initMethod;
		public TypeDef Type => initMethod?.DeclaringType;
		public bool Detected => initMethod != null;
		public AntiDebugger(ModuleDefMD module) => this.module = module;

		public void Find() {
			if (CheckMethod(DotNetUtils.GetModuleTypeCctor(module)))
				return;
		}

		bool CheckMethod(MethodDef method) {
			if (method == null || method.Body == null)
				return false;

			foreach (var instr in method.Body.Instructions) {
				if (instr.OpCode.Code != Code.Call)
					continue;
				var calledMethod = instr.Operand as MethodDef;
				if (calledMethod == null || !calledMethod.IsStatic)
					continue;
				if (!DotNetUtils.IsMethod(calledMethod, "System.Void", "()"))
					continue;
				var type = calledMethod.DeclaringType;
				if (type == null)
					continue;

				if (CheckMethod_normal(type, calledMethod) || CheckMethod_safe(type, calledMethod)) {
					initMethod = calledMethod;
					return true;
				}
			}

			return false;
		}

		static bool CheckProfilerStrings1(MethodDef method) {
			if (!DotNetUtils.HasString(method, "COR_ENABLE_PROFILING"))
				return false;
			if (!DotNetUtils.HasString(method, "COR_PROFILER"))
				return false;

			return true;
		}

		static bool CheckProfilerStrings2(MethodDef method) {
			if (!DotNetUtils.HasString(method, "COR_"))
				return false;
			if (!DotNetUtils.HasString(method, "ENABLE_PROFILING"))
				return false;
			if (!DotNetUtils.HasString(method, "PROFILER"))
				return false;

			return true;
		}

		static MethodDef GetAntiDebugMethod(TypeDef type, MethodDef initMethod) {
			foreach (var method in type.Methods) {
				if (method.Body == null || method == initMethod)
					continue;
				if (!method.IsStatic || method.Name == ".cctor")
					continue;
				if (!method.IsPrivate)
					continue;
				if (!DotNetUtils.IsMethod(method, "System.Void", "()") && !DotNetUtils.IsMethod(method, "System.Void", "(System.Object)"))
					continue;

				return method;
			}
			return null;
		}

		bool CheckMethod_normal(TypeDef type, MethodDef initMethod) {
			var ntQueryInformationProcess = DotNetUtils.GetPInvokeMethod(type, "ntdll", "NtQueryInformationProcess");
			if (ntQueryInformationProcess == null)
				return false;
			if (DotNetUtils.GetPInvokeMethod(type, "ntdll", "NtSetInformationProcess") == null)
				return false;
			if (DotNetUtils.GetPInvokeMethod(type, "kernel32", "CloseHandle") == null)
				return false;
			var antiDebugMethod = GetAntiDebugMethod(type, initMethod);
			if (antiDebugMethod == null)
				return false;
			bool hasDebuggerStrings = DotNetUtils.HasString(antiDebugMethod, "Debugger detected (Managed)");

			if (DotNetUtils.CallsMethod(initMethod, "System.Void System.Threading.Thread::.ctor(System.Threading.ParameterizedThreadStart)")) {
				int failFastCalls = ConfuserUtils.CountCalls(antiDebugMethod, "System.Void System.Environment::FailFast(System.String)");
				if (failFastCalls != 6 && failFastCalls != 8)
					return false;

				if (!CheckProfilerStrings1(initMethod))
					return false;

				if (!DotNetUtils.CallsMethod(antiDebugMethod, "System.Void System.Threading.Thread::.ctor(System.Threading.ParameterizedThreadStart)")) {
					if (!hasDebuggerStrings)
						return false;
					if (ConfuserUtils.CountCalls(antiDebugMethod, ntQueryInformationProcess) != 2)
						return false;
					version = ConfuserVersion.v16_r61954_normal;
				}
				else if (failFastCalls == 8) {
					if (!hasDebuggerStrings)
						return false;
					if (ConfuserUtils.CountCalls(antiDebugMethod, ntQueryInformationProcess) != 2)
						return false;
					version = ConfuserVersion.v17_r73822_normal;
				}
				else if (failFastCalls == 6) {
					if (DotNetUtils.GetPInvokeMethod(type, "IsDebuggerPresent") == null)
						return false;
					if (ConfuserUtils.CountCalls(antiDebugMethod, ntQueryInformationProcess) != 0)
						return false;
					if (hasDebuggerStrings)
						version = ConfuserVersion.v17_r74021_normal;
					else
						version = ConfuserVersion.v19_r78363_normal;
				}
				else
					return false;
			}
			else if (!DotNetUtils.CallsMethod(initMethod, "System.Void System.Threading.ThreadStart::.ctor(System.Object,System.IntPtr)")) {
				if (!hasDebuggerStrings)
					return false;
				if (!DotNetUtils.CallsMethod(initMethod, "System.Void System.Diagnostics.Process::EnterDebugMode()"))
					return false;
				if (!CheckProfilerStrings1(antiDebugMethod))
					return false;
				version = ConfuserVersion.v14_r57588_normal;
			}
			else {
				if (!hasDebuggerStrings)
					return false;
				if (!DotNetUtils.CallsMethod(initMethod, "System.Void System.Diagnostics.Process::EnterDebugMode()"))
					return false;
				if (!CheckProfilerStrings1(antiDebugMethod))
					return false;
				version = ConfuserVersion.v14_r60785_normal;
			}

			return true;
		}

		bool CheckMethod_safe(TypeDef type, MethodDef initMethod) {
			if (type == DotNetUtils.GetModuleType(module)) {
				if (!DotNetUtils.HasString(initMethod, "Debugger detected (Managed)"))
					return false;
				if (!CheckProfilerStrings1(initMethod))
					return false;

				version = ConfuserVersion.v14_r57588_safe;
			}
			else {
				var ntQueryInformationProcess = DotNetUtils.GetPInvokeMethod(type, "ntdll", "NtQueryInformationProcess");
				if (ntQueryInformationProcess == null)
					return false;
				if (DotNetUtils.GetPInvokeMethod(type, "ntdll", "NtSetInformationProcess") == null)
					return false;
				if (DotNetUtils.GetPInvokeMethod(type, "kernel32", "CloseHandle") == null)
					return false;
				var antiDebugMethod = GetAntiDebugMethod(type, initMethod);
				if (antiDebugMethod == null)
					return false;
				bool hasDebuggerStrings = DotNetUtils.HasString(antiDebugMethod, "Debugger detected (Managed)") ||
						DotNetUtils.HasString(antiDebugMethod, "Debugger is detected (Managed)");
				if (!DotNetUtils.CallsMethod(initMethod, "System.Void System.Threading.Thread::.ctor(System.Threading.ParameterizedThreadStart)"))
					return false;
				if (ConfuserUtils.CountCalls(antiDebugMethod, ntQueryInformationProcess) != 0)
					return false;
				if (!CheckProfilerStrings1(initMethod) && !CheckProfilerStrings2(initMethod))
					return false;

				int failFastCalls = ConfuserUtils.CountCalls(antiDebugMethod, "System.Void System.Environment::FailFast(System.String)");
				if (failFastCalls != 2)
					return false;

				if (hasDebuggerStrings) {
					if (!DotNetUtils.CallsMethod(antiDebugMethod, "System.Void System.Threading.Thread::.ctor(System.Threading.ParameterizedThreadStart)"))
						version = ConfuserVersion.v16_r61954_safe;
					else if (DotNetUtils.GetPInvokeMethod(type, "IsDebuggerPresent") == null)
						version = ConfuserVersion.v17_r73822_safe;
					else if (CheckProfilerStrings1(initMethod))
						version = ConfuserVersion.v17_r74021_safe;
					else
						version = ConfuserVersion.v19_r76119_safe;
				}
				else {
					version = ConfuserVersion.v19_r78363_safe;
				}
			}

			return true;
		}

		public bool GetRevisionRange(out int minRev, out int maxRev) {
			switch (version) {
			case ConfuserVersion.Unknown:
				minRev = maxRev = 0;
				return false;

			case ConfuserVersion.v14_r57588_safe:
				minRev = 57588;
				maxRev = 60787;
				return true;

			case ConfuserVersion.v16_r61954_safe:
				minRev = 61954;
				maxRev = 73791;
				return true;

			case ConfuserVersion.v17_r73822_safe:
				minRev = 73822;
				maxRev = 73822;
				return true;

			case ConfuserVersion.v17_r74021_safe:
				minRev = 74021;
				maxRev = 76101;
				return true;

			case ConfuserVersion.v19_r76119_safe:
				minRev = 76119;
				maxRev = 78342;
				return true;

			case ConfuserVersion.v19_r78363_safe:
				minRev = 78363;
				maxRev = int.MaxValue;
				return true;

			case ConfuserVersion.v14_r57588_normal:
				minRev = 57588;
				maxRev = 60408;
				return true;

			case ConfuserVersion.v14_r60785_normal:
				minRev = 60785;
				maxRev = 60787;
				return true;

			case ConfuserVersion.v16_r61954_normal:
				minRev = 61954;
				maxRev = 73791;
				return true;

			case ConfuserVersion.v17_r73822_normal:
				minRev = 73822;
				maxRev = 73822;
				return true;

			case ConfuserVersion.v17_r74021_normal:
				minRev = 74021;
				maxRev = 78342;
				return true;

			case ConfuserVersion.v19_r78363_normal:
				minRev = 78363;
				maxRev = int.MaxValue;
				return true;

			default: throw new ApplicationException("Invalid version");
			}
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Confuser/AntiDumping.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Confuser {
	class AntiDumping : IVersionProvider {
		ModuleDefMD module;
		MethodDef initMethod;
		ConfuserVersion version = ConfuserVersion.Unknown;

		enum ConfuserVersion {
			Unknown,
			v14_r58564,
			v14_r58852,
			v16_r69339,
			v17_r74708,
			v18_r75257,
			v19_r75725,
			v19_r76186,
		}

		public MethodDef InitMethod => initMethod;
		public TypeDef Type => initMethod?.DeclaringType;
		public bool Detected => initMethod != null;
		public AntiDumping(ModuleDefMD module) => this.module = module;

		public void Find(ISimpleDeobfuscator simpleDeobfuscator) {
			if (CheckMethod(simpleDeobfuscator, DotNetUtils.GetModuleTypeCctor(module)))
				return;
		}

		bool CheckMethod(ISimpleDeobfuscator simpleDeobfuscator, MethodDef method) {
			if (method == null || method.Body == null)
				return false;

			foreach (var instr in method.Body.Instructions) {
				if (instr.OpCode.Code != Code.Call)
					continue;
				var calledMethod = instr.Operand as MethodDef;
				if (calledMethod == null)
					continue;
				if (calledMethod == null || !calledMethod.IsStatic)
					continue;
				if (!DotNetUtils.IsMethod(calledMethod, "System.Void", "()"))
					continue;
				var type = calledMethod.DeclaringType;
				if (type.NestedTypes.Count > 0)
					continue;

				simpleDeobfuscator.Deobfuscate(calledMethod, SimpleDeobfuscatorFlags.Force | SimpleDeobfuscatorFlags.DisableConstantsFolderExtraInstrs);
				if (CheckType(type, calledMethod)) {
					initMethod = calledMethod;
					return true;
				}
			}
			return false;
		}

		bool CheckType(TypeDef type, MethodDef initMethod) =>
			CheckType_v14_r58564(type, initMethod) ||
			CheckType_v14_r58852(type, initMethod);

		bool CheckType_v14_r58564(TypeDef type, MethodDef initMethod) {
			var virtualProtect = DotNetUtils.GetPInvokeMethod(type, "VirtualProtect");
			if (virtualProtect == null)
				return false;
			if (!DotNetUtils.CallsMethod(initMethod, "System.IntPtr System.Runtime.InteropServices.Marshal::GetHINSTANCE(System.Reflection.Module)"))
				return false;
			if (ConfuserUtils.CountCalls(initMethod, virtualProtect) != 3)
				return false;
			if (!DeobUtils.HasInteger(initMethod, 224))
				return false;
			if (!DeobUtils.HasInteger(initMethod, 240))
				return false;
			if (!DeobUtils.HasInteger(initMethod, 267))
				return false;

			version = ConfuserVersion.v14_r58564;
			return true;
		}

		bool CheckType_v14_r58852(TypeDef type, MethodDef initMethod) {
			var virtualProtect = DotNetUtils.GetPInvokeMethod(type, "VirtualProtect");
			if (virtualProtect == null)
				return false;
			if (!DotNetUtils.CallsMethod(initMethod, "System.IntPtr System.Runtime.InteropServices.Marshal::GetHINSTANCE(System.Reflection.Module)"))
				return false;
			int virtualProtectCalls = ConfuserUtils.CountCalls(initMethod, virtualProtect);
			if (virtualProtectCalls != 14 && virtualProtectCalls != 16)
				return false;
			if (!DeobUtils.HasInteger(initMethod, 0x3C))
				return false;
			if (!DeobUtils.HasInteger(initMethod, 0x6c64746e))
				return false;
			if (!DeobUtils.HasInteger(initMethod, 0x6c642e6c))
				return false;
			if (!DeobUtils.HasInteger(initMethod, 0x6f43744e))
				return false;
			if (!DeobUtils.HasInteger(initMethod, 0x6e69746e))
				return false;
			int locallocs = ConfuserUtils.CountOpCode(initMethod, Code.Localloc);

			if (DeobUtils.HasInteger(initMethod, 0x18))
				version = ConfuserVersion.v14_r58852;
			else if (virtualProtectCalls == 16)
				version = ConfuserVersion.v16_r69339;
			else if (virtualProtectCalls == 14) {
				if (locallocs == 2)
					version = ConfuserVersion.v17_r74708;
				else if (locallocs == 1) {
					if (DotNetUtils.HasString(initMethod, "<Unknown>"))
						version = ConfuserVersion.v18_r75257;
					else if (IsRev75725(initMethod))
						version = ConfuserVersion.v19_r75725;
					else
						version = ConfuserVersion.v19_r76186;
				}
				else
					return false;
			}
			else
				return false;

			return true;
		}

		static bool IsRev75725(MethodDef method) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 9; i++) {
				if (!instrs[i].IsLdcI4() || instrs[i].GetLdcI4Value() != 8)
					continue;
				if (!instrs[i + 1].IsLdcI4() || instrs[i + 1].GetLdcI4Value() != 64)
					continue;
				if (instrs[i + 2].OpCode.Code != Code.Ldloca && instrs[i + 2].OpCode.Code != Code.Ldloca_S)
					continue;
				var call = instrs[i + 3];
				if (call.OpCode.Code != Code.Call)
					continue;
				var calledMethod = call.Operand as MethodDef;
				if (calledMethod == null || calledMethod.ImplMap == null || calledMethod.ImplMap.Name != "VirtualProtect")
					continue;
				if (instrs[i + 4].OpCode.Code != Code.Pop)
					continue;

				var ldloc = instrs[i + 5];
				if (!ldloc.IsLdloc())
					continue;
				var local = ldloc.GetLocal(method.Body.Variables);
				if (local == null)
					continue;

				if (!instrs[i + 6].IsLdcI4() || instrs[i + 6].GetLdcI4Value() != 0)
					continue;
				if (instrs[i + 7].OpCode.Code != Code.Stind_I4)
					continue;

				ldloc = instrs[i + 8];
				if (!ldloc.IsLdloc() || local != ldloc.GetLocal(method.Body.Variables))
					continue;
				if (!instrs[i + 9].IsLdcI4() || instrs[i + 9].GetLdcI4Value() != 4)
					continue;

				return true;
			}
			return false;
		}

		public bool GetRevisionRange(out int minRev, out int maxRev) {
			switch (version) {
			case ConfuserVersion.Unknown:
				minRev = maxRev = 0;
				return false;

			case ConfuserVersion.v14_r58564:
				minRev = 58564;
				maxRev = 58817;
				return true;

			case ConfuserVersion.v14_r58852:
				minRev = 58852;
				maxRev = 67058;
				return true;

			case ConfuserVersion.v16_r69339:
				minRev = 69339;
				maxRev = 74637;
				return true;

			case ConfuserVersion.v17_r74708:
				minRev = 74708;
				maxRev = 75184;
				return true;

			case ConfuserVersion.v18_r75257:
				minRev = 75257;
				maxRev = 75720;
				return true;

			case ConfuserVersion.v19_r75725:
				minRev = 75725;
				maxRev = 76163;
				return true;

			case ConfuserVersion.v19_r76186:
				minRev = 76186;
				maxRev = int.MaxValue;
				return true;

			default: throw new ApplicationException("Invalid version");
			}
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Confuser/Arg64ConstantsReader.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet.Emit;

namespace de4dot.code.deobfuscators.Confuser {
	class Arg64ConstantsReader : ConstantsReader {
		long arg;
		bool firstTime;

		public long Arg {
			get => arg;
			set {
				arg = value;
				firstTime = true;
			}
		}

		public Arg64ConstantsReader(IList<Instruction> instrs, bool emulateConvInstrs)
			: base(instrs, emulateConvInstrs) {
		}

		protected override bool ProcessInstructionInt64(ref int index, Stack<ConstantInfo<long>> stack) {
			if (!firstTime)
				return false;
			firstTime = false;
			if (instructions[index].OpCode.Code != Code.Conv_I8)
				return false;

			stack.Push(new ConstantInfo<long>(index, arg));
			index = index + 1;
			return true;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Confuser/ConfuserUtils.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.IO;
using SevenZip.Compression.LZMA;
using dnlib.IO;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Confuser {
	static class ConfuserUtils {
		public static int FindCallMethod(IList<Instruction> instrs, int index, Code callCode, string methodFullName) {
			for (int i = index; i < instrs.Count; i++) {
				if (!IsCallMethod(instrs[i], callCode, methodFullName))
					continue;

				return i;
			}
			return -1;
		}

		public static int FindCallMethod(IList<Instr> instrs, int index, Code callCode, string methodFullName) {
			for (int i = index; i < instrs.Count; i++) {
				if (!IsCallMethod(instrs[i].Instruction, callCode, methodFullName))
					continue;

				return i;
			}
			return -1;
		}

		public static bool IsCallMethod(Instruction instr, Code callCode, string methodFullName) {
			if (instr.OpCode.Code != callCode)
				return false;
			return instr.Operand is IMethod calledMethod && calledMethod.FullName == methodFullName;
		}

		public static bool RemoveResourceHookCode(Blocks blocks, MethodDef handler) =>
			RemoveResolveHandlerCode(blocks, handler, "System.Void System.AppDomain::add_ResourceResolve(System.ResolveEventHandler)");

		public static bool RemoveAssemblyHookCode(Blocks blocks, MethodDef handler) =>
			RemoveResolveHandlerCode(blocks, handler, "System.Void System.AppDomain::add_AssemblyResolve(System.ResolveEventHandler)");

		static bool RemoveResolveHandlerCode(Blocks blocks, MethodDef handler, string installHandlerMethod) {
			bool modified = false;
			foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {
				var instrs = block.Instructions;
				for (int i = 0; i < instrs.Count - 4; i++) {
					var call = instrs[i];
					if (call.OpCode.Code != Code.Call)
						continue;
					var calledMethod = call.Operand as IMethod;
					if (calledMethod == null || calledMethod.FullName != "System.AppDomain System.AppDomain::get_CurrentDomain()")
						continue;

					if (instrs[i + 1].OpCode.Code != Code.Ldnull)
						continue;

					var ldftn = instrs[i + 2];
					if (ldftn.OpCode.Code != Code.Ldftn)
						continue;
					if (ldftn.Operand != handler)
						continue;

					var newobj = instrs[i + 3];
					if (newobj.OpCode.Code != Code.Newobj)
						continue;
					var ctor = newobj.Operand as IMethod;
					if (ctor == null || ctor.FullName != "System.Void System.ResolveEventHandler::.ctor(System.Object,System.IntPtr)")
						continue;

					var callvirt = instrs[i + 4];
					if (callvirt.OpCode.Code != Code.Callvirt)
						continue;
					calledMethod = callvirt.Operand as IMethod;
					if (calledMethod == null || calledMethod.FullName != installHandlerMethod)
						continue;

					block.Remove(i, 5);
					modified = true;
				}
			}
			return modified;
		}

		public static byte[] DecryptCompressedInt32Data(Arg64ConstantsReader constReader, int exprStart, int exprEnd, ref DataReader reader, byte[] decrypted) {
			for (int i = 0; i < decrypted.Length; i++) {
				constReader.Arg = reader.Read7BitEncodedInt32();
				int index = exprStart;
				if (!constReader.GetInt64(ref index, out long result) || index != exprEnd)
					throw new ApplicationException("Could not decrypt integer");
				decrypted[i] = (byte)result;
			}
			return decrypted;
		}

		static readonly byte[] defaultDecryptKey = new byte[1];
		public static byte[] Decrypt(uint seed, byte[] encrypted) => Decrypt(seed, encrypted, defaultDecryptKey);

		public static byte[] Decrypt(uint seed, byte[] encrypted, byte[] key) {
			var decrypted = new byte[encrypted.Length];
			ushort _m = (ushort)(seed >> 16);
			ushort _c = (ushort)seed;
			ushort m = _c; ushort c = _m;
			for (int i = 0; i < decrypted.Length; i++) {
				decrypted[i] = (byte)(encrypted[i] ^ (seed * m + c) ^ key[i % key.Length]);
				m = (ushort)(seed * m + _m);
				c = (ushort)(seed * c + _c);
			}
			return decrypted;
		}

		public static int CountCalls(MethodDef method, string methodFullName) {
			if (method == null || method.Body == null)
				return 0;
			int count = 0;
			foreach (var instr in method.Body.Instructions) {
				if (instr.OpCode.Code != Code.Call && instr.OpCode.Code != Code.Callvirt && instr.OpCode.Code != Code.Newobj)
					continue;
				if (instr.Operand is IMethod calledMethod && calledMethod.FullName == methodFullName)
					count++;
			}
			return count;
		}

		public static int CountCalls(MethodDef method, MethodDef calledMethod) {
			if (method == null || method.Body == null)
				return 0;
			int count = 0;
			foreach (var instr in method.Body.Instructions) {
				if (instr.OpCode.Code != Code.Call && instr.OpCode.Code != Code.Callvirt && instr.OpCode.Code != Code.Newobj)
					continue;
				if (instr.Operand == calledMethod)
					count++;
			}
			return count;
		}

		public static int CountOpCode(MethodDef method, Code code) {
			if (method == null || method.Body == null)
				return 0;

			int count = 0;
			foreach (var instr in method.Body.Instructions) {
				if (instr.OpCode.Code == code)
					count++;
			}
			return count;
		}

		public static byte[] SevenZipDecompress(byte[] data) {
			var reader = new BinaryReader(new MemoryStream(data));
			var props = reader.ReadBytes(5);
			var decoder = new Decoder();
			decoder.SetDecoderProperties(props);
			long totalSize = reader.ReadInt64();
			long compressedSize = data.Length - props.Length - 8;
			var decompressed = new byte[totalSize];
			decoder.Code(reader.BaseStream, new MemoryStream(decompressed, true), compressedSize, totalSize, null);
			return decompressed;
		}

		// Finds the Lzma type by finding an instruction that allocates a new Lzma.Decoder
		public static TypeDef FindLzmaType(MethodDef method) {
			if (method == null || method.Body == null)
				return null;

			foreach (var instr in method.Body.Instructions) {
				if (instr.OpCode.Code != Code.Newobj)
					continue;
				var ctor = instr.Operand as MethodDef;
				if (ctor == null)
					continue;
				var ctorType = ctor.DeclaringType;
				if (ctorType == null)
					continue;
				if (!IsLzmaType(ctorType.DeclaringType))
					continue;

				return ctorType.DeclaringType;
			}

			return null;
		}

		static bool IsLzmaType(TypeDef type) {
			if (type == null)
				return false;

			if (type.NestedTypes.Count != 6)
				return false;
			if (!CheckLzmaMethods(type))
				return false;
			if (FindLzmaOutWindowType(type.NestedTypes) == null)
				return false;

			return true;
		}

		static bool CheckLzmaMethods(TypeDef type) {
			int methods = 0;
			foreach (var m in type.Methods) {
				if (m.IsStaticConstructor)
					continue;
				if (m.IsInstanceConstructor) {
					if (m.MethodSig.GetParamCount() != 0)
						return false;
					continue;
				}
				if (!DotNetUtils.IsMethod(m, "System.UInt32", "(System.UInt32)"))
					return false;
				methods++;
			}
			return methods == 1;
		}

		static readonly string[] outWindowFields = new string[] {
			"System.Byte[]",
			"System.UInt32",
			"System.IO.Stream",
		};
		static TypeDef FindLzmaOutWindowType(IEnumerable<TypeDef> types) {
			foreach (var type in types) {
				if (new FieldTypes(type).Exactly(outWindowFields))
					return type;
			}
			return null;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Confuser/ConstantsDecrypterBase.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Text;
using dnlib.IO;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Confuser {
	abstract class ConstantsDecrypterBase : IVersionProvider {
		protected ModuleDefMD module;
		protected byte[] fileData;
		protected ISimpleDeobfuscator simpleDeobfuscator;
		protected MethodDef nativeMethod;
		MethodDefAndDeclaringTypeDict<DecrypterInfo> methodToDecrypterInfo = new MethodDefAndDeclaringTypeDict<DecrypterInfo>();
		FieldDefAndDeclaringTypeDict<bool> fields = new FieldDefAndDeclaringTypeDict<bool>();
		protected EmbeddedResource resource;
		protected DataReader reader;

		public class DecrypterInfo {
			public MethodDef decryptMethod;
			public uint key0, key1, key2, key3;
			public byte doubleType, singleType, int32Type, int64Type, stringType;

			public void Initialize() {
				if (!InitializeKeys())
					throw new ApplicationException("Could not find all keys");
				if (!InitializeTypeCodes())
					throw new ApplicationException("Could not find all type codes");
			}

			protected virtual bool InitializeKeys() {
				if (!FindKey0(decryptMethod, out key0))
					return false;
				if (!FindKey1(decryptMethod, out key1))
					return false;
				if (!FindKey2Key3(decryptMethod, out key2, out key3))
					return false;

				return true;
			}

			protected static bool FindKey0(MethodDef method, out uint key) {
				var instrs = method.Body.Instructions;
				for (int i = 0; i < instrs.Count - 5; i++) {
					if (!instrs[i].IsLdloc())
						continue;
					if (instrs[i + 1].OpCode.Code != Code.Or)
						continue;
					var ldci4 = instrs[i + 2];
					if (!ldci4.IsLdcI4())
						continue;
					if (instrs[i + 3].OpCode.Code != Code.Xor)
						continue;
					if (instrs[i + 4].OpCode.Code != Code.Add)
						continue;
					if (!instrs[i + 5].IsStloc())
						continue;

					key = (uint)ldci4.GetLdcI4Value();
					return true;
				}
				key = 0;
				return false;
			}

			static bool FindKey1(MethodDef method, out uint key) {
				var instrs = method.Body.Instructions;
				for (int i = 0; i < instrs.Count; i++) {
					int index = ConfuserUtils.FindCallMethod(instrs, i, Code.Callvirt, "System.Int32 System.Reflection.MemberInfo::get_MetadataToken()");
					if (index < 0)
						break;
					if (index + 2 > instrs.Count)
						break;
					if (!instrs[index + 1].IsStloc())
						continue;
					var ldci4 = instrs[index + 2];
					if (!ldci4.IsLdcI4())
						continue;

					key = (uint)ldci4.GetLdcI4Value();
					return true;
				}
				key = 0;
				return false;
			}

			protected static bool FindKey2Key3(MethodDef method, out uint key2, out uint key3) {
				var instrs = method.Body.Instructions;
				for (int i = 0; i < instrs.Count - 3; i++) {
					var ldci4_1 = instrs[i];
					if (!ldci4_1.IsLdcI4())
						continue;
					if (!instrs[i + 1].IsStloc())
						continue;
					var ldci4_2 = instrs[i + 2];
					if (!ldci4_2.IsLdcI4())
						continue;
					if (!instrs[i + 3].IsStloc())
						continue;

					key2 = (uint)ldci4_1.GetLdcI4Value();
					key3 = (uint)ldci4_2.GetLdcI4Value();
					return true;
				}
				key2 = 0;
				key3 = 0;
				return false;
			}

			bool InitializeTypeCodes() {
				var allBlocks = new Blocks(decryptMethod).MethodBlocks.GetAllBlocks();
				if (!FindTypeCode(allBlocks, out doubleType, Code.Call, "System.Double System.BitConverter::ToDouble(System.Byte[],System.Int32)"))
					return false;
				if (!FindTypeCode(allBlocks, out singleType, Code.Call, "System.Single System.BitConverter::ToSingle(System.Byte[],System.Int32)"))
					return false;
				if (!FindTypeCode(allBlocks, out int32Type, Code.Call, "System.Int32 System.BitConverter::ToInt32(System.Byte[],System.Int32)"))
					return false;
				if (!FindTypeCode(allBlocks, out int64Type, Code.Call, "System.Int64 System.BitConverter::ToInt64(System.Byte[],System.Int32)"))
					return false;
				if (!FindTypeCode(allBlocks, out stringType, Code.Callvirt, "System.String System.Text.Encoding::GetString(System.Byte[])") &&
					!FindTypeCode(allBlocks, out stringType, Code.Callvirt, "System.String System.Text.Encoding::GetString(System.Byte[],System.Int32,System.Int32)"))
					return false;
				return true;
			}

			static bool FindTypeCode(IList<Block> allBlocks, out byte typeCode, Code callCode, string bitConverterMethod) {
				foreach (var block in allBlocks) {
					if (block.Sources.Count != 1)
						continue;
					int index = ConfuserUtils.FindCallMethod(block.Instructions, 0, callCode, bitConverterMethod);
					if (index < 0)
						continue;

					if (!FindTypeCode(block.Sources[0], out typeCode))
						continue;

					return true;
				}
				typeCode = 0;
				return false;
			}

			static Block FixBlock(Block block) {
				if (block.Sources.Count != 1)
					return block;
				if (block.GetOnlyTarget() == null)
					return block;
				if (block.Instructions.Count == 0) {
				}
				else if (block.Instructions.Count == 1 && block.Instructions[0].OpCode.Code == Code.Nop) {
				}
				else
					return block;
				return block.Sources[0];
			}

			static bool FindTypeCode(Block block, out byte typeCode) {
				block = FixBlock(block);

				var instrs = block.Instructions;
				int numCeq = 0;
				for (int i = instrs.Count - 1; i >= 0; i--) {
					var instr = instrs[i];
					if (instr.OpCode.Code == Code.Ceq) {
						numCeq++;
						continue;
					}
					if (!instr.Instruction.IsLdcI4())
						continue;
					if (numCeq != 0 && numCeq != 2)
						continue;

					typeCode = (byte)instr.Instruction.GetLdcI4Value();
					return true;
				}
				typeCode = 0;
				return false;
			}

			public uint CalcHash(uint x) {
				uint h0 = key1 ^ x;
				uint h1 = key2;
				uint h2 = key3;
				for (uint i = 1; i <= 64; i++) {
					h0 = (h0 << 8) | (h0 >> 24);
					uint n = h0 & 0x3F;
					if (n >= 0 && n < 16) {
						h1 |= ((byte)(h0 >> 8) & (h0 >> 16)) ^ (byte)~h0;
						h2 ^= (h0 * i + 1) & 0xF;
						h0 += (h1 | h2) ^ key0;
					}
					else if (n >= 16 && n < 32) {
						h1 ^= ((h0 & 0x00FF00FF) << 8) ^ (ushort)((h0 >> 8) | ~h0);
						h2 += (h0 * i) & 0x1F;
						h0 |= (h1 + ~h2) & key0;
					}
					else if (n >= 32 && n < 48) {
						h1 += (byte)(h0 | (h0 >> 16)) + (~h0 & 0xFF);
						h2 -= ~(h0 + n) % 48;
						h0 ^= (h1 % h2) | key0;
					}
					else if (n >= 48 && n < 64) {
						h1 ^= ((byte)(h0 >> 16) | ~(h0 & 0xFF)) * (~h0 & 0x00FF0000);
						h2 += (h0 ^ (i - 1)) % n;
						h0 -= ~(h1 ^ h2) + key0;
					}
				}
				return h0;
			}
		}

		public abstract bool Detected { get; }

		public MethodDef NativeMethod => nativeMethod;
		public EmbeddedResource Resource => resource;
		public IEnumerable<FieldDef> Fields => fields.GetKeys();
		protected bool HasDecrypterInfos => methodToDecrypterInfo.Count > 0;
		public IEnumerable<DecrypterInfo> DecrypterInfos => methodToDecrypterInfo.GetValues();

		public ConstantsDecrypterBase(ModuleDefMD module, byte[] fileData, ISimpleDeobfuscator simpleDeobfuscator) {
			this.module = module;
			this.fileData = fileData;
			this.simpleDeobfuscator = simpleDeobfuscator;
		}

		public abstract bool GetRevisionRange(out int minRev, out int maxRev);
		public abstract void Initialize();

		protected void Add(DecrypterInfo info) => methodToDecrypterInfo.Add(info.decryptMethod, info);

		protected bool Add(FieldDef field) {
			if (field == null)
				return false;
			fields.Add(field, true);
			return true;
		}

		protected void InitializeDecrypterInfos() {
			foreach (var info in methodToDecrypterInfo.GetValues()) {
				simpleDeobfuscator.Deobfuscate(info.decryptMethod);
				info.Initialize();
			}
		}

		protected void SetConstantsData(byte[] constants) => reader = ByteArrayDataReaderFactory.CreateReader(constants);
		protected EmbeddedResource FindResource(MethodDef method) => DotNetUtils.GetResource(module, DotNetUtils.GetCodeStrings(method)) as EmbeddedResource;

		protected static MethodDef FindNativeMethod(MethodDef method) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count; i++) {
				var call = instrs[i];
				if (call.OpCode.Code != Code.Call)
					continue;
				var calledMethod = call.Operand as MethodDef;
				if (calledMethod == null || !calledMethod.IsStatic || !calledMethod.IsNative)
					continue;
				if (!DotNetUtils.IsMethod(calledMethod, "System.Int32", "(System.Int32)"))
					continue;

				return calledMethod;
			}
			return null;
		}

		static Local GetDynamicLocal_v17_r73740(MethodDef method) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count; i++) {
				i = ConfuserUtils.FindCallMethod(instrs, i, Code.Callvirt, "System.Byte System.IO.BinaryReader::ReadByte()");
				if (i < 0 || i + 5 >= instrs.Count)
					break;
				if (!instrs[i + 1].IsStloc())
					continue;
				var ldloc = instrs[i + 2];
				if (!ldloc.IsLdloc())
					continue;
				if (!instrs[i + 3].IsLdloc())
					continue;
				var ldci4 = instrs[i + 4];
				if (!ldci4.IsLdcI4() || ldci4.GetLdcI4Value() != 0x7F)
					continue;
				if (instrs[i + 5].OpCode.Code != Code.And)
					continue;

				return ldloc.GetLocal(method.Body.Variables);
			}
			return null;
		}

		static int GetDynamicEndIndex_v17_r73740(MethodDef method, Local local) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 5; i++) {
				int index = i;
				var stloc = instrs[index++];
				if (!stloc.IsStloc() || stloc.GetLocal(method.Body.Variables) != local)
					continue;
				if (!instrs[index++].IsLdloc())
					continue;
				if (instrs[index].OpCode.Code == Code.Call) {
					if (i + 7 >= instrs.Count)
						continue;
					index++;
					if (!instrs[index++].IsLdloc())
						continue;
				}
				if (!instrs[index++].IsLdloc())
					continue;
				var ldloc = instrs[index++];
				if (!ldloc.IsLdloc() || ldloc.GetLocal(method.Body.Variables) != local)
					continue;
				if (instrs[index++].OpCode.Code != Code.Conv_U1)
					continue;
				if (instrs[index++].OpCode.Code != Code.Stelem_I1)
					continue;

				return i;
			}
			return -1;
		}

		static int GetDynamicEndIndex_v17_r74788(MethodDef method, Local local) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 11; i++) {
				var stloc = instrs[i];
				if (!stloc.IsStloc() || stloc.GetLocal(method.Body.Variables) != local)
					continue;
				if (!instrs[i + 1].IsLdloc())
					continue;
				if (!instrs[i + 2].IsLdloc())
					continue;
				if (!instrs[i + 3].IsLdloc())
					continue;
				if (!instrs[i + 4].IsLdloc())
					continue;
				if (!instrs[i + 5].IsLdloc())
					continue;
				var ldci4 = instrs[i + 6];
				if (!ldci4.IsLdcI4() || (ldci4.GetLdcI4Value() != 8 && ldci4.GetLdcI4Value() != 16))
					continue;
				if (instrs[i + 7].OpCode.Code != Code.Rem)
					continue;
				if (instrs[i + 8].OpCode.Code != Code.Ldelem_U1)
					continue;
				if (instrs[i + 9].OpCode.Code != Code.Xor)
					continue;
				if (instrs[i + 10].OpCode.Code != Code.Conv_U1)
					continue;
				if (instrs[i + 11].OpCode.Code != Code.Stelem_I1)
					continue;

				return i;
			}
			return -1;
		}

		static int GetDynamicStartIndex_v17_r73740(MethodDef method, int endIndex) {
			if (endIndex < 0)
				return -1;
			var instrs = method.Body.Instructions;
			for (int i = endIndex; i >= 0; i--) {
				if (i == 0)
					return i == endIndex ? -1 : i + 1;
				if (instrs[i].OpCode.FlowControl == FlowControl.Next)
					continue;

				return i + 1;
			}
			return -1;
		}

		static readonly byte[] defaultDecryptKey_v17 = new byte[1];
		protected byte[] DecryptConstant_v17_r73740_dynamic(DecrypterInfo info, byte[] encrypted, uint offs, uint key) =>
			DecryptConstant_v17_r73740_dynamic(info, encrypted, offs, key, defaultDecryptKey_v17);

		protected byte[] DecryptConstant_v17_r73740_dynamic(DecrypterInfo info, byte[] encrypted, uint offs, uint key1, byte[] key2) {
			var local = GetDynamicLocal_v17_r73740(info.decryptMethod);
			if (local == null)
				throw new ApplicationException("Could not find local");

			int endIndex = GetDynamicEndIndex_v17_r73740(info.decryptMethod, local);
			if (endIndex < 0)
				endIndex = GetDynamicEndIndex_v17_r74788(info.decryptMethod, local);
			int startIndex = GetDynamicStartIndex_v17_r73740(info.decryptMethod, endIndex);
			if (startIndex < 0)
				throw new ApplicationException("Could not find start/end index");

			var constReader = new ConstantsReader(info.decryptMethod);
			return Decrypt(encrypted, key1, (magic, i) => {
				constReader.SetConstantInt32(local, magic);
				int index = startIndex;
				if (!constReader.GetNextInt32(ref index, out int result) || index != endIndex)
					throw new ApplicationException("Could not decrypt integer");
				return (byte)(result ^ key2[i % key2.Length]);
			});
		}

		protected byte[] DecryptConstant_v17_r73764_native(DecrypterInfo info, byte[] encrypted, uint offs, uint key) =>
			DecryptConstant_v17_r73764_native(info, encrypted, offs, key, defaultDecryptKey_v17);

		protected byte[] DecryptConstant_v17_r73764_native(DecrypterInfo info, byte[] encrypted, uint offs, uint key1, byte[] key2) {
			using (var x86Emu = new X86Emulator(fileData))
				return Decrypt(encrypted, key1, (magic, i) => (byte)(x86Emu.Emulate((uint)nativeMethod.RVA, magic) ^ key2[i % key2.Length]));
		}

		static byte[] Decrypt(byte[] encrypted, uint key, Func<uint, int, byte> decryptFunc) {
			var reader = ByteArrayDataReaderFactory.CreateReader(encrypted);
			var decrypted = new byte[reader.ReadInt32() ^ key];
			for (int i = 0; i < decrypted.Length; i++) {
				uint magic = reader.Read7BitEncodedUInt32();
				decrypted[i] = decryptFunc(magic, i);
			}

			return decrypted;
		}

		public object DecryptInt32(MethodDef caller, MethodDef decryptMethod, object[] args) {
			var info = methodToDecrypterInfo.Find(decryptMethod);
			var data = DecryptData(info, caller, args, out byte typeCode);
			if (typeCode != info.int32Type)
				return null;
			if (data.Length != 4)
				throw new ApplicationException("Invalid data length");
			return BitConverter.ToInt32(data, 0);
		}

		public object DecryptInt64(MethodDef caller, MethodDef decryptMethod, object[] args) {
			var info = methodToDecrypterInfo.Find(decryptMethod);
			var data = DecryptData(info, caller, args, out byte typeCode);
			if (typeCode != info.int64Type)
				return null;
			if (data.Length != 8)
				throw new ApplicationException("Invalid data length");
			return BitConverter.ToInt64(data, 0);
		}

		public object DecryptSingle(MethodDef caller, MethodDef decryptMethod, object[] args) {
			var info = methodToDecrypterInfo.Find(decryptMethod);
			var data = DecryptData(info, caller, args, out byte typeCode);
			if (typeCode != info.singleType)
				return null;
			if (data.Length != 4)
				throw new ApplicationException("Invalid data length");
			return BitConverter.ToSingle(data, 0);
		}

		public object DecryptDouble(MethodDef caller, MethodDef decryptMethod, object[] args) {
			var info = methodToDecrypterInfo.Find(decryptMethod);
			var data = DecryptData(info, caller, args, out byte typeCode);
			if (typeCode != info.doubleType)
				return null;
			if (data.Length != 8)
				throw new ApplicationException("Invalid data length");
			return BitConverter.ToDouble(data, 0);
		}

		public string DecryptString(MethodDef caller, MethodDef decryptMethod, object[] args) {
			var info = methodToDecrypterInfo.Find(decryptMethod);
			var data = DecryptData(info, caller, args, out byte typeCode);
			if (typeCode != info.stringType)
				return null;
			return Encoding.UTF8.GetString(data);
		}

		protected abstract byte[] DecryptData(DecrypterInfo info, MethodDef caller, object[] args, out byte typeCode);
	}
}



================================================
File: de4dot.code/deobfuscators/Confuser/ConstantsDecrypterUtils.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace de4dot.code.deobfuscators.Confuser {
	static class ConstantsDecrypterUtils {
		public static FieldDef FindDictField(MethodDef method, TypeDef declaringType) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 1; i++) {
				var newobj = instrs[i];
				if (newobj.OpCode.Code != Code.Newobj)
					continue;
				var ctor = newobj.Operand as IMethod;
				if (ctor == null || ctor.FullName != "System.Void System.Collections.Generic.Dictionary`2<System.UInt32,System.Object>::.ctor()")
					continue;

				var stsfld = instrs[i + 1];
				if (stsfld.OpCode.Code != Code.Stsfld)
					continue;
				var field = stsfld.Operand as FieldDef;
				if (field == null || field.DeclaringType != declaringType)
					continue;
				if (field.FieldType.FullName != "System.Collections.Generic.Dictionary`2<System.UInt32,System.Object>")
					continue;

				return field;
			}
			return null;
		}

		public static FieldDef FindDataField_v18_r75367(MethodDef method, TypeDef declaringType) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 1; i++) {
				var callvirt = instrs[i];
				if (callvirt.OpCode.Code != Code.Callvirt)
					continue;
				var calledMethod = callvirt.Operand as IMethod;
				if (calledMethod == null || calledMethod.FullName != "System.Byte[] System.IO.MemoryStream::ToArray()")
					continue;

				var stsfld = instrs[i + 1];
				if (stsfld.OpCode.Code != Code.Stsfld)
					continue;
				var field = stsfld.Operand as FieldDef;
				if (field == null || field.DeclaringType != declaringType)
					continue;
				if (field.FieldType.FullName != "System.Byte[]")
					continue;

				return field;
			}
			return null;
		}

		// Normal ("safe") mode only (not dynamic or native)
		public static FieldDef FindDataField_v19_r77172(MethodDef method, TypeDef declaringType) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 1; i++) {
				var ldloc = instrs[i];
				if (!ldloc.IsLdloc())
					continue;
				var local = ldloc.GetLocal(method.Body.Variables);
				if (local == null || local.Type.GetFullName() != "System.Byte[]")
					continue;

				var stsfld = instrs[i + 1];
				if (stsfld.OpCode.Code != Code.Stsfld)
					continue;
				var field = stsfld.Operand as FieldDef;
				if (field == null || field.DeclaringType != declaringType)
					continue;
				if (field.FieldType.FullName != "System.Byte[]")
					continue;

				return field;
			}
			return null;
		}

		public static FieldDef FindStreamField(MethodDef method, TypeDef declaringType) =>
			FindStreamField(method, declaringType, "System.IO.Stream");

		public static FieldDef FindMemoryStreamField(MethodDef method, TypeDef declaringType) =>
			FindStreamField(method, declaringType, "System.IO.MemoryStream");

		public static FieldDef FindStreamField(MethodDef method, TypeDef declaringType, string fieldTypeName) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 1; i++) {
				var newobj = instrs[i];
				if (newobj.OpCode.Code != Code.Newobj)
					continue;
				var ctor = newobj.Operand as IMethod;
				if (ctor == null || ctor.FullName != "System.Void System.IO.MemoryStream::.ctor()")
					continue;

				var stsfld = instrs[i + 1];
				if (stsfld.OpCode.Code != Code.Stsfld)
					continue;
				var field = stsfld.Operand as FieldDef;
				if (field == null || field.DeclaringType != declaringType)
					continue;
				if (field.FieldType.FullName != fieldTypeName)
					continue;

				return field;
			}
			return null;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Confuser/ConstantsDecrypterV15.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.IO;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Confuser {
	// From v1.5 r60785 to v1.7 r74637
	class ConstantsDecrypterV15 : ConstantsDecrypterBase {
		ConfuserVersion version = ConfuserVersion.Unknown;
		DecrypterInfo theDecrypterInfo;

		enum ConfuserVersion {
			Unknown,
			v15_r60785_normal,
			v15_r60785_dynamic,
			v17_r72989_dynamic,
			v17_r73404_normal,
			v17_r73740_dynamic,
			v17_r73764_dynamic,
			v17_r73764_native,
			v17_r73822_normal,
			v17_r73822_dynamic,
			v17_r73822_native,
			v17_r74021_dynamic,
			v17_r74021_native,
			// v1.7 r74637 was the last version using this constants encrypter.
		}

		public override bool Detected => theDecrypterInfo != null;

		public ConstantsDecrypterV15(ModuleDefMD module, byte[] fileData, ISimpleDeobfuscator simpleDeobfuscator)
			: base(module, fileData, simpleDeobfuscator) {
		}

		static readonly string[] requiredLocals1 = new string[] {
			"System.Byte[]",
			"System.Collections.Generic.Dictionary`2<System.UInt32,System.Object>",
			"System.IO.BinaryReader",
			"System.IO.Compression.DeflateStream",
			"System.IO.MemoryStream",
			"System.Reflection.Assembly",
		};
		static readonly string[] requiredLocals2 = new string[] {
			"System.Byte[]",
			"System.IO.BinaryReader",
			"System.IO.Compression.DeflateStream",
			"System.Reflection.Assembly",
		};
		public void Find() {
			var type = DotNetUtils.GetModuleType(module);
			if (type == null)
				return;
			foreach (var method in type.Methods) {
				if (!method.IsStatic || method.Body == null)
					continue;
				if (!DotNetUtils.IsMethod(method, "System.Object", "(System.UInt32)"))
					continue;

				var info = new DecrypterInfo();
				var localTypes = new LocalTypes(method);
				if (localTypes.All(requiredLocals1)) {
					if (localTypes.Exists("System.Collections.BitArray"))	// or System.Random
						version = ConfuserVersion.v15_r60785_normal;
					else if (DeobUtils.HasInteger(method, 0x100) &&
							DeobUtils.HasInteger(method, 0x10000) &&
							DeobUtils.HasInteger(method, 0xFFFF))
						version = ConfuserVersion.v17_r73404_normal;
					else if (DotNetUtils.CallsMethod(method, "System.String System.Text.Encoding::GetString(System.Byte[])")) {
						if (FindInstruction(method.Body.Instructions, 0, Code.Conv_I8) >= 0) {
							if (DotNetUtils.CallsMethod(method, "System.Void System.Console::WriteLine()"))
								version = ConfuserVersion.v15_r60785_dynamic;
							else
								version = ConfuserVersion.v17_r72989_dynamic;
						}
						else
							version = ConfuserVersion.v17_r73740_dynamic;
					}
					else if (DotNetUtils.CallsMethod(method, "System.String System.Text.Encoding::GetString(System.Byte[],System.Int32,System.Int32)")) {
						if ((nativeMethod = FindNativeMethod(method)) == null)
							version = ConfuserVersion.v17_r73764_dynamic;
						else
							version = ConfuserVersion.v17_r73764_native;
					}
					else
						continue;
				}
				else if (localTypes.All(requiredLocals2)) {
					if (DeobUtils.HasInteger(method, 0x100) &&
						DeobUtils.HasInteger(method, 0x10000) &&
						DeobUtils.HasInteger(method, 0xFFFF))
						version = ConfuserVersion.v17_r73822_normal;
					else if (DotNetUtils.CallsMethod(method, "System.Int32 System.Object::GetHashCode()")) {
						if ((nativeMethod = FindNativeMethod(method)) == null)
							version = ConfuserVersion.v17_r74021_dynamic;
						else
							version = ConfuserVersion.v17_r74021_native;
					}
					else if ((nativeMethod = FindNativeMethod(method)) == null)
						version = ConfuserVersion.v17_r73822_dynamic;
					else
						version = ConfuserVersion.v17_r73822_native;
				}
				else
					continue;

				info.decryptMethod = method;
				theDecrypterInfo = info;
				Add(info);
				break;
			}
		}

		public override void Initialize() {
			if ((resource = FindResource(theDecrypterInfo.decryptMethod)) == null)
				throw new ApplicationException("Could not find encrypted consts resource");

			InitializeDecrypterInfos();
			if (!InitializeFields(theDecrypterInfo))
				throw new ApplicationException("Could not find all fields");

			SetConstantsData(DeobUtils.Inflate(resource.CreateReader().ToArray(), true));
		}

		bool InitializeFields(DecrypterInfo info) {
			switch (version) {
			case ConfuserVersion.v17_r73822_normal:
			case ConfuserVersion.v17_r73822_dynamic:
			case ConfuserVersion.v17_r73822_native:
			case ConfuserVersion.v17_r74021_dynamic:
			case ConfuserVersion.v17_r74021_native:
				if (!Add(ConstantsDecrypterUtils.FindDictField(info.decryptMethod, info.decryptMethod.DeclaringType)))
					return false;
				if (!Add(ConstantsDecrypterUtils.FindMemoryStreamField(info.decryptMethod, info.decryptMethod.DeclaringType)))
					return false;
				break;

			default:
				break;
			}

			return true;
		}

		protected override byte[] DecryptData(DecrypterInfo info, MethodDef caller, object[] args, out byte typeCode) {
			uint offs = info.CalcHash(caller.MDToken.ToUInt32()) ^ (uint)args[0];
			reader.Position = offs;
			typeCode = reader.ReadByte();
			if (typeCode != info.int32Type && typeCode != info.int64Type &&
				typeCode != info.singleType && typeCode != info.doubleType &&
				typeCode != info.stringType)
				throw new ApplicationException("Invalid type code");

			var encrypted = reader.ReadBytes(reader.ReadInt32());
			return DecryptConstant(info, encrypted, offs);
		}

		byte[] DecryptConstant(DecrypterInfo info, byte[] encrypted, uint offs) {
			switch (version) {
			case ConfuserVersion.v15_r60785_normal: return DecryptConstant_v15_r60785_normal(info, encrypted, offs);
			case ConfuserVersion.v15_r60785_dynamic: return DecryptConstant_v15_r60785_dynamic(info, encrypted, offs);
			case ConfuserVersion.v17_r72989_dynamic: return DecryptConstant_v15_r60785_dynamic(info, encrypted, offs);
			case ConfuserVersion.v17_r73404_normal: return DecryptConstant_v17_r73404_normal(info, encrypted, offs);
			case ConfuserVersion.v17_r73740_dynamic: return DecryptConstant_v17_r73740_dynamic(info, encrypted, offs, 0);
			case ConfuserVersion.v17_r73764_dynamic: return DecryptConstant_v17_r73740_dynamic(info, encrypted, offs, 0);
			case ConfuserVersion.v17_r73764_native: return DecryptConstant_v17_r73764_native(info, encrypted, offs, 0);
			case ConfuserVersion.v17_r73822_normal: return DecryptConstant_v17_r73404_normal(info, encrypted, offs);
			case ConfuserVersion.v17_r73822_dynamic: return DecryptConstant_v17_r73740_dynamic(info, encrypted, offs, 0);
			case ConfuserVersion.v17_r73822_native: return DecryptConstant_v17_r73764_native(info, encrypted, offs, 0);
			case ConfuserVersion.v17_r74021_dynamic: return DecryptConstant_v17_r73740_dynamic(info, encrypted, offs, 0);
			case ConfuserVersion.v17_r74021_native: return DecryptConstant_v17_r73764_native(info, encrypted, offs, 0);
			default: throw new ApplicationException("Invalid version");
			}
		}

		byte[] DecryptConstant_v15_r60785_normal(DecrypterInfo info, byte[] encrypted, uint offs) {
			var rand = new Random((int)(info.key0 ^ offs));
			var decrypted = new byte[encrypted.Length];
			rand.NextBytes(decrypted);
			for (int i = 0; i < decrypted.Length; i++)
				decrypted[i] ^= encrypted[i];
			return decrypted;
		}

		byte[] DecryptConstant_v15_r60785_dynamic(DecrypterInfo info, byte[] encrypted, uint offs) {
			var instrs = info.decryptMethod.Body.Instructions;
			int startIndex = GetDynamicStartIndex_v15_r60785(instrs);
			int endIndex = GetDynamicEndIndex_v15_r60785(instrs, startIndex);
			if (endIndex < 0)
				throw new ApplicationException("Could not find start/endIndex");

			var dataReader = ByteArrayDataReaderFactory.CreateReader(encrypted);
			var decrypted = new byte[dataReader.ReadInt32()];
			var constReader = new Arg64ConstantsReader(instrs, false);
			ConfuserUtils.DecryptCompressedInt32Data(constReader, startIndex, endIndex, ref dataReader, decrypted);
			return decrypted;
		}

		static int GetDynamicStartIndex_v15_r60785(IList<Instruction> instrs) {
			int index = FindInstruction(instrs, 0, Code.Conv_I8);
			if (index < 0)
				return -1;
			if (FindInstruction(instrs, index + 1, Code.Conv_I8) >= 0)
				return -1;
			return index;
		}

		static int GetDynamicEndIndex_v15_r60785(IList<Instruction> instrs, int index) {
			if (index < 0)
				return -1;
			for (int i = index; i < instrs.Count; i++) {
				var instr = instrs[i];
				if (instr.OpCode.FlowControl != FlowControl.Next)
					break;
				if (instr.OpCode.Code == Code.Conv_U1)
					return i;
			}
			return -1;
		}

		static int FindInstruction(IList<Instruction> instrs, int index, Code code) {
			for (int i = index; i < instrs.Count; i++) {
				if (instrs[i].OpCode.Code == code)
					return i;
			}
			return -1;
		}

		byte[] DecryptConstant_v17_r73404_normal(DecrypterInfo info, byte[] encrypted, uint offs) =>
			ConfuserUtils.Decrypt(info.key0 ^ offs, encrypted);

		public override bool GetRevisionRange(out int minRev, out int maxRev) {
			switch (version) {
			case ConfuserVersion.Unknown:
				minRev = maxRev = 0;
				return false;

			case ConfuserVersion.v15_r60785_normal:
				minRev = 60785;
				maxRev = 72989;
				return true;

			case ConfuserVersion.v17_r73404_normal:
				minRev = 73404;
				maxRev = 73791;
				return true;

			case ConfuserVersion.v17_r73822_normal:
				minRev = 73822;
				maxRev = 74637;
				return true;

			case ConfuserVersion.v15_r60785_dynamic:
				minRev = 60785;
				maxRev = 72868;
				return true;

			case ConfuserVersion.v17_r72989_dynamic:
				minRev = 72989;
				maxRev = 73605;
				return true;

			case ConfuserVersion.v17_r73740_dynamic:
				minRev = 73740;
				maxRev = 73740;
				return true;

			case ConfuserVersion.v17_r73764_dynamic:
			case ConfuserVersion.v17_r73764_native:
				minRev = 73764;
				maxRev = 73791;
				return true;

			case ConfuserVersion.v17_r73822_dynamic:
			case ConfuserVersion.v17_r73822_native:
				minRev = 73822;
				maxRev = 73822;
				return true;

			case ConfuserVersion.v17_r74021_dynamic:
			case ConfuserVersion.v17_r74021_native:
				minRev = 74021;
				maxRev = 74637;
				return true;

			default: throw new ApplicationException("Invalid version");
			}
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Confuser/ConstantsDecrypterV17.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Text;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Confuser {
	// From v1.7 r74708 to v1.8 r75349
	class ConstantsDecrypterV17 : ConstantsDecrypterBase {
		MethodDef initMethod;
		ConfuserVersion version = ConfuserVersion.Unknown;
		string resourceName;
		int keyArraySize = 8;

		enum ConfuserVersion {
			Unknown,
			v17_r74708_normal,
			v17_r74708_dynamic,
			v17_r74708_native,
			v17_r74788_normal,
			v17_r74788_dynamic,
			v17_r74788_native,
			v17_r74816_normal,
			v17_r74816_dynamic,
			v17_r74816_native,
			v17_r75056_normal,
			v17_r75056_dynamic,
			v17_r75056_native,
			v18_r75257_normal,
			v18_r75257_dynamic,
			v18_r75257_native,
			// 1.8 r75349 was the last version using this constants encrypter. Starting
			// from 1.8 r75367, the new constants encrypter (generic methods) is used.
		}

		class DecrypterInfoV17 : DecrypterInfo {
			public readonly ConfuserVersion version = ConfuserVersion.Unknown;
			public uint key4, key5;

			public DecrypterInfoV17(ConfuserVersion version, MethodDef decryptMethod) {
				this.version = version;
				this.decryptMethod = decryptMethod;
			}

			protected override bool InitializeKeys() {
				if (!FindKey0(decryptMethod, out key0))
					return false;
				if (!FindKey1_v17(decryptMethod, out key1))
					return false;
				if (!FindKey2Key3(decryptMethod, out key2, out key3))
					return false;
				if (!FindKey4(decryptMethod, out key4))
					return false;
				if (!FindKey5(decryptMethod, out key5))
					return false;

				return true;
			}

			static bool FindKey1_v17(MethodDef method, out uint key) {
				var instrs = method.Body.Instructions;
				for (int i = 0; i < instrs.Count - 4; i++) {
					var stloc = instrs[i];
					if (!stloc.IsStloc())
						continue;
					var ldci4 = instrs[i + 1];
					if (!ldci4.IsLdcI4())
						continue;
					var ldcloc = instrs[i + 2];
					if (!ldcloc.IsLdloc())
						continue;
					if (stloc.GetLocal(method.Body.Variables) != ldcloc.GetLocal(method.Body.Variables))
						continue;
					if (instrs[i + 3].OpCode.Code != Code.Xor)
						continue;
					if (!instrs[i + 4].IsStloc())
						continue;

					key = (uint)ldci4.GetLdcI4Value();
					return true;
				}
				key = 0;
				return false;
			}

			bool FindKey4(MethodDef method, out uint key) {
				switch (version) {
				case ConfuserVersion.v17_r74708_normal:
				case ConfuserVersion.v17_r74788_normal:
				case ConfuserVersion.v17_r74816_normal:
				case ConfuserVersion.v17_r75056_normal:
				case ConfuserVersion.v18_r75257_normal:
					return FindKey4_normal(method, out key);
				case ConfuserVersion.v17_r74708_dynamic:
				case ConfuserVersion.v17_r74708_native:
				case ConfuserVersion.v17_r74788_dynamic:
				case ConfuserVersion.v17_r74788_native:
				case ConfuserVersion.v17_r74816_dynamic:
				case ConfuserVersion.v17_r74816_native:
				case ConfuserVersion.v17_r75056_dynamic:
				case ConfuserVersion.v17_r75056_native:
				case ConfuserVersion.v18_r75257_dynamic:
				case ConfuserVersion.v18_r75257_native:
					return FindKey4_other(method, out key);
				default:
					throw new ApplicationException("Invalid version");
				}
			}

			static bool FindKey4_normal(MethodDef method, out uint key) {
				var instrs = method.Body.Instructions;
				for (int i = 0; i < instrs.Count - 5; i++) {
					if (!instrs[i].IsLdloc())
						continue;
					if (!instrs[i + 1].IsLdloc())
						continue;
					if (instrs[i + 2].OpCode.Code != Code.Add)
						continue;
					var ldci4 = instrs[i + 3];
					if (!ldci4.IsLdcI4())
						continue;
					if (instrs[i + 4].OpCode.Code != Code.Mul)
						continue;
					if (!instrs[i + 5].IsStloc())
						continue;

					key = (uint)ldci4.GetLdcI4Value();
					return true;
				}
				key = 0;
				return false;
			}

			static bool FindKey4_other(MethodDef method, out uint key) {
				var instrs = method.Body.Instructions;
				for (int i = 0; i < instrs.Count; i++) {
					int index = ConfuserUtils.FindCallMethod(instrs, i, Code.Callvirt, "System.Int32 System.IO.BinaryReader::ReadInt32()");
					if (index < 0)
						break;
					if (index + 1 >= instrs.Count)
						break;
					var ldci4 = instrs[index + 1];
					if (!ldci4.IsLdcI4())
						continue;

					key = (uint)ldci4.GetLdcI4Value();
					return true;
				}
				key = 0;
				return false;
			}

			bool FindKey5(MethodDef method, out uint key) {
				switch (version) {
				case ConfuserVersion.v17_r74788_normal:
				case ConfuserVersion.v17_r74788_dynamic:
				case ConfuserVersion.v17_r74788_native:
				case ConfuserVersion.v17_r74816_normal:
				case ConfuserVersion.v17_r74816_dynamic:
				case ConfuserVersion.v17_r74816_native:
				case ConfuserVersion.v17_r75056_normal:
				case ConfuserVersion.v17_r75056_dynamic:
				case ConfuserVersion.v17_r75056_native:
				case ConfuserVersion.v18_r75257_normal:
				case ConfuserVersion.v18_r75257_dynamic:
				case ConfuserVersion.v18_r75257_native:
					return FindKey5_v17_r74788(method, out key);
				default:
					key = 0;
					return true;
				}
			}

			static bool FindKey5_v17_r74788(MethodDef method, out uint key) {
				var instrs = method.Body.Instructions;
				for (int i = 0; i < instrs.Count; i++) {
					i = ConfuserUtils.FindCallMethod(instrs, i, Code.Callvirt, "System.Reflection.Module System.Reflection.Assembly::GetModule(System.String)");
					if (i < 0)
						break;
					if (i + 1 >= instrs.Count)
						break;
					var ldci4 = instrs[i + 1];
					if (!ldci4.IsLdcI4())
						continue;

					key = (uint)ldci4.GetLdcI4Value();
					return true;
				}
				key = 0;
				return false;
			}
		}

		public override bool Detected => initMethod != null;

		public ConstantsDecrypterV17(ModuleDefMD module, byte[] fileData, ISimpleDeobfuscator simpleDeobfuscator)
			: base(module, fileData, simpleDeobfuscator) {
		}

		static readonly string[] requiredLocalsCctor = new string[] {
			"System.Reflection.Assembly",
			"System.IO.Compression.DeflateStream",
			"System.Byte[]",
			"System.Int32",
		};
		public void Find() {
			var cctor = DotNetUtils.GetModuleTypeCctor(module);
			if (cctor == null)
				return;
			if (!new LocalTypes(cctor).All(requiredLocalsCctor))
				return;

			simpleDeobfuscator.Deobfuscate(cctor, SimpleDeobfuscatorFlags.Force | SimpleDeobfuscatorFlags.DisableConstantsFolderExtraInstrs);
			if (!Add(ConstantsDecrypterUtils.FindDictField(cctor, cctor.DeclaringType)))
				return;
			if (!Add(ConstantsDecrypterUtils.FindStreamField(cctor, cctor.DeclaringType)))
				return;

			var method = GetDecryptMethod();
			if (method == null)
				return;

			resourceName = GetResourceName(cctor);

			if (resourceName != null) {
				simpleDeobfuscator.Deobfuscate(method);
				keyArraySize = GetKeyArraySize(method);
				if (keyArraySize == 8)
					InitVersion(method, ConfuserVersion.v17_r75056_normal, ConfuserVersion.v17_r75056_dynamic, ConfuserVersion.v17_r75056_native);
				else if (keyArraySize == 16)
					InitVersion(method, ConfuserVersion.v18_r75257_normal, ConfuserVersion.v18_r75257_dynamic, ConfuserVersion.v18_r75257_native);
				else
					return;
			}
			else if (DotNetUtils.CallsMethod(method, "System.String System.Reflection.Module::get_ScopeName()"))
				InitVersion(method, ConfuserVersion.v17_r74816_normal, ConfuserVersion.v17_r74816_dynamic, ConfuserVersion.v17_r74816_native);
			else if (DotNetUtils.CallsMethod(method, "System.Reflection.Module System.Reflection.Assembly::GetModule(System.String)"))
				InitVersion(method, ConfuserVersion.v17_r74788_normal, ConfuserVersion.v17_r74788_dynamic, ConfuserVersion.v17_r74788_native);
			else
				InitVersion(method, ConfuserVersion.v17_r74708_normal, ConfuserVersion.v17_r74708_dynamic, ConfuserVersion.v17_r74708_native);

			initMethod = cctor;
		}

		void InitVersion(MethodDef method, ConfuserVersion normal, ConfuserVersion dynamic, ConfuserVersion native) {
			if (DeobUtils.HasInteger(method, 0x100) &&
				DeobUtils.HasInteger(method, 0x10000) &&
				DeobUtils.HasInteger(method, 0xFFFF))
				version = normal;
			else if ((nativeMethod = FindNativeMethod(method)) == null)
				version = dynamic;
			else
				version = native;
		}

		MethodDef GetDecryptMethod() {
			foreach (var type in module.Types) {
				if (type.Attributes != (TypeAttributes.Abstract | TypeAttributes.Sealed))
					continue;
				if (!CheckMethods(type.Methods))
					continue;
				foreach (var method in type.Methods) {
					if (!DotNetUtils.IsMethod(method, "System.Object", "(System.UInt32,System.UInt32)"))
						continue;

					return method;
				}
			}
			return null;
		}

		protected override byte[] DecryptData(DecrypterInfo info2, MethodDef caller, object[] args, out byte typeCode) {
			var info = (DecrypterInfoV17)info2;
			uint offs = info.CalcHash(info2.decryptMethod.MDToken.ToUInt32() ^ (info2.decryptMethod.DeclaringType.MDToken.ToUInt32() * (uint)args[0])) ^ (uint)args[1];
			reader.Position = offs;
			typeCode = reader.ReadByte();
			if (typeCode != info.int32Type && typeCode != info.int64Type &&
				typeCode != info.singleType && typeCode != info.doubleType &&
				typeCode != info.stringType)
				throw new ApplicationException("Invalid type code");

			var encrypted = reader.ReadBytes(reader.ReadInt32());
			return DecryptConstant(info, encrypted, offs, typeCode);
		}

		byte[] DecryptConstant(DecrypterInfoV17 info, byte[] encrypted, uint offs, byte typeCode) {
			switch (info.version) {
			case ConfuserVersion.v17_r74708_normal: return DecryptConstant_v17_r74708_normal(info, encrypted, offs, typeCode);
			case ConfuserVersion.v17_r74708_dynamic: return DecryptConstant_v17_r74708_dynamic(info, encrypted, offs, typeCode);
			case ConfuserVersion.v17_r74708_native: return DecryptConstant_v17_r74708_native(info, encrypted, offs, typeCode);
			case ConfuserVersion.v17_r74788_normal: return DecryptConstant_v17_r74788_normal(info, encrypted, offs, typeCode);
			case ConfuserVersion.v17_r74788_dynamic: return DecryptConstant_v17_r74788_dynamic(info, encrypted, offs, typeCode);
			case ConfuserVersion.v17_r74788_native: return DecryptConstant_v17_r74788_native(info, encrypted, offs, typeCode);
			case ConfuserVersion.v17_r74816_normal: return DecryptConstant_v17_r74788_normal(info, encrypted, offs, typeCode);
			case ConfuserVersion.v17_r74816_dynamic: return DecryptConstant_v17_r74788_dynamic(info, encrypted, offs, typeCode);
			case ConfuserVersion.v17_r74816_native: return DecryptConstant_v17_r74788_native(info, encrypted, offs, typeCode);
			case ConfuserVersion.v17_r75056_normal: return DecryptConstant_v17_r74788_normal(info, encrypted, offs, typeCode);
			case ConfuserVersion.v17_r75056_dynamic: return DecryptConstant_v17_r74788_dynamic(info, encrypted, offs, typeCode);
			case ConfuserVersion.v17_r75056_native: return DecryptConstant_v17_r74788_native(info, encrypted, offs, typeCode);
			case ConfuserVersion.v18_r75257_normal: return DecryptConstant_v17_r74788_normal(info, encrypted, offs, typeCode);
			case ConfuserVersion.v18_r75257_dynamic: return DecryptConstant_v17_r74788_dynamic(info, encrypted, offs, typeCode);
			case ConfuserVersion.v18_r75257_native: return DecryptConstant_v17_r74788_native(info, encrypted, offs, typeCode);
			default:
				throw new ApplicationException("Invalid version");
			}
		}

		byte[] DecryptConstant_v17_r74708_normal(DecrypterInfoV17 info, byte[] encrypted, uint offs, byte typeCode) =>
			ConfuserUtils.Decrypt(info.key4 * (offs + typeCode), encrypted);

		byte[] DecryptConstant_v17_r74708_dynamic(DecrypterInfoV17 info, byte[] encrypted, uint offs, byte typeCode) =>
			DecryptConstant_v17_r73740_dynamic(info, encrypted, offs, info.key4);

		byte[] DecryptConstant_v17_r74708_native(DecrypterInfoV17 info, byte[] encrypted, uint offs, byte typeCode) =>
			DecryptConstant_v17_r73764_native(info, encrypted, offs, info.key4);

		byte[] DecryptConstant_v17_r74788_normal(DecrypterInfoV17 info, byte[] encrypted, uint offs, byte typeCode) =>
			ConfuserUtils.Decrypt(info.key4 * (offs + typeCode), encrypted, GetKey_v17_r74788(info));

		byte[] DecryptConstant_v17_r74788_dynamic(DecrypterInfoV17 info, byte[] encrypted, uint offs, byte typeCode) =>
			DecryptConstant_v17_r73740_dynamic(info, encrypted, offs, info.key4, GetKey_v17_r74788(info));

		byte[] DecryptConstant_v17_r74788_native(DecrypterInfoV17 info, byte[] encrypted, uint offs, byte typeCode) =>
			DecryptConstant_v17_r73764_native(info, encrypted, offs, info.key4, GetKey_v17_r74788(info));

		byte[] GetKey_v17_r74788(DecrypterInfoV17 info) {
			var key = module.ReadBlob(info.decryptMethod.MDToken.ToUInt32() ^ info.key5);
			if (key.Length != keyArraySize)
				throw new ApplicationException("Invalid key size");
			return key;
		}

		public override void Initialize() {
			if (resourceName != null)
				resource = DotNetUtils.GetResource(module, resourceName) as EmbeddedResource;
			else
				resource = FindResource(initMethod);
			if (resource == null)
				throw new ApplicationException("Could not find encrypted consts resource");

			FindDecrypterInfos();
			InitializeDecrypterInfos();

			SetConstantsData(DeobUtils.Inflate(resource.CreateReader().ToArray(), true));
		}

		void FindDecrypterInfos() {
			foreach (var type in module.Types) {
				if (type.Attributes != (TypeAttributes.Abstract | TypeAttributes.Sealed))
					continue;
				if (!CheckMethods(type.Methods))
					continue;
				foreach (var method in type.Methods) {
					if (!DotNetUtils.IsMethod(method, "System.Object", "(System.UInt32,System.UInt32)"))
						continue;

					var info = new DecrypterInfoV17(version, method);
					Add(info);
				}
			}
		}

		static bool CheckMethods(IEnumerable<MethodDef> methods) {
			int numMethods = 0;
			foreach (var method in methods) {
				if (method.Name == ".ctor" || method.Name == ".cctor")
					return false;
				if (method.Attributes != (MethodAttributes.Static | MethodAttributes.HideBySig | MethodAttributes.CompilerControlled))
					return false;
				if (!DotNetUtils.IsMethod(method, "System.Object", "(System.UInt32,System.UInt32)"))
					return false;

				numMethods++;
			}
			return numMethods > 0;
		}

		static string GetResourceName(MethodDef method) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count; i++) {
				i = ConfuserUtils.FindCallMethod(instrs, i, Code.Call, "System.Byte[] System.BitConverter::GetBytes(System.Int32)");
				if (i < 0)
					break;
				if (i == 0)
					continue;
				var ldci4 = instrs[i - 1];
				if (!ldci4.IsLdcI4())
					continue;
				return Encoding.UTF8.GetString(BitConverter.GetBytes(ldci4.GetLdcI4Value()));
			}
			return null;
		}

		static int GetKeyArraySize(MethodDef method) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 4; i++) {
				if (!instrs[i].IsLdloc())
					continue;
				if (!instrs[i + 1].IsLdloc())
					continue;
				var ldci4 = instrs[i + 2];
				if (!ldci4.IsLdcI4())
					continue;
				if (instrs[i + 3].OpCode.Code != Code.Rem)
					continue;
				if (instrs[i + 4].OpCode.Code != Code.Ldelem_U1)
					continue;

				return ldci4.GetLdcI4Value();
			}
			return -1;
		}

		public override bool GetRevisionRange(out int minRev, out int maxRev) {
			switch (version) {
			case ConfuserVersion.Unknown:
				minRev = maxRev = 0;
				return false;

			case ConfuserVersion.v17_r74708_normal:
			case ConfuserVersion.v17_r74708_dynamic:
			case ConfuserVersion.v17_r74708_native:
				minRev = 74708;
				maxRev = 74708;
				return true;

			case ConfuserVersion.v17_r74788_normal:
			case ConfuserVersion.v17_r74788_dynamic:
			case ConfuserVersion.v17_r74788_native:
				minRev = 74788;
				maxRev = 74788;
				return true;

			case ConfuserVersion.v17_r74816_normal:
			case ConfuserVersion.v17_r74816_dynamic:
			case ConfuserVersion.v17_r74816_native:
				minRev = 74816;
				maxRev = 74852;
				return true;

			case ConfuserVersion.v17_r75056_normal:
			case ConfuserVersion.v17_r75056_dynamic:
			case ConfuserVersion.v17_r75056_native:
				minRev = 75056;
				maxRev = 75184;
				return true;

			case ConfuserVersion.v18_r75257_normal:
			case ConfuserVersion.v18_r75257_dynamic:
			case ConfuserVersion.v18_r75257_native:
				minRev = 75257;
				maxRev = 75349;
				return true;

			default: throw new ApplicationException("Invalid version");
			}
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Confuser/ConstantsDecrypterV18.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using dnlib.IO;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Confuser {
	// Since v1.8 r75367
	class ConstantsDecrypterV18 : IVersionProvider {
		ModuleDefMD module;
		byte[] fileData;
		ISimpleDeobfuscator simpleDeobfuscator;
		FieldDef dictField, dataField;
		MethodDef installMethod;
		MethodDefAndDeclaringTypeDict<DecrypterInfo> decrypters = new MethodDefAndDeclaringTypeDict<DecrypterInfo>();
		uint key0, key0d;
		MethodDef nativeMethod;
		TypeDef lzmaType;
		EmbeddedResource resource;
		byte[] constants;
		ConfuserVersion version = ConfuserVersion.Unknown;

		public enum ConfuserVersion {
			Unknown,
			v18_r75367_normal,
			v18_r75367_dynamic,
			v18_r75367_native,
			v18_r75369_normal,
			v18_r75369_dynamic,
			v18_r75369_native,
			v19_r77172_normal,
			v19_r77172_dynamic,
			v19_r77172_native,
			v19_r78056_normal,
			v19_r78056_dynamic,
			v19_r78056_native,
			v19_r78363_normal,
			v19_r78363_dynamic,
			v19_r78363_native,
			v19_r79630_normal,
			v19_r79630_dynamic,
			v19_r79630_native,
		}

		public class DecrypterInfo {
			readonly ConstantsDecrypterV18 constantsDecrypter;
			public readonly MethodDef method;
			public ulong key0l, key1l, key2l;
			public uint key0, key0d;
			readonly ConfuserVersion version;

			public DecrypterInfo(ConstantsDecrypterV18 constantsDecrypter, MethodDef method, ConfuserVersion version) {
				this.constantsDecrypter = constantsDecrypter;
				this.method = method;
				this.version = version;
			}

			public string DecryptString(uint magic1, ulong magic2) => Encoding.UTF8.GetString(Decrypt(magic1, magic2));
			public int DecryptInt32(uint magic1, ulong magic2) => BitConverter.ToInt32(Decrypt(magic1, magic2), 0);
			public long DecryptInt64(uint magic1, ulong magic2) => BitConverter.ToInt64(Decrypt(magic1, magic2), 0);
			public float DecryptSingle(uint magic1, ulong magic2) => BitConverter.ToSingle(Decrypt(magic1, magic2), 0);
			public double DecryptDouble(uint magic1, ulong magic2) => BitConverter.ToDouble(Decrypt(magic1, magic2), 0);

			byte[] Decrypt(uint magic1, ulong magic2) {
				ulong info = Hash(method.DeclaringType.MDToken.ToUInt32() * magic1) ^ magic2;
				int offset = (int)(info >> 32);
				int len = (int)info;
				var decrypted = new byte[len];
				byte[] key = BitConverter.GetBytes(method.MDToken.ToUInt32() ^ key0d);
				for (int i = 0; i < len; i++)
					decrypted[i] = (byte)(constantsDecrypter.constants[offset + i] ^ key[(offset + i) & 3]);
				return decrypted;
			}

			ulong Hash(uint magic) {
				switch (version) {
				case ConfuserVersion.v18_r75367_normal:
				case ConfuserVersion.v18_r75367_dynamic:
				case ConfuserVersion.v18_r75367_native:
					return Hash1(key0l ^ magic);
				case ConfuserVersion.v18_r75369_normal:
				case ConfuserVersion.v18_r75369_dynamic:
				case ConfuserVersion.v18_r75369_native:
				case ConfuserVersion.v19_r77172_normal:
				case ConfuserVersion.v19_r77172_dynamic:
				case ConfuserVersion.v19_r77172_native:
				case ConfuserVersion.v19_r78056_normal:
				case ConfuserVersion.v19_r78056_dynamic:
				case ConfuserVersion.v19_r78056_native:
				case ConfuserVersion.v19_r78363_normal:
				case ConfuserVersion.v19_r78363_dynamic:
				case ConfuserVersion.v19_r78363_native:
				case ConfuserVersion.v19_r79630_normal:
				case ConfuserVersion.v19_r79630_dynamic:
				case ConfuserVersion.v19_r79630_native:
					return Hash1(key0l * magic);
				default:
					throw new ApplicationException("Invalid version");
				}
			}

			ulong Hash1(ulong h0) {
				ulong h1 = key1l;
				ulong h2 = key2l;
				h1 *= h0;
				h2 *= h0;
				h0 *= h0;
				ulong hash = 14695981039346656037UL;
				while (h0 != 0) {
					hash *= 1099511628211UL;
					hash = (hash ^ h0) + (h1 ^ h2) * key0;
					h1 *= 0x811C9DC5;
					h2 *= 0xA2CEBAB2;
					h0 >>= 8;
				}
				return hash;
			}
		}

		public IEnumerable<TypeDef> Types {
			get {
				var types = new List<TypeDef>();
				foreach (var info in decrypters.GetValues())
					types.Add(info.method.DeclaringType);
				return types;
			}
		}

		public IEnumerable<FieldDef> Fields => new List<FieldDef> { dataField, dictField };
		public MethodDef NativeMethod => nativeMethod;
		public TypeDef LzmaType => lzmaType;
		public EmbeddedResource Resource => resource;
		public IEnumerable<DecrypterInfo> Decrypters => decrypters.GetValues();
		public bool Detected => installMethod != null;

		public ConstantsDecrypterV18(ModuleDefMD module, byte[] fileData, ISimpleDeobfuscator simpleDeobfuscator) {
			this.module = module;
			this.fileData = fileData;
			this.simpleDeobfuscator = simpleDeobfuscator;
		}

		public void Find() {
			var cctor = DotNetUtils.GetModuleTypeCctor(module);
			if (cctor == null)
				return;
			simpleDeobfuscator.Deobfuscate(cctor, SimpleDeobfuscatorFlags.Force | SimpleDeobfuscatorFlags.DisableConstantsFolderExtraInstrs);

			if ((dictField = ConstantsDecrypterUtils.FindDictField(cctor, cctor.DeclaringType)) == null)
				return;

			if ((dataField = ConstantsDecrypterUtils.FindDataField_v18_r75367(cctor, cctor.DeclaringType)) == null &&
				(dataField = ConstantsDecrypterUtils.FindDataField_v19_r77172(cctor, cctor.DeclaringType)) == null)
				return;

			nativeMethod = FindNativeMethod(cctor, cctor.DeclaringType);

			var method = GetDecryptMethod();
			if (method == null)
				return;
			simpleDeobfuscator.Deobfuscate(method, SimpleDeobfuscatorFlags.DisableConstantsFolderExtraInstrs);
			var info = new DecrypterInfo(this, method, ConfuserVersion.Unknown);
			if (FindKeys_v18_r75367(info))
				InitVersion(cctor, ConfuserVersion.v18_r75367_normal, ConfuserVersion.v18_r75367_dynamic, ConfuserVersion.v18_r75367_native);
			else if (FindKeys_v18_r75369(info)) {
				lzmaType = ConfuserUtils.FindLzmaType(cctor);
				if (lzmaType == null)
					InitVersion(cctor, ConfuserVersion.v18_r75369_normal, ConfuserVersion.v18_r75369_dynamic, ConfuserVersion.v18_r75369_native);
				else if (!DotNetUtils.CallsMethod(method, "System.Void System.Threading.Monitor::Exit(System.Object)"))
					InitVersion(cctor, ConfuserVersion.v19_r77172_normal, ConfuserVersion.v19_r77172_dynamic, ConfuserVersion.v19_r77172_native);
				else if (DotNetUtils.CallsMethod(method, "System.Void System.Diagnostics.StackFrame::.ctor(System.Int32)"))
					InitVersion(cctor, ConfuserVersion.v19_r78363_normal, ConfuserVersion.v19_r78363_dynamic, ConfuserVersion.v19_r78363_native);
				else {
					int index1 = ConfuserUtils.FindCallMethod(cctor.Body.Instructions, 0, Code.Callvirt, "System.Reflection.Module System.Reflection.MemberInfo::get_Module()");
					int index2 = ConfuserUtils.FindCallMethod(cctor.Body.Instructions, 0, Code.Callvirt, "System.Int32 System.Reflection.MemberInfo::get_MetadataToken()");
					if (index1 < 0 || index2 < 0) {
					}
					if (index2 - index1 == 3)
						InitVersion(cctor, ConfuserVersion.v19_r78056_normal, ConfuserVersion.v19_r78056_dynamic, ConfuserVersion.v19_r78056_native);
					else if (index2 - index1 == -4)
						InitVersion(cctor, ConfuserVersion.v19_r79630_normal, ConfuserVersion.v19_r79630_dynamic, ConfuserVersion.v19_r79630_native);
				}
			}
			else
				return;

			installMethod = cctor;
		}

		void InitVersion(MethodDef installMethod, ConfuserVersion normal, ConfuserVersion dynamic, ConfuserVersion native) {
			if (nativeMethod != null)
				version = native;
			else if (DeobUtils.HasInteger(installMethod, 0x10000))
				version = normal;
			else
				version = dynamic;
		}

		public void Initialize() {
			if (installMethod == null)
				return;

			if (!FindKeys())
				throw new ApplicationException("Could not find keys");

			if ((resource = FindResource(key0)) == null)
				throw new ApplicationException("Could not find resource");
			constants = DecryptResource(resource.CreateReader().ToArray());

			FindDecrypters();
		}

		EmbeddedResource FindResource(uint magic) {
			var name = Encoding.UTF8.GetString(BitConverter.GetBytes(magic));
			return DotNetUtils.GetResource(module, name) as EmbeddedResource;
		}

		bool FindKeys() {
			if (!FindKey0(installMethod, out key0))
				return false;
			if (!FindKey0d(installMethod, out key0d))
				return false;

			return true;
		}

		static bool FindKey0(MethodDef method, out uint key) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count; i++) {
				int index = ConfuserUtils.FindCallMethod(instrs, i, Code.Call, "System.Text.Encoding System.Text.Encoding::get_UTF8()");
				if (index < 0)
					break;
				int index2 = ConfuserUtils.FindCallMethod(instrs, i, Code.Call, "System.Byte[] System.BitConverter::GetBytes(System.Int32)");
				if (index2 - index != 2)
					continue;
				var ldci4 = instrs[index + 1];
				if (!ldci4.IsLdcI4())
					continue;

				key = (uint)ldci4.GetLdcI4Value();
				return true;
			}

			key = 0;
			return false;
		}

		static bool FindKey0d(MethodDef method, out uint key) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count; i++) {
				int index = ConfuserUtils.FindCallMethod(instrs, i, Code.Callvirt, "System.Reflection.Module System.Reflection.MemberInfo::get_Module()");
				if (index < 0)
					break;
				int index2 = ConfuserUtils.FindCallMethod(instrs, i, Code.Callvirt, "System.Int32 System.Reflection.MemberInfo::get_MetadataToken()");
				int ldci4Index;
				switch (index2 - index) {
				case 3:
					// rev <= r79440
					ldci4Index = index + 1;
					break;

				case -4:
					// rev >= r79630
					ldci4Index = index2 - 2;
					break;

				default:
					continue;
				}

				var ldci4 = instrs[ldci4Index];
				if (!ldci4.IsLdcI4())
					continue;
				if (!instrs[ldci4Index + 1].IsLdloc())
					continue;

				key = (uint)ldci4.GetLdcI4Value();
				return true;
			}

			key = 0;
			return false;
		}

		static MethodDef FindNativeMethod(MethodDef method, TypeDef declaringType) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count; i++) {
				if (!instrs[i].IsLdloc())
					continue;
				var call = instrs[i + 1];
				if (call.OpCode.Code != Code.Call)
					continue;
				var calledMethod = call.Operand as MethodDef;
				if (calledMethod == null || !calledMethod.IsStatic || !calledMethod.IsNative)
					continue;
				if (!DotNetUtils.IsMethod(calledMethod, "System.Int32", "(System.Int32)"))
					continue;

				return calledMethod;
			}
			return null;
		}

		MethodDef GetDecryptMethod() {
			foreach (var type in module.Types) {
				if (type.Attributes != (TypeAttributes.Abstract | TypeAttributes.Sealed))
					continue;
				if (!CheckMethods(type.Methods))
					continue;
				foreach (var method in type.Methods) {
					if (IsDecryptMethodSignature(method))
						return method;
				}
			}
			return null;
		}

		static bool CheckMethods(IEnumerable<MethodDef> methods) {
			int numMethods = 0;
			foreach (var method in methods) {
				if (method.Name == ".ctor" || method.Name == ".cctor")
					return false;
				if (!IsDecryptMethodSignature(method))
					return false;

				numMethods++;
			}
			return numMethods > 0;
		}

		static bool IsDecryptMethodSignature(MethodDef method) {
			if (method == null || method.Body == null)
				return false;
			if (method.Attributes != (MethodAttributes.Static | MethodAttributes.HideBySig | MethodAttributes.CompilerControlled))
				return false;
			var sig = method.MethodSig;
			if (sig == null)
				return false;
			if (sig.Params.Count != 2)
				return false;
			if (sig.Params[0].GetElementType() != ElementType.U4)
				return false;
			if (sig.Params[1].GetElementType() != ElementType.U8)
				return false;
			if (!(sig.RetType.RemovePinnedAndModifiers() is GenericMVar))
				return false;
			if (sig.GenParamCount != 1)
				return false;
			return true;
		}

		void FindDecrypters() {
			foreach (var type in module.Types) {
				if (type.Attributes != (TypeAttributes.Abstract | TypeAttributes.Sealed))
					continue;
				if (!CheckMethods(type.Methods))
					continue;
				foreach (var method in type.Methods) {
					var info = CreateDecrypterInfo(method);
					if (info != null)
						decrypters.Add(info.method, info);
				}
			}
		}

		DecrypterInfo CreateDecrypterInfo(MethodDef method) {
			if (!IsDecryptMethodSignature(method))
				return null;

			simpleDeobfuscator.Deobfuscate(method, SimpleDeobfuscatorFlags.DisableConstantsFolderExtraInstrs);
			var info = new DecrypterInfo(this, method, version);
			if (!FindKeys(info))
				return null;

			return info;
		}

		bool FindKeys(DecrypterInfo info) {
			switch (version) {
			case ConfuserVersion.v18_r75367_normal:
			case ConfuserVersion.v18_r75367_dynamic:
			case ConfuserVersion.v18_r75367_native:
				return FindKeys_v18_r75367(info);
			case ConfuserVersion.v18_r75369_normal:
			case ConfuserVersion.v18_r75369_dynamic:
			case ConfuserVersion.v18_r75369_native:
			case ConfuserVersion.v19_r77172_normal:
			case ConfuserVersion.v19_r77172_dynamic:
			case ConfuserVersion.v19_r77172_native:
			case ConfuserVersion.v19_r78056_normal:
			case ConfuserVersion.v19_r78056_dynamic:
			case ConfuserVersion.v19_r78056_native:
			case ConfuserVersion.v19_r78363_normal:
			case ConfuserVersion.v19_r78363_dynamic:
			case ConfuserVersion.v19_r78363_native:
			case ConfuserVersion.v19_r79630_normal:
			case ConfuserVersion.v19_r79630_dynamic:
			case ConfuserVersion.v19_r79630_native:
				return FindKeys_v18_r75369(info);
			default:
				throw new ApplicationException("Invalid version");
			}
		}

		static bool FindKeys_v18_r75367(DecrypterInfo info) {
			if (!FindLKeys_v18_r75367(info))
				return false;
			if (!FindKey0_v18_r75367(info))
				return false;
			if (!FindKey0d_v18_r75367(info))
				return false;
			return true;
		}

		static bool FindKeys_v18_r75369(DecrypterInfo info) {
			if (!FindLKeys_v18_r75369(info))
				return false;
			if (!FindKey0_v18_r75369(info))
				return false;
			if (!FindKey0d_v18_r75367(info))
				return false;
			return true;
		}

		static bool FindLKeys_v18_r75367(DecrypterInfo info) {
			var instrs = info.method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 10; i++) {
				var ldci4_1 = instrs[i];
				if (!ldci4_1.IsLdcI4())
					continue;
				if (!instrs[i + 1].IsLdloc())
					continue;
				if (instrs[i + 2].OpCode.Code != Code.Xor)
					continue;
				if (instrs[i + 3].OpCode.Code != Code.Conv_U8)
					continue;
				if (!instrs[i + 4].IsStloc())
					continue;
				var ldci4_2 = instrs[i + 5];
				if (!ldci4_2.IsLdcI4())
					continue;
				if (instrs[i + 6].OpCode.Code != Code.Conv_I8)
					continue;
				if (!instrs[i + 7].IsStloc())
					continue;
				var ldci4_3 = instrs[i + 8];
				if (!ldci4_3.IsLdcI4())
					continue;
				if (instrs[i + 9].OpCode.Code != Code.Conv_I8)
					continue;
				if (!instrs[i + 10].IsStloc())
					continue;

				info.key0l = (uint)ldci4_1.GetLdcI4Value();
				info.key1l = (uint)ldci4_2.GetLdcI4Value();
				info.key2l = (uint)ldci4_3.GetLdcI4Value();
				return true;
			}
			return false;
		}

		static bool FindKey0_v18_r75367(DecrypterInfo info) {
			var instrs = info.method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 4; i++) {
				if (instrs[i].OpCode.Code != Code.Xor)
					continue;
				var ldci4 = instrs[i + 1];
				if (!ldci4.IsLdcI4())
					continue;
				if (instrs[i + 2].OpCode.Code != Code.Conv_I8)
					continue;
				if (instrs[i + 3].OpCode.Code != Code.Mul)
					continue;
				if (instrs[i + 4].OpCode.Code != Code.Add)
					continue;

				info.key0 = (uint)ldci4.GetLdcI4Value();
				return true;
			}
			return false;
		}

		static bool FindKey0d_v18_r75367(DecrypterInfo info) {
			var instrs = info.method.Body.Instructions;
			for (int i = 0; i < instrs.Count; i++) {
				int index = ConfuserUtils.FindCallMethod(instrs, i, Code.Callvirt, "System.Int32 System.Reflection.MemberInfo::get_MetadataToken()");
				if (index < 0)
					break;
				int index2 = ConfuserUtils.FindCallMethod(instrs, index, Code.Call, "System.Byte[] System.BitConverter::GetBytes(System.Int32)");
				if (index2 < 0)
					break;
				if (index2 - index != 3)
					continue;
				var ldci4 = instrs[index + 1];
				if (!ldci4.IsLdcI4())
					continue;
				if (instrs[index + 2].OpCode.Code != Code.Xor)
					continue;

				info.key0d = (uint)ldci4.GetLdcI4Value();
				return true;
			}
			return false;
		}

		static bool FindLKeys_v18_r75369(DecrypterInfo info) {
			var instrs = info.method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 8; i++) {
				var ldci8_1 = instrs[i];
				if (ldci8_1.OpCode.Code != Code.Ldc_I8)
					continue;
				if (!instrs[i + 1].IsLdloc())
					continue;
				if (instrs[i + 2].OpCode.Code != Code.Conv_U8)
					continue;
				if (instrs[i + 3].OpCode.Code != Code.Mul)
					continue;
				if (!instrs[i + 4].IsStloc())
					continue;
				var ldci8_2 = instrs[i + 5];
				if (ldci8_2.OpCode.Code != Code.Ldc_I8)
					continue;
				if (!instrs[i + 6].IsStloc())
					continue;
				var ldci8_3 = instrs[i + 7];
				if (ldci8_3.OpCode.Code != Code.Ldc_I8)
					continue;
				if (!instrs[i + 8].IsStloc())
					continue;

				info.key0l = (ulong)(long)ldci8_1.Operand;
				info.key1l = (ulong)(long)ldci8_2.Operand;
				info.key2l = (ulong)(long)ldci8_3.Operand;
				return true;
			}
			return false;
		}

		static bool FindKey0_v18_r75369(DecrypterInfo info) {
			var instrs = info.method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 4; i++) {
				if (!instrs[i].IsLdloc())
					continue;
				if (instrs[i + 1].OpCode.Code != Code.Xor)
					continue;
				var ldci4 = instrs[i + 2];
				if (!ldci4.IsLdcI4())
					continue;
				if (instrs[i + 3].OpCode.Code != Code.Conv_U8)
					continue;
				if (instrs[i + 4].OpCode.Code != Code.Mul)
					continue;

				info.key0 = (uint)ldci4.GetLdcI4Value();
				return true;
			}
			return false;
		}

		byte[] Decompress(byte[] compressed) {
			if (lzmaType != null)
				return ConfuserUtils.SevenZipDecompress(compressed);
			return DeobUtils.Inflate(compressed, true);
		}

		byte[] DecryptResource(byte[] encrypted) {
			switch (version) {
			case ConfuserVersion.v18_r75367_normal:
			case ConfuserVersion.v18_r75369_normal:
			case ConfuserVersion.v19_r77172_normal:
			case ConfuserVersion.v19_r78056_normal:
			case ConfuserVersion.v19_r78363_normal:
			case ConfuserVersion.v19_r79630_normal:
				return DecryptResource_v18_r75367_normal(encrypted);

			case ConfuserVersion.v18_r75367_dynamic:
			case ConfuserVersion.v18_r75369_dynamic:
			case ConfuserVersion.v19_r77172_dynamic:
			case ConfuserVersion.v19_r78056_dynamic:
			case ConfuserVersion.v19_r78363_dynamic:
			case ConfuserVersion.v19_r79630_dynamic:
				return DecryptResource_v18_r75367_dynamic(encrypted);

			case ConfuserVersion.v18_r75367_native:
			case ConfuserVersion.v18_r75369_native:
			case ConfuserVersion.v19_r77172_native:
			case ConfuserVersion.v19_r78056_native:
			case ConfuserVersion.v19_r78363_native:
			case ConfuserVersion.v19_r79630_native:
				return DecryptResource_v18_r75367_native(encrypted);

			default:
				throw new ApplicationException("Unknown version");
			}
		}

		byte[] GetSigKey() => module.ReadBlob(key0d ^ installMethod.MDToken.ToUInt32());

		byte[] DecryptResource_v18_r75367_normal(byte[] encrypted) {
			var key = GetSigKey();
			var decrypted = ConfuserUtils.Decrypt(BitConverter.ToUInt32(key, 12) * (uint)key0, encrypted);
			return Decompress(DeobUtils.AesDecrypt(decrypted, key, DeobUtils.Md5Sum(key)));
		}

		static int GetDynamicStartIndex(IList<Instruction> instrs, int ldlocIndex) {
			for (int i = ldlocIndex - 1; i >= 0; i--) {
				if (instrs[i].OpCode.FlowControl != FlowControl.Next)
					return i + 1;
			}
			return 0;
		}

		int GetDynamicEndIndex(int startIndex, Local local) {
			if (startIndex < 0)
				return -1;
			var instrs = installMethod.Body.Instructions;
			for (int i = startIndex; i < instrs.Count; i++) {
				var instr = instrs[i];
				if (instr.IsStloc() && instr.GetLocal(installMethod.Body.Variables) == local)
					return i;
			}
			return -1;
		}

		Local GetDynamicLocal(out int instrIndex) {
			var instrs = installMethod.Body.Instructions;
			for (int i = 0; i < instrs.Count; i++) {
				i = ConfuserUtils.FindCallMethod(instrs, i, Code.Callvirt, "System.Void System.IO.BinaryWriter::Write(System.Byte)");
				if (i < 0)
					break;
				int index = i - 2;
				if (index < 0)
					continue;
				var ldloc = instrs[index];
				if (!ldloc.IsLdloc())
					continue;
				if (instrs[index + 1].OpCode.Code != Code.Conv_U1)
					continue;

				instrIndex = index;
				return ldloc.GetLocal(installMethod.Body.Variables);
			}
			instrIndex = 0;
			return null;
		}

		byte[] DecryptResource_v18_r75367_dynamic(byte[] encrypted) {
			var local = GetDynamicLocal(out int ldlocIndex);
			if (local == null)
				throw new ApplicationException("Could not find local");

			var instrs = installMethod.Body.Instructions;
			int startIndex = GetDynamicStartIndex(instrs, ldlocIndex);
			int endIndex = GetDynamicEndIndex(startIndex, local);
			if (endIndex < 0)
				throw new ApplicationException("Could not find endIndex");

			var constReader = new ConstantsReader(installMethod);

			return DecryptResource(encrypted, magic => {
				constReader.SetConstantInt32(local, magic);
				int index = startIndex;
				if (!constReader.GetNextInt32(ref index, out int result))
					throw new ApplicationException("Could not get constant");
				if (index != endIndex)
					throw new ApplicationException("Wrong constant");
				return (byte)result;
			});
		}

		byte[] DecryptResource_v18_r75367_native(byte[] encrypted) {
			using (var x86Emu = new X86Emulator(fileData))
				return DecryptResource(encrypted, magic => (byte)x86Emu.Emulate((uint)nativeMethod.RVA, magic));
		}

		byte[] DecryptResource(byte[] encrypted, Func<uint, byte> decryptFunc) {
			var key = GetSigKey();

			byte[] decrypted = DecryptAndDecompress(encrypted, key);
			var reader = ByteArrayDataReaderFactory.CreateReader(decrypted);
			var result = new MemoryStream();
			var writer = new BinaryWriter(result);
			while (reader.Position < reader.Length) {
				uint magic = reader.Read7BitEncodedUInt32();
				writer.Write(decryptFunc(magic));
			}

			return result.ToArray();
		}

		byte[] DecryptAndDecompress(byte[] encrypted, byte[] key) {
			byte[] iv = DeobUtils.Md5Sum(key);
			try {
				return Decompress(DeobUtils.AesDecrypt(encrypted, key, iv));
			}
			catch {
				return DeobUtils.AesDecrypt(Decompress(encrypted), key, iv);
			}
		}

		static bool VerifyGenericArg(MethodSpec gim, ElementType etype) {
			if (gim == null)
				return false;
			var gims = gim.GenericInstMethodSig;
			if (gims == null || gims.GenericArguments.Count != 1)
				return false;
			return gims.GenericArguments[0].GetElementType() == etype;
		}

		public string DecryptString(MethodDef method, MethodSpec gim, uint magic1, ulong magic2) {
			if (!VerifyGenericArg(gim, ElementType.String))
				return null;
			var info = decrypters.Find(method);
			return info.DecryptString(magic1, magic2);
		}

		public object DecryptInt32(MethodDef method, MethodSpec gim, uint magic1, ulong magic2) {
			if (!VerifyGenericArg(gim, ElementType.I4))
				return null;
			var info = decrypters.Find(method);
			return info.DecryptInt32(magic1, magic2);
		}

		public object DecryptInt64(MethodDef method, MethodSpec gim, uint magic1, ulong magic2) {
			if (!VerifyGenericArg(gim, ElementType.I8))
				return null;
			var info = decrypters.Find(method);
			return info.DecryptInt64(magic1, magic2);
		}

		public object DecryptSingle(MethodDef method, MethodSpec gim, uint magic1, ulong magic2) {
			if (!VerifyGenericArg(gim, ElementType.R4))
				return null;
			var info = decrypters.Find(method);
			return info.DecryptSingle(magic1, magic2);
		}

		public object DecryptDouble(MethodDef method, MethodSpec gim, uint magic1, ulong magic2) {
			if (!VerifyGenericArg(gim, ElementType.R8))
				return null;
			var info = decrypters.Find(method);
			return info.DecryptDouble(magic1, magic2);
		}

		public void CleanUp() {
			if (installMethod == null)
				return;

			//TODO: Only remove its code
			installMethod.Body.Instructions.Clear();
			installMethod.Body.Instructions.Add(Instruction.Create(OpCodes.Ret));
		}

		public bool GetRevisionRange(out int minRev, out int maxRev) {
			switch (version) {
			case ConfuserVersion.Unknown:
				minRev = maxRev = 0;
				return false;

			case ConfuserVersion.v18_r75367_normal:
			case ConfuserVersion.v18_r75367_dynamic:
			case ConfuserVersion.v18_r75367_native:
				minRev = 75367;
				maxRev = 75367;
				return true;

			case ConfuserVersion.v18_r75369_normal:
			case ConfuserVersion.v18_r75369_dynamic:
			case ConfuserVersion.v18_r75369_native:
				minRev = 75369;
				maxRev = 77124;
				return true;

			case ConfuserVersion.v19_r77172_normal:
			case ConfuserVersion.v19_r77172_dynamic:
			case ConfuserVersion.v19_r77172_native:
				minRev = 77172;
				maxRev = 77501;
				return true;

			case ConfuserVersion.v19_r78056_normal:
			case ConfuserVersion.v19_r78056_dynamic:
			case ConfuserVersion.v19_r78056_native:
				minRev = 78056;
				// r78964 removed code that made it impossible to differentiate it from this
				// version. All we know is that it can't be r78363-r78963.
				maxRev = 79440;
				return true;

			case ConfuserVersion.v19_r78363_normal:
			case ConfuserVersion.v19_r78363_dynamic:
			case ConfuserVersion.v19_r78363_native:
				minRev = 78363;
				maxRev = 78963;
				return true;

			case ConfuserVersion.v19_r79630_normal:
			case ConfuserVersion.v19_r79630_dynamic:
			case ConfuserVersion.v19_r79630_native:
				minRev = 79630;
				maxRev = int.MaxValue;
				return true;

			default: throw new ApplicationException("Invalid version");
			}
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Confuser/ConstantsFolder.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet.Emit;
using de4dot.blocks;
using de4dot.blocks.cflow;

namespace de4dot.code.deobfuscators.Confuser {
	class ConstantsFolder : BlockDeobfuscator {
		protected override bool Deobfuscate(Block block) {
			bool modified = false;

			var instrs = block.Instructions;
			var constantsReader = CreateConstantsReader(instrs);
			for (int i = 0; i < instrs.Count; i++) {
				int index = 0;
				Instruction newInstr = null;
				var instr = instrs[i];
				if (constantsReader.IsLoadConstantInt32(instr.Instruction)) {
					index = i;
					if (!constantsReader.GetInt32(ref index, out int val))
						continue;
					newInstr = Instruction.CreateLdcI4(val);
				}
				else if (constantsReader.IsLoadConstantInt64(instr.Instruction)) {
					index = i;
					if (!constantsReader.GetInt64(ref index, out long val))
						continue;
					newInstr = Instruction.Create(OpCodes.Ldc_I8, val);
				}
				else if (constantsReader.IsLoadConstantDouble(instr.Instruction)) {
					index = i;
					if (!constantsReader.GetDouble(ref index, out double val))
						continue;
					newInstr = Instruction.Create(OpCodes.Ldc_R8, val);
				}

				if (newInstr != null && index - i > 1) {
					block.Insert(index++, Instruction.Create(OpCodes.Pop));
					block.Insert(index++, newInstr);
					i = index - 1;
					constantsReader = CreateConstantsReader(instrs);
					modified = true;
					continue;
				}

				// Convert ldc.r4/r8 followed by conv to the appropriate ldc.i4/i8 instr
				if (i + 1 < instrs.Count && (instr.OpCode.Code == Code.Ldc_R4 || instr.OpCode.Code == Code.Ldc_R8)) {
					var conv = instrs[i + 1];
					/*int vali32 = instr.OpCode.Code == Code.Ldc_R4 ? (int)(float)instr.Operand : (int)(double)instr.Operand;
					long vali64 = instr.OpCode.Code == Code.Ldc_R4 ? (long)(float)instr.Operand : (long)(double)instr.Operand;
					uint valu32 = instr.OpCode.Code == Code.Ldc_R4 ? (uint)(float)instr.Operand : (uint)(double)instr.Operand;
					ulong valu64 = instr.OpCode.Code == Code.Ldc_R4 ? (ulong)(float)instr.Operand : (ulong)(double)instr.Operand;*/
					switch (conv.OpCode.Code) {
					case Code.Conv_I1:
						newInstr = Instruction.CreateLdcI4(instr.OpCode.Code == Code.Ldc_R4 ? (sbyte)(float)instr.Operand : (sbyte)(double)instr.Operand);
						break;
					case Code.Conv_U1:
						newInstr = Instruction.CreateLdcI4(instr.OpCode.Code == Code.Ldc_R4 ? (byte)(float)instr.Operand : (byte)(double)instr.Operand);
						break;
					case Code.Conv_I2:
						newInstr = Instruction.CreateLdcI4(instr.OpCode.Code == Code.Ldc_R4 ? (short)(float)instr.Operand : (short)(double)instr.Operand);
						break;
					case Code.Conv_U2:
						newInstr = Instruction.CreateLdcI4(instr.OpCode.Code == Code.Ldc_R4 ? (ushort)(float)instr.Operand : (ushort)(double)instr.Operand);
						break;
					case Code.Conv_I4:
						newInstr = Instruction.CreateLdcI4(instr.OpCode.Code == Code.Ldc_R4 ? (int)(float)instr.Operand : (int)(double)instr.Operand);
						break;
					case Code.Conv_U4:
						newInstr = Instruction.CreateLdcI4(instr.OpCode.Code == Code.Ldc_R4 ? (int)(uint)(float)instr.Operand : (int)(uint)(double)instr.Operand);
						break;
					case Code.Conv_I8:
						newInstr = Instruction.Create(OpCodes.Ldc_I8, instr.OpCode.Code == Code.Ldc_R4 ? (long)(float)instr.Operand : (long)(double)instr.Operand);
						break;
					case Code.Conv_U8:
						newInstr = Instruction.Create(OpCodes.Ldc_I8, instr.OpCode.Code == Code.Ldc_R4 ? (ulong)(float)instr.Operand : (ulong)(double)instr.Operand);
						break;
					default:
						newInstr = null;
						break;
					}
					if (newInstr != null) {
						block.Replace(i, 2, newInstr);
						constantsReader = CreateConstantsReader(instrs);
						modified = true;
						continue;
					}
				}
			}

			return modified;
		}

		static ConstantsReader CreateConstantsReader(IList<Instr> instrs) => new ConstantsReader(instrs, false);
	}
}



================================================
File: de4dot.code/deobfuscators/Confuser/ConstantsInliner.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using de4dot.blocks;
using de4dot.blocks.cflow;

namespace de4dot.code.deobfuscators.Confuser {
	class ConstantsInliner : IBlocksDeobfuscator {
		Blocks blocks;
		Int32ValueInliner int32ValueInliner;
		Int64ValueInliner int64ValueInliner;
		SingleValueInliner singleValueInliner;
		DoubleValueInliner doubleValueInliner;

		public bool ExecuteIfNotModified { get; set; }

		public ConstantsInliner(Int32ValueInliner int32ValueInliner, Int64ValueInliner int64ValueInliner, SingleValueInliner singleValueInliner, DoubleValueInliner doubleValueInliner) {
			this.int32ValueInliner = int32ValueInliner;
			this.int64ValueInliner = int64ValueInliner;
			this.singleValueInliner = singleValueInliner;
			this.doubleValueInliner = doubleValueInliner;
		}

		public void DeobfuscateBegin(Blocks blocks) => this.blocks = blocks;

		public bool Deobfuscate(List<Block> allBlocks) {
			bool modified = false;
			foreach (var block in allBlocks) {
				modified |= int32ValueInliner.Decrypt(blocks.Method, allBlocks) != 0;
				modified |= int64ValueInliner.Decrypt(blocks.Method, allBlocks) != 0;
				modified |= singleValueInliner.Decrypt(blocks.Method, allBlocks) != 0;
				modified |= doubleValueInliner.Decrypt(blocks.Method, allBlocks) != 0;
			}
			return modified;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Confuser/Deobfuscator.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet;
using de4dot.blocks;
using de4dot.blocks.cflow;

namespace de4dot.code.deobfuscators.Confuser {
	public class DeobfuscatorInfo : DeobfuscatorInfoBase {
		public const string THE_NAME = "Confuser";
		public const string THE_TYPE = "cr";
		const string DEFAULT_REGEX = DeobfuscatorBase.DEFAULT_VALID_NAME_REGEX;
		BoolOption removeAntiDebug;
		BoolOption removeAntiDump;
		BoolOption decryptMainAsm;

		public DeobfuscatorInfo()
			: base(DEFAULT_REGEX) {
			removeAntiDebug = new BoolOption(null, MakeArgName("antidb"), "Remove anti debug code", true);
			removeAntiDump = new BoolOption(null, MakeArgName("antidump"), "Remove anti dump code", true);
			decryptMainAsm = new BoolOption(null, MakeArgName("decrypt-main"), "Decrypt main embedded assembly", true);
		}

		public override string Name => THE_NAME;
		public override string Type => THE_TYPE;

		public override IDeobfuscator CreateDeobfuscator() =>
			new Deobfuscator(new Deobfuscator.Options {
				ValidNameRegex = validNameRegex.Get(),
				RemoveAntiDebug = removeAntiDebug.Get(),
				RemoveAntiDump = removeAntiDump.Get(),
				DecryptMainAsm = decryptMainAsm.Get(),
			});

		protected override IEnumerable<Option> GetOptionsInternal() =>
			new List<Option>() {
				removeAntiDebug,
				removeAntiDump,
				decryptMainAsm,
			};
	}

	class Deobfuscator : DeobfuscatorBase, IStringDecrypter {
		Options options;
		string obfuscatorName = DeobfuscatorInfo.THE_NAME;
		Version approxVersion;

		List<EmbeddedAssemblyInfo> embeddedAssemblyInfos = new List<EmbeddedAssemblyInfo>();
		JitMethodsDecrypter jitMethodsDecrypter;
		MemoryMethodsDecrypter memoryMethodsDecrypter;
		ProxyCallFixer proxyCallFixer;
		AntiDebugger antiDebugger;
		AntiDumping antiDumping;
		ResourceDecrypter resourceDecrypter;
		ConstantsDecrypterV18 constantsDecrypterV18;
		ConstantsDecrypterV17 constantsDecrypterV17;
		ConstantsDecrypterV15 constantsDecrypterV15;
		Int32ValueInliner int32ValueInliner;
		Int64ValueInliner int64ValueInliner;
		SingleValueInliner singleValueInliner;
		DoubleValueInliner doubleValueInliner;
		StringDecrypter stringDecrypter;
		Unpacker unpacker;
		EmbeddedAssemblyInfo mainAsmInfo;
		RealAssemblyInfo realAssemblyInfo;

		bool startedDeobfuscating = false;

		internal class Options : OptionsBase {
			public bool RemoveAntiDebug { get; set; }
			public bool RemoveAntiDump { get; set; }
			public bool DecryptMainAsm { get; set; }
		}

		public override string Type => DeobfuscatorInfo.THE_TYPE;
		public override string TypeLong => DeobfuscatorInfo.THE_NAME;
		public override string Name => obfuscatorName;

		public override IEnumerable<IBlocksDeobfuscator> BlocksDeobfuscators {
			get {
				var list = new List<IBlocksDeobfuscator>();
				list.Add(new ConstantsFolder { ExecuteIfNotModified = true });

				// Add this one last so all cflow is deobfuscated whenever it executes
				if (!startedDeobfuscating && int32ValueInliner != null)
					list.Add(new ConstantsInliner(int32ValueInliner, int64ValueInliner, singleValueInliner, doubleValueInliner) { ExecuteIfNotModified = true });

				return list;
			}
		}

		public Deobfuscator(Options options)
			: base(options) {
			this.options = options;
			StringFeatures = StringFeatures.AllowStaticDecryption | StringFeatures.AllowDynamicDecryption;
		}

		protected override int DetectInternal() {
			int val = 0;

			int sum = ToInt32(jitMethodsDecrypter != null ? jitMethodsDecrypter.Detected : false) +
					ToInt32(memoryMethodsDecrypter != null ? memoryMethodsDecrypter.Detected : false) +
					ToInt32(proxyCallFixer != null ? proxyCallFixer.Detected : false) +
					ToInt32(antiDebugger != null ? antiDebugger.Detected : false) +
					ToInt32(antiDumping != null ? antiDumping.Detected : false) +
					ToInt32(resourceDecrypter != null ? resourceDecrypter.Detected : false) +
					ToInt32(constantsDecrypterV18 != null ? constantsDecrypterV18.Detected : false) +
					ToInt32(constantsDecrypterV15 != null ? constantsDecrypterV15.Detected : false) +
					ToInt32(constantsDecrypterV17 != null ? constantsDecrypterV17.Detected : false) +
					ToInt32(stringDecrypter != null ? stringDecrypter.Detected : false) +
					ToInt32(unpacker != null ? unpacker.Detected : false);
			if (sum > 0)
				val += 100 + 10 * (sum - 1);

			return val;
		}

		protected override void ScanForObfuscator() {
			RemoveObfuscatorAttribute();
			jitMethodsDecrypter = new JitMethodsDecrypter(module, DeobfuscatedFile);
			try {
				jitMethodsDecrypter.Find();
			}
			catch {
			}
			if (jitMethodsDecrypter.Detected) {
				InitializeObfuscatorName();
				return;
			}
			memoryMethodsDecrypter = new MemoryMethodsDecrypter(module, DeobfuscatedFile);
			memoryMethodsDecrypter.Find();
			if (memoryMethodsDecrypter.Detected) {
				InitializeObfuscatorName();
				return;
			}
			InitializeTheRest(null);
		}

		void InitializeTheRest(Deobfuscator oldOne) {
			resourceDecrypter = new ResourceDecrypter(module, DeobfuscatedFile);
			resourceDecrypter.Find();

			constantsDecrypterV18 = new ConstantsDecrypterV18(module, GetFileData(), DeobfuscatedFile);
			constantsDecrypterV17 = new ConstantsDecrypterV17(module, GetFileData(), DeobfuscatedFile);
			constantsDecrypterV15 = new ConstantsDecrypterV15(module, GetFileData(), DeobfuscatedFile);
			do {
				constantsDecrypterV18.Find();
				if (constantsDecrypterV18.Detected) {
					InitializeConstantsDecrypterV18();
					break;
				}
				constantsDecrypterV17.Find();
				if (constantsDecrypterV17.Detected) {
					InitializeConstantsDecrypterV17();
					break;
				}
				constantsDecrypterV15.Find();
				if (constantsDecrypterV15.Detected) {
					InitializeConstantsDecrypterV15();
					break;
				}
			} while (false);

			proxyCallFixer = new ProxyCallFixer(module, GetFileData());
			proxyCallFixer.FindDelegateCreator(DeobfuscatedFile);
			antiDebugger = new AntiDebugger(module);
			antiDebugger.Find();
			antiDumping = new AntiDumping(module);
			antiDumping.Find(DeobfuscatedFile);
			stringDecrypter = new StringDecrypter(module);
			stringDecrypter.Find(DeobfuscatedFile);
			InitializeStringDecrypter();
			unpacker = new Unpacker(module, oldOne?.unpacker);
			unpacker.Find(DeobfuscatedFile, this);
			InitializeObfuscatorName();
		}

		void InitializeObfuscatorName() {
			var versionString = GetVersionString();
			if (string.IsNullOrEmpty(versionString))
				obfuscatorName = DeobfuscatorInfo.THE_NAME;
			else
				obfuscatorName = $"{DeobfuscatorInfo.THE_NAME} {versionString}";
		}

		const bool useAttributeVersion = true;
		string GetVersionString() {
			var versionProviders = new IVersionProvider[] {
				jitMethodsDecrypter,
				memoryMethodsDecrypter,
				proxyCallFixer,
				antiDebugger,
				antiDumping,
				resourceDecrypter,
				constantsDecrypterV18,
				constantsDecrypterV17,
				constantsDecrypterV15,
				stringDecrypter,
				unpacker,
			};

			var vd = new VersionDetector();
			foreach (var versionProvider in versionProviders) {
				if (versionProvider == null)
					continue;
				if (versionProvider.GetRevisionRange(out int minRev, out int maxRev)) {
					if (maxRev == int.MaxValue)
						Logger.v("r{0}-latest : {1}", minRev, versionProvider.GetType().Name);
					else
						Logger.v("r{0}-r{1} : {2}", minRev, maxRev, versionProvider.GetType().Name);
					vd.AddRevs(minRev, maxRev);
				}
			}
			if (useAttributeVersion)
				vd.SetVersion(approxVersion);
			return vd.GetVersionString();
		}

		byte[] GetFileData() {
			if (ModuleBytes != null)
				return ModuleBytes;
			return ModuleBytes = DeobUtils.ReadModule(module);
		}

		[Flags]
		enum DecryptState {
			CanDecryptMethods = 1,
			CanUnpack = 2,
		}
		DecryptState decryptState = DecryptState.CanDecryptMethods | DecryptState.CanUnpack;
		bool hasUnpacked = false;
		public override bool GetDecryptedModule(int count, ref byte[] newFileData, ref DumpedMethods dumpedMethods) {
			hasUnpacked = false;
			byte[] fileData = GetFileData();

			using (var peImage = new MyPEImage(fileData)) {
				if ((decryptState & DecryptState.CanDecryptMethods) != 0) {
					bool decrypted = false;
					if (jitMethodsDecrypter != null && jitMethodsDecrypter.Detected) {
						jitMethodsDecrypter.Initialize();
						if (!jitMethodsDecrypter.Decrypt(peImage, fileData, ref dumpedMethods))
							return false;
						decrypted = true;
					}
					else if (memoryMethodsDecrypter != null && memoryMethodsDecrypter.Detected) {
						memoryMethodsDecrypter.Initialize();
						if (!memoryMethodsDecrypter.Decrypt(peImage, fileData))
							return false;
						decrypted = true;
					}

					if (decrypted) {
						decryptState &= ~DecryptState.CanDecryptMethods;
						decryptState |= DecryptState.CanUnpack;
						newFileData = fileData;
						ModuleBytes = newFileData;
						return true;
					}
				}
			}

			if ((decryptState & DecryptState.CanUnpack) != 0) {
				if (unpacker != null && unpacker.Detected) {
					if (options.DecryptMainAsm) {
						decryptState |= DecryptState.CanDecryptMethods | DecryptState.CanUnpack;
						var mainInfo = unpacker.UnpackMainAssembly(true);
						newFileData = mainInfo.data;
						realAssemblyInfo = mainInfo.realAssemblyInfo;
						embeddedAssemblyInfos.AddRange(unpacker.GetEmbeddedAssemblyInfos());
						ModuleBytes = newFileData;
						hasUnpacked = true;
						return true;
					}
					else {
						decryptState &= ~DecryptState.CanUnpack;
						mainAsmInfo = unpacker.UnpackMainAssembly(false);
						embeddedAssemblyInfos.AddRange(unpacker.GetEmbeddedAssemblyInfos());
						return false;
					}
				}
			}

			return false;
		}

		public override IDeobfuscator ModuleReloaded(ModuleDefMD module) {
			if (module.Assembly != null)
				realAssemblyInfo = null;
			if (realAssemblyInfo != null) {
				realAssemblyInfo.realAssembly.Modules.Insert(0, module);
				if (realAssemblyInfo.entryPointToken != 0)
					module.EntryPoint = module.ResolveToken((int)realAssemblyInfo.entryPointToken) as MethodDef;
				module.Kind = realAssemblyInfo.kind;
				module.Name = new UTF8String(realAssemblyInfo.moduleName);
			}

			var newOne = new Deobfuscator(options);
			DeobfuscatedFile.SetDeobfuscator(newOne);
			newOne.realAssemblyInfo = realAssemblyInfo;
			newOne.decryptState = decryptState;
			newOne.DeobfuscatedFile = DeobfuscatedFile;
			newOne.ModuleBytes = ModuleBytes;
			newOne.embeddedAssemblyInfos.AddRange(embeddedAssemblyInfos);
			newOne.SetModule(module);
			newOne.RemoveObfuscatorAttribute();
			newOne.jitMethodsDecrypter = hasUnpacked ? new JitMethodsDecrypter(module, DeobfuscatedFile) :
						new JitMethodsDecrypter(module, DeobfuscatedFile, jitMethodsDecrypter);
			if ((newOne.decryptState & DecryptState.CanDecryptMethods) != 0) {
				try {
					newOne.jitMethodsDecrypter.Find();
				}
				catch {
				}
				if (newOne.jitMethodsDecrypter.Detected)
					return newOne;
			}
			newOne.memoryMethodsDecrypter = hasUnpacked ? new MemoryMethodsDecrypter(module, DeobfuscatedFile) :
						new MemoryMethodsDecrypter(module, DeobfuscatedFile, memoryMethodsDecrypter);
			if ((newOne.decryptState & DecryptState.CanDecryptMethods) != 0) {
				newOne.memoryMethodsDecrypter.Find();
				if (newOne.memoryMethodsDecrypter.Detected)
					return newOne;
			}
			newOne.InitializeTheRest(this);
			return newOne;
		}

		public override void DeobfuscateBegin() {
			base.DeobfuscateBegin();

			Logger.v("Detected {0}", obfuscatorName);

			InitializeConstantsDecrypterV18();
			InitializeConstantsDecrypterV17();
			InitializeConstantsDecrypterV15();
			InitializeStringDecrypter();

			if (jitMethodsDecrypter != null) {
				AddModuleCctorInitCallToBeRemoved(jitMethodsDecrypter.InitMethod);
				AddTypeToBeRemoved(jitMethodsDecrypter.Type, "Methods decrypter (JIT) type");
			}

			if (memoryMethodsDecrypter != null) {
				AddModuleCctorInitCallToBeRemoved(memoryMethodsDecrypter.InitMethod);
				AddTypeToBeRemoved(memoryMethodsDecrypter.Type, "Methods decrypter (memory) type");
			}

			if (options.RemoveAntiDebug && antiDebugger != null) {
				AddModuleCctorInitCallToBeRemoved(antiDebugger.InitMethod);
				AddTypeToBeRemoved(antiDebugger.Type, "Anti debugger type");
				if (antiDebugger.Type == DotNetUtils.GetModuleType(module))
					AddMethodToBeRemoved(antiDebugger.InitMethod, "Anti debugger method");
			}

			if (options.RemoveAntiDump && antiDumping != null) {
				AddModuleCctorInitCallToBeRemoved(antiDumping.InitMethod);
				AddTypeToBeRemoved(antiDumping.Type, "Anti dumping type");
			}

			if (proxyCallFixer != null)
				proxyCallFixer.Find();

			RemoveInvalidResources();
			DumpEmbeddedAssemblies();

			startedDeobfuscating = true;
		}

		void DumpEmbeddedAssemblies() {
			if (mainAsmInfo != null) {
				var asm = module.Assembly;
				var name = (asm == null ? module.Name : asm.Name).String;
				DeobfuscatedFile.CreateAssemblyFile(mainAsmInfo.data, name + "_real", mainAsmInfo.extension);
				AddResourceToBeRemoved(mainAsmInfo.resource, $"Embedded assembly: {mainAsmInfo.asmFullName}");
			}
			foreach (var info in embeddedAssemblyInfos) {
				if (module.Assembly == null || info.asmFullName != module.Assembly.FullName)
					DeobfuscatedFile.CreateAssemblyFile(info.data, info.asmSimpleName, info.extension);
				AddResourceToBeRemoved(info.resource, $"Embedded assembly: {info.asmFullName}");
			}
			embeddedAssemblyInfos.Clear();
		}

		void RemoveInvalidResources() {
			foreach (var rsrc in module.Resources) {
				var resource = rsrc as EmbeddedResource;
				if (resource == null)
					continue;
				if (resource.Offset != 0xFFFFFFFF)
					continue;
				AddResourceToBeRemoved(resource, "Invalid resource");
			}
		}

		bool hasInitializedStringDecrypter = false;
		void InitializeStringDecrypter() {
			if (hasInitializedStringDecrypter || (stringDecrypter== null || !stringDecrypter.Detected))
				return;
			hasInitializedStringDecrypter = true;

			DecryptResources();
			stringDecrypter.Initialize();
			staticStringInliner.Add(stringDecrypter.Method, (method, gim, args) => stringDecrypter.Decrypt(staticStringInliner.Method, (int)args[0]));
			DeobfuscatedFile.StringDecryptersAdded();
		}

		bool hasInitializedConstantsDecrypter = false;
		void InitializeConstantsDecrypterV18() {
			if (hasInitializedConstantsDecrypter || (constantsDecrypterV18 == null || !constantsDecrypterV18.Detected))
				return;
			hasInitializedConstantsDecrypter = true;

			DecryptResources();
			constantsDecrypterV18.Initialize();
			int32ValueInliner = new Int32ValueInliner();
			int64ValueInliner = new Int64ValueInliner();
			singleValueInliner = new SingleValueInliner();
			doubleValueInliner = new DoubleValueInliner();
			foreach (var info in constantsDecrypterV18.Decrypters) {
				staticStringInliner.Add(info.method, (method, gim, args) => constantsDecrypterV18.DecryptString(method, gim, (uint)args[0], (ulong)args[1]));
				int32ValueInliner.Add(info.method, (method, gim, args) => constantsDecrypterV18.DecryptInt32(method, gim, (uint)args[0], (ulong)args[1]));
				int64ValueInliner.Add(info.method, (method, gim, args) => constantsDecrypterV18.DecryptInt64(method, gim, (uint)args[0], (ulong)args[1]));
				singleValueInliner.Add(info.method, (method, gim, args) => constantsDecrypterV18.DecryptSingle(method, gim, (uint)args[0], (ulong)args[1]));
				doubleValueInliner.Add(info.method, (method, gim, args) => constantsDecrypterV18.DecryptDouble(method, gim, (uint)args[0], (ulong)args[1]));
			}
			DeobfuscatedFile.StringDecryptersAdded();
			AddTypesToBeRemoved(constantsDecrypterV18.Types, "Constants decrypter type");
			AddFieldsToBeRemoved(constantsDecrypterV18.Fields, "Constants decrypter field");
			AddMethodToBeRemoved(constantsDecrypterV18.NativeMethod, "Constants decrypter native method");
			AddTypeToBeRemoved(constantsDecrypterV18.LzmaType, "LZMA type");
			AddResourceToBeRemoved(constantsDecrypterV18.Resource, "Encrypted constants");
		}

		bool hasInitializedConstantsDecrypter15 = false;
		void InitializeConstantsDecrypterV15() => Initialize(constantsDecrypterV15, ref hasInitializedConstantsDecrypter15);

		bool hasInitializedConstantsDecrypter17 = false;
		void InitializeConstantsDecrypterV17() => Initialize(constantsDecrypterV17, ref hasInitializedConstantsDecrypter17);

		void Initialize(ConstantsDecrypterBase constDecrypter, ref bool hasInitialized) {
			if (hasInitialized || (constDecrypter == null || !constDecrypter.Detected))
				return;
			hasInitializedConstantsDecrypter15 = true;

			DecryptResources();
			constDecrypter.Initialize();
			int32ValueInliner = new Int32ValueInliner();
			int64ValueInliner = new Int64ValueInliner();
			singleValueInliner = new SingleValueInliner();
			doubleValueInliner = new DoubleValueInliner();
			foreach (var info in constDecrypter.DecrypterInfos) {
				staticStringInliner.Add(info.decryptMethod, (method, gim, args) => constDecrypter.DecryptString(staticStringInliner.Method, method, args));
				int32ValueInliner.Add(info.decryptMethod, (method, gim, args) => constDecrypter.DecryptInt32(int32ValueInliner.Method, method, args));
				int64ValueInliner.Add(info.decryptMethod, (method, gim, args) => constDecrypter.DecryptInt64(int64ValueInliner.Method, method, args));
				singleValueInliner.Add(info.decryptMethod, (method, gim, args) => constDecrypter.DecryptSingle(singleValueInliner.Method, method, args));
				doubleValueInliner.Add(info.decryptMethod, (method, gim, args) => constDecrypter.DecryptDouble(doubleValueInliner.Method, method, args));
			}
			int32ValueInliner.RemoveUnbox = true;
			int64ValueInliner.RemoveUnbox = true;
			singleValueInliner.RemoveUnbox = true;
			doubleValueInliner.RemoveUnbox = true;
			DeobfuscatedFile.StringDecryptersAdded();
			AddFieldsToBeRemoved(constDecrypter.Fields, "Constants decrypter field");
			var moduleType = DotNetUtils.GetModuleType(module);
			foreach (var info in constDecrypter.DecrypterInfos) {
				if (info.decryptMethod.DeclaringType == moduleType)
					AddMethodToBeRemoved(info.decryptMethod, "Constants decrypter method");
				else
					AddTypeToBeRemoved(info.decryptMethod.DeclaringType, "Constants decrypter type");
			}
			AddMethodToBeRemoved(constDecrypter.NativeMethod, "Constants decrypter native method");
			AddResourceToBeRemoved(constDecrypter.Resource, "Encrypted constants");
		}

		void DecryptResources() {
			var rsrc = resourceDecrypter.MergeResources();
			if (rsrc == null)
				return;
			AddResourceToBeRemoved(rsrc, "Encrypted resources");
			AddMethodToBeRemoved(resourceDecrypter.Handler, "Resource decrypter handler");
			AddFieldsToBeRemoved(resourceDecrypter.Fields, "Resource decrypter field");
			AddTypeToBeRemoved(resourceDecrypter.LzmaType, "LZMA type");
		}

		void RemoveObfuscatorAttribute() {
			foreach (var type in module.Types) {
				if (type.FullName == "ConfusedByAttribute") {
					SetConfuserVersion(type);
					AddAttributeToBeRemoved(type, "Obfuscator attribute");
					break;
				}
			}
		}

		void SetConfuserVersion(TypeDef type) {
			var s = DotNetUtils.GetCustomArgAsString(GetModuleAttribute(type) ?? GetAssemblyAttribute(type), 0);
			if (s == null)
				return;
			var val = System.Text.RegularExpressions.Regex.Match(s, @"^Confuser v(\d+)\.(\d+)\.(\d+)\.(\d+)$");
			if (val.Groups.Count < 5)
				return;
			approxVersion = new Version(int.Parse(val.Groups[1].ToString()),
										int.Parse(val.Groups[2].ToString()),
										int.Parse(val.Groups[3].ToString()),
										int.Parse(val.Groups[4].ToString()));
		}

		public override void DeobfuscateMethodEnd(Blocks blocks) {
			if (proxyCallFixer != null)
				proxyCallFixer.Deobfuscate(blocks);
			resourceDecrypter.Deobfuscate(blocks);
			unpacker.Deobfuscate(blocks);
			if (int32ValueInliner != null) {
				int32ValueInliner.Decrypt(blocks);
				int64ValueInliner.Decrypt(blocks);
				singleValueInliner.Decrypt(blocks);
				doubleValueInliner.Decrypt(blocks);
			}
			base.DeobfuscateMethodEnd(blocks);
		}

		public override void DeobfuscateEnd() {
			if (proxyCallFixer != null) {
				if (RemoveProxyDelegates(proxyCallFixer))
					AddFieldsToBeRemoved(proxyCallFixer.Fields, "Proxy delegate instance field");
				proxyCallFixer.CleanUp();
			}
			if (constantsDecrypterV18 != null)
				constantsDecrypterV18.CleanUp();

			if (CanRemoveStringDecrypterType) {
				if (stringDecrypter != null) {
					AddMethodToBeRemoved(stringDecrypter.Method, "String decrypter method");
					AddResourceToBeRemoved(stringDecrypter.Resource, "Encrypted strings");
				}
			}

			module.IsILOnly = true;

			base.DeobfuscateEnd();
		}

		public override IEnumerable<int> GetStringDecrypterMethods() {
			var list = new List<int>();
			if (stringDecrypter != null && stringDecrypter.Method != null)
				list.Add(stringDecrypter.Method.MDToken.ToInt32());
			if (constantsDecrypterV15 != null) {
				foreach (var info in constantsDecrypterV15.DecrypterInfos)
					list.Add(info.decryptMethod.MDToken.ToInt32());
			}
			if (constantsDecrypterV17 != null) {
				foreach (var info in constantsDecrypterV17.DecrypterInfos)
					list.Add(info.decryptMethod.MDToken.ToInt32());
			}
			if (constantsDecrypterV18 != null) {
				foreach (var info in constantsDecrypterV18.Decrypters)
					list.Add(info.method.MDToken.ToInt32());
			}
			return list;
		}

		string IStringDecrypter.ReadUserString(uint token) {
			if (jitMethodsDecrypter == null)
				return null;
			return ((IStringDecrypter)jitMethodsDecrypter).ReadUserString(token);
		}

		protected override void Dispose(bool disposing) {
			if (disposing) {
				if (proxyCallFixer != null)
					proxyCallFixer.Dispose();
				proxyCallFixer = null;
			}
			base.Dispose(disposing);
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Confuser/IVersionProvider.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

namespace de4dot.code.deobfuscators.Confuser {
	interface IVersionProvider {
		bool GetRevisionRange(out int minRev, out int maxRev);
	}
}



================================================
File: de4dot.code/deobfuscators/Confuser/JitMethodsDecrypter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using dnlib.IO;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Confuser {
	class JitMethodsDecrypter : MethodsDecrypterBase, IStringDecrypter {
		MethodDef compileMethod;
		MethodDef hookConstructStr;
		MethodDataIndexes methodDataIndexes;
		ConfuserVersion version = ConfuserVersion.Unknown;

		enum ConfuserVersion {
			Unknown,
			v17_r73404,
			v17_r73430,
			v17_r73477,
			v17_r73479,
			v17_r74021,
			v18_r75257,
			v18_r75288,
			v18_r75291,
			v18_r75402,
			v19_r75725,
		}

		struct MethodDataIndexes {
			public int codeSize;
			public int maxStack;
			public int ehs;
			public int localVarSigTok;
			public int options;
		}

		public JitMethodsDecrypter(ModuleDefMD module, ISimpleDeobfuscator simpleDeobfuscator)
			: base(module, simpleDeobfuscator) {
		}

		public JitMethodsDecrypter(ModuleDefMD module, ISimpleDeobfuscator simpleDeobfuscator, JitMethodsDecrypter other)
			: base(module, simpleDeobfuscator, other) {
			if (other != null)
				version = other.version;
		}

		protected override bool CheckType(TypeDef type, MethodDef initMethod) {
			if (type == null)
				return false;

			compileMethod = FindCompileMethod(type);
			if (compileMethod == null)
				return false;

			decryptMethod = FindDecryptMethod(type);
			if (decryptMethod == null)
				return false;

			var theVersion = ConfuserVersion.Unknown;
			switch (type.NestedTypes.Count) {
			case 35:
				if (type.Fields.Count == 9)
					theVersion = ConfuserVersion.v17_r73404;
				else if (type.Fields.Count == 10)
					theVersion = ConfuserVersion.v17_r73430;
				else
					return false;
				break;

			case 38:
				switch (CountInt32s(compileMethod, 0xFF)) {
				case 2: theVersion = ConfuserVersion.v17_r73477; break;
				case 4: theVersion = ConfuserVersion.v17_r73479; break;
				default: return false;
				}
				break;

			case 39:
				if (!DotNetUtils.CallsMethod(initMethod, "System.Void System.Console::WriteLine(System.Char)")) {
					if (DotNetUtils.CallsMethod(decryptMethod, "System.Security.Cryptography.Rijndael System.Security.Cryptography.Rijndael::Create()"))
						theVersion = ConfuserVersion.v17_r74021;
					else
						theVersion = ConfuserVersion.v18_r75291;
				}
				else if (DotNetUtils.CallsMethod(decryptMethod, "System.Security.Cryptography.Rijndael System.Security.Cryptography.Rijndael::Create()"))
					theVersion = ConfuserVersion.v18_r75257;
				else
					theVersion = ConfuserVersion.v18_r75288;
				break;

			case 27:
				if (DotNetUtils.CallsMethod(initMethod, "System.Int32 System.String::get_Length()"))
					theVersion = ConfuserVersion.v18_r75402;
				else
					theVersion = ConfuserVersion.v19_r75725;
				break;

			default:
				return false;
			}

			if (theVersion >= ConfuserVersion.v17_r73477) {
				hookConstructStr = FindHookConstructStr(type);
				if (hookConstructStr == null)
					return false;
			}

			version = theVersion;
			return true;
		}

		static int CountInt32s(MethodDef method, int val) {
			int count = 0;
			foreach (var instr in method.Body.Instructions) {
				if (!instr.IsLdcI4())
					continue;
				if (instr.GetLdcI4Value() == val)
					count++;
			}
			return count;
		}

		static MethodDef FindCompileMethod(TypeDef type) {
			foreach (var method in type.Methods) {
				if (!method.IsStatic || method.Body == null)
					continue;
				var sig = method.MethodSig;
				if (sig == null || sig.Params.Count != 6)
					continue;
				if (sig.RetType.GetElementType() != ElementType.U4)
					continue;
				if (sig.Params[0].GetElementType() != ElementType.I)
					continue;
				if (sig.Params[3].GetElementType() != ElementType.U4)
					continue;
				if (sig.Params[4].GetFullName() != "System.Byte**")
					continue;
				if (sig.Params[5].GetFullName() != "System.UInt32*")
					continue;

				return method;
			}
			return null;
		}

		static MethodDef FindHookConstructStr(TypeDef type) {
			foreach (var nested in type.NestedTypes) {
				if (nested.Fields.Count != 8 && nested.Fields.Count != 10)
					continue;
				foreach (var method in nested.Methods) {
					if (method.IsStatic || method.Body == null)
						continue;
					var sig = method.MethodSig;
					if (sig == null || sig.Params.Count != 4)
						continue;
					if (sig.Params[0].GetElementType() != ElementType.I)
						continue;
					if (sig.Params[1].GetElementType() != ElementType.I)
						continue;
					if (sig.Params[2].GetElementType() != ElementType.U4)
						continue;
					if (sig.Params[3].GetElementType() != ElementType.I && sig.Params[3].GetFullName() != "System.IntPtr&")
						continue;

					return method;
				}
			}
			return null;
		}

		public void Initialize() {
			if (initMethod == null)
				return;
			if (!InitializeKeys())
				throw new ApplicationException("Could not find all decryption keys");
			if (!InitializeMethodDataIndexes(compileMethod))
				throw new ApplicationException("Could not find MethodData indexes");
		}

		bool InitializeKeys() {
			switch (version) {
			case ConfuserVersion.v17_r73404: return InitializeKeys_v17_r73404();
			case ConfuserVersion.v17_r73430: return InitializeKeys_v17_r73404();
			case ConfuserVersion.v17_r73477: return InitializeKeys_v17_r73404();
			case ConfuserVersion.v17_r73479: return InitializeKeys_v17_r73404();
			case ConfuserVersion.v17_r74021: return InitializeKeys_v17_r73404();
			case ConfuserVersion.v18_r75257: return InitializeKeys_v17_r73404();
			case ConfuserVersion.v18_r75288: return InitializeKeys_v17_r73404();
			case ConfuserVersion.v18_r75291: return InitializeKeys_v17_r73404();
			case ConfuserVersion.v18_r75402: return InitializeKeys_v18_r75402();
			case ConfuserVersion.v19_r75725: return InitializeKeys_v18_r75402();
			default: throw new ApplicationException("Invalid version");
			}
		}

		bool InitializeKeys_v17_r73404() {
			simpleDeobfuscator.Deobfuscate(initMethod);
			if (!FindLKey0(initMethod, out lkey0))
				return false;
			if (!FindKey0_v16_r71742(initMethod, out key0))
				return false;
			if (!FindKey1(initMethod, out key1))
				return false;
			if (!FindKey2Key3(initMethod, out key2, out key3))
				return false;

			simpleDeobfuscator.Deobfuscate(decryptMethod);
			if (!FindKey6(decryptMethod, out key6))
				return false;

			return true;
		}

		bool InitializeKeys_v18_r75402() {
			simpleDeobfuscator.Deobfuscate(initMethod);
			if (!FindLKey0(initMethod, out lkey0))
				return false;
			if (!FindKey0_v16_r71742(initMethod, out key0))
				return false;
			if (!FindKey1(initMethod, out key1))
				return false;
			if (!FindKey2Key3(initMethod, out key2, out key3))
				return false;

			simpleDeobfuscator.Deobfuscate(compileMethod);
			if (!FindKey4(compileMethod, out key4))
				return false;

			simpleDeobfuscator.Deobfuscate(hookConstructStr);
			if (!FindKey5(hookConstructStr, out key5))
				return false;

			simpleDeobfuscator.Deobfuscate(decryptMethod);
			if (!FindKey6(decryptMethod, out key6))
				return false;

			return true;
		}

		static bool FindKey4(MethodDef method, out uint key) {
			var instrs = method.Body.Instructions;
			for (int index = 0; index < instrs.Count; index++) {
				index = ConfuserUtils.FindCallMethod(instrs, index, Code.Call, "System.Void System.Runtime.InteropServices.Marshal::Copy(System.Byte[],System.Int32,System.IntPtr,System.Int32)");
				if (index < 0)
					break;
				if (index + 2 >= instrs.Count)
					continue;
				if (!instrs[index + 1].IsLdloc())
					continue;
				var ldci4 = instrs[index + 2];
				if (!ldci4.IsLdcI4())
					continue;

				key = (uint)ldci4.GetLdcI4Value();
				return true;
			}

			key = 0;
			return false;
		}

		static bool FindKey5(MethodDef method, out uint key) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i + 4 < instrs.Count; i++) {
				int index = i;
				var ldci4_8 = instrs[index++];
				if (!ldci4_8.IsLdcI4() || ldci4_8.GetLdcI4Value() != 8)
					continue;
				if (instrs[index++].OpCode.Code != Code.Shl)
					continue;
				if (instrs[index++].OpCode.Code != Code.Or)
					continue;
				var ldci4 = instrs[index++];
				if (!ldci4.IsLdcI4())
					continue;
				if (instrs[index++].OpCode.Code != Code.Xor)
					continue;

				key = (uint)ldci4.GetLdcI4Value();
				return true;
			}

			key = 0;
			return false;
		}

		bool InitializeMethodDataIndexes(MethodDef compileMethod) {
			switch (version) {
			case ConfuserVersion.v17_r73404: return true;
			case ConfuserVersion.v17_r73430: return true;
			case ConfuserVersion.v17_r73477: return InitializeMethodDataIndexes_v17_r73477(compileMethod);
			case ConfuserVersion.v17_r73479: return InitializeMethodDataIndexes_v17_r73477(compileMethod);
			case ConfuserVersion.v17_r74021: return InitializeMethodDataIndexes_v17_r73477(compileMethod);
			case ConfuserVersion.v18_r75257: return InitializeMethodDataIndexes_v17_r73477(compileMethod);
			case ConfuserVersion.v18_r75288: return InitializeMethodDataIndexes_v17_r73477(compileMethod);
			case ConfuserVersion.v18_r75291: return InitializeMethodDataIndexes_v17_r73477(compileMethod);
			case ConfuserVersion.v18_r75402: return InitializeMethodDataIndexes_v17_r73477(compileMethod);
			case ConfuserVersion.v19_r75725: return InitializeMethodDataIndexes_v17_r73477(compileMethod);
			default: throw new ApplicationException("Invalid version");
			}
		}

		bool InitializeMethodDataIndexes_v17_r73477(MethodDef method) {
			simpleDeobfuscator.Deobfuscate(method);
			var methodDataType = FindFirstThreeIndexes(method, out methodDataIndexes.maxStack, out methodDataIndexes.ehs, out methodDataIndexes.options);
			if (methodDataType == null)
				return false;

			if (!FindLocalVarSigTokIndex(method, methodDataType, out methodDataIndexes.localVarSigTok))
				return false;

			if (!FindCodeSizeIndex(method, methodDataType, out methodDataIndexes.codeSize))
				return false;

			return true;
		}

		static TypeDef FindFirstThreeIndexes(MethodDef method, out int maxStackIndex, out int ehsIndex, out int optionsIndex) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count; i++) {
				int index1 = FindLdfldStind(instrs, i, false, true);
				if (index1 < 0)
					break;
				i = index1;

				int index2 = FindLdfldStind(instrs, index1 + 1, true, true);
				if (index2 < 0)
					continue;

				int index3 = FindLdfldStind(instrs, index2 + 1, true, false);
				if (index3 < 0)
					continue;

				var field1 = instrs[index1].Operand as FieldDef;
				var field2 = instrs[index2].Operand as FieldDef;
				var field3 = instrs[index3].Operand as FieldDef;
				if (field1 == null || field2 == null || field3 == null)
					continue;
				if (field1.DeclaringType != field2.DeclaringType || field1.DeclaringType != field3.DeclaringType)
					continue;

				maxStackIndex = GetInstanceFieldIndex(field1);
				ehsIndex = GetInstanceFieldIndex(field2);
				optionsIndex = GetInstanceFieldIndex(field3);
				return field1.DeclaringType;
			}

			maxStackIndex = -1;
			ehsIndex = -1;
			optionsIndex = -1;
			return null;
		}

		static bool FindLocalVarSigTokIndex(MethodDef method, TypeDef methodDataType, out int localVarSigTokIndex) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 1; i++) {
				var ldfld = instrs[i];
				if (ldfld.OpCode.Code != Code.Ldfld)
					continue;
				var field = ldfld.Operand as FieldDef;
				if (field == null || field.DeclaringType != methodDataType)
					continue;

				var call = instrs[i + 1];
				if (call.OpCode.Code != Code.Call)
					continue;
				var calledMethod = call.Operand as MethodDef;
				if (calledMethod == null || !calledMethod.IsStatic || calledMethod.DeclaringType != method.DeclaringType)
					continue;

				localVarSigTokIndex = GetInstanceFieldIndex(field);
				return true;
			}

			localVarSigTokIndex = -1;
			return false;
		}

		static bool FindCodeSizeIndex(MethodDef method, TypeDef methodDataType, out int codeSizeIndex) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 1; i++) {
				var ldfld = instrs[i];
				if (ldfld.OpCode.Code != Code.Ldfld)
					continue;
				var field = ldfld.Operand as FieldDef;
				if (field == null || field.DeclaringType != methodDataType)
					continue;

				if (instrs[i+1].OpCode.Code != Code.Stfld)
					continue;

				codeSizeIndex = GetInstanceFieldIndex(field);
				return true;
			}

			codeSizeIndex = -1;
			return false;
		}

		static int GetInstanceFieldIndex(FieldDef field) {
			int i = 0;
			foreach (var f in field.DeclaringType.Fields) {
				if (f.IsStatic)
					continue;
				if (f == field)
					return i;
				i++;
			}
			throw new ApplicationException("Could not find field");
		}

		static int FindLdfldStind(IList<Instruction> instrs, int index, bool onlyInBlock, bool checkStindi4) {
			for (int i = index; i < instrs.Count - 1; i++) {
				var ldfld = instrs[i];
				if (onlyInBlock && ldfld.OpCode.FlowControl != FlowControl.Next)
					break;

				if (ldfld.OpCode.Code != Code.Ldfld)
					continue;

				var stindi4 = instrs[i + 1];
				if (checkStindi4 && stindi4.OpCode.Code != Code.Stind_I4)
					continue;

				return i;
			}
			return -1;
		}

		public bool Decrypt(MyPEImage peImage, byte[] fileData, ref DumpedMethods dumpedMethods) {
			if (initMethod == null)
				return false;

			switch (version) {
			case ConfuserVersion.v17_r73404: return Decrypt_v17_r73404(peImage, fileData, ref dumpedMethods);
			case ConfuserVersion.v17_r73430: return Decrypt_v17_r73404(peImage, fileData, ref dumpedMethods);
			case ConfuserVersion.v17_r73477: return Decrypt_v17_r73477(peImage, fileData, ref dumpedMethods);
			case ConfuserVersion.v17_r73479: return Decrypt_v17_r73479(peImage, fileData, ref dumpedMethods);
			case ConfuserVersion.v17_r74021: return Decrypt_v17_r73479(peImage, fileData, ref dumpedMethods);
			case ConfuserVersion.v18_r75257: return Decrypt_v17_r73479(peImage, fileData, ref dumpedMethods);
			case ConfuserVersion.v18_r75288: return Decrypt_v17_r73479(peImage, fileData, ref dumpedMethods);
			case ConfuserVersion.v18_r75291: return Decrypt_v17_r73479(peImage, fileData, ref dumpedMethods);
			case ConfuserVersion.v18_r75402: return Decrypt_v18_r75402(peImage, fileData, ref dumpedMethods);
			case ConfuserVersion.v19_r75725: return Decrypt_v18_r75402(peImage, fileData, ref dumpedMethods);
			default: throw new ApplicationException("Unknown version");
			}
		}

		bool Decrypt_v17_r73404(MyPEImage peImage, byte[] fileData, ref DumpedMethods dumpedMethods) {
			methodsData = DecryptMethodsData_v17_r73404(peImage);
			dumpedMethods = Decrypt_v17_r73404(peImage, fileData);
			return dumpedMethods != null;
		}

		DumpedMethods Decrypt_v17_r73404(MyPEImage peImage, byte[] fileData) {
			var dumpedMethods = new DumpedMethods();

			var methodDef = peImage.Metadata.TablesStream.MethodTable;
			for (uint rid = 1; rid <= methodDef.Rows; rid++) {
				var dm = new DumpedMethod();
				peImage.ReadMethodTableRowTo(dm, rid);

				if (dm.mdRVA == 0)
					continue;
				uint bodyOffset = peImage.RvaToOffset(dm.mdRVA);

				if (!IsEncryptedMethod(fileData, (int)bodyOffset))
					continue;

				int key = BitConverter.ToInt32(fileData, (int)bodyOffset + 6);
				int mdOffs = BitConverter.ToInt32(fileData, (int)bodyOffset + 2) ^ key;
				int len = BitConverter.ToInt32(fileData, (int)bodyOffset + 11) ^ ~key;
				var codeData = DecryptMethodData_v17_r73404(methodsData, mdOffs + 2, (uint)key, len);

				var reader = ByteArrayDataReaderFactory.CreateReader(codeData);
				var mbHeader = MethodBodyParser.ParseMethodBody(ref reader, out dm.code, out dm.extraSections);
				if (reader.Position != reader.Length)
					throw new ApplicationException("Invalid method data");

				peImage.UpdateMethodHeaderInfo(dm, mbHeader);

				dumpedMethods.Add(dm);
			}

			return dumpedMethods;
		}

		bool Decrypt_v17_r73477(MyPEImage peImage, byte[] fileData, ref DumpedMethods dumpedMethods) {
			methodsData = DecryptMethodsData_v17_r73404(peImage);
			dumpedMethods = Decrypt_v17_r73477(peImage, fileData);
			return dumpedMethods != null;
		}

		DumpedMethods Decrypt_v17_r73477(MyPEImage peImage, byte[] fileData) =>
			Decrypt(peImage, fileData, new DecryptMethodData_v17_r73477());

		bool Decrypt_v17_r73479(MyPEImage peImage, byte[] fileData, ref DumpedMethods dumpedMethods) {
			methodsData = DecryptMethodsData_v17_r73404(peImage);
			dumpedMethods = Decrypt_v17_r73479(peImage, fileData);
			return dumpedMethods != null;
		}

		DumpedMethods Decrypt_v17_r73479(MyPEImage peImage, byte[] fileData) =>
			Decrypt(peImage, fileData, new DecryptMethodData_v17_r73479());

		bool Decrypt_v18_r75402(MyPEImage peImage, byte[] fileData, ref DumpedMethods dumpedMethods) {
			if (peImage.OptionalHeader.CheckSum == 0)
				return false;
			methodsData = DecryptMethodsData_v17_r73404(peImage);
			dumpedMethods = Decrypt_v18_r75402(peImage, fileData);
			return dumpedMethods != null;
		}

		DumpedMethods Decrypt_v18_r75402(MyPEImage peImage, byte[] fileData) =>
			Decrypt(peImage, fileData, new DecryptMethodData_v18_r75402(this));

		abstract class DecryptMethodData {
			public abstract void Decrypt(byte[] fileData, int offset, uint k1, int size, out uint[] methodData, out byte[] codeData);
			public bool IsCodeFollowedByExtraSections(uint options) => (options >> 8) == 0;
		}

		class DecryptMethodData_v17_r73477 : DecryptMethodData {
			public override void Decrypt(byte[] fileData, int offset, uint k1, int size, out uint[] methodData, out byte[] codeData) {
				var data = new byte[size];
				Array.Copy(fileData, offset, data, 0, data.Length);
				var key = BitConverter.GetBytes(k1);
				for (int i = 0; i < data.Length; i++)
					data[i] ^= key[i & 3];

				methodData = new uint[5];
				Buffer.BlockCopy(data, 0, methodData, 0, 20);
				codeData = new byte[size - 20];
				Array.Copy(data, 20, codeData, 0, codeData.Length);
			}
		}

		class DecryptMethodData_v17_r73479 : DecryptMethodData {
			public override void Decrypt(byte[] fileData, int offset, uint k1, int size, out uint[] methodData, out byte[] codeData) {
				var data = new byte[size];
				Array.Copy(fileData, offset, data, 0, data.Length);
				uint k = k1;
				for (int i = 0; i < data.Length; i++) {
					data[i] ^= (byte)k;
					k = (k * data[i] + k1) % 0xFF;
				}

				methodData = new uint[5];
				Buffer.BlockCopy(data, 0, methodData, 0, 20);
				codeData = new byte[size - 20];
				Array.Copy(data, 20, codeData, 0, codeData.Length);
			}
		}

		class DecryptMethodData_v18_r75402 : DecryptMethodData {
			JitMethodsDecrypter jitDecrypter;

			public DecryptMethodData_v18_r75402(JitMethodsDecrypter jitDecrypter) => this.jitDecrypter = jitDecrypter;

			public override void Decrypt(byte[] fileData, int offset, uint k1, int size, out uint[] methodData, out byte[] codeData) {
				var data = new byte[size];
				Array.Copy(fileData, offset, data, 0, data.Length);
				uint k2 = jitDecrypter.key4 * k1;
				for (int i = 0; i < data.Length; i++) {
					data[i] ^= (byte)k2;
					k2 = (byte)((k2 * data[i] + k1) % 0xFF);
				}

				methodData = new uint[5];
				Buffer.BlockCopy(data, 0, methodData, 0, 20);
				codeData = new byte[size - 20];
				Array.Copy(data, 20, codeData, 0, codeData.Length);
			}
		}

		DumpedMethods Decrypt(MyPEImage peImage, byte[] fileData, DecryptMethodData decrypter) {
			var dumpedMethods = new DumpedMethods();

			var methodDef = peImage.Metadata.TablesStream.MethodTable;
			for (uint rid = 1; rid <= methodDef.Rows; rid++) {
				var dm = new DumpedMethod();
				peImage.ReadMethodTableRowTo(dm, rid);

				if (dm.mdRVA == 0)
					continue;
				uint bodyOffset = peImage.RvaToOffset(dm.mdRVA);

				if (!IsEncryptedMethod(fileData, (int)bodyOffset))
					continue;

				int key = BitConverter.ToInt32(fileData, (int)bodyOffset + 6);
				int mdOffs = BitConverter.ToInt32(fileData, (int)bodyOffset + 2) ^ key;
				int len = BitConverter.ToInt32(fileData, (int)bodyOffset + 11) ^ ~key;
				int methodDataOffset = mdOffs + 2;
				decrypter.Decrypt(methodsData, methodDataOffset, (uint)key, len, out var methodData, out var codeData);

				dm.mhFlags = 0x03;
				int maxStack = (int)methodData[methodDataIndexes.maxStack];
				dm.mhMaxStack = (ushort)maxStack;
				dm.mhLocalVarSigTok = methodData[methodDataIndexes.localVarSigTok];
				if (dm.mhLocalVarSigTok != 0 && (dm.mhLocalVarSigTok >> 24) != 0x11)
					throw new ApplicationException("Invalid local var sig token");
				int numExceptions = (int)methodData[methodDataIndexes.ehs];
				uint options = methodData[methodDataIndexes.options];
				int codeSize = (int)methodData[methodDataIndexes.codeSize];

				var codeDataReader = ByteArrayDataReaderFactory.CreateReader(codeData);
				if (decrypter.IsCodeFollowedByExtraSections(options)) {
					dm.code = codeDataReader.ReadBytes(codeSize);
					dm.extraSections = ReadExceptionHandlers(ref codeDataReader, numExceptions);
				}
				else {
					dm.extraSections = ReadExceptionHandlers(ref codeDataReader, numExceptions);
					dm.code = codeDataReader.ReadBytes(codeSize);
				}
				if (codeDataReader.Position != codeDataReader.Length)
					throw new ApplicationException("Invalid method data");
				if (dm.extraSections != null)
					dm.mhFlags |= 8;
				dm.mhCodeSize = (uint)dm.code.Length;

				// Figure out if the original method was tiny or not.
				bool isTiny = dm.code.Length <= 0x3F &&
							dm.mhLocalVarSigTok == 0 &&
							dm.extraSections == null &&
							dm.mhMaxStack == 8;
				if (isTiny)
					dm.mhFlags |= 0x10;	// Set 'init locals'
				dm.mhFlags |= (ushort)(options & 0x10);	// copy 'init locals' bit

				dumpedMethods.Add(dm);
			}

			return dumpedMethods;
		}

		static bool IsEncryptedMethod(byte[] fileData, int offset) =>
			fileData[offset] == 0x46 &&
			fileData[offset + 1] == 0x21 &&
			fileData[offset + 10] == 0x20 &&
			fileData[offset + 15] == 0x26;

		static byte[] ReadExceptionHandlers(ref DataReader reader, int numExceptions) {
			if (numExceptions == 0)
				return null;

			var memStream = new MemoryStream();
			var writer = new BinaryWriter(memStream);

			ulong header64 = (((ulong)numExceptions * 24) << 8) | 0x41;
			if (header64 > uint.MaxValue)
				throw new ApplicationException("Too many exception handlers...");
			writer.Write((uint)header64);
			for (int i = 0; i < numExceptions; i++) {
				writer.Write(reader.ReadUInt32());	// flags
				writer.Write(reader.ReadUInt32());	// try offset
				writer.Write(reader.ReadUInt32());	// try length
				writer.Write(reader.ReadUInt32());	// handler offset
				writer.Write(reader.ReadUInt32());	// handler length
				writer.Write(reader.ReadUInt32());	// catch token or filter offset
			}

			return memStream.ToArray();
		}

		byte[] DecryptMethodData_v17_r73404(byte[] fileData, int offset, uint k1, int size) {
			var data = new byte[size];
			var kbytes = BitConverter.GetBytes(k1);
			for (int i = 0; i < size; i++)
				data[i] = (byte)(fileData[offset + i] ^ kbytes[i & 3]);
			return data;
		}

		string IStringDecrypter.ReadUserString(uint token) {
			if ((token & 0xFF800000) != 0x70800000)
				return null;
			var reader = ByteArrayDataReaderFactory.CreateReader(methodsData);
			reader.Position = (token & ~0xFF800000) + 2;
			int len = reader.ReadInt32();
			if ((len & 1) != 1)
				throw new ApplicationException("Invalid string len");
			int chars = len / 2;
			var sb = new StringBuilder(chars);
			for (int i = 0; i < chars; i++)
				sb.Append((char)(reader.ReadUInt16() ^ key5));
			return sb.ToString();
		}

		public override bool GetRevisionRange(out int minRev, out int maxRev) {
			switch (version) {
			case ConfuserVersion.Unknown:
				minRev = maxRev = 0;
				return false;

			case ConfuserVersion.v17_r73404:
				minRev = 73404;
				maxRev = 73404;
				return true;

			case ConfuserVersion.v17_r73430:
				minRev = 73430;
				maxRev = 73430;
				return true;

			case ConfuserVersion.v17_r73477:
				minRev = 73477;
				maxRev = 73477;
				return true;

			case ConfuserVersion.v17_r73479:
				minRev = 73479;
				maxRev = 73822;
				return true;

			case ConfuserVersion.v17_r74021:
				minRev = 74021;
				maxRev = 75184;
				return true;

			case ConfuserVersion.v18_r75257:
				minRev = 75257;
				maxRev = 75267;
				return true;

			case ConfuserVersion.v18_r75288:
				minRev = 75288;
				maxRev = 75288;
				return true;

			case ConfuserVersion.v18_r75291:
				minRev = 75291;
				maxRev = 75369;
				return true;

			case ConfuserVersion.v18_r75402:
				minRev = 75402;
				maxRev = 75720;
				return true;

			case ConfuserVersion.v19_r75725:
				minRev = 75725;
				maxRev = int.MaxValue;
				return true;

			default: throw new ApplicationException("Invalid version");
			}
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Confuser/MemoryMethodsDecrypter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.IO;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Confuser {
	class MemoryMethodsDecrypter : MethodsDecrypterBase {
		ConfuserVersion version = ConfuserVersion.Unknown;

		enum ConfuserVersion {
			Unknown,
			v14_r57884,
			v14_r58004,
			v14_r58564,
			v14_r58852,
			v15_r59014,
			v16_r71742,
			v17_r72989,
			// Removed in Confuser 1.7 r73404 and restored in Confuser 1.7 r73605
			v17_r73605,
			v18_r75288,
			v19_r75725,
		}

		public MemoryMethodsDecrypter(ModuleDefMD module, ISimpleDeobfuscator simpleDeobfuscator)
			: base(module, simpleDeobfuscator) {
		}

		public MemoryMethodsDecrypter(ModuleDefMD module, ISimpleDeobfuscator simpleDeobfuscator, MemoryMethodsDecrypter other)
			: base(module, simpleDeobfuscator, other) {
			if (other != null)
				version = other.version;
		}

		protected override bool CheckType(TypeDef type, MethodDef initMethod) {
			if (type == null)
				return false;
			if (type.Methods.Count != 3)
				return false;
			var virtProtect = DotNetUtils.GetPInvokeMethod(type, "kernel32", "VirtualProtect");
			if (virtProtect == null)
				return false;
			if (!DotNetUtils.HasString(initMethod, "Broken file"))
				return false;

			if ((decryptMethod = FindDecryptMethod(type)) == null)
				return false;

			bool callsFileStreamCtor = DotNetUtils.CallsMethod(initMethod, "System.Void System.IO.FileStream::.ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)");
			if (!DotNetUtils.HasString(initMethod, "Module error"))
				version = ConfuserVersion.v14_r57884;
			else if (virtProtect.IsPrivate && callsFileStreamCtor) {
				int calls = ConfuserUtils.CountCalls(initMethod, "System.Void System.Buffer::BlockCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)");
				if (calls <= 1)
					version = ConfuserVersion.v14_r58564;
				else if (calls == 2)
					version = ConfuserVersion.v14_r58852;
				else if (calls == 4)
					version = ConfuserVersion.v15_r59014;
				else
					return false;
			}
			else if (callsFileStreamCtor)
				version = ConfuserVersion.v14_r58004;
			else if (DotNetUtils.CallsMethod(initMethod, "System.Int32 System.Object::GetHashCode()")) {
				if (DotNetUtils.HasString(initMethod, "<Unknown>"))
					version = ConfuserVersion.v17_r72989;
				else
					version = ConfuserVersion.v16_r71742;
			}
			else if (DotNetUtils.CallsMethod(decryptMethod, "System.Security.Cryptography.Rijndael System.Security.Cryptography.Rijndael::Create()"))
				version = ConfuserVersion.v17_r73605;
			else if (DotNetUtils.HasString(initMethod, "<Unknown>"))
				version = ConfuserVersion.v18_r75288;
			else
				version = ConfuserVersion.v19_r75725;

			return true;
		}

		public void Initialize() {
			if (initMethod == null)
				return;

			if (!InitializeKeys())
				throw new ApplicationException("Could not find all decryption keys");
		}

		bool InitializeKeys() {
			switch (version) {
			case ConfuserVersion.v14_r57884:
			case ConfuserVersion.v14_r58004:
				return true;

			case ConfuserVersion.v14_r58564:
			case ConfuserVersion.v14_r58852:
			case ConfuserVersion.v15_r59014:
				return InitializeKeys_v14_r58564();

			case ConfuserVersion.v16_r71742:
			case ConfuserVersion.v17_r72989:
				return InitializeKeys_v16_r71742();

			case ConfuserVersion.v17_r73605:
			case ConfuserVersion.v18_r75288:
			case ConfuserVersion.v19_r75725:
				return InitializeKeys_v17_r73605();

			default:
				throw new ApplicationException("Unknown version");
			}
		}

		bool InitializeKeys_v14_r58564() {
			simpleDeobfuscator.Deobfuscate(initMethod);
			if (!FindLKey0(initMethod, out lkey0))
				return false;
			if (!FindKey0_v14_r58564(initMethod, out key0))
				return false;
			if (!FindKey2Key3(initMethod, out key2, out key3))
				return false;
			if (!FindKey4(initMethod, out key4))
				return false;
			if (!FindKey5(initMethod, out key5))
				return false;

			simpleDeobfuscator.Deobfuscate(decryptMethod);
			if (!FindKey6(decryptMethod, out key6))
				return false;

			return true;
		}

		bool InitializeKeys_v16_r71742() {
			simpleDeobfuscator.Deobfuscate(initMethod);
			if (!FindLKey0(initMethod, out lkey0))
				return false;
			if (!FindKey0_v16_r71742(initMethod, out key0))
				return false;
			if (!FindKey2Key3(initMethod, out key2, out key3))
				return false;
			if (!FindKey4(initMethod, out key4))
				return false;
			if (!FindKey5(initMethod, out key5))
				return false;

			simpleDeobfuscator.Deobfuscate(decryptMethod);
			if (!FindKey6(decryptMethod, out key6))
				return false;

			return true;
		}

		bool InitializeKeys_v17_r73605() {
			simpleDeobfuscator.Deobfuscate(initMethod);
			if (!FindLKey0(initMethod, out lkey0))
				return false;
			if (!FindKey0_v16_r71742(initMethod, out key0))
				return false;
			if (!FindKey1(initMethod, out key1))
				return false;
			if (!FindKey2Key3(initMethod, out key2, out key3))
				return false;
			if (!FindKey4(initMethod, out key4))
				return false;
			if (!FindKey5(initMethod, out key5))
				return false;

			simpleDeobfuscator.Deobfuscate(decryptMethod);
			if (!FindKey6(decryptMethod, out key6))
				return false;

			return true;
		}

		static bool FindKey4(MethodDef method, out uint key) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count; i++) {
				i = FindCallvirtReadUInt32(instrs, i);
				if (i < 0)
					break;
				if (i >= 2) {
					if (instrs[i-2].OpCode.Code == Code.Pop)
						continue;
				}
				if (i + 4 >= instrs.Count)
					break;

				var ldci4 = instrs[i + 1];
				if (!ldci4.IsLdcI4())
					continue;
				if (instrs[i + 2].OpCode.Code != Code.Xor)
					continue;
				var stloc = instrs[i + 3];
				if (!stloc.IsStloc())
					continue;
				var ldloc = instrs[i + 4];
				if (!ldloc.IsLdloc())
					continue;
				if (ldloc.GetLocal(method.Body.Variables) != stloc.GetLocal(method.Body.Variables))
					continue;

				key = (uint)ldci4.GetLdcI4Value();
				return true;
			}

			key = 0;
			return false;
		}

		static bool FindKey5(MethodDef method, out uint key) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count; i++) {
				i = FindCallvirtReadUInt32(instrs, i);
				if (i < 0)
					break;
				int index2 = ConfuserUtils.FindCallMethod(instrs, i, Code.Callvirt, "System.Int32 System.IO.BinaryReader::ReadInt32()");
				if (index2 < 0)
					break;
				if (index2 - i != 6)
					continue;

				var ldci4 = instrs[i + 1];
				if (!ldci4.IsLdcI4())
					continue;
				if (instrs[i + 2].OpCode.Code != Code.Xor)
					continue;
				var stloc = instrs[i + 3];
				if (!stloc.IsStloc())
					continue;
				var ldloc = instrs[i + 4];
				if (!ldloc.IsLdloc())
					continue;
				if (ldloc.GetLocal(method.Body.Variables) == stloc.GetLocal(method.Body.Variables))
					continue;
				if (!instrs[i + 5].IsLdloc())
					continue;

				key = (uint)ldci4.GetLdcI4Value();
				return true;
			}

			key = 0;
			return false;
		}

		public bool Decrypt(MyPEImage peImage, byte[] fileData) {
			if (initMethod == null)
				return false;

			switch (version) {
			case ConfuserVersion.v14_r57884: return Decrypt_v14_r57884(peImage, fileData);
			case ConfuserVersion.v14_r58004: return Decrypt_v14_r58004(peImage, fileData);
			case ConfuserVersion.v14_r58564: return Decrypt_v14_r58004(peImage, fileData);
			case ConfuserVersion.v14_r58852: return Decrypt_v14_r58004(peImage, fileData);
			case ConfuserVersion.v15_r59014: return Decrypt_v15_r59014(peImage, fileData);
			case ConfuserVersion.v16_r71742: return Decrypt_v16_r71742(peImage, fileData);
			case ConfuserVersion.v17_r72989: return Decrypt_v16_r71742(peImage, fileData);
			case ConfuserVersion.v17_r73605: return Decrypt_v17_r73605(peImage, fileData);
			case ConfuserVersion.v18_r75288: return Decrypt_v17_r73605(peImage, fileData);
			case ConfuserVersion.v19_r75725: return Decrypt_v17_r73605(peImage, fileData);
			default: throw new ApplicationException("Unknown version");
			}
		}

		bool Decrypt_v14_r57884(MyPEImage peImage, byte[] fileData) {
			methodsData = DecryptMethodsData_v14_r57884(peImage, false);

			var reader = new BinaryReader(new MemoryStream(methodsData));
			reader.ReadInt16();	// sig
			var writer = new BinaryWriter(new MemoryStream(fileData));
			int numInfos = reader.ReadInt32();
			for (int i = 0; i < numInfos; i++) {
				uint rva = reader.ReadUInt32();
				if (rva == 0)
					continue;
				writer.BaseStream.Position = peImage.RvaToOffset(rva);
				writer.Write(reader.ReadBytes(reader.ReadInt32()));
			}

			return true;
		}

		byte[] DecryptMethodsData_v14_r57884(MyPEImage peImage, bool hasStrongNameInfo) {
			var reader = peImage.Reader;
			reader.Position = 0;
			var md5SumData = reader.ReadBytes((int)peImage.OptionalHeader.CheckSum ^ (int)key0);

			int csOffs = (int)peImage.OptionalHeader.StartOffset + 0x40;
			Array.Clear(md5SumData, csOffs, 4);
			/*var md5Sum =*/ DeobUtils.Md5Sum(md5SumData);
			ulong checkSum = reader.ReadUInt64() ^ lkey0;
			if (hasStrongNameInfo) {
				int sn = reader.ReadInt32();
				int snLen = reader.ReadInt32();
				if (sn != 0) {
					if (peImage.RvaToOffset((uint)peImage.Cor20Header.StrongNameSignature.VirtualAddress) != sn ||
						peImage.Cor20Header.StrongNameSignature.Size != snLen)
						throw new ApplicationException("Invalid sn and snLen");
					Array.Clear(md5SumData, sn, snLen);
				}
			}
			if (checkSum != CalcChecksum(md5SumData))
				throw new ApplicationException("Invalid checksum. File has been modified.");
			var iv = reader.ReadBytes(reader.ReadInt32() ^ (int)key2);
			var encrypted = reader.ReadBytes(reader.ReadInt32() ^ (int)key3);
			var decrypted = Decrypt(encrypted, iv, md5SumData);
			if (BitConverter.ToInt16(decrypted, 0) != 0x6FD6)
				throw new ApplicationException("Invalid magic");
			return decrypted;
		}

		bool Decrypt_v14_r58004(MyPEImage peImage, byte[] fileData) {
			methodsData = DecryptMethodsData_v14_r57884(peImage, false);
			return DecryptImage_v14_r58004(peImage, fileData);
		}

		bool DecryptImage_v14_r58004(MyPEImage peImage, byte[] fileData) {
			var reader = new BinaryReader(new MemoryStream(methodsData));
			reader.ReadInt16();	// sig
			var writer = new BinaryWriter(new MemoryStream(fileData));
			int numInfos = reader.ReadInt32();
			for (int i = 0; i < numInfos; i++) {
				uint offs = reader.ReadUInt32() ^ key4;
				if (offs == 0)
					continue;
				uint rva = reader.ReadUInt32() ^ key4;
				if (peImage.RvaToOffset(rva) != offs)
					throw new ApplicationException("Invalid offs & rva");
				writer.BaseStream.Position = peImage.RvaToOffset(rva);
				writer.Write(reader.ReadBytes(reader.ReadInt32()));
			}

			return true;
		}

		bool Decrypt_v15_r59014(MyPEImage peImage, byte[] fileData) {
			methodsData = DecryptMethodsData_v14_r57884(peImage, true);
			return DecryptImage_v14_r58004(peImage, fileData);
		}

		bool Decrypt_v16_r71742(MyPEImage peImage, byte[] fileData) {
			methodsData = DecryptMethodsData_v16_r71742(peImage, GetEncryptedHeaderOffset_v16_r71742(peImage.Sections));
			return DecryptImage_v16_r71742(peImage, fileData);
		}

		bool Decrypt_v17_r73605(MyPEImage peImage, byte[] fileData) {
			if (peImage.OptionalHeader.CheckSum == 0)
				return false;

			methodsData = DecryptMethodsData_v17_r73404(peImage);
			return DecryptImage_v16_r71742(peImage, fileData);
		}

		bool DecryptImage_v16_r71742(MyPEImage peImage, byte[] fileData) {
			var reader = new BinaryReader(new MemoryStream(methodsData));
			reader.ReadInt16();	// sig
			int numInfos = reader.ReadInt32();
			for (int i = 0; i < numInfos; i++) {
				uint offs = reader.ReadUInt32() ^ key4;
				if (offs == 0)
					continue;
				uint rva = reader.ReadUInt32() ^ key5;
				if (peImage.RvaToOffset(rva) != offs)
					throw new ApplicationException("Invalid offs & rva");
				int len = reader.ReadInt32();
				for (int j = 0; j < len; j++)
					fileData[offs + j] = reader.ReadByte();
			}
			return true;
		}

		public override bool GetRevisionRange(out int minRev, out int maxRev) {
			switch (version) {
			case ConfuserVersion.Unknown:
				minRev = maxRev = 0;
				return false;

			case ConfuserVersion.v14_r57884:
				minRev = 57884;
				maxRev = 57884;
				return true;

			case ConfuserVersion.v14_r58004:
				minRev = 58004;
				maxRev = 58446;
				return true;

			case ConfuserVersion.v14_r58564:
				minRev = 58564;
				maxRev = 58817;
				return true;

			case ConfuserVersion.v14_r58852:
				minRev = 58852;
				maxRev = 58919;
				return true;

			case ConfuserVersion.v15_r59014:
				minRev = 59014;
				maxRev = 70489;
				return true;

			case ConfuserVersion.v16_r71742:
				minRev = 71742;
				maxRev = 72868;
				return true;

			case ConfuserVersion.v17_r72989:
				minRev = 72989;
				maxRev = 72989;
				return true;

			case ConfuserVersion.v17_r73605:
				minRev = 73605;
				maxRev = 75267;
				return true;

			case ConfuserVersion.v18_r75288:
				minRev = 75288;
				maxRev = 75720;
				return true;

			case ConfuserVersion.v19_r75725:
				minRev = 75725;
				maxRev = int.MaxValue;
				return true;

			default: throw new ApplicationException("Invalid version");
			}
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Confuser/MethodsDecrypterBase.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.IO;
using System.Security.Cryptography;
using dnlib.PE;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Confuser {
	abstract class MethodsDecrypterBase : IVersionProvider {
		protected ModuleDefMD module;
		protected ISimpleDeobfuscator simpleDeobfuscator;
		protected MethodDef initMethod;
		protected MethodDef decryptMethod;
		protected ulong lkey0;
		protected uint key0, key1, key2, key3, key4, key5, key6;
		protected byte[] methodsData;

		public MethodDef InitMethod => initMethod;
		public TypeDef Type => initMethod?.DeclaringType;
		public bool Detected => initMethod != null;

		protected MethodsDecrypterBase(ModuleDefMD module, ISimpleDeobfuscator simpleDeobfuscator) {
			this.module = module;
			this.simpleDeobfuscator = simpleDeobfuscator;
		}

		protected MethodsDecrypterBase(ModuleDefMD module, ISimpleDeobfuscator simpleDeobfuscator, MethodsDecrypterBase other) {
			this.module = module;
			this.simpleDeobfuscator = simpleDeobfuscator;
			if (other != null)
				initMethod = Lookup(other.initMethod, "Could not find initMethod");
		}

		T Lookup<T>(T def, string errorMessage) where T : class, ICodedToken => DeobUtils.Lookup(module, def, errorMessage);
		public abstract bool GetRevisionRange(out int minRev, out int maxRev);
		public void Find() => Find(DotNetUtils.GetModuleTypeCctor(module));

		bool Find(MethodDef method) {
			if (method == null || method.Body == null)
				return false;
			foreach (var instr in method.Body.Instructions) {
				if (instr.OpCode.Code != Code.Call)
					continue;
				var calledMethod = instr.Operand as MethodDef;
				try {
					// If the body is encrypted, this could throw
					if (calledMethod == null || calledMethod.Body == null)
						continue;
				}
				catch {
					continue;
				}
				if (!DotNetUtils.IsMethod(calledMethod, "System.Void", "()"))
					continue;
				if (!CheckType(calledMethod.DeclaringType, calledMethod))
					continue;

				initMethod = calledMethod;
				return true;
			}
			return false;
		}

		protected abstract bool CheckType(TypeDef type, MethodDef initMethod);

		protected static MethodDef FindDecryptMethod(TypeDef type) {
			foreach (var method in type.Methods) {
				if (!method.IsStatic || method.Body == null)
					continue;
				if (!DotNetUtils.IsMethod(method, "System.Byte[]", "(System.Byte[],System.Byte[],System.Byte[])"))
					continue;

				return method;
			}
			return null;
		}

		protected static bool FindLKey0(MethodDef method, out ulong key) {
			var instrs = method.Body.Instructions;
			for (int index = 0; index < instrs.Count; index++) {
				index = FindCallvirtReadUInt64(instrs, index);
				if (index < 0)
					break;
				if (index + 1 >= instrs.Count)
					continue;
				var ldci8 = instrs[index + 1];
				if (ldci8.OpCode.Code != Code.Ldc_I8)
					continue;

				key = (ulong)(long)ldci8.Operand;
				return true;
			}

			key = 0;
			return false;
		}

		protected static bool FindKey0_v16_r71742(MethodDef method, out uint key) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i + 5 < instrs.Count; i++) {
				i = FindCallvirtReadUInt32(instrs, i);
				if (i < 0)
					break;

				int index = i + 1;
				var ldci4_1 = instrs[index++];
				if (!ldci4_1.IsLdcI4())
					continue;
				if (instrs[index++].OpCode.Code != Code.Xor)
					continue;
				if (!instrs[index++].IsStloc())
					continue;
				if (!instrs[index++].IsLdloc())
					continue;
				var ldci4_2 = instrs[index++];
				if (!ldci4_2.IsLdcI4())
					continue;
				if (ldci4_1.GetLdcI4Value() != ldci4_2.GetLdcI4Value())
					continue;

				key = (uint)ldci4_1.GetLdcI4Value();
				return true;
			}

			key = 0;
			return false;
		}

		protected static bool FindKey0_v14_r58564(MethodDef method, out uint key) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i + 5 < instrs.Count; i++) {
				i = ConfuserUtils.FindCallMethod(instrs, i, Code.Callvirt, "System.Int32 System.IO.BinaryReader::ReadInt32()");
				if (i < 0)
					break;

				int index = i + 1;
				var ldci4_1 = instrs[index++];
				if (!ldci4_1.IsLdcI4())
					continue;
				if (instrs[index++].OpCode.Code != Code.Xor)
					continue;
				if (!instrs[index++].IsStloc())
					continue;
				if (!instrs[index++].IsLdloc())
					continue;
				var ldci4_2 = instrs[index++];
				if (!ldci4_2.IsLdcI4())
					continue;
				if (ldci4_2.GetLdcI4Value() != 0 && ldci4_1.GetLdcI4Value() != ldci4_2.GetLdcI4Value())
					continue;

				key = (uint)ldci4_1.GetLdcI4Value();
				return true;
			}

			key = 0;
			return false;
		}

		protected static bool FindKey1(MethodDef method, out uint key) {
			var instrs = method.Body.Instructions;
			for (int index = 0; index < instrs.Count; index++) {
				index = FindCallvirtReadUInt32(instrs, index);
				if (index < 0)
					break;
				if (index == 0)
					continue;
				int i = index - 1;
				if (!CheckCallvirtReadUInt32(instrs, ref i))
					continue;
				if (!CheckCallvirtReadUInt32(instrs, ref i))
					continue;
				if (!CheckCallvirtReadUInt32(instrs, ref i))
					continue;
				if (!CheckCallvirtReadUInt32(instrs, ref i))
					continue;

				if (i + 1 >= instrs.Count)
					continue;
				if (!instrs[i].IsLdloc())
					continue;
				var ldci4 = instrs[i + 1];
				if (!ldci4.IsLdcI4())
					continue;

				key = (uint)ldci4.GetLdcI4Value();
				return true;
			}

			key = 0;
			return false;
		}

		static bool CheckCallvirtReadUInt32(IList<Instruction> instrs, ref int index) {
			if (index + 2 >= instrs.Count)
				return false;

			if (!instrs[index].IsLdloc())
				return false;
			if (!ConfuserUtils.IsCallMethod(instrs[index + 1], Code.Callvirt, "System.UInt32 System.IO.BinaryReader::ReadUInt32()"))
				return false;
			if (!instrs[index + 2].IsStloc() && instrs[index + 2].OpCode.Code != Code.Pop)
				return false;

			index += 3;
			return true;
		}

		protected static bool FindKey2Key3(MethodDef method, out uint key2, out uint key3) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count; i++) {
				int index = i;
				if (!FindKey2OrKey3(instrs, ref index, out key2))
					continue;
				if (!FindKey2OrKey3(instrs, ref index, out key3))
					continue;

				return true;
			}

			key2 = 0;
			key3 = 0;
			return false;
		}

		static bool FindKey2OrKey3(IList<Instruction> instrs, ref int index, out uint key) {
			key = 0;
			if (index + 6 >= instrs.Count)
				return false;
			int i = index;
			if (!instrs[i++].IsLdloc())
				return false;
			if (!instrs[i++].IsLdloc())
				return false;
			if (!ConfuserUtils.IsCallMethod(instrs[i++], Code.Callvirt, "System.Int32 System.IO.BinaryReader::ReadInt32()"))
				return false;
			var ldci4 = instrs[i++];
			if (!ldci4.IsLdcI4())
				return false;
			if (instrs[i++].OpCode.Code != Code.Xor)
				return false;
			if (!ConfuserUtils.IsCallMethod(instrs[i++], Code.Callvirt, "System.Byte[] System.IO.BinaryReader::ReadBytes(System.Int32)"))
				return false;
			if (!instrs[i++].IsStloc())
				return false;

			key = (uint)ldci4.GetLdcI4Value();
			index = i;
			return true;
		}

		protected static bool FindKey6(MethodDef method, out uint key) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i + 4 < instrs.Count; i++) {
				int index = i;
				if (!instrs[index++].IsLdloc())
					continue;
				if (instrs[index++].OpCode.Code != Code.Sub)
					continue;
				if (instrs[index++].OpCode.Code != Code.Ldelem_U1)
					continue;
				var ldci4 = instrs[index++];
				if (!ldci4.IsLdcI4())
					continue;
				if (instrs[index++].OpCode.Code != Code.Xor)
					continue;
				if (instrs[index++].OpCode.Code != Code.Conv_U1)
					continue;

				key = (uint)ldci4.GetLdcI4Value();
				return true;
			}

			key = 0;
			return false;
		}

		protected static int FindCallvirtReadUInt32(IList<Instruction> instrs, int index) =>
			ConfuserUtils.FindCallMethod(instrs, index, Code.Callvirt, "System.UInt32 System.IO.BinaryReader::ReadUInt32()");

		static int FindCallvirtReadUInt64(IList<Instruction> instrs, int index) =>
			ConfuserUtils.FindCallMethod(instrs, index, Code.Callvirt, "System.UInt64 System.IO.BinaryReader::ReadUInt64()");

		protected byte[] DecryptMethodsData_v17_r73404(MyPEImage peImage) =>
			DecryptMethodsData_v16_r71742(peImage, GetEncryptedHeaderOffset_vXX(peImage.Sections));

		protected byte[] DecryptMethodsData_v16_r71742(MyPEImage peImage, uint encryptedHeaderOffset) {
			uint mdRva = peImage.OptionalHeader.CheckSum ^ (uint)key0;
			if ((RVA)mdRva != peImage.Cor20Header.Metadata.VirtualAddress)
				throw new ApplicationException("Invalid metadata rva");
			var reader = peImage.Reader;
			reader.Position = encryptedHeaderOffset;
			ulong checkSum = reader.ReadUInt64() ^ lkey0;
			reader.ReadInt32();	// strong name RVA
			reader.ReadInt32();	// strong name len
			var iv = reader.ReadBytes(reader.ReadInt32() ^ (int)key2);
			var encrypted = reader.ReadBytes(reader.ReadInt32() ^ (int)key3);
			var streamsBuffer = GetStreamsBuffer(peImage);
			if (checkSum != CalcChecksum(streamsBuffer))
				throw new ApplicationException("Invalid checksum. File has been modified.");
			var decrypted = Decrypt(encrypted, iv, streamsBuffer);
			if (BitConverter.ToInt16(decrypted, 0) != 0x6FD6)
				throw new ApplicationException("Invalid magic");
			return decrypted;
		}

		protected uint GetEncryptedHeaderOffset_v16_r71742(IList<ImageSectionHeader> sections) {
			for (int i = sections.Count - 1; i >= 0; i--) {
				var section = sections[i];
				if (section.DisplayName == ".confuse")
					return section.PointerToRawData;
			}
			throw new ApplicationException("Could not find encrypted section");
		}

		uint GetEncryptedHeaderOffset_vXX(IList<ImageSectionHeader> sections) {
			for (int i = sections.Count - 1; i >= 0; i--) {
				var section = sections[i];
				if (GetSectionNameHash(section) == (uint)key1)
					return section.PointerToRawData;
			}
			throw new ApplicationException("Could not find encrypted section");
		}

		static byte[] GetStreamsBuffer(MyPEImage peImage) {
			var memStream = new MemoryStream();
			var writer = new BinaryWriter(memStream);
			var reader = peImage.Reader;
			foreach (var mdStream in peImage.Metadata.AllStreams) {
				reader.Position = (uint)mdStream.StartOffset;
				writer.Write(reader.ReadBytes((int)(mdStream.EndOffset - mdStream.StartOffset)));
			}
			return memStream.ToArray();
		}

		protected static ulong CalcChecksum(byte[] data) {
			var sum = DeobUtils.Md5Sum(data);
			return BitConverter.ToUInt64(sum, 0) ^ BitConverter.ToUInt64(sum, 8);
		}

		static uint GetSectionNameHash(ImageSectionHeader section) {
			uint hash = 0;
			foreach (var c in section.Name)
				hash += c;
			return hash;
		}

		protected byte[] Decrypt(byte[] encrypted, byte[] iv, byte[] streamsBuffer) {
			var decrypted = DeobUtils.AesDecrypt(encrypted, DeobUtils.Sha256Sum(streamsBuffer), iv);
			var sha = SHA512.Create();
			var hash = sha.ComputeHash(streamsBuffer);
			for (int i = 0; i < decrypted.Length; i += 64) {
				int j;
				for (j = 0; j < 64 && i + j < decrypted.Length; j++)
					decrypted[i + j] ^= (byte)(hash[j] ^ key6);
				hash = sha.ComputeHash(decrypted, i, j);
			}
			return decrypted;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Confuser/ProxyCallFixer.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Confuser {
	class ProxyCallFixer : ProxyCallFixer2, IVersionProvider, IDisposable {
		MethodDefAndDeclaringTypeDict<ProxyCreatorInfo> methodToInfo = new MethodDefAndDeclaringTypeDict<ProxyCreatorInfo>();
		FieldDefAndDeclaringTypeDict<List<MethodDef>> fieldToMethods = new FieldDefAndDeclaringTypeDict<List<MethodDef>>();
		string ourAsm;
		ConfuserVersion version = ConfuserVersion.Unknown;
		byte[] fileData;
		X86Emulator x86emu;
		ushort callvirtChar;
		bool foundNewobjProxy;

		enum ConfuserVersion {
			Unknown,
			v10_r42915,
			v10_r42919,
			v10_r48717,
			v11_r50378,
			v12_r54564,
			v13_r55346,
			v13_r55604,
			v14_r58564,
			v14_r58802,
			v14_r58857,
			v16_r66631,
			v16_r70489,
			v17_r73479,
			v17_r73740_normal,
			v17_r73740_native,
			v17_r74708_normal,
			v17_r74708_native,
			v18_r75367_normal,
			v18_r75367_native,
			v18_r75369_normal,
			v18_r75369_native,
			v19_r76101_normal,
			v19_r76101_native,
			v19_r78363_normal,
			v19_r78363_native,
			v19_r78963_normal_Newobj,
			v19_r78963_native_Newobj,
		}

		enum ProxyCreatorType {
			None,
			CallOrCallvirt,
			Newobj,
		}

		class ProxyCreatorInfo {
			public readonly MethodDef creatorMethod;
			public readonly ProxyCreatorType proxyCreatorType;
			public readonly ConfuserVersion version;
			public readonly uint magic;
			public readonly MethodDef nativeMethod;
			public readonly ushort callvirtChar;

			public ProxyCreatorInfo(MethodDef creatorMethod, ProxyCreatorType proxyCreatorType, ConfuserVersion version, uint magic, MethodDef nativeMethod, ushort callvirtChar) {
				this.creatorMethod = creatorMethod;
				this.proxyCreatorType = proxyCreatorType;
				this.version = version;
				this.magic = magic;
				this.nativeMethod = nativeMethod;
				this.callvirtChar = callvirtChar;
			}
		}

		class DelegateInitInfo {
			public readonly byte[] data;
			public readonly FieldDef field;
			public readonly MethodDef creatorMethod;

			public DelegateInitInfo(FieldDef field, MethodDef creatorMethod) {
				this.field = field;
				this.creatorMethod = creatorMethod;
			}

			public DelegateInitInfo(string data, FieldDef field, MethodDef creatorMethod) {
				this.data = Convert.FromBase64String(data);
				this.field = field;
				this.creatorMethod = creatorMethod;
			}
		}

		protected override bool ProxyCallIsObfuscated => true;

		public IEnumerable<FieldDef> Fields {
			get {
				var fields = new List<FieldDef>(fieldToMethods.GetKeys());
				var type = DotNetUtils.GetModuleType(module);
				if (fields.Count > 0 && type != null) {
					foreach (var field in type.Fields) {
						var fieldType = field.FieldType.TryGetTypeDef();
						if (fieldType != null && delegateTypesDict.ContainsKey(fieldType))
							fields.Add(field);
					}
				}
				return fields;
			}
		}

		public override IEnumerable<Tuple<MethodDef, string>> OtherMethods {
			get {
				var list = new List<Tuple<MethodDef, string>>();
				foreach (var info in methodToInfo.GetValues()) {
					list.Add(new Tuple<MethodDef, string> {
						Item1 = info.creatorMethod,
						Item2 = "Delegate creator method",
					});
					list.Add(new Tuple<MethodDef, string> {
						Item1 = info.nativeMethod,
						Item2 = "Calculate RID native method",
					});
				}
				foreach (var methods in fieldToMethods.GetValues()) {
					foreach (var method in methods) {
						list.Add(new Tuple<MethodDef, string> {
							Item1 = method,
							Item2 = "Proxy delegate method",
						});
					}
				}
				return list;
			}
		}

		public ProxyCallFixer(ModuleDefMD module, byte[] fileData)
			: base(module) {
			this.fileData = fileData;
			if (module.Assembly == null)
				ourAsm = " -1-1-1-1-1- , Version=1.2.3.4, Culture=neutral, PublicKeyToken=null";
			else
				ourAsm = module.Assembly.FullName;
		}

		protected override object CheckCctor(TypeDef type, MethodDef cctor) {
			// Here if 1.2 r54564 (almost 1.3) or later

			var fieldToInfo = new FieldDefAndDeclaringTypeDict<DelegateInitInfo>();

			var instrs = cctor.Body.Instructions;
			for (int i = 0; i < instrs.Count - 1; i++) {
				var ldtoken = instrs[i];
				if (ldtoken.OpCode.Code != Code.Ldtoken)
					continue;
				var field = ldtoken.Operand as FieldDef;
				if (field == null || field.DeclaringType != cctor.DeclaringType)
					continue;

				var call = instrs[i + 1];
				if (call.OpCode.Code != Code.Call)
					continue;
				var calledMethod = call.Operand as MethodDef;
				if (calledMethod == null)
					continue;
				if (!IsDelegateCreatorMethod(calledMethod))
					continue;
				var info = methodToInfo.Find(calledMethod);
				if (info == null)
					continue;

				i++;
				fieldToInfo.Add(field, new DelegateInitInfo(field, calledMethod));
			}
			return fieldToInfo.Count == 0 ? null : fieldToInfo;
		}

		protected override void GetCallInfo(object context, FieldDef field, out IMethod calledMethod, out OpCode callOpcode) {
			var info = context as DelegateInitInfo;
			if (info == null) {
				if (context is FieldDefAndDeclaringTypeDict<DelegateInitInfo> fieldToInfo)
					info = fieldToInfo.Find(field);
			}
			if (info == null)
				throw new ApplicationException("Couldn't get the delegate info");
			var creatorInfo = methodToInfo.Find(info.creatorMethod);

			switch (creatorInfo.version) {
			case ConfuserVersion.v10_r42915:
			case ConfuserVersion.v10_r42919:
				GetCallInfo_v10_r42915(info, creatorInfo, out calledMethod, out callOpcode);
				break;

			case ConfuserVersion.v10_r48717:
			case ConfuserVersion.v11_r50378:
			case ConfuserVersion.v12_r54564:
			case ConfuserVersion.v13_r55346:
			case ConfuserVersion.v13_r55604:
			case ConfuserVersion.v14_r58564:
			case ConfuserVersion.v14_r58802:
				GetCallInfo_v10_r48717(info, creatorInfo, out calledMethod, out callOpcode);
				break;

			case ConfuserVersion.v14_r58857:
			case ConfuserVersion.v16_r66631:
			case ConfuserVersion.v16_r70489:
			case ConfuserVersion.v17_r73479:
				GetCallInfo_v14_r58857(info, creatorInfo, out calledMethod, out callOpcode);
				break;

			case ConfuserVersion.v17_r73740_normal:
			case ConfuserVersion.v17_r74708_normal:
				GetCallInfo_v17_r73740_normal(info, creatorInfo, out calledMethod, out callOpcode);
				break;

			case ConfuserVersion.v17_r73740_native:
			case ConfuserVersion.v17_r74708_native:
				GetCallInfo_v17_r73740_native(info, creatorInfo, out calledMethod, out callOpcode);
				break;

			case ConfuserVersion.v18_r75367_normal:
			case ConfuserVersion.v18_r75369_normal:
			case ConfuserVersion.v19_r76101_normal:
			case ConfuserVersion.v19_r78363_normal:
			case ConfuserVersion.v19_r78963_normal_Newobj:
				GetCallInfo_v18_r75367_normal(info, creatorInfo, out calledMethod, out callOpcode);
				break;

			case ConfuserVersion.v18_r75367_native:
			case ConfuserVersion.v18_r75369_native:
			case ConfuserVersion.v19_r76101_native:
			case ConfuserVersion.v19_r78363_native:
			case ConfuserVersion.v19_r78963_native_Newobj:
				GetCallInfo_v18_r75367_native(info, creatorInfo, out calledMethod, out callOpcode);
				break;

			default:
				throw new ApplicationException("Unknown version");
			}

			if (calledMethod == null) {
				Logger.w("Could not find real method. Proxy field: {0:X8}", info.field.MDToken.ToInt32());
				errors++;
			}
		}

		void GetCallInfo_v10_r42915(DelegateInitInfo info, ProxyCreatorInfo creatorInfo, out IMethod calledMethod, out OpCode callOpcode) {
			var reader = new BinaryReader(new MemoryStream(info.data));

			bool isCallvirt = false;
			if (creatorInfo.proxyCreatorType == ProxyCreatorType.CallOrCallvirt)
				isCallvirt = reader.ReadBoolean();

			var asmRef = ReadAssemblyNameReference(reader);
			// If < 1.0 r42919, then high byte is 06, else it's cleared.
			uint token = (reader.ReadUInt32() & 0x00FFFFFF) | 0x06000000;
			if (reader.BaseStream.Position != reader.BaseStream.Length)
				throw new ApplicationException("Extra data");

			if (asmRef.FullName == ourAsm)
				calledMethod = module.ResolveToken(token) as IMethod;
			else
				calledMethod = CreateMethodReference(asmRef, token);

			callOpcode = GetCallOpCode(creatorInfo, isCallvirt);
		}

		void GetCallInfo_v10_r48717(DelegateInitInfo info, ProxyCreatorInfo creatorInfo, out IMethod calledMethod, out OpCode callOpcode) {
			bool isNew = creatorInfo.version == ConfuserVersion.v14_r58802;

			int offs = creatorInfo.proxyCreatorType == ProxyCreatorType.CallOrCallvirt ? 2 : 1;
			if (isNew)
				offs--;
			int callvirtOffs = isNew ? 0 : 1;

			// This is an obfuscator bug. Field names are stored in the #Strings heap,
			// and strings in that heap are UTF8 zero terminated strings, but Confuser
			// can generate names with zeros in them. This was fixed in 1.4 58857.
			if (offs + 2 > info.field.Name.String.Length) {
				calledMethod = null;
				callOpcode = OpCodes.Call;
				return;
			}

			uint token = BitConverter.ToUInt32(Encoding.Unicode.GetBytes(info.field.Name.String.ToCharArray(), offs, 2), 0) ^ creatorInfo.magic;
			uint table = token >> 24;
			if (table != 0 && table != 6 && table != 0x0A && table != 0x2B)
				throw new ApplicationException("Invalid method token");

			// 1.3 r55346 now correctly uses method reference tokens and finally fixed the old
			// bug of using methoddef tokens to reference external methods.
			if (isNew || info.field.Name.String[0] == (char)1 || table != 0x06)
				calledMethod = module.ResolveToken(token) as IMethod;
			else {
				var asmRef = module.ResolveAssemblyRef((uint)info.field.Name.String[0] - 2 + 1);
				calledMethod = CreateMethodReference(asmRef, token);
			}

			bool isCallvirt = false;
			if (creatorInfo.proxyCreatorType == ProxyCreatorType.CallOrCallvirt && info.field.Name.String[callvirtOffs] == '\r')
				isCallvirt = true;
			callOpcode = GetCallOpCode(creatorInfo, isCallvirt);
		}

		void GetCallInfo_v14_r58857(DelegateInitInfo info, ProxyCreatorInfo creatorInfo, out IMethod calledMethod, out OpCode callOpcode) {
			int offs = creatorInfo.proxyCreatorType == ProxyCreatorType.CallOrCallvirt ? 1 : 0;
			var nameInfo = DecryptFieldName(info.field.Name.String);

			uint token = BitConverter.ToUInt32(nameInfo, offs) ^ creatorInfo.magic;
			uint table = token >> 24;
			if (table != 6 && table != 0x0A && table != 0x2B)
				throw new ApplicationException("Invalid method token");

			calledMethod = module.ResolveToken(token) as IMethod;

			bool isCallvirt = false;
			if (creatorInfo.proxyCreatorType == ProxyCreatorType.CallOrCallvirt && nameInfo[0] == '\r')
				isCallvirt = true;
			callOpcode = GetCallOpCode(creatorInfo, isCallvirt);
		}

		static byte[] DecryptFieldName(string name) {
			var chars = new char[name.Length];
			for (int i = 0; i < chars.Length; i++)
				chars[i] = (char)((byte)name[i] ^ i);
			return Convert.FromBase64CharArray(chars, 0, chars.Length);
		}

		void Extract_v17_r73740(ProxyCreatorInfo creatorInfo, byte[] nameInfo, out uint arg, out uint table, out bool isCallvirt) {
			switch (creatorInfo.proxyCreatorType) {
			case ProxyCreatorType.CallOrCallvirt:
				arg = BitConverter.ToUInt32(nameInfo, 1);
				table = (uint)(nameInfo[0] & 0x7F) << 24;
				isCallvirt = (nameInfo[0] & 0x80) != 0;
				break;

			case ProxyCreatorType.Newobj:
				arg = BitConverter.ToUInt32(nameInfo, 0);
				table = (uint)nameInfo[4] << 24;
				isCallvirt = false;
				break;

			default:
				throw new ApplicationException("Invalid creator type");
			}
		}

		void GetCallInfo_v17_r73740_normal(DelegateInitInfo info, ProxyCreatorInfo creatorInfo, out IMethod calledMethod, out OpCode callOpcode) {
			var nameInfo = DecryptFieldName(info.field.Name.String);
			Extract_v17_r73740(creatorInfo, nameInfo, out uint arg, out uint table, out bool isCallvirt);
			uint token = (arg ^ creatorInfo.magic) | table;

			calledMethod = module.ResolveToken((int)token) as IMethod;
			callOpcode = GetCallOpCode(creatorInfo, isCallvirt);
		}

		void GetCallInfo_v17_r73740_native(DelegateInitInfo info, ProxyCreatorInfo creatorInfo, out IMethod calledMethod, out OpCode callOpcode) {
			var nameInfo = DecryptFieldName(info.field.Name.String);
			Extract_v17_r73740(creatorInfo, nameInfo, out uint arg, out uint table, out bool isCallvirt);
			if (x86emu == null)
				x86emu = new X86Emulator(fileData);
			uint token = x86emu.Emulate((uint)creatorInfo.nativeMethod.RVA, arg) | table;

			calledMethod = module.ResolveToken((int)token) as IMethod;
			callOpcode = GetCallOpCode(creatorInfo, isCallvirt);
		}

		void GetCallInfo_v18_r75367_normal(DelegateInitInfo info, ProxyCreatorInfo creatorInfo, out IMethod calledMethod, out OpCode callOpcode) =>
			GetCallInfo_v18_r75367(info, creatorInfo, out calledMethod, out callOpcode, (creatorInfo2, magic) => creatorInfo2.magic ^ magic);

		void GetCallInfo_v18_r75367_native(DelegateInitInfo info, ProxyCreatorInfo creatorInfo, out IMethod calledMethod, out OpCode callOpcode) =>
			GetCallInfo_v18_r75367(info, creatorInfo, out calledMethod, out callOpcode, (creatorInfo2, magic) => {
				if (x86emu == null)
					x86emu = new X86Emulator(fileData);
				return x86emu.Emulate((uint)creatorInfo2.nativeMethod.RVA, magic);
			});

		void GetCallInfo_v18_r75367(DelegateInitInfo info, ProxyCreatorInfo creatorInfo, out IMethod calledMethod, out OpCode callOpcode, Func<ProxyCreatorInfo, uint, uint> getRid) {
			var sig = module.ReadBlob(info.field.MDToken.Raw);
			int len = sig.Length;
			uint magic = (uint)((sig[len - 2] << 24) | (sig[len - 3] << 16) | (sig[len - 5] << 8) | sig[len - 6]);
			uint rid = getRid(creatorInfo, magic);
			int token = (sig[len - 7] << 24) | (int)rid;
			uint table = (uint)token >> 24;
			if (table != 6 && table != 0x0A && table != 0x2B)
				throw new ApplicationException("Invalid method token");
			calledMethod = module.ResolveToken(token) as IMethod;
			callOpcode = GetCallOpCode(creatorInfo, info.field);
		}

		static OpCode GetCallOpCode(ProxyCreatorInfo info, FieldDef field) {
			switch (info.proxyCreatorType) {
			case ProxyCreatorType.CallOrCallvirt:
				if (field.Name.String.Length > 0 && field.Name.String[0] == info.callvirtChar)
					return OpCodes.Callvirt;
				return OpCodes.Call;

			case ProxyCreatorType.Newobj:
				return OpCodes.Newobj;

			default: throw new NotSupportedException();
			}
		}

		// A method token is not a stable value so this method can fail to return the correct method!
		// There's nothing I can do about that. It's an obfuscator bug. It was fixed in 1.3 r55346.
		IMethod CreateMethodReference(AssemblyRef asmRef, uint methodToken) {
			var asm = module.Context.AssemblyResolver.Resolve(asmRef, module);
			if (asm == null)
				return null;

			var method = ((ModuleDefMD)asm.ManifestModule).ResolveToken(methodToken) as MethodDef;
			if (method == null)
				return null;

			return module.Import(method);
		}

		AssemblyRef ReadAssemblyNameReference(BinaryReader reader) {
			var name = ReadString(reader);
			var version = new Version(reader.ReadInt16(), reader.ReadInt16(), reader.ReadInt16(), reader.ReadInt16());
			var culture = ReadString(reader);
			byte[] pkt = reader.ReadBoolean() ? reader.ReadBytes(8) : null;
			return module.UpdateRowId(new AssemblyRefUser(name, version, pkt == null ? null : new PublicKeyToken(pkt), culture));
		}

		static string ReadString(BinaryReader reader) {
			int len = reader.ReadByte();
			var bytes = new byte[len];
			for (int i = 0; i < len; i++)
				bytes[i] = (byte)(reader.ReadByte() ^ len);
			return Encoding.UTF8.GetString(bytes);
		}

		static OpCode GetCallOpCode(ProxyCreatorInfo info, bool isCallvirt) {
			switch (info.proxyCreatorType) {
			case ProxyCreatorType.Newobj:
				return OpCodes.Newobj;

			case ProxyCreatorType.CallOrCallvirt:
				return isCallvirt ? OpCodes.Callvirt : OpCodes.Call;

			default: throw new NotImplementedException();
			}
		}

		public void FindDelegateCreator(ISimpleDeobfuscator simpleDeobfuscator) {
			var type = DotNetUtils.GetModuleType(module);
			if (type == null)
				return;
			foreach (var method in type.Methods) {
				if (method.Body == null || !method.IsStatic || !method.IsAssembly)
					continue;
				var theVersion = ConfuserVersion.Unknown;

				if (DotNetUtils.IsMethod(method, "System.Void", "(System.String,System.RuntimeFieldHandle)"))
					theVersion = ConfuserVersion.v10_r42915;
				else if (DotNetUtils.IsMethod(method, "System.Void", "(System.RuntimeFieldHandle)"))
					theVersion = ConfuserVersion.v10_r48717;
				else
					continue;

				var proxyType = GetProxyCreatorType(method, simpleDeobfuscator, out int tmpVer);
				if (proxyType == ProxyCreatorType.None)
					continue;
				if (proxyType == ProxyCreatorType.Newobj)
					foundNewobjProxy = true;

				simpleDeobfuscator.Deobfuscate(method, SimpleDeobfuscatorFlags.DisableConstantsFolderExtraInstrs);
				MethodDef nativeMethod = null;
				if (FindMagic_v14_r58564(method, out uint magic)) {
					if (!DotNetUtils.CallsMethod(method, "System.Byte[] System.Convert::FromBase64String(System.String)")) {
						if (!IsMethodCreator_v14_r58802(method, proxyType))
							theVersion = ConfuserVersion.v14_r58564;
						else
							theVersion = ConfuserVersion.v14_r58802;
					}
					else if (DotNetUtils.CallsMethod(method, "System.Reflection.Module System.Reflection.MemberInfo::get_Module()"))
						theVersion = ConfuserVersion.v17_r73479;
					else if (proxyType != ProxyCreatorType.CallOrCallvirt || !HasFieldReference(method, "System.Reflection.Emit.OpCode System.Reflection.Emit.OpCodes::Castclass"))
						theVersion = ConfuserVersion.v14_r58857;
					else if (proxyType == ProxyCreatorType.CallOrCallvirt && DotNetUtils.CallsMethod(method, "System.Void System.Reflection.Emit.DynamicMethod::.ctor(System.String,System.Type,System.Type[],System.Boolean)"))
						theVersion = ConfuserVersion.v16_r66631;
					else if (proxyType == ProxyCreatorType.CallOrCallvirt)
						theVersion = ConfuserVersion.v16_r70489;
				}
				else if (!DotNetUtils.CallsMethod(method, "System.Byte[] System.Convert::FromBase64String(System.String)") &&
					DotNetUtils.CallsMethod(method, "System.Reflection.MethodBase System.Reflection.Module::ResolveMethod(System.Int32)")) {
					if (proxyType == ProxyCreatorType.CallOrCallvirt && !FindCallvirtChar(method, out callvirtChar))
						continue;
					if ((nativeMethod = FindNativeMethod_v18_r75367(method)) != null)
						theVersion = proxyType != ProxyCreatorType.CallOrCallvirt || callvirtChar == 9 ? ConfuserVersion.v18_r75367_native : ConfuserVersion.v18_r75369_native;
					else if (FindMagic_v18_r75367(method, out magic))
						theVersion = proxyType != ProxyCreatorType.CallOrCallvirt || callvirtChar == 9 ? ConfuserVersion.v18_r75367_normal : ConfuserVersion.v18_r75369_normal;
					else if (FindMagic_v19_r76101(method, out magic))
						CommonCheckVersion19(method, true, tmpVer, ref theVersion);
					else if ((nativeMethod = FindNativeMethod_v19_r76101(method)) != null)
						CommonCheckVersion19(method, false, tmpVer, ref theVersion);
					else {
						if (proxyType == ProxyCreatorType.CallOrCallvirt && !DotNetUtils.CallsMethod(method, "System.Int32 System.String::get_Length()"))
							theVersion = ConfuserVersion.v11_r50378;
						int numCalls = ConfuserUtils.CountCalls(method, "System.Byte[] System.Text.Encoding::GetBytes(System.Char[],System.Int32,System.Int32)");
						if (numCalls == 2)
							theVersion = ConfuserVersion.v12_r54564;
						if (!DotNetUtils.CallsMethod(method, "System.Reflection.Assembly System.Reflection.Assembly::Load(System.Reflection.AssemblyName)"))
							theVersion = ConfuserVersion.v13_r55346;
						if (DotNetUtils.CallsMethod(method, "System.Void System.Runtime.CompilerServices.RuntimeHelpers::RunClassConstructor(System.RuntimeTypeHandle)"))
							theVersion = ConfuserVersion.v13_r55604;
					}
				}
				else if (Is_v17_r73740(method)) {
					if (DotNetUtils.CallsMethod(method, "System.Boolean System.Type::get_IsArray()")) {
						if ((nativeMethod = FindNativeMethod_v17_r73740(method)) != null)
							theVersion = ConfuserVersion.v17_r74708_native;
						else if (FindMagic_v17_r73740(method, out magic))
							theVersion = ConfuserVersion.v17_r74708_normal;
						else
							continue;
					}
					else {
						if ((nativeMethod = FindNativeMethod_v17_r73740(method)) != null)
							theVersion = ConfuserVersion.v17_r73740_native;
						else if (FindMagic_v17_r73740(method, out magic))
							theVersion = ConfuserVersion.v17_r73740_normal;
						else
							continue;
					}
				}
				else if (theVersion == ConfuserVersion.v10_r42915) {
					if (DeobUtils.HasInteger(method, 0x06000000))
						theVersion = ConfuserVersion.v10_r42919;
				}

				SetDelegateCreatorMethod(method);
				methodToInfo.Add(method, new ProxyCreatorInfo(method, proxyType, theVersion, magic, nativeMethod, callvirtChar));
				version = (ConfuserVersion)Math.Max((int)version, (int)theVersion);
			}
		}

		static bool CommonCheckVersion19(MethodDef method, bool isNormal, int tmpProxyVer, ref ConfuserVersion theVersion) {
			if (tmpProxyVer == 1) {
				theVersion = isNormal ? ConfuserVersion.v19_r76101_normal : ConfuserVersion.v19_r76101_native;
				return true;
			}
			else if (tmpProxyVer == 2) {
				if (!CheckCtorProxyType_v19_r78963(method))
					theVersion = isNormal ? ConfuserVersion.v19_r78363_normal : ConfuserVersion.v19_r78363_native;
				else
					theVersion = isNormal ? ConfuserVersion.v19_r78963_normal_Newobj : ConfuserVersion.v19_r78963_native_Newobj;
				return true;
			}

			return false;
		}

		static bool HasFieldReference(MethodDef method, string fieldFullName) {
			foreach (var instr in method.Body.Instructions) {
				var field = instr.Operand as IField;
				if (field == null)
					continue;
				if (field.FullName == fieldFullName)
					return true;
			}
			return false;
		}

		static bool IsMethodCreator_v14_r58802(MethodDef method, ProxyCreatorType proxyType) {
			int index = GetFieldNameIndex(method);
			if (index < 0)
				throw new ApplicationException("Could not find field name index");
			switch (proxyType) {
			case ProxyCreatorType.Newobj:
				if (index == 1)
					return false;
				if (index == 0)
					return true;
				break;

			case ProxyCreatorType.CallOrCallvirt:
				if (index == 2)
					return false;
				if (index == 1)
					return true;
				break;

			default: throw new ApplicationException("Invalid proxy creator type");
			}

			throw new ApplicationException("Could not find field name index");
		}

		static int GetFieldNameIndex(MethodDef method) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count; i++) {
				i = ConfuserUtils.FindCallMethod(instrs, i, Code.Callvirt, "System.Byte[] System.Text.Encoding::GetBytes(System.Char[],System.Int32,System.Int32)");
				if (i < 0)
					break;
				if (i < 2)
					continue;
				var ldci4 = instrs[i - 2];
				if (!ldci4.IsLdcI4())
					continue;

				return ldci4.GetLdcI4Value();
			}
			return -1;
		}

		static bool FindMagic_v19_r76101(MethodDef method, out uint magic) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 7; i++) {
				var ldci4_1 = instrs[i];
				if (!ldci4_1.IsLdcI4() || ldci4_1.GetLdcI4Value() != 24)
					continue;
				if (instrs[i + 1].OpCode.Code != Code.Shl)
					continue;
				if (instrs[i + 2].OpCode.Code != Code.Or)
					continue;
				if (!instrs[i + 3].IsStloc())
					continue;
				if (!instrs[i + 4].IsLdloc())
					continue;
				if (!instrs[i + 5].IsLdloc())
					continue;
				var ldci4_2 = instrs[i + 6];
				if (!ldci4_2.IsLdcI4())
					continue;
				if (instrs[i + 7].OpCode.Code != Code.Xor)
					continue;

				magic = (uint)ldci4_2.GetLdcI4Value();
				return true;
			}
			magic = 0;
			return false;
		}

		static MethodDef FindNativeMethod_v19_r76101(MethodDef method) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 6; i++) {
				var ldci4 = instrs[i];
				if (!ldci4.IsLdcI4() || ldci4.GetLdcI4Value() != 24)
					continue;
				if (instrs[i + 1].OpCode.Code != Code.Shl)
					continue;
				if (instrs[i + 2].OpCode.Code != Code.Or)
					continue;
				if (!instrs[i + 3].IsStloc())
					continue;
				if (!instrs[i + 4].IsLdloc())
					continue;
				if (!instrs[i + 5].IsLdloc())
					continue;
				var call = instrs[i + 6];
				if (call.OpCode.Code != Code.Call)
					continue;
				var calledMethod = call.Operand as MethodDef;
				if (calledMethod == null || calledMethod.Body != null || !calledMethod.IsNative)
					continue;

				return calledMethod;
			}
			return null;
		}

		static bool FindMagic_v18_r75367(MethodDef method, out uint magic) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count; i++) {
				i = ConfuserUtils.FindCallMethod(instrs, i, Code.Callvirt, "System.Reflection.Module System.Reflection.MemberInfo::get_Module()");
				if (i < 0 || i + 3 >= instrs.Count)
					break;

				if (!instrs[i + 1].IsLdloc())
					continue;
				var ldci4 = instrs[i + 2];
				if (!ldci4.IsLdcI4())
					continue;
				if (instrs[i+3].OpCode.Code != Code.Xor)
					continue;

				magic = (uint)ldci4.GetLdcI4Value();
				return true;
			}
			magic = 0;
			return false;
		}

		static MethodDef FindNativeMethod_v18_r75367(MethodDef method) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count; i++) {
				i = ConfuserUtils.FindCallMethod(instrs, i, Code.Callvirt, "System.Reflection.Module System.Reflection.MemberInfo::get_Module()");
				if (i < 0 || i + 2 >= instrs.Count)
					break;

				if (!instrs[i + 1].IsLdloc())
					continue;

				var call = instrs[i + 2];
				if (call.OpCode.Code != Code.Call)
					continue;
				var calledMethod = call.Operand as MethodDef;
				if (calledMethod == null || calledMethod.Body != null || !calledMethod.IsNative)
					continue;

				return calledMethod;
			}
			return null;
		}

		static bool FindMagic_v17_r73740(MethodDef method, out uint magic) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count; i++) {
				int index = ConfuserUtils.FindCallMethod(instrs, i, Code.Call, "System.Int32 System.BitConverter::ToInt32(System.Byte[],System.Int32)");
				if (index < 0)
					break;
				if (index < 1 || index + 2 >= instrs.Count)
					continue;

				if (!instrs[index - 1].IsLdcI4())
					continue;
				var ldci4 = instrs[index + 1];
				if (!ldci4.IsLdcI4())
					continue;
				if (instrs[index + 2].OpCode.Code != Code.Xor)
					continue;

				magic = (uint)ldci4.GetLdcI4Value();
				return true;
			}
			magic = 0;
			return false;
		}

		static MethodDef FindNativeMethod_v17_r73740(MethodDef method) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count; i++) {
				int index = ConfuserUtils.FindCallMethod(instrs, i, Code.Call, "System.Int32 System.BitConverter::ToInt32(System.Byte[],System.Int32)");
				if (index < 0)
					break;
				if (index < 1 || index + 1 >= instrs.Count)
					continue;

				if (!instrs[index - 1].IsLdcI4())
					continue;
				var call = instrs[index + 1];
				if (call.OpCode.Code != Code.Call)
					continue;
				var calledMethod = call.Operand as MethodDef;
				if (calledMethod == null || calledMethod.Body != null || !calledMethod.IsNative)
					continue;

				return calledMethod;
			}
			return null;
		}

		static bool Is_v17_r73740(MethodDef method) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count; i++) {
				int index = ConfuserUtils.FindCallMethod(instrs, i, Code.Callvirt, "System.Reflection.MethodBase System.Reflection.Module::ResolveMethod(System.Int32)");
				if (index < 0)
					break;
				if (index < 3)
					continue;

				index -= 3;
				var ldci4 = instrs[index];
				if (!ldci4.IsLdcI4() || ldci4.GetLdcI4Value() != 24)
					continue;
				if (instrs[index + 1].OpCode.Code != Code.Shl)
					continue;
				if (instrs[index + 2].OpCode.Code != Code.Or)
					continue;

				return true;
			}
			return false;
		}

		static bool FindMagic_v14_r58564(MethodDef method, out uint magic) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count; i++) {
				int index = ConfuserUtils.FindCallMethod(instrs, i, Code.Call, "System.Int32 System.BitConverter::ToInt32(System.Byte[],System.Int32)");
				if (index < 0)
					break;
				int index2 = ConfuserUtils.FindCallMethod(instrs, i, Code.Callvirt, "System.Reflection.MethodBase System.Reflection.Module::ResolveMethod(System.Int32)");
				if (index2 < 0 || index2 - index != 3)
					continue;
				var ldci4 = instrs[index + 1];
				if (!ldci4.IsLdcI4())
					continue;
				if (instrs[index + 2].OpCode.Code != Code.Xor)
					continue;

				magic = (uint)ldci4.GetLdcI4Value();
				return true;
			}
			magic = 0;
			return false;
		}

		static ProxyCreatorType GetProxyCreatorType(MethodDef method, ISimpleDeobfuscator simpleDeobfuscator, out int version) {
			var type = GetProxyCreatorTypeV1(method);
			if (type != ProxyCreatorType.None) {
				version = 1;
				return type;
			}

			simpleDeobfuscator.Deobfuscate(method);

			type = GetProxyCreatorTypeV2(method);
			if (type != ProxyCreatorType.None) {
				version = 2;
				return type;
			}

			version = 0;
			return ProxyCreatorType.None;
		}

		// <= 1.9 r78342 (refs to System.Reflection.Emit.OpCodes)
		static ProxyCreatorType GetProxyCreatorTypeV1(MethodDef method) {
			foreach (var instr in method.Body.Instructions) {
				var field = instr.Operand as IField;
				if (field == null)
					continue;
				switch (field.FullName) {
				case "System.Reflection.Emit.OpCode System.Reflection.Emit.OpCodes::Call":
				case "System.Reflection.Emit.OpCode System.Reflection.Emit.OpCodes::Callvirt":
					return ProxyCreatorType.CallOrCallvirt;

				case "System.Reflection.Emit.OpCode System.Reflection.Emit.OpCodes::Newobj":
					return ProxyCreatorType.Newobj;
				}
			}
			return ProxyCreatorType.None;
		}

		// >= 1.9 r78363 (no refs to System.Reflection.Emit.OpCodes)
		static ProxyCreatorType GetProxyCreatorTypeV2(MethodDef method) {
			if (!DeobUtils.HasInteger(method, 0x2A))
				return ProxyCreatorType.None;
			if (CheckCtorProxyTypeV2(method))
				return ProxyCreatorType.Newobj;
			if (CheckCallProxyTypeV2(method))
				return ProxyCreatorType.CallOrCallvirt;
			return ProxyCreatorType.None;
		}

		static bool CheckCtorProxyTypeV2(MethodDef method) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 3; i++) {
				var ldci4 = instrs[i];
				if (!ldci4.IsLdcI4() || ldci4.GetLdcI4Value() != 2)
					continue;
				if (instrs[i + 1].OpCode.Code != Code.Mul)
					continue;
				ldci4 = instrs[i + 2];
				if (!ldci4.IsLdcI4() || ldci4.GetLdcI4Value() != 0x73)
					continue;
				if (instrs[i + 3].OpCode.Code != Code.Stelem_I1)
					continue;

				return true;
			}
			return false;
		}

		static bool CheckCallProxyTypeV2(MethodDef method) =>
			DeobUtils.HasInteger(method, 0x28) &&
			DeobUtils.HasInteger(method, 0x6F);

		// r78963 adds a 'castclass' opcode to the generated code. This code assumes
		// CheckCtorProxyTypeV2() has returned true.
		static bool CheckCtorProxyType_v19_r78963(MethodDef method) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 2; i++) {
				if (instrs[i].OpCode.Code != Code.Add)
					continue;
				var ldci4 = instrs[i + 1];
				if (!ldci4.IsLdcI4() || ldci4.GetLdcI4Value() != 0x74)
					continue;
				if (instrs[i + 2].OpCode.Code != Code.Stelem_I1)
					continue;

				return true;
			}
			return false;
		}

		public new void Find() {
			if (delegateCreatorMethods.Count == 0)
				return;
			var cctor = DotNetUtils.GetModuleTypeCctor(module);
			if (cctor == null)
				return;

			Logger.v("Finding all proxy delegates");

			var delegateInfos = CreateDelegateInitInfos(cctor);
			fieldToMethods = CreateFieldToMethodsDictionary(cctor.DeclaringType);
			if (delegateInfos.Count < fieldToMethods.Count)
				throw new ApplicationException("Missing proxy delegates");
			var delegateToFields = new Dictionary<TypeDef, List<FieldDef>>();
			foreach (var field in fieldToMethods.GetKeys()) {
				if (!delegateToFields.TryGetValue(field.FieldType.TryGetTypeDef(), out var list))
					delegateToFields[field.FieldType.TryGetTypeDef()] = list = new List<FieldDef>();
				list.Add(field);
			}

			foreach (var kv in delegateToFields) {
				var type = kv.Key;
				var fields = kv.Value;

				Logger.v("Found proxy delegate: {0} ({1:X8})", Utils.RemoveNewlines(type), type.MDToken.ToInt32());
				RemovedDelegateCreatorCalls++;

				Logger.Instance.Indent();
				foreach (var field in fields) {
					var proxyMethods = fieldToMethods.Find(field);
					if (proxyMethods == null)
						continue;
					var info = delegateInfos.Find(field);
					if (info == null)
						throw new ApplicationException("Missing proxy info");

					GetCallInfo(info, field, out var calledMethod, out var callOpcode);

					if (calledMethod == null)
						continue;
					foreach (var proxyMethod in proxyMethods) {
						Add(proxyMethod, new DelegateInfo(field, calledMethod, callOpcode));
						Logger.v("Field: {0}, Opcode: {1}, Method: {2} ({3:X8})",
									Utils.RemoveNewlines(field.Name),
									callOpcode,
									Utils.RemoveNewlines(calledMethod),
									calledMethod.MDToken.ToUInt32());
					}
				}
				Logger.Instance.DeIndent();
				delegateTypesDict[type] = true;
			}

			// 1.2 r54564 (almost 1.3) now moves method proxy init code to the delegate cctors
			Find2();
		}

		FieldDefAndDeclaringTypeDict<DelegateInitInfo> CreateDelegateInitInfos(MethodDef method) {
			switch (version) {
			case ConfuserVersion.v10_r42915:
			case ConfuserVersion.v10_r42919:
				return CreateDelegateInitInfos_v10_r42915(method);
			default:
				return CreateDelegateInitInfos_v10_r48717(method);
			}
		}

		FieldDefAndDeclaringTypeDict<DelegateInitInfo> CreateDelegateInitInfos_v10_r42915(MethodDef method) {
			var infos = new FieldDefAndDeclaringTypeDict<DelegateInitInfo>();
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 2; i++) {
				var ldstr = instrs[i];
				if (ldstr.OpCode.Code != Code.Ldstr)
					continue;
				var info = ldstr.Operand as string;
				if (info == null)
					continue;

				var ldtoken = instrs[i + 1];
				if (ldtoken.OpCode.Code != Code.Ldtoken)
					continue;
				var delegateField = ldtoken.Operand as FieldDef;
				if (delegateField == null)
					continue;
				var delegateType = delegateField.FieldType.TryGetTypeDef();
				if (!DotNetUtils.DerivesFromDelegate(delegateType))
					continue;

				var call = instrs[i + 2];
				if (call.OpCode.Code != Code.Call)
					continue;
				var delegateCreatorMethod = call.Operand as MethodDef;
				if (delegateCreatorMethod == null || !IsDelegateCreatorMethod(delegateCreatorMethod))
					continue;

				infos.Add(delegateField, new DelegateInitInfo(info, delegateField, delegateCreatorMethod));
				i += 2;
			}
			return infos;
		}

		FieldDefAndDeclaringTypeDict<DelegateInitInfo> CreateDelegateInitInfos_v10_r48717(MethodDef method) {
			var infos = new FieldDefAndDeclaringTypeDict<DelegateInitInfo>();
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 1; i++) {
				var ldtoken = instrs[i];
				if (ldtoken.OpCode.Code != Code.Ldtoken)
					continue;
				var delegateField = ldtoken.Operand as FieldDef;
				if (delegateField == null)
					continue;
				var delegateType = delegateField.FieldType.TryGetTypeDef();
				if (!DotNetUtils.DerivesFromDelegate(delegateType))
					continue;

				var call = instrs[i + 1];
				if (call.OpCode.Code != Code.Call)
					continue;
				var delegateCreatorMethod = call.Operand as MethodDef;
				if (delegateCreatorMethod == null || !IsDelegateCreatorMethod(delegateCreatorMethod))
					continue;

				infos.Add(delegateField, new DelegateInitInfo(delegateField, delegateCreatorMethod));
				i += 1;
			}
			return infos;
		}

		static FieldDefAndDeclaringTypeDict<List<MethodDef>> CreateFieldToMethodsDictionary(TypeDef type) {
			var dict = new FieldDefAndDeclaringTypeDict<List<MethodDef>>();
			foreach (var method in type.Methods) {
				if (!method.IsStatic || method.Body == null || method.Name == ".cctor")
					continue;
				var delegateField = GetDelegateField(method);
				if (delegateField == null)
					continue;
				var methods = dict.Find(delegateField);
				if (methods == null)
					dict.Add(delegateField, methods = new List<MethodDef>());
				methods.Add(method);
			}
			return dict;
		}

		static FieldDef GetDelegateField(MethodDef method) {
			if (method == null || method.Body == null)
				return null;

			FieldDef field = null;
			bool foundInvoke = false;
			foreach (var instr in method.Body.Instructions) {
				if (instr.OpCode.Code == Code.Ldsfld) {
					var field2 = instr.Operand as FieldDef;
					if (field2 == null || field2.DeclaringType != method.DeclaringType)
						continue;
					if (field != null)
						return null;
					if (!DotNetUtils.DerivesFromDelegate(field2.FieldType.TryGetTypeDef()))
						continue;
					field = field2;
				}
				else if (instr.OpCode.Code == Code.Call || instr.OpCode.Code == Code.Callvirt) {
					var calledMethod = instr.Operand as IMethod;
					foundInvoke |= calledMethod != null && calledMethod.Name == "Invoke";
				}
			}
			return foundInvoke ? field : null;
		}

		static bool FindCallvirtChar(MethodDef method, out ushort callvirtChar) {
			var instrs = method.Body.Instructions;
			for (int index = 0; index < instrs.Count; index++) {
				index = ConfuserUtils.FindCallMethod(instrs, index, Code.Callvirt, "System.Char System.String::get_Chars(System.Int32)");
				if (index < 0)
					break;

				index++;
				if (index >= instrs.Count)
					break;

				var ldci4 = instrs[index];
				if (!ldci4.IsLdcI4())
					continue;
				callvirtChar = (ushort)ldci4.GetLdcI4Value();
				return true;
			}
			callvirtChar = 0;
			return false;
		}

		public void CleanUp() {
			if (!Detected)
				return;
			var cctor = DotNetUtils.GetModuleTypeCctor(module);
			if (cctor == null)
				return;
			cctor.Body.Instructions.Clear();
			cctor.Body.Instructions.Add(Instruction.Create(OpCodes.Ret));
		}

		public bool GetRevisionRange(out int minRev, out int maxRev) {
			switch (version) {
			case ConfuserVersion.Unknown:
				minRev = maxRev = 0;
				return false;

			case ConfuserVersion.v10_r42915:
				minRev = 42915;
				maxRev = 42917;
				return true;

			case ConfuserVersion.v10_r42919:
				minRev = 42919;
				maxRev = 48509;
				return true;

			case ConfuserVersion.v10_r48717:
				minRev = 48717;
				maxRev = 54431;
				return true;

			case ConfuserVersion.v11_r50378:
				minRev = 50378;
				maxRev = 54431;
				return true;

			case ConfuserVersion.v12_r54564:
				minRev = 54564;
				maxRev = 54574;
				return true;

			case ConfuserVersion.v13_r55346:
				minRev = 55346;
				maxRev = 55346;
				return true;

			case ConfuserVersion.v13_r55604:
				minRev = 55604;
				maxRev = 58446;
				return true;

			case ConfuserVersion.v14_r58564:
				minRev = 58564;
				maxRev = 58741;
				return true;

			case ConfuserVersion.v14_r58802:
				minRev = 58802;
				maxRev = 58852;
				return true;

			case ConfuserVersion.v14_r58857:
				minRev = 58857;
				maxRev = 73477;
				return true;

			case ConfuserVersion.v16_r66631:
				minRev = 66631;
				maxRev = 69666;
				return true;

			case ConfuserVersion.v16_r70489:
				minRev = 70489;
				maxRev = 73477;
				return true;

			case ConfuserVersion.v17_r73479:
				minRev = 73479;
				maxRev = 73605;
				return true;

			case ConfuserVersion.v17_r73740_normal:
			case ConfuserVersion.v17_r73740_native:
				minRev = 73740;
				maxRev = 74637;
				return true;

			case ConfuserVersion.v17_r74708_normal:
			case ConfuserVersion.v17_r74708_native:
				minRev = 74708;
				maxRev = 75349;
				return true;

			case ConfuserVersion.v18_r75367_normal:
			case ConfuserVersion.v18_r75367_native:
				minRev = 75367;
				maxRev = 75926;
				return true;

			case ConfuserVersion.v18_r75369_normal:
			case ConfuserVersion.v18_r75369_native:
				minRev = 75369;
				maxRev = 75926;
				return true;

			case ConfuserVersion.v19_r76101_normal:
			case ConfuserVersion.v19_r76101_native:
				minRev = 76101;
				maxRev = 78342;
				return true;

			case ConfuserVersion.v19_r78363_normal:
			case ConfuserVersion.v19_r78363_native:
				minRev = 78363;
				// We can only detect the r78963 version if a method ctor proxy is used.
				// If it's not used, then maxRev must be the same maxRev as in the next case.
				// If a method ctor proxy is found, then we know that rev <= 78962.
				if (foundNewobjProxy)
					maxRev = 78962;
				else
					maxRev = int.MaxValue;
				return true;

			case ConfuserVersion.v19_r78963_normal_Newobj:
			case ConfuserVersion.v19_r78963_native_Newobj:
				minRev = 78963;
				maxRev = int.MaxValue;
				return true;

			default: throw new ApplicationException("Invalid version");
			}
		}

		public void Dispose() {
			if (x86emu != null)
				x86emu.Dispose();
			x86emu = null;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Confuser/ResourceDecrypter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.IO;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Confuser {
	class ResourceDecrypter : IVersionProvider {
		ModuleDefMD module;
		ISimpleDeobfuscator simpleDeobfuscator;
		MethodDef handler;
		MethodDef installMethod;
		TypeDef lzmaType;
		EmbeddedResource resource;
		Dictionary<FieldDef, bool> fields = new Dictionary<FieldDef, bool>();
		byte key0, key1;
		ConfuserVersion version = ConfuserVersion.Unknown;

		enum ConfuserVersion {
			Unknown,
			v14_r55802,
			v17_r73404,
			v17_r73822,
			v18_r75367,
			v18_r75369,
			v19_r77172,
		}

		public IEnumerable<FieldDef> Fields => fields.Keys;
		public MethodDef Handler => handler;
		public TypeDef LzmaType => lzmaType;
		public bool Detected => handler != null;

		public ResourceDecrypter(ModuleDefMD module, ISimpleDeobfuscator simpleDeobfuscator) {
			this.module = module;
			this.simpleDeobfuscator = simpleDeobfuscator;
		}

		public void Find() {
			if (CheckMethod(DotNetUtils.GetModuleTypeCctor(module)))
				return;
		}

		bool CheckMethod(MethodDef method) {
			if (method == null || method.Body == null)
				return false;
			if (!DotNetUtils.CallsMethod(method, "System.Void System.AppDomain::add_ResourceResolve(System.ResolveEventHandler)"))
				return false;
			simpleDeobfuscator.Deobfuscate(method, SimpleDeobfuscatorFlags.Force | SimpleDeobfuscatorFlags.DisableConstantsFolderExtraInstrs);
			fields.Clear();

			var tmpHandler = GetHandler(method);
			if (tmpHandler == null || tmpHandler.DeclaringType != method.DeclaringType)
				return false;

			var tmpResource = FindResource(tmpHandler);
			if (tmpResource == null)
				return false;

			simpleDeobfuscator.Deobfuscate(tmpHandler, SimpleDeobfuscatorFlags.Force | SimpleDeobfuscatorFlags.DisableConstantsFolderExtraInstrs);
			var tmpVersion = ConfuserVersion.Unknown;
			if (DotNetUtils.CallsMethod(tmpHandler, "System.Object System.AppDomain::GetData(System.String)")) {
				if (!DotNetUtils.CallsMethod(tmpHandler, "System.Void System.Buffer::BlockCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)")) {
					if (!FindKey0Key1_v14_r55802(tmpHandler, out key0, out key1))
						return false;
					tmpVersion = ConfuserVersion.v14_r55802;
				}
				else if (FindKey0_v17_r73404(tmpHandler, out key0) && FindKey1_v17_r73404(tmpHandler, out key1))
					tmpVersion = ConfuserVersion.v17_r73404;
				else
					return false;
			}
			else {
				if (AddFields(FindFields(tmpHandler, method.DeclaringType)) != 1)
					return false;

				if (FindKey0_v17_r73404(tmpHandler, out key0) && FindKey1_v17_r73404(tmpHandler, out key1))
					tmpVersion = ConfuserVersion.v17_r73822;
				else if (FindKey0_v18_r75367(tmpHandler, out key0) && FindKey1_v17_r73404(tmpHandler, out key1))
					tmpVersion = ConfuserVersion.v18_r75367;
				else if (FindKey0_v18_r75369(tmpHandler, out key0) && FindKey1_v18_r75369(tmpHandler, out key1)) {
					lzmaType = ConfuserUtils.FindLzmaType(tmpHandler);
					if (lzmaType == null)
						tmpVersion = ConfuserVersion.v18_r75369;
					else
						tmpVersion = ConfuserVersion.v19_r77172;
				}
				else
					return false;
			}

			handler = tmpHandler;
			resource = tmpResource;
			installMethod = method;
			version = tmpVersion;
			return true;
		}

		static MethodDef GetHandler(MethodDef method) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 2; i++) {
				var ldftn = instrs[i];
				if (ldftn.OpCode.Code != Code.Ldftn)
					continue;
				var handler = ldftn.Operand as MethodDef;
				if (handler == null)
					continue;

				var newobj = instrs[i + 1];
				if (newobj.OpCode.Code != Code.Newobj)
					continue;

				var callvirt = instrs[i + 2];
				if (callvirt.OpCode.Code != Code.Callvirt)
					continue;
				var calledMethod = callvirt.Operand as IMethod;
				if (calledMethod == null)
					continue;
				if (calledMethod.FullName != "System.Void System.AppDomain::add_ResourceResolve(System.ResolveEventHandler)")
					continue;

				return handler;
			}
			return null;
		}

		int AddFields(IEnumerable<FieldDef> moreFields) {
			int count = 0;
			foreach (var field in moreFields) {
				if (AddField(field))
					count++;
			}
			return count;
		}

		bool AddField(FieldDef field) {
			if (field == null)
				return false;
			if (fields.ContainsKey(field))
				return false;
			fields[field] = true;
			return true;
		}

		static IEnumerable<FieldDef> FindFields(MethodDef method, TypeDef declaringType) {
			var fields = new List<FieldDef>();
			foreach (var instr in method.Body.Instructions) {
				if (instr.Operand is FieldDef field && field.DeclaringType == declaringType)
					fields.Add(field);
			}
			return fields;
		}

		EmbeddedResource FindResource(MethodDef method) => DotNetUtils.GetResource(module, DotNetUtils.GetCodeStrings(method)) as EmbeddedResource;

		static bool FindKey0_v18_r75367(MethodDef method, out byte key0) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count; i++) {
				i = ConfuserUtils.FindCallMethod(instrs, i, Code.Callvirt, "System.Int32 System.IO.Stream::Read(System.Byte[],System.Int32,System.Int32)");
				if (i < 0)
					break;
				if (i + 3 >= instrs.Count)
					break;

				if (instrs[i + 1].OpCode.Code != Code.Pop)
					continue;
				var ldci4 = instrs[i + 2];
				if (!ldci4.IsLdcI4())
					continue;
				if (!instrs[i + 3].IsStloc())
					continue;

				key0 = (byte)ldci4.GetLdcI4Value();
				return true;
			}

			key0 = 0;
			return false;
		}

		static bool FindKey0_v18_r75369(MethodDef method, out byte key0) {
			var instrs = method.Body.Instructions;
			for (int index = 0; index < instrs.Count; index++) {
				index = ConfuserUtils.FindCallMethod(instrs, index, Code.Callvirt, "System.Int32 System.IO.Stream::Read(System.Byte[],System.Int32,System.Int32)");
				if (index < 0)
					break;

				if (index + 4 >= instrs.Count)
					break;
				index++;

				if (instrs[index++].OpCode.Code != Code.Pop)
					continue;
				var ldci4 = instrs[index++];
				if (!ldci4.IsLdcI4())
					continue;
				if (instrs[index++].OpCode.Code != Code.Conv_U1)
					continue;
				if (!instrs[index++].IsStloc())
					continue;

				key0 = (byte)ldci4.GetLdcI4Value();
				return true;
			}

			key0 = 0;
			return false;
		}

		static bool FindKey1_v18_r75369(MethodDef method, out byte key1) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 4; i++) {
				int index = i;
				if (!instrs[index++].IsLdloc())
					continue;
				var ldci4_1 = instrs[index++];
				if (!ldci4_1.IsLdcI4())
					continue;
				if (instrs[index++].OpCode.Code != Code.Mul)
					continue;
				var ldci4_2 = instrs[index++];
				if (!ldci4_2.IsLdcI4() || ldci4_2.GetLdcI4Value() != 0x100)
					continue;
				if (instrs[index++].OpCode.Code != Code.Rem)
					continue;

				key1 = (byte)ldci4_1.GetLdcI4Value();
				return true;
			}

			key1 = 0;
			return false;
		}

		static bool FindKey0Key1_v14_r55802(MethodDef method, out byte key0, out byte key1) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 5; i++) {
				if (!instrs[i].IsLdcI4())
					continue;
				if (instrs[i + 1].OpCode.Code != Code.Add)
					continue;
				if (instrs[i + 2].OpCode.Code != Code.Ldelem_U1)
					continue;
				var ldci4_1 = instrs[i + 3];
				if (!ldci4_1.IsLdcI4())
					continue;
				if (instrs[i + 4].OpCode.Code != Code.Xor)
					continue;
				var ldci4_2 = instrs[i + 5];
				if (!ldci4_2.IsLdcI4())
					continue;

				key0 = (byte)ldci4_1.GetLdcI4Value();
				key1 = (byte)ldci4_2.GetLdcI4Value();
				return true;
			}
			key0 = 0;
			key1 = 0;
			return false;
		}

		static bool FindKey0_v17_r73404(MethodDef method, out byte key) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 3; i++) {
				int index = ConfuserUtils.FindCallMethod(instrs, i, Code.Callvirt, "System.Byte[] System.IO.BinaryReader::ReadBytes(System.Int32)");
				if (index < 0)
					break;
				if (index + 3 >= instrs.Count)
					break;

				if (!instrs[index + 1].IsStloc())
					continue;
				var ldci4 = instrs[index + 2];
				if (!ldci4.IsLdcI4())
					continue;
				if (!instrs[index + 3].IsStloc())
					continue;

				key = (byte)ldci4.GetLdcI4Value();
				return true;
			}
			key = 0;
			return false;
		}

		static bool FindKey1_v17_r73404(MethodDef method, out byte key) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 3; i++) {
				var ldci4_1 = instrs[i];
				if (!ldci4_1.IsLdcI4())
					continue;
				if (instrs[i + 1].OpCode.Code != Code.Mul)
					continue;
				var ldci4_2 = instrs[i + 2];
				if (!ldci4_2.IsLdcI4() || ldci4_2.GetLdcI4Value() != 0x100)
					continue;
				if (instrs[i + 3].OpCode.Code != Code.Rem)
					continue;

				key = (byte)ldci4_1.GetLdcI4Value();
				return true;
			}
			key = 0;
			return false;
		}

		public EmbeddedResource MergeResources() {
			if (resource == null)
				return null;
			DeobUtils.DecryptAndAddResources(module, resource.Name.String, () => DecryptResource());
			var tmpResource = resource;
			resource = null;
			return tmpResource;
		}

		byte[] Decompress(byte[] compressed) {
			if (lzmaType != null)
				return ConfuserUtils.SevenZipDecompress(compressed);
			return DeobUtils.Inflate(compressed, true);
		}

		byte[] DecryptXor(byte[] data) {
			byte k = key0;
			for (int i = 0; i < data.Length; i++) {
				data[i] ^= k;
				k *= key1;
			}
			return data;
		}

		byte[] DecryptResource() {
			switch (version) {
			case ConfuserVersion.v14_r55802: return Decrypt_v14_r55802();
			case ConfuserVersion.v17_r73404: return Decrypt_v17_r73404();
			case ConfuserVersion.v17_r73822: return Decrypt_v17_r73404();
			case ConfuserVersion.v18_r75367: return Decrypt_v18_r75367();
			case ConfuserVersion.v18_r75369: return Decrypt_v18_r75367();
			case ConfuserVersion.v19_r77172: return Decrypt_v18_r75367();
			default: throw new ApplicationException("Unknown version");
			}
		}

		byte[] Decrypt_v14_r55802() {
			var reader = new BinaryReader(new MemoryStream(Decompress(resource.CreateReader().ToArray())));
			var encypted = reader.ReadBytes(reader.ReadInt32());
			if ((encypted.Length & 1) != 0)
				throw new ApplicationException("Invalid resource data length");
			var decrypted = new byte[encypted.Length / 2];
			for (int i = 0; i < decrypted.Length; i++)
				decrypted[i] = (byte)((encypted[i * 2 + 1] ^ key0) * key1 + (encypted[i * 2] ^ key0));
			reader = new BinaryReader(new MemoryStream(Decompress(decrypted)));
			return reader.ReadBytes(reader.ReadInt32());
		}

		byte[] Decrypt_v17_r73404() {
			var reader = new BinaryReader(new MemoryStream(Decompress(resource.CreateReader().ToArray())));
			return DecryptXor(reader.ReadBytes(reader.ReadInt32()));
		}

		byte[] Decrypt_v18_r75367() {
			var encrypted = DecryptXor(resource.CreateReader().ToArray());
			var reader = new BinaryReader(new MemoryStream(Decompress(encrypted)));
			return reader.ReadBytes(reader.ReadInt32());
		}

		public void Deobfuscate(Blocks blocks) {
			if (blocks.Method != installMethod)
				return;
			ConfuserUtils.RemoveResourceHookCode(blocks, handler);
		}

		public bool GetRevisionRange(out int minRev, out int maxRev) {
			switch (version) {
			case ConfuserVersion.Unknown:
				minRev = maxRev = 0;
				return false;

			case ConfuserVersion.v14_r55802:
				minRev = 55802;
				maxRev = 72989;
				return true;

			case ConfuserVersion.v17_r73404:
				minRev = 73404;
				maxRev = 73791;
				return true;

			case ConfuserVersion.v17_r73822:
				minRev = 73822;
				maxRev = 75349;
				return true;

			case ConfuserVersion.v18_r75367:
				minRev = 75367;
				maxRev = 75367;
				return true;

			case ConfuserVersion.v18_r75369:
				minRev = 75369;
				maxRev = 77124;
				return true;

			case ConfuserVersion.v19_r77172:
				minRev = 77172;
				maxRev = int.MaxValue;
				return true;

			default: throw new ApplicationException("Invalid version");
			}
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Confuser/StringDecrypter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Text;
using dnlib.IO;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Confuser {
	class StringDecrypter : IVersionProvider {
		ModuleDefMD module;
		MethodDef decryptMethod;
		EmbeddedResource resource;
		uint magic1, magic2, key1;
		DataReader reader;
		ConfuserVersion version = ConfuserVersion.Unknown;
		Decrypter decrypter;

		enum ConfuserVersion {
			Unknown,
			v10_r42915,
			v10_r48832,
			v11_r49299,
			v13_r55604_safe,
			v14_r58802_safe,
			v14_r58802_dynamic,
			// The string decrypter "confusion" was disabled from 1.5 r60785 and it was
			// replaced by the constants "confusion".
		}

		abstract class Decrypter {
			protected StringDecrypter stringDecrypter;

			protected Decrypter(StringDecrypter stringDecrypter) => this.stringDecrypter = stringDecrypter;

			public abstract string Decrypt(MethodDef caller, int magic);
		}

		class Decrypter_v10_r42915 : Decrypter {
			int? key;

			public Decrypter_v10_r42915(StringDecrypter stringDecrypter) : this(stringDecrypter, null) { }
			public Decrypter_v10_r42915(StringDecrypter stringDecrypter, int? key) : base(stringDecrypter) => this.key = key;

			public override string Decrypt(MethodDef caller, int magic) {
				var reader = stringDecrypter.reader;
				reader.Position = (uint)((caller.MDToken.ToInt32() ^ magic) - stringDecrypter.magic1);
				int len = reader.ReadInt32() ^ (int)~stringDecrypter.magic2;
				var bytes = reader.ReadBytes(len);
				var rand = new Random(key == null ? caller.MDToken.ToInt32() : key.Value);

				int mask = 0;
				for (int i = 0; i < bytes.Length; i++) {
					byte b = bytes[i];
					bytes[i] = (byte)(b ^ (rand.Next() & mask));
					mask += b;
				}
				return Encoding.UTF8.GetString(bytes);
			}
		}

		class Decrypter_v10_r48832 : Decrypter {
			PolyConstantsReader constReader;

			public Decrypter_v10_r48832(StringDecrypter stringDecrypter)
				: base(stringDecrypter) {
			}

			public override string Decrypt(MethodDef caller, int magic) {
				var reader = stringDecrypter.reader;
				reader.Position = (uint)((caller.MDToken.ToInt32() ^ magic) - stringDecrypter.magic1);
				int len = reader.ReadInt32() ^ (int)~stringDecrypter.magic2;
				var rand = new Random(caller.MDToken.ToInt32());

				var instrs = stringDecrypter.decryptMethod.Body.Instructions;
				constReader = new PolyConstantsReader(instrs, false);
				int polyIndex = ConfuserUtils.FindCallMethod(instrs, 0, Code.Callvirt, "System.Int64 System.IO.BinaryReader::ReadInt64()");
				if (polyIndex < 0)
					throw new ApplicationException("Could not find start of decrypt code");

				var decrypted = new byte[len];
				for (int i = 0; i < len; i += 8) {
					constReader.Arg = reader.ReadInt64();
					int index = polyIndex;
					if (!constReader.GetInt64(ref index, out long val) || instrs[index].OpCode.Code != Code.Conv_I8)
						throw new ApplicationException("Could not get string int64 value");
					Array.Copy(BitConverter.GetBytes(val ^ rand.Next()), 0, decrypted, i, Math.Min(8, len - i));
				}

				return Encoding.Unicode.GetString(decrypted);
			}
		}

		class Decrypter_v11_r49299 : Decrypter {
			public Decrypter_v11_r49299(StringDecrypter stringDecrypter)
				: base(stringDecrypter) {
			}

			public override string Decrypt(MethodDef caller, int magic) {
				var reader = stringDecrypter.reader;
				reader.Position = (uint)((caller.MDToken.ToInt32() ^ magic) - stringDecrypter.magic1);
				int len = reader.ReadInt32() ^ (int)~stringDecrypter.magic2;
				var decrypted = new byte[len];

				if (!FindPolyStartEndIndexes(out int startIndex, out int endIndex))
					throw new ApplicationException("Could not get start/end indexes");

				var constReader = new Arg64ConstantsReader(stringDecrypter.decryptMethod.Body.Instructions, false);
				ConfuserUtils.DecryptCompressedInt32Data(constReader, startIndex, endIndex, ref reader, decrypted);
				return Encoding.Unicode.GetString(decrypted);
			}

			bool FindPolyStartEndIndexes(out int startIndex, out int endIndex) {
				startIndex = 0;
				endIndex = 0;

				var local = FindLocal(stringDecrypter.decryptMethod);
				if (local == null)
					return false;

				if ((endIndex = FindEndIndex(stringDecrypter.decryptMethod)) < 0)
					return false;

				if ((startIndex = FindStartIndex(stringDecrypter.decryptMethod, endIndex)) < 0)
					return false;

				return true;
			}

			static Local FindLocal(MethodDef method) {
				var instrs = method.Body.Instructions;
				for (int i = 0; i < instrs.Count - 3; i++) {
					if (instrs[i].OpCode.Code != Code.And)
						continue;
					if (instrs[i + 1].OpCode.Code != Code.Shl)
						continue;
					if (instrs[i + 2].OpCode.Code != Code.Or)
						continue;
					if (!instrs[i + 3].IsStloc())
						continue;
					return instrs[i + 3].GetLocal(method.Body.Variables);
				}
				return null;
			}

			static int FindEndIndex(MethodDef method) {
				var instrs = method.Body.Instructions;
				for (int i = 0; i < instrs.Count - 5; i++) {
					if (instrs[i].OpCode.Code != Code.Conv_U1)
						continue;
					if (instrs[i + 1].OpCode.Code != Code.Stelem_I1)
						continue;
					if (!instrs[i + 2].IsLdloc())
						continue;
					if (!instrs[i + 3].IsLdcI4())
						continue;
					if (instrs[i + 4].OpCode.Code != Code.Add)
						continue;
					if (!instrs[i + 5].IsStloc())
						continue;
					return i;
				}
				return -1;
			}

			static int FindStartIndex(MethodDef method, int endIndex) {
				var instrs = method.Body.Instructions;
				for (int i = endIndex; i >= 0; i--) {
					var instr = instrs[i];
					if (instr.OpCode.FlowControl != FlowControl.Next)
						break;
					if (instr.OpCode.Code == Code.Conv_I8)
						return i;
				}
				return -1;
			}
		}

		class PolyConstantsReader : ConstantsReader {
			long arg;

			public long Arg {
				get => arg;
				set => arg = value;
			}

			public PolyConstantsReader(IList<Instruction> instrs, bool emulateConvInstrs)
				: base(instrs, emulateConvInstrs) {
			}

			protected override bool ProcessInstructionInt64(ref int index, Stack<ConstantInfo<long>> stack) {
				int i = index;

				if (instructions[i].IsLdloc()) {
					i++;
					if (i >= instructions.Count)
						return false;
				}
				var callvirt = instructions[i];
				if (callvirt.OpCode.Code != Code.Callvirt)
					return false;
				var calledMethod = callvirt.Operand as IMethod;
				if (calledMethod == null || calledMethod.FullName != "System.Int64 System.IO.BinaryReader::ReadInt64()")
					return false;

				stack.Push(new ConstantInfo<long>(index, arg));
				index = i + 1;
				return true;
			}
		}

		public EmbeddedResource Resource => resource;
		public MethodDef Method => decryptMethod;
		public bool Detected => decryptMethod != null;
		public StringDecrypter(ModuleDefMD module) => this.module = module;

		static string[] requiredLocals = new string[] {
			"System.Byte[]",
			"System.IO.BinaryReader",
			"System.Reflection.Assembly",
		};
		public void Find(ISimpleDeobfuscator simpleDeobfuscator) {
			var type = DotNetUtils.GetModuleType(module);
			if (type == null)
				return;
			foreach (var method in type.Methods) {
				if (!method.IsStatic || method.Body == null)
					continue;
				if (!DotNetUtils.IsMethod(method, "System.String", "(System.Int32)"))
					continue;
				var localTypes = new LocalTypes(method);
				if (!localTypes.All(requiredLocals))
					continue;

				simpleDeobfuscator.Deobfuscate(method);

				bool foundOldMagic1;
				if (FindMagic1(method, out magic1))
					foundOldMagic1 = true;
				else if (FindNewMagic1(method, out magic1))
					foundOldMagic1 = false;
				else
					continue;
				if (!FindMagic2(method, out magic2))
					continue;

				version = ConfuserVersion.Unknown;
				if (DotNetUtils.CallsMethod(method, "System.Text.Encoding System.Text.Encoding::get_UTF8()")) {
					if (foundOldMagic1) {
						if (DotNetUtils.CallsMethod(method, "System.Object System.AppDomain::GetData(System.String)"))
							version = ConfuserVersion.v13_r55604_safe;
						else
							version = ConfuserVersion.v10_r42915;
					}
					else {
						if (!FindSafeKey1(method, out key1))
							continue;
						version = ConfuserVersion.v14_r58802_safe;
					}
				}
				else if (!localTypes.Exists("System.Random")) {
					if (foundOldMagic1)
						version = ConfuserVersion.v11_r49299;
					else
						version = ConfuserVersion.v14_r58802_dynamic;
				}
				else if (localTypes.Exists("System.Collections.Generic.Dictionary`2<System.Int32,System.String>"))
					version = ConfuserVersion.v10_r48832;
				if (version == ConfuserVersion.Unknown)
					continue;

				decryptMethod = method;
				break;
			}
		}

		EmbeddedResource FindResource(MethodDef method) => DotNetUtils.GetResource(module, DotNetUtils.GetCodeStrings(method)) as EmbeddedResource;

		static bool FindMagic1(MethodDef method, out uint magic) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count; i++) {
				int index = ConfuserUtils.FindCallMethod(instrs, i, Code.Callvirt, "System.Byte[] System.IO.BinaryReader::ReadBytes(System.Int32)");
				if (index < 0)
					break;
				if (index < 4)
					continue;

				index -= 4;
				if (!instrs[index].IsLdarg())
					continue;
				if (instrs[index + 1].OpCode.Code != Code.Xor)
					continue;
				var ldci4 = instrs[index + 2];
				if (!ldci4.IsLdcI4())
					continue;
				if (instrs[index + 3].OpCode.Code != Code.Sub)
					continue;

				magic = (uint)ldci4.GetLdcI4Value();
				return true;
			}
			magic = 0;
			return false;
		}

		static bool FindNewMagic1(MethodDef method, out uint magic) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 4; i++) {
				if (instrs[i].OpCode.Code != Code.Ldarg_0)
					continue;
				if (instrs[i + 1].OpCode.Code != Code.Xor)
					continue;
				var ldci4 = instrs[i + 2];
				if (!ldci4.IsLdcI4())
					continue;
				if (instrs[i + 3].OpCode.Code != Code.Sub)
					continue;
				if (!instrs[i + 4].IsStloc())
					continue;

				magic = (uint)ldci4.GetLdcI4Value();
				return true;
			}
			magic = 0;
			return false;
		}

		static bool FindMagic2(MethodDef method, out uint magic) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count; i++) {
				int index = ConfuserUtils.FindCallMethod(instrs, i, Code.Callvirt, "System.UInt32 System.IO.BinaryReader::ReadUInt32()");
				if (index < 0)
					break;
				if (index + 4 >= instrs.Count)
					continue;

				if (instrs[index + 1].OpCode.Code != Code.Not)
					continue;
				var ldci4 = instrs[index + 2];
				if (!ldci4.IsLdcI4())
					continue;
				if (instrs[index + 3].OpCode.Code != Code.Xor)
					continue;
				if (!instrs[index + 4].IsStloc())
					continue;

				magic = (uint)ldci4.GetLdcI4Value();
				return true;
			}
			magic = 0;
			return false;
		}

		static bool FindSafeKey1(MethodDef method, out uint key) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count; i++) {
				int index = ConfuserUtils.FindCallMethod(instrs, i, Code.Newobj, "System.Void System.Random::.ctor(System.Int32)");
				if (index < 0)
					break;
				if (index == 0)
					continue;

				var ldci4 = instrs[index - 1];
				if (!ldci4.IsLdcI4())
					continue;

				key = (uint)ldci4.GetLdcI4Value();
				return true;
			}
			key = 0;
			return false;
		}

		public void Initialize() {
			if (decryptMethod == null)
				return;

			resource = FindResource(decryptMethod);
			if (resource == null)
				throw new ApplicationException("Could not find encrypted strings resource");
			reader = ByteArrayDataReaderFactory.CreateReader(DeobUtils.Inflate(resource.CreateReader().ToArray(), true));

			switch (version) {
			case ConfuserVersion.v10_r42915:
			case ConfuserVersion.v13_r55604_safe:
				decrypter = new Decrypter_v10_r42915(this);
				break;

			case ConfuserVersion.v10_r48832:
				decrypter = new Decrypter_v10_r48832(this);
				break;

			case ConfuserVersion.v11_r49299:
			case ConfuserVersion.v14_r58802_dynamic:
				decrypter = new Decrypter_v11_r49299(this);
				break;

			case ConfuserVersion.v14_r58802_safe:
				decrypter = new Decrypter_v10_r42915(this, (int)key1);
				break;

			default:
				throw new ApplicationException("Invalid version");
			}
		}

		public string Decrypt(MethodDef caller, int magic) => decrypter.Decrypt(caller, magic);

		public bool GetRevisionRange(out int minRev, out int maxRev) {
			switch (version) {
			case ConfuserVersion.Unknown:
				minRev = maxRev = 0;
				return false;

			case ConfuserVersion.v10_r42915:
				minRev = 42915;
				maxRev = 48771;
				return true;

			case ConfuserVersion.v10_r48832:
				minRev = 48832;
				maxRev = 49238;
				return true;

			case ConfuserVersion.v11_r49299:
				minRev = 49299;
				maxRev = 58741;
				return true;

			case ConfuserVersion.v13_r55604_safe:
				minRev = 55604;
				maxRev = 58741;
				return true;

			case ConfuserVersion.v14_r58802_safe:
			case ConfuserVersion.v14_r58802_dynamic:
				minRev = 58802;
				maxRev = 60408;
				return true;

			default: throw new ApplicationException("Invalid version");
			}
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Confuser/Unpacker.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.IO;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;
using SevenZip.Compression.LZMA;

namespace de4dot.code.deobfuscators.Confuser {
	class RealAssemblyInfo {
		public AssemblyDef realAssembly;
		public uint entryPointToken;
		public ModuleKind kind;
		public string moduleName;

		public RealAssemblyInfo(AssemblyDef realAssembly, uint entryPointToken, ModuleKind kind) {
			this.realAssembly = realAssembly;
			this.entryPointToken = entryPointToken;
			this.kind = kind;
			moduleName = realAssembly.Name.String + DeobUtils.GetExtension(kind);
		}
	}

	class EmbeddedAssemblyInfo {
		public readonly byte[] data;
		public string asmFullName;
		public string asmSimpleName;
		public string extension;
		public ModuleKind kind;
		public readonly EmbeddedResource resource;
		public RealAssemblyInfo realAssemblyInfo;

		public EmbeddedAssemblyInfo(EmbeddedResource resource, byte[] data, string asmFullName, ModuleKind kind) {
			this.resource = resource;
			this.data = data;
			this.asmFullName = asmFullName;
			asmSimpleName = Utils.GetAssemblySimpleName(asmFullName);
			this.kind = kind;
			extension = DeobUtils.GetExtension(kind);
		}

		public override string ToString() => asmFullName;
	}

	class Unpacker : IVersionProvider {
		ModuleDefMD module;
		EmbeddedResource mainAsmResource;
		uint key0/*, key1*/;
		uint entryPointToken;
		ConfuserVersion version = ConfuserVersion.Unknown;
		MethodDef asmResolverMethod;

		enum ConfuserVersion {
			Unknown,
			v10_r42915,
			v10_r48717,
			v14_r57778,
			v14_r58564,
			v14_r58802,
			v14_r58852,
			v15_r60785,
			v17_r73404,
			v17_r73477,
			v17_r73566,
			v17_r75076,
			v18_r75184,
			v18_r75367,
			v19_r77172,
		}

		public bool Detected => mainAsmResource != null;

		public Unpacker(ModuleDefMD module, Unpacker other) {
			this.module = module;
			if (other != null)
				version = other.version;
		}

		static string[] requiredFields = new string[] {
			 "System.String",
		};
		static string[] requiredEntryPointLocals = new string[] {
			"System.Byte[]",
			"System.IO.BinaryReader",
			"System.IO.Stream",
		};
		public void Find(ISimpleDeobfuscator simpleDeobfuscator, IDeobfuscator deob) {
			var entryPoint = module.EntryPoint;
			if (entryPoint == null)
				return;
			if (!new LocalTypes(entryPoint).All(requiredEntryPointLocals))
				return;
			var type = entryPoint.DeclaringType;
			if (!new FieldTypes(type).All(requiredFields))
				return;

			bool use7zip = type.NestedTypes.Count == 6;
			MethodDef decyptMethod;
			if (use7zip)
				decyptMethod = FindDecryptMethod_7zip(type);
			else
				decyptMethod = FindDecryptMethod_inflate(type);
			if (decyptMethod == null)
				return;

			var theVersion = ConfuserVersion.Unknown;
			var decryptLocals = new LocalTypes(decyptMethod);
			if (decryptLocals.Exists("System.IO.MemoryStream")) {
				if (DotNetUtils.CallsMethod(entryPoint, "System.Void", "(System.String,System.Byte[])"))
					theVersion = ConfuserVersion.v10_r42915;
				else if (DotNetUtils.CallsMethod(entryPoint, "System.Void", "(System.Security.Permissions.PermissionState)"))
					theVersion = ConfuserVersion.v10_r48717;
				else
					theVersion = ConfuserVersion.v14_r57778;
			}
			else
				theVersion = ConfuserVersion.v14_r58564;

			var cctor = type.FindStaticConstructor();
			if (cctor == null)
				return;

			if ((asmResolverMethod = FindAssemblyResolverMethod(entryPoint.DeclaringType)) != null) {
				theVersion = ConfuserVersion.v14_r58802;
				simpleDeobfuscator.Deobfuscate(asmResolverMethod);
				if (!FindKey1(asmResolverMethod, out uint key1))
					return;
			}

			switch (theVersion) {
			case ConfuserVersion.v10_r42915:
			case ConfuserVersion.v10_r48717:
			case ConfuserVersion.v14_r57778:
				break;

			case ConfuserVersion.v14_r58564:
			case ConfuserVersion.v14_r58802:
				simpleDeobfuscator.Deobfuscate(decyptMethod);
				if (FindKey0_v14_r58564(decyptMethod, out key0))
					break;
				if (FindKey0_v14_r58852(decyptMethod, out key0)) {
					if (!decryptLocals.Exists("System.Security.Cryptography.RijndaelManaged")) {
						theVersion = ConfuserVersion.v14_r58852;
						break;
					}
					if (use7zip) {
						if (new LocalTypes(decyptMethod).Exists("System.IO.MemoryStream"))
							theVersion = ConfuserVersion.v17_r75076;
						else if (module.Name == "Stub.exe")
							theVersion = ConfuserVersion.v18_r75184;
						else if (!IsGetLenToPosStateMethodPrivate(type))
							theVersion = ConfuserVersion.v18_r75367;
						else
							theVersion = ConfuserVersion.v19_r77172;
					}
					else if (IsDecryptMethod_v17_r73404(decyptMethod))
						theVersion = ConfuserVersion.v17_r73404;
					else
						theVersion = ConfuserVersion.v15_r60785;
					break;
				}
				throw new ApplicationException("Could not find magic");

			default:
				throw new ApplicationException("Invalid version");
			}

			simpleDeobfuscator.Deobfuscate(cctor);
			simpleDeobfuscator.DecryptStrings(cctor, deob);

			if (FindEntryPointToken(simpleDeobfuscator, cctor, entryPoint, out entryPointToken) && !use7zip) {
				if (DotNetUtils.CallsMethod(asmResolverMethod, "System.Void", "(System.String)"))
					theVersion = ConfuserVersion.v17_r73477;
				else
					theVersion = ConfuserVersion.v17_r73566;
			}

			mainAsmResource = FindResource(cctor);
			if (mainAsmResource == null)
				throw new ApplicationException("Could not find main assembly resource");
			version = theVersion;
		}

		static bool IsGetLenToPosStateMethodPrivate(TypeDef type) {
			foreach (var m in type.Methods) {
				if (!DotNetUtils.IsMethod(m, "System.UInt32", "(System.UInt32)"))
					continue;
				return m.IsPrivate;
			}
			return false;
		}

		bool FindEntryPointToken(ISimpleDeobfuscator simpleDeobfuscator, MethodDef cctor, MethodDef entryPoint, out uint token) {
			token = 0;
			if (!FindBase(cctor, out ulong @base))
				return false;

			var modPowMethod = DotNetUtils.GetMethod(cctor.DeclaringType, "System.UInt64", "(System.UInt64,System.UInt64,System.UInt64)");
			if (modPowMethod == null)
				throw new ApplicationException("Could not find modPow()");

			simpleDeobfuscator.Deobfuscate(entryPoint);
			if (!FindMod(entryPoint, out ulong mod))
				throw new ApplicationException("Could not find modulus");

			token = 0x06000000 | (uint)ModPow(@base, 0x47, mod);
			if ((token >> 24) != 0x06)
				throw new ApplicationException("Illegal entry point token");
			return true;
		}

		static ulong ModPow(ulong @base, ulong pow, ulong mod) {
			ulong m = 1;
			while (pow > 0) {
				if ((pow & 1) != 0)
					m = (m * @base) % mod;
				pow = pow >> 1;
				@base = (@base * @base) % mod;
			}
			return m;
		}

		static bool FindMod(MethodDef method, out ulong mod) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 1; i++) {
				var ldci8 = instrs[i];
				if (ldci8.OpCode.Code != Code.Ldc_I8)
					continue;

				var call = instrs[i + 1];
				if (call.OpCode.Code != Code.Call)
					continue;
				var calledMethod = call.Operand as IMethod;
				if (calledMethod == null)
					continue;
				if (!DotNetUtils.IsMethod(calledMethod, "System.UInt64", "(System.UInt64,System.UInt64,System.UInt64)"))
					continue;

				mod = (ulong)(long)ldci8.Operand;
				return true;
			}
			mod = 0;
			return false;
		}

		static bool FindBase(MethodDef method, out ulong @base) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 2; i++) {
				var ldci8 = instrs[i];
				if (ldci8.OpCode.Code != Code.Ldc_I8)
					continue;
				var stsfld = instrs[i + 1];
				if (stsfld.OpCode.Code != Code.Stsfld)
					continue;
				var field = stsfld.Operand as FieldDef;
				if (field == null || field.DeclaringType != method.DeclaringType)
					continue;
				if (field.FieldType.GetElementType() != ElementType.U8)
					continue;

				@base = (ulong)(long)ldci8.Operand;
				return true;
			}
			@base = 0;
			return false;
		}

		static bool IsDecryptMethod_v17_r73404(MethodDef method) {
			var instrs = method.Body.Instructions;
			if (instrs.Count < 4)
				return false;
			if (!instrs[0].IsLdarg())
				return false;
			if (!IsCallorNewobj(instrs[1]) && !IsCallorNewobj(instrs[2]))
				return false;
			var stloc = instrs[3];
			if (!stloc.IsStloc())
				return false;
			var local = stloc.GetLocal(method.Body.Variables);
			if (local == null || local.Type.FullName != "System.IO.BinaryReader")
				return false;

			return true;
		}

		static bool IsCallorNewobj(Instruction instr) => instr.OpCode.Code == Code.Call || instr.OpCode.Code == Code.Newobj;

		static MethodDef FindAssemblyResolverMethod(TypeDef type) {
			foreach (var method in type.Methods) {
				if (!method.IsStatic || method.Body == null)
					continue;
				if (!DotNetUtils.IsMethod(method, "System.Reflection.Assembly", "(System.Object,System.ResolveEventArgs)"))
					continue;

				return method;
			}
			return null;
		}

		static bool FindKey0_v14_r58564(MethodDef method, out uint key) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 2; i++) {
				if (instrs[i].OpCode.Code != Code.Xor)
					continue;
				var ldci4 = instrs[i + 1];
				if (!ldci4.IsLdcI4())
					continue;
				if (instrs[i + 2].OpCode.Code != Code.Xor)
					continue;

				key = (uint)ldci4.GetLdcI4Value();
				return true;
			}
			key = 0;
			return false;
		}

		static bool FindKey0_v14_r58852(MethodDef method, out uint key) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 3; i++) {
				var ldci4_1 = instrs[i];
				if (!ldci4_1.IsLdcI4())
					continue;
				if (!instrs[i + 1].IsStloc())
					continue;
				var ldci4_2 = instrs[i + 2];
				if (!ldci4_2.IsLdcI4() && ldci4_2.GetLdcI4Value() != 0)
					continue;
				if (!instrs[i + 3].IsStloc())
					continue;

				key = (uint)ldci4_1.GetLdcI4Value();
				return true;
			}
			key = 0;
			return false;
		}

		static bool FindKey1(MethodDef method, out uint key) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 4; i++) {
				if (instrs[i].OpCode.Code != Code.Ldelem_U1)
					continue;
				var ldci4 = instrs[i + 1];
				if (!ldci4.IsLdcI4())
					continue;
				if (instrs[i + 2].OpCode.Code != Code.Xor)
					continue;
				if (!instrs[i + 3].IsLdloc())
					continue;
				if (instrs[i + 4].OpCode.Code != Code.Xor)
					continue;

				key = (uint)ldci4.GetLdcI4Value();
				return true;
			}
			key = 0;
			return false;
		}

		EmbeddedResource FindResource(MethodDef method) => DotNetUtils.GetResource(module, DotNetUtils.GetCodeStrings(method)) as EmbeddedResource;

		static string[] requiredDecryptLocals_inflate = new string[] {
			"System.Byte[]",
			"System.IO.Compression.DeflateStream",
		};
		static MethodDef FindDecryptMethod_inflate(TypeDef type) {
			foreach (var method in type.Methods) {
				if (!method.IsStatic || method.Body == null)
					continue;
				if (!DotNetUtils.IsMethod(method, "System.Byte[]", "(System.Byte[])"))
					continue;
				if (!new LocalTypes(method).All(requiredDecryptLocals_inflate))
					continue;

				return method;
			}
			return null;
		}

		static string[] requiredDecryptLocals_7zip = new string[] {
			"System.Byte[]",
			"System.Int64",
			"System.IO.BinaryReader",
			"System.Security.Cryptography.CryptoStream",
			"System.Security.Cryptography.RijndaelManaged",
		};
		static MethodDef FindDecryptMethod_7zip(TypeDef type) {
			foreach (var method in type.Methods) {
				if (!method.IsStatic || method.Body == null)
					continue;
				if (!DotNetUtils.IsMethod(method, "System.Byte[]", "(System.Byte[])"))
					continue;
				if (!new LocalTypes(method).All(requiredDecryptLocals_7zip))
					continue;

				return method;
			}
			return null;
		}

		public EmbeddedAssemblyInfo UnpackMainAssembly(bool createAssembly) {
			if (mainAsmResource == null)
				return null;
			var info = CreateEmbeddedAssemblyInfo(mainAsmResource, Decrypt(mainAsmResource));

			var asm = module.Assembly;
			if (createAssembly && asm != null && entryPointToken != 0 && info.kind == ModuleKind.NetModule) {
				info.extension = DeobUtils.GetExtension(module.Kind);
				info.kind = module.Kind;

				var realAsm = module.UpdateRowId(new AssemblyDefUser(asm.Name, new Version(0, 0, 0, 0)));
				info.realAssemblyInfo = new RealAssemblyInfo(realAsm, entryPointToken, info.kind);
				if (module.Name != "Stub.exe")
					info.realAssemblyInfo.moduleName = module.Name.String;
				info.asmFullName = realAsm.FullName;
				info.asmSimpleName = realAsm.Name.String;
			}

			return info;
		}

		public List<EmbeddedAssemblyInfo> GetEmbeddedAssemblyInfos() {
			var infos = new List<EmbeddedAssemblyInfo>();
			foreach (var rsrc in module.Resources) {
				var resource = rsrc as EmbeddedResource;
				if (resource == null || resource == mainAsmResource)
					continue;
				try {
					infos.Add(CreateEmbeddedAssemblyInfo(resource, Decrypt(resource)));
				}
				catch {
				}
			}
			return infos;
		}

		static EmbeddedAssemblyInfo CreateEmbeddedAssemblyInfo(EmbeddedResource resource, byte[] data) {
			var mod = ModuleDefMD.Load(data);
			var asmFullName = mod.Assembly != null ? mod.Assembly.FullName : mod.Name.String;
			return new EmbeddedAssemblyInfo(resource, data, asmFullName, mod.Kind);
		}

		byte[] Decrypt(EmbeddedResource resource) {
			var data = resource.CreateReader().ToArray();
			switch (version) {
			case ConfuserVersion.v10_r42915: return Decrypt_v10_r42915(data);
			case ConfuserVersion.v10_r48717: return Decrypt_v10_r42915(data);
			case ConfuserVersion.v14_r57778: return Decrypt_v10_r42915(data);
			case ConfuserVersion.v14_r58564: return Decrypt_v14_r58564(data);
			case ConfuserVersion.v14_r58802: return Decrypt_v14_r58564(data);
			case ConfuserVersion.v14_r58852: return Decrypt_v14_r58852(data);
			case ConfuserVersion.v15_r60785: return Decrypt_v15_r60785(data);
			case ConfuserVersion.v17_r73404: return Decrypt_v17_r73404(data);
			case ConfuserVersion.v17_r73477: return Decrypt_v17_r73404(data);
			case ConfuserVersion.v17_r73566: return Decrypt_v17_r73404(data);
			case ConfuserVersion.v17_r75076: return Decrypt_v17_r75076(data);
			case ConfuserVersion.v18_r75184: return Decrypt_v17_r75076(data);
			case ConfuserVersion.v18_r75367: return Decrypt_v17_r75076(data);
			case ConfuserVersion.v19_r77172: return Decrypt_v17_r75076(data);
			default: throw new ApplicationException("Unknown version");
			}
		}

		byte[] Decrypt_v10_r42915(byte[] data) {
			for (int i = 0; i < data.Length; i++)
				data[i] ^= (byte)(i ^ key0);
			return DeobUtils.Inflate(data, true);
		}

		byte[] Decrypt_v14_r58564(byte[] data) {
			var reader = new BinaryReader(new MemoryStream(Decrypt_v10_r42915(data)));
			return reader.ReadBytes(reader.ReadInt32());
		}

		byte[] Decrypt_v14_r58852(byte[] data) {
			var reader = new BinaryReader(new MemoryStream(DeobUtils.Inflate(data, true)));
			data = reader.ReadBytes(reader.ReadInt32());
			for (int i = 0; i < data.Length; i++) {
				if ((i & 1) == 0)
					data[i] ^= (byte)((key0 & 0xF) - i);
				else
					data[i] ^= (byte)((key0 >> 4) + i);
				data[i] -= (byte)i;
			}
			return data;
		}

		byte[] Decrypt_v15_r60785(byte[] data) {
			var reader = new BinaryReader(new MemoryStream(DeobUtils.Inflate(data, true)));
			data = Decrypt_v15_r60785(reader, out var key, out var iv);
			reader = new BinaryReader(new MemoryStream(DeobUtils.AesDecrypt(data, key, iv)));
			return reader.ReadBytes(reader.ReadInt32());
		}

		byte[] Decrypt_v15_r60785(BinaryReader reader, out byte[] key, out byte[] iv) {
			var encrypted = reader.ReadBytes(reader.ReadInt32());
			iv = reader.ReadBytes(reader.ReadInt32());
			key = reader.ReadBytes(reader.ReadInt32());
			for (int i = 0; i < key.Length; i += 4) {
				key[i] ^= (byte)key0;
				key[i + 1] ^= (byte)(key0 >> 8);
				key[i + 2] ^= (byte)(key0 >> 16);
				key[i + 3] ^= (byte)(key0 >> 24);
			}
			return encrypted;
		}

		byte[] Decrypt_v17_r73404(byte[] data) {
			var reader = new BinaryReader(new MemoryStream(data));
			data = Decrypt_v15_r60785(reader, out var key, out var iv);
			reader = new BinaryReader(new MemoryStream(DeobUtils.Inflate(DeobUtils.AesDecrypt(data, key, iv), true)));
			return reader.ReadBytes(reader.ReadInt32());
		}

		byte[] Decrypt_v17_r75076(byte[] data) {
			var reader = new BinaryReader(new MemoryStream(data));
			data = Decrypt_v15_r60785(reader, out var key, out var iv);
			return SevenZipDecompress(DeobUtils.AesDecrypt(data, key, iv));
		}

		static byte[] SevenZipDecompress(byte[] data) {
			var reader = new BinaryReader(new MemoryStream(data));
			int totalSize = reader.ReadInt32();
			var props = reader.ReadBytes(5);
			var decoder = new Decoder();
			decoder.SetDecoderProperties(props);
			if ((long)totalSize != reader.ReadInt64())
				throw new ApplicationException("Invalid total size");
			long compressedSize = data.Length - props.Length - 8;
			var decompressed = new byte[totalSize];
			decoder.Code(reader.BaseStream, new MemoryStream(decompressed, true), compressedSize, totalSize, null);
			return decompressed;
		}

		public void Deobfuscate(Blocks blocks) {
			if (asmResolverMethod == null)
				return;
			if (blocks.Method != DotNetUtils.GetModuleTypeCctor(module))
				return;
			ConfuserUtils.RemoveResourceHookCode(blocks, asmResolverMethod);
		}

		public bool GetRevisionRange(out int minRev, out int maxRev) {
			switch (version) {
			case ConfuserVersion.Unknown:
				minRev = maxRev = 0;
				return false;

			case ConfuserVersion.v10_r42915:
				minRev = 42915;
				maxRev = 48509;
				return true;

			case ConfuserVersion.v10_r48717:
				minRev = 48717;
				maxRev = 57699;
				return true;

			case ConfuserVersion.v14_r57778:
				minRev = 57778;
				maxRev = 58446;
				return true;

			case ConfuserVersion.v14_r58564:
				minRev = 58564;
				maxRev = 58741;
				return true;

			case ConfuserVersion.v14_r58802:
				minRev = 58802;
				maxRev = 58817;
				return true;

			case ConfuserVersion.v14_r58852:
				minRev = 58852;
				maxRev = 60408;
				return true;

			case ConfuserVersion.v15_r60785:
				minRev = 60785;
				maxRev = 72989;
				return true;

			case ConfuserVersion.v17_r73404:
				minRev = 73404;
				maxRev = 73430;
				return true;

			case ConfuserVersion.v17_r73477:
				minRev = 73477;
				maxRev = 73479;
				return true;

			case ConfuserVersion.v17_r73566:
				minRev = 73566;
				maxRev = 75056;
				return true;

			case ConfuserVersion.v17_r75076:
				minRev = 75076;
				maxRev = 75158;
				return true;

			case ConfuserVersion.v18_r75184:
				minRev = 75184;
				maxRev = int.MaxValue;
				return true;

			case ConfuserVersion.v18_r75367:
				minRev = 75367;
				maxRev = 77124;
				return true;

			case ConfuserVersion.v19_r77172:
				minRev = 77172;
				maxRev = int.MaxValue;
				return true;

			default: throw new ApplicationException("Invalid version");
			}
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Confuser/VersionDetector.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;

namespace de4dot.code.deobfuscators.Confuser {
	class VersionDetector {
		int minRev = -1, maxRev = int.MaxValue;

		static readonly int[] revs = new int[] {
			42519, 42915, 42916, 42917, 42919, 42960, 43055, 45527,
			48493, 48509, 48717, 48718, 48771, 48832, 48863, 49238,
			49299, 49300, 49966, 50359, 50378, 50661, 54225, 54254,
			54312, 54431, 54564, 54566, 54574, 55346, 55604, 55608,
			55609, 55764, 55802, 56535, 57588, 57593, 57699, 57778,
			57884, 58004, 58172, 58446, 58564, 58741, 58802, 58804,
			58817, 58852, 58857, 58919, 59014, 60052, 60054, 60111,
			60408, 60785, 60787, 61954, 62284, 64574, 65189, 65282,
			65297, 65298, 65299, 65747, 66631, 66853, 66883, 67015,
			67058, 69339, 69666, 70489, 71742, 71743, 71847, 72164,
			72434, 72819, 72853, 72868, 72989, 73404, 73430, 73477,
			73479, 73566, 73593, 73605, 73740, 73764, 73770, 73791,
			73822, 74021, 74184, 74476, 74482, 74520, 74574, 74578,
			74637, 74708, 74788, 74816, 74852, 75056, 75076, 75077,
			75131, 75152, 75158, 75184, 75257, 75267, 75288, 75291,
			75306, 75318, 75349, 75367, 75369, 75402, 75459, 75461,
			75573, 75719, 75720, 75725, 75806, 75807, 75926, 76101,
			76119, 76163, 76186, 76271, 76360, 76509, 76542, 76548,
			76558, 76580, 76656, 76871, 76923, 76924, 76933, 76934,
			76972, 76974, 77124, 77172, 77447, 77501, 78056, 78072,
			78086, 78196, 78197, 78342, 78363, 78377, 78612, 78638,
			78642, 78730, 78731, 78962, 78963, 78964, 79256, 79257,
			79258, 79440, 79630, 79631, 79632, 79634, 79642,
		};

		static Dictionary<int, Version> revToVersion = new Dictionary<int, Version> {
			{ 42519, new Version(1, 0) },	// May 01 2010
			{ 49299, new Version(1, 1) },	// Jul 13 2010
			{ 50661, new Version(1, 2) },	// Jul 23 2010
			{ 54574, new Version(1, 3) },	// Aug 31 2010
			{ 55609, new Version(1, 4) },	// Sep 15 2010
			{ 58919, new Version(1, 5) },	// Nov 29 2010
			{ 60787, new Version(1, 6) },	// Jan 10 2011
			{ 72989, new Version(1, 7) },	// Mar 09 2012
			{ 75131, new Version(1, 8) },	// May 31 2012
			{ 75461, new Version(1, 9) },	// Jun 23 2012
		};

		static VersionDetector() {
			Version currentVersion = null;
			int prevRev = -1;
			foreach (var rev in revs) {
				if (rev <= prevRev)
					throw new ApplicationException();
				if (revToVersion.TryGetValue(rev, out var version))
					currentVersion = version;
				else if (currentVersion == null)
					throw new ApplicationException();
				else
					revToVersion[rev] = currentVersion;
				prevRev = rev;
			}
		}

		public void AddRevs(int min, int max) {
			if (min < 0 || max < 0 || min > max)
				throw new ArgumentOutOfRangeException();
			if (!revToVersion.ContainsKey(min) || (max != int.MaxValue && !revToVersion.ContainsKey(max)))
				throw new ArgumentOutOfRangeException();

			if (min > minRev)
				minRev = min;
			if (max < maxRev)
				maxRev = max;
		}

		public void SetVersion(Version version) {
			if (version == null)
				return;
			int minRev = int.MaxValue, maxRev = int.MinValue;
			foreach (var kv in revToVersion) {
				if (kv.Value.Major != version.Major || kv.Value.Minor != version.Minor)
					continue;
				if (minRev > kv.Key)
					minRev = kv.Key;
				if (maxRev < kv.Key)
					maxRev = kv.Key;
			}
			if (minRev == int.MaxValue)
				return;
			if (maxRev == revs[revs.Length - 1])
				maxRev = int.MaxValue;
			AddRevs(minRev, maxRev);
		}

		public string GetVersionString() {
			if (minRev > maxRev || minRev < 0)
				return null;
			var minVersion = revToVersion[minRev];
			if (maxRev == int.MaxValue) {
				var latestRev = revs[revs.Length - 1];
				if (minRev == latestRev)
					return $"v{minVersion.Major}.{minVersion.Minor} (r{minRev})";
				var latestVersion = revToVersion[latestRev];
				if (minVersion == latestVersion)
					return $"v{minVersion.Major}.{minVersion.Minor} (r{minRev}+)";
				return $"v{minVersion.Major}.{minVersion.Minor}+ (r{minRev}+)";
			}
			var maxVersion = revToVersion[maxRev];
			if (minVersion == maxVersion) {
				if (minRev == maxRev)
					return $"v{minVersion.Major}.{minVersion.Minor} (r{minRev})";
				return $"v{minVersion.Major}.{minVersion.Minor} (r{minRev}-r{maxRev})";
			}
			return $"v{minVersion.Major}.{minVersion.Minor} - v{maxVersion.Major}.{maxVersion.Minor} (r{minRev}-r{maxRev})";
		}

		public override string ToString() => GetVersionString() ?? "<no version>";
	}
}



================================================
File: de4dot.code/deobfuscators/Confuser/x86Emulator.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.IO;

namespace de4dot.code.deobfuscators.Confuser {
	class X86Emulator : IDisposable {
		// Confuser 1.7 r73740 - r73822
		static readonly byte[] prolog1 = new byte[] {
			0x8B, 0x44, 0x24, 0x04, 0x53, 0x50,
		};
		static readonly byte[] epilog1 = new byte[] {
			0x5B, 0xC3,
		};

		// Confuser 1.7 r74021+
		static readonly byte[] prolog2 = new byte[] {
			0x89, 0xE0, 0x53, 0x57, 0x56, 0x29, 0xE0, 0x83,
			0xF8, 0x18, 0x74, 0x07, 0x8B, 0x44, 0x24, 0x10,
			0x50, 0xEB, 0x01, 0x51,
		};
		static readonly byte[] epilog2 = new byte[] {
			0x5E, 0x5F, 0x5B, 0xC3,
		};

		MyPEImage peImage;
		DataReader reader;
		uint[] args;
		int nextArgIndex;
		uint[] regs = new uint[8];
		byte modRM, mod, reg, rm;

		enum OpCode {
			Add_RI,
			Add_RR,
			Mov_RI,
			Mov_RR,
			Neg_R,
			Not_R,
			Pop_R,
			Sub_RI,
			Sub_RR,
			Xor_RI,
			Xor_RR,
		}

		interface IOperand {
		}

		class RegOperand : IOperand {
			static readonly string[] names = new string[8] {
				"eax", "ecx", "edx", "ebx", "esp", "ebp", "esi", "edi",
			};
			public readonly int reg;
			public RegOperand(int reg) => this.reg = reg;
			public override string ToString() => names[reg];
		}

		class ImmOperand : IOperand {
			public readonly int imm;
			public ImmOperand(int imm) => this.imm = imm;
			public override string ToString() => $"{imm:X2}h";
		}

		class Instruction {
			public readonly OpCode opCode;
			public IOperand op1;
			public IOperand op2;

			public Instruction(OpCode opCode)
				: this(opCode, null, null) {
			}

			public Instruction(OpCode opCode, IOperand op1)
				: this(opCode, op1, null) {
			}

			public Instruction(OpCode opCode, IOperand op1, IOperand op2) {
				this.opCode = opCode;
				this.op1 = op1;
				this.op2 = op2;
			}

			public override string ToString() {
				if (op1 != null && op2 != null)
					return $"{opCode} {op1},{op2}";
				if (op1 != null)
					return $"{opCode} {op1}";
				return opCode.ToString();
			}
		}

		public X86Emulator(byte[] fileData) {
			peImage = new MyPEImage(fileData);
			reader = peImage.Reader;
		}

		public uint Emulate(uint rva, uint arg) => Emulate(rva, new uint[] { arg });

		public uint Emulate(uint rva, uint[] args) {
			Initialize(args);

			reader.Position = peImage.RvaToOffset(rva);
			byte[] prolog, epilog;
			if (IsBytes(prolog1)) {
				prolog = prolog1;
				epilog = epilog1;
			}
			else if (IsBytes(prolog2)) {
				prolog = prolog2;
				epilog = epilog2;
			}
			else
				throw new ApplicationException($"Missing prolog @ RVA {rva:X8}");
			reader.Position += (uint)prolog.Length;

			while (!IsBytes(epilog))
				Emulate();

			return regs[0];
		}

		void Initialize(uint[] args) {
			this.args = args;
			nextArgIndex = 0;
			for (int i = 0; i < regs.Length; i++)
				regs[i] = 0;
		}

		bool IsBytes(IList<byte> bytes) {
			uint oldPos = reader.Position;
			bool result = true;
			for (int i = 0; i < bytes.Count; i++) {
				if (bytes[i] != reader.ReadByte()) {
					result = false;
					break;
				}
			}
			reader.Position = oldPos;
			return result;
		}

		void Emulate() {
			var instr = Decode();
			switch (instr.opCode) {
			case OpCode.Add_RI:
			case OpCode.Add_RR:
				WriteReg(instr.op1, ReadOp(instr.op1) + ReadOp(instr.op2));
				break;

			case OpCode.Mov_RI:
			case OpCode.Mov_RR:
				WriteReg(instr.op1, ReadOp(instr.op2));
				break;

			case OpCode.Neg_R:
				WriteReg(instr.op1, (uint)-(int)ReadOp(instr.op1));
				break;

			case OpCode.Not_R:
				WriteReg(instr.op1, ~ReadOp(instr.op1));
				break;

			case OpCode.Pop_R:
				WriteReg(instr.op1, GetNextArg());
				break;

			case OpCode.Sub_RI:
			case OpCode.Sub_RR:
				WriteReg(instr.op1, ReadOp(instr.op1) - ReadOp(instr.op2));
				break;

			case OpCode.Xor_RI:
			case OpCode.Xor_RR:
				WriteReg(instr.op1, ReadOp(instr.op1) ^ ReadOp(instr.op2));
				break;

			default: throw new NotSupportedException();
			}
		}

		uint GetNextArg() {
			if (nextArgIndex >= args.Length)
				throw new ApplicationException("No more args");
			return args[nextArgIndex++];
		}

		void WriteReg(IOperand op, uint val) {
			var regOp = (RegOperand)op;
			regs[regOp.reg] = val;
		}

		uint ReadOp(IOperand op) {
			if (op is RegOperand regOp)
				return regs[regOp.reg];

			if (op is ImmOperand immOp)
				return (uint)immOp.imm;

			throw new NotSupportedException();
		}

		Instruction Decode() {
			byte opc = reader.ReadByte();
			switch (opc) {
			case 0x01:	// ADD Ed,Gd
				ParseModRM();
				return new Instruction(OpCode.Add_RR, new RegOperand(rm), new RegOperand(reg));

			case 0x29:	// SUB Ed,Gd
				ParseModRM();
				return new Instruction(OpCode.Sub_RR, new RegOperand(rm), new RegOperand(reg));

			case 0x31:	// XOR Ed,Gd
				ParseModRM();
				return new Instruction(OpCode.Xor_RR, new RegOperand(rm), new RegOperand(reg));

			case 0x58:	// POP EAX
			case 0x59:	// POP ECX
			case 0x5A:	// POP EDX
			case 0x5B:	// POP EBX
			case 0x5C:	// POP ESP
			case 0x5D:	// POP EBP
			case 0x5E:	// POP ESI
			case 0x5F:	// POP EDI
				return new Instruction(OpCode.Pop_R, new RegOperand(opc - 0x58));

			case 0x81:	// Grp1 Ed,Id
				ParseModRM();
				switch (reg) {
				case 0: return new Instruction(OpCode.Add_RI, new RegOperand(rm), new ImmOperand(reader.ReadInt32()));
				case 5: return new Instruction(OpCode.Sub_RI, new RegOperand(rm), new ImmOperand(reader.ReadInt32()));
				case 6: return new Instruction(OpCode.Xor_RI, new RegOperand(rm), new ImmOperand(reader.ReadInt32()));
				default: throw new NotSupportedException();
				}

			case 0x89:	// MOV Ed,Gd
				ParseModRM();
				return new Instruction(OpCode.Mov_RR, new RegOperand(rm), new RegOperand(reg));

			case 0xB8:	// MOV EAX,Id
			case 0xB9:	// MOV ECX,Id
			case 0xBA:	// MOV EDX,Id
			case 0xBB:	// MOV EBX,Id
			case 0xBC:	// MOV ESP,Id
			case 0xBD:	// MOV EBP,Id
			case 0xBE:	// MOV ESI,Id
			case 0xBF:	// MOV EDI,Id
				return new Instruction(OpCode.Mov_RI, new RegOperand(opc - 0xB8), new ImmOperand(reader.ReadInt32()));

			case 0xF7:	// Grp3 Ev
				ParseModRM();
				switch (reg) {
				case 2: return new Instruction(OpCode.Not_R, new RegOperand(rm));
				case 3: return new Instruction(OpCode.Neg_R, new RegOperand(rm));
				default: throw new NotSupportedException();
				}

			default: throw new NotSupportedException($"Invalid opcode: {opc:X2}");
			}
		}

		void ParseModRM() {
			modRM = reader.ReadByte();
			mod = (byte)((modRM >> 6) & 7);
			reg = (byte)((modRM >> 3) & 7);
			rm = (byte)(modRM & 7);
			if (mod != 3)
				throw new ApplicationException("Memory operand");
		}

		public void Dispose() {
			if (peImage != null)
				peImage.Dispose();
			peImage = null;
			reader = default;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/CryptoObfuscator/AntiDebugger.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using dnlib.DotNet;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.CryptoObfuscator {
	class AntiDebugger {
		ModuleDefMD module;
		ISimpleDeobfuscator simpleDeobfuscator;
		IDeobfuscator deob;
		TypeDef antiDebuggerType;
		MethodDef antiDebuggerMethod;

		public TypeDef Type => antiDebuggerType;
		public MethodDef Method => antiDebuggerMethod;

		public AntiDebugger(ModuleDefMD module, ISimpleDeobfuscator simpleDeobfuscator, IDeobfuscator deob) {
			this.module = module;
			this.simpleDeobfuscator = simpleDeobfuscator;
			this.deob = deob;
		}

		public void Find() {
			if (Find(module.EntryPoint))
				return;
			if (Find(DotNetUtils.GetModuleTypeCctor(module)))
				return;
		}

		bool Find(MethodDef methodToCheck) {
			if (methodToCheck == null)
				return false;
			foreach (var method in DotNetUtils.GetCalledMethods(module, methodToCheck)) {
				var type = method.DeclaringType;

				if (!method.IsStatic || !DotNetUtils.IsMethod(method, "System.Void", "()"))
					continue;
				if (DotNetUtils.GetPInvokeMethod(type, "kernel32", "LoadLibrary") == null)
					continue;
				if (DotNetUtils.GetPInvokeMethod(type, "kernel32", "GetProcAddress") == null)
					continue;
				Deobfuscate(method);
				if (!ContainsString(method, "debugger is activ") &&
					!ContainsString(method, "debugger is running") &&
					!ContainsString(method, "Debugger detected") &&
					!ContainsString(method, "Debugger was detected") &&
					!ContainsString(method, "{0} was detected") &&
					!ContainsString(method, "run under") &&
					!ContainsString(method, "run with") &&
					!ContainsString(method, "started under") &&
					!ContainsString(method, "{0} detected") &&
					!ContainsString(method, "{0} was found - this software cannot be executed") &&
					!ContainsString(method, "{0} found"))
					continue;

				antiDebuggerType = type;
				antiDebuggerMethod = method;
				return true;
			}

			return false;
		}

		void Deobfuscate(MethodDef method) {
			simpleDeobfuscator.Deobfuscate(method);
			simpleDeobfuscator.DecryptStrings(method, deob);
		}

		bool ContainsString(MethodDef method, string part) {
			foreach (var s in DotNetUtils.GetCodeStrings(method)) {
				if (s.Contains(part))
					return true;
			}
			return false;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/CryptoObfuscator/AssemblyResolver.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Text;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.CryptoObfuscator {
	class AssemblyResolver {
		ModuleDefMD module;
		TypeDef resolverType;
		MethodDef resolverMethod;
		List<AssemblyInfo> assemblyInfos = new List<AssemblyInfo>();
		string asmSeparator;

		public class AssemblyInfo {
			public string assemblyName;
			public EmbeddedResource resource;
			public EmbeddedResource symbolsResource;
			public AssemblyInfo(string assemblyName, EmbeddedResource resource, EmbeddedResource symbolsResource) {
				this.assemblyName = assemblyName;
				this.resource = resource;
				this.symbolsResource = symbolsResource;
			}

			public override string ToString() => $"{{{assemblyName} => {resource.Name}}}";
		}

		public bool Detected => resolverType != null;
		public List<AssemblyInfo> AssemblyInfos => assemblyInfos;
		public TypeDef Type => resolverType;
		public MethodDef Method => resolverMethod;
		public AssemblyResolver(ModuleDefMD module) => this.module = module;

		public void Find(ISimpleDeobfuscator simpleDeobfuscator) {
			var cctor = DotNetUtils.GetModuleTypeCctor(module);
			if (cctor == null)
				return;

			foreach (var method in DotNetUtils.GetCalledMethods(module, cctor)) {
				if (method.Name == ".cctor" || method.Name == ".ctor")
					continue;
				if (!method.IsStatic || !DotNetUtils.IsMethod(method, "System.Void", "()"))
					continue;
				if (CheckType(method.DeclaringType, method, simpleDeobfuscator))
					break;
			}
		}

		bool CheckType(TypeDef type, MethodDef initMethod, ISimpleDeobfuscator simpleDeobfuscator) {
			if (DotNetUtils.FindFieldType(type, "System.Collections.Hashtable", true) == null)
				return false;
			simpleDeobfuscator.Deobfuscate(initMethod);
			if (!CheckInitMethod(initMethod))
				return false;
			if ((asmSeparator = FindAssemblySeparator(initMethod)) == null)
				return false;

			List<AssemblyInfo> newAssemblyInfos = null;
			foreach (var s in DotNetUtils.GetCodeStrings(initMethod)) {
				newAssemblyInfos = InitializeEmbeddedAssemblies(s);
				if (newAssemblyInfos != null)
					break;
			}
			if (newAssemblyInfos == null)
				return false;

			resolverType = type;
			resolverMethod = initMethod;
			assemblyInfos = newAssemblyInfos;
			return true;
		}

		bool CheckInitMethod(MethodDef initMethod) {
			if (!initMethod.HasBody)
				return false;

			var instructions = initMethod.Body.Instructions;
			for (int i = 0; i < instructions.Count; i++) {
				var instrs = DotNetUtils.GetInstructions(instructions, i, OpCodes.Ldnull, OpCodes.Ldftn, OpCodes.Newobj);
				if (instrs == null)
					continue;

				IMethod methodRef;
				var ldftn = instrs[1];
				var newobj = instrs[2];

				methodRef = ldftn.Operand as IMethod;
				if (methodRef == null || !new SigComparer().Equals(initMethod.DeclaringType, methodRef.DeclaringType))
					continue;

				methodRef = newobj.Operand as IMethod;
				if (methodRef == null || methodRef.FullName != "System.Void System.ResolveEventHandler::.ctor(System.Object,System.IntPtr)")
					continue;

				return true;
			}

			return false;
		}

		List<AssemblyInfo> InitializeEmbeddedAssemblies(string s) {
			var sb = new StringBuilder(s.Length);
			foreach (var c in s)
				sb.Append((char)~c);
			var tmpAssemblyInfos = sb.ToString().Split(new string[] { asmSeparator }, StringSplitOptions.RemoveEmptyEntries);
			if (tmpAssemblyInfos.Length == 0 || (tmpAssemblyInfos.Length & 1) == 1)
				return null;

			var newAssemblyInfos = new List<AssemblyInfo>(tmpAssemblyInfos.Length / 2);
			for (int i = 0; i < tmpAssemblyInfos.Length; i += 2) {
				var assemblyName = tmpAssemblyInfos[i];
				var resourceName = tmpAssemblyInfos[i + 1];
				var resource = DotNetUtils.GetResource(module, resourceName) as EmbeddedResource;
				var symbolsResource = DotNetUtils.GetResource(module, resourceName + "#") as EmbeddedResource;
				if (resource == null)
					return null;
				newAssemblyInfos.Add(new AssemblyInfo(assemblyName, resource, symbolsResource));
			}

			return newAssemblyInfos;
		}

		string FindAssemblySeparator(MethodDef initMethod) {
			if (!initMethod.HasBody)
				return null;

			foreach (var instr in initMethod.Body.Instructions) {
				if (instr.OpCode.Code != Code.Newarr)
					continue;
				var op = module.CorLibTypes.GetCorLibTypeSig(instr.Operand as ITypeDefOrRef);
				if (op == null)
					continue;
				if (op.ElementType == ElementType.String)
					return "##";
				if (op.ElementType == ElementType.Char)
					return "`";
			}

			return null;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/CryptoObfuscator/CoMethodCallInliner.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using dnlib.DotNet;
using de4dot.blocks.cflow;

namespace de4dot.code.deobfuscators.CryptoObfuscator {
	class CoMethodCallInliner : MethodCallInliner {
		readonly InlinedMethodTypes inlinedMethodTypes;

		public CoMethodCallInliner(InlinedMethodTypes inlinedMethodTypes)
			: base(false) => this.inlinedMethodTypes = inlinedMethodTypes;

		protected override bool CanInline(MethodDef method) {
			if (method == null)
				return false;

			if (method.Attributes != (MethodAttributes.Assembly | MethodAttributes.Static | MethodAttributes.HideBySig))
				return false;
			if (method.HasGenericParameters)
				return false;
			if (!InlinedMethodTypes.IsValidMethodType(method.DeclaringType))
				return false;

			return true;
		}

		protected override void OnInlinedMethod(MethodDef methodToInline, bool inlinedMethod) {
			if (inlinedMethod)
				inlinedMethodTypes.Add(methodToInline.DeclaringType);
			else
				inlinedMethodTypes.DontRemoveType(methodToInline.DeclaringType);
		}
	}
}



================================================
File: de4dot.code/deobfuscators/CryptoObfuscator/CoUtils.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Text;
using dnlib.DotNet;
using de4dot.blocks;
using dnlib.DotNet.Emit;

namespace de4dot.code.deobfuscators.CryptoObfuscator {
	static class CoUtils {
		public static EmbeddedResource GetResource(ModuleDefMD module, MethodDef method) {
			if (method == null || method.Body == null)
				return null;
			return GetResource(module, DotNetUtils.GetCodeStrings(method));
		}

		public static EmbeddedResource GetResource(ModuleDefMD module, IEnumerable<string> names) {
			foreach (var name in names) {
				if (DotNetUtils.GetResource(module, name) is EmbeddedResource resource)
					return resource;
				try {
					resource = DotNetUtils.GetResource(module, Encoding.UTF8.GetString(Convert.FromBase64String(name))) as EmbeddedResource;
					if (resource != null)
						return resource;
				}
				catch {
				}
			}
			return null;
		}

		public static string XorCipher(string text, int key) {
			var array = text.ToCharArray();
			int len = array.Length;
			char cKey = Convert.ToChar(key);
			while (--len >= 0)
				array[len] ^= cKey;
			return new string(array);
		}

		public static string DecryptResourceName(string resourceName, int key, byte[] coddedBytes) {
			int len = resourceName.Length;
			var array = resourceName.ToCharArray();
			while (--len >= 0)
				array[len] = (char)((int)array[len] ^ ((int)coddedBytes[key & 15] | key));
			return new string(array);
		}

		public static string DecryptResourceName(ModuleDefMD module, MethodDef method) {
			string resourceName = "";
			MethodDef cctor = method, orginalResMethod = null;
			// retrive key and encrypted resource name 
			int key = 0;
			var instrs = cctor.Body.Instructions;
			for (int i = 0; i < instrs.Count - 2; i++) {
				if (instrs[i].OpCode != OpCodes.Ldstr)
					continue;
				if (!instrs[i + 1].IsLdcI4())
					break;
				key = instrs[i + 1].GetLdcI4Value();
				resourceName = instrs[i].Operand as String;
				cctor = instrs[i + 2].Operand as MethodDef;
				break;
			}

			// Find the method that contains resource name
			while (orginalResMethod == null) {
				foreach (var instr in cctor.Body.Instructions) {
					if (instr.OpCode == OpCodes.Ldftn) {
						var tempMethod = instr.Operand as MethodDef;
						if (tempMethod.ReturnType.FullName != "System.String")
							continue;
						orginalResMethod = tempMethod;
						break;
					}
					else if (instr.OpCode == OpCodes.Callvirt) {
						cctor = instr.Operand as MethodDef;
						cctor = cctor.DeclaringType.FindStaticConstructor();
						break;
					}
				}
			}

			// Get encrypted Resource name
			string encResourcename = DotNetUtils.GetCodeStrings(orginalResMethod)[0];
			// get Decryption key
			int xorKey = 0;
			for (int i = 0; i < orginalResMethod.Body.Instructions.Count; i++) {
				if (orginalResMethod.Body.Instructions[i].OpCode == OpCodes.Xor)
					xorKey = orginalResMethod.Body.Instructions[i - 1].GetLdcI4Value();
			}

			encResourcename = XorCipher(encResourcename, xorKey);
			var firstResource = GetResource(module, new string[] { encResourcename });
			resourceName = DecryptResourceName(resourceName, key, firstResource.CreateReader().ToArray());
			return resourceName;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/CryptoObfuscator/ConstantsDecrypter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.CryptoObfuscator {
	class ConstantsDecrypter {
		ModuleDefMD module;
		TypeDef decrypterType;
		MethodDef methodI4;
		MethodDef methodI8;
		MethodDef methodR4;
		MethodDef methodR8;
		MethodDef methodArray;
		InitializedDataCreator initializedDataCreator;
		EmbeddedResource encryptedResource;
		byte[] constantsData;

		public TypeDef Type => decrypterType;
		public EmbeddedResource Resource => encryptedResource;
		public MethodDef Int32Decrypter => methodI4;
		public MethodDef Int64Decrypter => methodI8;
		public MethodDef SingleDecrypter => methodR4;
		public MethodDef DoubleDecrypter => methodR8;
		public bool Detected => decrypterType != null;

		public ConstantsDecrypter(ModuleDefMD module, InitializedDataCreator initializedDataCreator) {
			this.module = module;
			this.initializedDataCreator = initializedDataCreator;
		}

		public void Find() {
			foreach (var type in module.Types) {
				if (!CheckType(type))
					continue;

				decrypterType = type;
				return;
			}
		}

		static readonly string[] requiredTypes = new string[] {
			"System.Byte[]",
		};
		bool CheckType(TypeDef type) {
			if (type.Methods.Count != 7)
				return false;
			if (type.Fields.Count < 1 || type.Fields.Count > 2)
				return false;
			if (!new FieldTypes(type).All(requiredTypes))
				return false;
			if (!CheckMethods(type))
				return false;

			return true;
		}

		bool CheckMethods(TypeDef type) {
			methodI4 = DotNetUtils.GetMethod(type, "System.Int32", "(System.Int32)");
			methodI8 = DotNetUtils.GetMethod(type, "System.Int64", "(System.Int32)");
			methodR4 = DotNetUtils.GetMethod(type, "System.Single", "(System.Int32)");
			methodR8 = DotNetUtils.GetMethod(type, "System.Double", "(System.Int32)");
			methodArray = DotNetUtils.GetMethod(type, "System.Void", "(System.Array,System.Int32)");

			return methodI4 != null && methodI8 != null &&
				methodR4 != null && methodR8 != null &&
				methodArray != null;
		}

		public void Initialize(ResourceDecrypter resourceDecrypter) {
			if (decrypterType == null)
				return;

			var cctor = decrypterType.FindStaticConstructor();
			encryptedResource = CoUtils.GetResource(module, DotNetUtils.GetCodeStrings(cctor));

			//if the return value is null, it is possible that resource name is encrypted
			if (encryptedResource == null) {
				var Resources = new string[] { CoUtils.DecryptResourceName(module, cctor) };
				encryptedResource = CoUtils.GetResource(module, Resources);
			}

			constantsData = resourceDecrypter.Decrypt(encryptedResource.CreateReader().AsStream());
		}

		public int DecryptInt32(int index) => BitConverter.ToInt32(constantsData, index);
		public long DecryptInt64(int index) => BitConverter.ToInt64(constantsData, index);
		public float DecryptSingle(int index) => BitConverter.ToSingle(constantsData, index);
		public double DecryptDouble(int index) => BitConverter.ToDouble(constantsData, index);

		struct ArrayInfo {
			public CorLibTypeSig arrayType;
			public int start, len;
			public int arySize, index;

			public ArrayInfo(int start, int len, CorLibTypeSig arrayType, int arySize, int index) {
				this.start = start;
				this.len = len;
				this.arrayType = arrayType;
				this.arySize = arySize;
				this.index = index;
			}
		}

		public void Deobfuscate(Blocks blocks) {
			var infos = new List<ArrayInfo>();
			foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {
				var instrs = block.Instructions;
				infos.Clear();

				for (int i = 0; i < instrs.Count - 5; i++) {
					int index = i;

					var ldci4_arySize = instrs[index++];
					if (!ldci4_arySize.IsLdcI4())
						continue;

					var newarr = instrs[index++];
					if (newarr.OpCode.Code != Code.Newarr)
						continue;
					var arrayType = module.CorLibTypes.GetCorLibTypeSig(newarr.Operand as ITypeDefOrRef);
					if (arrayType == null)
						continue;

					if (instrs[index++].OpCode.Code != Code.Dup)
						continue;

					var ldci4_index = instrs[index++];
					if (!ldci4_index.IsLdcI4())
						continue;

					var call = instrs[index++];
					if (call.OpCode.Code != Code.Call && call.OpCode.Code != Code.Callvirt)
						continue;
					if (!MethodEqualityComparer.CompareDeclaringTypes.Equals(call.Operand as IMethod, methodArray))
						continue;

					if (arrayType.ElementType.GetPrimitiveSize() == -1) {
						Logger.w("Can't decrypt non-primitive type array in method {0:X8}", blocks.Method.MDToken.ToInt32());
						continue;
					}

					infos.Add(new ArrayInfo(i, index - i, arrayType, ldci4_arySize.GetLdcI4Value(),
								ldci4_index.GetLdcI4Value()));
				}

				infos.Reverse();
				foreach (var info in infos) {
					var elemSize = info.arrayType.ElementType.GetPrimitiveSize();
					var decrypted = DecryptArray(info);
					initializedDataCreator.AddInitializeArrayCode(block, info.start, info.len, info.arrayType.ToTypeDefOrRef(), decrypted);
					Logger.v("Decrypted {0} array: {1} elements", info.arrayType.ToString(), decrypted.Length / elemSize);
				}
			}
		}

		byte[] DecryptArray(ArrayInfo aryInfo) {
			var ary = new byte[aryInfo.arySize * aryInfo.arrayType.ElementType.GetPrimitiveSize()];
			int dataIndex = aryInfo.index;
			int len = DeobUtils.ReadVariableLengthInt32(constantsData, ref dataIndex);
			Buffer.BlockCopy(constantsData, dataIndex, ary, 0, len);
			return ary;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/CryptoObfuscator/Deobfuscator.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using dnlib.DotNet;
using de4dot.blocks;
using de4dot.blocks.cflow;

namespace de4dot.code.deobfuscators.CryptoObfuscator {
	public class DeobfuscatorInfo : DeobfuscatorInfoBase {
		public const string THE_NAME = "Crypto Obfuscator";
		public const string THE_TYPE = "co";
		const string DEFAULT_REGEX = @"!^(get_|set_|add_|remove_)?[A-Z]{1,3}(?:`\d+)?$&!^(get_|set_|add_|remove_)?c[0-9a-f]{32}(?:`\d+)?$&" + DeobfuscatorBase.DEFAULT_ASIAN_VALID_NAME_REGEX;
		BoolOption removeTamperProtection;
		BoolOption decryptConstants;
		BoolOption inlineMethods;
		BoolOption fixLdnull;

		public DeobfuscatorInfo()
			: base(DEFAULT_REGEX) {
			removeTamperProtection = new BoolOption(null, MakeArgName("tamper"), "Remove tamper protection code", true);
			decryptConstants = new BoolOption(null, MakeArgName("consts"), "Decrypt constants", true);
			inlineMethods = new BoolOption(null, MakeArgName("inline"), "Inline short methods", true);
			fixLdnull = new BoolOption(null, MakeArgName("ldnull"), "Restore ldnull instructions", true);
		}

		public override string Name => THE_NAME;
		public override string Type => THE_TYPE;

		public override IDeobfuscator CreateDeobfuscator() =>
			new Deobfuscator(new Deobfuscator.Options {
				ValidNameRegex = validNameRegex.Get(),
				RemoveTamperProtection = removeTamperProtection.Get(),
				DecryptConstants = decryptConstants.Get(),
				InlineMethods = inlineMethods.Get(),
				FixLdnull = fixLdnull.Get(),
			});

		protected override IEnumerable<Option> GetOptionsInternal() =>
			new List<Option>() {
				removeTamperProtection,
				decryptConstants,
				inlineMethods,
				fixLdnull,
			};
	}

	class Deobfuscator : DeobfuscatorBase {
		Options options;
		string obfuscatorName = DeobfuscatorInfo.THE_NAME;
		bool foundCryptoObfuscatorAttribute = false;
		bool foundObfuscatedSymbols = false;
		bool foundObfuscatorUserString = false;
		bool startedDeobfuscating = false;

		MethodsDecrypter methodsDecrypter;
		ProxyCallFixer proxyCallFixer;
		ResourceDecrypter resourceDecrypter;
		ResourceResolver resourceResolver;
		AssemblyResolver assemblyResolver;
		StringDecrypter stringDecrypter;
		TamperDetection tamperDetection;
		AntiDebugger antiDebugger;
		ConstantsDecrypter constantsDecrypter;
		Int32ValueInliner int32ValueInliner;
		Int64ValueInliner int64ValueInliner;
		SingleValueInliner singleValueInliner;
		DoubleValueInliner doubleValueInliner;
		InlinedMethodTypes inlinedMethodTypes;

		internal class Options : OptionsBase {
			public bool RemoveTamperProtection { get; set; }
			public bool DecryptConstants { get; set; }
			public bool InlineMethods { get; set; }
			public bool FixLdnull { get; set; }
		}

		public override string Type => DeobfuscatorInfo.THE_TYPE;
		public override string TypeLong => DeobfuscatorInfo.THE_NAME;
		public override string Name => obfuscatorName;
		protected override bool CanInlineMethods => startedDeobfuscating ? options.InlineMethods : true;

		public override IEnumerable<IBlocksDeobfuscator> BlocksDeobfuscators {
			get {
				var list = new List<IBlocksDeobfuscator>();
				if (CanInlineMethods)
					list.Add(new CoMethodCallInliner(inlinedMethodTypes));
				return list;
			}
		}

		public Deobfuscator(Options options)
			: base(options) {
			this.options = options;
			StringFeatures = StringFeatures.AllowStaticDecryption | StringFeatures.AllowDynamicDecryption;
		}

		protected override int DetectInternal() {
			int val = 0;

			int sum = ToInt32(methodsDecrypter.Detected) +
					ToInt32(stringDecrypter.Detected) +
					ToInt32(tamperDetection.Detected) +
					ToInt32(proxyCallFixer.Detected) +
					ToInt32(constantsDecrypter.Detected);
			if (sum > 0)
				val += 100 + 10 * (sum - 1);
			if (foundCryptoObfuscatorAttribute || foundObfuscatedSymbols || foundObfuscatorUserString)
				val += 10;

			return val;
		}

		protected override void ScanForObfuscator() {
			foreach (var type in module.Types) {
				if (type.FullName == "CryptoObfuscator.ProtectedWithCryptoObfuscatorAttribute") {
					foundCryptoObfuscatorAttribute = true;
					AddAttributeToBeRemoved(type, "Obfuscator attribute");
					InitializeVersion(type);
				}
			}
			if (CheckCryptoObfuscator())
				foundObfuscatedSymbols = true;

			inlinedMethodTypes = new InlinedMethodTypes();
			methodsDecrypter = new MethodsDecrypter(module);
			methodsDecrypter.Find();
			proxyCallFixer = new ProxyCallFixer(module);
			proxyCallFixer.FindDelegateCreator();
			stringDecrypter = new StringDecrypter(module);
			stringDecrypter.Find();
			tamperDetection = new TamperDetection(module);
			tamperDetection.Find();
			constantsDecrypter = new ConstantsDecrypter(module, initializedDataCreator);
			constantsDecrypter.Find();
			foundObfuscatorUserString = Utils.StartsWith(module.ReadUserString(0x70000001), "\u0011\"3D9B94A98B-76A8-4810-B1A0-4BE7C4F9C98D", StringComparison.Ordinal);
		}

		void InitializeVersion(TypeDef attr) {
			var s = DotNetUtils.GetCustomArgAsString(GetAssemblyAttribute(attr), 0);
			if (s == null)
				return;

			var val = Regex.Match(s, @"^Protected with (Crypto Obfuscator.*)$");
			if (val.Groups.Count < 2)
				return;
			obfuscatorName = val.Groups[1].ToString();
			return;
		}

		bool CheckCryptoObfuscator() {
			int matched = 0;
			foreach (var type in module.Types) {
				if (type.Namespace != "A")
					continue;
				if (Regex.IsMatch(type.Name.String, "^c[0-9a-f]{32}$"))
					return true;
				else if (Regex.IsMatch(type.Name.String, "^A[A-Z]*$")) {
					if (++matched >= 10)
						return true;
				}
			}
			return false;
		}

		public override void DeobfuscateBegin() {
			base.DeobfuscateBegin();

			resourceDecrypter = new ResourceDecrypter(module, DeobfuscatedFile);
			resourceResolver = new ResourceResolver(module, resourceDecrypter);
			assemblyResolver = new AssemblyResolver(module);
			resourceResolver.Find();
			assemblyResolver.Find(DeobfuscatedFile);

			DecryptResources();
			stringDecrypter.Initialize(resourceDecrypter);
			if (stringDecrypter.Method != null) {
				staticStringInliner.Add(stringDecrypter.Method, (method, gim, args) => {
					return stringDecrypter.Decrypt((int)args[0]);
				});
				DeobfuscatedFile.StringDecryptersAdded();
			}

			methodsDecrypter.Decrypt(resourceDecrypter, DeobfuscatedFile);

			if (methodsDecrypter.Detected) {
				if (!assemblyResolver.Detected)
					assemblyResolver.Find(DeobfuscatedFile);
				if (!tamperDetection.Detected)
					tamperDetection.Find();
			}
			antiDebugger = new AntiDebugger(module, DeobfuscatedFile, this);
			antiDebugger.Find();

			if (options.DecryptConstants) {
				constantsDecrypter.Initialize(resourceDecrypter);
				int32ValueInliner = new Int32ValueInliner();
				int32ValueInliner.Add(constantsDecrypter.Int32Decrypter, (method, gim, args) => constantsDecrypter.DecryptInt32((int)args[0]));
				int64ValueInliner = new Int64ValueInliner();
				int64ValueInliner.Add(constantsDecrypter.Int64Decrypter, (method, gim, args) => constantsDecrypter.DecryptInt64((int)args[0]));
				singleValueInliner = new SingleValueInliner();
				singleValueInliner.Add(constantsDecrypter.SingleDecrypter, (method, gim, args) => constantsDecrypter.DecryptSingle((int)args[0]));
				doubleValueInliner = new DoubleValueInliner();
				doubleValueInliner.Add(constantsDecrypter.DoubleDecrypter, (method, gim, args) => constantsDecrypter.DecryptDouble((int)args[0]));
				AddTypeToBeRemoved(constantsDecrypter.Type, "Constants decrypter type");
				AddResourceToBeRemoved(constantsDecrypter.Resource, "Encrypted constants");
			}

			AddModuleCctorInitCallToBeRemoved(resourceResolver.Method);
			AddModuleCctorInitCallToBeRemoved(assemblyResolver.Method);
			AddCallToBeRemoved(module.EntryPoint, tamperDetection.Method);
			AddModuleCctorInitCallToBeRemoved(tamperDetection.Method);
			AddCallToBeRemoved(module.EntryPoint, antiDebugger.Method);
			AddModuleCctorInitCallToBeRemoved(antiDebugger.Method);
			AddTypeToBeRemoved(resourceResolver.Type, "Resource resolver type");
			AddTypeToBeRemoved(assemblyResolver.Type, "Assembly resolver type");
			AddTypeToBeRemoved(tamperDetection.Type, "Tamper detection type");
			AddTypeToBeRemoved(antiDebugger.Type, "Anti-debugger type");
			AddTypeToBeRemoved(methodsDecrypter.Type, "Methods decrypter type");
			AddTypesToBeRemoved(methodsDecrypter.DelegateTypes, "Methods decrypter delegate type");
			AddResourceToBeRemoved(methodsDecrypter.Resource, "Encrypted methods");

			proxyCallFixer.Find();

			DumpEmbeddedAssemblies();

			startedDeobfuscating = true;
		}

		public override void DeobfuscateMethodEnd(Blocks blocks) {
			proxyCallFixer.Deobfuscate(blocks);
			if (options.DecryptConstants) {
				int32ValueInliner.Decrypt(blocks);
				int64ValueInliner.Decrypt(blocks);
				singleValueInliner.Decrypt(blocks);
				doubleValueInliner.Decrypt(blocks);
				constantsDecrypter.Deobfuscate(blocks);
			}
			base.DeobfuscateMethodEnd(blocks);
		}

		public override void DeobfuscateEnd() {
			if (options.FixLdnull)
				new LdnullFixer(module, inlinedMethodTypes).Restore();
			RemoveProxyDelegates(proxyCallFixer);
			if (CanRemoveStringDecrypterType) {
				AddResourceToBeRemoved(stringDecrypter.Resource, "Encrypted strings");
				AddTypeToBeRemoved(stringDecrypter.Type, "String decrypter type");
			}
			AddTypesToBeRemoved(inlinedMethodTypes.Types, "Inlined methods type");
			base.DeobfuscateEnd();
		}

		void DecryptResources() {
			var rsrc = resourceResolver.MergeResources();
			if (rsrc == null)
				return;
			AddResourceToBeRemoved(rsrc, "Encrypted resources");
		}

		void DumpEmbeddedAssemblies() {
			foreach (var info in assemblyResolver.AssemblyInfos) {
				DumpEmbeddedFile(info.resource, info.assemblyName, ".dll", $"Embedded assembly: {info.assemblyName}");

				if (info.symbolsResource != null)
					DumpEmbeddedFile(info.symbolsResource, info.assemblyName, ".pdb", $"Embedded pdb: {info.assemblyName}");
			}
		}

		void DumpEmbeddedFile(EmbeddedResource resource, string assemblyName, string extension, string reason) {
			DeobfuscatedFile.CreateAssemblyFile(resourceDecrypter.Decrypt(resource.CreateReader().AsStream()), Utils.GetAssemblySimpleName(assemblyName), extension);
			AddResourceToBeRemoved(resource, reason);
		}

		public override IEnumerable<int> GetStringDecrypterMethods() {
			var list = new List<int>();
			if (stringDecrypter.Method != null)
				list.Add(stringDecrypter.Method.MDToken.ToInt32());
			return list;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/CryptoObfuscator/InlinedMethodTypes.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet;

namespace de4dot.code.deobfuscators.CryptoObfuscator {
	class InlinedMethodTypes {
		Dictionary<TypeDef, TypeFlags> types = new Dictionary<TypeDef, TypeFlags>();

		[Flags]
		enum TypeFlags {
			DontRemoveType = 1,
		}

		public IEnumerable<TypeDef> Types {
			get {
				foreach (var kv in types) {
					if ((kv.Value & TypeFlags.DontRemoveType) == 0)
						yield return kv.Key;
				}
			}
		}

		static bool IsValidType(TypeDef type) {
			if (type == null)
				return false;

			if (type.BaseType == null || type.BaseType.FullName != "System.Object")
				return false;
			if (type.DeclaringType != null)
				return false;
			if (type.Attributes != (TypeAttributes.NotPublic | TypeAttributes.AutoLayout |
				TypeAttributes.Class | TypeAttributes.Sealed | TypeAttributes.AnsiClass))
				return false;
			if (type.HasProperties || type.HasEvents)
				return false;
			if (type.HasInterfaces)
				return false;
			if (type.HasGenericParameters)
				return false;
			if (type.HasNestedTypes)
				return false;

			return true;
		}

		public static bool IsValidMethodType(TypeDef type) {
			if (!IsValidType(type))
				return false;

			if (type.HasFields)
				return false;
			if (type.Methods.Count != 1)
				return false;

			return true;
		}

		public static bool IsValidFieldType(TypeDef type) {
			if (!IsValidType(type))
				return false;

			if (type.HasMethods)
				return false;
			if (type.Fields.Count != 1)
				return false;

			return true;
		}

		public void Add(TypeDef type) {
			if (type == null || types.ContainsKey(type))
				return;
			types[type] = 0;
		}

		public void DontRemoveType(TypeDef type) {
			types.TryGetValue(type, out var flags);
			flags |= TypeFlags.DontRemoveType;
			types[type] = flags;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/CryptoObfuscator/LdnullFixer.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using de4dot.blocks;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace de4dot.code.deobfuscators.CryptoObfuscator {
	class LdnullFixer {
		readonly ModuleDef module;
		readonly InlinedMethodTypes inlinedMethodTypes;

		public LdnullFixer(ModuleDef module, InlinedMethodTypes inlinedMethodTypes) {
			this.module = module;
			this.inlinedMethodTypes = inlinedMethodTypes;
		}

		public void Restore() {
			var fields = FindFieldTypes(FindFieldTypes());
			Restore(fields);
			foreach (var field in fields.Keys)
				inlinedMethodTypes.Add(field.DeclaringType);
		}

		FieldDefAndDeclaringTypeDict<FieldDef> FindFieldTypes() {
			var dict = new FieldDefAndDeclaringTypeDict<FieldDef>();

			foreach (var type in module.GetTypes()) {
				foreach (var method in type.Methods) {
					var body = method.Body;
					if (body == null)
						continue;
					foreach (var instr in body.Instructions) {
						if (instr.OpCode.Code != Code.Ldsfld)
							continue;
						var field = instr.Operand as FieldDef;
						if (field == null)
							continue;
						var declType = field.DeclaringType;
						if (declType == null)
							continue;
						if (!InlinedMethodTypes.IsValidFieldType(declType))
							continue;
						dict.Add(field, field);
					}
				}
			}

			return dict;
		}

		Dictionary<FieldDef, bool> FindFieldTypes(FieldDefAndDeclaringTypeDict<FieldDef> fields) {
			var validFields = new Dictionary<FieldDef, bool>(fields.Count);
			foreach (var field in fields.GetKeys())
				validFields.Add(field, false);

			foreach (var type in module.GetTypes()) {
				if (validFields.Count == 0)
					break;

				foreach (var method in type.Methods) {
					var body = method.Body;
					if (body == null)
						continue;
					foreach (var instr in body.Instructions) {
						if (instr.OpCode.Code == Code.Ldsfld)
							continue;
						var field = instr.Operand as IField;
						if (field == null)
							continue;

						var validType = fields.Find(field);
						if (validType == null)
							continue;

						validFields.Remove(validType);
					}
				}
			}

			return validFields;
		}

		int Restore(Dictionary<FieldDef, bool> nullFields) {
			int numRestored = 0;
			foreach (var type in module.GetTypes()) {
				foreach (var method in type.Methods) {
					var body = method.Body;
					if (body == null)
						continue;
					foreach (var instr in body.Instructions) {
						if (instr.OpCode.Code != Code.Ldsfld)
							continue;
						var field = instr.Operand as FieldDef;
						if (field == null)
							continue;
						if (!nullFields.ContainsKey(field))
							continue;

						instr.OpCode = OpCodes.Ldnull;
						instr.Operand = null;
						numRestored++;
					}
				}
			}
			return numRestored;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/CryptoObfuscator/MethodBodyReader.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.IO;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace de4dot.code.deobfuscators.CryptoObfuscator {
	class MethodBodyReader : MethodBodyReaderBase {
		ModuleDefMD module;
		ushort maxStackSize;
		GenericParamContext gpContext;

		public MethodBodyReader(ModuleDefMD module, ref DataReader reader) : base(reader) => this.module = module;

		public void Read(MethodDef method) {
			gpContext = GenericParamContext.Create(method);
			parameters = method.Parameters;
			SetLocals(GetLocals(method));

			maxStackSize = (ushort)reader.ReadInt32();
			ReadInstructionsNumBytes(reader.ReadUInt32());
			ReadExceptionHandlers();
		}

		void ReadExceptionHandlers() {
			int totalSize = reader.ReadInt32();
			if (totalSize == 0)
				return;
			reader.ReadInt32();
			ReadExceptionHandlers((totalSize - 4) / 24);
		}

		static IList<Local> GetLocals(MethodDef method) {
			if (method.Body == null)
				return new List<Local>();
			return method.Body.Variables;
		}

		protected override IField ReadInlineField(Instruction instr) => module.ResolveToken(reader.ReadUInt32(), gpContext) as IField;
		protected override IMethod ReadInlineMethod(Instruction instr) => module.ResolveToken(reader.ReadUInt32(), gpContext) as IMethod;

		protected override MethodSig ReadInlineSig(Instruction instr) {
			var sas = module.ResolveStandAloneSig(MDToken.ToRID(reader.ReadUInt32()), gpContext);
			return sas?.MethodSig;
		}

		protected override string ReadInlineString(Instruction instr) => module.ReadUserString(reader.ReadUInt32());
		protected override ITokenOperand ReadInlineTok(Instruction instr) => module.ResolveToken(reader.ReadUInt32(), gpContext) as ITokenOperand;
		protected override ITypeDefOrRef ReadInlineType(Instruction instr) => module.ResolveToken(reader.ReadUInt32(), gpContext) as ITypeDefOrRef;

		void ReadExceptionHandlers(int numExceptionHandlers) {
			exceptionHandlers = new ExceptionHandler[numExceptionHandlers];
			for (int i = 0; i < exceptionHandlers.Count; i++)
				exceptionHandlers[i] = ReadExceptionHandler();
		}

		ExceptionHandler ReadExceptionHandler() {
			var eh = new ExceptionHandler((ExceptionHandlerType)reader.ReadUInt32());

			uint tryOffset = reader.ReadUInt32();
			eh.TryStart = GetInstructionThrow(tryOffset);
			eh.TryEnd = GetInstruction(tryOffset + reader.ReadUInt32());

			uint handlerOffset = reader.ReadUInt32();
			eh.HandlerStart = GetInstructionThrow(handlerOffset);
			eh.HandlerEnd = GetInstruction(handlerOffset + reader.ReadUInt32());

			switch (eh.HandlerType) {
			case ExceptionHandlerType.Catch:
				eh.CatchType = module.ResolveToken(reader.ReadUInt32(), gpContext) as ITypeDefOrRef;
				break;

			case ExceptionHandlerType.Filter:
				eh.FilterStart = GetInstructionThrow(reader.ReadUInt32());
				break;

			case ExceptionHandlerType.Finally:
			case ExceptionHandlerType.Fault:
			default:
				reader.ReadUInt32();
				break;
			}

			return eh;
		}

		public override void RestoreMethod(MethodDef method) {
			base.RestoreMethod(method);
			method.Body.MaxStack = maxStackSize;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/CryptoObfuscator/MethodsDecrypter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.IO;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.CryptoObfuscator {
	class MethodsDecrypter {
		ModuleDefMD module;
		TypeDef decrypterType;
		MethodDef decryptMethod;
		MethodDef decrypterCctor;
		EmbeddedResource resource;
		List<TypeDef> delegateTypes = new List<TypeDef>();

		public TypeDef Type => decrypterType;
		public IEnumerable<TypeDef> DelegateTypes => delegateTypes;
		public EmbeddedResource Resource => resource;
		public bool Detected => decrypterType != null;
		public MethodsDecrypter(ModuleDefMD module) => this.module = module;

		public void Find() {
			foreach (var type in module.Types) {
				if (Check(type))
					break;
			}
		}

		static readonly string[] requiredFields = new string[] {
			"System.Byte[]",
			"System.Collections.Generic.Dictionary`2<System.Int32,System.Int32>",
			"System.ModuleHandle",
		};
		bool Check(TypeDef type) {
			if (type.NestedTypes.Count != 1)
				return false;
			if (type.Fields.Count != 3)
				return false;
			if (!new FieldTypes(type).All(requiredFields))
				return false;

			var cctor = type.FindStaticConstructor();
			if (cctor == null)
				return false;
			var decryptMethodTmp = FindDecryptMethod(type);
			if (decryptMethodTmp == null)
				return false;

			decryptMethod = decryptMethodTmp;
			decrypterCctor = cctor;
			decrypterType = type;
			return true;
		}

		static readonly string[] requiredLocals = new string[] {
			"System.Delegate",
			"System.ModuleHandle",
			"System.Reflection.Emit.DynamicILInfo",
			"System.Reflection.Emit.DynamicMethod",
			"System.Reflection.FieldInfo",
			"System.Reflection.FieldInfo[]",
			"System.Reflection.MethodBase",
			"System.Reflection.MethodBody",
			"System.Type",
			"System.Type[]",
		};
		static MethodDef FindDecryptMethod(TypeDef type) {
			foreach (var method in type.Methods) {
				if (!method.IsStatic || method.Body == null)
					continue;
				if (!new LocalTypes(method).All(requiredLocals))
					continue;
				if (!DotNetUtils.IsMethod(method, "System.Void", "(System.Int32,System.Int32,System.Int32)"))
					continue;

				return method;
			}
			return null;
		}

		public void Decrypt(ResourceDecrypter resourceDecrypter, ISimpleDeobfuscator simpleDeobfuscator) {
			if (decryptMethod == null)
				return;

			resource = CoUtils.GetResource(module, decrypterCctor);
			if (resource == null)
				return;
			var decrypted = resourceDecrypter.Decrypt(resource.CreateReader().AsStream());
			var reader = ByteArrayDataReaderFactory.CreateReader(decrypted);
			int numEncrypted = reader.ReadInt32();
			Logger.v("Restoring {0} encrypted methods", numEncrypted);
			Logger.Instance.Indent();
			for (int i = 0; i < numEncrypted; i++) {
				int delegateTypeToken = reader.ReadInt32();
				uint codeOffset = reader.ReadUInt32();
				var origOffset = reader.Position;
				reader.Position = codeOffset;
				Decrypt(ref reader, delegateTypeToken, simpleDeobfuscator);
				reader.Position = origOffset;
			}
			Logger.Instance.DeIndent();
		}

		void Decrypt(ref DataReader reader, int delegateTypeToken, ISimpleDeobfuscator simpleDeobfuscator) {
			var delegateType = module.ResolveToken(delegateTypeToken) as TypeDef;
			if (delegateType == null)
				throw new ApplicationException("Couldn't find delegate type");

			if (!GetTokens(delegateType, out int delToken, out int encMethToken, out int encDeclToken))
				throw new ApplicationException("Could not find encrypted method tokens");
			if (delToken != delegateTypeToken)
				throw new ApplicationException("Invalid delegate type token");
			var encType = module.ResolveToken(encDeclToken) as ITypeDefOrRef;
			if (encType == null)
				throw new ApplicationException("Invalid declaring type token");
			var encMethod = module.ResolveToken(encMethToken) as MethodDef;
			if (encMethod == null)
				throw new ApplicationException("Invalid encrypted method token");

			var bodyReader = new MethodBodyReader(module, ref reader);
			bodyReader.Read(encMethod);
			bodyReader.RestoreMethod(encMethod);
			Logger.v("Restored method {0} ({1:X8}). Instrs:{2}, Locals:{3}, Exceptions:{4}",
					Utils.RemoveNewlines(encMethod.FullName),
					encMethod.MDToken.ToInt32(),
					encMethod.Body.Instructions.Count,
					encMethod.Body.Variables.Count,
					encMethod.Body.ExceptionHandlers.Count);
			delegateTypes.Add(delegateType);
			simpleDeobfuscator.MethodModified(encMethod);
		}

		bool GetTokens(TypeDef delegateType, out int delegateToken, out int encMethodToken, out int encDeclaringTypeToken) {
			delegateToken = 0;
			encMethodToken = 0;
			encDeclaringTypeToken = 0;

			var cctor = delegateType.FindStaticConstructor();
			if (cctor == null)
				return false;

			var instrs = cctor.Body.Instructions;
			for (int i = 0; i < instrs.Count - 3; i++) {
				var ldci4_1 = instrs[i];
				if (!ldci4_1.IsLdcI4())
					continue;
				var ldci4_2 = instrs[i + 1];
				if (!ldci4_2.IsLdcI4())
					continue;
				var ldci4_3 = instrs[i + 2];
				if (!ldci4_3.IsLdcI4())
					continue;
				var call = instrs[i + 3];
				if (call.OpCode.Code != Code.Call)
					continue;
				var calledMethod = call.Operand as MethodDef;
				if (calledMethod == null)
					continue;
				if (calledMethod != decryptMethod)
					continue;

				delegateToken = ldci4_1.GetLdcI4Value();
				encMethodToken = ldci4_2.GetLdcI4Value();
				encDeclaringTypeToken = ldci4_3.GetLdcI4Value();
				return true;
			}

			return false;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/CryptoObfuscator/ProxyCallFixer.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.CryptoObfuscator {
	class ProxyCallFixer : ProxyCallFixer2 {
		Dictionary<MethodDef, ProxyCreatorType> methodToType = new Dictionary<MethodDef, ProxyCreatorType>();

		public ProxyCallFixer(ModuleDefMD module)
			: base(module) {
		}

		enum ProxyCreatorType {
			None,
			CallOrCallvirt,
			CallCtor,
			Newobj,
		}

		class Context {
			public uint typeToken;
			public uint methodToken;
			public uint declaringTypeToken;
			public ProxyCreatorType proxyCreatorType;
			public Context(uint typeToken, uint methodToken, uint declaringTypeToken, ProxyCreatorType proxyCreatorType) {
				this.typeToken = typeToken;
				this.methodToken = methodToken;
				this.declaringTypeToken = declaringTypeToken;
				this.proxyCreatorType = proxyCreatorType;
			}
		}

		protected override object CheckCctor(TypeDef type, MethodDef cctor) {
			var instructions = cctor.Body.Instructions;
			for (int i = 0; i < instructions.Count; i++) {
				var instrs = DotNetUtils.GetInstructions(instructions, i, OpCodes.Ldc_I4, OpCodes.Ldc_I4, OpCodes.Ldc_I4, OpCodes.Call);
				if (instrs == null)
					continue;

				uint typeToken = (uint)(int)instrs[0].Operand;
				uint methodToken = (uint)(int)instrs[1].Operand;
				uint declaringTypeToken = (uint)(int)instrs[2].Operand;
				var createMethod = instrs[3].Operand as MethodDef;

				if (!methodToType.TryGetValue(createMethod, out var proxyCreatorType))
					continue;

				return new Context(typeToken, methodToken, declaringTypeToken, proxyCreatorType);
			}

			return null;
		}

		protected override void GetCallInfo(object context, FieldDef field, out IMethod calledMethod, out OpCode callOpcode) {
			var ctx = (Context)context;

			switch (ctx.proxyCreatorType) {
			case ProxyCreatorType.CallOrCallvirt:
				callOpcode = field.IsFamilyOrAssembly ? OpCodes.Callvirt : OpCodes.Call;
				break;
			case ProxyCreatorType.CallCtor:
				callOpcode = OpCodes.Call;
				break;
			case ProxyCreatorType.Newobj:
				callOpcode = OpCodes.Newobj;
				break;
			default:
				throw new ApplicationException($"Invalid proxy creator type: {ctx.proxyCreatorType}");
			}

			calledMethod = module.ResolveToken(ctx.methodToken) as IMethod;
		}

		public void FindDelegateCreator() {
			foreach (var type in module.Types) {
				var createMethod = GetProxyCreateMethod(type);
				if (createMethod == null)
					continue;

				var proxyCreatorType = GetProxyCreatorType(type, createMethod);
				if (proxyCreatorType == ProxyCreatorType.None)
					continue;
				methodToType[createMethod] = proxyCreatorType;
				SetDelegateCreatorMethod(createMethod);
			}
		}

		MethodDef GetProxyCreateMethod(TypeDef type) {
			if (DotNetUtils.FindFieldType(type, "System.ModuleHandle", true) == null)
				return null;
			if (type.Fields.Count < 1 || type.Fields.Count > 22)
				return null;

			MethodDef createMethod = null;
			foreach (var m in type.Methods) {
				if (m.Name == ".ctor" || m.Name == ".cctor")
					continue;
				if (createMethod == null && DotNetUtils.IsMethod(m, "System.Void", "(System.Int32,System.Int32,System.Int32)")) {
					createMethod = m;
					continue;
				}
				continue;
			}
			if (createMethod == null || !createMethod.HasBody)
				return null;
			if (!DeobUtils.HasInteger(createMethod, 0xFFFFFF))
				return null;

			return createMethod;
		}

		ProxyCreatorType GetProxyCreatorType(TypeDef type, MethodDef createMethod) {
			int numCalls = 0, numCallvirts = 0, numNewobjs = 0;
			foreach (var instr in createMethod.Body.Instructions) {
				if (instr.OpCode.Code != Code.Ldsfld)
					continue;
				var field = instr.Operand as IField;
				if (field == null)
					continue;
				switch (field.FullName) {
				case "System.Reflection.Emit.OpCode System.Reflection.Emit.OpCodes::Call":
					numCalls++;
					break;
				case "System.Reflection.Emit.OpCode System.Reflection.Emit.OpCodes::Callvirt":
					numCallvirts++;
					break;
				case "System.Reflection.Emit.OpCode System.Reflection.Emit.OpCodes::Newobj":
					numNewobjs++;
					break;
				}
			}

			if (numCalls == 1 && numCallvirts == 1 && numNewobjs == 0)
				return ProxyCreatorType.CallOrCallvirt;
			if (numCalls == 1 && numCallvirts == 0 && numNewobjs == 0)
				return ProxyCreatorType.CallCtor;
			if (numCalls == 0 && numCallvirts == 0 && numNewobjs == 1)
				return ProxyCreatorType.Newobj;
			return ProxyCreatorType.None;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/CryptoObfuscator/ResourceDecrypter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Security.Cryptography;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.CryptoObfuscator {
	class ResourceDecrypter {
		const int BUFLEN = 0x8000;
		ModuleDefMD module;
		TypeDef resourceDecrypterType;
		byte[] buffer1 = new byte[BUFLEN];
		byte[] buffer2 = new byte[BUFLEN];
		byte desEncryptedFlag;
		byte deflatedFlag;
		byte bitwiseNotEncryptedFlag;
		FrameworkType frameworkType;
		bool flipFlagsBits;
		bool skipBeforeFlag;
		int skipBytes;

		public ResourceDecrypter(ModuleDefMD module, ISimpleDeobfuscator simpleDeobfuscator) {
			this.module = module;
			frameworkType = DotNetUtils.GetFrameworkType(module);
			Find(simpleDeobfuscator);
		}

		void Find(ISimpleDeobfuscator simpleDeobfuscator) {
			switch (frameworkType) {
			case FrameworkType.Silverlight:
				FindSilverlight();
				break;

			case FrameworkType.Desktop:
			case FrameworkType.CompactFramework:
				if (!module.IsClr1x) {
					if (FindDesktopOrCompactFramework())
						break;
				}
				FindDesktopOrCompactFrameworkV1();
				break;
			}

			InitializeHeaderInfo(simpleDeobfuscator);
		}

		static string[] requiredTypes = new string[] {
			"System.IO.MemoryStream",
			"System.Object",
			"System.Int32",
		};
		bool FindDesktopOrCompactFramework() {
			resourceDecrypterType = null;
			foreach (var type in module.Types) {
				if (type.Fields.Count < 5)
					continue;
				if (!new FieldTypes(type).All(requiredTypes))
					continue;

				var cctor = type.FindStaticConstructor();
				if (cctor == null)
					continue;

				if (!CheckCctor(cctor))
					continue;

				resourceDecrypterType = type;
				return true;
			}
			return false;
		}

		bool CheckCctor(MethodDef cctor) {
			if (cctor.Body == null)
				return false;
			int stsfldCount = 0;
			foreach (var instr in cctor.Body.Instructions) {
				if (instr.OpCode.Code == Code.Stsfld) {
					var field = instr.Operand as IField;
					if (!new SigComparer().Equals(cctor.DeclaringType, field.DeclaringType))
						return false;
					stsfldCount++;
				}
			}
			return stsfldCount >= cctor.DeclaringType.Fields.Count;
		}

		static string[] requiredLocals_v1 = new string[] {
			"System.Boolean",
			"System.Byte",
			"System.Byte[]",
			"System.Int32",
			"System.Security.Cryptography.DESCryptoServiceProvider",
		};
		bool FindDesktopOrCompactFrameworkV1() {
			resourceDecrypterType = null;
			foreach (var type in module.Types) {
				if (type.Fields.Count != 0)
					continue;

				foreach (var method in GetDecrypterMethods(type)) {
					if (method == null)
						continue;
					if (!new LocalTypes(method).Exactly(requiredLocals_v1))
						continue;
					if (!DotNetUtils.CallsMethod(method, "System.Int64", "()"))
						continue;
					if (!DotNetUtils.CallsMethod(method, "System.Int32", "(System.Byte[],System.Int32,System.Int32)"))
						continue;
					if (!DotNetUtils.CallsMethod(method, "System.Void", "(System.Array,System.Int32,System.Array,System.Int32,System.Int32)"))
						continue;
					if (!DotNetUtils.CallsMethod(method, "System.Security.Cryptography.ICryptoTransform", "()"))
						continue;
					if (!DotNetUtils.CallsMethod(method, "System.Byte[]", "(System.Byte[],System.Int32,System.Int32)"))
						continue;

					resourceDecrypterType = type;
					return true;
				}
			}
			return false;
		}

		static string[] requiredLocals_sl = new string[] {
			"System.Byte",
			"System.Byte[]",
			"System.Int32",
		};
		void FindSilverlight() {
			foreach (var type in module.Types) {
				if (type.Fields.Count > 0)
					continue;
				if (type.HasNestedTypes || type.HasGenericParameters)
					continue;

				foreach (var method in GetDecrypterMethods(type)) {
					if (method == null)
						continue;
					if (!new LocalTypes(method).All(requiredLocals_sl))
						continue;

					resourceDecrypterType = type;
					return;
				}
			}
		}

		void InitializeHeaderInfo(ISimpleDeobfuscator simpleDeobfuscator) {
			skipBytes = 0;

			foreach (var method in GetDecrypterMethods(resourceDecrypterType)) {
				if (UpdateFlags(method, simpleDeobfuscator))
					return;
			}

			desEncryptedFlag = 1;
			deflatedFlag = 2;
			bitwiseNotEncryptedFlag = 4;
		}

		static bool CheckFlipBits(MethodDef method, out int index) {
			int nots = 0, i;
			var instrs = method.Body.Instructions;
			index = -1;
			for (i = 0; i < instrs.Count - 1; i++) {
				var ldloc = instrs[i];
				if (!ldloc.IsLdloc())
					continue;
				var local = ldloc.GetLocal(method.Body.Variables);
				if (local == null || local.Type.GetElementType().GetPrimitiveSize() < 0)
					continue;
				if (instrs[i + 1].OpCode.Code == Code.Not) {
					nots++;
					index = i + 1;
				}
			}
			return (nots & 1) == 1;
		}

		bool UpdateFlags(MethodDef method, ISimpleDeobfuscator simpleDeobfuscator) {
			if (method == null || method.Body == null || method.Body.Variables.Count < 3)
				return false;

			var constants = new List<int>();
			simpleDeobfuscator.Deobfuscate(method);
			var instructions = method.Body.Instructions;
			for (int i = 2; i < instructions.Count; i++) {
				var and = instructions[i];
				if (and.OpCode.Code != Code.And)
					continue;
				var ldci4 = instructions[i - 1];
				if (!ldci4.IsLdcI4())
					continue;
				int flagValue = ldci4.GetLdcI4Value();
				if (!IsFlag(flagValue))
					continue;
				var ldloc = instructions[i - 2];
				if (!ldloc.IsLdloc())
					continue;
				var local = ldloc.GetLocal(method.Body.Variables);
				if (local.Type.GetElementType().GetPrimitiveSize() < 0)
					continue;
				constants.Add(flagValue);
			}

			flipFlagsBits = CheckFlipBits(method, out int notIndex);
			skipBytes = GetHeaderSkipBytes(method, out int skipIndex);
			skipBeforeFlag = skipIndex < notIndex;

			switch (frameworkType) {
			case FrameworkType.Desktop:
				if (!module.IsClr1x) {
					if (constants.Count == 2) {
						desEncryptedFlag = (byte)constants[0];
						deflatedFlag = (byte)constants[1];
						return true;
					}
				}
				if (constants.Count == 1) {
					desEncryptedFlag = (byte)constants[0];
					return true;
				}
				break;

			case FrameworkType.Silverlight:
				if (constants.Count == 1) {
					bitwiseNotEncryptedFlag = (byte)constants[0];
					return true;
				}
				break;

			case FrameworkType.CompactFramework:
				if (constants.Count == 1) {
					desEncryptedFlag = (byte)constants[0];
					return true;
				}
				break;
			}

			return false;
		}

		static int GetHeaderSkipBytes(MethodDef method, out int index) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 1; i++) {
				var ldci4 = instrs[i];
				if (!ldci4.IsLdcI4())
					continue;
				int loopCount = ldci4.GetLdcI4Value();
				if (loopCount < 2 || loopCount > 4)
					continue;
				var blt = instrs[i + 1];
				if (blt.OpCode.Code != Code.Blt && blt.OpCode.Code != Code.Blt_S && blt.OpCode.Code != Code.Clt)
					continue;
				index = i;
				return loopCount - 1;
			}
			index = 0;
			return 0;
		}

		static bool IsFlag(int value) {
			for (uint tmp = (uint)value; tmp != 0; tmp >>= 1) {
				if ((tmp & 1) != 0)
					return tmp == 1;
			}
			return false;
		}

		static IEnumerable<MethodDef> GetDecrypterMethods(TypeDef type) {
			if (type == null)
				yield break;
			foreach (var method in type.Methods) {
				if (DotNetUtils.IsMethod(method, "System.Byte[]", "(System.IO.Stream)"))
					yield return method;
				else if (DotNetUtils.IsMethod(method, "System.Byte[]", "(System.Int64,System.IO.Stream)"))
					yield return method;
				else if (DotNetUtils.IsMethod(method, "System.Byte[]", "(System.Int64,System.IO.Stream,System.UInt32)"))
					yield return method;
				else if (DotNetUtils.IsMethod(method, "System.Byte[]", "(System.Int32,System.IO.Stream)"))
					yield return method;
				else if (DotNetUtils.IsMethod(method, "System.Byte[]", "(System.Int16,System.IO.Stream)"))
					yield return method;
				else if (DotNetUtils.IsMethod(method, "System.Byte[]", "(System.Byte,System.IO.Stream)"))
					yield return method;
				else if (DotNetUtils.IsMethod(method, "System.Byte[]", "(System.SByte,System.IO.Stream)"))
					yield return method;
				else if (DotNetUtils.IsMethod(method, "System.Byte[]", "(System.Byte,System.IO.Stream,System.Int32)"))
					yield return method;
				else if (DotNetUtils.IsMethod(method, "System.Byte[]", "(System.SByte,System.IO.Stream,System.UInt32)"))
					yield return method;
				else if (DotNetUtils.IsMethod(method, "System.Byte[]", "(System.Char,System.IO.Stream)"))
					yield return method;
				else if (DotNetUtils.IsMethod(method, "System.Byte[]", "(System.Int64,System.Object)"))
					yield return method;
			}
		}

		public byte[] Decrypt(Stream resourceStream) {
			var sourceStream = resourceStream;
			int sourceStreamOffset = 1;
			bool didSomething = false;

			if (skipBeforeFlag) {
				sourceStream.Position += skipBytes;
				sourceStreamOffset += skipBytes;
			}
			byte flags = (byte)sourceStream.ReadByte();
			if (flipFlagsBits)
				flags = (byte)~flags;
			if (!skipBeforeFlag) {
				sourceStream.Position += skipBytes;
				sourceStreamOffset += skipBytes;
			}

			byte allFlags = (byte)(desEncryptedFlag | deflatedFlag | bitwiseNotEncryptedFlag);
			if ((flags & ~allFlags) != 0)
				Logger.w("Found unknown resource encryption flags: 0x{0:X2}", flags);

			if ((flags & desEncryptedFlag) != 0) {
				var memStream = new MemoryStream((int)resourceStream.Length);
				using (var provider = new DESCryptoServiceProvider()) {
					var iv = new byte[8];
					sourceStream.Read(iv, 0, 8);
					provider.IV = iv;
					provider.Key = GetKey(sourceStream);

					using (var transform = provider.CreateDecryptor()) {
						while (true) {
							int count = sourceStream.Read(buffer1, 0, buffer1.Length);
							if (count <= 0)
								break;
							int count2 = transform.TransformBlock(buffer1, 0, count, buffer2, 0);
							memStream.Write(buffer2, 0, count2);
						}
						var finalData = transform.TransformFinalBlock(buffer1, 0, 0);
						memStream.Write(finalData, 0, finalData.Length);
					}
				}
				sourceStream = memStream;
				sourceStreamOffset = 0;
				didSomething = true;
			}

			if ((flags & deflatedFlag) != 0) {
				var memStream = new MemoryStream((int)resourceStream.Length);
				sourceStream.Position = sourceStreamOffset;
				using (var inflater = new DeflateStream(sourceStream, CompressionMode.Decompress)) {
					while (true) {
						int count = inflater.Read(buffer1, 0, buffer1.Length);
						if (count <= 0)
							break;
						memStream.Write(buffer1, 0, count);
					}
				}

				sourceStream = memStream;
				sourceStreamOffset = 0;
				didSomething = true;
			}

			if ((flags & bitwiseNotEncryptedFlag) != 0) {
				var memStream = new MemoryStream((int)resourceStream.Length);
				sourceStream.Position = sourceStreamOffset;
				for (int i = sourceStreamOffset; i < sourceStream.Length; i++)
					memStream.WriteByte((byte)~sourceStream.ReadByte());

				sourceStream = memStream;
				sourceStreamOffset = 0;
				didSomething = true;
			}

			if (didSomething && sourceStream is MemoryStream) {
				var memStream = (MemoryStream)sourceStream;
				return memStream.ToArray();
			}
			else {
				int len = (int)(sourceStream.Length - sourceStream.Position);
				byte[] data = new byte[len];
				sourceStream.Read(data, 0, len);
				return data;
			}
		}

		byte[] GetKey(Stream resourceStream) {
			byte[] key = new byte[8];
			resourceStream.Read(key, 0, key.Length);
			for (int i = 0; i < key.Length; i++) {
				if (key[i] != 0)
					return key;
			}
			key = PublicKeyBase.GetRawData(module.Assembly.PublicKeyToken);
			if (key == null)
				throw new ApplicationException("PublicKeyToken is null, can't decrypt resources");
			return key;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/CryptoObfuscator/ResourceResolver.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.CryptoObfuscator {
	class ResourceResolver {
		ModuleDefMD module;
		ResourceDecrypter resourceDecrypter;
		TypeDef resolverType;
		MethodDef resolverMethod;
		ResolverVersion resolverVersion = ResolverVersion.V1;
		bool mergedIt = false;

		enum ResolverVersion {
			None,
			V1,
			V2,
		}

		public TypeDef Type => resolverType;
		public MethodDef Method => resolverMethod;

		public ResourceResolver(ModuleDefMD module, ResourceDecrypter resourceDecrypter) {
			this.module = module;
			this.resourceDecrypter = resourceDecrypter;
		}

		public void Find() {
			var cctor = DotNetUtils.GetModuleTypeCctor(module);
			if (cctor == null)
				return;

			foreach (var method in DotNetUtils.GetCalledMethods(module, cctor)) {
				if (method.Name == ".cctor" || method.Name == ".ctor")
					continue;
				if (!method.IsStatic || !DotNetUtils.IsMethod(method, "System.Void", "()"))
					continue;
				if (CheckType(method))
					break;
			}
		}

		public EmbeddedResource MergeResources() {
			if (mergedIt)
				return null;

			var resource = DotNetUtils.GetResource(module, GetResourceNames()) as EmbeddedResource;
			if (resource == null)
				return null;

			DeobUtils.DecryptAndAddResources(module, resource.Name.String, () => resourceDecrypter.Decrypt(resource.CreateReader().AsStream()));
			mergedIt = true;
			return resource;
		}

		IEnumerable<string> GetResourceNames() {
			var names = new List<string>();

			switch (resolverVersion) {
			case ResolverVersion.V1:
				names.Add(module.Assembly.Name.String);
				break;

			case ResolverVersion.V2:
				names.Add($"{module.Assembly.Name.String}{module.Assembly.Name.String}{module.Assembly.Name.String}");
				names.Add($"{module.Assembly.Name.String}&");
				break;

			default:
				throw new ApplicationException("Unknown version");
			}

			return names;
		}

		bool CheckType(MethodDef initMethod) {
			if (!initMethod.HasBody)
				return false;
			if (DotNetUtils.FindFieldType(initMethod.DeclaringType, "System.Reflection.Assembly", true) == null)
				return false;

			resolverVersion = CheckSetupMethod(initMethod);
			if (resolverVersion == ResolverVersion.None)
				resolverVersion = CheckSetupMethod(initMethod.DeclaringType.FindStaticConstructor());
			if (resolverVersion == ResolverVersion.None)
				return false;

			resolverType = initMethod.DeclaringType;
			resolverMethod = initMethod;
			return true;
		}

		ResolverVersion CheckSetupMethod(MethodDef setupMethod) {
			var instructions = setupMethod.Body.Instructions;
			int foundCount = 0;
			for (int i = 0; i < instructions.Count; i++) {
				var instrs = DotNetUtils.GetInstructions(instructions, i, OpCodes.Ldnull, OpCodes.Ldftn, OpCodes.Newobj);
				if (instrs == null)
					continue;

				IMethod methodRef;
				var ldftn = instrs[1];
				var newobj = instrs[2];

				methodRef = ldftn.Operand as IMethod;
				if (methodRef == null || !new SigComparer().Equals(setupMethod.DeclaringType, methodRef.DeclaringType))
					continue;

				methodRef = newobj.Operand as IMethod;
				if (methodRef == null || methodRef.FullName != "System.Void System.ResolveEventHandler::.ctor(System.Object,System.IntPtr)")
					continue;

				foundCount++;
			}
			if (foundCount == 0)
				return ResolverVersion.None;

			switch (foundCount) {
			case 1: return ResolverVersion.V1;
			case 2: return ResolverVersion.V2;
			default: return ResolverVersion.None;
			}
		}
	}
}



================================================
File: de4dot.code/deobfuscators/CryptoObfuscator/StringDecrypter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Text;
using dnlib.DotNet;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.CryptoObfuscator {
	class StringDecrypter {
		ModuleDefMD module;
		EmbeddedResource stringResource;
		TypeDef stringDecrypterType;
		MethodDef stringDecrypterMethod;
		byte[] decryptedData;

		public bool Detected => stringDecrypterType != null;
		public TypeDef Type => stringDecrypterType;
		public MethodDef Method => stringDecrypterMethod;
		public EmbeddedResource Resource => stringResource;
		public StringDecrypter(ModuleDefMD module) => this.module = module;

		public void Find() {
			if (!FindStringDecrypterType(out var type, out var method))
				return;

			stringDecrypterType = type;
			stringDecrypterMethod = method;
		}

		public void Initialize(ResourceDecrypter resourceDecrypter) {
			if (decryptedData != null || stringDecrypterType == null)
				return;

			var resourceName = GetResourceName();
			stringResource = DotNetUtils.GetResource(module, resourceName) as EmbeddedResource;
			if (stringResource == null)
				return;
			Logger.v("Adding string decrypter. Resource: {0}", Utils.ToCsharpString(stringResource.Name));

			decryptedData = resourceDecrypter.Decrypt(stringResource.CreateReader().AsStream());
		}

		string GetResourceName() {
			var defaultName = module.Assembly.Name.String + module.Assembly.Name.String;

			var cctor = stringDecrypterType.FindStaticConstructor();
			if (cctor == null)
				return defaultName;

			foreach (var s in DotNetUtils.GetCodeStrings(cctor)) {
				if (DotNetUtils.GetResource(module, s) != null)
					return s;
				try {
					return Encoding.UTF8.GetString(Convert.FromBase64String(s));
				}
				catch {
					string s2 = CoUtils.DecryptResourceName(module, cctor);
					try {
						return Encoding.UTF8.GetString(Convert.FromBase64String(s2));
					}
					catch {
					}
				}
			}

			return defaultName;
		}

		public string Decrypt(int index) {
			int len = DeobUtils.ReadVariableLengthInt32(decryptedData, ref index);
			return Encoding.Unicode.GetString(decryptedData, index, len);
		}

		bool FindStringDecrypterType(out TypeDef theType, out MethodDef theMethod) {
			theType = null;
			theMethod = null;

			foreach (var type in module.Types) {
				if (type.IsPublic)
					continue;
				if (type.Fields.Count != 1)
					continue;
				if (DotNetUtils.FindFieldType(type, "System.Byte[]", true) == null)
					continue;
				if (type.Methods.Count != 2 && type.Methods.Count != 3)
					continue;
				if (type.NestedTypes.Count > 0)
					continue;

				MethodDef method = null;
				foreach (var m in type.Methods) {
					if (m.Name == ".ctor" || m.Name == ".cctor")
						continue;
					if (DotNetUtils.IsMethod(m, "System.String", "(System.Int32)")) {
						method = m;
						continue;
					}
					break;
				}
				if (method == null)
					continue;

				theType = type;
				theMethod = method;
				return true;
			}

			return false;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/CryptoObfuscator/TamperDetection.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using dnlib.DotNet;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.CryptoObfuscator {
	class TamperDetection {
		ModuleDefMD module;
		TypeDef tamperType;
		MethodDef tamperMethod;
		FrameworkType frameworkType;

		public bool Detected => tamperMethod != null;
		public TypeDef Type => tamperType;
		public MethodDef Method => tamperMethod;

		public TamperDetection(ModuleDefMD module) {
			this.module = module;
			frameworkType = DotNetUtils.GetFrameworkType(module);
		}

		public void Find() {
			if (Find(module.EntryPoint))
				return;
			if (Find(DotNetUtils.GetModuleTypeCctor(module)))
				return;
		}

		bool Find(MethodDef methodToCheck) {
			if (methodToCheck == null)
				return false;

			foreach (var method in DotNetUtils.GetCalledMethods(module, methodToCheck)) {
				bool result = false;
				switch (frameworkType) {
				case FrameworkType.Desktop:
					result = FindDesktop(method);
					break;
				case FrameworkType.Silverlight:
					result = FindSilverlight(method);
					break;
				case FrameworkType.CompactFramework:
					result = FindCompactFramework(method);
					break;
				}
				if (!result)
					continue;

				tamperType = method.DeclaringType;
				tamperMethod = method;
				return true;
			}

			return false;
		}

		bool FindDesktop(MethodDef method) {
			var type = method.DeclaringType;

			if (!method.IsStatic || !DotNetUtils.IsMethod(method, "System.Void", "()"))
				return false;
			if (type.Methods.Count < 3 || type.Methods.Count > 31)
				return false;
			if (DotNetUtils.GetPInvokeMethod(type, "mscoree", "StrongNameSignatureVerificationEx") != null) {
			}
			else if (DotNetUtils.GetPInvokeMethod(type, "mscoree", "CLRCreateInstance") != null) {
				if (type.NestedTypes.Count != 3)
					return false;
				if (!type.NestedTypes[0].IsInterface || !type.NestedTypes[1].IsInterface || !type.NestedTypes[2].IsInterface)
					return false;
			}
			else
				return false;

			return true;
		}

		static string[] requiredLocals_sl = new string[] {
			"System.Boolean",
			"System.Byte[]",
			"System.Int32",
			"System.Reflection.AssemblyName",
			"System.String",
		};
		bool FindSilverlight(MethodDef method) {
			if (!new LocalTypes(method).Exactly(requiredLocals_sl))
				return false;
			if (!DotNetUtils.CallsMethod(method, "System.Int32 System.String::get_Length()"))
				return false;
			if (!DotNetUtils.CallsMethod(method, "System.Byte[] System.Convert::FromBase64String(System.String)"))
				return false;
			if (!DotNetUtils.CallsMethod(method, "System.Reflection.Assembly System.Reflection.Assembly::GetExecutingAssembly()"))
				return false;
			if (!DotNetUtils.CallsMethod(method, "System.String System.Reflection.Assembly::get_FullName()"))
				return false;
			if (!DotNetUtils.CallsMethod(method, "System.Byte[] System.Reflection.AssemblyName::GetPublicKeyToken()"))
				return false;
			if (DotNetUtils.CallsMethod(method, "System.String", "(System.Reflection.Assembly)")) {
			}
			else if (DotNetUtils.CallsMethod(method, "System.String System.Reflection.AssemblyName::get_Name()")) {
			}
			else
				return false;

			return true;
		}

		static string[] requiredLocals_cf = new string[] {
			"System.Boolean",
			"System.Byte[]",
			"System.Int32",
			"System.String",
		};
		bool FindCompactFramework(MethodDef method) {
			if (!new LocalTypes(method).Exactly(requiredLocals_cf))
				return false;
			if (!DotNetUtils.CallsMethod(method, "System.Int32 System.String::get_Length()"))
				return false;
			if (!DotNetUtils.CallsMethod(method, "System.Byte[] System.Convert::FromBase64String(System.String)"))
				return false;
			if (!DotNetUtils.CallsMethod(method, "System.Reflection.Assembly System.Reflection.Assembly::GetExecutingAssembly()"))
				return false;

			if (DotNetUtils.CallsMethod(method, "System.Byte[]", "(System.Reflection.Assembly)") &&
				DotNetUtils.CallsMethod(method, "System.String", "(System.Reflection.Assembly)")) {
			}
			else if (DotNetUtils.CallsMethod(method, "System.Reflection.AssemblyName System.Reflection.Assembly::GetName()") &&
					DotNetUtils.CallsMethod(method, "System.Byte[] System.Reflection.AssemblyName::GetPublicKeyToken()")) {
			}
			else
				return false;

			return true;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/DeepSea/ArrayBlockDeobfuscator.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;
using de4dot.blocks.cflow;

namespace de4dot.code.deobfuscators.DeepSea {
	class ArrayBlockDeobfuscator : BlockDeobfuscator {
		ArrayBlockState arrayBlockState;
		Dictionary<Local, ArrayBlockState.FieldInfo> localToInfo = new Dictionary<Local, ArrayBlockState.FieldInfo>();
		DsConstantsReader constantsReader;

		public ArrayBlockDeobfuscator(ArrayBlockState arrayBlockState) => this.arrayBlockState = arrayBlockState;

		public override void DeobfuscateBegin(Blocks blocks) {
			base.DeobfuscateBegin(blocks);
			InitLocalToInfo();
		}

		void InitLocalToInfo() {
			localToInfo.Clear();

			foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {
				var instrs = block.Instructions;
				for (int i = 0; i < instrs.Count - 1; i++) {
					var ldsfld = instrs[i];
					if (ldsfld.OpCode.Code != Code.Ldsfld)
						continue;
					var stloc = instrs[i + 1];
					if (!stloc.IsStloc())
						continue;

					var info = arrayBlockState.GetFieldInfo((IField)ldsfld.Operand);
					if (info == null)
						continue;
					var local = stloc.Instruction.GetLocal(blocks.Locals);
					if (local == null)
						continue;

					localToInfo[local] = info;
				}
			}
		}

		protected override bool Deobfuscate(Block block) {
			bool modified = false;

			constantsReader = null;
			var instrs = block.Instructions;
			for (int i = 0; i < instrs.Count; i++) {
				bool ch = Deobfuscate1(block, i);
				if (ch) {
					modified = true;
					continue;
				}

				ch = Deobfuscate2(block, i);
				if (ch) {
					modified = true;
					continue;
				}

				ch = Deobfuscate3(block, i);
				if (ch) {
					modified = true;
					continue;
				}
			}

			return modified;
		}

		static bool IsLdelem(ArrayBlockState.FieldInfo info, Code code) {
			switch (info.elementType) {
			case ElementType.Boolean:
			case ElementType.I1:
			case ElementType.U1:
				return code == Code.Ldelem_I1 || code == Code.Ldelem_U1;

			case ElementType.Char:
			case ElementType.I2:
			case ElementType.U2:
				return code == Code.Ldelem_I2 || code == Code.Ldelem_U2;

			case ElementType.I4:
			case ElementType.U4:
				return code == Code.Ldelem_I4 || code == Code.Ldelem_U4;

			default:
				return false;
			}
		}

		static bool IsStelem(ArrayBlockState.FieldInfo info, Code code) {
			switch (info.elementType) {
			case ElementType.Boolean:
			case ElementType.I1:
			case ElementType.U1:
				return code == Code.Stelem_I1;

			case ElementType.Char:
			case ElementType.I2:
			case ElementType.U2:
				return code == Code.Stelem_I2;

			case ElementType.I4:
			case ElementType.U4:
				return code == Code.Stelem_I4;

			default:
				return false;
			}
		}

		bool Deobfuscate1(Block block, int i) {
			var instrs = block.Instructions;
			if (i >= instrs.Count - 2)
				return false;

			var ldloc = instrs[i];
			if (!ldloc.IsLdloc())
				return false;
			var local = ldloc.Instruction.GetLocal(blocks.Locals);
			if (local == null)
				return false;
			if (!localToInfo.TryGetValue(local, out var info))
				return false;

			var ldci4 = instrs[i + 1];
			if (!ldci4.IsLdcI4())
				return false;

			var ldelem = instrs[i + 2];
			if (!IsLdelem(info, ldelem.OpCode.Code))
				return false;

			block.Remove(i, 3 - 1);
			instrs[i] = new Instr(Instruction.CreateLdcI4((int)info.ReadArrayElement(ldci4.GetLdcI4Value())));
			return true;
		}

		bool Deobfuscate2(Block block, int i) {
			var instrs = block.Instructions;
			if (i >= instrs.Count - 2)
				return false;

			var ldsfld = instrs[i];
			if (ldsfld.OpCode.Code != Code.Ldsfld)
				return false;
			var info = arrayBlockState.GetFieldInfo(ldsfld.Operand as IField);
			if (info == null)
				return false;

			var ldci4 = instrs[i + 1];
			if (!ldci4.IsLdcI4())
				return false;

			var ldelem = instrs[i + 2];
			if (!IsLdelem(info, ldelem.OpCode.Code))
				return false;

			block.Remove(i, 3 - 1);
			instrs[i] = new Instr(Instruction.CreateLdcI4((int)info.ReadArrayElement(ldci4.GetLdcI4Value())));
			return true;
		}

		bool Deobfuscate3(Block block, int i) {
			var instrs = block.Instructions;
			if (i + 1 >= instrs.Count)
				return false;

			int start = i;
			var ldsfld = instrs[i];
			if (ldsfld.OpCode.Code != Code.Ldsfld)
				return false;
			var info = arrayBlockState.GetFieldInfo(ldsfld.Operand as IField);
			if (info == null)
				return false;

			if (!instrs[i + 1].IsLdcI4())
				return false;

			var constants = GetConstantsReader(block);
			i += 2;
			if (!constants.GetInt32(ref i, out int value))
				return false;

			if (i >= instrs.Count)
				return false;
			var stelem = instrs[i];
			if (!IsStelem(info, stelem.OpCode.Code))
				return false;

			block.Remove(start, i - start + 1);
			return true;
		}

		DsConstantsReader GetConstantsReader(Block block) {
			if (constantsReader != null)
				return constantsReader;
			return constantsReader = new DsConstantsReader(block.Instructions);
		}
	}
}



================================================
File: de4dot.code/deobfuscators/DeepSea/ArrayBlockState.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.DeepSea {
	class ArrayBlockState {
		ModuleDefMD module;
		FieldDefAndDeclaringTypeDict<FieldInfo> fieldToInfo = new FieldDefAndDeclaringTypeDict<FieldInfo>();

		public class FieldInfo {
			public readonly ElementType elementType;
			public readonly FieldDef field;
			public readonly FieldDef arrayInitField;
			public readonly Array array;

			public FieldInfo(FieldDef field, FieldDef arrayInitField) {
				this.field = field;
				elementType = ((SZArraySig)field.FieldType).Next.GetElementType();
				this.arrayInitField = arrayInitField;
				array = CreateArray(elementType, arrayInitField.InitialValue);
			}

			static Array CreateArray(ElementType etype, byte[] data) {
				switch (etype) {
				case ElementType.Boolean:
				case ElementType.I1:
				case ElementType.U1:
					return (byte[])data.Clone();

				case ElementType.Char:
				case ElementType.I2:
				case ElementType.U2:
					var ary2 = new ushort[data.Length / 2];
					Buffer.BlockCopy(data, 0, ary2, 0, ary2.Length * 2);
					return ary2;

				case ElementType.I4:
				case ElementType.U4:
					var ary4 = new uint[data.Length / 4];
					Buffer.BlockCopy(data, 0, ary4, 0, ary4.Length * 4);
					return ary4;

				default:
					throw new ApplicationException("Invalid etype");
				}
			}

			public uint ReadArrayElement(int index) {
				switch (elementType) {
				case ElementType.Boolean:
				case ElementType.I1:
				case ElementType.U1:
					return ((byte[])array)[index];

				case ElementType.Char:
				case ElementType.I2:
				case ElementType.U2:
					return ((ushort[])array)[index];

				case ElementType.I4:
				case ElementType.U4:
					return ((uint[])array)[index];

				default:
					throw new ApplicationException("Invalid etype");
				}
			}
		}

		public bool Detected => fieldToInfo.Count != 0;
		public ArrayBlockState(ModuleDefMD module) => this.module = module;

		public void Initialize(ISimpleDeobfuscator simpleDeobfuscator) =>
			InitializeArrays(simpleDeobfuscator, DotNetUtils.GetModuleTypeCctor(module));

		void InitializeArrays(ISimpleDeobfuscator simpleDeobfuscator, MethodDef method) {
			if (method == null || method.Body == null)
				return;
			while (InitializeArrays2(simpleDeobfuscator, method)) {
			}
		}

		bool InitializeArrays2(ISimpleDeobfuscator simpleDeobfuscator, MethodDef method) {
			bool foundField = false;
			simpleDeobfuscator.Deobfuscate(method, SimpleDeobfuscatorFlags.Force);
			var instructions = method.Body.Instructions;
			for (int i = 0; i < instructions.Count; i++) {
				var ldci4 = instructions[i];
				if (!ldci4.IsLdcI4())
					continue;
				i++;
				var instrs = DotNetUtils.GetInstructions(instructions, i, OpCodes.Newarr, OpCodes.Dup, OpCodes.Ldtoken, OpCodes.Call, OpCodes.Stsfld);
				if (instrs == null)
					continue;

				var arrayInitField = instrs[2].Operand as FieldDef;
				if (arrayInitField == null || arrayInitField.InitialValue == null || arrayInitField.InitialValue.Length == 0)
					continue;

				var calledMethod = instrs[3].Operand as IMethod;
				if (calledMethod == null || calledMethod.FullName != "System.Void System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(System.Array,System.RuntimeFieldHandle)")
					continue;

				var targetField = instrs[4].Operand as FieldDef;
				if (targetField == null || targetField.FieldType.GetElementType() != ElementType.SZArray)
					continue;
				var etype = ((SZArraySig)targetField.FieldType).Next.GetElementType();
				if (etype < ElementType.Boolean || etype > ElementType.U4)
					continue;

				if (fieldToInfo.Find(targetField) == null) {
					fieldToInfo.Add(targetField, new FieldInfo(targetField, arrayInitField));
					foundField = true;
				}
			}
			return foundField;
		}

		public FieldInfo GetFieldInfo(IField fieldRef) {
			if (fieldRef == null)
				return null;
			return fieldToInfo.Find(fieldRef);
		}

		public IEnumerable<FieldDef> CleanUp() {
			var removedFields = new List<FieldDef>();
			var moduleCctor = DotNetUtils.GetModuleTypeCctor(module);
			if (moduleCctor == null)
				return removedFields;
			var moduleCctorBlocks = new Blocks(moduleCctor);

			var keep = FindFieldsToKeep();
			foreach (var fieldInfo in fieldToInfo.GetValues()) {
				if (keep.ContainsKey(fieldInfo))
					continue;
				if (RemoveInitCode(moduleCctorBlocks, fieldInfo)) {
					removedFields.Add(fieldInfo.field);
					removedFields.Add(fieldInfo.arrayInitField);
				}
				fieldInfo.arrayInitField.InitialValue = new byte[1];
				fieldInfo.arrayInitField.FieldSig.Type = module.CorLibTypes.Byte;
				fieldInfo.arrayInitField.RVA = 0;
			}

			moduleCctorBlocks.GetCode(out var allInstructions, out var allExceptionHandlers);
			DotNetUtils.RestoreBody(moduleCctorBlocks.Method, allInstructions, allExceptionHandlers);
			return removedFields;
		}

		bool RemoveInitCode(Blocks blocks, FieldInfo info) {
			bool removedSomething = false;
			foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {
				var instrs = block.Instructions;
				for (int i = 0; i < instrs.Count - 5; i++) {
					var ldci4 = instrs[i];
					if (!ldci4.IsLdcI4())
						continue;
					if (instrs[i + 1].OpCode.Code != Code.Newarr)
						continue;
					if (instrs[i + 2].OpCode.Code != Code.Dup)
						continue;
					var ldtoken = instrs[i + 3];
					if (ldtoken.OpCode.Code != Code.Ldtoken)
						continue;
					if (ldtoken.Operand != info.arrayInitField)
						continue;
					var call = instrs[i + 4];
					if (call.OpCode.Code != Code.Call)
						continue;
					var calledMethod = call.Operand as IMethod;
					if (calledMethod == null || calledMethod.FullName != "System.Void System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(System.Array,System.RuntimeFieldHandle)")
						continue;
					var stsfld = instrs[i + 5];
					if (stsfld.OpCode.Code != Code.Stsfld)
						continue;
					if (stsfld.Operand != info.field)
						continue;
					block.Remove(i, 6);
					i--;
					removedSomething = true;
				}
			}
			return removedSomething;
		}

		Dictionary<FieldInfo, bool> FindFieldsToKeep() {
			var keep = new Dictionary<FieldInfo, bool>();
			foreach (var type in module.GetTypes()) {
				foreach (var method in type.Methods) {
					if (type == DotNetUtils.GetModuleType(module) && method.Name == ".cctor")
						continue;
					if (method.Body == null)
						continue;

					foreach (var instr in method.Body.Instructions) {
						var field = instr.Operand as IField;
						if (field == null)
							continue;
						var fieldInfo = fieldToInfo.Find(field);
						if (fieldInfo == null)
							continue;
						keep[fieldInfo] = true;
					}
				}
			}
			return keep;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/DeepSea/AssemblyResolver.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.DeepSea {
	class AssemblyResolver : ResolverBase {
		Version version;
		List<FieldInfo> fieldInfos;
		MethodDef decryptMethod;

		enum Version {
			Unknown,
			V3Old,
			V3,
			V4,
			V404,
			V41,
			V41SL,
		}

		public class AssemblyInfo {
			public byte[] data;
			public string fullName;
			public string simpleName;
			public string extension;
			public EmbeddedResource resource;

			public AssemblyInfo(byte[] data, string fullName, string simpleName, string extension, EmbeddedResource resource) {
				this.data = data;
				this.fullName = fullName;
				this.simpleName = simpleName;
				this.extension = extension;
				this.resource = resource;
			}

			public override string ToString() => fullName;
		}

		class FieldInfo {
			public FieldDef field;
			public int magic;

			public FieldInfo(FieldDef field, int magic) {
				this.field = field;
				this.magic = magic;
			}
		}

		public MethodDef DecryptMethod => decryptMethod;

		public AssemblyResolver(ModuleDefMD module, ISimpleDeobfuscator simpleDeobfuscator, IDeobfuscator deob)
			: base(module, simpleDeobfuscator, deob) {
		}

		static string[] requiredLocals_sl = new string[] {
			"System.Byte[]",
			"System.IO.Stream",
			"System.Reflection.Assembly",
			"System.Security.Cryptography.SHA1Managed",
			"System.Windows.AssemblyPart",
		};
		protected override bool CheckResolverInitMethodSilverlight(MethodDef resolverInitMethod) {
			if (resolverInitMethod.Body.ExceptionHandlers.Count != 1)
				return false;

			foreach (var method in DotNetUtils.GetCalledMethods(module, resolverInitMethod)) {
				if (!method.IsStatic || method.Body == null)
					continue;
				if (!method.IsPublic || method.HasGenericParameters)
					continue;
				if (!DotNetUtils.IsMethod(method, "System.Void", "(System.String)"))
					continue;
				simpleDeobfuscator.Deobfuscate(method);
				if (!new LocalTypes(method).All(requiredLocals_sl))
					continue;

				initMethod = resolverInitMethod;
				resolveHandler = method;
				UpdateVersion(resolveHandler);
				return true;
			}

			return false;
		}

		void UpdateVersion(MethodDef handler) {
			if (IsV3Old(handler)) {
				version = Version.V3Old;
				return;
			}
			if (IsV3SL(handler)) {
				version = Version.V3;	// 3.x-4.0.4
				return;
			}
			if (IsV41SL(handler)) {
				version = Version.V41SL;
				return;
			}
		}

		static bool IsV3SL(MethodDef handler) {
			var instrs = handler.Body.Instructions;
			for (int i = 0; i < instrs.Count - 3; i++) {
				if (!instrs[i].IsLdloc())
					continue;
				if (instrs[i + 1].OpCode.Code != Code.Add)
					continue;
				if (!instrs[i + 2].IsLdcI4())
					continue;
				if (instrs[i + 3].OpCode.Code != Code.And)
					continue;
				return true;
			}
			return false;
		}

		static bool IsV41SL(MethodDef handler) {
			var instrs = handler.Body.Instructions;
			for (int i = 0; i < instrs.Count; i++) {
				if (!instrs[i].IsLdcI4() || instrs[i].GetLdcI4Value() != 5)
					continue;
				if (instrs[i + 1].OpCode.Code != Code.And)
					continue;
				if (!instrs[i + 2].IsLdcI4() || instrs[i + 2].GetLdcI4Value() != 0x1F)
					continue;
				if (instrs[i + 3].OpCode.Code != Code.And)
					continue;
				return true;
			}
			return false;
		}

		static bool IsV3Old(MethodDef method) =>
			DotNetUtils.CallsMethod(method, "System.Int32 System.IO.Stream::Read(System.Byte[],System.Int32,System.Int32)") &&
			!DotNetUtils.CallsMethod(method, "System.Int32 System.IO.Stream::ReadByte()") &&
			// Obfuscated System.Int32 System.IO.Stream::ReadByte()
			!DotNetUtils.CallsMethod(method, "System.Int32", "(System.IO.Stream,System.Int32,System.Int32)");

		protected override bool CheckResolverInitMethodInternal(MethodDef resolverInitMethod) =>
			DotNetUtils.CallsMethod(resolverInitMethod, "System.Void System.AppDomain::add_AssemblyResolve(System.ResolveEventHandler)");

		protected override bool CheckHandlerMethodDesktopInternal(MethodDef handler) {
			if (CheckHandlerV3(handler) || CheckHandlerSL(handler)) {
				UpdateVersion(handler);
				return true;
			}

			simpleDeobfuscator.Deobfuscate(handler);
			if (CheckHandlerV4(handler, out var fieldInfosTmp, out var decryptMethodTmp)) {
				version = Version.V4;
				fieldInfos = fieldInfosTmp;
				decryptMethod = decryptMethodTmp;
				return true;
			}

			var versionTmp = CheckHandlerV404_41(handler, out fieldInfosTmp, out decryptMethodTmp);
			if (fieldInfosTmp.Count != 0) {
				version = versionTmp;
				fieldInfos = fieldInfosTmp;
				decryptMethod = decryptMethodTmp;
				return true;
			}

			return false;
		}

		static string[] handlerLocalTypes_NET = new string[] {
			"System.Byte[]",
			"System.IO.Compression.DeflateStream",
			"System.IO.MemoryStream",
			"System.IO.Stream",
			"System.Reflection.Assembly",
			"System.Security.Cryptography.SHA1CryptoServiceProvider",
			"System.String",
		};
		static bool CheckHandlerV3(MethodDef handler) => new LocalTypes(handler).All(handlerLocalTypes_NET);

		static string[] handlerLocalTypes_SL = new string[] {
			"System.Byte[]",
			"System.IO.Stream",
			"System.Reflection.Assembly",
			"System.Security.Cryptography.SHA1Managed",
			"System.String",
			"System.Windows.AssemblyPart",
		};
		static bool CheckHandlerSL(MethodDef handler) => new LocalTypes(handler).All(handlerLocalTypes_SL);

		// 4.0.1.18 .. 4.0.3
		bool CheckHandlerV4(MethodDef handler, out List<FieldInfo> fieldInfos, out MethodDef decryptMethod) {
			fieldInfos = new List<FieldInfo>();
			decryptMethod = null;

			var instrs = handler.Body.Instructions;
			for (int i = 0; i < instrs.Count - 3; i++) {
				int index = i;

				var ldtoken = instrs[index++];
				if (ldtoken.OpCode.Code != Code.Ldtoken)
					continue;
				var field = ldtoken.Operand as FieldDef;
				if (field == null || field.InitialValue == null || field.InitialValue.Length == 0)
					return false;

				var ldci4_len = instrs[index++];
				if (!ldci4_len.IsLdcI4())
					return false;
				if (ldci4_len.GetLdcI4Value() != field.InitialValue.Length)
					return false;

				var ldci4_magic = instrs[index++];
				if (!ldci4_magic.IsLdcI4())
					return false;
				int magic = ldci4_magic.GetLdcI4Value();

				var call = instrs[index++];
				if (call.OpCode.Code == Code.Tailcall)
					call = instrs[index++];
				if (call.OpCode.Code != Code.Call)
					return false;
				var decryptMethodTmp = call.Operand as MethodDef;
				if (!DotNetUtils.IsMethod(decryptMethodTmp, "System.Reflection.Assembly", "(System.RuntimeFieldHandle,System.Int32,System.Int32)"))
					return false;

				decryptMethod = decryptMethodTmp;
				fieldInfos.Add(new FieldInfo(field, magic));
			}

			return fieldInfos.Count != 0;
		}

		// 4.0.4, 4.1+
		Version CheckHandlerV404_41(MethodDef handler, out List<FieldInfo> fieldInfos, out MethodDef decryptMethod) {
			var version = Version.Unknown;
			fieldInfos = new List<FieldInfo>();
			decryptMethod = null;

			var instrs = handler.Body.Instructions;
			for (int i = 0; i < instrs.Count - 6; i++) {
				int index = i;

				var ldci4_len = instrs[index++];
				if (!ldci4_len.IsLdcI4())
					continue;
				if (instrs[index++].OpCode.Code != Code.Newarr)
					continue;
				if (!instrs[index++].IsStloc())
					continue;
				if (!instrs[index++].IsLdloc())
					continue;

				var ldtoken = instrs[index++];
				if (ldtoken.OpCode.Code != Code.Ldtoken)
					continue;
				var field = ldtoken.Operand as FieldDef;
				if (field == null || field.InitialValue == null || field.InitialValue.Length == 0)
					continue;

				var call1 = instrs[index++];
				if (call1.OpCode.Code != Code.Call)
					continue;
				if (!DotNetUtils.IsMethod(call1.Operand as IMethod, "System.Void", "(System.Array,System.RuntimeFieldHandle)"))
					continue;

				int callIndex = GetCallDecryptMethodIndex(instrs, index);
				if (callIndex < 0)
					continue;
				var args = DsUtils.GetArgValues(instrs, callIndex);
				if (args == null)
					continue;
				var decryptMethodTmp = instrs[callIndex].Operand as MethodDef;
				if (decryptMethodTmp == null)
					continue;
				GetMagic(decryptMethodTmp, args, out var versionTmp, out int magic);

				version = versionTmp;
				decryptMethod = decryptMethodTmp;
				fieldInfos.Add(new FieldInfo(field, magic));
			}

			return version;
		}

		static bool GetMagic(MethodDef method, IList<object> args, out Version version, out int magic) {
			magic = 0;
			int magicIndex = GetMagicIndex(method, out version);
			if (magicIndex < 0 || magicIndex >= args.Count)
				return false;
			var val = args[magicIndex];
			if (!(val is int))
				return false;

			magic = (int)val;
			return true;
		}

		static int GetMagicIndex(MethodDef method, out Version version) {
			int magicIndex = GetMagicIndex404(method);
			if (magicIndex >= 0) {
				version = Version.V404;
				return magicIndex;
			}

			magicIndex = GetMagicIndex41Trial(method);
			if (magicIndex >= 0) {
				version = Version.V41;
				return magicIndex;
			}

			version = Version.Unknown;
			return -1;
		}

		static int GetMagicIndex404(MethodDef method) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 4; i++) {
				int index = i;
				if (!instrs[index++].IsLdloc())
					continue;
				var ldarg = instrs[index++];
				if (!ldarg.IsLdarg())
					continue;
				if (instrs[index++].OpCode.Code != Code.Add)
					continue;
				var ldci4 = instrs[index++];
				if (!ldci4.IsLdcI4())
					continue;
				if (ldci4.GetLdcI4Value() != 0xFF)
					continue;
				return ldarg.GetParameterIndex();
			}
			return -1;
		}

		static int GetMagicIndex41Trial(MethodDef method) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 4; i++) {
				int index = i;
				if (instrs[index++].OpCode.Code != Code.Div)
					continue;
				var ldarg = instrs[index++];
				if (!ldarg.IsLdarg())
					continue;
				if (instrs[index++].OpCode.Code != Code.Add)
					continue;
				var ldci4 = instrs[index++];
				if (!ldci4.IsLdcI4())
					continue;
				if (ldci4.GetLdcI4Value() != 0xFF)
					continue;
				return ldarg.GetParameterIndex();
			}
			return -1;
		}

		static int GetCallDecryptMethodIndex(IList<Instruction> instrs, int index) {
			index = GetRetIndex(instrs, index);
			if (index < 0)
				return -1;
			for (int i = index - 1; i >= 0; i--) {
				var instr = instrs[i];
				if (!IsCallOrNext(instr))
					break;
				if (instr.OpCode.Code != Code.Call)
					continue;
				var calledMethod = instr.Operand as IMethod;
				if (calledMethod == null || calledMethod.MethodSig.GetParamCount() < 2)
					continue;

				return i;
			}
			return -1;
		}

		static int GetRetIndex(IList<Instruction> instrs, int index) {
			for (int i = index; i < instrs.Count; i++) {
				var instr = instrs[i];
				if (instr.OpCode.Code == Code.Ret)
					return i;
				if (!IsCallOrNext(instr))
					break;
			}
			return -1;
		}

		static bool IsCallOrNext(Instruction instr) {
			switch (instr.OpCode.FlowControl) {
			case FlowControl.Call:
			case FlowControl.Next:
				return true;
			default:
				return false;
			}
		}

		public IEnumerable<AssemblyInfo> GetAssemblyInfos() {
			if (!Detected)
				return new List<AssemblyInfo>();

			switch (version) {
			case Version.V3Old:
				return GetAssemblyInfos(resource => DecryptResourceV3Old(resource));
			case Version.V3:
				return GetAssemblyInfos(resource => DecryptResourceV3(resource));
			case Version.V4:
			case Version.V404:
				return GetAssemblyInfosV4();
			case Version.V41:
				return GetAssemblyInfosV41();
			case Version.V41SL:
				return GetAssemblyInfos(resource => DecryptResourceV41SL(resource));
			default:
				throw new ApplicationException("Unknown version");
			}
		}

		IEnumerable<AssemblyInfo> GetAssemblyInfos(Func<EmbeddedResource, byte[]> decrypter) {
			var infos = new List<AssemblyInfo>();

			foreach (var tmp in module.Resources) {
				var resource = tmp as EmbeddedResource;
				if (resource == null)
					continue;
				if (!Regex.IsMatch(resource.Name.String, @"^[0-9A-F]{40}$"))
					continue;
				var info = GetAssemblyInfo(resource, decrypter);
				if (info == null)
					continue;
				infos.Add(info);
			}

			return infos;
		}

		AssemblyInfo GetAssemblyInfo(EmbeddedResource resource, Func<EmbeddedResource, byte[]> decrypter) {
			try {
				var decrypted = decrypter(resource);
				return GetAssemblyInfo(decrypted, resource);
			}
			catch (Exception) {
				return null;
			}
		}

		AssemblyInfo GetAssemblyInfo(byte[] decryptedData, EmbeddedResource resource) {
			var asm = AssemblyDef.Load(decryptedData);
			var fullName = asm.FullName;
			var simpleName = asm.Name.String;
			var extension = DeobUtils.GetExtension(asm.Modules[0].Kind);
			return new AssemblyInfo(decryptedData, fullName, simpleName, extension, resource);
		}

		IEnumerable<AssemblyInfo> GetAssemblyInfos(Func<byte[], int, byte[]> decrypter) {
			var infos = new List<AssemblyInfo>();

			if (fieldInfos == null)
				return infos;

			foreach (var fieldInfo in fieldInfos) {
				var decrypted = decrypter(fieldInfo.field.InitialValue, fieldInfo.magic);
				infos.Add(GetAssemblyInfo(decrypted, null));
				fieldInfo.field.InitialValue = new byte[1];
				fieldInfo.field.FieldSig.Type = module.CorLibTypes.Byte;
				fieldInfo.field.RVA = 0;
			}

			return infos;
		}

		IEnumerable<AssemblyInfo> GetAssemblyInfosV4() => GetAssemblyInfos((data, magic) => DecryptResourceV4(data, magic));
		IEnumerable<AssemblyInfo> GetAssemblyInfosV41() => GetAssemblyInfos((data, magic) => InflateIfNeeded(Decrypt41Trial(data, magic)));

		static byte[] Decrypt41Trial(byte[] data, int magic) {
			for (int i = 0; i < data.Length; i++)
				data[i] ^= (byte)(i / 3 + magic);
			return data;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/DeepSea/CastDeobfuscator.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using de4dot.blocks;
using de4dot.blocks.cflow;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace de4dot.code.deobfuscators.DeepSea {
	class CastDeobfuscator : IBlocksDeobfuscator {
		Blocks blocks;
		Dictionary<Local, LocalInfo> localInfos = new Dictionary<Local, LocalInfo>();

		class LocalInfo {
			public readonly Local local;
			ITypeDefOrRef type;
			bool isValid;

			public ITypeDefOrRef CastType {
				get => type;
				set {
					if (!isValid)
						return;

					if (value == null) {
						Invalid();
						return;
					}

					if (type != null && !new SigComparer().Equals(type, value)) {
						Invalid();
						return;
					}

					type = value;
				}
			}

			public LocalInfo(Local local) {
				this.local = local;
				isValid = true;
			}

			public void Invalid() {
				isValid = false;
				type = null;
			}

			public override string ToString() {
				if (type == null)
					return $"{local} - INVALID";
				return $"{local} - {type.MDToken.ToInt32():X8} {type.FullName}";
			}
		}

		public bool ExecuteIfNotModified => true;
		public void DeobfuscateBegin(Blocks blocks) => this.blocks = blocks;

		public bool Deobfuscate(List<Block> allBlocks) {
			if (!Initialize(allBlocks))
				return false;

			bool modified = false;

			var indexesToRemove = new List<int>();
			foreach (var block in allBlocks) {
				indexesToRemove.Clear();
				var instrs = block.Instructions;
				for (int i = 0; i < instrs.Count - 1; i++) {
					var instr = instrs[i];
					if (instr.OpCode.Code == Code.Ldloca || instr.OpCode.Code == Code.Ldloca_S) {
						var local = instr.Operand as Local;
						if (local == null)
							continue;
						localInfos[local].Invalid();
					}
					else if (instr.IsLdloc()) {
						var local = instr.Instruction.GetLocal(blocks.Locals);
						if (local == null)
							continue;
						var localInfo = localInfos[local];
						var cast = instrs[i + 1];
						if (localInfo.CastType == null)
							continue;
						if (!IsCast(cast))
							throw new ApplicationException("Not a cast instr");

						indexesToRemove.Add(i + 1);
					}
				}
				if (indexesToRemove.Count > 0) {
					block.Remove(indexesToRemove);
					modified = true;
				}
			}

			foreach (var info in localInfos.Values) {
				if (info.CastType == null)
					continue;
				info.local.Type = info.CastType.ToTypeSig();
			}

			if (modified) {
				foreach (var block in allBlocks) {
					var instrs = block.Instructions;
					for (int i = 0; i < instrs.Count - 1; i++) {
						var instr = instrs[i];
						int castIndex = i + 1;
						if (instr.OpCode.Code == Code.Dup) {
							if (i == 0)
								continue;
							castIndex = i;
							instr = instrs[i - 1];
						}

						if (instr.IsLdarg())
							AddCast(block, castIndex, i + 1, instr.Instruction.GetArgumentType(blocks.Method.MethodSig, blocks.Method.DeclaringType));
						else if (instr.OpCode.Code == Code.Ldfld || instr.OpCode.Code == Code.Ldsfld) {
							var field = instr.Operand as IField;
							if (field == null)
								continue;
							AddCast(block, castIndex, i + 1, field.FieldSig.GetFieldType());
						}
						else if (instr.OpCode.Code == Code.Call || instr.OpCode.Code == Code.Callvirt) {
							var calledMethod = instr.Operand as IMethod;
							if (calledMethod == null || !DotNetUtils.HasReturnValue(calledMethod))
								continue;
							AddCast(block, castIndex, i + 1, calledMethod.MethodSig.GetRetType());
						}
					}
				}
			}

			return modified;
		}

		bool AddCast(Block block, int castIndex, int index, TypeSig type) {
			if (type == null)
				return false;
			if (castIndex >= block.Instructions.Count || index >= block.Instructions.Count)
				return false;
			var stloc = block.Instructions[index];
			if (!stloc.IsStloc())
				return false;
			var local = stloc.Instruction.GetLocal(blocks.Locals);
			if (local == null)
				return false;
			var localInfo = localInfos[local];
			if (localInfo.CastType == null)
				return false;

			if (!new SigComparer().Equals(localInfo.CastType, type))
				block.Insert(castIndex, new Instruction(OpCodes.Castclass, localInfo.CastType));
			return true;
		}

		bool Initialize(List<Block> allBlocks) {
			localInfos.Clear();
			foreach (var local in blocks.Locals)
				localInfos[local] = new LocalInfo(local);
			if (localInfos.Count == 0)
				return false;

			foreach (var block in allBlocks) {
				var instrs = block.Instructions;
				for (int i = 0; i < instrs.Count - 1; i++) {
					var ldloc = instrs[i];
					if (!ldloc.IsLdloc())
						continue;
					var local = ldloc.Instruction.GetLocal(blocks.Locals);
					if (local == null)
						continue;
					var localInfo = localInfos[local];
					localInfo.CastType = GetCastType(instrs[i + 1]);
				}
			}
			return true;
		}

		static bool IsCast(Instr instr) => instr.OpCode.Code == Code.Castclass || instr.OpCode.Code == Code.Isinst;

		static ITypeDefOrRef GetCastType(Instr instr) {
			if (!IsCast(instr))
				return null;
			return instr.Operand as ITypeDefOrRef;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/DeepSea/Deobfuscator.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet;
using de4dot.blocks;
using de4dot.blocks.cflow;

namespace de4dot.code.deobfuscators.DeepSea {
	public class DeobfuscatorInfo : DeobfuscatorInfoBase {
		public const string THE_NAME = "DeepSea";
		public const string THE_TYPE = "ds";
		const string DEFAULT_REGEX = DeobfuscatorBase.DEFAULT_ASIAN_VALID_NAME_REGEX;
		BoolOption inlineMethods;
		BoolOption removeInlinedMethods;
		BoolOption decryptResources;
		BoolOption dumpEmbeddedAssemblies;
		BoolOption restoreFields;
		BoolOption renameResourceKeys;
		BoolOption castDeobfuscation;

		public DeobfuscatorInfo()
			: base(DEFAULT_REGEX) {
			inlineMethods = new BoolOption(null, MakeArgName("inline"), "Inline short methods", true);
			removeInlinedMethods = new BoolOption(null, MakeArgName("remove-inlined"), "Remove inlined methods", true);
			decryptResources = new BoolOption(null, MakeArgName("rsrc"), "Decrypt resources", true);
			dumpEmbeddedAssemblies = new BoolOption(null, MakeArgName("embedded"), "Dump embedded assemblies", true);
			restoreFields = new BoolOption(null, MakeArgName("fields"), "Restore fields", true);
			renameResourceKeys = new BoolOption(null, MakeArgName("keys"), "Rename resource keys", true);
			castDeobfuscation = new BoolOption(null, MakeArgName("casts"), "Deobfuscate casts", true);
		}

		public override string Name => THE_NAME;
		public override string Type => THE_TYPE;

		public override IDeobfuscator CreateDeobfuscator() =>
			new Deobfuscator(new Deobfuscator.Options {
				ValidNameRegex = validNameRegex.Get(),
				InlineMethods = inlineMethods.Get(),
				RemoveInlinedMethods = removeInlinedMethods.Get(),
				DecryptResources = decryptResources.Get(),
				DumpEmbeddedAssemblies = dumpEmbeddedAssemblies.Get(),
				RestoreFields = restoreFields.Get(),
				RenameResourceKeys = renameResourceKeys.Get(),
				CastDeobfuscation = castDeobfuscation.Get(),
			});

		protected override IEnumerable<Option> GetOptionsInternal() =>
			new List<Option>() {
				inlineMethods,
				removeInlinedMethods,
				decryptResources,
				dumpEmbeddedAssemblies,
				restoreFields,
				renameResourceKeys,
				castDeobfuscation,
			};
	}

	class Deobfuscator : DeobfuscatorBase {
		Options options;
		string obfuscatorName = DeobfuscatorInfo.THE_NAME;
		bool startedDeobfuscating = false;

		StringDecrypter stringDecrypter;
		ResourceResolver resourceResolver;
		AssemblyResolver assemblyResolver;
		FieldsRestorer fieldsRestorer;
		ArrayBlockState arrayBlockState;

		internal class Options : OptionsBase {
			public bool InlineMethods { get; set; }
			public bool RemoveInlinedMethods { get; set; }
			public bool DecryptResources { get; set; }
			public bool DumpEmbeddedAssemblies { get; set; }
			public bool RestoreFields { get; set; }
			public bool RenameResourceKeys { get; set; }
			public bool CastDeobfuscation { get; set; }
		}

		public override string Type => DeobfuscatorInfo.THE_TYPE;
		public override string TypeLong => DeobfuscatorInfo.THE_NAME;
		public override string Name => obfuscatorName;
		protected override bool CanInlineMethods => startedDeobfuscating ? options.InlineMethods : true;

		public override IEnumerable<IBlocksDeobfuscator> BlocksDeobfuscators {
			get {
				var list = new List<IBlocksDeobfuscator>(GetBlocksDeobfuscators());
				if (CanInlineMethods)
					list.Add(new DsMethodCallInliner(new CachedCflowDeobfuscator(GetBlocksDeobfuscators())));
				return list;
			}
		}

		List<IBlocksDeobfuscator> GetBlocksDeobfuscators() {
			var list = new List<IBlocksDeobfuscator>();
			if (arrayBlockState != null && arrayBlockState.Detected)
				list.Add(new ArrayBlockDeobfuscator(arrayBlockState));
			if (!startedDeobfuscating || options.CastDeobfuscation)
				list.Add(new CastDeobfuscator());
			return list;
		}

		public Deobfuscator(Options options)
			: base(options) {
			this.options = options;

			if (options.RenameResourceKeys)
				RenamingOptions |= RenamingOptions.RenameResourceKeys;
			else
				RenamingOptions &= ~RenamingOptions.RenameResourceKeys;
		}

		protected override int DetectInternal() {
			int val = 0;

			int sum = ToInt32(stringDecrypter.Detected) +
					ToInt32(resourceResolver.Detected) +
					ToInt32(assemblyResolver.Detected);
			if (sum > 0)
				val += 100 + 10 * (sum - 1);

			return val;
		}

		protected override void ScanForObfuscator() {
			staticStringInliner.UseUnknownArgs = true;
			arrayBlockState = new ArrayBlockState(module);
			arrayBlockState.Initialize(DeobfuscatedFile);
			stringDecrypter = new StringDecrypter(module);
			stringDecrypter.Find(DeobfuscatedFile);
			resourceResolver = new ResourceResolver(module, DeobfuscatedFile, this);
			resourceResolver.Find();
			assemblyResolver = new AssemblyResolver(module, DeobfuscatedFile, this);
			assemblyResolver.Find();
			obfuscatorName = DetectVersion();
		}

		string DetectVersion() {
			switch (stringDecrypter.Version) {
			case StringDecrypter.DecrypterVersion.V1_3:
				if (DetectMethodProxyObfuscation())
					return DeobfuscatorInfo.THE_NAME + " 3.5";
				return DeobfuscatorInfo.THE_NAME + " 1.x-3.x";
			case StringDecrypter.DecrypterVersion.V4_0:
				return DeobfuscatorInfo.THE_NAME + " 4.0";
			case StringDecrypter.DecrypterVersion.V4_1:
				return DeobfuscatorInfo.THE_NAME + " 4.1";
			}

			return DeobfuscatorInfo.THE_NAME;
		}

		bool DetectMethodProxyObfuscation() {
			const int MIN_FOUND_PROXIES = 10;

			int foundProxies = 0, checkedMethods = 0;
			foreach (var type in module.GetTypes()) {
				foreach (var method in type.Methods) {
					if (foundProxies >= MIN_FOUND_PROXIES)
						goto done;
					if (!method.IsStatic || method.Body == null)
						continue;
					if (checkedMethods++ >= 1000)
						goto done;
					if (!DsMethodCallInliner.CanInline(method))
						continue;
					foundProxies++;
				}
			}
done:
			return foundProxies >= MIN_FOUND_PROXIES;
		}

		public override void DeobfuscateBegin() {
			base.DeobfuscateBegin();

			if (options.RestoreFields) {
				fieldsRestorer = new FieldsRestorer(module);
				fieldsRestorer.Initialize();
			}

			foreach (var method in stringDecrypter.DecrypterMethods) {
				staticStringInliner.Add(method, (method2, gim, args) => {
					return stringDecrypter.Decrypt(method2, args);
				});
			}
			DeobfuscatedFile.StringDecryptersAdded();

			resourceResolver.Initialize();
			DecryptResources();

			DumpEmbeddedAssemblies();

			startedDeobfuscating = true;
		}

		void DecryptResources() {
			if (!options.DecryptResources)
				return;
			if (!resourceResolver.MergeResources(out var rsrc))
				return;
			AddResourceToBeRemoved(rsrc, "Encrypted resources");
			AddCctorInitCallToBeRemoved(resourceResolver.InitMethod);
			AddCallToBeRemoved(module.EntryPoint, resourceResolver.InitMethod);
			AddMethodToBeRemoved(resourceResolver.InitMethod, "Resource resolver init method");
			AddMethodToBeRemoved(resourceResolver.InitMethod2, "Resource resolver init method #2");
			AddMethodToBeRemoved(resourceResolver.HandlerMethod, "Resource resolver handler method");
			AddMethodToBeRemoved(resourceResolver.GetDataMethod, "Resource resolver 'get resource data' method");
		}

		void DumpEmbeddedAssemblies() {
			if (!options.DumpEmbeddedAssemblies)
				return;
			foreach (var info in assemblyResolver.GetAssemblyInfos()) {
				if (info.resource != null && info.resource == resourceResolver.Resource)
					continue;
				DeobfuscatedFile.CreateAssemblyFile(info.data, info.simpleName, info.extension);
				AddResourceToBeRemoved(info.resource, $"Embedded assembly: {info.fullName}");
			}
			AddCctorInitCallToBeRemoved(assemblyResolver.InitMethod);
			AddCallToBeRemoved(module.EntryPoint, assemblyResolver.InitMethod);
			AddMethodToBeRemoved(assemblyResolver.InitMethod, "Assembly resolver init method");
			AddMethodToBeRemoved(assemblyResolver.HandlerMethod, "Assembly resolver handler method");
			AddMethodToBeRemoved(assemblyResolver.DecryptMethod, "Assembly resolver decrypt method");
		}

		public override void DeobfuscateMethodEnd(Blocks blocks) {
			if (options.RestoreFields)
				fieldsRestorer.Deobfuscate(blocks);
			base.DeobfuscateMethodEnd(blocks);
		}

		public override void DeobfuscateEnd() {
			if (options.RestoreFields && CanRemoveTypes)
				fieldsRestorer.CleanUp();
			RemoveInlinedMethods();

			if (options.RestoreFields)
				AddTypesToBeRemoved(fieldsRestorer.FieldStructs, "Type with moved fields");

			if (CanRemoveStringDecrypterType) {
				AddMethodsToBeRemoved(stringDecrypter.DecrypterMethods, "String decrypter method");
				stringDecrypter.CleanUp();
			}

			AddFieldsToBeRemoved(arrayBlockState.CleanUp(), "Control flow obfuscation array");

			base.DeobfuscateEnd();
		}

		void RemoveInlinedMethods() {
			if (!options.InlineMethods || !options.RemoveInlinedMethods)
				return;
			RemoveInlinedMethods(DsInlinedMethodsFinder.Find(module, staticStringInliner.Methods));
		}

		public override IEnumerable<int> GetStringDecrypterMethods() {
			var list = new List<int>();
			foreach (var method in stringDecrypter.DecrypterMethods)
				list.Add(method.MDToken.ToInt32());
			return list;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/DeepSea/DsConstantsReader.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.DeepSea {
	class DsConstantsReader : ConstantsReader {
		public DsConstantsReader(List<Instr> instrs)
			: base(instrs) {
		}

		protected override bool GetLocalConstantInt32(Instruction instr, out int value) {
			value = 0;
			return true;
		}

		protected override bool GetArgConstantInt32(Instruction instr, out int value) {
			value = 0;
			return true;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/DeepSea/DsInlinedMethodsFinder.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet;

namespace de4dot.code.deobfuscators.DeepSea {
	static class DsInlinedMethodsFinder {
		public static List<MethodDef> Find(ModuleDefMD module, IEnumerable<MethodDef> notInlinedMethods) {
			var notInlinedMethodsDict = new Dictionary<MethodDef, bool>();
			foreach (var method in notInlinedMethods)
				notInlinedMethodsDict[method] = true;

			var inlinedMethods = new List<MethodDef>();

			foreach (var type in module.GetTypes()) {
				foreach (var method in type.Methods) {
					if (!notInlinedMethodsDict.ContainsKey(method) && DsMethodCallInliner.CanInline(method))
						inlinedMethods.Add(method);
				}
			}

			return inlinedMethods;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/DeepSea/DsMethodCallInliner.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;
using de4dot.blocks.cflow;

namespace de4dot.code.deobfuscators.DeepSea {
	class DsMethodCallInliner : MethodCallInlinerBase {
		InstructionEmulator instructionEmulator = new InstructionEmulator();
		IList<Parameter> parameters;
		Parameter arg1, arg2;
		Value returnValue;
		MethodDef methodToInline;
		CachedCflowDeobfuscator cflowDeobfuscator;

		public DsMethodCallInliner(CachedCflowDeobfuscator cflowDeobfuscator) =>
			this.cflowDeobfuscator = cflowDeobfuscator;

		protected override bool DeobfuscateInternal() {
			bool modified = false;

			var instructions = block.Instructions;
			for (int i = 0; i < instructions.Count; i++) {
				var instr = instructions[i].Instruction;
				if (instr.OpCode.Code == Code.Call)
					modified |= InlineMethod(instr, i);
			}

			return modified;
		}

		bool InlineMethod(Instruction callInstr, int instrIndex) {
			var method = callInstr.Operand as MethodDef;
			if (method == null) {
				if (callInstr.Operand is MethodSpec ms)
					method = ms.Method as MethodDef;
				if (method == null)
					return false;
			}
			if (!CanInline(method))
				return false;

			if (instrIndex < 2)
				return false;
			var ldci4_1st = block.Instructions[instrIndex - 2];
			var ldci4_2nd = block.Instructions[instrIndex - 1];
			if (!ldci4_1st.IsLdcI4() || !ldci4_2nd.IsLdcI4())
				return false;

			if (!InlineMethod(method, instrIndex, ldci4_1st.GetLdcI4Value(), ldci4_2nd.GetLdcI4Value()))
				return false;

			return true;
		}

		protected override Instruction OnAfterLoadArg(MethodDef methodToInline, Instruction instr, ref int instrIndex) {
			if (instr.OpCode.Code != Code.Box)
				return instr;
			if (methodToInline.MethodSig.GetGenParamCount() == 0)
				return instr;
			return DotNetUtils.GetInstruction(methodToInline.Body.Instructions, ref instrIndex);
		}

		bool InlineMethod(MethodDef methodToInline, int instrIndex, int const1, int const2) {
			this.methodToInline = methodToInline = cflowDeobfuscator.Deobfuscate(methodToInline);

			parameters = methodToInline.Parameters;
			arg1 = parameters[parameters.Count - 2];
			arg2 = parameters[parameters.Count - 1];
			returnValue = null;

			instructionEmulator.Initialize(methodToInline);
			foreach (var arg in parameters) {
				if (!arg.IsNormalMethodParameter)
					continue;
				if (arg.Type.ElementType >= ElementType.Boolean && arg.Type.ElementType <= ElementType.U4)
					instructionEmulator.SetArg(arg, new Int32Value(0));
			}
			instructionEmulator.SetArg(arg1, new Int32Value(const1));
			instructionEmulator.SetArg(arg2, new Int32Value(const2));

			int index = 0;
			if (!EmulateInstructions(ref index, false))
				return false;
			var patcher = TryInlineOtherMethod(instrIndex, methodToInline, methodToInline.Body.Instructions[index], index + 1, 2);
			if (patcher == null)
				return false;
			if (!EmulateToReturn(patcher.afterIndex, patcher.lastInstr))
				return false;
			patcher.Patch(block);
			block.Insert(instrIndex, OpCodes.Pop.ToInstruction());
			block.Insert(instrIndex, OpCodes.Pop.ToInstruction());
			return true;
		}

		bool EmulateInstructions(ref int index, bool allowUnknownArgs) {
			Instruction instr;
			var instrs = methodToInline.Body.Instructions;
			int counter = 0;
			var foundOpCodes = new Dictionary<Code, bool>();
			bool checkInstrs = false;
			while (true) {
				if (counter++ >= 50)
					return false;
				if (index < 0 || index >= instrs.Count)
					return false;
				instr = instrs[index];
				foundOpCodes[instr.OpCode.Code] = true;
				switch (instr.OpCode.Code) {
				case Code.Stloc:
				case Code.Stloc_S:
				case Code.Stloc_0:
				case Code.Stloc_1:
				case Code.Stloc_2:
				case Code.Stloc_3:
				case Code.Ldloc:
				case Code.Ldloc_S:
				case Code.Ldloc_0:
				case Code.Ldloc_1:
				case Code.Ldloc_2:
				case Code.Ldloc_3:
				case Code.Ldc_I4:
				case Code.Ldc_I4_0:
				case Code.Ldc_I4_1:
				case Code.Ldc_I4_2:
				case Code.Ldc_I4_3:
				case Code.Ldc_I4_4:
				case Code.Ldc_I4_5:
				case Code.Ldc_I4_6:
				case Code.Ldc_I4_7:
				case Code.Ldc_I4_8:
				case Code.Ldc_I4_M1:
				case Code.Ldc_I4_S:
				case Code.Add:
				case Code.Sub:
				case Code.Xor:
				case Code.Or:
				case Code.Nop:
				case Code.Dup:
				case Code.Mul:
				case Code.Rem:
				case Code.Div:
					instructionEmulator.Emulate(instr);
					index++;
					break;

				case Code.Ldarg:
				case Code.Ldarg_S:
				case Code.Ldarg_0:
				case Code.Ldarg_1:
				case Code.Ldarg_2:
				case Code.Ldarg_3:
					var arg = instr.GetParameter(parameters);
					if (arg != arg1 && arg != arg2) {
						if (!allowUnknownArgs)
							goto done;
						checkInstrs = true;
					}
					instructionEmulator.Emulate(instr);
					index++;
					break;

				case Code.Call:
				case Code.Callvirt:
				case Code.Newobj:
					goto done;

				case Code.Switch:
					var value = instructionEmulator.Pop() as Int32Value;
					if (value == null || !value.AllBitsValid())
						return false;
					var targets = (Instruction[])instr.Operand;
					if (value.Value >= 0 && value.Value < targets.Length)
						index = instrs.IndexOf(targets[value.Value]);
					else
						index++;
					break;

				case Code.Br:
				case Code.Br_S:
					index = instrs.IndexOf((Instruction)instr.Operand);
					break;

				case Code.Brtrue:
				case Code.Brtrue_S:
					index = EmulateBrtrue(index);
					break;

				case Code.Brfalse:
				case Code.Brfalse_S:
					index = EmulateBrfalse(index);
					break;

				case Code.Isinst:
				case Code.Castclass:
					if (returnValue != null && instructionEmulator.Peek() == returnValue) {
						// Do nothing
					}
					else
						instructionEmulator.Emulate(instr);
					index++;
					break;

				default:
					if (instr.OpCode.OpCodeType != OpCodeType.Prefix)
						goto done;
					index++;
					break;
				}
			}
done:
			if (checkInstrs) {
				if (!foundOpCodes.ContainsKey(Code.Ldc_I4_1))
					return false;
				if (!foundOpCodes.ContainsKey(Code.Ldc_I4_2))
					return false;
				if (!foundOpCodes.ContainsKey(Code.Add))
					return false;
				if (!foundOpCodes.ContainsKey(Code.Dup))
					return false;
				if (!foundOpCodes.ContainsKey(Code.Mul))
					return false;
				if (!foundOpCodes.ContainsKey(Code.Rem))
					return false;
				if (!foundOpCodes.ContainsKey(Code.Brtrue) && !foundOpCodes.ContainsKey(Code.Brtrue_S) &&
					!foundOpCodes.ContainsKey(Code.Brfalse) && !foundOpCodes.ContainsKey(Code.Brfalse_S))
					return false;
			}
			return true;
		}

		int EmulateBranch(int stackArgs, Bool3 cond, Instruction instrTrue, Instruction instrFalse) {
			if (cond == Bool3.Unknown)
				return -1;
			var instr = cond == Bool3.True ? instrTrue : instrFalse;
			return methodToInline.Body.Instructions.IndexOf(instr);
		}

		int EmulateBrtrue(int instrIndex) {
			var val1 = instructionEmulator.Pop();

			var instr = methodToInline.Body.Instructions[instrIndex];
			var instrTrue = (Instruction)instr.Operand;
			var instrFalse = methodToInline.Body.Instructions[instrIndex + 1];

			if (val1.IsInt32())
				return EmulateBranch(1, Int32Value.CompareTrue((Int32Value)val1), instrTrue, instrFalse);
			return -1;
		}

		int EmulateBrfalse(int instrIndex) {
			var val1 = instructionEmulator.Pop();

			var instr = methodToInline.Body.Instructions[instrIndex];
			var instrTrue = (Instruction)instr.Operand;
			var instrFalse = methodToInline.Body.Instructions[instrIndex + 1];

			if (val1.IsInt32())
				return EmulateBranch(1, Int32Value.CompareFalse((Int32Value)val1), instrTrue, instrFalse);
			return -1;
		}

		bool EmulateToReturn(int index, Instruction lastInstr) {
			lastInstr.CalculateStackUsage(false, out int pushes, out int pops);
			instructionEmulator.Pop(pops);

			returnValue = null;
			if (pushes != 0) {
				returnValue = new UnknownValue();
				instructionEmulator.SetProtected(returnValue);
				instructionEmulator.Push(returnValue);
			}

			if (!EmulateInstructions(ref index, true))
				return false;
			if (index >= methodToInline.Body.Instructions.Count)
				return false;
			if (methodToInline.Body.Instructions[index].OpCode.Code != Code.Ret)
				return false;

			if (returnValue != null) {
				if (instructionEmulator.Pop() != returnValue)
					return false;
			}
			return instructionEmulator.StackSize() == 0;
		}

		public static bool CanInline(MethodDef method) {
			if (method == null || method.Body == null)
				return false;
			if (method.Attributes != (MethodAttributes.Assembly | MethodAttributes.Static))
				return false;
			if (method.Body.ExceptionHandlers.Count > 0)
				return false;

			var parameters = method.MethodSig.GetParams();
			int paramCount = parameters.Count;
			if (paramCount < 2)
				return false;

			if (method.GenericParameters.Count > 0) {
				foreach (var gp in method.GenericParameters) {
					if (gp.GenericParamConstraints.Count == 0)
						return false;
				}
			}

			var param1 = parameters[paramCount - 1];
			var param2 = parameters[paramCount - 2];
			if (!IsIntType(param1.ElementType))
				return false;
			if (!IsIntType(param2.ElementType))
				return false;

			return true;
		}

		static bool IsIntType(ElementType etype) =>
			etype == ElementType.Char || etype == ElementType.I2 || etype == ElementType.I4;

		protected override bool IsReturn(MethodDef methodToInline, int instrIndex) {
			int oldIndex = instrIndex;
			if (base.IsReturn(methodToInline, oldIndex))
				return true;

			return false;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/DeepSea/DsUtils.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.DeepSea {
	static class DsUtils {
		public static IList<object> GetArgValues(IList<Instruction> instrs, int index) =>
			GetArgValues(DotNetUtils.GetArgPushes(instrs, index));

		public static IList<object> GetArgValues(IList<Instruction> argInstrs) {
			if (argInstrs == null)
				return null;
			var args = new List<object>(argInstrs.Count);
			foreach (var argInstr in argInstrs) {
				GetArgValue(argInstr, out object arg);
				args.Add(arg);
			}
			return args;
		}

		public static bool GetArgValue(MethodDef method, int index, out object arg) =>
			GetArgValue(method.Body.Instructions[index], out arg);

		public static bool GetArgValue(Instruction instr, out object arg) {
			switch (instr.OpCode.Code) {
			case Code.Ldc_I4_S: arg = (int)(sbyte)instr.Operand; return true;
			case Code.Ldc_I4_M1: arg = -1; return true;
			case Code.Ldc_I4_0: arg = 0; return true;
			case Code.Ldc_I4_1: arg = 1; return true;
			case Code.Ldc_I4_2: arg = 2; return true;
			case Code.Ldc_I4_3: arg = 3; return true;
			case Code.Ldc_I4_4: arg = 4; return true;
			case Code.Ldc_I4_5: arg = 5; return true;
			case Code.Ldc_I4_6: arg = 6; return true;
			case Code.Ldc_I4_7: arg = 7; return true;
			case Code.Ldc_I4_8: arg = 8; return true;
			case Code.Ldnull: arg = null; return true;

			case Code.Ldstr:
			case Code.Ldc_I4:
			case Code.Ldc_I8:
			case Code.Ldc_R4:
			case Code.Ldc_R8:
				arg = instr.Operand;
				return true;

			case Code.Ldarg:
			case Code.Ldarg_S:
			case Code.Ldarg_0:
			case Code.Ldarg_1:
			case Code.Ldarg_2:
			case Code.Ldarg_3:
			case Code.Ldloc:
			case Code.Ldloc_S:
			case Code.Ldloc_0:
			case Code.Ldloc_1:
			case Code.Ldloc_2:
			case Code.Ldloc_3:
				arg = null;
				return true;

			default:
				arg = null;
				return false;
			}
		}
	}
}



================================================
File: de4dot.code/deobfuscators/DeepSea/FieldsRestorer.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.DeepSea {
	// DS 4.x can move fields from a class to a struct. This class restores the fields.
	class FieldsRestorer {
		ModuleDefMD module;
		TypeDefDict<List<TypeDef>> structToOwners = new TypeDefDict<List<TypeDef>>();
		FieldDefAndDeclaringTypeDict<bool> structFieldsToFix = new FieldDefAndDeclaringTypeDict<bool>();
		TypeDefDict<FieldDefAndDeclaringTypeDict<FieldDef>> typeToFieldsDict = new TypeDefDict<FieldDefAndDeclaringTypeDict<FieldDef>>();

		public List<TypeDef> FieldStructs {
			get {
				var list = new List<TypeDef>(structToOwners.Count);
				foreach (var structType in structToOwners.GetKeys()) {
					if (!HasNoMethods(structType))
						continue;

					list.Add(structType);
				}
				return list;
			}
		}

		static bool HasNoMethods(TypeDef type) {
			if (type.Methods.Count == 0)
				return true;
			if (type.BaseType == null)
				return false;
			if (type.BaseType.FullName != "System.Object")
				return false;
			if (type.Methods.Count != 1)
				return false;
			var ctor = type.Methods[0];
			if (ctor.Name != ".ctor" || ctor.MethodSig.GetParamCount() != 0)
				return false;
			return true;
		}

		public FieldsRestorer(ModuleDefMD module) => this.module = module;

		public void Initialize() {
			foreach (var kv in GetMovedTypes()) {
				var structType = kv.Key;
				structToOwners.Add(structType, kv.Value);

				foreach (var ownerType in kv.Value) {
					foreach (var ownerField in ownerType.Fields) {
						if (DotNetUtils.GetType(module, ownerField.FieldSig.GetFieldType()) != structType)
							continue;
						structFieldsToFix.Add(ownerField, true);
						break;
					}

					var fieldsDict = new FieldDefAndDeclaringTypeDict<FieldDef>();
					typeToFieldsDict.Add(ownerType, fieldsDict);
					foreach (var structField in structType.Fields) {
						var newField = module.UpdateRowId(new FieldDefUser(structField.Name, structField.FieldSig.Clone(), structField.Attributes));
						ownerType.Fields.Add(newField);
						fieldsDict.Add(structField, newField);
					}
				}
			}
		}

		Dictionary<TypeDef, List<TypeDef>> GetMovedTypes() {
			var candidates = new Dictionary<TypeDef, List<TypeDef>>();
			var typeToStruct = new Dictionary<TypeDef, TypeDef>();
			foreach (var type in module.GetTypes()) {
				foreach (var field in GetPossibleFields(type)) {
					var fieldType = DotNetUtils.GetType(module, field.FieldSig.GetFieldType());
					if (fieldType == null)
						continue;
					if (!CheckBaseType(fieldType))
						continue;
					if ((fieldType.Attributes & ~TypeAttributes.Sealed) != TypeAttributes.NestedAssembly)
						continue;
					if (fieldType.NestedTypes.Count > 0)
						continue;
					if (fieldType.GenericParameters.Count > 0)
						continue;
					if (fieldType.Fields.Count == 0)
						continue;
					if (fieldType.HasEvents || fieldType.HasProperties || fieldType.HasInterfaces)
						continue;
					if (CheckMethods(fieldType))
						continue;
					if (!CheckFields(fieldType))
						continue;

					if (!candidates.TryGetValue(fieldType, out var list))
						candidates[fieldType] = list = new List<TypeDef>();
					list.Add(type);
					typeToStruct[type] = fieldType;
					break;
				}
			}

			foreach (var type in module.GetTypes()) {
				typeToStruct.TryGetValue(type, out var structType);

				foreach (var field in type.Fields) {
					if (field.IsStatic || field.FieldSig.GetFieldType().TryGetTypeDef() != structType)
						RemoveType(candidates, field.FieldSig.GetFieldType());
				}
				foreach (var method in type.Methods) {
					RemoveType(candidates, method.MethodSig.GetRetType());
					foreach (var parameter in method.MethodSig.GetParams())
						RemoveType(candidates, parameter);
					if (method.Body != null) {
						foreach (var local in method.Body.Variables)
							RemoveType(candidates, local.Type);
					}
				}
			}

			return candidates;
		}

		IEnumerable<FieldDef> GetPossibleFields(TypeDef type) {
			var typeToFields = new TypeDefDict<List<FieldDef>>();
			foreach (var field in type.Fields) {
				if (field.Attributes != FieldAttributes.Private)
					continue;
				var fieldType = DotNetUtils.GetType(module, field.FieldSig.GetFieldType());
				if (fieldType == null)
					continue;
				if (!CheckBaseType(fieldType))
					continue;
				var list = typeToFields.Find(fieldType);
				if (list == null)
					typeToFields.Add(fieldType, list = new List<FieldDef>());
				list.Add(field);
			}

			foreach (var list in typeToFields.GetValues()) {
				if (list.Count == 1)
					yield return list[0];
			}
		}

		static bool CheckBaseType(TypeDef type) {
			if (type == null || type.BaseType == null)
				return false;
			var fn = type.BaseType.FullName;
			return fn == "System.ValueType" || fn == "System.Object";
		}

		void RemoveType(Dictionary<TypeDef, List<TypeDef>> candidates, TypeSig type) {
			var typeDef = DotNetUtils.GetType(module, type);
			if (typeDef == null)
				return;
			candidates.Remove(typeDef);
		}

		static bool CheckMethods(TypeDef type) {
			foreach (var method in type.Methods) {
				if (method.Name == ".cctor")
					continue;
				if (type.BaseType != null && type.BaseType.FullName == "System.Object" && method.Name == ".ctor" && method.MethodSig.GetParamCount() == 0)
					continue;
				if (!method.IsStatic)
					return true;
				if (method.GenericParameters.Count > 0)
					return true;
				if (method.Body == null)
					return true;
				if (method.ImplMap != null)
					return true;
			}
			return false;
		}

		static bool CheckFields(TypeDef type) {
			if (type.Fields.Count == 0)
				return false;
			foreach (var field in type.Fields) {
				if (field.IsStatic)
					return false;
				if (!field.IsAssembly)
					return false;
			}
			return true;
		}

		public void Deobfuscate(Blocks blocks) {
			DeobfuscateNormal(blocks);
			FixFieldCtorCalls(blocks);
		}

		void DeobfuscateNormal(Blocks blocks) {
			var instrsToRemove = new List<int>();
			foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {
				instrsToRemove.Clear();
				var instrs = block.Instructions;
				for (int i = instrs.Count - 1; i >= 0; i--) {
					var instr = instrs[i];
					if (instr.OpCode.Code != Code.Ldflda && instr.OpCode.Code != Code.Ldfld)
						continue;
					var structField = instr.Operand as IField;
					if (structField == null || !structFieldsToFix.Find(structField))
						continue;

					var ldStFld = instrs[FindLdStFieldIndex(instrs, i + 1)];
					ldStFld.Operand = GetNewField(structField, ldStFld.Operand as IField);
					instrsToRemove.Add(i);
				}
				if (instrsToRemove.Count > 0)
					block.Remove(instrsToRemove);
			}
		}

		void FixFieldCtorCalls(Blocks blocks) {
			if (blocks.Method.Name != ".ctor")
				return;
			//var instrsToRemove = new List<int>();
			foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {
				var instrs = block.Instructions;
				for (int i = 0; i < instrs.Count; i++) {
					var stfld = instrs[i];
					if (stfld.OpCode.Code != Code.Stfld)
						continue;
					var field = stfld.Operand as IField;
					if (field == null)
						continue;
					if (!structFieldsToFix.Find(field))
						continue;
					var instrs2 = ToInstructionList(instrs);
					var instrPushes = DotNetUtils.GetArgPushes(instrs2, i);
					if (instrPushes == null || instrPushes.Count != 2)
						continue;
					block.Remove(i, 1);
					block.Remove(instrs2.IndexOf(instrPushes[1]), 1);
					block.Remove(instrs2.IndexOf(instrPushes[0]), 1);
					i -= 3;
				}
			}
		}

		static IList<Instruction> ToInstructionList(IEnumerable<Instr> instrs) {
			var newInstrs = new List<Instruction>();
			foreach (var instr in instrs)
				newInstrs.Add(instr.Instruction);
			return newInstrs;
		}

		FieldDef GetNewField(IField structField, IField oldFieldRef) {
			var fieldsDict = typeToFieldsDict.Find(structField.DeclaringType);
			if (fieldsDict == null)
				throw new ApplicationException("Could not find structField declaringType");
			var newField = fieldsDict.Find(oldFieldRef);
			if (newField == null)
				throw new ApplicationException("Could not find new field");
			return newField;
		}

		static int FindLdStFieldIndex(IList<Instr> instrs, int index) {
			int stack = 0;
			for (int i = index; i < instrs.Count; i++) {
				var instr = instrs[i];

				if (stack == 0 && (instr.OpCode.Code == Code.Ldfld || instr.OpCode.Code == Code.Ldflda))
					return i;
				if (stack == 1 && instr.OpCode.Code == Code.Stfld)
					return i;

				instr.Instruction.CalculateStackUsage(false, out int pushes, out int pops);
				stack -= pops;
				if (stack < 0)
					break;
				stack += pushes;
			}
			throw new ApplicationException("Could not find ldfld/stfld");
		}

		public void CleanUp() {
			foreach (var field in structFieldsToFix.GetKeys())
				field.DeclaringType.Fields.Remove(field);
		}
	}
}



================================================
File: de4dot.code/deobfuscators/DeepSea/ResolverBase.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.DeepSea {
	abstract class ResolverBase {
		protected ModuleDefMD module;
		protected ISimpleDeobfuscator simpleDeobfuscator;
		protected IDeobfuscator deob;
		protected MethodDef initMethod;
		protected MethodDef resolveHandler;
		protected FrameworkType frameworkType;

		public MethodDef InitMethod => initMethod;
		public MethodDef HandlerMethod => resolveHandler;
		public bool Detected => initMethod != null;

		public ResolverBase(ModuleDefMD module, ISimpleDeobfuscator simpleDeobfuscator, IDeobfuscator deob) {
			this.module = module;
			frameworkType = DotNetUtils.GetFrameworkType(module);
			this.simpleDeobfuscator = simpleDeobfuscator;
			this.deob = deob;
		}

		public void Find() {
			if (CheckCalledMethods(DotNetUtils.GetModuleTypeCctor(module)))
				return;
			if (CheckCalledMethods(module.EntryPoint))
				return;
		}

		bool CheckCalledMethods(MethodDef checkMethod) {
			if (checkMethod == null || checkMethod.Body == null)
				return false;

			foreach (var method in DotNetUtils.GetCalledMethods(module, checkMethod)) {
				if (method.Name == ".cctor" || method.Name == ".ctor")
					continue;
				if (!method.IsStatic || !DotNetUtils.IsMethod(method, "System.Void", "()"))
					continue;

				if (CheckResolverInitMethod(method))
					return true;
			}

			return false;
		}

		bool CheckResolverInitMethod(MethodDef resolverInitMethod) {
			if (resolverInitMethod == null || resolverInitMethod.Body == null)
				return false;
			if (resolverInitMethod.Body.ExceptionHandlers.Count != 1)
				return false;

			switch (frameworkType) {
			case FrameworkType.Silverlight:
				return CheckResolverInitMethodSilverlight(resolverInitMethod);
			default:
				return CheckResolverInitMethodDesktop(resolverInitMethod);
			}
		}

		bool CheckResolverInitMethodDesktop(MethodDef resolverInitMethod) {
			simpleDeobfuscator.Deobfuscate(resolverInitMethod);
			if (!CheckResolverInitMethodInternal(resolverInitMethod))
				return false;

			foreach (var resolveHandlerMethod in GetLdftnMethods(resolverInitMethod)) {
				if (!CheckHandlerMethodDesktop(resolveHandlerMethod))
					continue;

				initMethod = resolverInitMethod;
				resolveHandler = resolveHandlerMethod;
				return true;
			}

			return false;
		}

		protected virtual bool CheckResolverInitMethodSilverlight(MethodDef resolverInitMethod) => false;
		protected abstract bool CheckResolverInitMethodInternal(MethodDef resolverInitMethod);

		IEnumerable<MethodDef> GetLdftnMethods(MethodDef method) {
			var list = new List<MethodDef>();
			foreach (var instr in method.Body.Instructions) {
				if (instr.OpCode.Code != Code.Ldftn)
					continue;
				if (instr.Operand is MethodDef loadedMethod)
					list.Add(loadedMethod);
			}
			return list;
		}

		bool CheckHandlerMethodDesktop(MethodDef handler) {
			if (handler == null || handler.Body == null || !handler.IsStatic)
				return false;
			if (!DotNetUtils.IsMethod(handler, "System.Reflection.Assembly", "(System.Object,System.ResolveEventArgs)"))
				return false;
			return CheckHandlerMethodDesktopInternal(handler);
		}

		protected abstract bool CheckHandlerMethodDesktopInternal(MethodDef handler);

		// 3.0.3.41 - 3.0.4.44
		protected static byte[] DecryptResourceV3Old(EmbeddedResource resource) =>
			DecryptResourceV3Old(resource.CreateReader().ToArray());

		// 3.0.3.41 - 3.0.4.44
		protected static byte[] DecryptResourceV3Old(byte[] data) =>
			DecryptResource(data, 0, data.Length, 0);

		protected static byte[] DecryptResourceV41SL(EmbeddedResource resource) {
			var data = resource.CreateReader().ToArray();
			byte k = data[0];
			for (int i = 0; i < data.Length - 1; i++)
				data[i + 1] ^= (byte)((k << (i & 5)) + i);
			return InflateIfNeeded(data, 1, data.Length - 1);
		}

		protected static byte[] DecryptResourceV3(EmbeddedResource resource) => DecryptResourceV3(resource.CreateReader().ToArray());
		protected static byte[] DecryptResourceV3(byte[] data) => DecryptResource(data, 1, data.Length - 1, data[0]);
		protected static byte[] DecryptResourceV4(byte[] data, int magic) => DecryptResource(data, 0, data.Length, magic);

		protected static byte[] DecryptResource(byte[] data, int start, int len, int magic) {
			for (int i = start; i < start + len; i++)
				data[i] ^= (byte)(i - start + magic);
			return InflateIfNeeded(data, start, len);
		}

		protected static byte[] InflateIfNeeded(byte[] data) => InflateIfNeeded(data, 0, data.Length);

		protected static byte[] InflateIfNeeded(byte[] data, int start, int len) {
			if (BitConverter.ToInt16(data, start) != 0x5A4D)
				return DeobUtils.Inflate(data, start, len, true);

			var data2 = new byte[len];
			Array.Copy(data, start, data2, 0, data2.Length);
			return data2;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/DeepSea/ResourceResolver.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.DeepSea {
	class ResourceResolver : ResolverBase {
		Data30 data30;
		Data40 data40;
		Data41 data41;
		ResourceVersion version = ResourceVersion.Unknown;

		enum ResourceVersion {
			Unknown,
			V3,
			V40,
			V41,
		}

		class Data30 {
			public EmbeddedResource resource;
		}

		class Data40 {
			public FieldDef resourceField;
			public MethodDef resolveHandler2;
			public MethodDef getDataMethod;
			public int magic;
		}

		class Data41 {
			public FieldDef resourceField;
			public MethodDef resolveHandler2;
			public int magic;
			public bool isTrial;
		}

		class HandlerInfo {
			public MethodDef handler;
			public IList<object> args;

			public HandlerInfo(MethodDef handler, IList<object> args) {
				this.handler = handler;
				this.args = args;
			}
		}

		public MethodDef InitMethod2 {
			get {
				if (data40 != null)
					return data40.resolveHandler2;
				if (data41 != null)
					return data41.resolveHandler2;
				return null;
			}
		}

		public MethodDef GetDataMethod => data40?.getDataMethod;
		public EmbeddedResource Resource => data30?.resource;

		public ResourceResolver(ModuleDefMD module, ISimpleDeobfuscator simpleDeobfuscator, IDeobfuscator deob)
			: base(module, simpleDeobfuscator, deob) {
		}

		protected override bool CheckResolverInitMethodInternal(MethodDef resolverInitMethod) =>
			DotNetUtils.CallsMethod(resolverInitMethod, "System.Void System.AppDomain::add_ResourceResolve(System.ResolveEventHandler)");

		protected override bool CheckHandlerMethodDesktopInternal(MethodDef handler) {
			if (CheckHandlerV3(handler)) {
				version = ResourceVersion.V3;
				return true;
			}

			simpleDeobfuscator.Deobfuscate(handler);
			if ((data40 = CheckHandlerV40(handler)) != null) {
				version = ResourceVersion.V40;
				return true;
			}

			var info = GetHandlerArgs41(handler);
			if (info != null && CheckHandlerV41(info, out var data41Tmp)) {
				version = ResourceVersion.V41;
				data41 = data41Tmp;
				return true;
			}

			return false;
		}

		HandlerInfo GetHandlerArgs41(MethodDef handler) {
			var instrs = handler.Body.Instructions;
			for (int i = 0; i < instrs.Count; i++) {
				var instr = instrs[i];
				if (instr.OpCode.Code != Code.Call)
					continue;
				var calledMethod = instr.Operand as MethodDef;
				if (calledMethod == null)
					continue;
				if (GetLdtokenField(calledMethod) == null)
					continue;
				var args = DsUtils.GetArgValues(instrs, i);
				if (args == null)
					continue;

				return new HandlerInfo(calledMethod, args);
			}
			return null;
		}

		bool CheckHandlerV41(HandlerInfo info, out Data41 data41) {
			data41 = new Data41();
			data41.resolveHandler2 = info.handler;
			data41.resourceField = GetLdtokenField(info.handler);
			if (data41.resourceField == null)
				return false;
			int magicArgIndex = GetMagicArgIndex41Retail(info.handler, out bool isOtherRetail);
			if (magicArgIndex < 0) {
				magicArgIndex = GetMagicArgIndex41Trial(info.handler);
				data41.isTrial = true;
			}
			var asmVer = module.Assembly.Version;
			if (magicArgIndex < 0 || magicArgIndex >= info.args.Count)
				return false;
			var val = info.args[magicArgIndex];
			if (!(val is int))
				return false;
			if (data41.isTrial)
				data41.magic = (int)val >> 3;
			else if (isOtherRetail)
				data41.magic = data41.resourceField.InitialValue.Length - (int)val;
			else
				data41.magic = ((asmVer.Major << 3) | (asmVer.Minor << 2) | asmVer.Revision) - (int)val;
			return true;
		}

		static int GetMagicArgIndex41Retail(MethodDef method, out bool isOtherRetail) {
			isOtherRetail = false;
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 4; i++) {
				isOtherRetail = false;
				var ld = instrs[i];
				if (ld.IsLdarg())
					isOtherRetail = true;
				else if (!ld.IsLdloc())
					continue;

				var add = instrs[i + 1];
				if (add.OpCode.Code != Code.Add)
					continue;
				var ldarg = instrs[i + 2];
				if (!ldarg.IsLdarg())
					continue;
				var sub = instrs[i + 3];
				if (sub.OpCode.Code != Code.Sub)
					continue;
				var ldci4 = instrs[i + 4];
				if (!ldci4.IsLdcI4() || ldci4.GetLdcI4Value() != 0xFF)
					continue;

				return ldarg.GetParameterIndex();
			}

			return -1;
		}

		static int GetMagicArgIndex41Trial(MethodDef method) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 2; i++) {
				var ldarg = instrs[i];
				if (!ldarg.IsLdarg())
					continue;
				if (!instrs[i + 1].IsLdcI4())
					continue;
				if (instrs[i + 2].OpCode.Code != Code.Shr)
					continue;

				return ldarg.GetParameterIndex();
			}
			return -1;
		}

		static FieldDef GetLdtokenField(MethodDef method) {
			foreach (var instr in method.Body.Instructions) {
				if (instr.OpCode.Code != Code.Ldtoken)
					continue;
				var field = instr.Operand as FieldDef;
				if (field == null || field.InitialValue == null || field.InitialValue.Length == 0)
					continue;

				return field;
			}
			return null;
		}

		static string[] handlerLocalTypes_V3 = new string[] {
			"System.AppDomain",
			"System.Byte[]",
			"System.Collections.Generic.Dictionary`2<System.String,System.String>",
			"System.IO.Compression.DeflateStream",
			"System.IO.MemoryStream",
			"System.IO.Stream",
			"System.Reflection.Assembly",
			"System.String",
			"System.String[]",
		};
		static bool CheckHandlerV3(MethodDef handler) => new LocalTypes(handler).All(handlerLocalTypes_V3);

		static Data40 CheckHandlerV40(MethodDef handler) {
			var data40 = new Data40();

			var instrs = handler.Body.Instructions;
			for (int i = 0; i < instrs.Count; i++) {
				int index = i;

				if (instrs[index++].OpCode.Code != Code.Ldarg_1)
					continue;

				var ldtoken = instrs[index++];
				if (ldtoken.OpCode.Code != Code.Ldtoken)
					continue;
				var field = ldtoken.Operand as FieldDef;

				string methodSig = "(System.ResolveEventArgs,System.RuntimeFieldHandle,System.Int32,System.String,System.Int32)";
				var method = ldtoken.Operand as MethodDef;
				if (method != null) {
					// >= 4.0.4
					if (!DotNetUtils.IsMethod(method, "System.Byte[]", "()"))
						continue;
					field = GetResourceField(method);
					methodSig = "(System.ResolveEventArgs,System.RuntimeMethodHandle,System.Int32,System.String,System.Int32)";
				}
				else {
					// 4.0.1.18 .. 4.0.3
				}

				if (field == null || field.InitialValue == null || field.InitialValue.Length == 0)
					continue;

				var ldci4_len = instrs[index++];
				if (!ldci4_len.IsLdcI4())
					continue;
				if (ldci4_len.GetLdcI4Value() != field.InitialValue.Length)
					continue;

				if (instrs[index++].OpCode.Code != Code.Ldstr)
					continue;

				var ldci4_magic = instrs[index++];
				if (!ldci4_magic.IsLdcI4())
					continue;
				data40.magic = ldci4_magic.GetLdcI4Value();

				var call = instrs[index++];
				if (call.OpCode.Code == Code.Tailcall)
					call = instrs[index++];
				if (call.OpCode.Code != Code.Call)
					continue;
				var resolveHandler2 = call.Operand as MethodDef;
				if (!DotNetUtils.IsMethod(resolveHandler2, "System.Reflection.Assembly", methodSig))
					continue;

				data40.resourceField = field;
				data40.getDataMethod = method;
				data40.resolveHandler2 = resolveHandler2;
				return data40;
			}

			return null;
		}

		static FieldDef GetResourceField(MethodDef method) {
			foreach (var instr in method.Body.Instructions) {
				if (instr.OpCode.Code != Code.Ldtoken)
					continue;
				var field = instr.Operand as FieldDef;
				if (field == null || field.InitialValue == null || field.InitialValue.Length == 0)
					continue;
				return field;
			}
			return null;
		}

		public void Initialize() {
			if (resolveHandler == null)
				return;

			if (version == ResourceVersion.V3) {
				simpleDeobfuscator.Deobfuscate(resolveHandler);
				simpleDeobfuscator.DecryptStrings(resolveHandler, deob);
				data30 = new Data30();
				data30.resource = DeobUtils.GetEmbeddedResourceFromCodeStrings(module, resolveHandler);
				if (data30.resource == null) {
					Logger.w("Could not find resource of encrypted resources");
					return;
				}
			}
		}

		public bool MergeResources(out EmbeddedResource rsrc) {
			rsrc = null;

			switch (version) {
			case ResourceVersion.V3:
				if (data30.resource == null)
					return false;

				DeobUtils.DecryptAndAddResources(module, data30.resource.Name.String, () => DecryptResourceV3(data30.resource));
				rsrc = data30.resource;
				return true;

			case ResourceVersion.V40:
				return DecryptResource(data40.resourceField, data40.magic);

			case ResourceVersion.V41:
				return DecryptResource(data41.resourceField, data41.magic);

			default:
				return true;
			}
		}

		bool DecryptResource(FieldDef resourceField, int magic) {
			if (resourceField == null)
				return false;

			string name = $"Embedded data field {resourceField.MDToken.ToInt32():X8} RVA {(uint)resourceField.RVA:X8}";
			DeobUtils.DecryptAndAddResources(module, name, () => DecryptResourceV4(resourceField.InitialValue, magic));
			resourceField.InitialValue = new byte[1];
			resourceField.FieldSig.Type = module.CorLibTypes.Byte;
			resourceField.RVA = 0;
			return true;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/DeepSea/StringDecrypter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Text;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.DeepSea {
	class StringDecrypter {
		ModuleDefMD module;
		MethodDefAndDeclaringTypeDict<IDecrypterInfo> methodToInfo = new MethodDefAndDeclaringTypeDict<IDecrypterInfo>();
		DecrypterVersion version = DecrypterVersion.Unknown;

		public enum DecrypterVersion {
			Unknown,
			V1_3,
			V4_0,
			V4_1,
		}

		interface IDecrypterInfo {
			DecrypterVersion Version { get; }
			MethodDef Method { get; }
			string Decrypt(object[] args);
			void CleanUp();
		}

		static short[] FindKey(MethodDef initMethod, FieldDef keyField) {
			var fields = new FieldDefAndDeclaringTypeDict<bool>();
			fields.Add(keyField, true);
			return FindKey(initMethod, fields);
		}

		static short[] FindKey(MethodDef initMethod, FieldDefAndDeclaringTypeDict<bool> fields) {
			var instrs = initMethod.Body.Instructions;
			for (int i = 0; i < instrs.Count - 2; i++) {
				var ldci4 = instrs[i];
				if (!ldci4.IsLdcI4())
					continue;
				var newarr = instrs[i + 1];
				if (newarr.OpCode.Code != Code.Newarr)
					continue;
				if (newarr.Operand.ToString() != "System.Char")
					continue;

				var stloc = instrs[i + 2];
				if (!stloc.IsStloc())
					continue;
				var local = stloc.GetLocal(initMethod.Body.Variables);

				int startInitIndex = i;
				i++;
				var array = ArrayFinder.GetInitializedInt16Array(ldci4.GetLdcI4Value(), initMethod, ref i);
				if (array == null)
					continue;

				var field = GetStoreField(initMethod, startInitIndex, local);
				if (field == null)
					continue;
				if (fields.Find(field))
					return array;
			}

			return null;
		}

		static FieldDef GetStoreField(MethodDef method, int startIndex, Local local) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 1; i++) {
				var ldloc = instrs[i];
				if (!ldloc.IsLdloc())
					continue;
				if (ldloc.GetLocal(method.Body.Variables) != local)
					continue;

				var stsfld = instrs[i + 1];
				if (stsfld.OpCode.Code != Code.Stsfld)
					continue;
				return stsfld.Operand as FieldDef;
			}

			return null;
		}

		static bool FindMagic(MethodDef method, out int magic) => FindMagic(method, out int arg1, out int arg2, out magic);

		static bool FindMagic(MethodDef method, out int arg1, out int arg2, out int magic) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 3; i++) {
				if ((arg1 = instrs[i].GetParameterIndex()) < 0)
					continue;
				var ldci4 = instrs[i + 1];
				if (!ldci4.IsLdcI4())
					continue;
				if (instrs[i + 2].OpCode.Code != Code.Xor)
					continue;
				if ((arg2 = instrs[i + 3].GetParameterIndex()) < 0)
					continue;
				magic = ldci4.GetLdcI4Value();
				return true;
			}
			arg1 = arg2 = 0;
			magic = 0;
			return false;
		}

		static void RemoveInitializeArrayCall(MethodDef method, FieldDef field) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 1; i++) {
				var ldtoken = instrs[i];
				if (ldtoken.OpCode.Code != Code.Ldtoken)
					continue;
				if (ldtoken.Operand != field)
					continue;

				var call = instrs[i + 1];
				if (call.OpCode.Code != Code.Call)
					continue;
				var calledMethod = call.Operand as IMethod;
				if (calledMethod == null)
					continue;
				if (calledMethod.ToString() != "System.Void System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(System.Array,System.RuntimeFieldHandle)")
					continue;

				instrs[i] = OpCodes.Pop.ToInstruction();
				instrs[i + 1] = OpCodes.Nop.ToInstruction();
			}
		}

		class DecrypterInfo41 : IDecrypterInfo {
			MethodDef cctor;
			int magic;
			int arg1, arg2;
			FieldDefAndDeclaringTypeDict<bool> fields;
			ArrayInfo arrayInfo;
			ushort[] encryptedData;
			short[] key;
			int keyShift;
			DecryptType decryptType;

			// This'll do for now. Code should be added to detect the constants in the code.
			enum DecryptType {
				Type1,
				Type2,
				Type3,
			}

			class ArrayInfo {
				public int sizeInElems;
				public ITypeDefOrRef elementType;
				public FieldDef initField;
				public FieldDef field;

				public ArrayInfo(int sizeInElems, ITypeDefOrRef elementType, FieldDef initField, FieldDef field) {
					this.sizeInElems = sizeInElems;
					this.elementType = elementType;
					this.initField = initField;
					this.field = field;
				}
			}

			public DecrypterVersion Version => DecrypterVersion.V4_1;
			public MethodDef Method { get; private set; }

			public DecrypterInfo41(MethodDef cctor, MethodDef method) {
				this.cctor = cctor;
				Method = method;
			}

			public static bool IsPossibleDecrypterMethod(MethodDef method, ref bool? state) {
				if (!CheckMethodSignature(method))
					return false;
				var fields = GetFields(method);
				if (fields == null || fields.Count != 3)
					return false;

				return true;
			}

			static bool CheckMethodSignature(MethodDef method) {
				if (method.MethodSig.GetRetType().GetElementType() != ElementType.String)
					return false;
				int count = 0;
				foreach (var arg in method.MethodSig.GetParams()) {
					if (arg.ElementType == ElementType.I4)
						count++;
				}
				return count >= 2;
			}

			static FieldDefAndDeclaringTypeDict<bool> GetFields(MethodDef method) {
				var fields = new FieldDefAndDeclaringTypeDict<bool>();
				foreach (var instr in method.Body.Instructions) {
					if (instr.OpCode.Code != Code.Ldsfld && instr.OpCode.Code != Code.Stsfld)
						continue;
					var field = instr.Operand as FieldDef;
					if (field == null)
						continue;
					if (field.DeclaringType != method.DeclaringType)
						continue;
					fields.Add(field, true);
				}
				return fields;
			}

			public bool Initialize() {
				if (!FindMagic(Method, out arg1, out arg2, out magic))
					return false;

				fields = GetFields(Method);
				if (fields == null)
					return false;

				arrayInfo = GetArrayInfo(cctor);
				if (arrayInfo == null)
					return false;

				if (arrayInfo.initField.InitialValue.Length % 2 == 1)
					return false;
				encryptedData = new ushort[arrayInfo.initField.InitialValue.Length / 2];
				Buffer.BlockCopy(arrayInfo.initField.InitialValue, 0, encryptedData, 0, arrayInfo.initField.InitialValue.Length);

				decryptType = GetDecryptType(Method);
				keyShift = FindKeyShift(cctor);
				key = FindKey();
				if (key == null || key.Length == 0)
					return false;

				return true;
			}

			static DecryptType GetDecryptType(MethodDef method) {
				if (DeobUtils.HasInteger(method, 0xFFF0))
					return DecryptType.Type2;
				if (DeobUtils.HasInteger(method, 0xFFC0))
					return DecryptType.Type3;
				return DecryptType.Type1;	// trial
			}

			int FindKeyShift(MethodDef method) {
				var instrs = method.Body.Instructions;
				for (int i = 0; i < instrs.Count - 3; i++) {
					int index = i;

					var ldci4 = instrs[index++];
					if (!ldci4.IsLdcI4())
						continue;
					if (ldci4.GetLdcI4Value() != 0xFF)
						continue;

					if (instrs[index++].OpCode.Code != Code.And)
						continue;
					if (instrs[index++].OpCode.Code != Code.Dup)
						continue;

					var ldci4_2 = instrs[index++];
					if (!ldci4_2.IsLdcI4())
						continue;

					if (FindNextFieldUse(method, index) < 0)
						continue;

					return ldci4_2.GetLdcI4Value();
				}
				return -1;
			}

			int FindNextFieldUse(MethodDef method, int index) {
				var instrs = method.Body.Instructions;
				for (int i = index; i < instrs.Count; i++) {
					var instr = instrs[i];
					if (instr.OpCode.Code != Code.Ldsfld && instr.OpCode.Code != Code.Stsfld)
						continue;
					var field = instr.Operand as IField;
					if (!fields.Find(field))
						return -1;

					return i;
				}
				return -1;
			}

			ArrayInfo GetArrayInfo(MethodDef method) {
				var instructions = method.Body.Instructions;
				for (int i = 0; i < instructions.Count; i++) {
					var ldci4_arraySizeInBytes = instructions[i];
					if (!ldci4_arraySizeInBytes.IsLdcI4())
						continue;
					i++;
					var instrs = DotNetUtils.GetInstructions(instructions, i, OpCodes.Newarr, OpCodes.Dup, OpCodes.Ldtoken, OpCodes.Call, OpCodes.Stsfld);
					if (instrs == null)
						continue;

					int sizeInBytes = ldci4_arraySizeInBytes.GetLdcI4Value();
					var elementType = instrs[0].Operand as ITypeDefOrRef;
					var initField = instrs[2].Operand as FieldDef;
					var field = instrs[4].Operand as FieldDef;
					if (elementType == null)
						continue;
					if (initField == null || initField.InitialValue == null || initField.InitialValue.Length == 0)
						continue;
					if (!fields.Find(field))
						continue;

					return new ArrayInfo(sizeInBytes, elementType, initField, field);
				}
				return null;
			}

			short[] FindKey() {
				if (cctor.Module.Assembly == null)
					return null;
				var pkt = cctor.Module.Assembly.PublicKeyToken;
				if (!PublicKeyBase.IsNullOrEmpty2(pkt))
					return GetPublicKeyTokenKey(pkt.Data);
				return FindKey(cctor);
			}

			short[] FindKey(MethodDef initMethod) => StringDecrypter.FindKey(initMethod, fields);

			short[] GetPublicKeyTokenKey(byte[] publicKeyToken) {
				if (keyShift < 0)
					throw new ApplicationException("Could not find shift value");
				var key = new short[publicKeyToken.Length];
				for (int i = 0; i < publicKeyToken.Length; i++) {
					int b = publicKeyToken[i];
					key[i] = (short)((b << keyShift) ^ b);
				}
				return key;
			}

			public string Decrypt(object[] args) {
				switch (decryptType) {
				case DecryptType.Type1:
					return DecryptTrial((int)args[arg1], (int)args[arg2]);

				case DecryptType.Type2:
					return DecryptRetail2((int)args[arg1], (int)args[arg2]);

				case DecryptType.Type3:
					return DecryptRetail3((int)args[arg1], (int)args[arg2]);

				default:
					throw new ApplicationException("Unknown type");
				}
			}

			string DecryptTrial(int magic2, int magic3) {
				int offset = magic ^ magic2 ^ magic3;
				var keyChar = encryptedData[offset + 1];
				//int cachedIndex = encryptedData[offset] ^ keyChar;
				int numChars = ((keyChar ^ encryptedData[offset + 2]) << 16) + (keyChar ^ encryptedData[offset + 3]);
				offset += 4;
				var sb = new StringBuilder(numChars);
				for (int i = 0; i < numChars; i++)
					sb.Append((char)(keyChar ^ encryptedData[offset + i] ^ key[(offset + i) % key.Length]));
				return sb.ToString();
			}

			string DecryptRetail2(int magic2, int magic3) => DecryptRetail(magic2, magic3, 2, 1, 0, 8, 0);
			string DecryptRetail3(int magic2, int magic3) => DecryptRetail(magic2, magic3, 0, 2, 1, 0x20, 17);

			string DecryptRetail(int magic2, int magic3, int keyCharOffs, int cachedIndexOffs, int flagsOffset, int flag, int keyDispl) {
				int offset = magic ^ magic2 ^ magic3;
				var keyChar = encryptedData[offset + keyCharOffs];
				//int cachedIndex = encryptedData[offset + cachedIndexOffs] ^ keyChar;
				int flags = encryptedData[offset + flagsOffset] ^ keyChar;
				int numChars = ((flags >> 1) & ~(flag - 1)) | (flags & (flag - 1));
				if ((flags & flag) != 0) {
					numChars <<= 15;
					numChars |= encryptedData[offset + 3] ^ keyChar;
					offset++;
				}
				offset += 3;
				var sb = new StringBuilder(numChars);
				for (int i = 0; i < numChars; i++)
					sb.Append((char)(keyChar ^ encryptedData[offset + numChars - i - 1] ^ key[(i + 1 + keyDispl + offset) % key.Length]));
				return sb.ToString();
			}

			public void CleanUp() {
				arrayInfo.initField.InitialValue = new byte[1];
				arrayInfo.initField.FieldSig.Type = arrayInfo.initField.Module.CorLibTypes.Byte;
				arrayInfo.initField.RVA = 0;
				RemoveInitializeArrayCall(cctor, arrayInfo.initField);
			}
		}

		class DecrypterInfo40 : IDecrypterInfo {
			MethodDef cctor;
			int magic;
			FieldDef cachedStringsField;
			FieldDef keyField;
			FieldDef encryptedStringsField;
			FieldDef encryptedDataField;
			short[] key;
			ushort[] encryptedData;

			public MethodDef Method { get; private set; }
			public DecrypterVersion Version => DecrypterVersion.V4_0;

			public DecrypterInfo40(MethodDef cctor, MethodDef method) {
				this.cctor = cctor;
				Method = method;
			}

			public static bool IsPossibleDecrypterMethod(MethodDef method, ref bool? state) {
				if (state == null)
					state = CheckFields(method.DeclaringType.Fields);
				if (!state.Value)
					return false;
				return DotNetUtils.IsMethod(method, "System.String", "(System.Int32,System.Int32)");
			}

			public bool Initialize() {
				if (!FindMagic(Method, out magic))
					return false;

				var charArrayFields = FindFields();
				if (charArrayFields == null || charArrayFields.Count != 2)
					return false;

				encryptedStringsField = FindEncryptedStrings(cctor, charArrayFields, out encryptedDataField);
				if (encryptedStringsField == null)
					return false;
				if (encryptedDataField.InitialValue.Length % 2 == 1)
					return false;
				encryptedData = new ushort[encryptedDataField.InitialValue.Length / 2];
				Buffer.BlockCopy(encryptedDataField.InitialValue, 0, encryptedData, 0, encryptedDataField.InitialValue.Length);

				charArrayFields.Remove(encryptedStringsField);
				keyField = charArrayFields[0];

				key = FindKey();
				if (key == null || key.Length == 0)
					return false;

				return true;
			}

			List<FieldDef> FindFields() {
				var charArrayFields = new List<FieldDef>();

				foreach (var instr in Method.Body.Instructions) {
					if (instr.OpCode.Code != Code.Stsfld && instr.OpCode.Code != Code.Ldsfld)
						continue;
					var field = instr.Operand as FieldDef;
					if (field == null)
						continue;
					if (!new SigComparer().Equals(Method.DeclaringType, field.DeclaringType))
						continue;
					switch (field.FieldSig.GetFieldType().GetFullName()) {
					case "System.Char[]":
						if (!charArrayFields.Contains(field))
							charArrayFields.Add(field);
						break;

					case "System.String[]":
						if (cachedStringsField != null && cachedStringsField != field)
							return null;
						cachedStringsField = field;
						break;

					default:
						break;
					}
				}

				if (cachedStringsField == null)
					return null;

				return charArrayFields;
			}

			static FieldDef FindEncryptedStrings(MethodDef initMethod, List<FieldDef> ourFields, out FieldDef dataField) {
				for (int i = 0; i < initMethod.Body.Instructions.Count; i++) {
					var instrs = DotNetUtils.GetInstructions(initMethod.Body.Instructions, i, OpCodes.Ldtoken, OpCodes.Call, OpCodes.Stsfld);
					if (instrs == null)
						continue;

					dataField = instrs[0].Operand as FieldDef;
					if (dataField == null || dataField.InitialValue == null || dataField.InitialValue.Length == 0)
						continue;

					var savedField = instrs[2].Operand as FieldDef;
					if (savedField == null || !Matches(ourFields, savedField))
						continue;

					return savedField;
				}

				dataField = null;
				return null;
			}

			static bool Matches(IEnumerable<FieldDef> ourFields, FieldDef field) {
				foreach (var ourField in ourFields) {
					if (FieldEqualityComparer.CompareDeclaringTypes.Equals(ourField, field))
						return true;
				}
				return false;
			}

			short[] FindKey() {
				if (cctor.Module.Assembly == null)
					return null;
				var pkt = cctor.Module.Assembly.PublicKeyToken;
				if (!PublicKeyBase.IsNullOrEmpty2(pkt))
					return GetPublicKeyTokenKey(pkt.Data);
				return FindKey(cctor);
			}

			short[] FindKey(MethodDef initMethod) => StringDecrypter.FindKey(initMethod, keyField);

			static short[] GetPublicKeyTokenKey(byte[] publicKeyToken) {
				var key = new short[publicKeyToken.Length];
				for (int i = 0; i < publicKeyToken.Length; i++) {
					int b = publicKeyToken[i];
					key[i] = (short)((b << 4) ^ b);
				}
				return key;
			}

			public string Decrypt(object[] args) => Decrypt((int)args[0], (int)args[1]);

			string Decrypt(int magic2, int magic3) {
				int index = magic ^ magic2 ^ magic3;
				int cachedIndex = encryptedData[index++];
				int stringLen = encryptedData[index++] + ((int)encryptedData[index++] << 16);
				var sb = new StringBuilder(stringLen);
				for (int i = 0; i < stringLen; i++)
					sb.Append((char)(encryptedData[index++] ^ key[cachedIndex++ % key.Length]));
				return sb.ToString();
			}

			public void CleanUp() {
				encryptedDataField.InitialValue = new byte[1];
				encryptedDataField.FieldSig.Type = encryptedDataField.Module.CorLibTypes.Byte;
				encryptedDataField.RVA = 0;
				RemoveInitializeArrayCall(cctor, encryptedDataField);
			}
		}

		class DecrypterInfo13 : IDecrypterInfo {
			MethodDef cctor;
			FieldDef cachedStringsField;
			FieldDef keyField;
			int magic;
			string[] encryptedStrings;
			short[] key;

			public MethodDef Method { get; private set; }
			public DecrypterVersion Version => DecrypterVersion.V1_3;

			public static bool IsPossibleDecrypterMethod(MethodDef method, ref bool? state) {
				if (state == null)
					state = CheckFields(method.DeclaringType.Fields);
				if (!state.Value)
					return false;
				return DotNetUtils.IsMethod(method, "System.String", "(System.Int32)");
			}

			public DecrypterInfo13(MethodDef cctor, MethodDef method) {
				this.cctor = cctor;
				Method = method;
			}

			public string Decrypt(object[] args) => Decrypt((int)args[0]);

			string Decrypt(int magic2) {
				var es = encryptedStrings[magic ^ magic2];
				var sb = new StringBuilder(es.Length);
				for (int i = 0; i < es.Length; i++)
					sb.Append((char)(es[i] ^ key[(magic2 + i) % key.Length]));
				return sb.ToString();
			}

			public bool Initialize() {
				if (!FindMagic(Method, out magic))
					return false;

				if (!FindFields())
					return false;

				if (!FindEncryptedStrings(Method))
					return false;

				key = FindKey();
				if (key == null || key.Length == 0)
					return false;

				return true;
			}

			bool FindFields() {
				foreach (var instr in Method.Body.Instructions) {
					if (instr.OpCode.Code != Code.Stsfld && instr.OpCode.Code != Code.Ldsfld)
						continue;
					var field = instr.Operand as FieldDef;
					if (field == null)
						continue;
					if (!new SigComparer().Equals(Method.DeclaringType, field.DeclaringType))
						continue;
					switch (field.FieldSig.GetFieldType().GetFullName()) {
					case "System.Char[]":
						if (keyField != null && keyField != field)
							return false;
						keyField = field;
						break;

					case "System.String[]":
						if (cachedStringsField != null && cachedStringsField != field)
							return false;
						cachedStringsField = field;
						break;

					default:
						break;
					}
				}

				return keyField != null && cachedStringsField != null;
			}

			short[] FindKey() {
				if (cctor.Module.Assembly == null)
					return null;
				var pkt = cctor.Module.Assembly.PublicKeyToken;
				if (!PublicKeyBase.IsNullOrEmpty2(pkt))
					return GetPublicKeyTokenKey(pkt.Data);
				return FindKey(cctor);
			}

			short[] FindKey(MethodDef initMethod) => StringDecrypter.FindKey(initMethod, keyField);

			static short[] GetPublicKeyTokenKey(byte[] publicKeyToken) {
				var key = new short[publicKeyToken.Length];
				for (int i = 0; i < publicKeyToken.Length; i++) {
					int b = publicKeyToken[i];
					key[i] = (short)((b << 4) ^ b);
				}
				return key;
			}

			static bool FindMagic(MethodDef method, out int magic) {
				var instrs = method.Body.Instructions;
				for (int i = 0; i < instrs.Count - 2; i++) {
					var ldarg = instrs[i];
					if (ldarg.GetParameterIndex() < 0)
						continue;
					var ldci4 = instrs[i + 1];
					if (!ldci4.IsLdcI4())
						continue;
					if (instrs[i + 2].OpCode.Code != Code.Xor)
						continue;
					magic = ldci4.GetLdcI4Value();
					return true;
				}
				magic = 0;
				return false;
			}

			bool FindEncryptedStrings(MethodDef method) {
				var switchInstr = GetOnlySwitchInstruction(method);
				if (switchInstr == null)
					return false;
				var targets = (Instruction[])switchInstr.Operand;
				encryptedStrings = new string[targets.Length];
				for (int i = 0; i < targets.Length; i++) {
					var target = targets[i];
					if (target.OpCode.Code != Code.Ldstr)
						return false;
					encryptedStrings[i] = (string)target.Operand;
				}
				return true;
			}

			static Instruction GetOnlySwitchInstruction(MethodDef method) {
				Instruction switchInstr = null;
				foreach (var instr in method.Body.Instructions) {
					if (instr.OpCode.Code != Code.Switch)
						continue;
					if (switchInstr != null)
						return null;
					switchInstr = instr;
				}
				return switchInstr;
			}

			public void CleanUp() { }
			public override string ToString() => $"M:{magic:X8} N:{encryptedStrings.Length}";
		}

		public bool Detected => methodToInfo.Count != 0;
		public DecrypterVersion Version => version;

		public List<MethodDef> DecrypterMethods {
			get {
				var methods = new List<MethodDef>(methodToInfo.Count);
				foreach (var info in methodToInfo.GetValues())
					methods.Add(info.Method);
				return methods;
			}
		}

		public StringDecrypter(ModuleDefMD module) => this.module = module;

		public void Find(ISimpleDeobfuscator simpleDeobfuscator) {
			if (module.Assembly == null)
				return;

			var pkt = module.Assembly.PublicKeyToken;
			bool hasPublicKeyToken = !PublicKeyBase.IsNullOrEmpty2(pkt);
			foreach (var type in module.GetTypes()) {
				var cctor = type.FindStaticConstructor();
				if (cctor == null)
					continue;

				bool deobfuscatedCctor = false;
				bool? v13State = null, v40State = null, v41State = null;
				foreach (var method in type.Methods) {
					if (!method.IsStatic || method.Body == null)
						continue;

					IDecrypterInfo info = null;

					if (DecrypterInfo13.IsPossibleDecrypterMethod(method, ref v13State)) {
						DeobfuscateCctor(simpleDeobfuscator, cctor, ref deobfuscatedCctor, hasPublicKeyToken);
						simpleDeobfuscator.Deobfuscate(method);
						info = GetInfoV13(cctor, method);
					}
					else if (DecrypterInfo40.IsPossibleDecrypterMethod(method, ref v40State)) {
						DeobfuscateCctor(simpleDeobfuscator, cctor, ref deobfuscatedCctor, hasPublicKeyToken);
						simpleDeobfuscator.Deobfuscate(method);
						info = GetInfoV40(cctor, method);
					}
					else if (DecrypterInfo41.IsPossibleDecrypterMethod(method, ref v41State)) {
						DeobfuscateCctor(simpleDeobfuscator, cctor, ref deobfuscatedCctor, hasPublicKeyToken);
						simpleDeobfuscator.Deobfuscate(method);
						info = GetInfoV41(cctor, method);
					}

					if (info == null)
						continue;
					methodToInfo.Add(method, info);
					version = info.Version;
				}
			}
		}

		static void DeobfuscateCctor(ISimpleDeobfuscator simpleDeobfuscator, MethodDef cctor, ref bool deobfuscatedCctor, bool hasPublicKeyToken) {
			if (deobfuscatedCctor || hasPublicKeyToken)
				return;
			simpleDeobfuscator.Deobfuscate(cctor);
			deobfuscatedCctor = true;
		}

		static bool CheckFields(IEnumerable<FieldDef> fields) {
			bool foundCharAry = false, foundStringAry = false;
			foreach (var field in fields) {
				if (foundCharAry && foundStringAry)
					break;
				switch (field.FieldSig.GetFieldType().GetFullName()) {
				case "System.Char[]":
					foundCharAry = true;
					break;
				case "System.String[]":
					foundStringAry = true;
					break;
				}
			}
			return foundCharAry && foundStringAry;
		}

		DecrypterInfo13 GetInfoV13(MethodDef cctor, MethodDef method) {
			var info = new DecrypterInfo13(cctor, method);
			if (!info.Initialize())
				return null;
			return info;
		}

		DecrypterInfo40 GetInfoV40(MethodDef cctor, MethodDef method) {
			var info = new DecrypterInfo40(cctor, method);
			if (!info.Initialize())
				return null;
			return info;
		}

		DecrypterInfo41 GetInfoV41(MethodDef cctor, MethodDef method) {
			var info = new DecrypterInfo41(cctor, method);
			if (!info.Initialize())
				return null;
			return info;
		}

		public string Decrypt(IMethod method, object[] args) {
			var info = methodToInfo.Find(method);
			return info.Decrypt(args);
		}

		public void CleanUp() {
			foreach (var info in methodToInfo.GetValues())
				info.CleanUp();
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Dotfuscator/CflowDecrypter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace de4dot.code.deobfuscators.Dotfuscator {
	class CflowDecrypter {
		ModuleDefMD module;

		public CflowDecrypter(ModuleDefMD module) => this.module = module;

		public void CflowClean() {
			foreach (var type in module.GetTypes()) {
				if (!type.HasMethods)
					continue;
				foreach (var method in type.Methods) {
					CleanMethod(method);
				}
			}
		}

		public void CleanMethod(MethodDef method) {
			if (!method.HasBody)
				return;
			if (!method.Body.HasInstructions)
				return;
			if (method.Body.Instructions.Count < 4)
				return;
			if (method.Body.Variables.Count == 0)
				return;
			var instructions = method.Body.Instructions;
			GetFixIndexs(instructions, out var nopIdxs, out var ldlocIdxs);
			if (nopIdxs.Count > 0) {
				foreach (var idx in nopIdxs) {
					method.Body.Instructions[idx].OpCode = OpCodes.Nop;
					method.Body.Instructions[idx].Operand = null;
				}
			}
			if (ldlocIdxs.Count > 0) {
				foreach (var idx in ldlocIdxs) {
					method.Body.Instructions[idx].OpCode = OpCodes.Ldloc;
				}
			}
		}

		static void GetFixIndexs(IList<Instruction> instructions, out List<int> nopIdxs, out List<int> ldlocIdxs) {
			var insNoNops = new List<Instruction>();
			foreach (var ins in instructions) {
				if (ins.OpCode != OpCodes.Nop)
					insNoNops.Add(ins);
			}
			nopIdxs = new List<int>();
			ldlocIdxs = new List<int>();
			for (int i = 3; i < insNoNops.Count - 1; i++) {
				var ldind = insNoNops[i];
				if (ldind.OpCode != OpCodes.Ldind_I4 && ldind.OpCode != OpCodes.Ldind_I2)
					continue;
				var ldlocX = insNoNops[i - 1];
				if (!ldlocX.IsLdloc() && ldlocX.OpCode.Code != Code.Ldloca && ldlocX.OpCode.Code != Code.Ldloca_S)
					continue;
				var stloc = insNoNops[i - 2];
				if (!stloc.IsStloc())
					continue;
				var ldci4 = insNoNops[i - 3];
				if (!ldci4.IsLdcI4())
					continue;
				ldlocIdxs.Add(instructions.IndexOf(ldlocX));
				nopIdxs.Add(instructions.IndexOf(ldind));
				var convi2 = insNoNops[i + 1];
				if (ldind.OpCode == OpCodes.Ldind_I2 && convi2.OpCode == OpCodes.Conv_I2)
					nopIdxs.Add(instructions.IndexOf(convi2));
			}
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Dotfuscator/Deobfuscator.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Dotfuscator {
	public class DeobfuscatorInfo : DeobfuscatorInfoBase {
		public const string THE_NAME = "Dotfuscator";
		public const string THE_TYPE = "df";
		const string DEFAULT_REGEX = @"!^(?:eval_)?[a-z][a-z0-9]{0,2}$&!^A_[0-9]+$&" + DeobfuscatorBase.DEFAULT_ASIAN_VALID_NAME_REGEX;
		public DeobfuscatorInfo()
			: base(DEFAULT_REGEX) {
		}

		public override string Name => THE_NAME;
		public override string Type => THE_TYPE;

		public override IDeobfuscator CreateDeobfuscator() =>
			new Deobfuscator(new Deobfuscator.Options {
				RenameResourcesInCode = false,
				ValidNameRegex = validNameRegex.Get(),
			});
	}

	class Deobfuscator : DeobfuscatorBase {
		string obfuscatorName = "Dotfuscator";

		StringDecrypter stringDecrypter;
		bool foundDotfuscatorAttribute = false;

		internal class Options : OptionsBase {
		}

		public override string Type => DeobfuscatorInfo.THE_TYPE;
		public override string TypeLong => DeobfuscatorInfo.THE_NAME;
		public override string Name => obfuscatorName;
		public Deobfuscator(Options options) : base(options) { }

		protected override int DetectInternal() {
			int val = 0;

			if (stringDecrypter.Detected)
				val += 100;
			if (foundDotfuscatorAttribute)
				val += 10;

			return val;
		}

		protected override void ScanForObfuscator() {
			stringDecrypter = new StringDecrypter(module);
			stringDecrypter.Find(DeobfuscatedFile);
			FindDotfuscatorAttribute();
		}

		void FindDotfuscatorAttribute() {
			foreach (var type in module.Types) {
				if (type.FullName == "DotfuscatorAttribute") {
					foundDotfuscatorAttribute = true;
					AddAttributeToBeRemoved(type, "Obfuscator attribute");
					InitializeVersion(type);
					return;
				}
			}
		}

		void InitializeVersion(TypeDef attr) {
			var s = DotNetUtils.GetCustomArgAsString(GetAssemblyAttribute(attr), 0);
			if (s == null)
				return;

			var val = System.Text.RegularExpressions.Regex.Match(s, @"^(\d+(?::\d+)*\.\d+(?:\.\d+)*)$");
			if (val.Groups.Count < 2)
				return;
			obfuscatorName = "Dotfuscator " + val.Groups[1].ToString();
		}

		public override void DeobfuscateBegin() {
			base.DeobfuscateBegin();
			DoCflowClean();
			DoStringBuilderClean();
			foreach (var info in stringDecrypter.StringDecrypterInfos)
				staticStringInliner.Add(info.method, (method, gim, args) => stringDecrypter.Decrypt(method, (string)args[0], (int)args[1]));
			DeobfuscatedFile.StringDecryptersAdded();
		}

		public override void DeobfuscateEnd() {
			if (CanRemoveStringDecrypterType)
				AddMethodsToBeRemoved(stringDecrypter.StringDecrypters, "String decrypter method");

			base.DeobfuscateEnd();
		}

		public override IEnumerable<int> GetStringDecrypterMethods() {
			var list = new List<int>();
			foreach (var method in stringDecrypter.StringDecrypters)
				list.Add(method.MDToken.ToInt32());
			return list;
		}

		void DoCflowClean() {
			var cflowDescrypter = new CflowDecrypter(module);
			cflowDescrypter.CflowClean();
		}
		
		void DoStringBuilderClean() {
			var decrypter = new StringBuilderDecrypter(module);
			decrypter.StringBuilderClean();
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Dotfuscator/StringBuilderDecrypter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace de4dot.code.deobfuscators.Dotfuscator {

	/// <summary>
	///     remove stringbuilder crypter
	/// </summary>
	/// <code>
	///            int[] array2 = new int[]
	///            {
	///                -22,
	///                19,
	///                41,
	///                -36
	///            };
	///            StringBuilder stringBuilder2 = new StringBuilder();
	///            stringBuilder2.Append((char)(array2[0] + 98));
	///            stringBuilder2.Append((char)(array2[1] + 92));
	///            stringBuilder2.Append((char)(array2[2] + 56));
	///            stringBuilder2.Append((char)(array2[3] + 136));
	///            string text = stringBuilder2.ToString();
	/// </code>
	public class StringBuilderDecrypter {
		ModuleDefMD module;

		public StringBuilderDecrypter(ModuleDefMD module) => this.module = module;

		public void StringBuilderClean() {
			foreach (var type in module.GetTypes()) {
				if (!type.HasMethods)
					continue;

				foreach (var method in type.Methods) {
					CleanStringBuilder(method);

				}
			}
		}

		void CleanStringBuilder(MethodDef method) {
			if (!method.HasBody)
				return;
			if (!method.Body.HasInstructions)
				return;
			if (method.Body.Instructions.Count < 4)
				return;
			if (method.Body.Variables.Count == 0)
				return;

			var instructions = method.Body.Instructions;

			GetStringBuilderFixIndexs(instructions, out var nopIdxs, out var ldstrIdxs);

			foreach (var idx in nopIdxs) {
				method.Body.Instructions[idx].OpCode = OpCodes.Nop;
				method.Body.Instructions[idx].Operand = null;
			}

			foreach (var idx in ldstrIdxs) {
				method.Body.Instructions[idx.Key].OpCode = OpCodes.Ldstr;
				method.Body.Instructions[idx.Key].Operand = idx.Value;
			}
		}


		static void GetStringBuilderFixIndexs(IList<Instruction> instructions, out List<int> nopIdxs, out Dictionary<int, string> ldstrIdxs) {
			var insNoNops = instructions.Where(ins => ins.OpCode != OpCodes.Nop).ToList();

			nopIdxs = new List<int>();
			ldstrIdxs = new Dictionary<int, string>();

			for (var i = 1; i < insNoNops.Count; i++) {
				if (insNoNops[i - 1].IsLdcI4() &&
					insNoNops[i].OpCode == OpCodes.Newarr &&
					insNoNops[i].Operand is TypeRef typeRef &&
					typeRef.FullName == typeof(Int32).FullName) {
					int[] data = null;
					int index = 0;
					var arrLength = insNoNops[i - 1].GetLdcI4Value();
					if (arrLength == 1) {
						if (i + 6 < insNoNops.Count &&
							insNoNops[i + 6].OpCode == OpCodes.Newobj &&
							insNoNops[i + 6].Operand is MemberRef memberRef &&
							memberRef.GetDeclaringTypeFullName() == typeof(StringBuilder).FullName &&
							memberRef.Name == ".ctor" &&
							insNoNops[i + 3].IsLdcI4()) {
							data = new int[arrLength];
							data[0] = insNoNops[i + 3].GetLdcI4Value();

							index = TryGetStringBuilderAppendData(insNoNops, i + 7, data);
						}
					}
					else if (arrLength == 2) {
						if (i + 10 < insNoNops.Count &&
							insNoNops[i + 10].OpCode == OpCodes.Newobj &&
							insNoNops[i + 10].Operand is MemberRef memberRef &&
							memberRef.GetDeclaringTypeFullName() == typeof(StringBuilder).FullName &&
							memberRef.Name == ".ctor" &&
							insNoNops[i + 3].IsLdcI4() &&
							insNoNops[i + 7].IsLdcI4()) {
							data = new int[arrLength];
							data[0] = insNoNops[i + 3].GetLdcI4Value();
							data[1] = insNoNops[i + 7].GetLdcI4Value();

							index = TryGetStringBuilderAppendData(insNoNops, i + 11, data);
						}
					}
					else {
						if (i + 5 < insNoNops.Count &&
							insNoNops[i + 2].OpCode == OpCodes.Ldtoken &&
							insNoNops[i + 2].Operand is FieldDef fieldDef &&
							fieldDef.InitialValue != null &&
							fieldDef.InitialValue.Length / 4 == arrLength &&
							insNoNops[i + 5].OpCode == OpCodes.Newobj &&
							insNoNops[i + 5].Operand is MemberRef memberRef &&
							memberRef.GetDeclaringTypeFullName() == typeof(StringBuilder).FullName &&
							memberRef.Name == ".ctor") {
							data = new int[arrLength];
							for (var j = 0; j < arrLength; j++) {
								data[j] = BitConverter.ToInt32(fieldDef.InitialValue, j * 4);
							}

							index = TryGetStringBuilderAppendData(insNoNops, i + 6, data);
						}
					}

					if (index != 0 && data != null) {
						var array = new char[data.Length];

						for (int j = 0; j < data.Length; j++) {
							array[j] = (char)data[j];
						}

						for (var j = i - 1; j < index; j++) {
							nopIdxs.Add(instructions.IndexOf(insNoNops[j]));
						}

						ldstrIdxs.Add(instructions.IndexOf(insNoNops[index]), new string(array));

						i = index;
					}
				}
			}
		}

		static int TryGetStringBuilderAppendData(IList<Instruction> instructions, int index, int[] data) {
			var length = data.Length;

			if (index + length * 9 + 3 < instructions.Count &&
				instructions[index + 9 * length + 2].OpCode == OpCodes.Callvirt &&
				(instructions[index + 9 * length + 2].Operand as MemberRef)?.Name == "ToString") {
				if (instructions[index + 9 * length + 3].IsStloc() ||
					instructions[index + 9 * length + 3].OpCode == OpCodes.Pop) {
					for (var j = 0; j < length; j++) {
						var insNoNop = instructions[index + j * 9 + 5];
						if (insNoNop.IsLdcI4()) {
							data[j] += insNoNop.GetLdcI4Value();
						}
						else {
							return 0;
						}
					}

					return index + 9 * length + 2;
				}
			}

			return 0;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Dotfuscator/StringDecrypter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Dotfuscator {
	class StringDecrypter {
		ModuleDefMD module;
		MethodDefAndDeclaringTypeDict<StringDecrypterInfo> stringDecrypterMethods = new MethodDefAndDeclaringTypeDict<StringDecrypterInfo>();

		public class StringDecrypterInfo {
			public MethodDef method;
			public int magic;
			public StringDecrypterInfo(MethodDef method, int magic) {
				this.method = method;
				this.magic = magic;
			}
		}

		public bool Detected => stringDecrypterMethods.Count > 0;

		public IEnumerable<MethodDef> StringDecrypters {
			get {
				var list = new List<MethodDef>(stringDecrypterMethods.Count);
				foreach (var info in stringDecrypterMethods.GetValues())
					list.Add(info.method);
				return list;
			}
		}

		public IEnumerable<StringDecrypterInfo> StringDecrypterInfos => stringDecrypterMethods.GetValues();
		public StringDecrypter(ModuleDefMD module) => this.module = module;

		public void Find(ISimpleDeobfuscator simpleDeobfuscator) {
			foreach (var type in module.GetTypes())
				FindStringDecrypterMethods(type, simpleDeobfuscator);
		}

		void FindStringDecrypterMethods(TypeDef type, ISimpleDeobfuscator simpleDeobfuscator) {
			foreach (var method in DotNetUtils.FindMethods(type.Methods, "System.String", new string[] { "System.String", "System.Int32" })) {
				if (method.Body.HasExceptionHandlers)
					continue;

				if (DotNetUtils.GetMethodCalls(method, "System.Char[] System.String::ToCharArray()") != 1)
					continue;
				if (DotNetUtils.GetMethodCalls(method, "System.String System.String::Intern(System.String)") != 1)
					continue;

				simpleDeobfuscator.Deobfuscate(method);
				var instrs = method.Body.Instructions;
				for (int i = 0; i < instrs.Count - 6; i++) {
					var ldarg = instrs[i];
					if (!ldarg.IsLdarg() || ldarg.GetParameterIndex() != 0)
						continue;
					var callvirt = instrs[i + 1];
					if (callvirt.OpCode.Code != Code.Callvirt)
						continue;
					var calledMethod = callvirt.Operand as MemberRef;
					if (calledMethod == null || calledMethod.FullName != "System.Char[] System.String::ToCharArray()")
						continue;
					var stloc = instrs[i + 2];
					if (!stloc.IsStloc())
						continue;
					var ldci4 = instrs[i + 3];
					if (!ldci4.IsLdcI4())
						continue;
					var ldarg2 = instrs[i + 4];
					if (!ldarg2.IsLdarg() || ldarg2.GetParameterIndex() != 1)
						continue;
					var opAdd1 = instrs[i + 5];
					if (opAdd1.OpCode != OpCodes.Add)
						continue;

					int magicAdd = 0;
					int j = i + 6;
					while (j < instrs.Count - 1 && !instrs[j].IsStloc()) {
						var ldcOp = instrs[j];
						var addOp = instrs[j + 1];
						if (ldcOp.IsLdcI4() && addOp.OpCode == OpCodes.Add) {
							magicAdd = magicAdd + ldcOp.GetLdcI4Value();
							j = j + 2;
						}
						else
							j++;
					}

					var info = new StringDecrypterInfo(method, ldci4.GetLdcI4Value() + magicAdd);
					stringDecrypterMethods.Add(info.method, info);
					Logger.v("Found string decrypter method: {0}, magic: 0x{1:X8}", Utils.RemoveNewlines(info.method), info.magic);
					break;
				}
			}
		}

		public string Decrypt(IMethod method, string encrypted, int value) {
			var info = stringDecrypterMethods.FindAny(method);
			char[] chars = encrypted.ToCharArray();
			byte key = (byte)(info.magic + value);
			for (int i = 0; i < chars.Length; i++) {
				char c = chars[i];
				byte b1 = (byte)((byte)c ^ key++);
				byte b2 = (byte)((byte)(c >> 8) ^ key++);
				chars[i] = (char)((b1 << 8) | b2);
			}
			return new string(chars);
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Eazfuscator_NET/AssemblyResolver.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Eazfuscator_NET {
	class AssemblyResolver {
		ModuleDefMD module;
		DecrypterType decrypterType;
		TypeDef resolverType;
		MethodDef initMethod;
		MethodDef handlerMethod;
		MethodDef decryptMethod;
		TypeDef otherType;
		List<AssemblyInfo> assemblyInfos = new List<AssemblyInfo>();
		FrameworkType frameworkType;
		byte[] decryptKey;
		CodeCompilerMethodCallRestorer codeCompilerMethodCallRestorer;

		public class AssemblyInfo {
			public bool IsEncrypted { get; set; }
			public bool IsCompressed { get; set; }
			public string ResourceName { get; set; }
			public string Filename { get; set; }
			public string AssemblyFullName { get; set; }
			public string SimpleName { get; set; }
			public string Extension { get; set; }
			public EmbeddedResource Resource { get; set; }
			public byte[] Data { get; set; }
			public override string ToString() => AssemblyFullName ?? Filename;
		}

		public TypeDef Type => resolverType;
		public TypeDef OtherType => otherType;
		public MethodDef InitMethod => initMethod;
		public IEnumerable<AssemblyInfo> AssemblyInfos => assemblyInfos;
		public bool Detected => resolverType != null;

		public AssemblyResolver(ModuleDefMD module, DecrypterType decrypterType) {
			this.module = module;
			frameworkType = DotNetUtils.GetFrameworkType(module);
			this.decrypterType = decrypterType;
			codeCompilerMethodCallRestorer = new CodeCompilerMethodCallRestorer(module);
		}

		public void Find() => CheckCalledMethods(DotNetUtils.GetModuleTypeCctor(module));

		bool CheckCalledMethods(MethodDef method) {
			if (method == null || method.Body == null)
				return false;

			foreach (var instr in method.Body.Instructions) {
				if (instr.OpCode.Code != Code.Call)
					continue;

				var calledMethod = instr.Operand as MethodDef;
				if (calledMethod == null || !calledMethod.IsStatic || calledMethod.Body == null)
					continue;
				if (!DotNetUtils.IsMethod(calledMethod, "System.Void", "()"))
					continue;

				if (frameworkType == FrameworkType.Silverlight) {
					if (!CheckInitMethodSilverlight(calledMethod))
						continue;
				}
				else {
					if (!CheckInitMethod(calledMethod))
						continue;
				}

				decryptMethod = GetDecryptMethod();
				UpdateDecrypterType();
				FindCodeDomMethods();
				return true;
			}

			return false;
		}

		bool CheckInitMethodSilverlight(MethodDef method) {
			var type = method.DeclaringType;
			if (type.NestedTypes.Count != 2)
				return false;

			var resolveHandler = GetResolveMethodSilverlight(method);
			if (resolveHandler == null)
				return false;

			initMethod = method;
			resolverType = type;
			handlerMethod = resolveHandler;
			return true;
		}

		static MethodDef GetResolveMethodSilverlight(MethodDef initMethod) {
			foreach (var instr in initMethod.Body.Instructions) {
				if (instr.OpCode.Code != Code.Call)
					continue;
				var calledMethod = instr.Operand as MethodDef;
				if (calledMethod == null)
					continue;
				if (!DotNetUtils.IsMethod(calledMethod, "System.Void", "()"))
					continue;
				if (!DeobUtils.HasInteger(calledMethod, ',') ||
					!DeobUtils.HasInteger(calledMethod, '|'))
					continue;

				return calledMethod;
			}

			return null;
		}

		bool CheckInitMethod(MethodDef method) {
			var type = method.DeclaringType;
			if (type.NestedTypes.Count < 2 || type.NestedTypes.Count > 6)
				return false;
			if (DotNetUtils.GetPInvokeMethod(type, "kernel32", "MoveFileEx") == null)
				return false;

			var resolveHandler = DeobUtils.GetResolveMethod(method);
			if (resolveHandler == null)
				return false;
			if (!DeobUtils.HasInteger(resolveHandler, ',') ||
				!DeobUtils.HasInteger(resolveHandler, '|'))
				return false;

			initMethod = method;
			resolverType = type;
			handlerMethod = resolveHandler;
			return true;
		}

		MethodDef GetDecryptMethod() {
			foreach (var method in resolverType.Methods) {
				if (!method.IsStatic || method.Body == null)
					continue;
				if (!DotNetUtils.IsMethod(method, "System.Byte[]", "(System.Byte[])"))
					continue;
				if (!DeobUtils.HasInteger(method, 32) ||
					!DeobUtils.HasInteger(method, 121))
					continue;

				return method;
			}

			return null;
		}

		void UpdateDecrypterType() {
			var theDecrypterType = GetDecrypterType(decryptMethod);
			if (theDecrypterType == null)
				return;
			decrypterType.Type = theDecrypterType;
			if (!decrypterType.Initialize())
				throw new ApplicationException("Could not initialize decrypterType");
		}

		TypeDef GetDecrypterType(MethodDef method) {
			if (method == null || method.Body == null)
				return null;

			foreach (var instr in method.Body.Instructions) {
				if (instr.OpCode.Code != Code.Call)
					continue;
				var calledMethod = instr.Operand as MethodDef;
				if (calledMethod == null || !calledMethod.IsStatic || calledMethod.DeclaringType == resolverType)
					continue;
				if (!DotNetUtils.IsMethod(calledMethod, "System.Void", "(System.Byte[])"))
					continue;

				return calledMethod.DeclaringType;
			}

			return null;
		}

		public void Initialize(ISimpleDeobfuscator simpleDeobfuscator, IDeobfuscator deob) {
			if (handlerMethod == null)
				return;

			FindOtherType();

			simpleDeobfuscator.Deobfuscate(handlerMethod);
			simpleDeobfuscator.DecryptStrings(handlerMethod, deob);
			if (!CreateAssemblyInfos())
				throw new ApplicationException("Could not initialize assembly infos");

			if (decryptMethod != null) {
				simpleDeobfuscator.Deobfuscate(decryptMethod);
				simpleDeobfuscator.DecryptStrings(decryptMethod, deob);
				if (!CreateDecryptKey())
					throw new ApplicationException("Could not initialize decryption key");
			}
		}

		void FindOtherType() {
			foreach (var type in module.Types) {
				// This type is added by EF 3.1+. The last number seems to be an int32 hash of
				// the assembly name, but - replaced with _.
				if (!Regex.IsMatch(type.FullName, @"^pc1eOx2WJVV[_0-9]+$"))
					continue;

				otherType = type;
				break;
			}
		}

		bool CreateDecryptKey() {
			if (decryptMethod == null)
				return false;

			foreach (var s in DotNetUtils.GetCodeStrings(decryptMethod)) {
				decryptKey = DecodeBase64(s);
				if (decryptKey == null || decryptKey.Length == 0)
					continue;

				if (decrypterType.Detected) {
					var data = new byte[8];
					ulong magic = decrypterType.GetMagic();
					data[0] = (byte)magic;
					data[7] = (byte)(magic >> 8);
					data[6] = (byte)(magic >> 16);
					data[5] = (byte)(magic >> 24);
					data[4] = (byte)(magic >> 32);
					data[1] = (byte)(magic >> 40);
					data[3] = (byte)(magic >> 48);
					data[2] = (byte)(magic >> 56);

					for (int i = 0; i < decryptKey.Length; i++)
						decryptKey[i] ^= (byte)(i + data[i % data.Length]);
				}

				return true;
			}

			decryptKey = null;
			return false;
		}

		static byte[] DecodeBase64(string s) {
			try {
				return Convert.FromBase64String(s);
			}
			catch (FormatException) {
				return null;
			}
		}

		bool CreateAssemblyInfos() {
			int numElements = DeobUtils.HasInteger(handlerMethod, 3) ? 3 : 2;
			foreach (var s in DotNetUtils.GetCodeStrings(handlerMethod)) {
				var infos = CreateAssemblyInfos(s, numElements);
				if (infos == null)
					continue;

				assemblyInfos = infos;
				return true;
			}

			return false;
		}

		List<AssemblyInfo> CreateAssemblyInfos(string s, int numElements) {
			try {
				return TryCreateAssemblyInfos(s, numElements);
			}
			catch (FormatException) {
				return null;	// Convert.FromBase64String() failed
			}
		}

		List<AssemblyInfo> TryCreateAssemblyInfos(string s, int numElements) {
			var ary = s.Split(',');
			if (ary.Length == 0 || ary.Length % numElements != 0)
				return null;

			var infos = new List<AssemblyInfo>();
			for (int i = 0; i < ary.Length; i += numElements) {
				var info = new AssemblyInfo();

				info.AssemblyFullName = Encoding.UTF8.GetString(Convert.FromBase64String(ary[i]));
				info.ResourceName = ary[i + 1];
				if (numElements >= 3)
					info.Filename = Encoding.UTF8.GetString(Convert.FromBase64String(ary[i + 2]));
				else
					info.Filename = Utils.GetAssemblySimpleName(info.AssemblyFullName) + ".dll";
				int index = info.ResourceName.IndexOf('|');
				if (index >= 0) {
					var flags = info.ResourceName.Substring(0, index);
					info.ResourceName = info.ResourceName.Substring(index + 1);
					info.IsEncrypted = flags.IndexOf('a') >= 0;
					info.IsCompressed = flags.IndexOf('b') >= 0;
				}

				infos.Add(info);
			}

			return infos;
		}

		public void InitializeEmbeddedFiles() {
			foreach (var info in assemblyInfos) {
				info.Resource = DotNetUtils.GetResource(module, info.ResourceName) as EmbeddedResource;
				if (info.Resource == null)
					throw new ApplicationException($"Could not find resource {Utils.ToCsharpString(info.ResourceName)}");

				info.Data = info.Resource.CreateReader().ToArray();
				if (info.IsEncrypted)
					Decrypt(info.Data);
				if (info.IsCompressed)
					info.Data = Decompress(info.Data);

				InitializeNameAndExtension(info);
			}
		}

		static void InitializeNameAndExtension(AssemblyInfo info) {
			try {
				var mod = ModuleDefMD.Load(info.Data);
				info.AssemblyFullName = mod.Assembly.FullName;
				info.SimpleName = mod.Assembly.Name.String;
				info.Extension = DeobUtils.GetExtension(mod.Kind);
				return;
			}
			catch {
			}
			Logger.w("Could not load assembly from decrypted resource {0}", Utils.ToCsharpString(info.ResourceName));
			int index = info.Filename.LastIndexOf('.');
			if (index < 0) {
				info.SimpleName = info.Filename;
				info.Extension = "";
			}
			else {
				info.SimpleName = info.Filename.Substring(0, index);
				info.Extension = info.Filename.Substring(index);
			}
		}

		static readonly byte[] key2 = new byte[] { 148, 68, 208, 52 };
		void Decrypt(byte[] encryptedData) {
			var indexes = new byte[256];
			for (int i = 0; i < indexes.Length; i++)
				indexes[i] = (byte)i;
			byte i1 = 0, i2 = 0;
			for (int i = 0; i < indexes.Length; i++) {
				i2 += (byte)(decryptKey[i % decryptKey.Length] + indexes[i]);
				Swap(indexes, i, i2);
			}

			byte val = 0;
			for (int i = 0; i < encryptedData.Length; i++) {
				if ((i & 0x1F) == 0) {
					i2 += indexes[++i1];
					Swap(indexes, i1, i2);
					val = indexes[(byte)(indexes[i1] + indexes[i2])];
				}
				encryptedData[i] ^= (byte)(val ^ key2[(i >> 2) & 3] ^ key2[(i + 1) & 3]);
			}
		}

		static void Swap(byte[] data, int i, int j) {
			byte tmp = data[i];
			data[i] = data[j];
			data[j] = tmp;
		}

		byte[] Decompress(byte[] compressedData) {
			// First dword is sig: 0x9B728BC7
			// Second dword is decompressed length
			return DeobUtils.Inflate(compressedData, 8, compressedData.Length - 8, true);
		}

		public AssemblyInfo Get(string asmFullName) {
			var simpleName = Utils.GetAssemblySimpleName(asmFullName);
			for (int i = 0; i < assemblyInfos.Count; i++) {
				var info = assemblyInfos[i];
				if (info.SimpleName != simpleName)
					continue;

				assemblyInfos.RemoveAt(i);
				return info;
			}

			return null;
		}

		public void Deobfuscate(Blocks blocks) => codeCompilerMethodCallRestorer.Deobfuscate(blocks);

		void FindCodeDomMethods() {
			if (resolverType == null)
				return;

			foreach (var nestedType in resolverType.NestedTypes) {
				if (nestedType.Fields.Count != 0)
					continue;

				var CompileAssemblyFromDom1         = GetTheOnlyMethod(nestedType, "System.CodeDom.Compiler.CodeDomProvider", "CompileAssemblyFromDom", "System.CodeDom.Compiler.CompilerResults", "System.CodeDom.Compiler.CompilerParameters,System.CodeDom.CodeCompileUnit[]");
				var CompileAssemblyFromFile1        = GetTheOnlyMethod(nestedType, "System.CodeDom.Compiler.CodeDomProvider", "CompileAssemblyFromFile", "System.CodeDom.Compiler.CompilerResults", "System.CodeDom.Compiler.CompilerParameters,System.String[]");
				var CompileAssemblyFromSource1      = GetTheOnlyMethod(nestedType, "System.CodeDom.Compiler.CodeDomProvider", "CompileAssemblyFromSource", "System.CodeDom.Compiler.CompilerResults", "System.CodeDom.Compiler.CompilerParameters,System.String[]");
				var CompileAssemblyFromDom2         = GetTheOnlyMethod(nestedType, "System.CodeDom.Compiler.ICodeCompiler", "CompileAssemblyFromDom", "System.CodeDom.Compiler.CompilerResults", "System.CodeDom.Compiler.CompilerParameters,System.CodeDom.CodeCompileUnit");
				var CompileAssemblyFromDomBatch2    = GetTheOnlyMethod(nestedType, "System.CodeDom.Compiler.ICodeCompiler", "CompileAssemblyFromDomBatch", "System.CodeDom.Compiler.CompilerResults", "System.CodeDom.Compiler.CompilerParameters,System.CodeDom.CodeCompileUnit[]");
				var CompileAssemblyFromFile2        = GetTheOnlyMethod(nestedType, "System.CodeDom.Compiler.ICodeCompiler", "CompileAssemblyFromFile", "System.CodeDom.Compiler.CompilerResults", "System.CodeDom.Compiler.CompilerParameters,System.String");
				var CompileAssemblyFromFileBatch2   = GetTheOnlyMethod(nestedType, "System.CodeDom.Compiler.ICodeCompiler", "CompileAssemblyFromFileBatch", "System.CodeDom.Compiler.CompilerResults", "System.CodeDom.Compiler.CompilerParameters,System.String[]");
				var CompileAssemblyFromSource2      = GetTheOnlyMethod(nestedType, "System.CodeDom.Compiler.ICodeCompiler", "CompileAssemblyFromSource", "System.CodeDom.Compiler.CompilerResults", "System.CodeDom.Compiler.CompilerParameters,System.String");
				var CompileAssemblyFromSourceBatch2 = GetTheOnlyMethod(nestedType, "System.CodeDom.Compiler.ICodeCompiler", "CompileAssemblyFromSourceBatch", "System.CodeDom.Compiler.CompilerResults", "System.CodeDom.Compiler.CompilerParameters,System.String[]");

				if (CompileAssemblyFromDom1 == null && CompileAssemblyFromFile1 == null &&
					CompileAssemblyFromSource1 == null && CompileAssemblyFromDom2 == null &&
					CompileAssemblyFromDomBatch2 == null && CompileAssemblyFromFile2 == null &&
					CompileAssemblyFromFileBatch2 == null && CompileAssemblyFromSource2 == null &&
					CompileAssemblyFromSourceBatch2 == null) {
					continue;
				}

				codeCompilerMethodCallRestorer.Add_CodeDomProvider_CompileAssemblyFromDom(CompileAssemblyFromDom1);
				codeCompilerMethodCallRestorer.Add_CodeDomProvider_CompileAssemblyFromFile(CompileAssemblyFromFile1);
				codeCompilerMethodCallRestorer.Add_CodeDomProvider_CompileAssemblyFromSource(CompileAssemblyFromSource1);
				codeCompilerMethodCallRestorer.Add_ICodeCompiler_CompileAssemblyFromDom(CompileAssemblyFromDom2);
				codeCompilerMethodCallRestorer.Add_ICodeCompiler_CompileAssemblyFromDomBatch(CompileAssemblyFromDomBatch2);
				codeCompilerMethodCallRestorer.Add_ICodeCompiler_CompileAssemblyFromFile(CompileAssemblyFromFile2);
				codeCompilerMethodCallRestorer.Add_ICodeCompiler_CompileAssemblyFromFileBatch(CompileAssemblyFromFileBatch2);
				codeCompilerMethodCallRestorer.Add_ICodeCompiler_CompileAssemblyFromSource(CompileAssemblyFromSource2);
				codeCompilerMethodCallRestorer.Add_ICodeCompiler_CompileAssemblyFromSourceBatch(CompileAssemblyFromSourceBatch2);
				break;
			}
		}

		static MethodDef GetTheOnlyMethod(TypeDef type, string typeName, string methodName, string returnType, string parameters) {
			MethodDef foundMethod = null;

			foreach (var method in type.Methods) {
				if (!method.IsStatic || method.Body == null || method.HasGenericParameters)
					continue;
				if (method.IsPrivate)
					continue;
				if (!DotNetUtils.IsMethod(method, returnType, "(" + typeName + "," + parameters + ")"))
					continue;
				if (!DotNetUtils.CallsMethod(method, returnType + " " + typeName + "::" + methodName + "(" + parameters + ")"))
					continue;

				if (foundMethod != null)
					return null;
				foundMethod = method;
			}

			return foundMethod;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Eazfuscator_NET/CodeCompilerMethodCallRestorer.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using dnlib.DotNet;

namespace de4dot.code.deobfuscators.Eazfuscator_NET {
	class CodeCompilerMethodCallRestorer : MethodCallRestorerBase {
		ITypeDefOrRef CodeDomProvider => builder.Type("System.CodeDom.Compiler", "CodeDomProvider", "System").ToTypeDefOrRef();
		ITypeDefOrRef ICodeCompiler => builder.Type("System.CodeDom.Compiler", "ICodeCompiler", "System").ToTypeDefOrRef();
		TypeSig CompilerResults => builder.Type("System.CodeDom.Compiler", "CompilerResults", "System");
		TypeSig CompilerParameters => builder.Type("System.CodeDom.Compiler", "CompilerParameters", "System");
		TypeSig CodeCompileUnit => builder.Type("System.CodeDom", "CodeCompileUnit", "System");
		TypeSig CodeCompileUnitArray => builder.Array(CodeCompileUnit);
		TypeSig StringArray => builder.Array(builder.String);

		public CodeCompilerMethodCallRestorer(ModuleDefMD module) : base(module) { }

		public void Add_CodeDomProvider_CompileAssemblyFromDom(MethodDef oldMethod) {
			if (oldMethod == null)
				return;
			Add(oldMethod, builder.InstanceMethod("CompileAssemblyFromDom", CodeDomProvider, CompilerResults, CompilerParameters, CodeCompileUnitArray));
		}

		public void Add_CodeDomProvider_CompileAssemblyFromFile(MethodDef oldMethod) {
			if (oldMethod == null)
				return;
			Add(oldMethod, builder.InstanceMethod("CompileAssemblyFromFile", CodeDomProvider, CompilerResults, CompilerParameters, StringArray));
		}

		public void Add_CodeDomProvider_CompileAssemblyFromSource(MethodDef oldMethod) {
			if (oldMethod == null)
				return;
			Add(oldMethod, builder.InstanceMethod("CompileAssemblyFromSource", CodeDomProvider, CompilerResults, CompilerParameters, StringArray));
		}

		public void Add_ICodeCompiler_CompileAssemblyFromDom(MethodDef oldMethod) {
			if (oldMethod == null)
				return;
			Add(oldMethod, builder.InstanceMethod("CompileAssemblyFromDom", ICodeCompiler, CompilerResults, CompilerParameters, CodeCompileUnit));
		}

		public void Add_ICodeCompiler_CompileAssemblyFromDomBatch(MethodDef oldMethod) {
			if (oldMethod == null)
				return;
			Add(oldMethod, builder.InstanceMethod("CompileAssemblyFromDomBatch", ICodeCompiler, CompilerResults, CompilerParameters, CodeCompileUnitArray));
		}

		public void Add_ICodeCompiler_CompileAssemblyFromFile(MethodDef oldMethod) {
			if (oldMethod == null)
				return;
			Add(oldMethod, builder.InstanceMethod("CompileAssemblyFromFile", ICodeCompiler, CompilerResults, CompilerParameters, builder.String));
		}

		public void Add_ICodeCompiler_CompileAssemblyFromFileBatch(MethodDef oldMethod) {
			if (oldMethod == null)
				return;
			Add(oldMethod, builder.InstanceMethod("CompileAssemblyFromFileBatch", ICodeCompiler, CompilerResults, CompilerParameters, StringArray));
		}

		public void Add_ICodeCompiler_CompileAssemblyFromSource(MethodDef oldMethod) {
			if (oldMethod == null)
				return;
			Add(oldMethod, builder.InstanceMethod("CompileAssemblyFromSource", ICodeCompiler, CompilerResults, CompilerParameters, builder.String));
		}

		public void Add_ICodeCompiler_CompileAssemblyFromSourceBatch(MethodDef oldMethod) {
			if (oldMethod == null)
				return;
			Add(oldMethod, builder.InstanceMethod("CompileAssemblyFromSourceBatch", ICodeCompiler, CompilerResults, CompilerParameters, StringArray));
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Eazfuscator_NET/DecrypterType.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Text;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Eazfuscator_NET {
	class DecrypterType {
		ModuleDefMD module;
		ISimpleDeobfuscator simpleDeobfuscator;
		TypeDef type;
		MethodDef int64Method;
		bool initialized;
		ulong l1;
		int i1, i2, i3;
		int m1_i1, m2_i1, m2_i2, m3_i1;
		MethodDef[] efConstMethods;
		List<int> shiftConsts;

		public MethodDef Int64Method => int64Method;

		public TypeDef Type {
			get => type;
			set {
				if (type == null)
					type = value;
				else if (type != value)
					throw new ApplicationException("Found another one");
			}
		}

		public bool Detected => type != null;

		public List<int> ShiftConsts {
			get => shiftConsts;
			set {
				if (shiftConsts == null)
					shiftConsts = value;
				else if (shiftConsts != value)
					throw new ApplicationException("Found another one");
			}
		}

		public DecrypterType(ModuleDefMD module, ISimpleDeobfuscator simpleDeobfuscator) {
			this.module = module;
			this.simpleDeobfuscator = simpleDeobfuscator;
		}

		public bool Initialize() {
			if (initialized)
				return true;

			int64Method = FindInt64Method();
			if (int64Method == null)
				return false;

			if (!InitializeEfConstMethods())
				return false;
			if (!FindInt1And2())
				return false;
			if (!FindInt3())
				return false;
			if (!FindMethodInts())
				return false;

			initialized = true;
			return true;
		}

		bool InitializeEfConstMethods() {
			if (type == null)
				return false;

			efConstMethods = new MethodDef[6];

			efConstMethods[0] = FindEfConstMethodCall(int64Method);
			efConstMethods[5] = FindEfConstMethodCall(efConstMethods[0]);
			efConstMethods[4] = FindEfConstMethodCall(efConstMethods[5]);
			var calls = FindEfConstMethodCalls(efConstMethods[4]);
			if (calls.Count != 2)
				return false;
			if (GetNumberOfTypeofs(calls[0]) == 3) {
				efConstMethods[2] = calls[0];
				efConstMethods[1] = calls[1];
			}
			else {
				efConstMethods[2] = calls[0];
				efConstMethods[1] = calls[1];
			}
			efConstMethods[3] = FindEfConstMethodCall(efConstMethods[1]);

			foreach (var m in efConstMethods) {
				if (m == null)
					return false;
			}
			return true;
		}

		static int GetNumberOfTypeofs(MethodDef method) {
			if (method == null)
				return 0;
			int count = 0;
			foreach (var instr in method.Body.Instructions) {
				if (instr.OpCode.Code == Code.Ldtoken)
					count++;
			}
			return count;
		}

		MethodDef FindEfConstMethodCall(MethodDef method) {
			var list = FindEfConstMethodCalls(method);
			if (list == null || list.Count != 1)
				return null;
			return list[0];
		}

		List<MethodDef> FindEfConstMethodCalls(MethodDef method) {
			if (method == null)
				return null;
			var list = new List<MethodDef>();
			foreach (var instr in method.Body.Instructions) {
				if (instr.OpCode.Code != Code.Call)
					continue;
				var calledMethod = instr.Operand as MethodDef;
				if (calledMethod == null || !calledMethod.IsStatic || calledMethod.Body == null)
					continue;
				if (!DotNetUtils.IsMethod(calledMethod, "System.Int32", "()"))
					continue;
				if (type.NestedTypes.IndexOf(calledMethod.DeclaringType) < 0)
					continue;

				list.Add(calledMethod);
			}
			return list;
		}

		MethodDef FindInt64Method() {
			if (type == null)
				return null;
			foreach (var method in type.Methods) {
				if (!method.IsStatic || method.Body == null || method.HasGenericParameters)
					continue;
				if (!DotNetUtils.IsMethod(method, "System.Int64", "()"))
					continue;
				if (!FindInt64(method))
					continue;

				return method;
			}

			return null;
		}

		bool FindInt64(MethodDef method) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 1; i++) {
				var ldci8 = instrs[i];
				if (ldci8.OpCode.Code != Code.Ldc_I8)
					continue;

				if (instrs[i + 1].OpCode.Code != Code.Xor)
					continue;

				l1 = (ulong)(long)ldci8.Operand;
				return true;
			}
			return false;
		}

		bool FindInt1And2() {
			var consts = GetConstants(efConstMethods[2]);
			if (consts.Count != 2)
				return false;
			i1 = consts[0];
			i2 = consts[1];
			return true;
		}

		bool FindInt3() {
			var consts = GetConstants(efConstMethods[5]);
			if (consts.Count != 1)
				return false;
			i3 = consts[0];
			return true;
		}

		bool FindMethodInts() {
			foreach (var nestedType in type.NestedTypes) {
				var methods = GetBinaryIntMethods(nestedType);
				if (methods.Count < 3)
					continue;
				foreach (var m in methods)
					simpleDeobfuscator.Deobfuscate(m);
				if (!FindMethod1Int(methods))
					continue;
				if (!FindMethod2Int(methods))
					continue;
				if (!FindMethod3Int(methods))
					continue;

				return true;
			}
			return false;
		}

		
		static List<MethodDef> GetBinaryIntMethods(TypeDef type) {
			var list = new List<MethodDef>();
			foreach (var method in type.Methods) {
				if (!method.IsStatic || method.Body == null)
					continue;
				if (!DotNetUtils.IsMethod(method, "System.Int32", "(System.Int32,System.Int32)"))
					continue;

				list.Add(method);
			}
			return list;
		}

		bool FindMethod1Int(IEnumerable<MethodDef> methods) {
			foreach (var method in methods) {
				if (CountInstructions(method, Code.Ldarg_0) != 1)
					continue;
				var constants = GetConstants(method);
				if (constants.Count != 1)
					continue;

				m1_i1 = constants[0];
				return true;
			}
			return false;
		}

		bool FindMethod2Int(IEnumerable<MethodDef> methods) {
			foreach (var method in methods) {
				var constants = GetConstants(method);
				if (constants.Count != 2)
					continue;

				m2_i1 = constants[0];
				m2_i2 = constants[1];
				return true;
			}
			return false;
		}

		bool FindMethod3Int(IEnumerable<MethodDef> methods) {
			foreach (var method in methods) {
				if (CountInstructions(method, Code.Ldarg_0) != 2)
					continue;
				var constants = GetConstants(method);
				if (constants.Count != 1)
					continue;

				m3_i1 = constants[0];
				return true;
			}
			return false;
		}

		static int CountInstructions(MethodDef method, Code code) {
			int count = 0;
			foreach (var instr in method.Body.Instructions) {
				if (instr.OpCode.Code == code)
					count++;
			}
			return count;
		}

		static List<int> GetConstants(MethodDef method) {
			var list = new List<int>();

			if (method == null)
				return list;

			int index = 0;
			var instrs = method.Body.Instructions;
			var constantsReader = new EfConstantsReader(method);
			while (true) {
				if (!constantsReader.GetNextInt32(ref index, out int val))
					break;

				if (index < instrs.Count && instrs[index].OpCode.Code != Code.Ret)
					list.Add(val);
			}

			return list;
		}

		int BinOp1(int a, int b) => a ^ (b - m1_i1);
		int BinOp2(int a, int b) => (a - m2_i1) ^ (b + m2_i2);
		int BinOp3(int a, int b) => a ^ (b - m3_i1) ^ (a - b);

		int ConstMethod1() =>
			BinOp3(BinOp2(efConstMethods[1].DeclaringType.MDToken.ToInt32(), BinOp3(efConstMethods[0].DeclaringType.MDToken.ToInt32(), efConstMethods[4].DeclaringType.MDToken.ToInt32())), ConstMethod6());

		int ConstMethod2() =>
			BinOp1(efConstMethods[2].DeclaringType.MDToken.ToInt32(), efConstMethods[3].DeclaringType.MDToken.ToInt32() ^ BinOp2(efConstMethods[1].DeclaringType.MDToken.ToInt32(), BinOp3(efConstMethods[5].DeclaringType.MDToken.ToInt32(), ConstMethod4())));

		int ConstMethod3() =>
			BinOp3(BinOp1(ConstMethod2() ^ i1, efConstMethods[3].DeclaringType.MDToken.ToInt32()), BinOp2(efConstMethods[0].DeclaringType.MDToken.ToInt32() ^ efConstMethods[5].DeclaringType.MDToken.ToInt32(), i2));

		int ConstMethod4() =>
			BinOp3(efConstMethods[3].DeclaringType.MDToken.ToInt32(), BinOp1(efConstMethods[0].DeclaringType.MDToken.ToInt32(), BinOp2(efConstMethods[1].DeclaringType.MDToken.ToInt32(), BinOp3(efConstMethods[2].DeclaringType.MDToken.ToInt32(), BinOp1(efConstMethods[4].DeclaringType.MDToken.ToInt32(), efConstMethods[5].DeclaringType.MDToken.ToInt32())))));

		int ConstMethod5() =>
			BinOp2(BinOp2(ConstMethod3(), BinOp1(efConstMethods[4].DeclaringType.MDToken.ToInt32(), ConstMethod2())), efConstMethods[5].DeclaringType.MDToken.ToInt32());

		int ConstMethod6() =>
			BinOp1(efConstMethods[5].DeclaringType.MDToken.ToInt32(), BinOp3(BinOp2(efConstMethods[4].DeclaringType.MDToken.ToInt32(), efConstMethods[0].DeclaringType.MDToken.ToInt32()), BinOp3(efConstMethods[2].DeclaringType.MDToken.ToInt32() ^ i3, ConstMethod5())));

		public ulong GetMagic() {
			if (type == null)
				throw new ApplicationException("Can't calculate magic since type isn't initialized");

			var bytes = new List<byte>();
			if (module.Assembly != null) {
				if (!PublicKeyBase.IsNullOrEmpty2(module.Assembly.PublicKey))
					bytes.AddRange(module.Assembly.PublicKeyToken.Data);
				bytes.AddRange(Encoding.Unicode.GetBytes(module.Assembly.Name.String));
			}

			int num3 = ConstMethod1();
			int num2 = type.MDToken.ToInt32();

			bytes.Add((byte)(num2 >> shiftConsts[0]));
			bytes.Add((byte)(num3 >> shiftConsts[1]));
			bytes.Add((byte)(num2 >> shiftConsts[2]));
			bytes.Add((byte)(num3 >> shiftConsts[3]));
			bytes.Add((byte)(num2 >> shiftConsts[4]));
			bytes.Add((byte)(num3 >> shiftConsts[5]));
			bytes.Add((byte)(num2 >> shiftConsts[6]));
			bytes.Add((byte)(num3 >> shiftConsts[7]));

			ulong magic = 0;
			foreach (var b in bytes) {
				magic += b;
				magic += magic << 20;
				magic ^= magic >> 12;
			}
			magic += magic << 6;
			magic ^= magic >> 22;
			magic += magic << 30;
			return magic ^ l1;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Eazfuscator_NET/Deobfuscator.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;
using de4dot.code.renamer;

namespace de4dot.code.deobfuscators.Eazfuscator_NET {
	public class DeobfuscatorInfo : DeobfuscatorInfoBase {
		public const string THE_NAME = "Eazfuscator.NET";
		public const string THE_TYPE = "ef";
		const string DEFAULT_REGEX = @"!^[a-zA-Z]$&!^#=&!^dje_.+_ejd$&" + DeobfuscatorBase.DEFAULT_ASIAN_VALID_NAME_REGEX;
		public DeobfuscatorInfo()
			: base(DEFAULT_REGEX) {
		}

		public override string Name => THE_NAME;
		public override string Type => THE_TYPE;

		public override IDeobfuscator CreateDeobfuscator() =>
			new Deobfuscator(new Deobfuscator.Options {
				ValidNameRegex = validNameRegex.Get(),
			});
	}

	class Deobfuscator : DeobfuscatorBase {
		string obfuscatorName = DeobfuscatorInfo.THE_NAME;
		bool detectedVersion = false;

		DecrypterType decrypterType;
		StringDecrypter stringDecrypter;
		AssemblyResolver assemblyResolver;
		ResourceResolver resourceResolver;
		ResourceMethodsRestorer resourceMethodsRestorer;

		internal class Options : OptionsBase {
		}

		public override string Type => DeobfuscatorInfo.THE_TYPE;
		public override string TypeLong => DeobfuscatorInfo.THE_NAME;
		public override string Name => obfuscatorName;
		public Deobfuscator(Options options) : base(options) { }

		protected override int DetectInternal() {
			int val = 0;

			int sum = ToInt32(stringDecrypter.Detected) +
					ToInt32(assemblyResolver.Detected) +
					ToInt32(resourceResolver.Detected);
			if (sum > 0)
				val += 100 + 10 * (sum - 1);
			if (detectedVersion)
				val += 10;

			return val;
		}

		protected override void ScanForObfuscator() {
			decrypterType = new DecrypterType(module, DeobfuscatedFile);
			stringDecrypter = new StringDecrypter(module, decrypterType);
			stringDecrypter.Find();
			assemblyResolver = new AssemblyResolver(module, decrypterType);
			assemblyResolver.Find();
			resourceResolver = new ResourceResolver(module, assemblyResolver);
			resourceResolver.Find();
			if (stringDecrypter.Detected)
				DetectVersion();
		}

		void DetectVersion() {
			var version = new VersionDetector(module, stringDecrypter).Detect();
			if (version == null)
				return;

			detectedVersion = true;
			obfuscatorName = DeobfuscatorInfo.THE_NAME + " " +  version;
		}

		public override void DeobfuscateBegin() {
			base.DeobfuscateBegin();

			stringDecrypter.Initialize(DeobfuscatedFile);
			staticStringInliner.Add(stringDecrypter.RealMethod, (method2, gim, args) => {
				return stringDecrypter.Decrypt((int)args[0]);
			});
			DeobfuscatedFile.StringDecryptersAdded();

			assemblyResolver.Initialize(DeobfuscatedFile, this);
			assemblyResolver.InitializeEmbeddedFiles();
			AddModuleCctorInitCallToBeRemoved(assemblyResolver.InitMethod);

			resourceResolver.Initialize(DeobfuscatedFile, this);
			foreach (var info in resourceResolver.MergeResources())
				AddResourceToBeRemoved(info.Resource, "Encrypted resources");
			AddModuleCctorInitCallToBeRemoved(resourceResolver.InitMethod);

			resourceMethodsRestorer = new ResourceMethodsRestorer(module);
			if ((Operations.RenamerFlags & (RenamerFlags.RenameTypes | RenamerFlags.RenameNamespaces)) != 0)
				resourceMethodsRestorer.Find(DeobfuscatedFile, this);

			DumpEmbeddedAssemblies();
		}

		void DumpEmbeddedAssemblies() {
			foreach (var info in assemblyResolver.AssemblyInfos) {
				DeobfuscatedFile.CreateAssemblyFile(info.Data, info.SimpleName, info.Extension);
				AddResourceToBeRemoved(info.Resource, $"Embedded assembly: {info.AssemblyFullName}");
			}
		}

		public override void DeobfuscateMethodEnd(Blocks blocks) {
			resourceMethodsRestorer.Deobfuscate(blocks);
			assemblyResolver.Deobfuscate(blocks);
			base.DeobfuscateMethodEnd(blocks);
		}

		public override void DeobfuscateEnd() {
			if (CanRemoveStringDecrypterType) {
				AddTypesToBeRemoved(stringDecrypter.Types, "String decrypter type");
				//AddTypeToBeRemoved(decrypterType.Type, "Decrypter type");
				AddTypesToBeRemoved(stringDecrypter.DynocodeTypes, "Dynocode type");
				AddResourceToBeRemoved(stringDecrypter.Resource, "Encrypted strings");
			}
			stringDecrypter.CloseServer();

			AddTypeToBeRemoved(assemblyResolver.Type, "Assembly resolver type");
			AddTypeToBeRemoved(assemblyResolver.OtherType, "Assembly resolver other type");
			AddTypeToBeRemoved(resourceResolver.Type, "Resource resolver type");
			AddTypeToBeRemoved(resourceMethodsRestorer.Type, "GetManifestResourceStream type");
			AddResourceToBeRemoved(resourceMethodsRestorer.Resource, "GetManifestResourceStream type resource");

			FixInterfaces();
			StringDecrypterBugWorkaround();
			base.DeobfuscateEnd();
		}

		void StringDecrypterBugWorkaround() {
			// There's a bug in Eazfuscator.NET when the VM and string encryption features are
			// enabled. The string decrypter's initialization code checks to make sure it's not
			// called by eg. a dynamic method. When it's called from the VM code, it is
			// called by MethodBase.Invoke() and the string decrypter antis set in causing it
			// to fail.
			// One way to work around this is to make sure the string decrypter has been called
			// once. That way, any VM code calling it won't trigger a failure.
			// We can put this code in <Module>::.cctor() since it gets executed before any
			// other code.
			// Note that we can't call the string decrypter from <Module>::.cctor() since
			// its DeclaringType property will return null (since it's the global type). We
			// must call another created class which calls the string decrypter.

			// You must use --dont-rename --keep-types --preserve-tokens and decrypt strings
			if (!Operations.KeepObfuscatorTypes || Operations.DecryptStrings == OpDecryptString.None ||
				(Operations.RenamerFlags & (RenamerFlags.RenameNamespaces | RenamerFlags.RenameTypes)) != 0)
				return;

			if (stringDecrypter.ValidStringDecrypterValue == null)
				return;

			var newType = module.UpdateRowId(new TypeDefUser(Guid.NewGuid().ToString("B"), module.CorLibTypes.Object.TypeDefOrRef));
			module.Types.Add(newType);
			var newMethod = module.UpdateRowId(new MethodDefUser("x", MethodSig.CreateStatic(module.CorLibTypes.Void), 0, MethodAttributes.Static | MethodAttributes.HideBySig));
			newType.Methods.Add(newMethod);
			newMethod.Body = new CilBody();
			newMethod.Body.MaxStack = 1;
			newMethod.Body.Instructions.Add(Instruction.CreateLdcI4(stringDecrypter.ValidStringDecrypterValue.Value));
			newMethod.Body.Instructions.Add(OpCodes.Call.ToInstruction(stringDecrypter.Method));
			newMethod.Body.Instructions.Add(OpCodes.Pop.ToInstruction());
			newMethod.Body.Instructions.Add(OpCodes.Ret.ToInstruction());

			var cctor = module.GlobalType.FindOrCreateStaticConstructor();
			var blocks = new Blocks(cctor);
			var block = blocks.MethodBlocks.GetAllBlocks()[0];
			block.Insert(0, OpCodes.Call.ToInstruction(newMethod));

			blocks.GetCode(out var allInstructions, out var allExceptionHandlers);
			DotNetUtils.RestoreBody(cctor, allInstructions, allExceptionHandlers);
		}

		protected override void Dispose(bool disposing) {
			if (disposing) {
				if (stringDecrypter != null)
					stringDecrypter.Dispose();
			}
			base.Dispose(disposing);
		}

		public override IEnumerable<int> GetStringDecrypterMethods() {
			var list = new List<int>();
			if (stringDecrypter.Method != null)
				list.Add(stringDecrypter.Method.MDToken.ToInt32());
			return list;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Eazfuscator_NET/DynamicDynocodeIterator.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using AssemblyData;
using de4dot.code.AssemblyClient;
using dnlib.DotNet;

namespace de4dot.code.deobfuscators.Eazfuscator_NET {
	class DynamicDynocodeIterator : IDisposable, IEnumerable<int> {
		IAssemblyClient assemblyClient;
		List<TypeDef> dynocodeTypes = new List<TypeDef>();

		public List<TypeDef> Types => dynocodeTypes;

		class MyEnumerator : IEnumerator<int> {
			DynamicDynocodeIterator ddi;
			public MyEnumerator(DynamicDynocodeIterator ddi) => this.ddi = ddi;
			public int Current => (int)ddi.assemblyClient.GenericService.SendMessage(DynocodeService.MSG_CALL_GET_CURRENT, null);
			public void Dispose() { }
			object System.Collections.IEnumerator.Current => Current;
			public bool MoveNext() => (bool)ddi.assemblyClient.GenericService.SendMessage(DynocodeService.MSG_CALL_MOVE_NEXT, null);
			public void Reset() => throw new NotImplementedException();
		}

		public void Dispose() {
			if (assemblyClient != null)
				assemblyClient.Dispose();
			assemblyClient = null;
		}

		public void Initialize(ModuleDef module) {
			if (assemblyClient != null)
				return;

			var serverVersion = NewProcessAssemblyClientFactory.GetServerClrVersion(module);
			assemblyClient = new NewProcessAssemblyClientFactory(serverVersion).Create(AssemblyServiceType.Generic);
			assemblyClient.Connect();
			assemblyClient.WaitConnected();

			assemblyClient.GenericService.LoadUserService(typeof(DynocodeService), null);
			assemblyClient.GenericService.LoadAssembly(module.Location);
		}

		public void CreateEnumerable(MethodDef ctor, object[] args) {
			var type = ctor.DeclaringType;
			while (type.DeclaringType != null)
				type = type.DeclaringType;
			dynocodeTypes.Add(type);
			assemblyClient.GenericService.SendMessage(DynocodeService.MSG_CREATE_ENUMERABLE,
					new object[] { ctor.MDToken.ToUInt32(), args });
		}

		public void WriteEnumerableField(uint fieldToken, object value) =>
			assemblyClient.GenericService.SendMessage(DynocodeService.MSG_WRITE_ENUMERABLE_FIELD, new object[] { fieldToken, value });

		public void CreateEnumerator() =>
			assemblyClient.GenericService.SendMessage(DynocodeService.MSG_CREATE_ENUMERATOR, null);

		public IEnumerator<int> GetEnumerator() => new MyEnumerator(this);
		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => new MyEnumerator(this);
	}
}



================================================
File: de4dot.code/deobfuscators/Eazfuscator_NET/DynocodeService.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Reflection;
using AssemblyData;

namespace de4dot.code.deobfuscators.Eazfuscator_NET {
	class DynocodeService : IUserGenericService {
		public const int MSG_CREATE_ENUMERABLE = 0;
		public const int MSG_WRITE_ENUMERABLE_FIELD = 1;
		public const int MSG_CREATE_ENUMERATOR = 2;
		public const int MSG_CALL_GET_CURRENT = 3;
		public const int MSG_CALL_MOVE_NEXT = 4;

		Module reflObfModule;
		object ienumerable = null;
		object ienumerator = null;
		MethodInfo mi_get_Current;
		MethodInfo mi_MoveNext;

		[CreateUserGenericService]
		public static IUserGenericService Create() => new DynocodeService();

		public void AssemblyLoaded(Assembly assembly) => reflObfModule = assembly.ManifestModule;

		public object HandleMessage(int msg, object[] args) {
			switch (msg) {
			case MSG_CREATE_ENUMERABLE:
				CreateEnumerable((uint)args[0], args[1] as object[]);
				return true;

			case MSG_WRITE_ENUMERABLE_FIELD:
				WriteEnumerableField((uint)args[0], args[1] as object);
				return true;

			case MSG_CREATE_ENUMERATOR:
				CreateEnumerator();
				return true;

			case MSG_CALL_GET_CURRENT:
				return CallGetCurrent();

			case MSG_CALL_MOVE_NEXT:
				return CallMoveNext();

			default:
				throw new ApplicationException($"Invalid msg: {msg:X8}");
			}
		}

		void CreateEnumerable(uint ctorToken, object[] args) {
			var ctor = reflObfModule.ResolveMethod((int)ctorToken) as ConstructorInfo;
			if (ctor == null)
				throw new ApplicationException($"Invalid ctor with token: {ctorToken:X8}");
			ienumerable = ctor.Invoke(args);
		}

		void WriteEnumerableField(uint fieldToken, object value) {
			var field = reflObfModule.ResolveField((int)fieldToken);
			if (field == null)
				throw new ApplicationException($"Invalid field: {fieldToken:X8}");
			field.SetValue(ienumerable, value);
		}

		void CreateEnumerator() {
			foreach (var method in ienumerable.GetType().GetMethods(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic)) {
				if (method.GetParameters().Length != 0)
					continue;
				var retType = method.ReturnType;
				if (!retType.IsGenericType)
					continue;
				var genArgs = retType.GetGenericArguments();
				if (genArgs.Length != 1)
					continue;
				if (genArgs[0] != typeof(int))
					continue;
				if (!FindEnumeratorMethods(retType))
					continue;

				ienumerator = method.Invoke(ienumerable, null);
				return;
			}

			throw new ApplicationException("No GetEnumerator() method found");
		}

		bool FindEnumeratorMethods(Type type) {
			mi_get_Current = null;
			mi_MoveNext = null;

			foreach (var method in ienumerable.GetType().GetMethods(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic)) {
				if (Is_get_Current(method)) {
					if (mi_get_Current != null)
						return false;
					mi_get_Current = method;
					continue;
				}

				if (Is_MoveNext(method)) {
					if (mi_MoveNext != null)
						return false;
					mi_MoveNext = method;
					continue;
				}
			}

			return mi_get_Current != null && mi_MoveNext != null;
		}

		static bool Is_get_Current(MethodInfo method) {
			if (method.GetParameters().Length != 0)
				return false;
			if (method.ReturnType != typeof(int))
				return false;

			return true;
		}

		static bool Is_MoveNext(MethodInfo method) {
			if (method.GetParameters().Length != 0)
				return false;
			if (method.ReturnType != typeof(bool))
				return false;

			return true;
		}

		int CallGetCurrent() => (int)mi_get_Current.Invoke(ienumerator, null);
		bool CallMoveNext() => (bool)mi_MoveNext.Invoke(ienumerator, null);
		public void Dispose() { }
	}
}



================================================
File: de4dot.code/deobfuscators/Eazfuscator_NET/EfConstantsReader.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using dnlib.DotNet;

namespace de4dot.code.deobfuscators.Eazfuscator_NET {
	class EfConstantsReader : ConstantsReader {
		public EfConstantsReader(MethodDef method) : base(method) => Initialize();
		void Initialize() => FindConstants();

		void FindConstants() {
			for (int index = 0; index < instructions.Count; ) {
				if (!GetInt32(ref index, out int value))
					break;
				var stloc = instructions[index];
				if (!stloc.IsStloc())
					break;
				var local = stloc.GetLocal(locals);
				if (local == null || local.Type.GetElementType() != ElementType.I4)
					break;
				localsValuesInt32[local] = value;
				index++;
			}

			if (localsValuesInt32.Count != 2)
				localsValuesInt32.Clear();
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Eazfuscator_NET/EfUtils.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace de4dot.code.deobfuscators.Eazfuscator_NET {
	static class EfUtils {
		public static int FindOpCodeIndex(MethodDef method, int index, Code code) {
			for (; index < method.Body.Instructions.Count; index++) {
				var instr = method.Body.Instructions[index];
				if (instr.OpCode.Code != code)
					continue;

				return index;
			}
			return -1;
		}

		public static int FindOpCodeIndex(MethodDef method, int index, Code code, string operandString) {
			while (index < method.Body.Instructions.Count) {
				index = FindOpCodeIndex(method, index, code);
				if (index < 0)
					break;
				var instr = method.Body.Instructions[index];
				if (instr.Operand.ToString() == operandString)
					return index;

				index++;
			}
			return -1;
		}

		public static Instruction GetNextStore(MethodDef method, ref int index) {
			for (; index < method.Body.Instructions.Count; index++) {
				var instr = method.Body.Instructions[index];

				switch (instr.OpCode.Code) {
				case Code.Starg:
				case Code.Starg_S:
				case Code.Stelem:
				case Code.Stelem_I:
				case Code.Stelem_I1:
				case Code.Stelem_I2:
				case Code.Stelem_I4:
				case Code.Stelem_I8:
				case Code.Stelem_R4:
				case Code.Stelem_R8:
				case Code.Stelem_Ref:
				case Code.Stfld:
				case Code.Stind_I:
				case Code.Stind_I1:
				case Code.Stind_I2:
				case Code.Stind_I4:
				case Code.Stind_I8:
				case Code.Stind_R4:
				case Code.Stind_R8:
				case Code.Stind_Ref:
				case Code.Stloc:
				case Code.Stloc_0:
				case Code.Stloc_1:
				case Code.Stloc_2:
				case Code.Stloc_3:
				case Code.Stloc_S:
				case Code.Stobj:
				case Code.Stsfld:
					return instr;
				}

				if (instr.OpCode.FlowControl != FlowControl.Next)
					break;
			}

			return null;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Eazfuscator_NET/ResourceMethodsRestorer.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using dnlib.DotNet;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Eazfuscator_NET {
	class ResourceMethodsRestorer : MethodCallRestorerBase {
		TypeDef getManifestResourceStreamType;
		EmbeddedResource getManifestResourceStreamTypeResource;

		public TypeDef Type => getManifestResourceStreamType;
		public Resource Resource => getManifestResourceStreamTypeResource;
		public ResourceMethodsRestorer(ModuleDefMD module) : base(module) { }

		public void Find(ISimpleDeobfuscator simpleDeobfuscator, IDeobfuscator deob) {
			foreach (var type in module.Types) {
				if (type.Fields.Count != 1)
					continue;
				if (type.HasNestedTypes || type.HasGenericParameters || type.IsValueType)
					continue;
				if (DotNetUtils.GetField(type, "System.Reflection.Assembly") == null)
					continue;
				if (type.FindStaticConstructor() == null)
					continue;

				var getStream2 = GetTheOnlyMethod(type, "System.IO.Stream", "(System.Reflection.Assembly,System.Type,System.String)");
				var getNames = GetTheOnlyMethod(type, "System.String[]", "(System.Reflection.Assembly)");
				var getRefAsms = GetTheOnlyMethod(type, "System.Reflection.AssemblyName[]", "(System.Reflection.Assembly)");
				var bitmapCtor = GetTheOnlyMethod(type, "System.Drawing.Bitmap", "(System.Type,System.String)");
				var iconCtor = GetTheOnlyMethod(type, "System.Drawing.Icon", "(System.Type,System.String)");
				if (getStream2 == null && getNames == null && getRefAsms == null &&
					bitmapCtor == null && iconCtor == null)
					continue;

				var resource = FindGetManifestResourceStreamTypeResource(type, simpleDeobfuscator, deob);
				if (resource == null && getStream2 != null)
					continue;

				getManifestResourceStreamType = type;
				CreateGetManifestResourceStream2(getStream2);
				CreateGetManifestResourceNames(getNames);
				CreateGetReferencedAssemblies(getRefAsms);
				CreateBitmapCtor(bitmapCtor);
				CreateIconCtor(iconCtor);
				getManifestResourceStreamTypeResource = resource;
				break;
			}
		}

		EmbeddedResource FindGetManifestResourceStreamTypeResource(TypeDef type, ISimpleDeobfuscator simpleDeobfuscator, IDeobfuscator deob) {
			foreach (var method in type.Methods) {
				if (!method.IsPrivate || !method.IsStatic || method.Body == null)
					continue;
				if (!DotNetUtils.IsMethod(method, "System.String", "(System.Reflection.Assembly,System.Type,System.String)"))
					continue;
				simpleDeobfuscator.Deobfuscate(method);
				simpleDeobfuscator.DecryptStrings(method, deob);
				foreach (var s in DotNetUtils.GetCodeStrings(method)) {
					if (DotNetUtils.GetResource(module, s) is EmbeddedResource resource)
						return resource;
				}
			}
			return null;
		}

		static MethodDef GetTheOnlyMethod(TypeDef type, string returnType, string parameters) {
			MethodDef foundMethod = null;

			foreach (var method in type.Methods) {
				if (!method.IsStatic || method.Body == null || method.HasGenericParameters)
					continue;
				if (method.IsPrivate)
					continue;
				if (!DotNetUtils.IsMethod(method, returnType, parameters))
					continue;

				if (foundMethod != null)
					return null;
				foundMethod = method;
			}

			return foundMethod;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Eazfuscator_NET/ResourceResolver.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Eazfuscator_NET {
	class ResourceResolver {
		ModuleDefMD module;
		AssemblyResolver assemblyResolver;
		TypeDef resolverType;
		MethodDef initMethod;
		MethodDef handlerMethod;
		List<string> resourceInfos = new List<string>();

		public TypeDef Type => resolverType;
		public MethodDef InitMethod => initMethod;
		public bool Detected => resolverType != null;

		public ResourceResolver(ModuleDefMD module, AssemblyResolver assemblyResolver) {
			this.module = module;
			this.assemblyResolver = assemblyResolver;
		}

		public void Find() {
			if (!assemblyResolver.Detected)
				return;
			CheckCalledMethods(DotNetUtils.GetModuleTypeCctor(module));
		}

		bool CheckCalledMethods(MethodDef method) {
			if (method == null || method.Body == null)
				return false;

			foreach (var instr in method.Body.Instructions) {
				if (instr.OpCode.Code != Code.Call)
					continue;
				if (!CheckInitMethod(instr.Operand as MethodDef))
					continue;

				return true;
			}

			return false;
		}

		bool CheckInitMethod(MethodDef method) {
			if (method == null || !method.IsStatic || method.Body == null)
				return false;
			if (!DotNetUtils.IsMethod(method, "System.Void", "()"))
				return false;
			var type = method.DeclaringType;
			if (type.NestedTypes.Count != 1)
				return false;
			if (DotNetUtils.GetField(type, "System.Reflection.Assembly") == null)
				return false;

			var resolveHandler = DeobUtils.GetResolveMethod(method);
			if (resolveHandler == null)
				return false;

			initMethod = method;
			resolverType = type;
			handlerMethod = resolveHandler;
			return true;
		}

		public void Initialize(ISimpleDeobfuscator simpleDeobfuscator, IDeobfuscator deob) {
			if (!InitializeInfos(simpleDeobfuscator, deob))
				throw new ApplicationException("Could not initialize resource decrypter");
		}

		bool InitializeInfos(ISimpleDeobfuscator simpleDeobfuscator, IDeobfuscator deob) {
			if (handlerMethod == null)
				return true;

			foreach (var method in resolverType.Methods) {
				if (!method.IsStatic || method.Body == null)
					continue;
				if (!DotNetUtils.IsMethod(method, "System.Void", "()"))
					continue;
				if (!DeobUtils.HasInteger(method, ':') || !DeobUtils.HasInteger(method, '|'))
					continue;

				simpleDeobfuscator.Deobfuscate(method);
				simpleDeobfuscator.DecryptStrings(method, deob);
				if (!InitializeInfos(method))
					continue;

				return true;
			}

			return false;
		}

		bool InitializeInfos(MethodDef method) {
			foreach (var s in DotNetUtils.GetCodeStrings(method)) {
				if (string.IsNullOrEmpty(s))
					continue;
				var ary = s.Split(':');

				foreach (var asmInfo in ary)
					resourceInfos.Add(asmInfo.Split('|')[0]);

				return true;
			}

			return false;
		}

		public List<AssemblyResolver.AssemblyInfo> MergeResources() {
			var list = new List<AssemblyResolver.AssemblyInfo>();
			foreach (var asmName in resourceInfos) {
				var asmInfo = assemblyResolver.Get(asmName);
				if (asmInfo == null)
					throw new ApplicationException($"Could not find resource assembly {Utils.ToCsharpString(asmName)}");

				DeobUtils.DecryptAndAddResources(module, asmInfo.ResourceName, () => asmInfo.Data);
				list.Add(asmInfo);
			}
			resourceInfos.Clear();
			return list;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Eazfuscator_NET/StringDecrypter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;
using de4dot.blocks.cflow;

namespace de4dot.code.deobfuscators.Eazfuscator_NET {
	class StringDecrypter : IDisposable {
		ModuleDefMD module;
		TypeDef stringType;
		MethodDef stringMethod;
		TypeDef dataDecrypterType;
		short s1, s2, s3;
		int i1, /*i2,*/ i3, i4, i5, i6;
		bool checkMinus2;
		bool usePublicKeyToken;
		int keyLen;
		byte[] theKey;
		int magic1;
		uint rldFlag, bytesFlag;
		EmbeddedResource encryptedResource;
		BinaryReader reader;
		DecrypterType decrypterType;
		StreamHelperType streamHelperType;
		EfConstantsReader stringMethodConsts;
		bool isV32OrLater;
		bool isV50OrLater;
		bool isV51OrLater;
		int? validStringDecrypterValue;
		DynamicDynocodeIterator dynocode;
		MethodDef realMethod;

		class StreamHelperType {
			public TypeDef type;
			public MethodDef readInt16Method;
			public MethodDef readInt32Method;
			public MethodDef readBytesMethod;

			public bool Detected =>
				readInt16Method != null &&
				readInt32Method != null &&
				readBytesMethod != null;

			public StreamHelperType(TypeDef type) {
				this.type = type;

				foreach (var method in type.Methods) {
					if (method.IsStatic || method.Body == null || method.IsPrivate || method.GenericParameters.Count > 0)
						continue;
					if (DotNetUtils.IsMethod(method, "System.Int16", "()"))
						readInt16Method = method;
					else if (DotNetUtils.IsMethod(method, "System.Int32", "()"))
						readInt32Method = method;
					else if (DotNetUtils.IsMethod(method, "System.Byte[]", "(System.Int32)"))
						readBytesMethod = method;
				}
			}
		}

		public int? ValidStringDecrypterValue => validStringDecrypterValue;
		public TypeDef Type => stringType;
		public EmbeddedResource Resource => encryptedResource;
		public IEnumerable<TypeDef> Types => new List<TypeDef> { stringType, dataDecrypterType };
		public IEnumerable<TypeDef> DynocodeTypes => dynocode.Types;
		public MethodDef Method => stringMethod;
		public bool Detected => stringType != null;

		/// <summary>
		/// In 5.0, the actual string decrypter method doesn't do much, calls a helper method which
		/// does most of the work (and is mostly the same as the stringMethod from 4.9 and below).
		/// </summary>
		public bool HasRealMethod => realMethod != null;
		public MethodDef RealMethod => realMethod ?? stringMethod;

		public StringDecrypter(ModuleDefMD module, DecrypterType decrypterType) {
			this.module = module;
			this.decrypterType = decrypterType;
		}

		static bool CheckIfV32OrLater(TypeDef type) {
			int numInts = 0;
			foreach (var field in type.Fields) {
				if (field.FieldSig.GetFieldType().GetElementType() == ElementType.I4)
					numInts++;
			}
			return numInts >= 2;
		}

		public void Find() {
			foreach (var type in module.Types) {
				if (!CheckType(type))
					continue;

				foreach (var method in type.Methods) {
					if (!CheckDecrypterMethod(method))
						continue;

					// 5.0
					if (CheckIfHelperMethod(method)) {
						stringMethod = method;
						realMethod = GetRealDecrypterMethod(method);
						isV50OrLater = true;
						foreach (var inst in stringMethod.Body.Instructions) {
							if (inst.OpCode.Code == Code.Cgt_Un) {
								isV51OrLater = true;
								break;
							}
						}
					}
					else stringMethod = method;

					stringType = type;
					isV32OrLater = CheckIfV32OrLater(stringType);
					return;
				}
			}
		}

		static string[] requiredFieldTypes = new string[] {
			"System.Byte[]",
			"System.Int16",
		};
		bool CheckType(TypeDef type) {
			if (!new FieldTypes(type).All(requiredFieldTypes))
				return false;
			if (type.NestedTypes.Count == 0) {
				return DotNetUtils.FindFieldType(type, "System.IO.BinaryReader", true) != null &&
					DotNetUtils.FindFieldType(type, "System.Collections.Generic.Dictionary`2<System.Int32,System.String>", true) != null;
			}
			else if (type.NestedTypes.Count == 3) {
				streamHelperType = FindStreamHelperType(type);
				return streamHelperType != null;
			}
			else if (type.NestedTypes.Count == 1) {
				return type.NestedTypes[0].IsEnum;
			}
			else
				return false;
		}

		static string[] streamHelperTypeFields = new string[] {
			"System.IO.Stream",
			"System.Byte[]",
		};
		static StreamHelperType FindStreamHelperType(TypeDef type) {
			foreach (var field in type.Fields) {
				var nested = field.FieldSig.GetFieldType().TryGetTypeDef();
				if (nested == null)
					continue;
				if (nested.DeclaringType != type)
					continue;
				if (!new FieldTypes(nested).Exactly(streamHelperTypeFields))
					continue;
				var streamHelperType = new StreamHelperType(nested);
				if (!streamHelperType.Detected)
					continue;

				return streamHelperType;
			}
			return null;
		}

		static string[] requiredLocalTypes = new string[] {
			"System.Boolean",
			"System.Byte[]",
			"System.Char[]",
			"System.Int16",
			"System.Int32",
			"System.Reflection.Assembly",
			"System.String",
		};
		static bool CheckDecrypterMethod(MethodDef method) {
			if (method == null || !method.IsStatic || method.Body == null)
				return false;
			if (!(DotNetUtils.IsMethod(method, "System.String", "(System.Int32)") || DotNetUtils.IsMethod(method, "System.String", "(System.Int32,System.Boolean)")))
				return false;
			if (!new LocalTypes(method).All(requiredLocalTypes))
				return false;

			foreach (var instr in method.Body.Instructions) {
				if (instr.OpCode != OpCodes.Callvirt)
					continue;
				if (instr.Operand is IMethod calledMethod && calledMethod.FullName == "System.IO.Stream System.Reflection.Assembly::GetManifestResourceStream(System.String)")
					return true;
			}

			return false;
		}

		/// <remarks>5.0</remarks>
		static bool CheckIfHelperMethod(MethodDef method) {
			// Helper method will be `private static`, instead of `internal static`
			return method.IsPrivate;
		}

		/// <summary>
		/// Get the real decrypter method from a found helper method.
		/// </summary>
		/// <remarks>5.0</remarks>
		static MethodDef GetRealDecrypterMethod(MethodDef helper) {
			var methods = helper.DeclaringType.Methods;
			foreach (var method in methods) {
				if (method.MDToken != helper.MDToken &&
					method.IsAssembly &&
					method.Parameters.Count >= 1 &&
					method.Parameters[0].Type == helper.Parameters[0].Type)	//checking first type, which should be string
					return method;
			}

			return null;
		}

		public void Initialize(ISimpleDeobfuscator simpleDeobfuscator) {
			if (stringType == null)
				return;

			if (!FindConstants(simpleDeobfuscator)) {
				if (encryptedResource == null)
					Logger.w("Could not find encrypted resource. Strings cannot be decrypted.");
				else
					Logger.w("Can't decrypt strings. Possibly a new Eazfuscator.NET version.");
				return;
			}
		}

		bool FindConstants(ISimpleDeobfuscator simpleDeobfuscator) {
			dynocode = new DynamicDynocodeIterator();
			simpleDeobfuscator.Deobfuscate(stringMethod);
			stringMethodConsts = new EfConstantsReader(stringMethod);

			if (!FindResource(stringMethod))
				return false;

			checkMinus2 = isV32OrLater || DeobUtils.HasInteger(stringMethod, -2);
			usePublicKeyToken = CallsGetPublicKeyToken(stringMethod);

			var int64Method = FindInt64Method(stringMethod);
			if (int64Method != null)
				decrypterType.Type = int64Method.DeclaringType;

			if (!FindShorts())
				return false;
			if (!FindInt3())
				return false;
			if (!FindInt4())
				return false;
			if (checkMinus2 && !FindInt5())
				return false;

			// The method body of the data decrypter method has been moved into
			// the string decrypter helper method in 5.0
			if (!isV50OrLater) {
				dataDecrypterType = FindDataDecrypterType(stringMethod);
				if (dataDecrypterType == null)
					return false;
			}

			if (isV32OrLater) {
				int index = FindInitIntsIndex(stringMethod, out bool initializedAll);

				//better return early than late on error
				if (index == -1)
					return false;

				var cctor = stringType.FindStaticConstructor();
				if (!initializedAll && cctor != null) {
					simpleDeobfuscator.Deobfuscate(cctor);
					if (!FindIntsCctor(cctor))
						return false;
				}

				if (decrypterType.Detected && !decrypterType.Initialize())
					return false;

				if (!isV50OrLater)
					decrypterType.ShiftConsts = new List<int> { 24, 16, 8, 0, 16, 8, 0, 24 };
				else {
					if (!FindShiftInts(decrypterType.Int64Method, out var shiftConsts))
						return false;

					decrypterType.ShiftConsts = shiftConsts;
				}

				if (!FindInts(index))
					return false;
			}


			InitializeFlags();
			Initialize();

			return true;
		}

		void InitializeFlags() {
			if (!isV32OrLater) {
				rldFlag = 0x40000000;
				bytesFlag = 0x80000000;
				return;
			}

			var instrs = stringMethod.Body.Instructions;
			for (int i = 0; i < instrs.Count; i++) {
				var ldci4 = instrs[i];
				if (!stringMethodConsts.IsLoadConstantInt32(ldci4))
					continue;
				int index = i;
				if (!stringMethodConsts.GetInt32(ref index, out int tmp) || !IsFlagsMask(tmp))
					continue;
				if (FindFlags(i))
					return;
			}

			throw new ApplicationException("Could not find string decrypter flags");
		}

		static bool IsFlagsMask(int value) => value == 0x1FFFFFFF || value == 0x0FFFFFFF;

		class FlagsInfo {
			public Local Local { get; set; }
			public uint Value { get; set; }
			public int Offset { get; set; }
			public FlagsInfo(Local local, uint value, int offset) {
				Local = local;
				Value = value;
				Offset = offset;
			}
		}

		bool FindFlags(int index) {
			var flags = FindFlags2(index);
			if (flags == null)
				return false;

			flags.Sort((a, b) => a.Offset.CompareTo(b.Offset));

			rldFlag = flags[0].Value;
			bytesFlag = flags[1].Value;
			return true;
		}

		List<FlagsInfo> FindFlags2(int index) {
			var flags = new List<FlagsInfo>(3);
			for (int i = index - 1; i >= 0; i--) {
				var instr = stringMethod.Body.Instructions[i];
				if (instr.OpCode.FlowControl != FlowControl.Next)
					break;
				if (!stringMethodConsts.IsLoadConstantInt32(instr))
					continue;
				int index2 = i;
				if (!stringMethodConsts.GetInt32(ref index2, out int value))
					continue;
				if ((uint)value != 0x80000000 && value != 0x40000000 && value != 0x20000000)
					continue;
				var local = GetFlagsLocal(stringMethod, index2);
				if (local == null)
					continue;
				int offset = GetFlagsOffset(stringMethod, index2, local);
				if (offset < 0)
					continue;

				flags.Add(new FlagsInfo(local, (uint)value, offset));
				if (flags.Count != 3)
					continue;

				return flags;
			}

			return null;
		}

		static int GetFlagsOffset(MethodDef method, int index, Local local) {
			var instrs = method.Body.Instructions;
			for (; index < instrs.Count; index++) {
				var ldloc = instrs[index];
				if (!ldloc.IsLdloc())
					continue;
				if (ldloc.GetLocal(method.Body.Variables) != local)
					continue;

				return index;
			}
			return -1;
		}

		Local GetFlagsLocal(MethodDef method, int index) {
			if (isV51OrLater)
				return GetFlagsLocalNew(method, index);
			return GetFlagsLocalOld(method, index);
		}

		// <= 5.0 
		static Local GetFlagsLocalOld(MethodDef method, int index) {
			var instrs = method.Body.Instructions;
			if (index + 5 >= instrs.Count)
				return null;
			if (instrs[index++].OpCode.Code != Code.And)
				return null;
			if (instrs[index++].OpCode.Code != Code.Ldc_I4_0)
				return null;
			if (instrs[index++].OpCode.Code != Code.Ceq)
				return null;
			if (instrs[index++].OpCode.Code != Code.Ldc_I4_0)
				return null;
			if (instrs[index++].OpCode.Code != Code.Ceq)
				return null;
			var stloc = instrs[index++];
			if (!stloc.IsStloc())
				return null;
			return stloc.GetLocal(method.Body.Variables);
		}

		// 5.1+
		// Uses different OpCodes
		static Local GetFlagsLocalNew(MethodDef method, int index) {
			var instrs = method.Body.Instructions;
			if (index + 5 >= instrs.Count)
				return null;
			if (instrs[index++].OpCode.Code != Code.And)
				return null;
			if (instrs[index++].OpCode.Code != Code.Ldc_I4_0)
				return null;
			if (instrs[index++].OpCode.Code != Code.Cgt_Un)
				return null;
			var stloc = instrs[index++];
			if (!stloc.IsStloc())
				return null;
			return stloc.GetLocal(method.Body.Variables);
		}

		void Initialize() {
			reader = new BinaryReader(encryptedResource.CreateReader().AsStream());
			short len = (short)(reader.ReadInt16() ^ s1);
			if (len != 0)
				theKey = reader.ReadBytes(len);
			else
				keyLen = reader.ReadInt16() ^ s2;
		}

		public string Decrypt(int val) {
			validStringDecrypterValue = val;
			while (true) {
				int offset = magic1 ^ i3 ^ val ^ i6;
				reader.BaseStream.Position = offset;
				byte[] tmpKey;
				if (theKey == null) {
					tmpKey = reader.ReadBytes(keyLen == -1 ? (short)(reader.ReadInt16() ^ s3 ^ offset) : keyLen);
					if (isV32OrLater) {
						for (int i = 0; i < tmpKey.Length; i++)
							tmpKey[i] ^= (byte)(magic1 >> ((i & 3) << 3));
					}
				}
				else
					tmpKey = theKey;

				int flags = i4 ^ magic1 ^ offset ^ reader.ReadInt32();
				if (checkMinus2 && flags == -2) {
					var ary2 = reader.ReadBytes(4);
					val = -(magic1 ^ i5) ^ (ary2[2] | (ary2[0] << 8) | (ary2[3] << 16) | (ary2[1] << 24));
					continue;
				}

				var bytes = reader.ReadBytes(flags & 0x1FFFFFFF);
				Decrypt1(bytes, tmpKey);
				var pkt = PublicKeyBase.ToPublicKeyToken(module.Assembly.PublicKey);
				if (usePublicKeyToken && !PublicKeyBase.IsNullOrEmpty2(pkt)) {
					for (int i = 0; i < bytes.Length; i++)
						bytes[i] ^= (byte)((pkt.Data[i & 7] >> 5) + (pkt.Data[i & 7] << 3));
				}

				if ((flags & rldFlag) != 0)
					bytes = rld(bytes);
				if ((flags & bytesFlag) != 0) {
					var sb = new StringBuilder(bytes.Length);
					foreach (var b in bytes)
						sb.Append((char)b);
					return sb.ToString();
				}
				else
					return Encoding.Unicode.GetString(bytes);
			}
		}

		static byte[] rld(byte[] src) {
			var dst = new byte[src[2] + (src[3] << 8) + (src[0] << 16) + (src[1] << 24)];
			int srcIndex = 4;
			int dstIndex = 0;
			int flags = 0;
			int bit = 128;
			while (dstIndex < dst.Length) {
				bit <<= 1;
				if (bit == 256) {
					bit = 1;
					flags = src[srcIndex++];
				}

				if ((flags & bit) == 0) {
					dst[dstIndex++] = src[srcIndex++];
					continue;
				}

				int numBytes = (src[srcIndex] >> 2) + 3;
				int copyIndex = dstIndex - ((src[srcIndex + 1] + (src[srcIndex] << 8)) & 0x3FF);
				if (copyIndex < 0)
					break;
				while (dstIndex < dst.Length && numBytes-- > 0)
					dst[dstIndex++] = dst[copyIndex++];
				srcIndex += 2;
			}

			return dst;
		}

		static void Decrypt1(byte[] dest, byte[] key) {
			byte b = (byte)((key[1] + 7) ^ (dest.Length + 11));
			uint lcg = (uint)((key[0] | (key[2] << 8)) + (b << 3));
			b += 3;
			ushort xn = 0;
			for (int i = 0; i < dest.Length; i++) {
				if ((i & 1) == 0) {
					lcg = LcgNext(lcg);
					xn = (ushort)(lcg >> 16);
				}
				byte tmp = dest[i];
				dest[i] ^= (byte)(key[1] ^ xn ^ b);
				b = (byte)(tmp + 3);
				xn >>= 8;
			}
		}

		static uint LcgNext(uint lcg) => lcg * 214013 + 2531011;

		bool FindResource(MethodDef method) {
			encryptedResource = FindResourceFromCodeString(method) ??
								FindResourceFromStringBuilder(method);
			return encryptedResource != null;
		}

		EmbeddedResource FindResourceFromCodeString(MethodDef method) =>
			DotNetUtils.GetResource(module, DotNetUtils.GetCodeStrings(method)) as EmbeddedResource;

		EmbeddedResource FindResourceFromStringBuilder(MethodDef method) {
			int startIndex = EfUtils.FindOpCodeIndex(method, 0, Code.Newobj, "System.Void System.Text.StringBuilder::.ctor()");
			if (startIndex < 0)
				return null;
			int endIndex = EfUtils.FindOpCodeIndex(method, startIndex, Code.Call, "System.String System.Text.StringBuilder::ToString()");
			if (endIndex < 0)
				return null;

			var sb = new StringBuilder();
			var instrs = method.Body.Instructions;
			int val = 0, shift = 0;
			for (int i = startIndex; i < endIndex; i++) {
				var instr = instrs[i];
				if (instr.OpCode.Code == Code.Call && instr.Operand.ToString() == "System.Text.StringBuilder System.Text.StringBuilder::Append(System.Char)") {
					sb.Append((char)(val >> shift));
					shift = 0;
				}
				if (stringMethodConsts.IsLoadConstantInt32(instr)) {
					if (!stringMethodConsts.GetInt32(ref i, out int tmp))
						break;
					if (i >= endIndex)
						break;

					var next = instrs[i];
					if (next.OpCode.Code == Code.Shr)
						shift = tmp;
					else {
						val = tmp;
						shift = 0;
					}
				}
			}

			return DotNetUtils.GetResource(module, sb.ToString()) as EmbeddedResource;
		}

		bool FindShiftInts(MethodDef method, out List<int> bytes) {
			var instrs = method.Body.Instructions;
			var constantsReader = new EfConstantsReader(method);
			bytes = new List<int>(8);

			for (int i = 0; i < instrs.Count - 4; i++) {
				if (bytes.Count >= 8)
					return true;

				var ldloc1 = instrs[i];
				if (ldloc1.OpCode.Code != Code.Ldloc_1)
					continue;

				var ldlocs = instrs[i + 1];
				if (ldlocs.OpCode.Code != Code.Ldloc_S)
					continue;

				var maybe = instrs[i + 2];
				if (maybe.OpCode.Code == Code.Conv_U1) {
					var callvirt = instrs[i + 3];
					if (callvirt.OpCode.Code != Code.Callvirt)
						return false;

					bytes.Add(0);
					continue;
				}
				var shr = instrs[i + 3];
				if (shr.OpCode.Code != Code.Shr)
					return false;

				var convu1 = instrs[i + 4];
				if (convu1.OpCode.Code != Code.Conv_U1)
					return false;

				int index = i + 2;
				if (!constantsReader.GetInt32(ref index, out int constant))
					return false;

				bytes.Add(constant);
			}

			return false;
		}

		static MethodDef FindInt64Method(MethodDef method) {
			foreach (var instr in method.Body.Instructions) {
				if (instr.OpCode.Code != Code.Call)
					continue;
				var calledMethod = instr.Operand as MethodDef;
				if (calledMethod == null)
					continue;
				if (!DotNetUtils.IsMethod(calledMethod, "System.Int64", "()"))
					continue;

				return calledMethod;
			}
			return null;
		}

		static TypeDef FindDataDecrypterType(MethodDef method) {
			foreach (var instr in method.Body.Instructions) {
				if (instr.OpCode.Code != Code.Call)
					continue;
				var calledMethod = instr.Operand as MethodDef;
				if (calledMethod == null)
					continue;
				if (!DotNetUtils.IsMethod(calledMethod, "System.Byte[]", "(System.Byte[],System.Byte[])"))
					continue;

				return calledMethod.DeclaringType;
			}
			return null;
		}

		bool FindShorts() {
			int index = 0;
			if (!FindShort(ref index, ref s1))
				return false;
			if (!FindShort(ref index, ref s2))
				return false;
			if (!FindShort(ref index, ref s3))
				return false;

			return true;
		}

		bool FindShort(ref int index, ref short s) {
			if (!FindCallReadInt16(ref index))
				return false;
			index++;
			return stringMethodConsts.GetInt16(ref index, out s);
		}

		bool FindInts(int index) {
			if (index < 0)
				return false;

			//i2 = 0;
			var instrs = stringMethod.Body.Instructions;

			var emu = new InstructionEmulator(stringMethod);
			foreach (var kv in stringMethodConsts.Locals32)
				emu.SetLocal(kv.Key, new Int32Value(kv.Value));

			var fields = new Dictionary<FieldDef, int?>();
			for (int i = index; i < instrs.Count - 2; i++) {
				var instr = instrs[i];

				FieldDef field;
				switch (instr.OpCode.Code) {
				case Code.Ldsfld:
					field = instr.Operand as FieldDef;
					if (field == null || field.DeclaringType != stringMethod.DeclaringType || field.FieldType.GetElementType() != ElementType.I4)
						goto default;
					fields[field] = null;
					emu.Push(new Int32Value(i1));
					break;

				case Code.Stsfld:
					field = instr.Operand as FieldDef;
					if (field == null || field.DeclaringType != stringMethod.DeclaringType || field.FieldType.GetElementType() != ElementType.I4)
						goto default;
					if (fields.ContainsKey(field) && fields[field] == null)
						goto default;
					var val = emu.Pop() as Int32Value;
					if (val == null || !val.AllBitsValid())
						fields[field] = null;
					else
						fields[field] = val.Value;
					break;

				case Code.Call:
					var method = instr.Operand as MethodDef;
					if (!decrypterType.Detected || method != decrypterType.Int64Method)
						goto done;
					emu.Push(new Int64Value((long)decrypterType.GetMagic()));
					break;

				case Code.Newobj:
					if (!EmulateDynocode(emu, ref i))
						goto default;
					break;

				default:
					if (instr.OpCode.FlowControl != FlowControl.Next)
						goto done;
					emu.Emulate(instr);
					break;
				}
			}
done:

			foreach (var val in fields.Values) {
				if (val == null)
					continue;
				magic1 = /*i2 =*/ val.Value;
				return true;
			}

			return false;
		}

		bool EmulateDynocode(InstructionEmulator emu, ref int index) {
			if (isV51OrLater)
				return EmulateDynocodeNew(emu, ref index);
			return EmulateDynocodeOld(emu, ref index);
		}

		// <= 5.0
		bool EmulateDynocodeOld(InstructionEmulator emu, ref int index) {
			var instrs = stringMethod.Body.Instructions;
			var instr = instrs[index];

			var ctor = instr.Operand as MethodDef;
			if (ctor == null || ctor.MethodSig.GetParamCount() != 1 || ctor.MethodSig.Params[0].ElementType != ElementType.I4)
				return false;

			if (index + 4 >= instrs.Count)
				return false;
			var ldloc = instrs[index + 3];
			var stfld = instrs[index + 4];
			if (!ldloc.IsLdloc() || stfld.OpCode.Code != Code.Stfld)
				return false;
			var enumerableField = stfld.Operand as FieldDef;
			if (enumerableField == null)
				return false;

			var initValue = emu.GetLocal(ldloc.GetLocal(stringMethod.Body.Variables)) as Int32Value;
			if (initValue == null || !initValue.AllBitsValid())
				return false;

			int leaveIndex = FindLeave(instrs, index);
			if (leaveIndex < 0)
				return false;
			var afterLoop = instrs[leaveIndex].Operand as Instruction;
			if (afterLoop == null)
				return false;
			int newIndex = instrs.IndexOf(afterLoop);
			var loopLocal = GetDCLoopLocal(index, newIndex);
			if (loopLocal == null)
				return false;
			var initValue2 = emu.GetLocal(loopLocal) as Int32Value;
			if (initValue2 == null || !initValue2.AllBitsValid())
				return false;

			int loopStart = GetIndexOfCall(instrs, index, leaveIndex, "System.Int32", "()");
			int loopEnd = GetIndexOfCall(instrs, loopStart, leaveIndex, "System.Boolean", "()");
			if (loopStart < 0 || loopEnd < 0)
				return false;
			loopStart++;
			loopEnd--;

			dynocode.Initialize(module);
			var ctorArg = emu.Pop() as Int32Value;
			if (ctorArg == null || !ctorArg.AllBitsValid())
				return false;
			dynocode.CreateEnumerable(ctor, new object[] { ctorArg.Value });
			dynocode.WriteEnumerableField(enumerableField.MDToken.ToUInt32(), initValue.Value);
			dynocode.CreateEnumerator();
			foreach (var val in dynocode) {
				emu.Push(new Int32Value(val));
				for (int i = loopStart; i < loopEnd; i++)
					emu.Emulate(instrs[i]);
			}

			index = newIndex - 1;
			return true;
		}

		// 5.1+
		// the only changes are the indexes of ldloc and stfld
		bool EmulateDynocodeNew(InstructionEmulator emu, ref int index) {
			var instrs = stringMethod.Body.Instructions;
			var instr = instrs[index];

			var ctor = instr.Operand as MethodDef;
			if (ctor == null || ctor.MethodSig.GetParamCount() != 1 || ctor.MethodSig.Params[0].ElementType != ElementType.I4)
				return false;

			if (index + 4 >= instrs.Count)
				return false;
			var ldloc = instrs[index + 2];
			var stfld = instrs[index + 3];
			if (!ldloc.IsLdloc() || stfld.OpCode.Code != Code.Stfld)
				return false;
			var enumerableField = stfld.Operand as FieldDef;
			if (enumerableField == null)
				return false;

			var initValue = emu.GetLocal(ldloc.GetLocal(stringMethod.Body.Variables)) as Int32Value;
			if (initValue == null || !initValue.AllBitsValid())
				return false;

			int leaveIndex = FindLeave(instrs, index);
			if (leaveIndex < 0)
				return false;
			var afterLoop = instrs[leaveIndex].Operand as Instruction;
			if (afterLoop == null)
				return false;
			int newIndex = instrs.IndexOf(afterLoop);
			var loopLocal = GetDCLoopLocal(index, newIndex);
			if (loopLocal == null)
				return false;
			var initValue2 = emu.GetLocal(loopLocal) as Int32Value;
			if (initValue2 == null || !initValue2.AllBitsValid())
				return false;

			int loopStart = GetIndexOfCall(instrs, index, leaveIndex, "System.Int32", "()");
			int loopEnd = GetIndexOfCall(instrs, loopStart, leaveIndex, "System.Boolean", "()");
			if (loopStart < 0 || loopEnd < 0)
				return false;
			loopStart++;
			loopEnd--;

			dynocode.Initialize(module);
			var ctorArg = emu.Pop() as Int32Value;
			if (ctorArg == null || !ctorArg.AllBitsValid())
				return false;
			dynocode.CreateEnumerable(ctor, new object[] { ctorArg.Value });
			dynocode.WriteEnumerableField(enumerableField.MDToken.ToUInt32(), initValue.Value);
			dynocode.CreateEnumerator();
			foreach (var val in dynocode) {
				emu.Push(new Int32Value(val));
				for (int i = loopStart; i < loopEnd; i++)
					emu.Emulate(instrs[i]);
			}

			index = newIndex - 1;
			return true;
		}

		static int GetIndexOfCall(IList<Instruction> instrs, int startIndex, int endIndex, string returnType, string parameters) {
			if (startIndex < 0 || endIndex < 0)
				return -1;
			for (int i = startIndex; i < endIndex; i++) {
				var instr = instrs[i];
				if (instr.OpCode.Code != Code.Call && instr.OpCode.Code != Code.Callvirt)
					continue;
				var method = instr.Operand as IMethod;
				if (!DotNetUtils.IsMethod(method, returnType, parameters))
					continue;

				return i;
			}
			return -1;
		}

		Local GetDCLoopLocal(int start, int end) {
			var instrs = stringMethod.Body.Instructions;
			for (int i = start; i < end - 1; i++) {
				if (instrs[i].OpCode.Code != Code.Xor)
					continue;
				var stloc = instrs[i + 1];
				if (!stloc.IsStloc())
					continue;
				return stloc.GetLocal(stringMethod.Body.Variables);
			}
			return null;
		}

		static int FindLeave(IList<Instruction> instrs, int index) {
			for (int i = index; i < instrs.Count; i++) {
				if (instrs[i].OpCode.Code == Code.Leave_S || instrs[i].OpCode.Code == Code.Leave)
					return i;
			}
			return -1;
		}

		static int FindInitIntsIndex(MethodDef method, out bool initializedAll) {
			initializedAll = false;

			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count; i++) {
				var ldnull = instrs[i];
				if (ldnull.OpCode.Code != Code.Ldnull
					&& ldnull.OpCode.Code != Code.Call)
					continue;

				var stsfld = instrs[i + 1];
				if (stsfld.OpCode.Code != Code.Stsfld)
					continue;

				var storeField = stsfld.Operand as FieldDef;
				if (storeField == null || storeField.FieldType.FullName != "System.Byte[]")
					continue;

				var instr = instrs[i + 2];
				if (instr.OpCode.Code == Code.Ldsfld) {
					var loadField = instr.Operand as FieldDef;
					if (loadField == null || loadField.FieldType.GetElementType() != ElementType.I4)
						continue;
				}
				else if (instr.IsLdcI4()) {
					initializedAll = true;
				}
				else
					continue;

				return i + 2;	//+2 or else we would land on the call method
			}

			return -1;
		}

		bool FindIntsCctor(MethodDef cctor) {
			int index = 0;

			//since somewhere after eaz 5.2, there are 2 calls to GetFrame, we need the last one
			if (!FindLastCallGetFrame(cctor, ref index))
				return FindIntsCctor2(cctor);

			int tmp3 = 0;
			var constantsReader = new EfConstantsReader(cctor);
			if (!constantsReader.GetNextInt32(ref index, out int tmp1))
				return false;
			if (tmp1 == 0 && !constantsReader.GetNextInt32(ref index, out tmp1))
				return false;
			if (!constantsReader.GetNextInt32(ref index, out int tmp2))
				return false;
			if (tmp2 == 0 && !constantsReader.GetNextInt32(ref index, out tmp2))
				return false;

			index = 0;
			var instrs = cctor.Body.Instructions;
			while (index < instrs.Count) {
				if (!constantsReader.GetNextInt32(ref index, out int tmp4))
					break;
				if (index < instrs.Count && instrs[index].IsLdloc())
					tmp3 = tmp4;
			}

			i1 = tmp1 ^ tmp2 ^ tmp3;
			return true;
		}

		// Compact Framework doesn't have StackFrame
		bool FindIntsCctor2(MethodDef cctor) {
			int index = 0;
			var instrs = cctor.Body.Instructions;
			var constantsReader = new EfConstantsReader(cctor);
			while (index >= 0) {
				if (!constantsReader.GetNextInt32(ref index, out int val))
					break;
				if (index < instrs.Count && instrs[index].OpCode.Code == Code.Add) {
					i1 = val;
					return true;
				}
			}

			return false;
		}

		bool FindInt3() {
			if (!isV32OrLater)
				return FindInt3Old();
			return FindInt3New();
		}

		// <= 3.1
		bool FindInt3Old() {
			var instrs = stringMethod.Body.Instructions;
			for (int i = 0; i < instrs.Count - 4; i++) {
				var ldarg0 = instrs[i];
				if (ldarg0.OpCode.Code != Code.Ldarg_0)
					continue;

				var ldci4 = instrs[i + 1];
				if (!ldci4.IsLdcI4())
					continue;

				int index = i + 1;
				if (!stringMethodConsts.GetInt32(ref index, out int value))
					continue;
				if (index >= instrs.Count)
					continue;

				if (instrs[index].OpCode.Code != Code.Xor)
					continue;

				i3 = value;
				return true;
			}

			return false;
		}

		// 3.2+
		bool FindInt3New() {
			var instrs = stringMethod.Body.Instructions;
			for (int i = 0; i < instrs.Count; i++) {
				int index = i;

				var ldarg0 = instrs[index++];
				if (ldarg0.OpCode.Code != Code.Ldarg_0)
					continue;

				if (!stringMethodConsts.GetInt32(ref index, out int value))
					continue;

				if (index + 3 >= instrs.Count)
					break;

				if (instrs[index++].OpCode.Code != Code.Xor)
					continue;

				if (!instrs[index++].IsLdloc())
					continue;

				if (instrs[index++].OpCode.Code != Code.Xor)
					continue;

				i3 = value;
				if (!FindInt6(index++))
					return false;
				return true;
			}

			return false;
		}

		// v3.3.134+
		bool FindInt6(int index) {
			index = GetNextLdci4InSameBlock(index);
			if (index < 0)
				return true;

			return stringMethodConsts.GetNextInt32(ref index, out i6);
		}

		bool FindInt4() {
			int index = 0;
			if (!FindCallReadInt32(ref index))
				return false;
			if (!stringMethodConsts.GetNextInt32(ref index, out i4))
				return false;

			return true;
		}

		int GetNextLdci4InSameBlock(int index) {
			var instrs = stringMethod.Body.Instructions;
			for (int i = index; i < instrs.Count; i++) {
				var instr = instrs[i];
				if (instr.OpCode.FlowControl != FlowControl.Next)
					return -1;
				if (stringMethodConsts.IsLoadConstantInt32(instr))
					return i;
			}

			return -1;
		}

		bool FindInt5() {
			int index = -1;
			while (true) {
				index++;
				if (!FindCallReadBytes(ref index))
					return false;
				if (index <= 0)
					continue;
				var ldci4 = stringMethod.Body.Instructions[index - 1];
				if (!ldci4.IsLdcI4())
					continue;
				if (ldci4.GetLdcI4Value() != 4)
					continue;
				if (!stringMethodConsts.GetNextInt32(ref index, out i5))
					return false;

				return true;
			}
		}

		static bool CallsGetPublicKeyToken(MethodDef method) {
			int index = 0;
			return FindCall(method, ref index, "System.Byte[] System.Reflection.AssemblyName::GetPublicKeyToken()");
		}

		bool FindCallReadInt16(ref int index) =>
			FindCall(stringMethod, ref index, streamHelperType == null ? "System.Int16 System.IO.BinaryReader::ReadInt16()" : streamHelperType.readInt16Method.FullName);

		bool FindCallReadInt32(ref int index) =>
			FindCall(stringMethod, ref index, streamHelperType == null ? "System.Int32 System.IO.BinaryReader::ReadInt32()" : streamHelperType.readInt32Method.FullName);

		bool FindCallReadBytes(ref int index) =>
			FindCall(stringMethod, ref index, streamHelperType == null ? "System.Byte[] System.IO.BinaryReader::ReadBytes(System.Int32)" : streamHelperType.readBytesMethod.FullName);

		static bool FindLastCallGetFrame(MethodDef method, ref int index) =>
			FindLastCall(method, ref index, "System.Diagnostics.StackFrame System.Diagnostics.StackTrace::GetFrame(System.Int32)");

		static bool FindLastCall(MethodDef method, ref int index, string methodFullName) {
			bool found;
			bool foundOnce = false;
			int tempIndex = index;

			//keep doing until findcall returns false (we reached the end of the method)
			do {
				found = FindCall(method, ref tempIndex, methodFullName);

				//indicate we did find one
				if (found) {
					foundOnce = true;
					index = tempIndex;

					//to not get stuck on the same instruction
					tempIndex++;
				}
			} while (found);
			return foundOnce;
		}

		static bool FindCall(MethodDef method, ref int index, string methodFullName) {
			for (; index < method.Body.Instructions.Count; index++) {
				if (!FindCallvirt(method, ref index))
					return false;

				var calledMethod = method.Body.Instructions[index].Operand as IMethod;
				if (calledMethod == null)
					continue;
				if (calledMethod.ToString() != methodFullName)
					continue;

				return true;
			}
			return false;
		}

		static bool FindCallvirt(MethodDef method, ref int index) {
			var instrs = method.Body.Instructions;
			for (; index < instrs.Count; index++) {
				var instr = instrs[index];
				if (instr.OpCode.Code != Code.Callvirt)
					continue;

				return true;
			}

			return false;
		}

		public void Dispose() => CloseServer();

		public void CloseServer() {
			if (dynocode != null)
				dynocode.Dispose();
			dynocode = null;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Eazfuscator_NET/VersionDetector.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet.Emit;
using dnlib.DotNet;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Eazfuscator_NET {
	class VersionDetector {
		StringDecrypter stringDecrypter;
		FrameworkType frameworkType;

		public VersionDetector(ModuleDefMD module, StringDecrypter stringDecrypter) {
			this.stringDecrypter = stringDecrypter;
			frameworkType = DotNetUtils.GetFrameworkType(module);
		}

		public string Detect() {
			var decryptStringType = stringDecrypter.Type;
			var decryptStringMethod = stringDecrypter.Method;
			if (decryptStringType == null || decryptStringMethod == null)
				return null;

			var otherMethods = new List<MethodDef>();
			MethodDef cctor = null;
			foreach (var method in decryptStringType.Methods) {
				if (method == decryptStringMethod)
					continue;
				if (method.Name == ".cctor")
					cctor = method;
				else
					otherMethods.Add(method);
			}
			if (cctor == null)
				return null;

			bool hasConstantM2 = DeobUtils.HasInteger(decryptStringMethod, -2);

			/////////////////////////////////////////////////////////////////
			/////////////////////////////////////////////////////////////////
			/////////////////////////////////////////////////////////////////

			var fields11 = new string[] {
				"System.Collections.Generic.Dictionary`2<System.Int32,System.String>",
				"System.IO.BinaryReader",
				"System.Byte[]",
				"System.Int16",
				"System.Boolean",
			};
			var locals11 = CreateLocalsArray(
				"System.Boolean",
				"System.Byte[]",
				"System.Char[]",
				"System.Int16",
				"System.Int32",
				"System.Reflection.Assembly",
				"System.String"
			);
			if (otherMethods.Count == 0 &&
				decryptStringType.NestedTypes.Count == 0 &&
				!hasConstantM2 &&
				!decryptStringMethod.IsNoInlining &&
				decryptStringMethod.IsPublic &&
				decryptStringMethod.IsSynchronized &&
				decryptStringMethod.Body.MaxStack >= 35 &&
				decryptStringMethod.Body.MaxStack <= 50 &&
				decryptStringMethod.Body.ExceptionHandlers.Count == 0 &&
				new LocalTypes(decryptStringMethod).Exactly(locals11) &&
				CheckTypeFields(fields11)) {
				return "1.1 - 1.2";
			}

			/////////////////////////////////////////////////////////////////
			/////////////////////////////////////////////////////////////////
			/////////////////////////////////////////////////////////////////

			var fields13 = new string[] {
				"System.Collections.Generic.Dictionary`2<System.Int32,System.String>",
				"System.IO.BinaryReader",
				"System.Byte[]",
				"System.Int16",
				"System.Boolean",
				"System.Byte[]",
			};
			var locals13 = CreateLocalsArray(
				"System.Boolean",
				"System.Byte",
				"System.Byte[]",
				"System.Char[]",
				"System.Int16",
				"System.Int32",
				"System.Reflection.Assembly",
				"System.String"
			);
			if (otherMethods.Count == 0 &&
				decryptStringType.NestedTypes.Count == 0 &&
				!hasConstantM2 &&
				!decryptStringMethod.IsNoInlining &&
				decryptStringMethod.IsPublic &&
				decryptStringMethod.IsSynchronized &&
				decryptStringMethod.Body.MaxStack >= 35 &&
				decryptStringMethod.Body.MaxStack <= 50 &&
				decryptStringMethod.Body.ExceptionHandlers.Count == 0 &&
				new LocalTypes(decryptStringMethod).Exactly(locals13) &&
				CheckTypeFields(fields13)) {
				return "1.3";
			}

			/////////////////////////////////////////////////////////////////
			/////////////////////////////////////////////////////////////////
			/////////////////////////////////////////////////////////////////

			var fields14 = new string[] {
				"System.Collections.Generic.Dictionary`2<System.Int32,System.String>",
				"System.IO.BinaryReader",
				"System.Byte[]",
				"System.Int16",
				"System.Boolean",
				"System.Byte[]",
			};
			var locals14 = CreateLocalsArray(
				"System.Boolean",
				"System.Byte",
				"System.Byte[]",
				"System.Char[]",
				"System.Int16",
				"System.Int32",
				"System.Reflection.Assembly",
				"System.String"
			);
			if (otherMethods.Count == 0 &&
				decryptStringType.NestedTypes.Count == 0 &&
				!hasConstantM2 &&
				!decryptStringMethod.IsNoInlining &&
				decryptStringMethod.IsPublic &&
				decryptStringMethod.IsSynchronized &&
				decryptStringMethod.Body.MaxStack >= 150 &&
				decryptStringMethod.Body.MaxStack <= 200 &&
				decryptStringMethod.Body.ExceptionHandlers.Count == 0 &&
				new LocalTypes(decryptStringMethod).Exactly(locals14) &&
				CheckTypeFields(fields14)) {
				return "1.4 - 2.3";
			}

			/////////////////////////////////////////////////////////////////
			/////////////////////////////////////////////////////////////////
			/////////////////////////////////////////////////////////////////

			var fields24 = new string[] {
				"System.Collections.Generic.Dictionary`2<System.Int32,System.String>",
				"System.IO.BinaryReader",
				"System.Byte[]",
				"System.Int16",
				"System.Boolean",
				"System.Byte[]",
			};
			var locals24 = CreateLocalsArray(
				"System.Boolean",
				"System.Byte",
				"System.Byte[]",
				"System.Char[]",
				"System.Int16",
				"System.Int32",
				"System.Reflection.Assembly",
				"System.Reflection.AssemblyName",
				"System.String"
			);
			if (otherMethods.Count == 0 &&
				decryptStringType.NestedTypes.Count == 0 &&
				!hasConstantM2 &&
				!decryptStringMethod.IsNoInlining &&
				decryptStringMethod.IsPublic &&
				decryptStringMethod.IsSynchronized &&
				decryptStringMethod.Body.MaxStack >= 1 &&
				decryptStringMethod.Body.MaxStack <= 8 &&
				decryptStringMethod.Body.ExceptionHandlers.Count == 0 &&
				new LocalTypes(decryptStringMethod).Exactly(locals24) &&
				CheckTypeFields(fields24)) {
				return "2.4 - 2.5";
			}

			/////////////////////////////////////////////////////////////////
			/////////////////////////////////////////////////////////////////
			/////////////////////////////////////////////////////////////////

			var fields26 = new string[] {
				"System.Collections.Generic.Dictionary`2<System.Int32,System.String>",
				"System.IO.BinaryReader",
				"System.Byte[]",
				"System.Int16",
				"System.Boolean",
				"System.Byte[]",
			};
			var locals26 = CreateLocalsArray(
				"System.Boolean",
				"System.Byte",
				"System.Byte[]",
				"System.Char[]",
				"System.Collections.Generic.Dictionary`2<System.Int32,System.String>",
				"System.Int16",
				"System.Int32",
				"System.Reflection.Assembly",
				"System.Reflection.AssemblyName",
				"System.String"
			);
			if (otherMethods.Count == 0 &&
				decryptStringType.NestedTypes.Count == 0 &&
				!hasConstantM2 &&
				!decryptStringMethod.IsNoInlining &&
				decryptStringMethod.IsPublic &&
				!decryptStringMethod.IsSynchronized &&
				decryptStringMethod.Body.MaxStack >= 1 &&
				decryptStringMethod.Body.MaxStack <= 8 &&
				decryptStringMethod.Body.ExceptionHandlers.Count == 1 &&
				new LocalTypes(decryptStringMethod).Exactly(locals26) &&
				CheckTypeFields(fields26)) {
				return "2.6";
			}

			/////////////////////////////////////////////////////////////////
			/////////////////////////////////////////////////////////////////
			/////////////////////////////////////////////////////////////////

			var fields27 = new string[] {
				"System.Collections.Generic.Dictionary`2<System.Int32,System.String>",
				"System.IO.BinaryReader",
				"System.Byte[]",
				"System.Int16",
				"System.Boolean",
				"System.Byte[]",
			};
			var locals27 = CreateLocalsArray(
				"System.Boolean",
				"System.Byte",
				"System.Byte[]",
				"System.Char[]",
				"System.Collections.Generic.Dictionary`2<System.Int32,System.String>",
				"System.Int16",
				"System.Int32",
				"System.Reflection.Assembly",
				"System.Reflection.AssemblyName",
				"System.String"
			);
			if (otherMethods.Count == 0 &&
				decryptStringType.NestedTypes.Count == 0 &&
				!hasConstantM2 &&
				decryptStringMethod.IsNoInlining &&
				decryptStringMethod.IsPublic &&
				!decryptStringMethod.IsSynchronized &&
				decryptStringMethod.Body.MaxStack >= 1 &&
				decryptStringMethod.Body.MaxStack <= 8 &&
				decryptStringMethod.Body.ExceptionHandlers.Count == 1 &&
				new LocalTypes(decryptStringMethod).Exactly(locals27) &&
				CheckTypeFields(fields27)) {
				return "2.7";
			}

			/////////////////////////////////////////////////////////////////
			/////////////////////////////////////////////////////////////////
			/////////////////////////////////////////////////////////////////

			var fields28 = new string[] {
				"System.Collections.Generic.Dictionary`2<System.Int32,System.String>",
				"System.IO.BinaryReader",
				"System.Byte[]",
				"System.Int16",
				"System.Boolean",
				"System.Byte[]",
				"System.Boolean",
			};
			var locals28 = CreateLocalsArray(
				"System.Boolean",
				"System.Byte",
				"System.Byte[]",
				"System.Char[]",
				"System.Collections.Generic.Dictionary`2<System.Int32,System.String>",
				"System.Int16",
				"System.Int32",
				"System.Reflection.Assembly",
				"System.Reflection.AssemblyName",
				"System.String"
			);
			if (otherMethods.Count == 0 &&
				decryptStringType.NestedTypes.Count == 0 &&
				!hasConstantM2 &&
				decryptStringMethod.IsNoInlining &&
				decryptStringMethod.IsAssembly &&
				!decryptStringMethod.IsSynchronized &&
				decryptStringMethod.Body.MaxStack >= 1 &&
				decryptStringMethod.Body.MaxStack <= 8 &&
				decryptStringMethod.Body.ExceptionHandlers.Count == 1 &&
				new LocalTypes(decryptStringMethod).Exactly(locals28) &&
				CheckTypeFields(fields28)) {
				return "2.8";
			}

			/////////////////////////////////////////////////////////////////
			/////////////////////////////////////////////////////////////////
			/////////////////////////////////////////////////////////////////

			var fields29 = new string[] {
				"System.Collections.Generic.Dictionary`2<System.Int32,System.String>",
				"System.IO.BinaryReader",
				"System.Byte[]",
				"System.Int16",
				"System.Int32",
				"System.Byte[]",
			};
			var locals29 = CreateLocalsArray(
				"System.Boolean",
				"System.Byte",
				"System.Byte[]",
				"System.Char[]",
				"System.Collections.Generic.Dictionary`2<System.Int32,System.String>",
				"System.Diagnostics.StackFrame",
				"System.Diagnostics.StackTrace",
				"System.Int16",
				"System.Int32",
				"System.IO.Stream",
				"System.Reflection.Assembly",
				"System.Reflection.AssemblyName",
				"System.Reflection.MethodBase",
				"System.String",
				"System.Type"
			);
			if (otherMethods.Count == 0 &&
				decryptStringType.NestedTypes.Count == 0 &&
				!hasConstantM2 &&
				decryptStringMethod.IsNoInlining &&
				decryptStringMethod.IsAssembly &&
				!decryptStringMethod.IsSynchronized &&
				decryptStringMethod.Body.MaxStack >= 1 &&
				decryptStringMethod.Body.MaxStack <= 8 &&
				(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&
				new LocalTypes(decryptStringMethod).Exactly(locals29) &&
				CheckTypeFields(fields29)) {
				return "2.9";
			}

			/////////////////////////////////////////////////////////////////
			/////////////////////////////////////////////////////////////////
			/////////////////////////////////////////////////////////////////

			var fields30 = new string[] {
				"System.Collections.Generic.Dictionary`2<System.Int32,System.String>",
				"System.IO.BinaryReader",
				"System.Byte[]",
				"System.Int16",
				"System.Int32",
				"System.Byte[]",
			};
			var locals30 = CreateLocalsArray(
				"System.Boolean",
				"System.Byte",
				"System.Byte[]",
				"System.Char[]",
				"System.Collections.Generic.Dictionary`2<System.Int32,System.String>",
				"System.Diagnostics.StackFrame",
				"System.Diagnostics.StackTrace",
				"System.Int16",
				"System.Int32",
				"System.IO.Stream",
				"System.Reflection.Assembly",
				"System.Reflection.AssemblyName",
				"System.Reflection.MethodBase",
				"System.String",
				"System.Type"
			);
			var olocals30 = CreateLocalsArray(
				"System.Int32"
			);
			if (otherMethods.Count == 1 &&
				decryptStringType.NestedTypes.Count == 0 &&
				DotNetUtils.IsMethod(otherMethods[0], "System.Int32", "(System.Byte[],System.Int32,System.Byte[])") &&
				otherMethods[0].IsPrivate &&
				otherMethods[0].IsStatic &&
				new LocalTypes(otherMethods[0]).Exactly(olocals30) &&
				!hasConstantM2 &&
				decryptStringMethod.IsNoInlining &&
				decryptStringMethod.IsAssembly &&
				!decryptStringMethod.IsSynchronized &&
				decryptStringMethod.Body.MaxStack >= 1 &&
				decryptStringMethod.Body.MaxStack <= 8 &&
				(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&
				new LocalTypes(decryptStringMethod).Exactly(locals30) &&
				CheckTypeFields(fields30)) {
				return "3.0";
			}

			/////////////////////////////////////////////////////////////////
			/////////////////////////////////////////////////////////////////
			/////////////////////////////////////////////////////////////////

			var fields31 = new string[] {
				"System.Collections.Generic.Dictionary`2<System.Int32,System.String>",
				"System.IO.BinaryReader",
				"System.Byte[]",
				"System.Int16",
				"System.Int32",
				"System.Byte[]",
			};
			var locals31 = CreateLocalsArray(
				"System.Boolean",
				"System.Byte",
				"System.Byte[]",
				"System.Char[]",
				"System.Collections.Generic.Dictionary`2<System.Int32,System.String>",
				"System.Diagnostics.StackFrame",
				"System.Diagnostics.StackTrace",
				"System.Int16",
				"System.Int32",
				"System.IO.Stream",
				"System.Reflection.Assembly",
				"System.Reflection.AssemblyName",
				"System.Reflection.MethodBase",
				"System.String",
				"System.Type"
			);
			var olocals31 = CreateLocalsArray(
				"System.Int32"
			);
			if (otherMethods.Count == 1 &&
				decryptStringType.NestedTypes.Count == 0 &&
				DotNetUtils.IsMethod(otherMethods[0], "System.Int32", "(System.Byte[],System.Int32,System.Byte[])") &&
				otherMethods[0].IsPrivate &&
				otherMethods[0].IsStatic &&
				new LocalTypes(otherMethods[0]).Exactly(olocals31) &&
				hasConstantM2 &&
				decryptStringMethod.IsNoInlining &&
				decryptStringMethod.IsAssembly &&
				!decryptStringMethod.IsSynchronized &&
				decryptStringMethod.Body.MaxStack >= 1 &&
				decryptStringMethod.Body.MaxStack <= 8 &&
				(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&
				new LocalTypes(decryptStringMethod).Exactly(locals31) &&
				CheckTypeFields(fields31)) {
				return "3.1";
			}

			/////////////////////////////////////////////////////////////////
			/////////////////////////////////////////////////////////////////
			/////////////////////////////////////////////////////////////////

			var fields32 = new string[] {
				"System.Collections.Generic.Dictionary`2<System.Int32,System.String>",
				"System.IO.BinaryReader",
				"System.Byte[]",
				"System.Int16",
				"System.Int32",
				"System.Byte[]",
				"System.Int32",
			};
			var locals32 = CreateLocalsArray(
				"System.Boolean",
				"System.Byte",
				"System.Byte[]",
				"System.Char[]",
				"System.Collections.Generic.Dictionary`2<System.Int32,System.String>",
				"System.Diagnostics.StackFrame",
				"System.Diagnostics.StackTrace",
				"System.Int16",
				"System.Int32",
				"System.Int64",
				"System.IO.Stream",
				"System.Reflection.Assembly",
				"System.Reflection.AssemblyName",
				"System.Reflection.MethodBase",
				"System.String",
				"System.Type"
			);
			var olocals32 = CreateLocalsArray(
				"System.Int32"
			);
			if (otherMethods.Count == 1 &&
				decryptStringType.NestedTypes.Count == 0 &&
				DotNetUtils.IsMethod(otherMethods[0], "System.Void", "(System.Byte[],System.Int32,System.Byte[])") &&
				otherMethods[0].IsPrivate &&
				otherMethods[0].IsStatic &&
				new LocalTypes(otherMethods[0]).Exactly(olocals32) &&
				hasConstantM2 &&
				decryptStringMethod.IsNoInlining &&
				decryptStringMethod.IsAssembly &&
				!decryptStringMethod.IsSynchronized &&
				decryptStringMethod.Body.MaxStack >= 1 &&
				decryptStringMethod.Body.MaxStack <= 8 &&
				(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&
				new LocalTypes(decryptStringMethod).Exactly(locals32) &&
				CheckTypeFields(fields32)) {
				return "3.2";
			}

			/////////////////////////////////////////////////////////////////
			/////////////////////////////////////////////////////////////////
			/////////////////////////////////////////////////////////////////

			if (decryptStringType.NestedTypes.Count == 1) {
				var fields33 = new string[] {
					"System.Collections.Generic.Dictionary`2<System.Int32,System.String>",
					"System.IO.BinaryReader",
					"System.Byte[]",
					"System.Int16",
					"System.Int32",
					"System.Byte[]",
					"System.Int32",
					"System.Int32",
					decryptStringType.NestedTypes[0].FullName,
				};
				var locals33 = CreateLocalsArray(
					"System.Boolean",
					"System.Byte",
					"System.Byte[]",
					"System.Char[]",
					"System.Collections.Generic.Dictionary`2<System.Int32,System.String>",
					"System.Diagnostics.StackFrame",
					"System.Diagnostics.StackTrace",
					"System.Int16",
					"System.Int32",
					"System.Int64",
					"System.IO.Stream",
					"System.Reflection.Assembly",
					"System.Reflection.AssemblyName",
					"System.Reflection.MethodBase",
					"System.String",
					"System.Type"
				);
				var olocals33 = CreateLocalsArray(
					"System.Int32"
				);
				if (otherMethods.Count == 1 &&
					decryptStringType.NestedTypes.Count == 1 &&
					DotNetUtils.IsMethod(otherMethods[0], "System.Void", "(System.Byte[],System.Int32,System.Byte[])") &&
					otherMethods[0].IsPrivate &&
					otherMethods[0].IsStatic &&
					new LocalTypes(otherMethods[0]).Exactly(olocals33) &&
					hasConstantM2 &&
					decryptStringMethod.IsNoInlining &&
					decryptStringMethod.IsAssembly &&
					!decryptStringMethod.IsSynchronized &&
					decryptStringMethod.Body.MaxStack >= 1 &&
					decryptStringMethod.Body.MaxStack <= 8 &&
					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&
					new LocalTypes(decryptStringMethod).Exactly(locals33) &&
					CheckTypeFields(fields33)) {
					return "3.3.29 - 3.3.57 (BETA)";
				}
			}

			/////////////////////////////////////////////////////////////////
			/////////////////////////////////////////////////////////////////
			/////////////////////////////////////////////////////////////////

			if (decryptStringType.NestedTypes.Count == 3) {
				var fields33 = new string[] {
					GetNestedTypeName(0),
					GetNestedTypeName(1),
					"System.Byte[]",
					"System.Int16",
					"System.Int32",
					"System.Byte[]",
					"System.Int32",
					"System.Int32",
					GetNestedTypeName(2),
				};
				var locals33 = CreateLocalsArray(
					"System.Boolean",
					"System.Byte",
					"System.Byte[]",
					"System.Char[]",
					GetNestedTypeName(0),
					"System.Diagnostics.StackFrame",
					"System.Diagnostics.StackTrace",
					"System.Int16",
					"System.Int32",
					"System.Int64",
					"System.IO.Stream",
					"System.Reflection.Assembly",
					"System.Reflection.AssemblyName",
					"System.Reflection.MethodBase",
					"System.String",
					"System.Type"
				);
				var olocals33 = CreateLocalsArray(
					"System.Int32"
				);
				if (otherMethods.Count == 1 &&
					decryptStringType.NestedTypes.Count == 3 &&
					DotNetUtils.IsMethod(otherMethods[0], "System.Void", "(System.Byte[],System.Int32,System.Byte[])") &&
					otherMethods[0].IsPrivate &&
					otherMethods[0].IsStatic &&
					new LocalTypes(otherMethods[0]).Exactly(olocals33) &&
					decryptStringMethod.IsNoInlining &&
					decryptStringMethod.IsAssembly &&
					!decryptStringMethod.IsSynchronized &&
					decryptStringMethod.Body.MaxStack >= 1 &&
					decryptStringMethod.Body.MaxStack <= 8 &&
					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&
					new LocalTypes(decryptStringMethod).Exactly(locals33) &&
					CheckTypeFields(fields33)) {
					return "3.3";
				}

				/////////////////////////////////////////////////////////////////
				/////////////////////////////////////////////////////////////////
				/////////////////////////////////////////////////////////////////

				var fields33_149 = new string[] {
					GetNestedTypeName(0),
					GetNestedTypeName(1),
					"System.Byte[]",
					"System.Int16",
					"System.Int32",
					"System.Byte[]",
					"System.Int32",
					"System.Int32",
					GetNestedTypeName(2),
				};
				var locals33_149 = CreateLocalsArray(
					"System.Boolean",
					"System.Byte",
					"System.Byte[]",
					"System.Char[]",
					GetNestedTypeName(0),
					"System.Diagnostics.StackFrame",
					"System.Diagnostics.StackTrace",
					"System.Int16",
					"System.Int32",
					"System.Int64",
					"System.IO.Stream",
					"System.Reflection.Assembly",
					"System.Reflection.AssemblyName",
					"System.Reflection.MethodBase",
					"System.String",
					"System.Text.StringBuilder",
					"System.Type"
				);
				var olocals33_149 = CreateLocalsArray(
					"System.Int32"
				);
				if (otherMethods.Count == 1 &&
					decryptStringType.NestedTypes.Count == 3 &&
					DotNetUtils.IsMethod(otherMethods[0], "System.Void", "(System.Byte[],System.Int32,System.Byte[])") &&
					otherMethods[0].IsPrivate &&
					otherMethods[0].IsStatic &&
					new LocalTypes(otherMethods[0]).Exactly(olocals33_149) &&
					decryptStringMethod.IsNoInlining &&
					decryptStringMethod.IsAssembly &&
					!decryptStringMethod.IsSynchronized &&
					decryptStringMethod.Body.MaxStack >= 1 &&
					decryptStringMethod.Body.MaxStack <= 8 &&
					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&
					new LocalTypes(decryptStringMethod).Exactly(locals33_149) &&
					CheckTypeFields2(fields33_149)) {
					return "3.3.149 - 3.4"; // 3.3.149+ (but not SL or CF)
				}

				/////////////////////////////////////////////////////////////////
				/////////////////////////////////////////////////////////////////
				/////////////////////////////////////////////////////////////////

				var fields35 = new string[] {
					GetNestedTypeName(0),
					GetNestedTypeName(1),
					"System.Byte[]",
					"System.Int16",
					"System.Int32",
					"System.Byte[]",
					"System.Int32",
					"System.Int32",
					GetNestedTypeName(2),
				};
				var locals35 = CreateLocalsArray(
					"System.Boolean",
					"System.Byte",
					"System.Byte[]",
					"System.Char[]",
					"System.Collections.Generic.IEnumerator`1<System.Int32>",
					GetNestedTypeName(0),
					"System.Diagnostics.StackFrame",
					"System.Diagnostics.StackTrace",
					"System.Int16",
					"System.Int32",
					"System.Int64",
					"System.IO.Stream",
					"System.Reflection.Assembly",
					"System.Reflection.AssemblyName",
					"System.Reflection.MethodBase",
					"System.String",
					"System.Text.StringBuilder",
					"System.Type"
				);
				var olocals35 = CreateLocalsArray(
					"System.Int32"
				);
				if (otherMethods.Count == 1 &&
					decryptStringType.NestedTypes.Count == 3 &&
					DotNetUtils.IsMethod(otherMethods[0], "System.Void", "(System.Byte[],System.Int32,System.Byte[])") &&
					otherMethods[0].IsPrivate &&
					otherMethods[0].IsStatic &&
					new LocalTypes(otherMethods[0]).Exactly(olocals35) &&
					decryptStringMethod.IsNoInlining &&
					decryptStringMethod.IsAssembly &&
					!decryptStringMethod.IsSynchronized &&
					decryptStringMethod.Body.MaxStack >= 1 &&
					decryptStringMethod.Body.MaxStack <= 8 &&
					decryptStringMethod.Body.ExceptionHandlers.Count >= 2 &&
					new LocalTypes(decryptStringMethod).All(locals35) &&
					CheckTypeFields2(fields35)) {
					return "3.5 - 4.2";
				}

				/////////////////////////////////////////////////////////////////
				/////////////////////////////////////////////////////////////////
				/////////////////////////////////////////////////////////////////

				var fields43 = new string[] {
					GetNestedTypeName(0),
					GetNestedTypeName(1),
					"System.Byte[]",
					"System.Int16",
					"System.Int32",
					"System.Byte[]",
					"System.Int32",
					"System.Int32",
					GetNestedTypeName(2),
				};
				var locals43 = CreateLocalsArray(
					"System.Boolean",
					"System.Byte",
					"System.Byte[]",
					"System.Char[]",
					FindEnumeratorName(decryptStringMethod),
					GetNestedTypeName(0),
					"System.Diagnostics.StackFrame",
					"System.Diagnostics.StackTrace",
					"System.Int16",
					"System.Int32",
					"System.Int64",
					"System.IO.Stream",
					"System.Reflection.Assembly",
					"System.Reflection.AssemblyName",
					"System.Reflection.MethodBase",
					"System.String",
					"System.Text.StringBuilder",
					"System.Type"
				);
				var olocals43 = CreateLocalsArray(
					"System.Int32"
				);
				if (otherMethods.Count == 1 &&
					decryptStringType.NestedTypes.Count == 3 &&
					DotNetUtils.IsMethod(otherMethods[0], "System.Void", "(System.Byte[],System.Int32,System.Byte[])") &&
					otherMethods[0].IsPrivate &&
					otherMethods[0].IsStatic &&
					new LocalTypes(otherMethods[0]).Exactly(olocals43) &&
					decryptStringMethod.IsNoInlining &&
					decryptStringMethod.IsAssembly &&
					!decryptStringMethod.IsSynchronized &&
					decryptStringMethod.Body.MaxStack >= 1 &&
					decryptStringMethod.Body.MaxStack <= 8 &&
					decryptStringMethod.Body.ExceptionHandlers.Count >= 2 &&
					new LocalTypes(decryptStringMethod).All(locals43) &&
					CheckTypeFields2(fields43)) {
					return "4.3 - 4.9";
				}

				/////////////////////////////////////////////////////////////////
				/////////////////////////////////////////////////////////////////
				/////////////////////////////////////////////////////////////////

				var fields50 = new string[] {
					GetNestedTypeName(0),
					GetNestedTypeName(1),
					"System.Byte[]",
					"System.Int16",
					"System.Int32",
					"System.Byte[]",
					"System.Int32",
					"System.Int32",
					GetNestedTypeName(2),
				};
				var locals50 = CreateLocalsArray(
					// GetNestedTypeName(2) // One of the nested types is the first local (non-enum type)
					"System.String",
					"System.String"
				);
				var otherMethod50 = otherMethods.Find((m) => {
					return DotNetUtils.IsMethod(m, "System.Void", "(System.Byte[],System.Int32,System.Byte[])");
				});
				decryptStringMethod = stringDecrypter.RealMethod;
				if (stringDecrypter.HasRealMethod &&
					otherMethods.Count == 2 &&
					otherMethod50 != null &&
					decryptStringType.NestedTypes.Count == 3 &&
					otherMethod50.IsPrivate &&
					otherMethod50.IsStatic &&
					decryptStringMethod.IsNoInlining &&
					decryptStringMethod.IsAssembly &&
					!decryptStringMethod.IsSynchronized &&
					decryptStringMethod.Body.MaxStack >= 1 &&
					decryptStringMethod.Body.MaxStack <= 8 &&
					decryptStringMethod.Body.ExceptionHandlers.Count == 1 &&
					new LocalTypes(decryptStringMethod).All(locals50) &&
					CheckTypeFields2(fields50)) {
					foreach (var inst in stringDecrypter.Method.Body.Instructions) {
						if (inst.OpCode.Code == Code.Cgt_Un)
							return "5.1";
					}
					return "5.0";
				}

				if (stringDecrypter.HasRealMethod &&
				    otherMethods.Count == 5 &&
				    otherMethod50 != null &&
				    decryptStringType.NestedTypes.Count == 3 &&
				    otherMethod50.IsPrivate &&
				    otherMethod50.IsStatic &&
				    decryptStringMethod.IsNoInlining &&
				    decryptStringMethod.IsAssembly &&
				    !decryptStringMethod.IsSynchronized &&
				    decryptStringMethod.Body.MaxStack >= 1 &&
				    decryptStringMethod.Body.MaxStack <= 8 &&
				    decryptStringMethod.Body.ExceptionHandlers.Count == 1) {
					return "5.2-5.8";
				}
			}

			return null;
		}

		static string FindEnumeratorName(MethodDef method) {
			foreach (var local in method.Body.Variables) {
				var gis = local.Type as GenericInstSig;
				if (gis == null)
					continue;
				if (gis.FullName == "System.Collections.Generic.IEnumerator`1<System.Int32>")
					continue;
				if (gis.GenericArguments.Count != 1)
					continue;
				if (gis.GenericArguments[0].GetFullName() != "System.Int32")
					continue;

				return gis.FullName;
			}
			return null;
		}

		TypeDef GetNestedType(int n) {
			var type = stringDecrypter.Type;

			if (n == 0) {
				foreach (var nested in type.NestedTypes) {
					if (nested.NestedTypes.Count == 1)
						return nested;
				}
			}
			else if (n == 1) {
				foreach (var nested in type.NestedTypes) {
					if (nested.IsEnum)
						continue;
					if (nested.NestedTypes.Count != 0)
						continue;
					return nested;
				}
			}
			else if (n == 2) {
				foreach (var nested in type.NestedTypes) {
					if (nested.IsEnum)
						return nested;
				}
			}
			return null;
		}

		string GetNestedTypeName(int n) => GetNestedType(n)?.FullName;

		bool CheckTypeFields(string[] fieldTypes) {
			if (fieldTypes.Length != stringDecrypter.Type.Fields.Count)
				return false;
			for (int i = 0; i < fieldTypes.Length; i++) {
				if (fieldTypes[i] != stringDecrypter.Type.Fields[i].FieldType.FullName)
					return false;
			}
			return true;
		}

		bool CheckTypeFields2(string[] fieldTypes) {
			if (fieldTypes.Length != stringDecrypter.Type.Fields.Count)
				return false;

			var fieldTypes1 = new List<string>(fieldTypes);
			fieldTypes1.Sort();

			var fieldTypes2 = new List<string>();
			foreach (var f in stringDecrypter.Type.Fields)
				fieldTypes2.Add(f.FieldType.FullName);
			fieldTypes2.Sort();

			for (int i = 0; i < fieldTypes1.Count; i++) {
				if (fieldTypes1[i] != fieldTypes2[i])
					return false;
			}
			return true;
		}

		static Dictionary<string, bool> removeLocals_cf = new Dictionary<string, bool>(StringComparer.Ordinal) {
			{ "System.Diagnostics.StackFrame", true },
			{ "System.Diagnostics.StackTrace", true },
		};
		string[] CreateLocalsArray(params string[] locals) {
			Dictionary<string, bool> removeLocals = null;
			switch (frameworkType) {
			case FrameworkType.CompactFramework:
				removeLocals = removeLocals_cf;
				break;
			}
			if (removeLocals == null)
				return locals;

			var list = new List<string>(locals.Length);
			foreach (var s in locals) {
				if (!removeLocals.ContainsKey(s))
					list.Add(s);
			}
			return list.ToArray();
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Goliath_NET/ArrayDecrypter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using dnlib.DotNet;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Goliath_NET {
	class ArrayDecrypter : DecrypterBase {
		public ArrayDecrypter(ModuleDefMD module)
			: base(module) {
		}

		static string[] requiredFields = new string[] {
			"System.Byte[]",
			"System.Collections.Generic.Dictionary`2<System.Int32,System.Byte[]>",
		};
		protected override bool CheckDecrypterType(TypeDef type) =>
			new FieldTypes(type).Exactly(requiredFields);

		protected override bool CheckDelegateInvokeMethod(MethodDef invokeMethod) =>
			DotNetUtils.IsMethod(invokeMethod, "System.Byte[]", "(System.Int32)");

		public byte[] Decrypt(MethodDef method) {
			var info = GetInfo(method);
			decryptedReader.BaseStream.Position = info.offset;
			return decryptedReader.ReadBytes(decryptedReader.ReadInt32());
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Goliath_NET/ArrayValueInliner.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet;

namespace de4dot.code.deobfuscators.Goliath_NET {
	class ArrayValueInliner : ValueInlinerBase<byte[]> {
		InitializedDataCreator initializedDataCreator;
		ModuleDefMD module;

		public ArrayValueInliner(ModuleDefMD module, InitializedDataCreator initializedDataCreator) {
			this.module = module;
			this.initializedDataCreator = initializedDataCreator;
		}

		protected override void InlineReturnValues(IList<CallResult> callResults) {
			foreach (var callResult in callResults) {
				var block = callResult.block;
				int num = callResult.callEndIndex - callResult.callStartIndex + 1;

				var arrayData = (byte[])callResult.returnValue;
				initializedDataCreator.AddInitializeArrayCode(block, callResult.callStartIndex, num, module.CorLibTypes.Byte.TypeDefOrRef, arrayData);
				Logger.v("Decrypted array: {0} bytes", arrayData.Length);
			}
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Goliath_NET/DecrypterBase.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.IO;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Goliath_NET {
	abstract class DecrypterBase {
		protected ModuleDefMD module;
		EmbeddedResource encryptedResource;
		TypeDef decrypterType;
		TypeDef delegateType;
		TypeDef delegateInitType;
		protected BinaryReader decryptedReader;
		MethodDefAndDeclaringTypeDict<Info> decrypterMethods = new MethodDefAndDeclaringTypeDict<Info>();

		protected class Info {
			public MethodDef method;
			public int offset;
			public bool referenced = false;
			public Info(MethodDef method, int offset) {
				this.method = method;
				this.offset = offset;
			}
		}

		public bool Detected => encryptedResource != null;
		public Resource EncryptedResource => encryptedResource;
		public TypeDef Type => decrypterType;
		public TypeDef DelegateInitType => delegateInitType ?? FindDelegateInitType();
		public TypeDef DelegateType => delegateType;

		public IEnumerable<TypeDef> DecrypterTypes {
			get {
				var types = new TypeDefDict<TypeDef>();
				foreach (var info in decrypterMethods.GetValues()) {
					if (info.referenced)
						types.Add(info.method.DeclaringType, info.method.DeclaringType);
				}
				return types.GetValues();
			}
		}

		public DecrypterBase(ModuleDefMD module) => this.module = module;

		protected Info GetInfo(MethodDef method) {
			var info = decrypterMethods.Find(method);
			if (info == null)
				return null;

			info.referenced = true;
			return info;
		}

		public void Find() {
			foreach (var tmp in module.Resources) {
				var resource = tmp as EmbeddedResource;
				if (resource == null)
					continue;
				if (!resource.Name.String.EndsWith(".resources", StringComparison.Ordinal))
					continue;
				SplitTypeName(resource.Name.String.Substring(0, resource.Name.String.Length - 10), out string ns, out string name);
				var type = new TypeRefUser(module, ns, name, module).Resolve();
				if (type == null)
					continue;
				if (!CheckDecrypterType(type))
					continue;

				encryptedResource = resource;
				decrypterType = type;
				break;
			}
		}

		protected abstract bool CheckDecrypterType(TypeDef type);

		void SplitTypeName(string fullName, out string ns, out string name) {
			int index = fullName.LastIndexOf('.');
			if (index < 0) {
				ns = "";
				name = fullName;
			}
			else {
				ns = fullName.Substring(0, index);
				name = fullName.Substring(index + 1);
			}
		}

		public void Initialize() {
			if (encryptedResource == null)
				return;

			decryptedReader = new BinaryReader(new MemoryStream(Decrypt(encryptedResource.CreateReader().ToArray())));

			delegateType = null;
			foreach (var type in module.GetTypes()) {
				var cctor = type.FindStaticConstructor();
				if (cctor == null)
					continue;

				if (type.Fields.Count != 1)
					continue;
				var field = type.Fields[0];
				var tmpDelegateType = DotNetUtils.GetType(module, field.FieldType);
				if (tmpDelegateType == null)
					continue;

				if (!CheckDelegateType(tmpDelegateType))
					continue;
				if (delegateType != null && delegateType != tmpDelegateType)
					continue;

				if (!CheckCctor(cctor))
					continue;

				delegateType = tmpDelegateType;

				foreach (var method in type.Methods) {
					if (method.Name == ".cctor")
						continue;
					if (!method.IsStatic || method.Body == null)
						continue;
					var sig = method.MethodSig;
					if (sig == null || sig.Params.Count != 0)
						continue;
					if (sig.RetType.GetElementType() == ElementType.Void)
						continue;
					var info = GetDecrypterInfo(method, field);
					if (info == null)
						continue;

					decrypterMethods.Add(info.method, info);
				}
			}
		}

		Info GetDecrypterInfo(MethodDef method, FieldDef delegateField) {
			try {
				int index = 0;
				var instrs = method.Body.Instructions;
				if (instrs[index].OpCode.Code != Code.Ldsfld)
					return null;
				var field = instrs[index++].Operand as FieldDef;
				if (field != delegateField)
					return null;

				if (!instrs[index].IsLdcI4())
					return null;
				int offset = instrs[index++].GetLdcI4Value();

				if (instrs[index].OpCode.Code != Code.Call && instrs[index].OpCode.Code != Code.Callvirt)
					return null;
				var calledMethod = instrs[index++].Operand as IMethod;
				if (calledMethod.Name != "Invoke")
					return null;

				if (instrs[index].OpCode.Code == Code.Unbox_Any)
					index++;

				if (instrs[index++].OpCode.Code != Code.Ret)
					return null;

				return new Info(method, offset);
			}
			catch (ArgumentOutOfRangeException) {
				return null;
			}
		}

		bool CheckCctor(MethodDef cctor) {
			var ldtokenType = GetLdtokenType(cctor);
			if (!new SigComparer().Equals(ldtokenType, cctor.DeclaringType))
				return false;

			MethodDef initMethod = null;
			foreach (var method in DotNetUtils.GetCalledMethods(module, cctor)) {
				if (DotNetUtils.IsMethod(method, "System.Void", "(System.Type)")) {
					initMethod = method;
					break;
				}
			}
			if (initMethod == null || initMethod.Body == null)
				return false;

			return true;
		}

		static ITypeDefOrRef GetLdtokenType(MethodDef method) {
			if (method == null || method.Body == null)
				return null;
			foreach (var instr in method.Body.Instructions) {
				if (instr.OpCode.Code != Code.Ldtoken)
					continue;
				return instr.Operand as ITypeDefOrRef;
			}
			return null;
		}

		bool CheckDelegateType(TypeDef type) {
			if (!DotNetUtils.DerivesFromDelegate(type))
				return false;
			var invoke = type.FindMethod("Invoke");
			if (invoke == null)
				return false;
			return CheckDelegateInvokeMethod(invoke);
		}

		protected abstract bool CheckDelegateInvokeMethod(MethodDef invokeMethod);

		byte[] Decrypt(byte[] encryptedData) {
			const int KEY_LEN = 0x100;
			if (encryptedData.Length < KEY_LEN)
				throw new ApplicationException("Invalid encrypted data length");
			var decryptedData = new byte[encryptedData.Length - KEY_LEN];
			var pkt = PublicKey.GetRawData(PublicKeyBase.ToPublicKeyToken(module.Assembly.PublicKey));
			if (pkt == null || pkt.Length == 0)
				pkt = new byte[8];

			for (int i = 0, j = 0, ki = 0; i < decryptedData.Length; i++) {
				ki = (ki + 1) % (KEY_LEN - 1);
				j = (j + encryptedData[ki] + pkt[i % 8]) % (KEY_LEN - 1);
				var tmp = encryptedData[j];
				encryptedData[j] = encryptedData[ki];
				encryptedData[ki] = tmp;
				decryptedData[i] = (byte)(encryptedData[KEY_LEN + i] ^ encryptedData[(encryptedData[j] + encryptedData[ki]) % (KEY_LEN - 1)]);
			}

			return decryptedData;
		}

		TypeDef FindDelegateInitType() {
			if (delegateType == null)
				return null;

			foreach (var type in module.Types) {
				if (type.HasProperties || type.HasEvents || type.HasFields)
					continue;

				foreach (var method in type.Methods) {
					if (!method.IsStatic || method.IsPrivate || method.Body == null)
						continue;
					var ldtokenType = GetLdtokenType(method);
					if (ldtokenType == null)
						continue;
					if (!new SigComparer().Equals(ldtokenType, delegateType))
						continue;

					delegateInitType = type;
					return delegateInitType;
				}
			}

			return null;
		}

		public IEnumerable<MethodDef> GetMethods() {
			var list = new List<MethodDef>(decrypterMethods.Count);
			foreach (var info in decrypterMethods.GetValues())
				list.Add(info.method);
			return list;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Goliath_NET/Deobfuscator.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Goliath_NET {
	public class DeobfuscatorInfo : DeobfuscatorInfoBase {
		public const string THE_NAME = "Goliath.NET";
		public const string THE_TYPE = "go";
		const string DEFAULT_REGEX = @"!^[A-Za-z]{1,2}(?:`\d+)?$&" + DeobfuscatorBase.DEFAULT_ASIAN_VALID_NAME_REGEX;
		BoolOption inlineMethods;
		BoolOption removeInlinedMethods;
		BoolOption restoreLocals;
		BoolOption decryptIntegers;
		BoolOption decryptArrays;
		BoolOption removeAntiStrongName;

		public DeobfuscatorInfo()
			: base(DEFAULT_REGEX) {
			inlineMethods = new BoolOption(null, MakeArgName("inline"), "Inline short methods", true);
			removeInlinedMethods = new BoolOption(null, MakeArgName("remove-inlined"), "Remove inlined methods", true);
			restoreLocals = new BoolOption(null, MakeArgName("locals"), "Restore locals", true);
			decryptIntegers = new BoolOption(null, MakeArgName("ints"), "Decrypt integers", true);
			decryptArrays = new BoolOption(null, MakeArgName("arrays"), "Decrypt arrays", true);
			removeAntiStrongName = new BoolOption(null, MakeArgName("sn"), "Remove anti strong name code", true);
		}

		public override string Name => THE_NAME;
		public override string Type => THE_TYPE;

		public override IDeobfuscator CreateDeobfuscator() =>
			new Deobfuscator(new Deobfuscator.Options {
				RenameResourcesInCode = false,
				ValidNameRegex = validNameRegex.Get(),
				InlineMethods = inlineMethods.Get(),
				RemoveInlinedMethods = removeInlinedMethods.Get(),
				RestoreLocals = restoreLocals.Get(),
				DecryptIntegers = decryptIntegers.Get(),
				DecryptArrays = decryptArrays.Get(),
				RemoveAntiStrongName = removeAntiStrongName.Get(),
			});

		protected override IEnumerable<Option> GetOptionsInternal() =>
			new List<Option>() {
				inlineMethods,
				removeInlinedMethods,
				restoreLocals,
				decryptIntegers,
				decryptArrays,
				removeAntiStrongName,
			};
	}

	class Deobfuscator : DeobfuscatorBase {
		Options options;
		string obfuscatorName = DeobfuscatorInfo.THE_NAME;

		ProxyCallFixer proxyCallFixer;
		LocalsRestorer localsRestorer;
		LogicalExpressionFixer logicalExpressionFixer;
		StringDecrypter stringDecrypter;
		IntegerDecrypter integerDecrypter;
		Int32ValueInliner int32ValueInliner;
		ArrayDecrypter arrayDecrypter;
		ArrayValueInliner arrayValueInliner;
		StrongNameChecker strongNameChecker;

		bool foundGoliathAttribute = false;
		bool startedDeobfuscating = false;

		internal class Options : OptionsBase {
			public bool InlineMethods { get; set; }
			public bool RemoveInlinedMethods { get; set; }
			public bool RestoreLocals { get; set; }
			public bool DecryptIntegers { get; set; }
			public bool DecryptArrays { get; set; }
			public bool RemoveAntiStrongName { get; set; }
		}

		public override string Type => DeobfuscatorInfo.THE_TYPE;
		public override string TypeLong => DeobfuscatorInfo.THE_NAME;
		public override string Name => obfuscatorName;
		protected override bool CanInlineMethods => startedDeobfuscating ? options.InlineMethods : true;
		internal Deobfuscator(Options options) : base(options) => this.options = options;

		protected override int DetectInternal() {
			int val = 0;

			int sum = ToInt32(stringDecrypter.Detected) +
					ToInt32(integerDecrypter.Detected) +
					ToInt32(arrayDecrypter.Detected) +
					ToInt32(strongNameChecker.Detected) +
					ToInt32(HasMetadataStream("#GOLIATH"));
			if (sum > 0)
				val += 100 + 10 * (sum - 1);
			if (foundGoliathAttribute)
				val += 10;

			return val;
		}

		protected override void ScanForObfuscator() {
			FindGoliathAttribute();
			stringDecrypter = new StringDecrypter(module);
			stringDecrypter.Find();
			integerDecrypter = new IntegerDecrypter(module);
			integerDecrypter.Find();
			arrayDecrypter = new ArrayDecrypter(module);
			arrayDecrypter.Find();
			strongNameChecker = new StrongNameChecker(module);
			strongNameChecker.Find();
		}

		void FindGoliathAttribute() {
			foreach (var type in module.Types) {
				if (type.FullName.Contains("ObfuscatedByGoliath")) {
					foundGoliathAttribute = true;
					AddAttributeToBeRemoved(type, "Obfuscator attribute");
					InitializeVersion(type);
					break;
				}
			}
		}

		void InitializeVersion(TypeDef attr) {
			var s = DotNetUtils.GetCustomArgAsString(GetAssemblyAttribute(attr), 0);
			if (s == null)
				return;

			var val = System.Text.RegularExpressions.Regex.Match(s, @"^Goliath \.NET Obfuscator rel\. (\d+\.\d+\.\d+)$");
			if (val.Groups.Count < 2)
				return;
			obfuscatorName = DeobfuscatorInfo.THE_NAME + " " + val.Groups[1].ToString();
			return;
		}

		public override void DeobfuscateBegin() {
			base.DeobfuscateBegin();

			proxyCallFixer = new ProxyCallFixer(module);
			proxyCallFixer.Find();
			localsRestorer = new LocalsRestorer(module);
			if (options.RestoreLocals)
				localsRestorer.Find();

			logicalExpressionFixer = new LogicalExpressionFixer();
			stringDecrypter.Initialize();
			integerDecrypter.Initialize();
			arrayDecrypter.Initialize();

			if (options.DecryptIntegers) {
				int32ValueInliner = new Int32ValueInliner();
				foreach (var method in integerDecrypter.GetMethods()) {
					int32ValueInliner.Add(method, (method2, gim, args) => {
						return integerDecrypter.Decrypt(method2);
					});
				}
			}

			if (options.DecryptArrays) {
				arrayValueInliner = new ArrayValueInliner(module, initializedDataCreator);
				foreach (var method in arrayDecrypter.GetMethods()) {
					arrayValueInliner.Add(method, (method2, gim, args) => {
						return arrayDecrypter.Decrypt(method2);
					});
				}
			}

			foreach (var method in stringDecrypter.GetMethods()) {
				staticStringInliner.Add(method, (method2, gim, args) => {
					return stringDecrypter.Decrypt(method2);
				});
				DeobfuscatedFile.StringDecryptersAdded();
			}

			if (options.RemoveAntiStrongName)
				AddTypeToBeRemoved(strongNameChecker.Type, "Strong name checker type");

			startedDeobfuscating = true;
		}

		public override void DeobfuscateMethodBegin(Blocks blocks) {
			proxyCallFixer.Deobfuscate(blocks);
			base.DeobfuscateMethodBegin(blocks);
		}

		public override void DeobfuscateMethodEnd(Blocks blocks) {
			stringDecrypter.Deobfuscate(blocks);
			int32ValueInliner.Decrypt(blocks);
			arrayValueInliner.Decrypt(blocks);
			if (options.RestoreLocals)
				localsRestorer.Deobfuscate(blocks);
			if (options.RemoveAntiStrongName) {
				if (strongNameChecker.Deobfuscate(blocks))
					Logger.v("Removed strong name checker code");
			}
			logicalExpressionFixer.Deobfuscate(blocks);
			base.DeobfuscateMethodEnd(blocks);
		}

		public override void DeobfuscateEnd() {
			RemoveProxyDelegates(proxyCallFixer);
			RemoveInlinedMethods();
			AddTypesToBeRemoved(localsRestorer.Types, "Method locals obfuscation type");

			if (CanRemoveStringDecrypterType) {
				RemoveDecrypterStuff(stringDecrypter, "String", "strings");
				AddTypeToBeRemoved(stringDecrypter.StringStruct, "String struct");
			}
			if (options.DecryptIntegers)
				RemoveDecrypterStuff(integerDecrypter, "Integer", "integers");
			if (options.DecryptArrays)
				RemoveDecrypterStuff(arrayDecrypter, "Array", "arrays");

			base.DeobfuscateEnd();
		}

		void RemoveDecrypterStuff(DecrypterBase decrypter, string name1, string name2) {
			AddResourceToBeRemoved(decrypter.EncryptedResource, "Encrypted " + name2);
			AddTypesToBeRemoved(decrypter.DecrypterTypes, name1 + " decrypter type");
			AddTypeToBeRemoved(decrypter.Type, name1 + " resource decrypter type");
			if (decrypter.DelegateInitType != null) {
				AddTypeToBeRemoved(decrypter.DelegateType, name1 + " resource decrypter delegate type");
				AddTypeToBeRemoved(decrypter.DelegateInitType, name1 + " delegate initializer type");
			}
		}

		void RemoveInlinedMethods() {
			if (!options.InlineMethods || !options.RemoveInlinedMethods)
				return;
			FindAndRemoveInlinedMethods();
		}

		public override IEnumerable<int> GetStringDecrypterMethods() {
			var list = new List<int>();
			foreach (var method in stringDecrypter.GetMethods())
				list.Add(method.MDToken.ToInt32());
			return list;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Goliath_NET/IntegerDecrypter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using dnlib.DotNet;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Goliath_NET {
	class IntegerDecrypter : DecrypterBase {
		public IntegerDecrypter(ModuleDefMD module)
			: base(module) {
		}

		static string[] requiredFields = new string[] {
			"System.Byte[]",
			"System.Collections.Generic.Dictionary`2<System.Int32,System.Object>",
		};
		protected override bool CheckDecrypterType(TypeDef type) =>
			new FieldTypes(type).Exactly(requiredFields);

		protected override bool CheckDelegateInvokeMethod(MethodDef invokeMethod) =>
			DotNetUtils.IsMethod(invokeMethod, "System.Object", "(System.Int32)");

		public int Decrypt(MethodDef method) {
			var info = GetInfo(method);
			decryptedReader.BaseStream.Position = info.offset;
			int len = decryptedReader.ReadInt32();
			return BitConverter.ToInt32(decryptedReader.ReadBytes(len), 0);
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Goliath_NET/LocalsRestorer.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Goliath_NET {
	class LocalsRestorer {
		ModuleDefMD module;
		TypeDefDict<Info> typeToInfo = new TypeDefDict<Info>();

		class Info {
			public TypeDef type;
			public TypeSig localType;
			public bool referenced = false;
			public Info(TypeDef type, TypeSig localType) {
				this.type = type;
				this.localType = localType;
			}
		}

		public List<TypeDef> Types {
			get {
				var list = new List<TypeDef>(typeToInfo.Count);
				foreach (var info in typeToInfo.GetValues()) {
					if (info.referenced)
						list.Add(info.type);
				}
				return list;
			}
		}

		public LocalsRestorer(ModuleDefMD module) => this.module = module;

		public void Find() {
			foreach (var type in module.GetTypes())
				Initialize(type);
		}

		void Initialize(TypeDef type) {
			if (type.HasEvents || type.HasProperties)
				return;

			if (!type.IsValueType)
				return;
			if (type.Methods.Count != 1)
				return;
			var ctor = type.Methods[0];
			if (ctor.Name != ".ctor" || ctor.Body == null || ctor.IsStatic)
				return;
			var sig = ctor.MethodSig;
			if (sig == null || sig.Params.Count != 1)
				return;
			var ctorParam = sig.Params[0];

			if (type.Fields.Count != 1)
				return;
			var typeField = type.Fields[0];
			if (typeField.IsStatic)
				return;
			if (!new SigComparer().Equals(ctorParam, typeField.FieldType))
				return;

			typeToInfo.Add(ctor.DeclaringType, new Info(ctor.DeclaringType, typeField.FieldType));
		}

		public void Deobfuscate(Blocks blocks) {
			var instrsToRemove = new List<int>();
			foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {
				instrsToRemove.Clear();
				var instrs = block.Instructions;
				for (int i = 0; i < instrs.Count; i++) {
					var instr = instrs[i];
					int indexToRemove;
					ITypeDefOrRef type;
					Local local = null;

					if (instr.OpCode.Code == Code.Newobj) {
						if (i + 1 >= instrs.Count)
							continue;
						var ctor = instr.Operand as IMethod;
						if (ctor == null || ctor.DeclaringType == null)
							continue;
						if (ctor.Name != ".ctor")
							continue;

						var next = instrs[i + 1];
						if (!next.IsStloc() && !next.IsLeave() && next.OpCode.Code != Code.Pop)
							continue;

						indexToRemove = i;
						type = ctor.DeclaringType;
						if (next.IsStloc())
							local = Instr.GetLocalVar(blocks.Locals, next);
					}
					else if (instr.OpCode.Code == Code.Ldfld) {
						if (i == 0)
							continue;
						var ldloc = instrs[i - 1];
						if (!ldloc.IsLdloc())
							continue;

						var field = instr.Operand as IField;
						if (field == null || field.DeclaringType == null)
							continue;

						indexToRemove = i;
						type = field.DeclaringType;
						local = Instr.GetLocalVar(blocks.Locals, ldloc);
					}
					else
						continue;

					if (type == null)
						continue;
					var info = typeToInfo.Find(type);
					if (info == null)
						continue;

					info.referenced = true;
					instrsToRemove.Add(indexToRemove);
					if (local != null)
						local.Type = info.localType;
				}
				if (instrsToRemove.Count > 0)
					block.Remove(instrsToRemove);
			}
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Goliath_NET/LogicalExpressionFixer.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Goliath_NET {
	class LogicalExpressionFixer {
		public void Deobfuscate(Blocks blocks) {
			foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {
				var instrs = block.Instructions;
				for (int i = 0; i < instrs.Count - 1; i++) {
					var first = instrs[i];
					var second = instrs[i + 1];
					if (first.OpCode.Code == Code.Not && second.OpCode.Code == Code.Neg) {
						// It's increment
						instrs[i] = new Instr(OpCodes.Ldc_I4_1.ToInstruction());
						instrs[i + 1] = new Instr(OpCodes.Add.ToInstruction());
					}
					else if (first.OpCode.Code == Code.Neg && second.OpCode.Code == Code.Not) {
						// It's decrement
						instrs[i] = new Instr(OpCodes.Ldc_I4_1.ToInstruction());
						instrs[i + 1] = new Instr(OpCodes.Sub.ToInstruction());
					}
				}
			}
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Goliath_NET/ProxyCallFixer.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace de4dot.code.deobfuscators.Goliath_NET {
	class ProxyCallFixer : ProxyCallFixer2 {
		public ProxyCallFixer(ModuleDefMD module)
			: base(module) {
		}

		class MyInfo {
			public MethodDef method;
			public DelegateInfo delegateInfo;
			public MyInfo(MethodDef method, DelegateInfo delegateInfo) {
				this.method = method;
				this.delegateInfo = delegateInfo;
			}
		}

		public new void Find() {
			Logger.v("Finding all proxy delegates");
			var infos = new List<MyInfo>();
			foreach (var type in module.GetTypes()) {
				if (type.BaseType == null || type.BaseType.FullName != "System.MulticastDelegate")
					continue;

				infos.Clear();
				foreach (var method in type.Methods) {
					if (!CheckProxyMethod(method, out var info))
						continue;
					infos.Add(new MyInfo(method, info));
				}

				if (infos.Count == 0)
					continue;

				Logger.v("Found proxy delegate: {0} ({1:X8})", Utils.RemoveNewlines(type), type.MDToken.ToUInt32());
				RemovedDelegateCreatorCalls++;
				Logger.Instance.Indent();
				foreach (var info in infos) {
					var di = info.delegateInfo;
					Add(info.method, di);
					Logger.v("Field: {0}, Opcode: {1}, Method: {2} ({3:X8})",
								Utils.RemoveNewlines(di.field.Name),
								di.callOpcode,
								Utils.RemoveNewlines(di.methodRef),
								di.methodRef.MDToken.ToUInt32());
				}
				Logger.Instance.DeIndent();
				delegateTypesDict[type] = true;
			}
		}

		bool CheckProxyMethod(MethodDef method, out DelegateInfo info) {
			info = null;
			if (!method.IsStatic || method.Body == null)
				return false;

			var instrs = method.Body.Instructions;
			if (instrs.Count < 7)
				return false;

			int index = 0;

			if (instrs[index].OpCode.Code != Code.Ldsfld)
				return false;
			var field = instrs[index++].Operand as FieldDef;
			if (field == null || !field.IsStatic)
				return false;
			if (!new SigComparer().Equals(method.DeclaringType, field.DeclaringType))
				return false;

			if (!instrs[index++].IsBrtrue())
				return false;
			if (instrs[index++].OpCode.Code != Code.Ldnull)
				return false;
			if (instrs[index].OpCode.Code != Code.Ldftn)
				return false;
			var calledMethod = instrs[index++].Operand as IMethod;
			if (calledMethod == null)
				return false;
			if (instrs[index++].OpCode.Code != Code.Newobj)
				return false;
			if (instrs[index].OpCode.Code != Code.Stsfld)
				return false;
			if (!new SigComparer().Equals(field, instrs[index++].Operand as IField))
				return false;
			if (instrs[index].OpCode.Code != Code.Ldsfld)
				return false;
			if (!new SigComparer().Equals(field, instrs[index++].Operand as IField))
				return false;

			var sig = method.MethodSig;
			if (sig == null)
				return false;
			for (int i = 0; i < sig.Params.Count; i++) {
				if (index >= instrs.Count)
					return false;
				if (instrs[index++].GetParameterIndex() != i)
					return false;
			}

			if (index + 2 > instrs.Count)
				return false;
			var call = instrs[index++];
			if (call.OpCode.Code != Code.Callvirt)
				return false;

			if (instrs[index++].OpCode.Code != Code.Ret)
				return false;

			info = new DelegateInfo(field, calledMethod, OpCodes.Call);
			return true;
		}

		protected override object CheckCctor(TypeDef type, MethodDef cctor) => throw new System.NotImplementedException();
		protected override void GetCallInfo(object context, FieldDef field, out IMethod calledMethod, out OpCode callOpcode) => throw new System.NotImplementedException();
	}
}



================================================
File: de4dot.code/deobfuscators/Goliath_NET/StringDecrypter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Text;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Goliath_NET {
	class StringDecrypter : DecrypterBase {
		IType delegateReturnType;
		FieldDef stringStructField;

		public TypeDef StringStruct => Detected && stringStructField != null ? stringStructField.DeclaringType : null;
		public StringDecrypter(ModuleDefMD module) : base(module) { }

		protected override bool CheckDecrypterType(TypeDef type) {
			var fields = type.Fields;
			if (fields.Count != 2)
				return false;

			if (fields[0].FieldType.FullName != "System.Byte[]")
				return false;

			var dict = fields[1].FieldType.ToGenericInstSig();
			if (dict == null || dict.GenericArguments.Count != 2)
				return false;
			if (dict.GenericType.GetFullName() != "System.Collections.Generic.Dictionary`2")
				return false;

			if (dict.GenericArguments[0].FullName != "System.Int32")
				return false;

			var garg = dict.GenericArguments[1];
			if (garg.FullName != "System.String") {
				if (!garg.IsValueType)
					return false;
				var gargType = DotNetUtils.GetType(module, garg);
				if (gargType == null || !gargType.IsClass)
					return false;
				if (gargType.Fields.Count != 1)
					return false;
				var field = gargType.Fields[0];
				if (field.FieldType.FullName != "System.String")
					return false;
				delegateReturnType = gargType;
				stringStructField = field;
			}
			else {
				delegateReturnType = garg;
				stringStructField = null;
			}

			return true;
		}

		protected override bool CheckDelegateInvokeMethod(MethodDef invokeMethod) =>
			DotNetUtils.IsMethod(invokeMethod, delegateReturnType.FullName, "(System.Int32)");

		public string Decrypt(MethodDef method) {
			var info = GetInfo(method);
			decryptedReader.BaseStream.Position = info.offset;
			int len = decryptedReader.ReadInt32();
			return Encoding.UTF8.GetString(decryptedReader.ReadBytes(len));
		}

		public void Deobfuscate(Blocks blocks) {
			if (!Detected)
				return;
			if (stringStructField == null)
				return;

			foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {
				var instrs = block.Instructions;
				for (int i = 0; i < instrs.Count - 1; i++) {
					var ldstr = instrs[i];
					if (ldstr.OpCode.Code != Code.Ldstr)
						continue;
					var ldfld = instrs[i + 1];
					if (ldfld.OpCode.Code != Code.Ldfld)
						continue;
					if (!FieldEqualityComparer.CompareDeclaringTypes.Equals(stringStructField, ldfld.Operand as IField))
						continue;
					block.Remove(i + 1, 1);
				}
			}
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Goliath_NET/StrongNameChecker.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Goliath_NET {
	class StrongNameChecker {
		ModuleDefMD module;
		TypeDef strongNameType;
		MethodDef strongNameCheckMethod;

		public bool Detected => strongNameType != null;
		public TypeDef Type => strongNameType;
		public MethodDef CheckerMethod => strongNameCheckMethod;
		public StrongNameChecker(ModuleDefMD module) => this.module = module;

		public void Find() {
			foreach (var type in module.Types) {
				if (type.HasFields || type.HasEvents || type.HasProperties)
					continue;

				var checkMethod = GetAntiTamperingDetectionMethod(type);
				if (checkMethod == null)
					continue;

				if (DotNetUtils.GetMethod(type, "System.Byte[]", "(System.Reflection.Assembly)") == null)
					continue;
				if (DotNetUtils.GetMethod(type, "System.String", "(System.Collections.Generic.Stack`1<System.Int32>)") == null)
					continue;
				if (DotNetUtils.GetMethod(type, "System.Int32", "(System.Int32,System.Byte[])") == null)
					continue;

				strongNameType = type;
				strongNameCheckMethod = checkMethod;
				return;
			}
		}

		MethodDef GetAntiTamperingDetectionMethod(TypeDef type) {
			var requiredLocals = new string[] {
				"System.Reflection.Assembly",
				"System.Collections.Generic.Stack`1<System.Int32>",
			};
			foreach (var method in type.Methods) {
				if (!method.IsStatic || method.Body == null)
					continue;
				if (!DotNetUtils.IsMethod(method, "System.Void", "(System.Type)"))
					continue;
				if (!new LocalTypes(method).All(requiredLocals))
					continue;
				if (!HasThrow(method))
					continue;

				return method;
			}
			return null;
		}

		static bool HasThrow(MethodDef method) {
			if (method == null || method.Body == null)
				return false;
			foreach (var instr in method.Body.Instructions) {
				if (instr.OpCode.Code == Code.Throw)
					return true;
			}
			return false;
		}

		public bool Deobfuscate(Blocks blocks) {
			if (blocks.Method.Name != ".cctor" && blocks.Method.Name != ".ctor")
				return false;
			foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {
				var instrs = block.Instructions;
				for (int i = 0; i < instrs.Count - 2; i++) {
					var ldtoken = instrs[i];
					if (ldtoken.OpCode.Code != Code.Ldtoken)
						continue;

					var call1 = instrs[i + 1];
					if (call1.OpCode.Code != Code.Call && call1.OpCode.Code != Code.Callvirt)
						continue;
					if (!DotNetUtils.IsMethod(call1.Operand as IMethod, "System.Type", "(System.RuntimeTypeHandle)"))
						continue;

					var call2 = instrs[i + 2];
					if (call2.OpCode.Code != Code.Call && call2.OpCode.Code != Code.Callvirt)
						continue;
					if (!MethodEqualityComparer.CompareDeclaringTypes.Equals(call2.Operand as IMethod, strongNameCheckMethod))
						continue;

					block.Remove(i, 3);
					return true;
				}
			}
			return false;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/ILProtector/DecryptedMethodInfo.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;

namespace de4dot.code.deobfuscators.ILProtector {
	[Serializable]
	class DecryptedMethodInfo {
		public int id;
		public byte[] data;

		public DecryptedMethodInfo(int id, int size) {
			this.id = id;
			data = new byte[size];
		}

		public DecryptedMethodInfo(int id, byte[] data) {
			this.id = id;
			this.data = data;
		}

		public override string ToString() => $"ID: {id}, Size: 0x{data.Length:X}";
	}
}



================================================
File: de4dot.code/deobfuscators/ILProtector/Deobfuscator.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;

namespace de4dot.code.deobfuscators.ILProtector {
	public class DeobfuscatorInfo : DeobfuscatorInfoBase {
		public const string THE_NAME = "ILProtector";
		public const string THE_TYPE = "il";
		const string DEFAULT_REGEX = DeobfuscatorBase.DEFAULT_ASIAN_VALID_NAME_REGEX;

		public DeobfuscatorInfo()
			: base(DEFAULT_REGEX) {
		}

		public override string Name => THE_NAME;
		public override string Type => THE_TYPE;

		public override IDeobfuscator CreateDeobfuscator() =>
			new Deobfuscator(new Deobfuscator.Options {
				ValidNameRegex = validNameRegex.Get(),
			});

		protected override IEnumerable<Option> GetOptionsInternal() => new Option[0];
	}

	class Deobfuscator : DeobfuscatorBase {
		string obfuscatorName = DeobfuscatorInfo.THE_NAME;

		MainType mainType;
		StaticMethodsDecrypter staticMethodsDecrypter;
		DynamicMethodsRestorer dynamicMethodsRestorer;

		internal class Options : OptionsBase {
		}

		public override string Type => DeobfuscatorInfo.THE_TYPE;
		public override string TypeLong => DeobfuscatorInfo.THE_NAME;
		public override string Name => obfuscatorName;
		public Deobfuscator(Options options) : base(options) { }
		protected override int DetectInternal() => mainType.Detected ? 150 : 0;

		protected override void ScanForObfuscator() {
			mainType = new MainType(module);
			mainType.Find();

			staticMethodsDecrypter = new StaticMethodsDecrypter(module, mainType);
			if (mainType.Detected)
				staticMethodsDecrypter.Find();

			if (mainType.Detected && !staticMethodsDecrypter.Detected)
				dynamicMethodsRestorer = new DynamicMethodsRestorer(module, mainType);

			if (mainType.Detected) {
				if (staticMethodsDecrypter.Detected)
					UpdateObfuscatorNameWith(staticMethodsDecrypter.Version);
				else
					UpdateObfuscatorNameWith(mainType.GetRuntimeVersionString());
			}
		}

		void UpdateObfuscatorNameWith(string version) {
			if (!string.IsNullOrEmpty(version))
				obfuscatorName += " " + version;
		}

		public override void DeobfuscateBegin() {
			base.DeobfuscateBegin();

			if (mainType.Detected) {
				if (staticMethodsDecrypter.Detected) {
					staticMethodsDecrypter.Decrypt();
					RemoveObfuscatorJunk(staticMethodsDecrypter);
				}
				else if (dynamicMethodsRestorer != null) {
					Logger.v("Runtime file versions:");
					Logger.Instance.Indent();
					bool emailMe = false;
					foreach (var info in mainType.RuntimeFileInfos) {
						var version = info.GetVersion();
						emailMe |= version != null && version == new Version(1, 0, 7, 0);
						Logger.v("Version: {0} ({1})", version == null ? "UNKNOWN" : version.ToString(), info.PathName);
					}
					Logger.Instance.DeIndent();
					if (emailMe)
						Logger.n("**** Email me this program! de4dot@gmail.com");

					dynamicMethodsRestorer.Decrypt();
					RemoveObfuscatorJunk(dynamicMethodsRestorer);
				}
				else
					Logger.w("New ILProtector version. Can't decrypt methods (yet)");
			}
		}

		void RemoveObfuscatorJunk(MethodsDecrypterBase methodsDecrypter) {
			AddTypesToBeRemoved(methodsDecrypter.DelegateTypes, "Obfuscator method delegate type");
			AddResourceToBeRemoved(methodsDecrypter.Resource, "Encrypted methods resource");
			AddTypeToBeRemoved(mainType.InvokerDelegate, "Invoker delegate type");
			AddFieldToBeRemoved(mainType.InvokerInstanceField, "Invoker delegate instance field");
			foreach (var info in mainType.RuntimeFileInfos)
				AddMethodToBeRemoved(info.ProtectMethod, "Obfuscator 'Protect' init method");
			mainType.CleanUp();
		}

		public override IEnumerable<int> GetStringDecrypterMethods() => new int[0];
	}
}



================================================
File: de4dot.code/deobfuscators/ILProtector/DynamicMethodsDecrypter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.ExceptionServices;
using System.Runtime.InteropServices;
using System.Security;
using dnlib.DotNet;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.ILProtector {
	sealed class DynamicMethodsDecrypter : IDisposable {
		ModuleDefMD module;
		Module reflectionModule;
		Module reflectionProtectModule;
		TypeDef protectMainType;
		FieldInfo invokerFieldInfo;
		ModuleDefMD moduleProtect;
		IDecrypter decrypter;
		bool methodReaderHasDelegateTypeFlag;

		static class CodeAllocator {
			[DllImport("kernel32")]
			static extern IntPtr VirtualAlloc(IntPtr lpAddress, UIntPtr dwSize, uint flAllocationType, uint flProtect);

			const uint PAGE_EXECUTE_READWRITE = 0x40;
			const uint MEM_COMMIT = 0x00001000;
			const int ALIGNMENT = 0x10;

			static IntPtr currentPage;
			static int nextOffset;
			static int pageSize;

			public static IntPtr Allocate(byte[] code) {
				if (code == null || code.Length == 0)
					return IntPtr.Zero;

				var addr = Allocate(code.Length);
				Marshal.Copy(code, 0, addr, code.Length);
				return addr;
			}

			public static IntPtr Allocate(int size) {
				if (size <= 0)
					return IntPtr.Zero;

				size = (size + ALIGNMENT - 1) & ~(ALIGNMENT - 1);
				if (nextOffset + size > pageSize)
					AllocNewPage(size);

				var data = new IntPtr(currentPage.ToInt64() + nextOffset);
				nextOffset += size;
				return data;
			}

			static void AllocNewPage(int size) {
				size = (size + 0xFFF) & ~0xFFF;
				currentPage = VirtualAlloc(IntPtr.Zero, new UIntPtr((uint)size), MEM_COMMIT, PAGE_EXECUTE_READWRITE);
				if (currentPage == IntPtr.Zero)
					throw new ApplicationException("VirtualAlloc() failed");
				pageSize = size;
				nextOffset = 0;
			}
		}

		interface IDecrypter {
			byte[] Decrypt(int methodId, uint rid);
		}

		abstract class DecrypterBase : IDecrypter {
			protected readonly DynamicMethodsDecrypter dmd;
			protected readonly int appDomainId;
			protected readonly int asmHashCode;

			class PatchData {
				public int RVA { get; set; }
				public byte[] Data { get; set; }

				public PatchData() {
				}

				public PatchData(int rva, byte[] data) {
					RVA = rva;
					Data = data;
				}
			}

			class PatchInfo {
				public int RvaDecryptMethod { get; set; }
				public List<PatchData> PatchData { get; set; }

				public PatchInfo() {
				}

				public PatchInfo(int rvaDecryptMethod, PatchData patchData) {
					RvaDecryptMethod = rvaDecryptMethod;
					PatchData = new List<PatchData> { patchData };
				}
			}

			static readonly byte[] nops2 = new byte[] { 0x90, 0x90 };
			static readonly byte[] nops6 = new byte[] { 0x90, 0x90, 0x90, 0x90, 0x90, 0x90 };
			static readonly Dictionary<Version, PatchInfo> patchInfos32 = new Dictionary<Version, PatchInfo> {
				{ new Version(2, 0, 8, 0),	new PatchInfo(0x00020B20, new PatchData(0x00005733, nops2)) },
				{ new Version(2, 0, 8, 5),	new PatchInfo(0x000221A0, new PatchData(0x00005742, nops2)) },
				{ new Version(2, 0, 9, 0),	new PatchInfo(0x00023360, new PatchData(0x000056F2, nops6)) },
				{ new Version(2, 0, 10, 0), new PatchInfo(0x00023B30, new PatchData(0x00005B12, nops6)) },
				{ new Version(2, 0, 11, 0), new PatchInfo(0x000207C0, new PatchData(0x00018432, nops6)) },
				{ new Version(2, 0, 11, 1), new PatchInfo(0x000207C0, new PatchData(0x00018432, nops6)) },
			};
			static readonly Dictionary<Version, PatchInfo> patchInfos64 = new Dictionary<Version, PatchInfo> {
				{ new Version(2, 0, 8, 0),	new PatchInfo(0x00026090, new PatchData(0x00005E0C, nops6)) },
				{ new Version(2, 0, 8, 5),	new PatchInfo(0x000273D0, new PatchData(0x000060CA, nops6)) },
				{ new Version(2, 0, 9, 0),	new PatchInfo(0x00028B00, new PatchData(0x00005F70, nops6)) },
				{ new Version(2, 0, 10, 0), new PatchInfo(0x00029630, new PatchData(0x00006510, nops6)) },
				{ new Version(2, 0, 11, 0), new PatchInfo(0x000257C0, new PatchData(0x0001C9A0, nops6)) },
				{ new Version(2, 0, 11, 1), new PatchInfo(0x000257C0, new PatchData(0x0001C9A0, nops6)) },
			};

			[DllImport("kernel32")]
			static extern bool VirtualProtect(IntPtr addr, int size, uint newProtect, out uint oldProtect);
			const uint PAGE_EXECUTE_READWRITE = 0x40;

			public DecrypterBase(DynamicMethodsDecrypter dmd) {
				this.dmd = dmd;
				appDomainId = AppDomain.CurrentDomain.Id;
				asmHashCode = dmd.reflectionModule.Assembly.GetHashCode();
			}

			protected IntPtr GetDelegateAddress(FieldDef delegateField) {
				var delegateFieldInfo = dmd.reflectionProtectModule.ResolveField(0x04000000 + (int)delegateField.Rid);
				object mainTypeInst = ((Delegate)dmd.invokerFieldInfo.GetValue(null)).Target;
				return GetNativeAddressOfDelegate((Delegate)delegateFieldInfo.GetValue(mainTypeInst));
			}

			static IntPtr GetNativeAddressOfDelegate(Delegate del) {
				var field = typeof(Delegate).GetField("_methodPtrAux", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
				if (field == null)
					return IntPtr.Zero;

				return (IntPtr)field.GetValue(del);
			}

			protected void PatchRuntime(IntPtr decryptAddr) {
				if (!PatchRuntimeInternal(decryptAddr))
					throw new ApplicationException("Probably a new version. Could not patch runtime.");
			}

			bool PatchRuntimeInternal(IntPtr decryptAddr) {
				var patchInfos = IntPtr.Size == 4 ? patchInfos32 : patchInfos64;
				var protectVersion = dmd.reflectionProtectModule.Assembly.GetName().Version;
				if (!patchInfos.TryGetValue(protectVersion, out var info))
					return false;
				return PatchRuntime(decryptAddr, info);
			}

			[HandleProcessCorruptedStateExceptions, SecurityCritical]	// Req'd on .NET 4.0
			static bool PatchRuntime(IntPtr decryptAddr, PatchInfo info) {
				try {
					var baseAddr = new IntPtr(decryptAddr.ToInt64() - info.RvaDecryptMethod);
					if ((baseAddr.ToInt64() & 0xFFFF) != 0)
						return false;

					if (Marshal.ReadInt16(baseAddr) != 0x5A4D)
						return false;

					foreach (var patchData in info.PatchData) {
						var patchAddr = new IntPtr(baseAddr.ToInt64() + patchData.RVA);
						if (!VirtualProtect(patchAddr, patchData.Data.Length, PAGE_EXECUTE_READWRITE, out uint oldProtect))
							return false;
						Marshal.Copy(patchData.Data, 0, patchAddr, patchData.Data.Length);
						VirtualProtect(patchAddr, patchData.Data.Length, oldProtect, out oldProtect);
					}

					return true;
				}
				catch {
				}

				return false;
			}

			public abstract byte[] Decrypt(int methodId, uint rid);
		}

		// 1.0.7.0 - 1.0.8.0
		class DecrypterV1_0_7_0 : DecrypterBase {
			DecryptMethod decryptMethod;

			unsafe delegate bool DecryptMethod(int appDomainId, int asmHashCode, int methodId, out byte* pMethodCode, out int methodSize);

			public DecrypterV1_0_7_0(DynamicMethodsDecrypter dmd, FieldDef delegateField)
				: base(dmd) {
				var addr = GetDelegateAddress(delegateField);
				decryptMethod = (DecryptMethod)Marshal.GetDelegateForFunctionPointer(addr, typeof(DecryptMethod));
			}

			public unsafe override byte[] Decrypt(int methodId, uint rid) {
				if (!decryptMethod(appDomainId, asmHashCode, methodId, out var pMethodCode, out int methodSize))
					return null;
				byte[] methodData = new byte[methodSize];
				Marshal.Copy(new IntPtr(pMethodCode), methodData, 0, methodData.Length);
				return methodData;
			}
		}

		// 2.0.0.0 - 2.0.7.6
		class DecrypterV2_0_0_0 : DecrypterBase {
			DecryptMethod decryptMethod;

			unsafe delegate bool DecryptMethod(int clrMajorVersion, int appDomainId, int asmHashCode, int methodId, out byte* pMethodCode, out int methodSize);

			public DecrypterV2_0_0_0(DynamicMethodsDecrypter dmd, FieldDef delegateField)
				: base(dmd) {
				var addr = GetDelegateAddress(delegateField);
				decryptMethod = (DecryptMethod)Marshal.GetDelegateForFunctionPointer(addr, typeof(DecryptMethod));
			}

			public unsafe override byte[] Decrypt(int methodId, uint rid) {
				if (!decryptMethod(Environment.Version.Major, appDomainId, asmHashCode, methodId, out var pMethodCode, out int methodSize))
					return null;
				byte[] methodData = new byte[methodSize];
				Marshal.Copy(new IntPtr(pMethodCode), methodData, 0, methodData.Length);
				return methodData;
			}
		}

		// 2.0.8.0
		class DecrypterV2_0_8_0 : DecrypterBase {
			DecryptMethod decryptMethod;
			byte[] decryptedData;

			delegate bool DecryptMethod(int clrMajorVersion, int appDomainId, int asmHashCode, int methodId, [MarshalAs(UnmanagedType.FunctionPtr)] DecryptCallback decryptCallback, [MarshalAs(UnmanagedType.Interface)] out Delegate createdDelegate);
			unsafe delegate bool DecryptCallback(byte* pMethodCode, int methodSize, [MarshalAs(UnmanagedType.Interface)] ref Delegate createdDelegate);

			public DecrypterV2_0_8_0(DynamicMethodsDecrypter dmd, FieldDef delegateField)
				: base(dmd) {
				var addr = GetDelegateAddress(delegateField);
				decryptMethod = (DecryptMethod)Marshal.GetDelegateForFunctionPointer(addr, typeof(DecryptMethod));
				PatchRuntime(addr);
			}

			public unsafe override byte[] Decrypt(int methodId, uint rid) {
				if (!decryptMethod(Environment.Version.Major, appDomainId, asmHashCode, methodId, MyDecryptCallback, out var createdDelegate))
					return null;
				return decryptedData;
			}

			unsafe bool MyDecryptCallback(byte* pMethodCode, int methodSize, ref Delegate createdDelegate) {
				decryptedData = new byte[methodSize];
				Marshal.Copy(new IntPtr(pMethodCode), decryptedData, 0, decryptedData.Length);
				return true;
			}
		}

		// 2.0.8.5
		class DecrypterV2_0_8_5 : DecrypterBase {
			DecryptMethod decryptMethod;
			byte[] decryptedData;
			bool decryptReturnValue;

			delegate bool DecryptMethod(int clrMajorVersion, int appDomainId, int asmHashCode, int methodId, [MarshalAs(UnmanagedType.Interface)] StackTrace stackTrace, [MarshalAs(UnmanagedType.FunctionPtr)] DecryptCallback decryptCallback, [MarshalAs(UnmanagedType.Interface)] out Delegate createdDelegate);
			unsafe delegate bool DecryptCallback(byte* pMethodCode, int methodSize, [MarshalAs(UnmanagedType.Interface)] ref Delegate createdDelegate);

			public DecrypterV2_0_8_5(DynamicMethodsDecrypter dmd, FieldDef delegateField)
				: base(dmd) {
				var addr = GetDelegateAddress(delegateField);
				decryptMethod = (DecryptMethod)Marshal.GetDelegateForFunctionPointer(addr, typeof(DecryptMethod));
				PatchRuntime(addr);
			}

			public unsafe override byte[] Decrypt(int methodId, uint rid) {
				decryptReturnValue = false;
				if (!decryptMethod(Environment.Version.Major, appDomainId, asmHashCode, methodId, new StackTrace(), MyDecryptCallback, out var createdDelegate) &&
					!decryptReturnValue)
					return null;
				return decryptedData;
			}

			unsafe bool MyDecryptCallback(byte* pMethodCode, int methodSize, ref Delegate createdDelegate) {
				createdDelegate = new DecryptCallback(MyDecryptCallback);
				decryptedData = new byte[methodSize];
				Marshal.Copy(new IntPtr(pMethodCode), decryptedData, 0, decryptedData.Length);
				return decryptReturnValue = true;
			}
		}

		// 2.0.9.0 - 2.0.11.1
		class DecrypterV2_0_9_0 : DecrypterBase {
			DecryptMethod decryptMethod;
			byte[] decryptedData;

			delegate bool DecryptMethod(int clrMajorVersion, int appDomainId, int asmHashCode, int methodId, [MarshalAs(UnmanagedType.Interface)] StackTrace stackTrace, [MarshalAs(UnmanagedType.FunctionPtr)] DecryptCallback decryptCallback);
			unsafe delegate bool DecryptCallback(byte* pMethodCode, int methodSize, int methodId);

			public DecrypterV2_0_9_0(DynamicMethodsDecrypter dmd, FieldDef delegateField)
				: base(dmd) {
				var addr = GetDelegateAddress(delegateField);
				decryptMethod = (DecryptMethod)Marshal.GetDelegateForFunctionPointer(addr, typeof(DecryptMethod));
				PatchRuntime(addr);
			}

			public unsafe override byte[] Decrypt(int methodId, uint rid) {
				var encMethod = dmd.reflectionModule.ResolveMethod(0x06000000 + (int)rid);
				var stackTrace = StackTracePatcher.WriteStackFrame(new StackTrace(), 1, encMethod);
				if (!decryptMethod(Environment.Version.Major, appDomainId, asmHashCode, methodId, stackTrace, MyDecryptCallback))
					return null;
				return decryptedData;
			}

			unsafe bool MyDecryptCallback(byte* pMethodCode, int methodSize, int methodId) {
				decryptedData = new byte[methodSize];
				Marshal.Copy(new IntPtr(pMethodCode), decryptedData, 0, decryptedData.Length);
				return true;
			}
		}

		abstract class DecrypterBaseV2_0_12_x : IDecrypter {
			protected readonly DynamicMethodsDecrypter dmd;
			protected byte[] currentILBytes;
			byte[] decryptedData;
			readonly Delegate invoker;
			protected readonly IntPtr pGetILBytes;
			protected readonly IntPtr pDecryptCallback;

			protected unsafe DecrypterBaseV2_0_12_x(DynamicMethodsDecrypter dmd) {
				this.dmd = dmd;
				invoker = (Delegate)dmd.invokerFieldInfo.GetValue(null);

				byte* p = (byte*)GetStateAddr(invoker.Target);
				p += IntPtr.Size * 3;
				p = *(byte**)p;
				p += 8 + IntPtr.Size * 8;
				p = *(byte**)p;
				p += IntPtr.Size * 3;
				p = *(byte**)p;
				pGetILBytes = new IntPtr(p + IntPtr.Size * 39);
				pDecryptCallback = new IntPtr(p + IntPtr.Size * 40);
			}

			public static IntPtr GetStateAddr(object obj) {
				var flags = BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic;
				foreach (var fi in obj.GetType().GetFields(flags)) {
					if (fi.FieldType == typeof(IntPtr))
						return (IntPtr)fi.GetValue(obj);
				}
				throw new ApplicationException("Could not find an IntPtr field");
			}

			public byte[] Decrypt(int methodId, uint rid) {
				decryptedData = null;
				currentILBytes = dmd.reflectionModule.ResolveMethod(0x06000000 + (int)rid).GetMethodBody().GetILAsByteArray();
				invoker.DynamicInvoke(new object[1] { methodId });
				return decryptedData;
			}

			protected unsafe void SaveDecryptedData(byte* pMethodCode, int methodSize) {
				decryptedData = new byte[methodSize];
				Marshal.Copy(new IntPtr(pMethodCode), decryptedData, 0, decryptedData.Length);
			}
		}

		// 2.0.12.0 - 2.0.12.2
		class DecrypterV2_0_12_0 : DecrypterBaseV2_0_12_x {
			readonly GetCallerMethodAsILByteArrayDelegate getCallerMethodAsILByteArrayDelegate;
			readonly DecryptCallbackDelegate decryptCallbackDelegate;

#pragma warning disable CS0618 // Type or member is obsolete
			[return: MarshalAs(UnmanagedType.SafeArray)]
#pragma warning restore CS0618 // Type or member is obsolete
			delegate byte[] GetCallerMethodAsILByteArrayDelegate(IntPtr a, int skipFrames);
			unsafe delegate bool DecryptCallbackDelegate(IntPtr a, byte* pMethodCode, int methodSize, int methodId);

			public unsafe DecrypterV2_0_12_0(DynamicMethodsDecrypter dmd)
				: base(dmd) {
				getCallerMethodAsILByteArrayDelegate = GetCallerMethodAsILByteArray;
				decryptCallbackDelegate = DecryptCallback;

				*(IntPtr*)pGetILBytes = Marshal.GetFunctionPointerForDelegate(getCallerMethodAsILByteArrayDelegate);
				*(IntPtr*)pDecryptCallback = Marshal.GetFunctionPointerForDelegate(decryptCallbackDelegate);
			}

			byte[] GetCallerMethodAsILByteArray(IntPtr a, int skipFrames) => currentILBytes;

			unsafe bool DecryptCallback(IntPtr a, byte* pMethodCode, int methodSize, int methodId) {
				SaveDecryptedData(pMethodCode, methodSize);
				return true;
			}
		}

		// 2.0.12.3
		class DecrypterV2_0_12_3 : DecrypterBaseV2_0_12_x {
			readonly GetCallerMethodAsILByteArrayDelegate getCallerMethodAsILByteArrayDelegate;
			readonly DecryptCallbackDelegate decryptCallbackDelegate;

#pragma warning disable CS0618 // Type or member is obsolete
			[return: MarshalAs(UnmanagedType.SafeArray)]
#pragma warning restore CS0618 // Type or member is obsolete
			delegate byte[] GetCallerMethodAsILByteArrayDelegate(IntPtr a, int skipFrames, IntPtr c, IntPtr d);
			unsafe delegate bool DecryptCallbackDelegate(IntPtr a, byte* pMethodCode, int methodSize, int methodId, IntPtr e);

			public unsafe DecrypterV2_0_12_3(DynamicMethodsDecrypter dmd)
				: base(dmd) {
				getCallerMethodAsILByteArrayDelegate = GetCallerMethodAsILByteArray;
				decryptCallbackDelegate = DecryptCallback;

				*(IntPtr*)pGetILBytes = Marshal.GetFunctionPointerForDelegate(getCallerMethodAsILByteArrayDelegate);
				*(IntPtr*)pDecryptCallback = Marshal.GetFunctionPointerForDelegate(decryptCallbackDelegate);
			}

			byte[] GetCallerMethodAsILByteArray(IntPtr a, int skipFrames, IntPtr c, IntPtr d) => currentILBytes;

			unsafe bool DecryptCallback(IntPtr a, byte* pMethodCode, int methodSize, int methodId, IntPtr e) {
				SaveDecryptedData(pMethodCode, methodSize);
				return true;
			}
		}

		abstract class DecrypterV2_0_13_0_Base : IDecrypter {
			protected readonly DynamicMethodsDecrypter dmd;
			protected byte[] currentILBytes;
			byte[] decryptedData;
			readonly Delegate invoker;

			readonly GetCallerMethodAsILByteArrayDelegate getCallerMethodAsILByteArrayDelegate;
			readonly DecryptCallbackDelegate decryptCallbackDelegate;
			readonly IgnoreDelegate ignoreDelegate;

			[DllImport("kernel32")]
			static extern bool GetModuleHandleEx(uint dwFlags, IntPtr lpModuleName, out IntPtr phModule);

#pragma warning disable CS0618 // Type or member is obsolete
			[return: MarshalAs(UnmanagedType.SafeArray)]
#pragma warning restore CS0618 // Type or member is obsolete
			delegate byte[] GetCallerMethodAsILByteArrayDelegate(IntPtr a, int skipFrames, ref int flags, IntPtr d);
			unsafe delegate bool DecryptCallbackDelegate(IntPtr a, byte* pMethodCode, int methodSize, int methodId, IntPtr e);
			delegate IntPtr IgnoreDelegate(IntPtr a, IntPtr b);

			public unsafe DecrypterV2_0_13_0_Base(DynamicMethodsDecrypter dmd) {
				this.dmd = dmd;
				invoker = (Delegate)dmd.invokerFieldInfo.GetValue(null);

				byte* p = (byte*)DecrypterBaseV2_0_12_x.GetStateAddr(invoker.Target);
				byte* pis = GetAddr(*(byte**)p);
				p = *(byte**)pis;
				byte* pam = *(byte**)(p + IntPtr.Size * 2);
				p = *(byte**)(p + ((Environment.Version.Major - 2) / 2 * IntPtr.Size));
				p += IntPtr.Size * 8 + 0x18;
				p = LookUp(p, AppDomain.CurrentDomain.Id);
				p = *(byte**)(p + IntPtr.Size * 16 + 0x18);
				byte* pd = p + IntPtr.Size * 2;
				p = *(byte**)(p + IntPtr.Size * 13);

				getCallerMethodAsILByteArrayDelegate = GetCallerMethodAsILByteArray;
				decryptCallbackDelegate = DecryptCallback;
				ignoreDelegate = IgnoreMethod;

				byte* pm = p + 0x28 * IntPtr.Size;
				*(IntPtr*)(p + 0x29 * IntPtr.Size) = Marshal.GetFunctionPointerForDelegate(getCallerMethodAsILByteArrayDelegate);
				*(IntPtr*)(p + 0x2A * IntPtr.Size) = Marshal.GetFunctionPointerForDelegate(decryptCallbackDelegate);
				if (IntPtr.Size == 4)
					*(IntPtr*)(p + 0x2B * IntPtr.Size) = Marshal.GetFunctionPointerForDelegate(ignoreDelegate);
				InitCode(GetModuleHandle(pis), pam, pd, pm);
			}

			static unsafe byte* GetModuleHandle(byte* addr) {
				if (!GetModuleHandleEx(4, new IntPtr(addr), out var hModule))
					throw new ApplicationException("GetModuleHandleEx() failed");
				return (byte*)hModule;
			}

			protected unsafe abstract void InitCode(byte* ba, byte* pam, byte* pd, byte* pm);

			static unsafe byte* GetAddr(byte* p) {
				if (IntPtr.Size == 4) {
					for (int i = 0; i < 20; i++, p++) {
						if (*p == 0xA1)
							return *(byte**)(p + 1);
					}
				}
				else {
					for (int i = 0; i < 20; i++, p++)
						if (*p == 0x4C && p[1] == 0x8B && p[2] == 0x15)
							return p + 7 + *(int*)(p + 3);
				}
				return null;
			}

			static unsafe byte* LookUp(byte* p, int key) {
				p = *(byte**)(p + IntPtr.Size);
				p = *(byte**)(p + IntPtr.Size);

				int f1 = 0;
				int f2 = IntPtr.Size * 2;
				int f3 = IntPtr.Size * 3;
				int f4 = IntPtr.Size * 4;
				int f5 = IntPtr.Size * 5 + 1;

				byte* res = null;
				while (true) {
					if (*(p + f5) != 0)
						break;
					int k = *(int*)(p + f3);
					if (k < key)
						p = *(byte**)(p + f2);
					else {
						res = p;
						p = *(byte**)(p + f1);
					}
				}
				return *(byte**)(res + f4);
			}

			byte[] aryDummy = new byte[7];
			IntPtr dummy;
			public unsafe byte[] Decrypt(int methodId, uint rid) {
				fixed (byte* p = &aryDummy[0]) {
					dummy = new IntPtr(p);
					decryptedData = null;
					currentILBytes = dmd.reflectionModule.ResolveMethod(0x06000000 + (int)rid).GetMethodBody().GetILAsByteArray();
					invoker.DynamicInvoke(new object[1] { methodId });
				}
				dummy = IntPtr.Zero;
				return decryptedData;
			}

			byte[] GetCallerMethodAsILByteArray(IntPtr a, int skipFrames, ref int flags, IntPtr d) {
				flags = 2;
				return currentILBytes;
			}

			unsafe bool DecryptCallback(IntPtr a, byte* pMethodCode, int methodSize, int methodId, IntPtr e) {
				decryptedData = new byte[methodSize];
				Marshal.Copy(new IntPtr(pMethodCode), decryptedData, 0, decryptedData.Length);
				return true;
			}

			IntPtr IgnoreMethod(IntPtr a, IntPtr b) => dummy;
		}

		class DecrypterV2_0_13_0 : DecrypterV2_0_13_0_Base {
			public unsafe DecrypterV2_0_13_0(DynamicMethodsDecrypter dmd)
				: base(dmd) {
			}

			static readonly byte[] initCode_x86 = new byte[] {
				0x8B, 0xCC, 0x8B, 0x41, 0x04, 0xFF, 0x71, 0x10,
				0xFF, 0x71, 0x0C, 0xFF, 0x71, 0x08, 0xFF, 0x51,
				0x14, 0xC2, 0x14, 0x00,
			};
			unsafe delegate void InitCode32Delegate(byte* pppam, byte* m, IntPtr s, byte* pd, byte* f);
			unsafe delegate void InitCode64Delegate(byte* pppam, byte* m, IntPtr s, byte* pd);
			protected unsafe override void InitCode(byte* ba, byte* pam, byte* pd, byte* pm) {
				byte* ppam = (byte*)&pam;
				byte* pppam = (byte*)&ppam;
				if (IntPtr.Size == 4) {
					var del = (InitCode32Delegate)Marshal.GetDelegateForFunctionPointer(CodeAllocator.Allocate(initCode_x86), typeof(InitCode32Delegate));
					del(pppam, pm, new IntPtr(IntPtr.Size * 4), pd, ba + 0x00012500);
				}
				else {
					var del = (InitCode64Delegate)Marshal.GetDelegateForFunctionPointer(new IntPtr(ba + 0x00014CF0), typeof(InitCode64Delegate));
					del(pppam, pm, new IntPtr(IntPtr.Size * 4), pd);
				}
			}
		}

		class DecrypterV2_0_13_1 : DecrypterV2_0_13_0_Base {
			public unsafe DecrypterV2_0_13_1(DynamicMethodsDecrypter dmd)
				: base(dmd) {
			}

			unsafe delegate void InitCodeDelegate(byte* pppam, byte* m, IntPtr s, byte* pd);
			protected unsafe override void InitCode(byte* ba, byte* pam, byte* pd, byte* pm) {
				int rva = IntPtr.Size == 4 ? 0x00013650 : 0x00016B50;
				var del = (InitCodeDelegate)Marshal.GetDelegateForFunctionPointer(new IntPtr(ba + rva), typeof(InitCodeDelegate));
				byte* ppam = (byte*)&pam;
				byte* pppam = (byte*)&ppam;
				del(pppam, pm, new IntPtr(IntPtr.Size * 4), pd);
			}
		}

		public bool MethodReaderHasDelegateTypeFlag => methodReaderHasDelegateTypeFlag;

		public DynamicMethodsDecrypter(ModuleDefMD module, Module reflectionModule) {
			this.module = module;
			this.reflectionModule = reflectionModule;
		}

		public void Initialize() {
			RuntimeHelpers.RunModuleConstructor(reflectionModule.ModuleHandle);
			var reflectionProtectAssembly = GetProtectAssembly();
			if (reflectionProtectAssembly == null)
				throw new ApplicationException("Could not find 'Protect' assembly");
			reflectionProtectModule = reflectionProtectAssembly.ManifestModule;
			moduleProtect = ModuleDefMD.Load(reflectionProtectModule);
			protectMainType = FindMainType(moduleProtect);
			if (protectMainType == null)
				throw new ApplicationException("Could not find Protect.MainType");
			var invokerField = FindInvokerField(module);

			/*reflectionProtectMainType =*/ reflectionProtectModule.ResolveType(0x02000000 + (int)protectMainType.Rid);
			invokerFieldInfo = reflectionModule.ResolveField(0x04000000 + (int)invokerField.Rid);

			decrypter = CreateDecrypter();
			if (decrypter == null)
				throw new ApplicationException("Probably a new version. Could not create a decrypter.");
		}

		public DecryptedMethodInfo Decrypt(int methodId, uint rid) {
			byte[] methodData = decrypter.Decrypt(methodId, rid);
			if (methodData == null)
				throw new ApplicationException($"Probably a new version. Could not decrypt method. ID:{methodId}, RID:{rid:X4}");
			return new DecryptedMethodInfo(methodId, methodData);
		}

		public void Dispose() {
			if (moduleProtect != null)
				moduleProtect.Dispose();
			moduleProtect = null;
		}

		IDecrypter CreateDecrypter() {
			var version = reflectionProtectModule.Assembly.GetName().Version;
			if (reflectionProtectModule.Assembly.GetName().Version < new Version(2, 0, 12, 0)) {
				return CreateDecrypterV1_0_7_0() ??
					CreateDecrypterV2_0_0_0() ??
					CreateDecrypterV2_0_8_0() ??
					CreateDecrypterV2_0_8_5() ??
					CreateDecrypterV2_0_9_0();
			}

			methodReaderHasDelegateTypeFlag = true;
			if (version < new Version(2, 0, 12, 3))
				return new DecrypterV2_0_12_0(this);
			if (version == new Version(2, 0, 12, 3))
				return new DecrypterV2_0_12_3(this);
			if (version == new Version(2, 0, 13, 0))
				return new DecrypterV2_0_13_0(this);
			if (version == new Version(2, 0, 13, 1))
				return new DecrypterV2_0_13_1(this);

			return null;
		}

		IDecrypter CreateDecrypterV1_0_7_0() {
			var delegateField = FindDelegateFieldV1_0_7_0(protectMainType);
			if (delegateField == null)
				return null;

			return new DecrypterV1_0_7_0(this, delegateField);
		}

		IDecrypter CreateDecrypterV2_0_0_0() {
			var delegateField = FindDelegateFieldV2_0_0_0(protectMainType);
			if (delegateField == null)
				return null;

			return new DecrypterV2_0_0_0(this, delegateField);
		}

		IDecrypter CreateDecrypterV2_0_8_0() {
			var delegateField = FindDelegateFieldV2_0_8_0(protectMainType, FindDecryptCallbackV2_0_8_0(protectMainType));
			if (delegateField == null)
				return null;

			return new DecrypterV2_0_8_0(this, delegateField);
		}

		IDecrypter CreateDecrypterV2_0_8_5() {
			var delegateField = FindDelegateFieldV2_0_8_5(protectMainType, FindDecryptCallbackV2_0_8_0(protectMainType));
			if (delegateField == null)
				return null;

			return new DecrypterV2_0_8_5(this, delegateField);
		}

		IDecrypter CreateDecrypterV2_0_9_0() {
			var delegateField = FindDelegateFieldV2_0_9_0(protectMainType, FindDecryptCallbackV2_0_9_0(protectMainType));
			if (delegateField == null)
				return null;

			return new DecrypterV2_0_9_0(this, delegateField);
		}

		static readonly byte[] ilpPublicKeyToken = new byte[8] { 0x20, 0x12, 0xD3, 0xC0, 0x55, 0x1F, 0xE0, 0x3D };
		static Assembly GetProtectAssembly() {
			foreach (var asm in AppDomain.CurrentDomain.GetAssemblies()) {
				if (!string.IsNullOrEmpty(asm.Location))
					continue;
				var asmName = asm.GetName();
				if (asmName.Name != "Protect")
					continue;
				if (!Compare(asmName.GetPublicKeyToken(), ilpPublicKeyToken))
					continue;

				return asm;
			}
			return null;
		}

		static bool Compare(byte[] a, byte[] b) {
			if (a == null && b == null)
				return true;
			if (a == null || b == null)
				return false;
			if (a.Length != b.Length)
				return false;
			for (int i = 0; i < a.Length; i++) {
				if (a[i] != b[i])
					return false;
			}
			return true;
		}

		static TypeDef FindMainType(ModuleDef module) {
			foreach (var type in module.Types) {
				if (type.FindMethod("Finalize") != null)
					return type;
			}
			return null;
		}

		static FieldDef FindInvokerField(ModuleDef module) =>
			FindDelegateField(module.GlobalType, "System.Delegate", "(System.Int32)");

		static FieldDef FindDelegateFieldV1_0_7_0(TypeDef mainType) =>
			FindDelegateField(mainType, "System.Boolean", "(System.Int32,System.Int32,System.Int32,System.Byte*&,System.Int32&)");

		static FieldDef FindDelegateFieldV2_0_0_0(TypeDef mainType) =>
			FindDelegateField(mainType, "System.Boolean", "(System.Int32,System.Int32,System.Int32,System.Int32,System.Byte*&,System.Int32&)");

		static FieldDef FindDecryptCallbackV2_0_8_0(TypeDef mainType) =>
			FindDelegateField(mainType, "System.Boolean", "(System.Byte*,System.Int32,System.Delegate&)");

		static FieldDef FindDecryptCallbackV2_0_9_0(TypeDef mainType) =>
			FindDelegateField(mainType, "System.Boolean", "(System.Byte*,System.Int32,System.Int32)");

		static FieldDef FindDelegateFieldV2_0_8_0(TypeDef mainType, FieldDef decryptCallbackField) {
			if (decryptCallbackField == null)
				return null;
			var type = decryptCallbackField.FieldSig.GetFieldType().ToTypeDefOrRef() as TypeDef;
			if (type == null)
				return null;
			return FindDelegateField(mainType, "System.Boolean", $"(System.Int32,System.Int32,System.Int32,System.Int32,{type.FullName},System.Delegate&)");
		}

		static FieldDef FindDelegateFieldV2_0_8_5(TypeDef mainType, FieldDef decryptCallbackField) {
			if (decryptCallbackField == null)
				return null;
			var type = decryptCallbackField.FieldSig.GetFieldType().ToTypeDefOrRef() as TypeDef;
			if (type == null)
				return null;
			return FindDelegateField(mainType, "System.Boolean", $"(System.Int32,System.Int32,System.Int32,System.Int32,System.Diagnostics.StackTrace,{type.FullName},System.Delegate&)");
		}

		static FieldDef FindDelegateFieldV2_0_9_0(TypeDef mainType, FieldDef decryptCallbackField) {
			if (decryptCallbackField == null)
				return null;
			var type = decryptCallbackField.FieldSig.GetFieldType().ToTypeDefOrRef() as TypeDef;
			if (type == null)
				return null;
			return FindDelegateField(mainType, "System.Boolean", $"(System.Int32,System.Int32,System.Int32,System.Int32,System.Diagnostics.StackTrace,{type.FullName})");
		}

		static FieldDef FindDelegateField(TypeDef mainType, string returnType, string parameters) {
			foreach (var field in mainType.Fields) {
				var fieldSig = field.FieldSig;
				if (fieldSig == null)
					continue;
				var fieldType = fieldSig.Type.ToTypeDefOrRef() as TypeDef;
				if (fieldType == null)
					continue;
				if (fieldType.BaseType != null && fieldType.BaseType.FullName != "System.MulticastDelegate")
					continue;
				var invokeMethod = fieldType.FindMethod("Invoke");
				if (!DotNetUtils.IsMethod(invokeMethod, returnType, parameters))
					continue;

				return field;
			}
			return null;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/ILProtector/DynamicMethodsDecrypterService.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Reflection;
using System.Collections.Generic;
using dnlib.DotNet;
using AssemblyData;

namespace de4dot.code.deobfuscators.ILProtector {
	sealed class DynamicMethodsDecrypterService : IUserGenericService {
		public const int MSG_DECRYPT_METHODS = 0;
		public const int MSG_HAS_DELEGATE_TYPE_FLAG = 1;

		Module reflObfModule;
		ModuleDefMD obfModule;
		bool hasDelegateTypeFlag;

		[CreateUserGenericService]
		public static IUserGenericService Create() => new DynamicMethodsDecrypterService();

		public void Dispose() {
			if (obfModule != null)
				obfModule.Dispose();
			obfModule = null;
		}

		public void AssemblyLoaded(Assembly assembly) {
			reflObfModule = assembly.ManifestModule;
			obfModule = ModuleDefMD.Load(reflObfModule);
		}

		public object HandleMessage(int msg, object[] args) {
			switch (msg) {
			case MSG_DECRYPT_METHODS:
				return DecryptMethods(args[0] as IList<int>);

			case MSG_HAS_DELEGATE_TYPE_FLAG:
				return hasDelegateTypeFlag;

			default:
				throw new ApplicationException($"Invalid msg: {msg:X8}");
			}
		}

		IList<DecryptedMethodInfo> DecryptMethods(IList<int> methodIds) {
			using (var decrypter = new DynamicMethodsDecrypter(obfModule, reflObfModule)) {
				decrypter.Initialize();

				var infos = new List<DecryptedMethodInfo>();

				for (int i = 0; i < methodIds.Count; i += 2)
					infos.Add(decrypter.Decrypt(methodIds[i], (uint)methodIds[i + 1]));

				hasDelegateTypeFlag = decrypter.MethodReaderHasDelegateTypeFlag;

				return infos;
			}
		}
	}
}



================================================
File: de4dot.code/deobfuscators/ILProtector/DynamicMethodsRestorer.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.IO;
using dnlib.DotNet;
using AssemblyData;
using de4dot.code.AssemblyClient;

namespace de4dot.code.deobfuscators.ILProtector {
	// Calls class to dynamically decrypt methods, then restores them.
	class DynamicMethodsRestorer : MethodsDecrypterBase {
		public DynamicMethodsRestorer(ModuleDefMD module, MainType mainType)
			: base(module, mainType) {
		}

		protected override void DecryptInternal() {
			CheckRuntimeFiles();
			IList<DecryptedMethodInfo> decryptedData;
			var serverVersion = NewProcessAssemblyClientFactory.GetServerClrVersion(module);
			using (var client = new NewProcessAssemblyClientFactory(serverVersion).Create(AssemblyServiceType.Generic)) {
				client.Connect();
				client.WaitConnected();

				client.GenericService.LoadUserService(typeof(DynamicMethodsDecrypterService), null);
				client.GenericService.LoadAssembly(module.Location);
				decryptedData = client.GenericService.SendMessage(DynamicMethodsDecrypterService.MSG_DECRYPT_METHODS, new object[] { GetMethodIds() }) as IList<DecryptedMethodInfo>;
				MethodReaderHasDelegateTypeFlag = (bool)client.GenericService.SendMessage(DynamicMethodsDecrypterService.MSG_HAS_DELEGATE_TYPE_FLAG, new object[0]);
			}

			if (decryptedData == null)
				throw new ApplicationException("Unknown return value from dynamic methods decrypter service");

			foreach (var info in decryptedData)
				methodInfos[info.id] = info;
		}

		void CheckRuntimeFiles() {
			foreach (var info in mainType.RuntimeFileInfos) {
				if (!File.Exists(info.PathName))
					Logger.w($"ILProtector runtime file '{info.PathName}' is missing.");
			}
		}

		IList<int> GetMethodIds() {
			var ids = new List<int>();

			foreach (var type in module.GetTypes()) {
				foreach (var method in type.Methods) {
					int? id = GetMethodId(method);
					if (id == null)
						continue;

					ids.Add(id.Value);
					ids.Add((int)method.Rid);
				}
			}

			return ids;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/ILProtector/MainType.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.ILProtector {
	class MainType {
		ModuleDefMD module;
		List<RuntimeFileInfo> runtimeFileInfos;
		TypeDef invokerDelegate;
		FieldDef invokerInstanceField;

		public List<RuntimeFileInfo> RuntimeFileInfos => runtimeFileInfos;
		public TypeDef InvokerDelegate => invokerDelegate;
		public FieldDef InvokerInstanceField => invokerInstanceField;
		public bool Detected => runtimeFileInfos != null;
		public MainType(ModuleDefMD module) => this.module = module;
		public void Find() => CheckMethod(DotNetUtils.GetModuleTypeCctor(module));

		static string[] ilpLocalsV1x = new string[] {
			"System.Boolean",
			"System.IntPtr",
			"System.Object[]",
		};
		static string[] ilpLocalsV2x = new string[] {
			"System.IntPtr",
		};
		bool CheckMethod(MethodDef cctor) {
			if (cctor == null || cctor.Body == null)
				return false;
			var localTypes = new LocalTypes(cctor);
			if (!localTypes.Exactly(ilpLocalsV1x) &&
				!localTypes.Exactly(ilpLocalsV2x))
				return false;

			var type = cctor.DeclaringType;
			var methods = GetPinvokeMethods(type, "Protect");
			if (methods.Count == 0)
				methods = GetPinvokeMethods(type, "P0");
			if (methods.Count != 2)
				return false;
			if (type.Fields.Count < 1 || type.Fields.Count > 2)
				return false;

			if (!GetDelegate(type, out invokerInstanceField, out invokerDelegate))
				return false;

			runtimeFileInfos = new List<RuntimeFileInfo>(methods.Count);
			foreach (var method in methods)
				runtimeFileInfos.Add(new RuntimeFileInfo(method));
			return true;
		}

		bool GetDelegate(TypeDef type, out FieldDef field, out TypeDef del) {
			foreach (var fld in type.Fields) {
				var theDelegate = fld.FieldType.TryGetTypeDef();
				if (theDelegate != null && DotNetUtils.DerivesFromDelegate(theDelegate)) {
					field = fld;
					del = theDelegate;
					return true;
				}
			}

			field = null;
			del = null;
			return false;
		}

		static List<MethodDef> GetPinvokeMethods(TypeDef type, string name) {
			var list = new List<MethodDef>();
			foreach (var method in type.Methods) {
				if (method.ImplMap != null && method.ImplMap.Name == name)
					list.Add(method);
			}
			return list;
		}

		public string GetRuntimeVersionString() {
			if (runtimeFileInfos == null)
				return null;
			foreach (var info in runtimeFileInfos) {
				var version = info.GetVersion();
				if (version != null)
					return version.ToString();
			}
			return null;
		}

		public void CleanUp() {
			var cctor = DotNetUtils.GetModuleTypeCctor(module);
			if (cctor != null) {
				cctor.Body.InitLocals = false;
				cctor.Body.Variables.Clear();
				cctor.Body.Instructions.Clear();
				cctor.Body.Instructions.Add(OpCodes.Ret.ToInstruction());
				cctor.Body.ExceptionHandlers.Clear();
			}
		}
	}
}



================================================
File: de4dot.code/deobfuscators/ILProtector/MethodReader.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.IO;
using dnlib.DotNet;
using dnlib.DotNet.MD;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.ILProtector {
	class MethodReader : MethodBodyReaderBase {
		ModuleDefMD module;
		MethodFlags flags;
		TypeDef delegateType;
		bool hasDelegateTypeFlag;
		GenericParamContext gpContext;

		[Flags]
		enum MethodFlags {
			InitLocals = 1,
			HasLocals = 2,
			HasInstructions = 4,
			HasExceptionHandlers = 8,
			HasDelegateType = 0x10,
		}

		public TypeDef DelegateType => delegateType;
		public bool InitLocals => (flags & MethodFlags.InitLocals) != 0;
		bool HasLocals => (flags & MethodFlags.HasLocals) != 0;
		bool HasInstructions => (flags & MethodFlags.HasInstructions) != 0;
		bool HasExceptionHandlers => (flags & MethodFlags.HasExceptionHandlers) != 0;
		bool HasDelegateType => !hasDelegateTypeFlag || (flags & MethodFlags.HasDelegateType) != 0;

		public bool HasDelegateTypeFlag {
			get => hasDelegateTypeFlag;
			set => hasDelegateTypeFlag = value;
		}

		public MethodReader(ModuleDefMD module, byte[] data, IList<Parameter> parameters)
			: base(ByteArrayDataReaderFactory.CreateReader(data), parameters) => this.module = module;

		public void Read(MethodDef method) {
			gpContext = GenericParamContext.Create(method);
			flags = (MethodFlags)reader.ReadByte();
			if (HasDelegateType) {
				delegateType = Resolve<TypeDef>(ReadTypeToken());
				if (!DotNetUtils.DerivesFromDelegate(delegateType))
					throw new ApplicationException("Invalid delegate type");
			}
			if (HasLocals)
				ReadLocals((int)reader.Read7BitEncodedUInt32());
			if (HasInstructions)
				ReadInstructions((int)reader.Read7BitEncodedUInt32());
			if (HasExceptionHandlers)
				ReadExceptionHandlers((int)reader.Read7BitEncodedUInt32());
		}

		int GetTypeDefOrRefToken(uint token) {
			switch (token & 3) {
			case 0: return 0x02000000 + (int)(token >> 2);
			case 1: return 0x01000000 + (int)(token >> 2);
			case 2: return 0x1B000000 + (int)(token >> 2);
			default: throw new ApplicationException("Invalid token");
			}
		}

		void ReadLocals(int numLocals) {
			var localsTypes = new List<TypeSig>();
			for (int i = 0; i < numLocals; i++)
				localsTypes.Add(ReadType());
			SetLocals(localsTypes);
		}

		T Resolve<T>(int token) => (T)module.ResolveToken(token, gpContext);
		int ReadTypeToken() => GetTypeDefOrRefToken(reader.Read7BitEncodedUInt32());

		TypeSig ReadType() {
			switch ((ElementType)reader.ReadByte()) {
			case ElementType.Void:		return module.CorLibTypes.Void;
			case ElementType.Boolean:	return module.CorLibTypes.Boolean;
			case ElementType.Char:		return module.CorLibTypes.Char;
			case ElementType.I1:		return module.CorLibTypes.SByte;
			case ElementType.U1:		return module.CorLibTypes.Byte;
			case ElementType.I2:		return module.CorLibTypes.Int16;
			case ElementType.U2:		return module.CorLibTypes.UInt16;
			case ElementType.I4:		return module.CorLibTypes.Int32;
			case ElementType.U4:		return module.CorLibTypes.UInt32;
			case ElementType.I8:		return module.CorLibTypes.Int64;
			case ElementType.U8:		return module.CorLibTypes.UInt64;
			case ElementType.R4:		return module.CorLibTypes.Single;
			case ElementType.R8:		return module.CorLibTypes.Double;
			case ElementType.String:	return module.CorLibTypes.String;
			case ElementType.Ptr:		return new PtrSig(ReadType());
			case ElementType.ByRef:		return new ByRefSig(ReadType());
			case ElementType.TypedByRef:return module.CorLibTypes.TypedReference;
			case ElementType.I:			return module.CorLibTypes.IntPtr;
			case ElementType.U:			return module.CorLibTypes.UIntPtr;
			case ElementType.Object:	return module.CorLibTypes.Object;
			case ElementType.SZArray:	return new SZArraySig(ReadType());
			case ElementType.Sentinel:	ReadType(); return new SentinelSig();
			case ElementType.Pinned:	return new PinnedSig(ReadType());

			case ElementType.ValueType:
			case ElementType.Class:
				return Resolve<ITypeDefOrRef>(ReadTypeToken()).ToTypeSig();

			case ElementType.Array:
				var arrayType = ReadType();
				uint rank = reader.Read7BitEncodedUInt32();
				return new ArraySig(arrayType, rank);

			case ElementType.GenericInst:
				reader.ReadByte();
				var genericType = Resolve<ITypeDefOrRef>(ReadTypeToken());
				int numGenericArgs = (int)reader.Read7BitEncodedUInt32();
				var git = new GenericInstSig(genericType.ToTypeSig() as ClassOrValueTypeSig);
				for (int i = 0; i < numGenericArgs; i++)
					git.GenericArguments.Add(ReadType());
				return git;

			case ElementType.Var:
			case ElementType.MVar:
			case ElementType.FnPtr:
			case ElementType.CModReqd:
			case ElementType.CModOpt:
			case ElementType.Internal:
			default:
				throw new ApplicationException("Invalid local element type");
			}
		}

		protected override IField ReadInlineField(Instruction instr) => Resolve<IField>(reader.ReadInt32());
		protected override IMethod ReadInlineMethod(Instruction instr) => Resolve<IMethod>(reader.ReadInt32());

		protected override MethodSig ReadInlineSig(Instruction instr) {
			var token = reader.ReadUInt32();
			if (MDToken.ToTable(token) != Table.StandAloneSig)
				return null;
			var sas = module.ResolveStandAloneSig(MDToken.ToRID(token), gpContext);
			return sas?.MethodSig;
		}

		protected override string ReadInlineString(Instruction instr) => module.ReadUserString(reader.ReadUInt32());
		protected override ITokenOperand ReadInlineTok(Instruction instr) => Resolve<ITokenOperand>(reader.ReadInt32());
		protected override ITypeDefOrRef ReadInlineType(Instruction instr) => Resolve<ITypeDefOrRef>(reader.ReadInt32());

		void ReadExceptionHandlers(int numExceptionHandlers) {
			exceptionHandlers = new List<ExceptionHandler>(numExceptionHandlers);
			for (int i = 0; i < numExceptionHandlers; i++)
				Add(ReadExceptionHandler());
		}

		ExceptionHandler ReadExceptionHandler() {
			var eh = new ExceptionHandler((ExceptionHandlerType)(reader.Read7BitEncodedUInt32() & 7));

			uint tryOffset = reader.Read7BitEncodedUInt32();
			eh.TryStart = GetInstructionThrow(tryOffset);
			eh.TryEnd = GetInstruction(tryOffset + reader.Read7BitEncodedUInt32());

			uint handlerOffset = reader.Read7BitEncodedUInt32();
			eh.HandlerStart = GetInstructionThrow(handlerOffset);
			eh.HandlerEnd = GetInstruction(handlerOffset + reader.Read7BitEncodedUInt32());

			switch (eh.HandlerType) {
			case ExceptionHandlerType.Catch:
				eh.CatchType = Resolve<ITypeDefOrRef>(reader.ReadInt32());
				break;

			case ExceptionHandlerType.Filter:
				eh.FilterStart = GetInstructionThrow(reader.ReadUInt32());
				break;

			case ExceptionHandlerType.Finally:
			case ExceptionHandlerType.Fault:
			default:
				reader.ReadInt32();
				break;
			}

			return eh;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/ILProtector/MethodsDecrypterBase.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace de4dot.code.deobfuscators.ILProtector {
	abstract class MethodsDecrypterBase {
		protected ModuleDefMD module;
		protected MainType mainType;
		protected EmbeddedResource methodsResource;
		protected Dictionary<int, DecryptedMethodInfo> methodInfos = new Dictionary<int, DecryptedMethodInfo>();
		List<TypeDef> delegateTypes = new List<TypeDef>();

		public EmbeddedResource Resource => methodsResource;
		public IEnumerable<TypeDef> DelegateTypes => delegateTypes;
		public bool MethodReaderHasDelegateTypeFlag { get; set; }

		public MethodsDecrypterBase(ModuleDefMD module, MainType mainType) {
			this.module = module;
			this.mainType = mainType;
		}

		public void Decrypt() {
			DecryptInternal();
			RestoreMethods();
		}

		protected abstract void DecryptInternal();

		void RestoreMethods() {
			if (methodInfos.Count == 0)
				return;

			Logger.v("Restoring {0} methods", methodInfos.Count);
			Logger.Instance.Indent();
			foreach (var type in module.GetTypes()) {
				foreach (var method in type.Methods) {
					if (method.Body == null)
						continue;

					if (RestoreMethod(method)) {
						Logger.v("Restored method {0} ({1:X8}). Instrs:{2}, Locals:{3}, Exceptions:{4}",
							Utils.RemoveNewlines(method.FullName),
							method.MDToken.ToInt32(),
							method.Body.Instructions.Count,
							method.Body.Variables.Count,
							method.Body.ExceptionHandlers.Count);
					}
				}
			}
			Logger.Instance.DeIndent();
			if (methodInfos.Count != 0)
				Logger.w("{0} methods weren't restored", methodInfos.Count);
		}

		bool RestoreMethod(MethodDef method) {
			int? methodId = GetMethodId(method);
			if (methodId == null)
				return false;

			var parameters = method.Parameters;
			var methodInfo = methodInfos[methodId.Value];
			methodInfos.Remove(methodId.Value);
			var methodReader = new MethodReader(module, methodInfo.data, parameters);
			methodReader.HasDelegateTypeFlag = MethodReaderHasDelegateTypeFlag;
			methodReader.Read(method);

			RestoreMethod(method, methodReader);
			if (methodReader.DelegateType != null)
				delegateTypes.Add(methodReader.DelegateType);

			return true;
		}

		static void RestoreMethod(MethodDef method, MethodReader methodReader) {
			// body.MaxStackSize = <let dnlib calculate this>
			method.Body.InitLocals = methodReader.InitLocals;
			methodReader.RestoreMethod(method);
		}

		protected int? GetMethodId(MethodDef method) {
			if (method == null || method.Body == null)
				return null;

			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 1; i++) {
				var ldsfld = instrs[i];
				if (ldsfld.OpCode.Code != Code.Ldsfld)
					continue;

				var ldci4 = instrs[i + 1];
				if (!ldci4.IsLdcI4())
					continue;

				var field = ldsfld.Operand as FieldDef;
				if (field == null || field != mainType.InvokerInstanceField)
					continue;

				return ldci4.GetLdcI4Value();
			}

			return null;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/ILProtector/RuntimeFileInfo.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.IO;
using System.Security.Cryptography;
using dnlib.DotNet;

namespace de4dot.code.deobfuscators.ILProtector {
	class RuntimeFileInfo {
		public MethodDef ProtectMethod { get; private set; }
		public string PathName { get; private set; }
		public string Name { get; private set; }
		Version runtimeVersion;
		bool runtimeVersionInitialized;

		class VersionInfo {
			public Version Version { get; private set; }
			public uint FileOffset { get; private set; }
			public byte[] Hash { get; private set; }

			public VersionInfo(Version version, byte[] hash) {
				Version = version;
				Hash = hash;
			}
		}

		static readonly VersionInfo[] versionInfo32 = new VersionInfo[] {
			new VersionInfo(new Version(1, 0, 7, 0), new byte[] { 0x1B, 0x7A, 0x48, 0x9E, 0x70, 0x69, 0x3C, 0x51, 0xDB, 0x3E, 0xD8, 0x09, 0x71, 0x1F, 0x16, 0x33 }),
			new VersionInfo(new Version(1, 0, 7, 1), new byte[] { 0xD2, 0x76, 0x37, 0xA2, 0xE4, 0xCC, 0x66, 0xAB, 0x6A, 0x72, 0x45, 0x25, 0x06, 0x64, 0x05, 0xD7 }),
			new VersionInfo(new Version(1, 0, 8, 0), new byte[] { 0x0B, 0x3D, 0xFD, 0xB3, 0x8B, 0xCF, 0x59, 0x42, 0x9C, 0x4C, 0x2B, 0x43, 0xA4, 0x22, 0x91, 0xB0 }),
			new VersionInfo(new Version(2, 0, 0, 0), new byte[] { 0xC5, 0x8A, 0x92, 0x92, 0xBD, 0xA4, 0x6D, 0xF2, 0xEA, 0xF8, 0x4F, 0x79, 0x89, 0xF2, 0x44, 0x38 }),
			new VersionInfo(new Version(2, 0, 1, 0), new byte[] { 0xFD, 0x79, 0x53, 0x6C, 0xDA, 0x10, 0x3F, 0x29, 0xBF, 0x52, 0x4B, 0x70, 0xB2, 0xFF, 0x55, 0x25 }),
			new VersionInfo(new Version(2, 0, 2, 0), new byte[] { 0xED, 0xC2, 0xB2, 0x07, 0x1F, 0x1A, 0xF0, 0x4D, 0x9B, 0x37, 0x6F, 0x10, 0x7A, 0xDA, 0xA2, 0xED }),
			new VersionInfo(new Version(2, 0, 3, 0), new byte[] { 0xF3, 0xD8, 0x48, 0x69, 0x2B, 0x39, 0x99, 0x48, 0xB7, 0x8D, 0x0D, 0x72, 0xC5, 0xE4, 0xF5, 0x6D }),
			new VersionInfo(new Version(2, 0, 4, 0), new byte[] { 0xBC, 0x39, 0x58, 0x38, 0x5C, 0x2F, 0x5A, 0x50, 0xCF, 0xF7, 0x47, 0xC7, 0xEC, 0x52, 0xC6, 0xD0 }),
			new VersionInfo(new Version(2, 0, 5, 0), new byte[] { 0x90, 0x42, 0x0F, 0xB5, 0x84, 0x09, 0x90, 0xE5, 0xD8, 0x10, 0xF1, 0xAF, 0xF5, 0xBC, 0xA5, 0xF8 }),
			new VersionInfo(new Version(2, 0, 6, 0), new byte[] { 0xD1, 0x8D, 0x0C, 0x3C, 0x51, 0xBD, 0x36, 0x37, 0x17, 0xAB, 0xEC, 0x92, 0x19, 0x1B, 0xB0, 0xD6 }),
			new VersionInfo(new Version(2, 0, 7, 0), new byte[] { 0x02, 0xD1, 0x75, 0x77, 0x12, 0x6D, 0x4E, 0x86, 0x90, 0x34, 0x6A, 0xBB, 0x56, 0x0E, 0x6A, 0xEA }),
			new VersionInfo(new Version(2, 0, 7, 5), new byte[] { 0x7D, 0x5C, 0xBE, 0x21, 0x0B, 0xA9, 0x15, 0xFF, 0xE6, 0xC9, 0xD5, 0xFD, 0x7C, 0xA0, 0xAA, 0xC1 }),
			new VersionInfo(new Version(2, 0, 7, 6), new byte[] { 0x0D, 0x03, 0xB7, 0x1A, 0x74, 0x8E, 0x6B, 0x94, 0x2B, 0xD4, 0x33, 0x24, 0x49, 0xF8, 0x38, 0xD2 }),
			new VersionInfo(new Version(2, 0, 8, 0), new byte[] { 0xE6, 0xD6, 0x07, 0x89, 0x03, 0xA8, 0xE3, 0xD7, 0x86, 0x5A, 0x3D, 0xC2, 0x86, 0xF5, 0x0F, 0x67 }),
			new VersionInfo(new Version(2, 0, 8, 5), new byte[] { 0xFC, 0x79, 0x83, 0x61, 0xD2, 0x99, 0x8E, 0xE8, 0x2C, 0x5F, 0x14, 0xBA, 0xCB, 0xB9, 0x28, 0xF2 }),
			new VersionInfo(new Version(2, 0, 9, 0), new byte[] { 0x7A, 0x88, 0xD8, 0xC3, 0xB8, 0x77, 0xAA, 0x13, 0xC0, 0x6C, 0x43, 0x88, 0x0D, 0x66, 0xFE, 0x7A }),
			new VersionInfo(new Version(2, 0, 10, 0), new byte[] { 0xE5, 0x8E, 0xEB, 0x26, 0x1A, 0x1C, 0x44, 0xA8, 0xFF, 0x88, 0x14, 0xE7, 0x38, 0x13, 0xE5, 0x6D }),
			new VersionInfo(new Version(2, 0, 11, 0), new byte[] { 0x67, 0xB8, 0xF7, 0x15, 0x70, 0x1D, 0xF2, 0x57, 0x00, 0x42, 0xF3, 0xA4, 0x83, 0x07, 0x62, 0xA3 }),
			new VersionInfo(new Version(2, 0, 11, 1), new byte[] { 0x2E, 0xC9, 0x53, 0xA0, 0x3C, 0x9B, 0x08, 0xDA, 0x88, 0x84, 0x37, 0xFC, 0x07, 0xAE, 0x8B, 0xEC }),
			new VersionInfo(new Version(2, 0, 12, 0), new byte[] { 0x63, 0x8B, 0x5C, 0xE9, 0x89, 0x83, 0x57, 0x9D, 0xDC, 0xC3, 0xBD, 0xD9, 0xDB, 0x54, 0xBE, 0x66 }),
			new VersionInfo(new Version(2, 0, 12, 2), new byte[] { 0xD5, 0x46, 0x38, 0xC7, 0x48, 0xF6, 0x3C, 0x1C, 0x1E, 0x7F, 0x3B, 0x7B, 0x5B, 0xE0, 0x49, 0x46 }),
			new VersionInfo(new Version(2, 0, 12, 3), new byte[] { 0x35, 0xA3, 0x53, 0xE9, 0x9E, 0x30, 0x6E, 0x9C, 0x0F, 0x46, 0x20, 0x9A, 0x91, 0xD2, 0x95, 0x18 }),
			new VersionInfo(new Version(2, 0, 13, 0), new byte[] { 0x66, 0x21, 0xA1, 0x1F, 0x8F, 0x4A, 0xD2, 0xF8, 0x68, 0xEE, 0xD5, 0xD9, 0xC8, 0xB8, 0x17, 0xC7 }),
			new VersionInfo(new Version(2, 0, 13, 1), new byte[] { 0xDF, 0x7A, 0xBF, 0x8B, 0xAD, 0x2B, 0x94, 0x6F, 0x37, 0xD9, 0x4B, 0xFC, 0x42, 0x7F, 0x0B, 0x37 }),
		};

		static readonly VersionInfo[] versionInfo64 = new VersionInfo[] {
			// No sig for 1.0.7.0 x64 since I don't have it yet.
			new VersionInfo(new Version(1, 0, 7, 1), new byte[] { 0x8E, 0xB4, 0x61, 0x12, 0xDF, 0x76, 0x6F, 0xAB, 0xF0, 0x2C, 0x7A, 0x3A, 0x0D, 0x71, 0xE8, 0xB0 }),
			new VersionInfo(new Version(1, 0, 8, 0), new byte[] { 0x04, 0xB1, 0xDA, 0x92, 0xE7, 0x59, 0x54, 0x82, 0x0F, 0x46, 0xD6, 0x08, 0xA2, 0x69, 0xB7, 0x75 }),
			new VersionInfo(new Version(2, 0, 0, 0), new byte[] { 0xC7, 0xD9, 0x62, 0x7E, 0xEC, 0x6D, 0x10, 0x8A, 0xBF, 0x71, 0x7A, 0x4C, 0xC0, 0x3E, 0xAE, 0x9E }),
			new VersionInfo(new Version(2, 0, 1, 0), new byte[] { 0xD3, 0xCF, 0x89, 0x80, 0xFD, 0xB7, 0x38, 0xC2, 0x3C, 0xDF, 0x4E, 0x9D, 0xCE, 0xDD, 0x95, 0xDE }),
			new VersionInfo(new Version(2, 0, 2, 0), new byte[] { 0x44, 0xB7, 0xBA, 0xF9, 0x0A, 0x5B, 0xD6, 0xE7, 0xBE, 0x7A, 0x47, 0x82, 0x3B, 0x24, 0xB3, 0x73 }),
			new VersionInfo(new Version(2, 0, 3, 0), new byte[] { 0x8D, 0x25, 0x16, 0x40, 0xB6, 0xCF, 0x54, 0xF8, 0x78, 0xBE, 0x3A, 0xE5, 0x3D, 0x5E, 0xF9, 0x60 }),
			new VersionInfo(new Version(2, 0, 4, 0), new byte[] { 0x7F, 0x49, 0xEA, 0x93, 0x8E, 0x81, 0xFC, 0xF5, 0x56, 0x94, 0x73, 0xA8, 0x52, 0x61, 0x79, 0x60 }),
			new VersionInfo(new Version(2, 0, 5, 0), new byte[] { 0x08, 0xDB, 0xA2, 0x8E, 0xD7, 0x27, 0xBB, 0xD0, 0x69, 0xF5, 0x63, 0x28, 0x46, 0xBF, 0xBB, 0xB3 }),
			new VersionInfo(new Version(2, 0, 6, 0), new byte[] { 0x09, 0xFC, 0x92, 0x18, 0xC8, 0x34, 0xD6, 0x55, 0xE3, 0x7C, 0xA5, 0xCB, 0x15, 0x28, 0x59, 0x94 }),
			new VersionInfo(new Version(2, 0, 7, 0), new byte[] { 0x7B, 0x36, 0x68, 0xA0, 0x9E, 0xCB, 0xB9, 0x73, 0x5B, 0x1A, 0xAC, 0x50, 0x7E, 0x59, 0x1C, 0xB7 }),
			new VersionInfo(new Version(2, 0, 7, 5), new byte[] { 0x14, 0x13, 0x30, 0x60, 0x1A, 0xB0, 0x6F, 0x37, 0x82, 0xE3, 0x67, 0x16, 0x6C, 0x62, 0x30, 0x16 }),
			new VersionInfo(new Version(2, 0, 7, 6), new byte[] { 0x98, 0xDE, 0x41, 0x4B, 0x15, 0x2C, 0xF7, 0x34, 0x2A, 0xEF, 0xE3, 0x91, 0x07, 0x7F, 0x0F, 0xE7 }),
			new VersionInfo(new Version(2, 0, 8, 0), new byte[] { 0x21, 0x40, 0xED, 0xC6, 0xA2, 0x13, 0x3D, 0xCA, 0x22, 0x11, 0x02, 0x75, 0xFC, 0xE6, 0x3A, 0x51 }),
			new VersionInfo(new Version(2, 0, 8, 5), new byte[] { 0xF5, 0x67, 0xC1, 0x44, 0xF6, 0x2F, 0xBA, 0x01, 0xA3, 0x01, 0x91, 0x60, 0xDF, 0x99, 0xAB, 0x0C }),
			new VersionInfo(new Version(2, 0, 9, 0), new byte[] { 0x04, 0x17, 0xF3, 0xEA, 0x97, 0x24, 0x48, 0xC0, 0x01, 0x2E, 0x45, 0x80, 0x9D, 0x5B, 0x7C, 0xDF }),
			new VersionInfo(new Version(2, 0, 10, 0), new byte[] { 0xD8, 0x79, 0x05, 0xC9, 0x2D, 0xA6, 0x5B, 0x7D, 0xEE, 0xA6, 0x13, 0x25, 0x7D, 0x29, 0x73, 0xB4 }),
			new VersionInfo(new Version(2, 0, 11, 0), new byte[] { 0x49, 0xAD, 0x40, 0x10, 0xD4, 0x03, 0x04, 0xB4, 0x3C, 0xD2, 0x36, 0x67, 0x38, 0x62, 0x9C, 0xE8 }),
			new VersionInfo(new Version(2, 0, 11, 1), new byte[] { 0x1D, 0x6C, 0xB6, 0xC8, 0xB3, 0x07, 0x53, 0x24, 0x6F, 0xC0, 0xF3, 0x4F, 0x5E, 0x8B, 0x9F, 0xD1 }),
			new VersionInfo(new Version(2, 0, 12, 0), new byte[] { 0x5F, 0x42, 0xA5, 0x6C, 0x19, 0xC6, 0x73, 0x9E, 0xE6, 0x74, 0x62, 0x3B, 0x8A, 0x51, 0xBB, 0x93 }),
			new VersionInfo(new Version(2, 0, 12, 2), new byte[] { 0x10, 0x91, 0xED, 0x05, 0x9C, 0x31, 0x0B, 0x63, 0x76, 0xD7, 0x4A, 0xEC, 0xDE, 0x99, 0x6D, 0xD0 }),
			new VersionInfo(new Version(2, 0, 12, 3), new byte[] { 0x38, 0x86, 0xE0, 0xBF, 0xC6, 0x64, 0xB9, 0xA0, 0x07, 0xED, 0xDB, 0x02, 0x40, 0xD0, 0x57, 0xE8 }),
			new VersionInfo(new Version(2, 0, 13, 0), new byte[] { 0xF0, 0x13, 0xC4, 0x6F, 0x31, 0x0F, 0x61, 0xEA, 0x89, 0x1E, 0x8A, 0x95, 0x8C, 0xBE, 0x2E, 0x44 }),
			new VersionInfo(new Version(2, 0, 13, 1), new byte[] { 0xD4, 0x71, 0x75, 0xE2, 0xB1, 0xA5, 0xAE, 0xF5, 0x32, 0xD7, 0x72, 0xDE, 0x93, 0xDC, 0x0B, 0x68 }),
		};

		public RuntimeFileInfo(MethodDef protectMethod) {
			ProtectMethod = protectMethod;
			Name = !protectMethod.HasImplMap ? "<<UNKNOWN_NAME>>" : protectMethod.ImplMap.Module.Name.String;
			PathName = Path.Combine(Path.GetDirectoryName(Utils.GetFullPath(protectMethod.Module.Location)), Name);
		}

		public Version GetVersion() {
			if (runtimeVersionInitialized)
				return runtimeVersion;
			runtimeVersion = GetVersion2();
			runtimeVersionInitialized = true;
			return runtimeVersion;
		}

		Version GetVersion2() {
			try {
				var hash = GetHash(PathName);
				var info = GetVersionInfo(hash, versionInfo32);
				if (info != null)
					return info.Version;
				info = GetVersionInfo(hash, versionInfo64);
				if (info != null)
					return info.Version;
			}
			catch {
			}
			return null;
		}

		static VersionInfo GetVersionInfo(byte[] hash, VersionInfo[] infos) {
			foreach (var info in infos) {
				if (Equals(hash, info.Hash))
					return info;
			}
			return null;
		}

		static byte[] GetHash(string fullPath) {
			try {
				using (var hasher = MD5.Create()) {
					using (var outStream = new NullStream()) {
						using (var csStream = new CryptoStream(outStream, hasher, CryptoStreamMode.Write))
							new BinaryWriter(csStream).Write(File.ReadAllBytes(fullPath));
					}
					return hasher.Hash;
				}
			}
			catch {
			}
			return null;
		}

		static bool Equals(byte[] a, byte[] b) {
			if (a == null && b == null)
				return true;
			if (a == null || b == null)
				return false;
			if (a.Length != b.Length)
				return false;
			for (int i = 0; i < a.Length; i++) {
				if (a[i] != b[i])
					return false;
			}
			return true;
		}

		public override string ToString() => PathName;
	}
}



================================================
File: de4dot.code/deobfuscators/ILProtector/StaticMethodsDecrypter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.IO;
using dnlib.IO;
using dnlib.DotNet;

namespace de4dot.code.deobfuscators.ILProtector {
	class StaticMethodsDecrypter : MethodsDecrypterBase {
		IDecrypter decrypter;

		interface IDecrypter {
			string Version { get; }
			byte[] GetMethodsData(EmbeddedResource resource);
		}

		class DecrypterBase : IDecrypter {
			protected static readonly byte[] ilpPublicKeyToken = new byte[8] { 0x20, 0x12, 0xD3, 0xC0, 0x55, 0x1F, 0xE0, 0x3D };

			protected string ilpVersion;
			protected int startOffset;
			protected byte[] decryptionKey;
			protected int decryptionKeyMod;

			public string Version => ilpVersion;

			protected void SetVersion(Version version) {
				if (version.Revision == 0)
					ilpVersion = $"{version.Major}.{version.Minor}.{version.Build}";
				else
					ilpVersion = version.ToString();
			}

			public virtual byte[] GetMethodsData(EmbeddedResource resource) {
				var reader = resource.CreateReader();
				reader.Position = (uint)startOffset;
				if ((reader.ReadInt32() & 1) != 0)
					return Decompress(ref reader);
				else
					return reader.ReadRemainingBytes();
			}

			byte[] Decompress(ref DataReader reader) => Decompress(ref reader, decryptionKey, decryptionKeyMod);

			static void Copy(byte[] src, int srcIndex, byte[] dst, int dstIndex, int size) {
				for (int i = 0; i < size; i++)
					dst[dstIndex++] = src[srcIndex++];
			}

			static byte[] Decompress(ref DataReader reader, byte[] key, int keyMod) =>
				Decompress(new byte[reader.Read7BitEncodedUInt32()], ref reader, key, keyMod);

			protected static byte[] Decompress(byte[] decrypted, ref DataReader reader, byte[] key, int keyMod) {
				int destIndex = 0;
				while (reader.Position < reader.Length) {
					if (destIndex >= decrypted.Length)
						break;
					byte flags = reader.ReadByte();
					for (int mask = 1; mask != 0x100; mask <<= 1) {
						if (reader.Position >= reader.Length)
							break;
						if (destIndex >= decrypted.Length)
							break;
						if ((flags & mask) != 0) {
							int displ = (int)reader.Read7BitEncodedUInt32();
							int size = (int)reader.Read7BitEncodedUInt32();
							Copy(decrypted, destIndex - displ, decrypted, destIndex, size);
							destIndex += size;
						}
						else {
							byte b = reader.ReadByte();
							if (key != null)
								b ^= key[destIndex % keyMod];
							decrypted[destIndex++] = b;
						}
					}
				}

				return decrypted;
			}
		}

		// 1.0.0 - 1.0.4
		class DecrypterV100 : DecrypterBase {
			// This is the first four bytes of ILProtector's public key token
			const uint RESOURCE_MAGIC = 0xC0D31220;

			DecrypterV100(Version ilpVersion) {
				SetVersion(ilpVersion);
				startOffset = 8;
				decryptionKey = ilpPublicKeyToken;
				decryptionKeyMod = 8;
			}

			public static DecrypterV100 Create(ref DataReader reader) {
				reader.Position = 0;
				if (reader.Length < 12)
					return null;
				if (reader.ReadUInt32() != RESOURCE_MAGIC)
					return null;

				return new DecrypterV100(new Version(reader.ReadByte(), reader.ReadByte(), reader.ReadByte(), reader.ReadByte()));
			}
		}

		// 1.0.5
		class DecrypterV105 : DecrypterBase {
			DecrypterV105(Version ilpVersion, byte[] key) {
				SetVersion(ilpVersion);
				startOffset = 0xA0;
				decryptionKey = key;
				decryptionKeyMod = key.Length - 1;
			}

			public static DecrypterV105 Create(ref DataReader reader) {
				reader.Position = 0;
				if (reader.Length < 0xA4)
					return null;
				var key = reader.ReadBytes(0x94);
				if (!Utils.Compare(reader.ReadBytes(8), ilpPublicKeyToken))
					return null;
				return new DecrypterV105(new Version(reader.ReadByte(), reader.ReadByte(), reader.ReadByte(), reader.ReadByte()), key);
			}
		}

		// 1.0.6.x
		class DecrypterV106 : DecrypterBase {
			byte[] decryptionKey6;
			byte[] decryptionKey7;

			DecrypterV106(byte[] key0, byte[] key6, byte[] key7, int startOffset) {
				ilpVersion = "1.0.6.x";
				this.startOffset = startOffset;
				decryptionKey = key0;
				decryptionKey6 = key6;
				decryptionKey7 = key7;
				decryptionKeyMod = key0.Length - 1;
			}

			public static DecrypterV106 Create(ref DataReader reader) {
				try {
					int keyXorOffs7 = (ReadByteAt(ref reader, 0) ^ ReadByteAt(ref reader, 2)) + 2;
					reader.Position = (uint)(keyXorOffs7 + (ReadByteAt(ref reader, 1) ^ ReadByteAt(ref reader, keyXorOffs7)));

					int sha1DataLen = reader.Read7BitEncodedInt32() + 0x80;
					int keyXorOffs6 = (int)reader.Position;
					int encryptedOffs = (int)reader.Position + sha1DataLen;
					var sha1Data = reader.ReadBytes(sha1DataLen);
					uint crc32 = CRC32.CheckSum(sha1Data);

					reader.Position = reader.Length - 0x18;
					uint origCrc32 = reader.ReadUInt32();
					if (crc32 != origCrc32)
						return null;

					var key0 = DeobUtils.Sha1Sum(sha1Data);				// 1.0.6.0
					var key6 = GetKey(ref reader, key0, keyXorOffs6);	// 1.0.6.6
					var key7 = GetKey(ref reader, key0, keyXorOffs7);	// 1.0.6.7
					return new DecrypterV106(key0, key6, key7, encryptedOffs);
				}
				catch (Exception ex) when (ex is IOException || ex is ArgumentException) {
					return null;
				}
			}

			static byte[] GetKey(ref DataReader reader, byte[] sha1Sum, int offs) {
				var key = (byte[])sha1Sum.Clone();
				reader.Position = (uint)offs;
				for (int i = 0; i < key.Length; i++)
					key[i] ^= reader.ReadByte();
				return key;
			}

			static byte ReadByteAt(ref DataReader reader, int offs) {
				reader.Position = (uint)offs;
				return reader.ReadByte();
			}

			public override byte[] GetMethodsData(EmbeddedResource resource) {
				var reader = resource.CreateReader();
				reader.Position = (uint)startOffset;
				var decrypted = new byte[reader.Read7BitEncodedUInt32()];
				uint origCrc32 = reader.ReadUInt32();
				uint pos = reader.Position;

				var keys = new byte[][] { decryptionKey, decryptionKey6, decryptionKey7 };
				foreach (var key in keys) {
					try {
						reader.Position = pos;
						Decompress(decrypted, ref reader, key, decryptionKeyMod);
						uint crc32 = CRC32.CheckSum(decrypted);
						if (crc32 == origCrc32)
							return decrypted;
					}
					catch (OutOfMemoryException) {
					}
					catch (Exception ex) when (ex is IOException || ex is ArgumentException) {
					}
				}

				throw new ApplicationException("Could not decrypt methods data");
			}
		}

		public string Version => decrypter?.Version;
		public bool Detected => methodsResource != null;
		public StaticMethodsDecrypter(ModuleDefMD module, MainType mainType) : base(module, mainType) { }

		public void Find() {
			foreach (var tmp in module.Resources) {
				var resource = tmp as EmbeddedResource;
				if (resource == null)
					continue;
				var reader = resource.CreateReader();
				reader.Position = 0;
				if (!CheckResourceV100(ref reader) &&
					!CheckResourceV105(ref reader) &&
					!CheckResourceV106(ref reader))
					continue;

				methodsResource = resource;
				break;
			}
		}

		bool CheckResourceV100(ref DataReader reader) {
			decrypter = DecrypterV100.Create(ref reader);
			return decrypter != null;
		}

		bool CheckResourceV105(ref DataReader reader) {
			decrypter = DecrypterV105.Create(ref reader);
			return decrypter != null;
		}

		bool CheckResourceV106(ref DataReader reader) {
			decrypter = DecrypterV106.Create(ref reader);
			return decrypter != null;
		}

		protected override void DecryptInternal() {
			if (methodsResource == null || decrypter == null)
				return;

			foreach (var info in ReadMethodInfos(decrypter.GetMethodsData(methodsResource)))
				methodInfos[info.id] = info;
		}

		static DecryptedMethodInfo[] ReadMethodInfos(byte[] data) {
			var toOffset = new Dictionary<DecryptedMethodInfo, int>();
			var reader = ByteArrayDataReaderFactory.CreateReader(data);
			int numMethods = (int)reader.Read7BitEncodedUInt32();
			/*int totalCodeSize = (int)*/reader.Read7BitEncodedUInt32();
			var methodInfos = new DecryptedMethodInfo[numMethods];
			int offset = 0;
			for (int i = 0; i < numMethods; i++) {
				int id = (int)reader.Read7BitEncodedUInt32();
				int size = (int)reader.Read7BitEncodedUInt32();
				var info = new DecryptedMethodInfo(id, size);
				methodInfos[i] = info;
				toOffset[info] = offset;
				offset += size;
			}
			uint dataOffset = reader.Position;
			foreach (var info in methodInfos) {
				reader.Position = dataOffset + (uint)toOffset[info];
				reader.ReadBytes(info.data, 0, info.data.Length);
			}
			return methodInfos;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/MPRESS/Deobfuscator.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Security.Cryptography;
using System.Text;
using dnlib.PE;
using dnlib.DotNet;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.MPRESS {
	public class DeobfuscatorInfo : DeobfuscatorInfoBase {
		public const string THE_NAME = "MPRESS";
		public const string THE_TYPE = "mp";
		const string DEFAULT_REGEX = DeobfuscatorBase.DEFAULT_ASIAN_VALID_NAME_REGEX;

		public DeobfuscatorInfo()
			: base(DEFAULT_REGEX) {
		}

		public override string Name => THE_NAME;
		public override string Type => THE_TYPE;

		public override IDeobfuscator CreateDeobfuscator() =>
			new Deobfuscator(new Deobfuscator.Options {
				ValidNameRegex = validNameRegex.Get(),
			});

		protected override IEnumerable<Option> GetOptionsInternal() => new List<Option>() { };
	}

	class Deobfuscator : DeobfuscatorBase {
		Options options;
		Version version;
		string obfuscatorName = DeobfuscatorInfo.THE_NAME;

		enum Version {
			Unknown,
			V0x,		// 0.71 - 0.99
			V1x_217,	// 1.x - 2.17
			V218,		// 2.18+
		}

		internal class Options : OptionsBase {
		}

		public override string Type => DeobfuscatorInfo.THE_TYPE;
		public override string TypeLong => DeobfuscatorInfo.THE_NAME;
		public override string Name => obfuscatorName;
		public Deobfuscator(Options options) : base(options) => this.options = options;

		protected override int DetectInternal() {
			int val = 0;

			if (version != Version.Unknown)
				val += 100;

			return val;
		}

		protected override void ScanForObfuscator() {
			version = DetectVersion();
			switch (version) {
			case Version.V0x: obfuscatorName += " v0.71 - v0.99"; break;
			case Version.V1x_217: obfuscatorName += " v1.x - v2.17"; break;
			case Version.V218: obfuscatorName += " v2.18+"; break;
			case Version.Unknown: break;
			default: throw new ApplicationException("Unknown version");
			}
		}

		class MethodInfo {
			public readonly string returnType;
			public readonly string parameters;
			public readonly string name;

			public MethodInfo(string returnType, string parameters)
				: this(returnType, parameters, null) {
			}

			public MethodInfo(string returnType, string parameters, string name) {
				this.returnType = returnType;
				this.parameters = parameters;
				this.name = name;
			}
		}

		static readonly string[] requiredFields = new string[] {
			"System.Reflection.Assembly",
		};
		static readonly MethodInfo[] methods_v0x = new MethodInfo[] {
			new MethodInfo("System.Void", "()", ".ctor"),
			new MethodInfo("System.Boolean", "(System.String,System.Byte[]&)"),
			new MethodInfo("System.Boolean", "(System.Byte[],System.Byte[]&)"),
			new MethodInfo("System.Int32", "(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)"),
			new MethodInfo("System.Int32", "(System.String[])"),
		};
		static readonly MethodInfo[] methods_v1x = new MethodInfo[] {
			new MethodInfo("System.Void", "()", ".ctor"),
			new MethodInfo("System.Boolean", "(System.String,System.Byte[]&)"),
			new MethodInfo("System.Boolean", "(System.Byte[],System.Byte[]&,System.Int32)"),
			new MethodInfo("System.Int32", "(System.Byte[],System.Byte[],System.Int32)"),
			new MethodInfo("System.Int32", "(System.String[])"),
		};
		Version DetectVersion() {
			var ep = module.EntryPoint;
			if (ep == null || ep.Body == null)
				return Version.Unknown;
			var type = ep.DeclaringType;
			if (type == null)
				return Version.Unknown;
			if (!new FieldTypes(type).Exactly(requiredFields))
				return Version.Unknown;
			if (module.Types.Count != 2)
				return Version.Unknown;
			if (module.Types[1] != type)
				return Version.Unknown;
			if (module.Types[0].Methods.Count != 0)
				return Version.Unknown;

			if (CheckMethods(type, methods_v0x))
				return Version.V0x;
			if (CheckMethods(type, methods_v1x)) {
				var lfMethod = DotNetUtils.GetMethod(type, "System.Boolean", "(System.String,System.Byte[]&)");
				if (lfMethod != null) {
					if (DeobUtils.HasInteger(lfMethod, (int)Machine.AMD64))
						return Version.V218;
					return Version.V1x_217;
				}
			}
			return Version.Unknown;
		}

		static bool CheckMethods(TypeDef type, MethodInfo[] requiredMethods) {
			var methods = new List<MethodDef>(type.Methods);
			foreach (var info in requiredMethods) {
				if (!CheckMethod(methods, info))
					return false;
			}
			return methods.Count == 0;
		}

		static bool CheckMethod(List<MethodDef> methods, MethodInfo info) {
			foreach (var method in methods) {
				if (info.name != null && info.name != method.Name)
					continue;
				if (!DotNetUtils.IsMethod(method, info.returnType, info.parameters))
					continue;

				methods.Remove(method);
				return true;
			}
			return false;
		}

		public override bool GetDecryptedModule(int count, ref byte[] newFileData, ref DumpedMethods dumpedMethods) {
			if (count != 0 || version == Version.Unknown)
				return false;

			byte[] fileData = ModuleBytes ?? DeobUtils.ReadModule(module);
			byte[] decompressed;
			using (var peImage = new MyPEImage(fileData)) {
				var section = peImage.Sections[peImage.Sections.Count - 1];
				var offset = section.PointerToRawData;
				offset += 16;

				byte[] compressed;
				int compressedLen;
				switch (version) {
				case Version.V0x:
					compressedLen = fileData.Length - (int)offset;
					compressed = peImage.OffsetReadBytes(offset, compressedLen);
					decompressed = Lzmat.DecompressOld(compressed);
					if (decompressed == null)
						throw new ApplicationException("LZMAT decompression failed");
					break;

				case Version.V1x_217:
				case Version.V218:
					if (peImage.PEImage.ImageNTHeaders.FileHeader.Machine == Machine.AMD64 && version == Version.V218)
						offset = section.PointerToRawData + section.VirtualSize;
					int decompressedLen = (int)peImage.OffsetReadUInt32(offset);
					compressedLen = fileData.Length - (int)offset - 4;
					compressed = peImage.OffsetReadBytes(offset + 4, compressedLen);
					decompressed = new byte[decompressedLen];
					uint decompressedLen2;
					if (Lzmat.Decompress(decompressed, out decompressedLen2, compressed) != LzmatStatus.OK)
						throw new ApplicationException("LZMAT decompression failed");
					break;

				default:
					throw new ApplicationException("Unknown MPRESS version");
				}
			}

			newFileData = decompressed;
			return true;
		}

		public override IDeobfuscator ModuleReloaded(ModuleDefMD module) {
			var newOne = new Deobfuscator(options);
			newOne.SetModule(module);
			return newOne;
		}

		public override void DeobfuscateBegin() {
			base.DeobfuscateBegin();

			FixInvalidMvid();
		}

		void FixInvalidMvid() {
			if (module.Mvid == Guid.Empty) {
				var hash = new SHA1Managed().ComputeHash(Encoding.UTF8.GetBytes(module.ToString()));
				var guid = new Guid(BitConverter.ToInt32(hash, 0),
									BitConverter.ToInt16(hash, 4),
									BitConverter.ToInt16(hash, 6),
									hash[8], hash[9], hash[10], hash[11],
									hash[12], hash[13], hash[14], hash[15]);
				Logger.v("Updating MVID: {0}", guid.ToString("B"));
				module.Mvid = guid;
			}
		}

		public override IEnumerable<int> GetStringDecrypterMethods() => new List<int>();
	}
}



================================================
File: de4dot.code/deobfuscators/MPRESS/Lzmat.cs
================================================
/*
***************************************************************************
** LZMAT ANSI-C decoder 1.01
** Copyright (C) 2007,2008 Vitaly Evseenko. All Rights Reserved.
** lzmat_dec.c
**
** This file is part of the LZMAT real-time data compression library.
**
** The LZMAT library is free software; you can redistribute it and/or
** modify it under the terms of the GNU General Public License as
** published by the Free Software Foundation; either version 2 of
** the License, or (at your option) any later version.
**
** The LZMAT library is distributed WITHOUT ANY WARRANTY;
** without even the implied warranty of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
** License for more details.
**
** You should have received a copy of the GNU General Public License
** along with the LZMAT library; see the file GPL.TXT.
** If not, write to the Free Software Foundation, Inc.,
** 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
**
** Vitaly Evseenko
** <ve@matcode.com>
** http://www.matcode.com/lzmat.htm
***************************************************************************
*/

using System;

namespace de4dot.code.deobfuscators.MPRESS {
	enum LzmatStatus {
		OK = 0,
		ERROR = -1,
		INTEGRITY_FAILURE = 0x100,
		BUFFER_TOO_SMALL = 0x110,
	}

	static class Lzmat {
		const int LZMAT_DEFAULT_CNT = 0x12;
		const int LZMAT_1BYTE_CNT = (0xFF + LZMAT_DEFAULT_CNT);
		const int LZMAT_2BYTE_CNT = (0xFFFF + LZMAT_1BYTE_CNT);
		const int LZMAT_MAX_2BYTE_CNT = (LZMAT_2BYTE_CNT - 1);

		const int MAX_LZMAT_SHORT_DIST0 = 0x80;
		const int MAX_LZMAT_SHORT_DIST1 = (0x800 | MAX_LZMAT_SHORT_DIST0);
		const int MAX_LZMAT_LONG_DIST0 = 0x40;
		const int MAX_LZMAT_LONG_DIST1 = (0x400 | MAX_LZMAT_LONG_DIST0);
		const int MAX_LZMAT_LONG_DIST2 = (0x4000 | MAX_LZMAT_LONG_DIST1);
		const int MAX_LZMAT_LONG_DIST3 = (0x40000 | MAX_LZMAT_LONG_DIST2);
		const int MAX_LZMAT_GAMMA_DIST = (MAX_LZMAT_LONG_DIST3 - 1);

		const int LZMAT_DIST_MSK0 = 0x3F;
		const int LZMAT_DIST_MSK1 = 0x3FF;

		static uint LZMAT_GET_U4(byte[] _p_, ref uint _i_, ref byte _n_) => (_n_ ^= 1) != 0 ? (uint)(_p_[_i_] & 0xF) : (uint)(_p_[_i_++] >> 4);
		static byte LZMAT_GET_U8(byte[] _p_, uint _i_, byte _n_) => (byte)(((_n_) != 0 ? ((_p_[_i_] >> 4) | (_p_[_i_ + 1] << 4)) : _p_[_i_]));
		static ushort LZMAT_GET_LE16(byte[] _p_, uint _i_, byte _n_) => (ushort)((_n_) != 0 ? ((_p_[_i_] >> 4) | ((ushort)(GET_LE16(_p_, _i_ + 1)) << 4)) : GET_LE16(_p_, _i_));
		static ushort GET_LE16(byte[] _p_, uint _i_) => BitConverter.ToUInt16(_p_, (int)_i_);

		public static LzmatStatus Decompress(byte[] pbOut, out uint pcbOut, byte[] pbIn) {
			pcbOut = 0;
			uint cbIn = (uint)pbIn.Length;

	uint  inPos, outPos;
	uint  cbOutBuf = (uint)pbOut.Length;
	byte  cur_nib;
	pbOut[0] = pbIn[0];
	for(inPos=1, outPos=1, cur_nib=0; inPos<(cbIn-cur_nib);)
	{
		int bc;
		byte tag;
		tag = LZMAT_GET_U8(pbIn,inPos,cur_nib);
		inPos++;
		for(bc=0; bc<8 && inPos<(cbIn-cur_nib) && outPos<cbOutBuf; bc++, tag<<=1)
		{
			if((tag&0x80)!=0) // gamma
			{
				uint r_pos, r_cnt, dist;
//#define cflag	r_cnt
				r_cnt = LZMAT_GET_LE16(pbIn,inPos,cur_nib);
				inPos++;
				if(outPos>MAX_LZMAT_SHORT_DIST1)
				{
					dist = r_cnt>>2;
					switch(r_cnt&3)
					{
					case 0:
						dist=(dist&LZMAT_DIST_MSK0)+1;
						break;
					case 1:
						inPos+=cur_nib;
						dist = (dist&LZMAT_DIST_MSK1)+0x41;
						cur_nib^=1;
						break;
					case 2:
						inPos++;
						dist += 0x441;
						break;
					case 3:
						if((inPos+2+cur_nib)>cbIn)
							return LzmatStatus.INTEGRITY_FAILURE+1;
						inPos++;
						dist = (dist + 
							((uint)LZMAT_GET_U4(pbIn,ref inPos,ref cur_nib)<<14))
							+0x4441;
						break;
					}
				}
				else
				{
					dist = r_cnt>>1;
					if((r_cnt&1)!=0)
					{
						inPos+=cur_nib;
						dist = (dist&0x7FF)+0x81;
						cur_nib^=1;
					}
					else
						dist = (dist&0x7F)+1;
				}
//#undef cflag
				r_cnt = LZMAT_GET_U4(pbIn,ref inPos,ref cur_nib);
				if(r_cnt!=0xF)
				{
					r_cnt += 3;
				}
				else
				{
					if((inPos+1+cur_nib)>cbIn)
						return LzmatStatus.INTEGRITY_FAILURE+2;
					r_cnt = LZMAT_GET_U8(pbIn,inPos,cur_nib);
					inPos++;
					if(r_cnt!=0xFF)
					{
						r_cnt += LZMAT_DEFAULT_CNT;
					}
					else
					{
						if((inPos+2+cur_nib)>cbIn)
							return LzmatStatus.INTEGRITY_FAILURE+3;
						r_cnt = (uint)(LZMAT_GET_LE16(pbIn,inPos,cur_nib)+LZMAT_1BYTE_CNT);
						inPos+=2;
						if(r_cnt==LZMAT_2BYTE_CNT)
						{
							// copy chunk
							if(cur_nib!=0)
							{
								r_cnt = ((uint)pbIn[inPos-4]&0xFC)<<5;
								inPos++;
								cur_nib = 0;
							}
							else
							{
								r_cnt = (uint)((GET_LE16(pbIn,inPos-5)&0xFC0)<<1);
							}
							r_cnt+=(uint)((tag&0x7F)+4);
							r_cnt<<=1;
							if((outPos+(r_cnt<<2))>cbOutBuf)
								return LzmatStatus.BUFFER_TOO_SMALL;
							while(r_cnt--!=0 && outPos<cbOutBuf)
							{
								pbOut[outPos] = pbIn[inPos];
								pbOut[outPos + 1] = pbIn[inPos + 1];
								pbOut[outPos + 2] = pbIn[inPos + 2];
								pbOut[outPos + 3] = pbIn[inPos + 3];
								inPos+=4;
								outPos+=4;
							}
							break;
						}
					}
				}
				if(outPos<dist)
					return LzmatStatus.INTEGRITY_FAILURE+4;
				if((outPos+r_cnt)>cbOutBuf)
					return LzmatStatus.BUFFER_TOO_SMALL+1;
				r_pos = outPos-dist;
				while(r_cnt--!=0 && outPos<cbOutBuf)
					pbOut[outPos++]=pbOut[r_pos++];
			}
			else
			{
				pbOut[outPos++]=LZMAT_GET_U8(pbIn,inPos,cur_nib);
				inPos++;
			}
		}
	}
	pcbOut = outPos;
	return LzmatStatus.OK;
		}

		public static byte[] DecompressOld(byte[] compressed) {
			int srcIndex = 3;
			int dstIndex = 0;
			int decompressedLen = compressed[0] + (compressed[1] << 8) + (compressed[2] << 16);
			byte[] decompressed = new byte[decompressedLen];
			while (dstIndex < decompressedLen) {
				int partLen = compressed[srcIndex++] + (compressed[srcIndex++] << 8) + (compressed[srcIndex++] << 16);
				if (partLen < 0x800000) {
					Array.Copy(compressed, srcIndex, decompressed, dstIndex, partLen);
					srcIndex += partLen;
					dstIndex += partLen;
				}
				else {
					partLen &= 0x7FFFFF;
					int decompressedLen2 = Lzmat_old(decompressed, dstIndex, decompressedLen - dstIndex, compressed, srcIndex, partLen);
					if (decompressedLen2 == 0)
						return null;
					dstIndex += decompressedLen2;
					srcIndex += partLen;
				}
			}
			return decompressed;
		}

		static int Lzmat_old(byte[] outBuf, int outIndex, int outLen, byte[] inBuf, int inIndex, int inLen) {
			int inPos = 0;
			int outPos = 0;
			while (inPos < inLen) {
				byte tag = inBuf[inIndex + inPos++];
				for (int bc = 0; bc < 8 && inPos < inLen && outPos < outLen; bc++, tag <<= 1) {
					if ((tag & 0x80) != 0) {
						ushort outPosDispl = (ushort)((((inBuf[inIndex + inPos + 1]) & 0xF) << 8) + inBuf[inIndex + inPos]);
						inPos++;
						int r_cnt = (inBuf[inIndex + inPos++] >> 4) + 3;
						if (outPosDispl == 0)
							outPosDispl = 0x1000;
						if (outPosDispl > outPos)
							return 0;
						if (r_cnt == 18) {
							if (inPos >= inLen)
								return 0;
							r_cnt = inBuf[inIndex + inPos++] + 18;
						}
						if (r_cnt == 0x111) {
							if (inPos + 2 > inLen)
								return 0;
							r_cnt = (inBuf[inIndex + inPos + 1] << 8) + inBuf[inIndex + inPos] + 0x111;
							inPos += 2;
						}
						int outPos2 = outPos - outPosDispl;
						while (r_cnt-- > 0 && outPos < outLen)
							outBuf[outIndex + outPos++] = outBuf[outIndex + outPos2++];
					}
					else
						outBuf[outIndex + outPos++] = inBuf[inIndex + inPos++];
				}
			}
			if (inPos < inLen)
				return 0;
			return outPos;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/MaxtoCode/CryptDecrypter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;

namespace de4dot.code.deobfuscators.MaxtoCode {
	class CryptDecrypter {
		byte[] key;

		static readonly byte[] sbox = new byte[8 * 8 * 8] {
			14,  4, 13,  1,  2, 15, 11,  8,
			 3, 10,  6, 12,  5,  9,  0,  7,
			 0, 15,  7,  4, 14,  2, 13,  1,
			10,  6, 12, 11,  9,  5,  3,  8,
			 4,  1, 14,  8, 13,  6,  2, 11,
			15, 12,  9,  7,  3, 10,  5,  0,
			15, 12,  8,  2,  4,  9,  1,  7,
			 5, 11,  3, 14, 10,  0,  6, 13,
			15,  1,  8, 14,  6, 11,  3,  4,
			 9,  7,  2, 13, 12,  0,  5, 10,
			 3, 13,  4,  7, 15,  2,  8, 14,
			12,  0,  1, 10,  6,  9, 11,  5,
			 0, 14,  7, 11, 10,  4, 13,  1,
			 5,  8, 12,  6,  9,  3,  2, 15,
			13,  8, 10,  1,  3, 15,  4,  2,
			11,  6,  7, 12,  0,  5, 14,  9,
			10,  0,  9, 14,  6,  3, 15,  5,
			 1, 13, 12,  7, 11,  4,  2,  8,
			13,  7,  0,  9,  3,  4,  6, 10,
			 2,  8,  5, 14, 12, 11, 15,  1,
			13,  6,  4,  9,  8, 15,  3,  0,
			11,  1,  2, 12,  5, 10, 14,  7,
			 1, 10, 13,  0,  6,  9,  8,  7,
			 4, 15, 14,  3, 11,  5,  2, 12,
			 7, 13, 14,  3,  0,  6,  9, 10,
			 1,  2,  8,  5, 11, 12,  4, 15,
			13,  8, 11,  5,  6, 15,  0,  3,
			 4,  7,  2, 12,  1, 10, 14,  9,
			10,  6,  9,  0, 12, 11,  7, 13,
			15,  1,  3, 14,  5,  2,  8,  4,
			 3, 15,  0,  6, 10,  1, 13,  8,
			 9,  4,  5, 11, 12,  7,  2, 14,
			 2, 12,  4,  1,  7, 10, 11,  6,
			 8,  5,  3, 15, 13,  0, 14,  9,
			14, 11,  2, 12,  4,  7, 13,  1,
			 5,  0, 15, 10,  3,  9,  8,  6,
			 4,  2,  1, 11, 10, 13,  7,  8,
			15,  9, 12,  5,  6,  3,  0, 14,
			11,  8, 12,  7,  1, 14,  2, 13,
			 6, 15,  0,  9, 10,  4,  5,  3,
			12,  1, 10, 15,  9,  2,  6,  8,
			 0, 13,  3,  4, 14,  7,  5, 11,
			10, 15,  4,  2,  7, 12,  9,  5,
			 6,  1, 13, 14,  0, 11,  3,  8,
			 9, 14, 15,  5,  2,  8, 12,  3,
			 7,  0,  4, 10,  1, 13, 11,  6,
			 4,  3,  2, 12,  9,  5, 15, 10,
			11, 14,  1,  7,  6,  0,  8, 13,
			 4, 11,  2, 14, 15,  0,  8, 13,
			 3, 12,  9,  7,  5, 10,  6,  1,
			13,  0, 11,  7,  4,  9,  1, 10,
			14,  3,  5, 12,  2, 15,  8,  6,
			 1,  4, 11, 13, 12,  3,  7, 14,
			10, 15,  6,  8,  0,  5,  9,  2,
			 6, 11, 13,  8,  1,  4, 10,  7,
			 9,  5,  0, 15, 14,  2,  3, 12,
			13,  2,  8,  4,  6, 15, 11,  1,
			10,  9,  3, 14,  5,  0, 12,  7,
			 1, 15, 13,  8, 10,  3,  7,  4,
			12,  5,  6, 11,  0, 14,  9,  2,
			 7, 11,  4,  1,  9, 12, 14,  2,
			 0,  6, 10, 13, 15,  3,  5,  8,
			 2,  1, 14,  7,  4, 10,  8, 13,
			15, 12,  9,  0,  3,  5,  6, 11,
		};
		static readonly byte[] perm = new byte[32] {
			16,  7, 20, 21, 29, 12, 28, 17,
			 1, 15, 23, 26,  5, 18, 31, 10,
			 2,  8, 24, 14, 32, 27,  3,  9,
			19, 13, 30,  6, 22, 11,  4, 25,
		};
		static readonly byte[] esel = new byte[48] {
			32,  1,  2,  3,  4,  5,  4,  5,
			 6,  7,  8,  9,  8,  9, 10, 11,
			12, 13, 12, 13, 14, 15, 16, 17,
			16, 17, 18, 19, 20, 21, 20, 21,
			22, 23, 24, 25, 24, 25, 26, 27,
			28, 29, 28, 29, 30, 31, 32,  1,
		};
		static readonly byte[] ip = new byte[64] {
			58, 50, 42, 34, 26, 18, 10,  2,
			60, 52, 44, 36, 28, 20, 12,  4,
			62, 54, 46, 38, 30, 22, 14,  6,
			64, 56, 48, 40, 32, 24, 16,  8,
			57, 49, 41, 33, 25, 17,  9,  1,
			59, 51, 43, 35, 27, 19, 11,  3,
			61, 53, 45, 37, 29, 21, 13,  5,
			63, 55, 47, 39, 31, 23, 15,  7,
		};
		static readonly byte[] final = new byte[64] {
			40,  8, 48, 16, 56, 24, 64, 32,
			39,  7, 47, 15, 55, 23, 63, 31,
			38,  6, 46, 14, 54, 22, 62, 30,
			37,  5, 45, 13, 53, 21, 61, 29,
			36,  4, 44, 12, 52, 20, 60, 28,
			35,  3, 43, 11, 51, 19, 59, 27,
			34,  2, 42, 10, 50, 18, 58, 26,
			33,  1, 41,  9, 49, 17, 57, 25,
		};
		static readonly byte[] pc1 = new byte[56] {
			57, 49, 41, 33, 25, 17,  9,  1,
			58, 50, 42, 34, 26, 18, 10,  2,
			59, 51, 43, 35, 27, 19, 11,  3,
			60, 52, 44, 36, 63, 55, 47, 39,
			31, 23, 15,  7, 62, 54, 46, 38,
			30, 22, 14,  6, 61, 53, 45, 37,
			29, 21, 13,  5, 28, 20, 12,  4,
		};
		static readonly byte[] pc2 = new byte[48] {
			14, 17, 11, 24,  1,  5,  3, 28,
			15,  6, 21, 10, 23, 19, 12,  4,
			26,  8, 16,  7, 27, 20, 13,  2,
			41, 52, 31, 37, 47, 55, 30, 40,
			51, 45, 33, 48, 44, 49, 39, 56,
			34, 53, 46, 42, 50, 36, 29, 32,
		};
		static readonly byte[] rots = new byte[16] {
			1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1,
		};

		struct Bits {
			readonly byte[] byteBits;

			public static Bits FromBytes(byte[] bytes) => FromBytes(bytes, 0, bytes.Length * 8);
			public static Bits FromBytes(byte[] bytes, int index, int numBits) => new Bits(bytes, index, numBits);
			public static Bits FromByteBits(byte[] byteBits1, byte[] byteBits2) => new Bits(byteBits1, byteBits2);
			public static Bits FromByteBits(byte[] byteBits) => FromByteBits(byteBits, 0, byteBits.Length);

			public static Bits FromByteBits(byte[] byteBits, int index, int numBits) {
				var bits = new Bits(numBits);
				for (int i = 0; i < numBits; i++)
					bits.byteBits[i] = byteBits[index + i];
				return bits;
			}

			public byte this[int index] => byteBits[index];
			public byte[] ByteBits => byteBits;

			Bits(int numBits) => byteBits = new byte[numBits];
			Bits(byte[] bytes1, byte[] bytes2) => byteBits = Concat(bytes1, bytes2);
			Bits(byte[] bytes, int index, int numBits) => byteBits = ToByteBits(bytes, index, numBits);

			static byte[] ToByteBits(byte[] bytes, int index, int numBits) {
				var byteBits = new byte[numBits];
				for (int i = 0; i < numBits; i++) {
					int j = i / 8;
					int k = i & 7;
					byteBits[i] = (byte)(((bytes[index + j] >> k) & 1) != 0 ? 1 : 0);
				}
				return byteBits;
			}

			static byte[] Concat(byte[] bytes1, byte[] bytes2) {
				var bytes = new byte[bytes1.Length + bytes2.Length];
				Array.Copy(bytes1, 0, bytes, 0, bytes1.Length);
				Array.Copy(bytes2, 0, bytes, bytes1.Length, bytes2.Length);
				return bytes;
			}

			public Bits Transpose(byte[] bits) {
				var result = new Bits(bits.Length);
				for (int i = 0; i < bits.Length; i++)
					result.byteBits[i] = byteBits[bits[i] - 1];
				return result;
			}

			public void Rol() {
				if (byteBits.Length == 0)
					return;
				var first = byteBits[0];
				for (int i = 1; i < byteBits.Length; i++)
					byteBits[i - 1] = byteBits[i];
				byteBits[byteBits.Length - 1] = first;
			}

			public void Rol(int num) {
				for (int i = 0; i < num; i++)
					Rol();
			}

			public Bits Extract(int index, int numBits) => FromByteBits(byteBits, index, numBits);

			public void ToBits(byte[] dest, int index) {
				var bits = ToBits();
				Array.Copy(bits, 0, dest, index, bits.Length);
			}

			public byte[] ToBits() {
				var bits = new byte[(byteBits.Length + 7) / 8];
				for (int i = 0; i < bits.Length; i++) {
					byte val = 0;
					for (int j = i * 8, k = 1; j < byteBits.Length; j++, k <<= 1) {
						if (byteBits[j] != 0)
							val |= (byte)k;
					}
					bits[i] = val;
				}
				return bits;
			}

			public Bits Clone() => FromByteBits(byteBits, 0, byteBits.Length);

			public void Set(int destIndex, Bits other) {
				for (int i = 0; i < other.byteBits.Length; i++)
					byteBits[destIndex + i] = other.byteBits[i];
			}

			public void Xor(Bits other) {
				if (byteBits.Length != other.byteBits.Length)
					throw new ArgumentException("other");
				for (int i = 0; i < byteBits.Length; i++)
					byteBits[i] ^= other.byteBits[i];
			}

			public void CopyTo(byte[] dest, int index) {
				for (int i = 0; i < byteBits.Length; i++)
					dest[index + i] = byteBits[i];
			}
		}

		public CryptDecrypter(byte[] key) {
			if (key.Length <= 8)
				throw new ArgumentException("Invalid size", "key");
			this.key = key;
		}

		public static byte[] Decrypt(byte[] key, byte[] encrypted) => new CryptDecrypter(key).Decrypt(encrypted);

		byte[] Decrypt(byte[] encrypted) {
			if (encrypted.Length % 8 != 0)
				throw new ArgumentException("encrypted");
			var key1 = CreateKey(key, 0);
			var key2 = CreateKey(key, 8);

			var decrypted = new byte[encrypted.Length];
			int count = encrypted.Length / 8;
			for (int i = 0; i < count; i++) {
				var buf = new byte[8];
				Array.Copy(encrypted, i * 8, buf, 0, buf.Length);
				buf = Decrypt(buf, key1, true);
				buf = Decrypt(buf, key2, false);
				buf = Decrypt(buf, key1, true);
				Array.Copy(buf, 0, decrypted, i * 8, buf.Length);
			}

			return decrypted;
		}

		byte[] Decrypt(byte[] data, Bits key, bool flag) {
			var bits = Bits.FromBytes(data).Transpose(ip);

			if (flag) {
				for (int i = 0, ki = key.ByteBits.Length - 48; i < 16; i++, ki -= 48) {
					var oldBits = bits.Extract(0, 32);
					var tmp = Decrypt(oldBits.Clone(), key.Extract(ki, 48));
					tmp.Xor(bits.Extract(32, 32));
					bits.Set(32, oldBits);
					bits.Set(0, tmp);
				}
			}
			else {
				for (int i = 0, ki = 0; i < 16; i++, ki += 48) {
					var oldBits = bits.Extract(32, 32);
					var tmp = Decrypt(oldBits.Clone(), key.Extract(ki, 48));
					tmp.Xor(bits.Extract(0, 32));
					bits.Set(0, oldBits);
					bits.Set(32, tmp);
				}
			}

			bits = bits.Transpose(final);
			return bits.ToBits();
		}

		Bits Decrypt(Bits data, Bits key) {
			var newData = data.Clone().Transpose(esel);
			newData.Xor(key);
			return Bits.FromByteBits(GetSbox(newData)).Transpose(perm);
		}

		byte[] GetSbox(Bits data) {
			var sboxByteBits = new byte[32];

			for (int i = 0; i < 8; i++) {
				int di = i * 6;
				int index = (data[di + 0] << 5) + (data[di + 5] << 4) + (data[di + 1] << 3) +
							(data[di + 2] << 2) + (data[di + 3] << 1) + data[di + 4] + i * 64;
				Bits.FromBytes(sbox, index, 4).CopyTo(sboxByteBits, i * 4);
			}

			return sboxByteBits;
		}

		static Bits CreateKey(byte[] data, int index) {
			CreateKeys(data, index, out var key1, out var key2);
			byte[] newKey = new byte[16 * 6];
			//byte[] tmpData = new byte[28 * 2];
			for (int i = 0; i < 16; i++) {
				int rolCount = rots[i];
				key1.Rol(rolCount);
				key2.Rol(rolCount);
				Bits.FromByteBits(key1.ByteBits, key2.ByteBits).Transpose(pc2).ToBits(newKey, i * 6);
			}
			return Bits.FromBytes(newKey);
		}

		static void CreateKeys(byte[] data, int index, out Bits key1, out Bits key2) {
			var tmpKey = new byte[8];
			int len = Math.Min(tmpKey.Length, data.Length - index);
			if (len == 0)
				throw new ArgumentException("data");
			Array.Copy(data, index, tmpKey, 0, len);
			var bits = Bits.FromBytes(tmpKey).Transpose(pc1);
			key1 = Bits.FromByteBits(bits.ByteBits, 0, 28);
			key2 = Bits.FromByteBits(bits.ByteBits, 28, 28);
		}
	}
}



================================================
File: de4dot.code/deobfuscators/MaxtoCode/Decrypter6.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;

namespace de4dot.code.deobfuscators.MaxtoCode {
	class Decrypter6 {
		readonly uint[] key;
		readonly byte[] gen1 = new byte[0x100];
		readonly byte[] gen2 = new byte[0x100];
		readonly byte[] gen3 = new byte[0x100];
		readonly byte[] gen4 = new byte[0x100];
		static readonly byte[] d1h = new byte[16] { 14, 4, 13, 21, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7 };
		static readonly byte[] d1l = new byte[16] { 15, 1, 8, 14, 6, 11, 3, 4, 30, 7, 2, 13, 12, 0, 5, 10 };
		static readonly byte[] d2h = new byte[16] { 10, 0, 9, 14, 6, 3, 15, 5, 23, 13, 12, 7, 11, 4, 2, 8 };
		static readonly byte[] d2l = new byte[16] { 7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15 };
		static readonly byte[] d3h = new byte[16] { 2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9 };
		static readonly byte[] d3l = new byte[16] { 12, 1, 10, 15, 9, 2, 6, 8, 2, 13, 3, 4, 14, 7, 5, 11 };
		static readonly byte[] d4h = new byte[16] { 4, 11, 12, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1 };
		static readonly byte[] d4l = new byte[16] { 13, 2, 8, 14, 6, 7, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7 };

		public static byte[] Decrypt(byte[] key, byte[] encrypted) => new Decrypter6(key).Decrypt(encrypted);

		Decrypter6(byte[] key) {
			if (key.Length != 32)
				throw new ArgumentException("Invalid key size", "key");
			this.key = new uint[8];
			Buffer.BlockCopy(key, 0, this.key, 0, key.Length);
			Initialize();
		}

		byte[] Decrypt(byte[] encrypted) {
			if ((encrypted.Length & 7) != 0)
				throw new ArgumentException("Invalid data length", "encrypted");
			var decrypted = new byte[encrypted.Length];

			int count = decrypted.Length / 8;
			for (int i = 0; i < count; i++) {
				Decrypt(BitConverter.ToUInt32(encrypted, i * 8), BitConverter.ToUInt32(encrypted, i * 8 + 4), out uint x, out uint y);
				for (int j = 1; j < 100; j++)
					Decrypt(x, y, out x, out y);
				WriteUInt32(decrypted, i * 8, x);
				WriteUInt32(decrypted, i * 8 + 4, y);
			}

			return decrypted;
		}

		static void WriteUInt32(byte[] data, int index, uint value) {
			data[index] = (byte)value;
			data[index + 1] = (byte)(value >> 8);
			data[index + 2] = (byte)(value >> 16);
			data[index + 3] = (byte)(value >> 24);
		}

		void Initialize() {
			for (int i = 0; i < 0x100; i++) {
				gen1[i] = (byte)((d1h[i / 16] << 4) | d1l[i & 0x0F]);
				gen2[i] = (byte)((d2h[i / 16] << 4) | d2l[i & 0x0F]);
				gen3[i] = (byte)((d3h[i / 16] << 4) | d3l[i & 0x0F]);
				gen4[i] = (byte)((d4h[i / 16] << 4) | d4l[i & 0x0F]);
			}
		}

		void Decrypt(uint i0, uint i1, out uint o0, out uint o1) {
			uint x = i0;
			uint y = Decrypt(x + key[0]);
			y ^= i1;
			x ^= Decrypt(y + key[1]);
			y ^= Decrypt(x + key[2]);
			x ^= Decrypt(y + key[3]);
			y ^= Decrypt(x + key[4]);
			x ^= Decrypt(y + key[5]);
			y ^= Decrypt(x + key[6]);
			x ^= Decrypt(y + key[7]);

			for (int i = 0; i < 3; i++) {
				y ^= Decrypt(x + key[7]);
				x ^= Decrypt(y + key[6]);
				y ^= Decrypt(x + key[5]);
				x ^= Decrypt(y + key[4]);
				y ^= Decrypt(x + key[3]);
				x ^= Decrypt(y + key[2]);
				y ^= Decrypt(x + key[1]);
				x ^= Decrypt(y + key[0]);
			}

			o0 = y;
			o1 = x;
		}

		uint Decrypt(uint val) {
			uint x = (uint)((gen1[(byte)(val >> 24)] << 24) |
				(gen2[(byte)(val >> 16)] << 16) |
				(gen3[(byte)(val >> 8)] << 8) |
				gen4[(byte)val]);
			return Ror(x, 21);
		}

		static uint Ror(uint val, int n) => (val << (32 - n)) + (val >> n);
	}
}



================================================
File: de4dot.code/deobfuscators/MaxtoCode/DecrypterInfo.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;

namespace de4dot.code.deobfuscators.MaxtoCode {
	class DecrypterInfo : IDisposable {
		public MainType mainType;
		public readonly MyPEImage peImage;
		public readonly PeHeader peHeader;
		public readonly McKey mcKey;
		public readonly byte[] fileData;

		public DecrypterInfo(MainType mainType, byte[] fileData) {
			this.mainType = mainType;
			peImage = new MyPEImage(fileData);
			peHeader = new PeHeader(mainType, peImage);
			mcKey = new McKey(peImage, peHeader);
			this.fileData = fileData;
		}

		public void Dispose() {
			if (peImage != null)
				peImage.Dispose();
		}
	}
}



================================================
File: de4dot.code/deobfuscators/MaxtoCode/Deobfuscator.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using System.Text;
using dnlib.DotNet;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.MaxtoCode {
	public class DeobfuscatorInfo : DeobfuscatorInfoBase {
		public const string THE_NAME = "MaxtoCode";
		public const string THE_TYPE = "mc";
		const string DEFAULT_REGEX = @"!^[oO01l]+$&!^[A-F0-9]{20,}$&" + DeobfuscatorBase.DEFAULT_ASIAN_VALID_NAME_REGEX;
		IntOption stringCodePage;

		public DeobfuscatorInfo() : base(DEFAULT_REGEX) => stringCodePage = new IntOption(null, MakeArgName("cp"), "String code page", 936);

		public override string Name => THE_NAME;
		public override string Type => THE_TYPE;

		public override IDeobfuscator CreateDeobfuscator() =>
			new Deobfuscator(new Deobfuscator.Options {
				RenameResourcesInCode = false,
				ValidNameRegex = validNameRegex.Get(),
				StringCodePage = stringCodePage.Get(),
			});

		protected override IEnumerable<Option> GetOptionsInternal() => new List<Option>() { stringCodePage };
	}

	class Deobfuscator : DeobfuscatorBase {
		Options options;
		MainType mainType;
		DecrypterInfo decrypterInfo;
		StringDecrypter stringDecrypter;

		internal class Options : OptionsBase {
			public int StringCodePage { get; set; }
		}

		public override string Type => DeobfuscatorInfo.THE_TYPE;
		public override string TypeLong => DeobfuscatorInfo.THE_NAME;
		public override string Name => DeobfuscatorInfo.THE_NAME;

		internal Deobfuscator(Options options)
			: base(options) {
			this.options = options;
			StringFeatures = StringFeatures.AllowStaticDecryption | StringFeatures.AllowDynamicDecryption;
		}

		protected override int DetectInternal() {
			int val = 0;

			if (mainType.Detected)
				val = 150;

			return val;
		}

		protected override void ScanForObfuscator() {
			mainType = new MainType(module);
			mainType.Find();
		}

		public override bool GetDecryptedModule(int count, ref byte[] newFileData, ref DumpedMethods dumpedMethods) {
			if (count != 0 || !mainType.Detected)
				return false;

			var fileData = DeobUtils.ReadModule(module);
			decrypterInfo = new DecrypterInfo(mainType, fileData);
			var methodsDecrypter = new MethodsDecrypter(module, decrypterInfo);

			if (!methodsDecrypter.Decrypt(ref dumpedMethods))
				return false;

			newFileData = fileData;
			return true;
		}

		public override IDeobfuscator ModuleReloaded(ModuleDefMD module) {
			var newOne = new Deobfuscator(options);
			newOne.SetModule(module);
			newOne.mainType = new MainType(module, mainType);
			newOne.decrypterInfo = decrypterInfo;
			decrypterInfo = null;
			if (newOne.decrypterInfo != null)
				newOne.decrypterInfo.mainType = newOne.mainType;
			return newOne;
		}

		void FreePEImage() {
			if (decrypterInfo != null)
				decrypterInfo.Dispose();
			decrypterInfo = null;
		}

		public override void DeobfuscateBegin() {
			base.DeobfuscateBegin();

			stringDecrypter = new StringDecrypter(decrypterInfo);
			stringDecrypter.Find();
			if (stringDecrypter.Detected) {
				stringDecrypter.Initialize(GetEncoding(options.StringCodePage));
				staticStringInliner.Add(stringDecrypter.Method, (method, gim, args) => stringDecrypter.Decrypt((uint)args[0]));
				DeobfuscatedFile.StringDecryptersAdded();
			}
			else
				FreePEImage();

			foreach (var method in mainType.InitMethods)
				AddCctorInitCallToBeRemoved(method);
			AddTypeToBeRemoved(mainType.Type, "Obfuscator type");
			RemoveDuplicateEmbeddedResources();
			RemoveInvalidResources();
		}

		public override void DeobfuscateEnd() {
			FreePEImage();
			base.DeobfuscateEnd();
		}

		static Encoding GetEncoding(int cp) {
			try {
				return Encoding.GetEncoding(cp);
			}
			catch {
				Logger.w("Invalid code page {0}!", cp);
				return Encoding.Default;
			}
		}

		class ResourceKey {
			readonly EmbeddedResource resource;

			public ResourceKey(EmbeddedResource resource) => this.resource = resource;

			public override int GetHashCode() {
				int hash = 0;
				if (resource.Offset != null)
					hash ^= resource.Offset.GetHashCode();
				hash ^= (int)resource.CreateReader().Position;
				hash ^= (int)resource.CreateReader().Length;
				return hash;
			}

			public override bool Equals(object obj) {
				var other = obj as ResourceKey;
				if (other == null)
					return false;
				return resource.CreateReader().StartOffset == other.resource.CreateReader().StartOffset &&
					resource.CreateReader().Length == other.resource.CreateReader().Length;
			}

			public override string ToString() => resource.Name.String;
		}

		void RemoveDuplicateEmbeddedResources() {
			var resources = new Dictionary<ResourceKey, List<EmbeddedResource>>();
			foreach (var tmp in module.Resources) {
				var rsrc = tmp as EmbeddedResource;
				if (rsrc == null)
					continue;
				if (rsrc.Offset == null)
					continue;
				var key = new ResourceKey(rsrc);
				if (!resources.TryGetValue(key, out var list))
					resources[key] = list = new List<EmbeddedResource>();
				list.Add(rsrc);
			}

			foreach (var list in resources.Values) {
				if (list.Count <= 1)
					continue;

				EmbeddedResource resourceToKeep = null;
				foreach (var rsrc in list) {
					if (UTF8String.IsNullOrEmpty(rsrc.Name))
						continue;

					resourceToKeep = rsrc;
					break;
				}
				if (resourceToKeep == null)
					continue;

				foreach (var rsrc in list) {
					if (rsrc == resourceToKeep)
						continue;
					AddResourceToBeRemoved(rsrc, $"Duplicate of resource {Utils.ToCsharpString(resourceToKeep.Name)}");
				}
			}
		}

		void RemoveInvalidResources() {
			foreach (var tmp in module.Resources) {
				var resource = tmp as EmbeddedResource;
				if (resource == null)
					continue;
				if (resource.Offset == null || (resource.CreateReader().StartOffset == 0 && resource.CreateReader().Length == 0))
					AddResourceToBeRemoved(resource, "Invalid resource");
			}
		}

		public override IEnumerable<int> GetStringDecrypterMethods() {
			var list = new List<int>();
			if (stringDecrypter != null && stringDecrypter.Detected)
				list.Add(stringDecrypter.Method.MDToken.ToInt32());
			return list;
		}

		protected override void Dispose(bool disposing) {
			if (disposing)
				FreePEImage();
			base.Dispose(disposing);
		}
	}
}



================================================
File: de4dot.code/deobfuscators/MaxtoCode/EncryptionInfos.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

namespace de4dot.code.deobfuscators.MaxtoCode {
	class EncryptionInfo {
		public uint MagicLo { get; set; }
		public uint MagicHi { get; set; }
		public EncryptionVersion Version { get; set; }
	}

	static class EncryptionInfos {
		public static readonly EncryptionInfo[] Rva900h = new EncryptionInfo[] {
			// PE header timestamp
			// 462FA2D2 = Wed, 25 Apr 2007 18:49:54 (3.20)
			// 471299D3 = Sun, 14 Oct 2007 22:36:03 (3.22)
			new EncryptionInfo {
				MagicLo = 0xA098B387,
				MagicHi = 0x1E8EBCA3,
				Version = EncryptionVersion.V1,
			},
			// 482384FB = Thu, 08 May 2008 22:55:55 (3.36)
			new EncryptionInfo {
				MagicLo = 0xAA98B387,
				MagicHi = 0x1E8EECA3,
				Version = EncryptionVersion.V2,
			},
			// 4A5EEC64 = Thu, 16 Jul 2009 09:01:24
			// 4C6220EC = Wed, 11 Aug 2010 04:02:52
			// 4C622357 = Wed, 11 Aug 2010 04:13:11
			new EncryptionInfo {
				MagicLo = 0xAA98B387,
				MagicHi = 0x128EECA3,
				Version = EncryptionVersion.V2,
			},
			// 4C6E4605 = Fri, 20 Aug 2010 09:08:21
			// 4D0E220D = Sun, 19 Dec 2010 15:17:33
			// 4DC2FC75 = Thu, 05 May 2011 19:37:25
			// 4DFA3D5D = Thu, 16 Jun 2011 17:29:01
			new EncryptionInfo {
				MagicLo = 0xAA98B387,
				MagicHi = 0xF28EECA3,
				Version = EncryptionVersion.V2,
			},
			// 4DC2FE0C = Thu, 05 May 2011 19:44:12
			new EncryptionInfo {
				MagicLo = 0xAA98B387,
				MagicHi = 0xF28EEAA3,
				Version = EncryptionVersion.V2,
			},
			// 4ED76740 = Thu, 01 Dec 2011 11:38:40
			// 4EE1FAD1 = Fri, 09 Dec 2011 12:10:57
			new EncryptionInfo {
				MagicLo = 0xAA983B87,
				MagicHi = 0xF28EECA3,
				Version = EncryptionVersion.V3,
			},
			// 4F832868 = Mon, Apr 09 2012 20:20:24
			new EncryptionInfo {
				MagicLo = 0xAA913B87,
				MagicHi = 0xF28EE0A3,
				Version = EncryptionVersion.V4,
			},
			// 4F8E262C = Wed, 18 Apr 2012 02:25:48
			// 4FBE81DE = Thu, 24 May 2012 18:45:50
			new EncryptionInfo {
				MagicLo = 0xBA983B87,
				MagicHi = 0xF28EDDA3,
				Version = EncryptionVersion.V5,
			},
			// 50A0963C = Mon, 12 Nov 2012 06:25:00
			new EncryptionInfo {
				MagicLo = 0xBA683B87,
				MagicHi = 0xF28ECDA3,
				Version = EncryptionVersion.V6,
			},
			// 50D367A5 = Mon, 12 Nov 2012 06:25:00
			new EncryptionInfo {
				MagicLo = 0x8A683B87,
				MagicHi = 0x828ECDA3,
				Version = EncryptionVersion.V7,
			},
			// 513D4492
			// 51413BD8
			// 51413D68
			// 5166DB4F
			new EncryptionInfo {
				MagicLo = 0x1A683B87,
				MagicHi = 0x128ECDA3,
				Version = EncryptionVersion.V8,
			},
			// 51927495
			new EncryptionInfo {
				MagicLo = 0x7A643B87,
				MagicHi = 0x624ECDA3,
				Version = EncryptionVersion.V8,
			},
			// 526BC020
			// 526BDD12
			// 5296E242
			// 52B2B2A3
			// 52B3043C
			// 53172907
			// 531729C4
			new EncryptionInfo {
				MagicLo = 0x9A683B87,
				MagicHi = 0x928ECDA3,
				Version = EncryptionVersion.V8,
			},
		};

		public static readonly EncryptionInfo[] McKey8C0h = new EncryptionInfo[] {
			// 462FA2D2 = Wed, 25 Apr 2007 18:49:54 (3.20)
			// 471299D3 = Sun, 14 Oct 2007 22:36:03 (3.22)
			new EncryptionInfo {
				MagicLo = 0x6AA13B13,
				MagicHi = 0xD72B991F,
				Version = EncryptionVersion.V1,
			},
			// 482384FB = Thu, 08 May 2008 22:55:55 (3.36)
			new EncryptionInfo {
				MagicLo = 0x6A713B13,
				MagicHi = 0xD72B891F,
				Version = EncryptionVersion.V2,
			},
			// 4A5EEC64 = Thu, 16 Jul 2009 09:01:24
			// 4C6220EC = Wed, 11 Aug 2010 04:02:52
			// 4C622357 = Wed, 11 Aug 2010 04:13:11
			// 4C6E4605 = Fri, 20 Aug 2010 09:08:21
			// 4D0E220D = Sun, 19 Dec 2010 15:17:33
			// 4DC2FC75 = Thu, 05 May 2011 19:37:25
			// 4DC2FE0C = Thu, 05 May 2011 19:44:12
			// 4DFA3D5D = Thu, 16 Jun 2011 17:29:01
			new EncryptionInfo {
				MagicLo = 0x6A713B13,
				MagicHi = 0xD72B891F,
				Version = EncryptionVersion.V2,
			},
			// 4ED76740 = Thu, 01 Dec 2011 11:38:40
			// 4EE1FAD1 = Fri, 09 Dec 2011 12:10:57
			new EncryptionInfo {
				MagicLo = 0x6A731B13,
				MagicHi = 0xD72B891F,
				Version = EncryptionVersion.V3,
			},
			// 4F832868 = Mon, Apr 09 2012 20:20:24
			new EncryptionInfo {
				MagicLo = 0x6AD31B13,
				MagicHi = 0xD72B8A1F,
				Version = EncryptionVersion.V4,
			},
			// 4F8E262C = Wed, 18 Apr 2012 02:25:48
			new EncryptionInfo {
				MagicLo = 0xAA731B13,
				MagicHi = 0xD723891F,
				Version = EncryptionVersion.V5,
			},
			// 50D367A5 = Mon, 12 Nov 2012 06:25:00
			new EncryptionInfo {
				MagicLo = 0x8A731B13,
				MagicHi = 0x8723891F,
				Version = EncryptionVersion.V7,
			},
			// 513D4492
			// 51413BD8
			// 51413D68
			// 5166DB4F
			// 526BC020
			// 526BDD12
			// 5296E242
			// 52B2B2A3
			// 52B3043C
			// 53172907
			// 531729C4
			new EncryptionInfo {
				MagicLo = 0x1A731B13,
				MagicHi = 0x1723891F,
				Version = EncryptionVersion.V8,
			},
			// 51927495
			new EncryptionInfo {
				MagicLo = 0x7A731B13,
				MagicHi = 0x1723891F,
				Version = EncryptionVersion.V8,
			},
		};
	}
}



================================================
File: de4dot.code/deobfuscators/MaxtoCode/MainType.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.MaxtoCode {
	class MainType {
		ModuleDefMD module;
		TypeDef mcType;
		bool isOld;
		ModuleRef runtimeModule1, runtimeModule2;

		public bool IsOld => isOld;
		public TypeDef Type => mcType;

		public IEnumerable<MethodDef> InitMethods {
			get {
				var list = new List<MethodDef>();
				if (mcType == null)
					return list;
				foreach (var method in mcType.Methods) {
					if (method.IsStatic && DotNetUtils.IsMethod(method, "System.Void", "()"))
						list.Add(method);
				}
				return list;
			}
		}

		public IEnumerable<ModuleRef> RuntimeModuleRefs {
			get {
				if (runtimeModule1 != null)
					yield return runtimeModule1;
				if (runtimeModule2 != null)
					yield return runtimeModule2;
			}
		}

		public bool Detected => mcType != null;
		public MainType(ModuleDefMD module) => this.module = module;

		public MainType(ModuleDefMD module, MainType oldOne) {
			this.module = module;
			mcType = Lookup(oldOne.mcType, "Could not find main type");
		}

		T Lookup<T>(T def, string errorMessage) where T : class, ICodedToken =>
			DeobUtils.Lookup(module, def, errorMessage);

		public void Find() {
			foreach (var cctor in DeobUtils.GetInitCctors(module, 3)) {
				if (CheckCctor(cctor))
					break;
			}
		}

		bool CheckCctor(MethodDef cctor) {
			foreach (var method in DotNetUtils.GetCalledMethods(module, cctor)) {
				if (method.Name != "Startup")
					continue;
				if (!DotNetUtils.IsMethod(method, "System.Void", "()"))
					continue;

				if (!CheckType(method.DeclaringType, out runtimeModule1, out runtimeModule2, out bool isOldTmp))
					continue;

				mcType = method.DeclaringType;
				isOld = isOldTmp;
				return true;
			}

			return false;
		}

		static bool CheckType(TypeDef type, out ModuleRef module1, out ModuleRef module2, out bool isOld) {
			module1 = module2 = null;
			isOld = false;

			if (type.FindMethod("Startup") == null)
				return false;

			var pinvokes = GetPinvokes(type);
			var pinvokeList = GetPinvokeList(pinvokes, "CheckRuntime");
			if (pinvokeList == null)
				return false;
			if (GetPinvokeList(pinvokes, "MainDLL") == null)
				return false;

			// Newer versions (3.4+ ???) also have GetModuleBase()
			isOld = GetPinvokeList(pinvokes, "GetModuleBase") == null;

			module1 = pinvokeList[0].ImplMap.Module;
			module2 = pinvokeList[1].ImplMap.Module;
			return true;
		}

		static Dictionary<string, List<MethodDef>> GetPinvokes(TypeDef type) {
			var pinvokes = new Dictionary<string, List<MethodDef>>(StringComparer.Ordinal);
			foreach (var method in type.Methods) {
				var info = method.ImplMap;
				if (info == null || UTF8String.IsNullOrEmpty(info.Name))
					continue;
				if (!pinvokes.TryGetValue(info.Name.String, out var list))
					pinvokes[info.Name.String] = list = new List<MethodDef>();
				list.Add(method);
			}
			return pinvokes;
		}

		static List<MethodDef> GetPinvokeList(Dictionary<string, List<MethodDef>> pinvokes, string methodName) {
			if (!pinvokes.TryGetValue(methodName, out var list))
				return null;
			if (list.Count != 2)
				return null;
			return list;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/MaxtoCode/McKey.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.IO;

namespace de4dot.code.deobfuscators.MaxtoCode {
	class McKey {
		byte[] data;

		public byte this[int index] => data[index];

		public McKey(MyPEImage peImage, PeHeader peHeader) {
			try {
				data = peImage.ReadBytes(peHeader.GetMcKeyRva(), 0x2000);
			}
			catch (Exception ex) when (ex is IOException || ex is ArgumentException) {
				data = peImage.ReadBytes(peHeader.GetMcKeyRva(), 0x1000);
			}
		}

		public byte[] ReadBytes(int offset, int len) {
			byte[] bytes = new byte[len];
			Array.Copy(data, offset, bytes, 0, len);
			return bytes;
		}

		public byte ReadByte(int offset) => data[offset];
		public uint ReadUInt32(int offset) => BitConverter.ToUInt32(data, offset);
	}
}



================================================
File: de4dot.code/deobfuscators/MaxtoCode/MethodsDecrypter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using dnlib.DotNet;
using dnlib.IO;
using dnlib.PE;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.MaxtoCode {
	// Decrypts methods, resources and strings (#US heap)
	class MethodsDecrypter {
		ModuleDef module;
		DecrypterInfo decrypterInfo;

		class MethodInfos {
			ModuleDef module;
			MainType mainType;
			MyPEImage peImage;
			PeHeader peHeader;
			McKey mcKey;
			uint structSize;
			uint methodInfosOffset;
			uint encryptedDataOffset;
			uint xorKey;
			Dictionary<uint, DecryptedMethodInfo> infos = new Dictionary<uint, DecryptedMethodInfo>();
			List<IDecrypter> decrypters = new List<IDecrypter>();
			const int ENCRYPTED_DATA_INFO_SIZE = 0x13;

			delegate byte[] DecryptFunc(byte[] encrypted);

			public class DecryptedMethodInfo {
				public uint bodyRva;
				public byte[] body;

				public DecryptedMethodInfo(uint bodyRva, byte[] body) {
					this.bodyRva = bodyRva;
					this.body = body;
				}
			}

			public MethodInfos(ModuleDef module, MainType mainType, MyPEImage peImage, PeHeader peHeader, McKey mcKey) {
				this.module = module;
				this.mainType = mainType;
				this.peImage = peImage;
				this.peHeader = peHeader;
				this.mcKey = mcKey;

				structSize = GetStructSize(mcKey);

				uint methodInfosRva = peHeader.GetRva(0x0FF8, mcKey.ReadUInt32(0x005A));
				uint encryptedDataRva = peHeader.GetRva(0x0FF0, mcKey.ReadUInt32(0x0046));

				methodInfosOffset = peImage.RvaToOffset(methodInfosRva);
				encryptedDataOffset = peImage.RvaToOffset(encryptedDataRva);
			}

			static uint GetStructSize(McKey mcKey) {
				uint magicLo = mcKey.ReadUInt32(0x8C0);
				uint magicHi = mcKey.ReadUInt32(0x8C4);
				foreach (var info in EncryptionInfos.McKey8C0h) {
					if (magicLo == info.MagicLo && magicHi == info.MagicHi)
						return 0xC + 6 * ENCRYPTED_DATA_INFO_SIZE;
				}
				return 0xC + 3 * ENCRYPTED_DATA_INFO_SIZE;
			}

			EncryptionVersion GetVersion() {
				if (peHeader.EncryptionVersion != EncryptionVersion.Unknown)
					return peHeader.EncryptionVersion;

				uint m2lo = mcKey.ReadUInt32(0x8C0);
				uint m2hi = mcKey.ReadUInt32(0x8C4);

				foreach (var info in EncryptionInfos.McKey8C0h) {
					if (info.MagicLo == m2lo && info.MagicHi == m2hi)
						return info.Version;
				}

				Logger.w("Could not detect MC version. Magic2: {0:X8} {1:X8}", m2lo, m2hi);
				return EncryptionVersion.Unknown;
			}

			public DecryptedMethodInfo Lookup(uint bodyRva) {
				infos.TryGetValue(bodyRva, out var info);
				return info;
			}

			byte ReadByte(uint offset) => peImage.OffsetReadByte(methodInfosOffset + offset);
			short ReadInt16(uint offset) => (short)peImage.OffsetReadUInt16(methodInfosOffset + offset);
			uint ReadUInt32(uint offset) => peImage.OffsetReadUInt32(methodInfosOffset + offset);
			int ReadInt32(uint offset) => (int)ReadUInt32(offset);
			short ReadEncryptedInt16(uint offset) => (short)(ReadInt16(offset) ^ xorKey);
			int ReadEncryptedInt32(uint offset) => (int)ReadEncryptedUInt32(offset);
			uint ReadEncryptedUInt32(uint offset) => ReadUInt32(offset) ^ xorKey;

			interface IDecrypter {
				byte[] Decrypt(int type, byte[] encrypted);
				bool HasTimeStamp(uint timeStamp);
			}

			class Decrypter : IDecrypter {
				DecryptFunc[] decrypterHandlers;
				uint[] timeStamps;

				public Decrypter(DecryptFunc[] decrypterHandlers)
					: this(decrypterHandlers, null) {
				}

				public Decrypter(DecryptFunc[] decrypterHandlers, uint[] timeStamps) {
					this.decrypterHandlers = decrypterHandlers;
					this.timeStamps = timeStamps ?? new uint[0];
				}

				public byte[] Decrypt(int type, byte[] encrypted) {
					if (1 <= type && type <= decrypterHandlers.Length)
						return decrypterHandlers[type - 1](encrypted);
					throw new ApplicationException($"Invalid encryption type: {type:X2}");
				}

				public bool HasTimeStamp(uint timeStamp) {
					foreach (var ts in timeStamps) {
						if (timeStamp == ts)
							return true;
					}
					return false;
				}
			}

			void InitializeDecrypter() {
				switch (GetVersion()) {
				case EncryptionVersion.V1:
					decrypters.Add(new Decrypter(new DecryptFunc[] { Decrypt1_v1, Decrypt4_v1, Decrypt2_v1, Decrypt3_v1, Decrypt5, Decrypt6, Decrypt7 }, new uint[] { 0x462FA2D2 }));
					decrypters.Add(new Decrypter(new DecryptFunc[] { Decrypt4_v1, Decrypt1_v1, Decrypt2_v1, Decrypt3_v1, Decrypt5, Decrypt6, Decrypt7 }, new uint[] { 0x471299D3 }));
					break;

				case EncryptionVersion.V2: decrypters.Add(new Decrypter(new DecryptFunc[] { Decrypt3_v1, Decrypt2_v1, Decrypt1_v1, Decrypt4_v1, Decrypt5, Decrypt6, Decrypt7 }, new uint[] { 0x482384FB, 0x4A5EEC64, 0x4BD6F703, 0x4C6220EC, 0x4C622357, 0x4C6E4605, 0x4D0E220D, 0x4DC2FC75, 0x4DC2FE0C, 0x4DFA3D5D })); break;
				case EncryptionVersion.V3: decrypters.Add(new Decrypter(new DecryptFunc[] { Decrypt1_v1, Decrypt2_v1, Decrypt3_v1, Decrypt4_v1, Decrypt5, Decrypt6, Decrypt7 }, new uint[] { 0x4ECF2195, 0x4ED76740, 0x4EE1FAD1 })); break;
				case EncryptionVersion.V4: decrypters.Add(new Decrypter(new DecryptFunc[] { Decrypt2_v1, Decrypt1_v1, Decrypt3_v1, Decrypt4_v1, Decrypt5, Decrypt6, Decrypt7 }, new uint[] { 0x4F832868, 0x4F8C86BE, 0x4F9447DB, 0x4FDEF2FF })); break;

				case EncryptionVersion.V5:
					decrypters.Add(new Decrypter(new DecryptFunc[] { Decrypt4_v1, Decrypt2_v1, Decrypt3_v1, Decrypt1_v1, Decrypt5, Decrypt6, Decrypt7 }, new uint[] { 0x4F8E262C, 0x4F966B0B, 0x4FAB3CCF }));
					decrypters.Add(new Decrypter(new DecryptFunc[] { Decrypt4_v2, Decrypt2_v2, Decrypt3_v2, Decrypt1_v2, Decrypt6, Decrypt7, Decrypt5 }, new uint[] { 0x4FC7459E, 0x4FCEBD7B }));
					decrypters.Add(new Decrypter(new DecryptFunc[] { Decrypt4_v3, Decrypt2_v3, Decrypt3_v3, Decrypt1_v3, Decrypt6, Decrypt7, Decrypt5 }, new uint[] { 0x4FBE81DE }));
					break;

				case EncryptionVersion.V6: decrypters.Add(new Decrypter(new DecryptFunc[] { Decrypt4_v4, Decrypt2_v4, Decrypt3_v4, Decrypt1_v4, Decrypt6, Decrypt7, Decrypt5 }, new uint[] { 0x50A0963C })); break;
				case EncryptionVersion.V7: decrypters.Add(new Decrypter(new DecryptFunc[] { Decrypt4_v5, Decrypt2_v5, Decrypt3_v5, Decrypt1_v5, Decrypt6, Decrypt8_v5, Decrypt9_v5, Decrypt7, Decrypt5 }, new uint[] { 0x50D367A5 })); break;

				case EncryptionVersion.V8:
					decrypters.Add(new Decrypter(new DecryptFunc[] { Decrypt4_v6, Decrypt2_v2, Decrypt3_v6, Decrypt1_v6, Decrypt6, Decrypt8_v6, Decrypt9_v6, Decrypt7, Decrypt10, Decrypt5 }, new uint[] { 0x5166DB4F, 0x51927495 }));
					decrypters.Add(new Decrypter(new DecryptFunc[] { Decrypt4_v7, Decrypt2_v2, Decrypt3_v6, Decrypt1_v7, Decrypt6, Decrypt8_v7, Decrypt9_v7, Decrypt7, Decrypt5 }, new uint[] { 0x51413D68 }));
					decrypters.Add(new Decrypter(new DecryptFunc[] { Decrypt4_v7, Decrypt2_v2, Decrypt3_v6, Decrypt1_v7, Decrypt6, Decrypt8_v8, Decrypt9_v8, Decrypt7, Decrypt5 }, new uint[] { 0x513D7124, 0x51413BD8 }));
					decrypters.Add(new Decrypter(new DecryptFunc[] { Decrypt4_v5, Decrypt2_v2, Decrypt3_v6, Decrypt1_v9, Decrypt6, Decrypt8_v8, Decrypt9_v9, Decrypt7, Decrypt5 }, new uint[] { 0x513D4492, 0x5113E277 }));
					decrypters.Add(new Decrypter(new DecryptFunc[] { Decrypt3_v6, Decrypt2_v2, Decrypt4_v8, Decrypt1_v10, Decrypt8_v9, Decrypt9_v10, Decrypt6, Decrypt7, Decrypt5 }, new uint[] { 0x526BDD12 }));
					decrypters.Add(new Decrypter(new DecryptFunc[] { Decrypt1_v10, Decrypt4_v8, Decrypt2_v2, Decrypt3_v6, Decrypt6, Decrypt8_v9, Decrypt9_v10, Decrypt7, Decrypt5 }, new uint[] { 0x526BC020 }));
					decrypters.Add(new Decrypter(new DecryptFunc[] { Decrypt3_v7, Decrypt2_v6, Decrypt4_v9, Decrypt1_v11, Decrypt8_v10, Decrypt11_v1, Decrypt6, Decrypt7, Decrypt5 }, new uint[] { 0x5296E242, 0x52B3043C }));
					decrypters.Add(new Decrypter(new DecryptFunc[] { Decrypt4_v10, Decrypt1_v12, Decrypt3_v8, Decrypt2_v7, Decrypt6, Decrypt8_v11, Decrypt9_v11, Decrypt7, Decrypt5 }, new uint[] { 0x531729C4 }));
					decrypters.Add(new Decrypter(new DecryptFunc[] { Decrypt1_v13, Decrypt4_v11, Decrypt2_v8, Decrypt3_v9, Decrypt6, Decrypt8_v11, Decrypt9_v12, Decrypt7, Decrypt5 }, new uint[] { 0x52B2B2A3 }));
					decrypters.Add(new Decrypter(new DecryptFunc[] { Decrypt2_v9, Decrypt3_v10, Decrypt1_v10, Decrypt4_v12, Decrypt8_v12, Decrypt9_v13, Decrypt6, Decrypt7, Decrypt5 }, new uint[] { 0x53172907 }));
					break;

				case EncryptionVersion.Unknown:
				default:
					throw new ApplicationException("Unknown MC version");
				}
			}

			public void InitializeInfos() {
				InitializeDecrypter();
				if (!InitializeInfos2())
					throw new ApplicationException("Could not decrypt methods");
			}

			uint GetRuntimeTimeStamp() {
				string path = module.Location;
				if (string.IsNullOrEmpty(path))
					return 0;

				try {
					var rtNames = new List<string>();
					foreach (var rtModRef in mainType.RuntimeModuleRefs) {
						string dllName = rtModRef.Name;
						if (!dllName.ToUpperInvariant().EndsWith(".DLL"))
							dllName += ".dll";
						rtNames.Add(dllName);
					}
					if (rtNames.Count == 0)
						return 0;

					for (var di = new DirectoryInfo(Path.GetDirectoryName(path)); di != null; di = di.Parent) {
						foreach (var dllName in rtNames) {
							try {
								using (var peImage = new PEImage(Path.Combine(di.FullName, dllName))) {
									if (peImage.ImageNTHeaders.FileHeader.Machine == Machine.I386)
										return peImage.ImageNTHeaders.FileHeader.TimeDateStamp;
								}
							}
							catch {
							}
						}
					}
				}
				catch {
				}

				return 0;
			}

			bool InitializeInfos2() {
				uint rtTimeStamp = GetRuntimeTimeStamp();
				if (rtTimeStamp != 0) {
					var decrypter = GetCorrectDecrypter(rtTimeStamp);
					if (decrypter != null) {
						try {
							if (InitializeInfos2(decrypter))
								return true;
						}
						catch {
						}
					}
				}

				Dictionary<uint, DecryptedMethodInfo> savedInfos = null;
				foreach (var decrypter in decrypters) {
					try {
						if (InitializeInfos2(decrypter)) {
							if (savedInfos != null) {
								Logger.w("Decryption probably failed. Make sure the correct MaxtoCode runtime file is present.");
								break;
							}
							savedInfos = infos;
							infos = new Dictionary<uint, DecryptedMethodInfo>();
						}
					}
					catch {
					}
				}
				if (savedInfos == null)
					return false;
				infos = savedInfos;
				return true;
			}

			IDecrypter GetCorrectDecrypter(uint timeStamp) {
				foreach (var decrypter in decrypters) {
					if (decrypter.HasTimeStamp(timeStamp))
						return decrypter;
				}
				return null;
			}

			bool InitializeInfos2(IDecrypter decrypter) {
				int numMethods = ReadInt32(0) ^ ReadInt32(4);
				if (numMethods < 0)
					throw new ApplicationException("Invalid number of encrypted methods");

				xorKey = (uint)numMethods;
				int numEncryptedDataInfos = ((int)structSize - 0xC) / ENCRYPTED_DATA_INFO_SIZE;
				var encryptedDataInfos = new byte[numEncryptedDataInfos][];

				uint offset = 8;
				infos.Clear();
				for (int i = 0; i < numMethods; i++, offset += structSize) {
					uint methodBodyRva = ReadEncryptedUInt32(offset);
					uint totalSize = ReadEncryptedUInt32(offset + 4);
					/*uint methodInstructionRva =*/ ReadEncryptedUInt32(offset + 8);

					// Read the method body header and method body (instrs + exception handlers).
					// The method body header is always in the first one. The instrs + ex handlers
					// are always in the last 4, and evenly divided (each byte[] is totalLen / 4).
					// The 2nd one is for the exceptions (or padding), but it may be null.
					uint offset2 = offset + 0xC;
					int exOffset = 0;
					for (int j = 0; j < encryptedDataInfos.Length; j++, offset2 += ENCRYPTED_DATA_INFO_SIZE) {
						// readByte(offset2); <-- index
						int encryptionType = ReadEncryptedInt16(offset2 + 1);
						uint dataOffset = ReadEncryptedUInt32(offset2 + 3);
						uint encryptedSize = ReadEncryptedUInt32(offset2 + 7);
						uint realSize = ReadEncryptedUInt32(offset2 + 11);
						if (j >= 3 && dataOffset == xorKey && encryptedSize == xorKey) {
							encryptedDataInfos[j] = null;
							continue;
						}
						if (j == 1)
							exOffset = ReadEncryptedInt32(offset2 + 15);
						if (j == 1 && exOffset == 0)
							encryptedDataInfos[j] = null;
						else
							encryptedDataInfos[j] = Decrypt(decrypter, encryptionType, dataOffset, encryptedSize, realSize);
					}

					var decryptedData = new byte[totalSize];
					int copyOffset = 0;
					copyOffset = CopyData(decryptedData, encryptedDataInfos[0], copyOffset);
					for (int j = 2; j < encryptedDataInfos.Length; j++)
						copyOffset = CopyData(decryptedData, encryptedDataInfos[j], copyOffset);
					CopyData(decryptedData, encryptedDataInfos[1], exOffset); // Exceptions or padding

					if (!MethodBodyParser.Verify(decryptedData))
						throw new InvalidMethodBody();

					var info = new DecryptedMethodInfo(methodBodyRva, decryptedData);
					infos[info.bodyRva] = info;
				}

				return true;
			}

			static int CopyData(byte[] dest, byte[] source, int offset) {
				if (source == null)
					return offset;
				Array.Copy(source, 0, dest, offset, source.Length);
				return offset + source.Length;
			}

			byte[] ReadData(uint offset, int size) => peImage.OffsetReadBytes(encryptedDataOffset + offset, size);

			byte[] Decrypt(IDecrypter decrypter, int type, uint dataOffset, uint encryptedSize, uint realSize) {
				if (realSize == 0)
					return null;
				if (realSize > encryptedSize)
					throw new ApplicationException("Invalid realSize");

				var encrypted = ReadData(dataOffset, (int)encryptedSize);
				var decrypted = decrypter.Decrypt(type, encrypted);
				if (realSize > decrypted.Length)
					throw new ApplicationException("Invalid decrypted length");
				Array.Resize(ref decrypted, (int)realSize);
				return decrypted;
			}

			byte[] Decrypt1_v1(byte[] encrypted) => Decrypt1(encrypted, 0, 0, 0x2000);
			byte[] Decrypt1_v2(byte[] encrypted) => Decrypt1(encrypted, 6, 6, 0x500);
			byte[] Decrypt1_v3(byte[] encrypted) => Decrypt1(encrypted, 6, 0, 0x1000);
			byte[] Decrypt1_v4(byte[] encrypted) => Decrypt1(encrypted, 5, 5, 0x500);
			byte[] Decrypt1_v5(byte[] encrypted) => Decrypt1(encrypted, 9, 9, 0x500);
			byte[] Decrypt1_v6(byte[] encrypted) => Decrypt1(encrypted, 0x27, 0x27, 0x100);
			byte[] Decrypt1_v7(byte[] encrypted) => Decrypt1(encrypted, 0x1D, 0x1D, 0x400);
			byte[] Decrypt1_v9(byte[] encrypted) => Decrypt1(encrypted, 9, 0x13, 0x400);
			byte[] Decrypt1_v10(byte[] encrypted) => Decrypt1(encrypted, 0x11, 0x11, 0x400);
			byte[] Decrypt1_v11(byte[] encrypted) => Decrypt1(encrypted, 0x13, 0x13, 0x400);
			byte[] Decrypt1_v12(byte[] encrypted) => Decrypt1(encrypted, 0x12, 0x12, 0x200);
			byte[] Decrypt1_v13(byte[] encrypted) => Decrypt1(encrypted, 0x11, 0x11, 0x200);

			byte[] Decrypt1(byte[] encrypted, int keyStart, int keyReset, int keyEnd) {
				var decrypted = new byte[encrypted.Length];
				for (int i = 0, ki = keyStart; i < decrypted.Length; i++) {
					decrypted[i] = (byte)(encrypted[i] ^ mcKey.ReadByte(ki));
					if (++ki == keyEnd)
						ki = keyReset;
				}
				return decrypted;
			}

			byte[] Decrypt2_v1(byte[] encrypted) => Decrypt2(encrypted, 0x00FA);
			byte[] Decrypt2_v2(byte[] encrypted) => Decrypt2(encrypted, 0x00FA + 9);
			byte[] Decrypt2_v3(byte[] encrypted) => Decrypt2(encrypted, 0x00FA + 0x24);
			byte[] Decrypt2_v4(byte[] encrypted) => Decrypt2(encrypted, 0x00FA + 7);
			byte[] Decrypt2_v5(byte[] encrypted) => Decrypt2(encrypted, 0x00FA + 0x63);
			byte[] Decrypt2_v6(byte[] encrypted) => Decrypt2(encrypted, 0x00FA + 0x0B);
			byte[] Decrypt2_v7(byte[] encrypted) => Decrypt2(encrypted, 0x00FA + 0x0E);
			byte[] Decrypt2_v8(byte[] encrypted) => Decrypt2(encrypted, 0x00FA + 0x0D);
			byte[] Decrypt2_v9(byte[] encrypted) => Decrypt2(encrypted, 0x00FA + 0x0C);

			byte[] Decrypt2(byte[] encrypted, int offset) {
				if ((encrypted.Length & 7) != 0)
					throw new ApplicationException("Invalid encryption #2 length");
				uint key4 = mcKey.ReadUInt32(offset + 4 * 4);
				uint key5 = mcKey.ReadUInt32(offset + 5 * 4);

				byte[] decrypted = new byte[encrypted.Length & ~7];
				var writer = new BinaryWriter(new MemoryStream(decrypted));

				int loopCount = encrypted.Length / 8;
				for (int i = 0; i < loopCount; i++) {
					uint val0 = BitConverter.ToUInt32(encrypted, i * 8);
					uint val1 = BitConverter.ToUInt32(encrypted, i * 8 + 4);
					uint x = (val1 >> 26) + (val0 << 6);
					uint y = (val0 >> 26) + (val1 << 6);

					writer.Write(x ^ key4);
					writer.Write(y ^ key5);
				}

				return decrypted;
			}

			byte[] Decrypt3_v1(byte[] encrypted) => Decrypt3(encrypted, 0x015E);
			byte[] Decrypt3_v2(byte[] encrypted) => Decrypt3(encrypted, 0x015E + 0xE5);
			byte[] Decrypt3_v3(byte[] encrypted) => Decrypt3(encrypted, 0x015E + 0x28);
			byte[] Decrypt3_v4(byte[] encrypted) => Decrypt3(encrypted, 0x015E + 8);
			byte[] Decrypt3_v5(byte[] encrypted) => Decrypt3(encrypted, 0x015E + 7);
			byte[] Decrypt3_v6(byte[] encrypted) => Decrypt3(encrypted, 0x015E + 0x7F);
			byte[] Decrypt3_v7(byte[] encrypted) => Decrypt3(encrypted, 0x015E + 0x0D);
			byte[] Decrypt3_v8(byte[] encrypted) => Decrypt3(encrypted, 0x015E + 0x0F);
			byte[] Decrypt3_v9(byte[] encrypted) => Decrypt3(encrypted, 0x015E + 0x12);
			byte[] Decrypt3_v10(byte[] encrypted) => Decrypt3(encrypted, 0x015E + 0x0E);

			static readonly byte[] decrypt3Shifts = new byte[16] { 5, 11, 14, 21, 6, 20, 17, 29, 4, 10, 3, 2, 7, 1, 26, 18 };
			byte[] Decrypt3(byte[] encrypted, int offset) {
				if ((encrypted.Length & 7) != 0)
					throw new ApplicationException("Invalid encryption #3 length");
				uint key0 = mcKey.ReadUInt32(offset + 0 * 4);
				uint key3 = mcKey.ReadUInt32(offset + 3 * 4);

				byte[] decrypted = new byte[encrypted.Length & ~7];
				var writer = new BinaryWriter(new MemoryStream(decrypted));

				int loopCount = encrypted.Length / 8;
				for (int i = 0; i < loopCount; i++) {
					uint x = BitConverter.ToUInt32(encrypted, i * 8);
					uint y = BitConverter.ToUInt32(encrypted, i * 8 + 4);
					foreach (var shift in decrypt3Shifts) {
						int shift1 = 32 - shift;
						uint x1 = (y >> shift1) + (x << shift);
						uint y1 = (x >> shift1) + (y << shift);
						x = x1;
						y = y1;
					}

					writer.Write(x ^ key0);
					writer.Write(y ^ key3);
				}

				return decrypted;
			}

			byte[] Decrypt4_v1(byte[] encrypted) => Decrypt4(encrypted, 0, 0, 0x2000);
			byte[] Decrypt4_v2(byte[] encrypted) => Decrypt4(encrypted, 0x14, 0x14, 0x1000);
			byte[] Decrypt4_v3(byte[] encrypted) => Decrypt4(encrypted, 5, 0, 0x2000);
			byte[] Decrypt4_v4(byte[] encrypted) => Decrypt4(encrypted, 0x0B, 0x0B, 0x1000);
			byte[] Decrypt4_v5(byte[] encrypted) => Decrypt4(encrypted, 0x15, 0x15, 0x100);
			byte[] Decrypt4_v6(byte[] encrypted) => Decrypt4(encrypted, 0x63, 0x63, 0x150);
			byte[] Decrypt4_v7(byte[] encrypted) => Decrypt4(encrypted, 0x0B, 0x0B, 0x100);
			byte[] Decrypt4_v8(byte[] encrypted) => Decrypt4(encrypted, 9, 9, 0x100);
			byte[] Decrypt4_v9(byte[] encrypted) => Decrypt4(encrypted, 0x0B, 0x0B, 0x150);
			byte[] Decrypt4_v10(byte[] encrypted) => Decrypt4(encrypted, 0x10, 0x10, 0x120);
			byte[] Decrypt4_v11(byte[] encrypted) => Decrypt4(encrypted, 0x0F, 0x0E, 0x120);
			byte[] Decrypt4_v12(byte[] encrypted) => Decrypt4(encrypted, 0x0C, 0x0C, 0x150);

			byte[] Decrypt4(byte[] encrypted, int keyStart, int keyReset, int keyEnd) {
				var decrypted = new byte[encrypted.Length / 3 * 2 + 1];

				int count = encrypted.Length / 3;
				int i = 0, ki = keyStart, j = 0;
				while (count-- > 0) {
					byte k1 = mcKey.ReadByte(ki + 1);
					byte k2 = mcKey.ReadByte(ki + 2);
					byte k3 = mcKey.ReadByte(ki + 3);
					decrypted[j++] = (byte)(((encrypted[i + 1] ^ k2) >> 4) | ((encrypted[i] ^ k1) & 0xF0));
					decrypted[j++] = (byte)(((encrypted[i + 1] ^ k2) << 4) | ((encrypted[i + 2] ^ k3) & 0x0F));
					i += 3;
					ki += 4;
					if (ki >= keyEnd)
						ki = keyReset;
				}

				if ((encrypted.Length % 3) != 0)
					decrypted[j] = (byte)(encrypted[i] ^ mcKey.ReadByte(ki));

				return decrypted;
			}

			byte[] Decrypt5(byte[] encrypted) => CryptDecrypter.Decrypt(mcKey.ReadBytes(0x0032, 15), encrypted);
			byte[] Decrypt6(byte[] encrypted) => Decrypter6.Decrypt(mcKey.ReadBytes(0x0096, 32), encrypted);

			byte[] Decrypt7(byte[] encrypted) {
				var decrypted = (byte[])encrypted.Clone();
				new Blowfish(GetBlowfishKey()).Decrypt_LE(decrypted);
				return decrypted;
			}

			byte[] Decrypt8_v5(byte[] encrypted) => Decrypt8(encrypted, 7, 7, 0x600);
			byte[] Decrypt8_v6(byte[] encrypted) => Decrypt8(encrypted, 0x1B, 0x1B, 0x100);
			byte[] Decrypt8_v7(byte[] encrypted) => Decrypt8(encrypted, 0x0D, 0x0D, 0x600);
			byte[] Decrypt8_v8(byte[] encrypted) => Decrypt8(encrypted, 0x11, 0x11, 0x600);
			byte[] Decrypt8_v9(byte[] encrypted) => Decrypt8(encrypted, 0xA, 0xA, 0x600);
			byte[] Decrypt8_v10(byte[] encrypted) => Decrypt8(encrypted, 0x14, 0x14, 0x600);
			byte[] Decrypt8_v11(byte[] encrypted) => Decrypt8(encrypted, 0x19, 0x19, 0x500);
			byte[] Decrypt8_v12(byte[] encrypted) => Decrypt8(encrypted, 0x14, 0x14, 0x600);

			byte[] Decrypt8(byte[] encrypted, int keyStart, int keyReset, int keyEnd) {
				var decrypted = new byte[encrypted.Length];
				int ki = keyStart;
				for (int i = 0; i < encrypted.Length; i++) {
					int b = mcKey.ReadByte(ki++) ^ encrypted[i];
					decrypted[i] = (byte)((b << 4) | (b >> 4));
					if (ki >= keyEnd)
						ki = keyReset;
				}

				return decrypted;
			}

			byte[] Decrypt9_v5(byte[] encrypted) => Decrypt9(encrypted, 0x11, 0x11, 0x610);
			byte[] Decrypt9_v6(byte[] encrypted) => Decrypt9(encrypted, 0x2E, 0x2E, 0x310);
			byte[] Decrypt9_v7(byte[] encrypted) => Decrypt9(encrypted, 0x28, 0x28, 0x510);
			byte[] Decrypt9_v8(byte[] encrypted) => Decrypt9(encrypted, 0x2C, 0x2C, 0x510);
			byte[] Decrypt9_v9(byte[] encrypted) => Decrypt9(encrypted, 0x10, 0x10, 0x510);
			byte[] Decrypt9_v10(byte[] encrypted) => Decrypt9(encrypted, 5, 5, 0x510);
			byte[] Decrypt9_v11(byte[] encrypted) => Decrypt9(encrypted, 0x19, 0x19, 0x500);
			byte[] Decrypt9_v12(byte[] encrypted) => Decrypt9(encrypted, 0x19, 0x19, 0x500);
			byte[] Decrypt9_v13(byte[] encrypted) => Decrypt9(encrypted, 5, 5, 0x510);

			byte[] Decrypt9(byte[] encrypted, int keyStart, int keyReset, int keyEnd) {
				var decrypted = new byte[encrypted.Length];
				int ki = keyStart;
				for (int i = 0; ; ) {
					byte b, k;

					if (i >= encrypted.Length) break;
					k = mcKey.ReadByte(ki++);
					b = encrypted[i];
					b ^= k;
					decrypted[i] = b;
					i++;
					if (ki >= keyEnd) ki = keyReset;

					if (i >= encrypted.Length) break;
					k = mcKey.ReadByte(ki++);
					b = encrypted[i];
					b ^= k;
					b = (byte)((b << 4) | (b >> 4));
					decrypted[i] = b;
					i++;
					if (ki >= keyEnd) ki = keyReset;

					if (i >= encrypted.Length) break;
					b = encrypted[i];
					b = (byte)((b << 4) | (b >> 4));
					decrypted[i] = b;
					ki++;
					i++;
					if (ki >= keyEnd) ki = keyReset;
				}
				return decrypted;
			}

			byte[] Decrypt10(byte[] encrypted) {
				byte[] enc = (byte[])encrypted.Clone();
				byte[] dest = new byte[enc.Length];
				int halfSize = enc.Length / 2;

				byte b = enc[0];
				b ^= 0xA1;
				dest[0] = b;

				b = enc[enc.Length - 1];
				b ^= 0x1A;
				dest[enc.Length - 1] = b;

				enc[0] = dest[0];
				enc[enc.Length - 1] = b;

				for (int i = 1; i < halfSize; i++)
					dest[i] = (byte)(enc[i] ^ dest[i - 1]);

				for (int i = enc.Length - 2; i >= halfSize; i--)
					dest[i] = (byte)(enc[i] ^ dest[i + 1]);

				return dest;
			}

			byte[] Decrypt11_v1(byte[] encrypted) => Decrypt11(encrypted, 5, 5, 0x510);

			byte[] Decrypt11(byte[] encrypted, int keyStart, int keyReset, int keyEnd) {
				byte[] dest = new byte[encrypted.Length];

				for (int i = 0, ki = keyStart; i < encrypted.Length; i++, ki++) {
					if (ki >= keyEnd)
						ki = keyStart;

					byte b;
					switch (i % 3) {
					case 0:
						dest[i] = (byte)(encrypted[i] ^ mcKey.ReadByte(ki));
						break;

					case 1:
						b = (byte)(encrypted[i] ^ mcKey.ReadByte(ki));
						dest[i] = (byte)((b << 4) | (b >> 4));
						break;

					case 2:
						b = encrypted[i];
						dest[i] = (byte)((b << 4) | (b >> 4));
						break;
					}
				}

				return dest;
			}

			byte[] blowfishKey;
			byte[] GetBlowfishKey() {
				if (blowfishKey != null)
					return blowfishKey;
				var key = new byte[100];
				int i;
				for (i = 0; i < key.Length; i++) {
					byte b = mcKey.ReadByte(i);
					if (b == 0)
						break;
					key[i] = b;
				}
				for (; i < key.Length; i++)
					key[i] = 0;
				key[key.Length - 1] = 0;
				return blowfishKey = key;
			}
		}

		public MethodsDecrypter(ModuleDef module, DecrypterInfo decrypterInfo) {
			this.module = module;
			this.decrypterInfo = decrypterInfo;
		}

		public bool Decrypt(ref DumpedMethods dumpedMethods) {
			dumpedMethods = DecryptMethods();
			if (dumpedMethods == null)
				return false;

			DecryptResources();
			DecryptStrings();

			return true;
		}

		DumpedMethods DecryptMethods() {
			var dumpedMethods = new DumpedMethods();

			var peImage = decrypterInfo.peImage;
			var methodInfos = new MethodInfos(module, decrypterInfo.mainType, peImage, decrypterInfo.peHeader, decrypterInfo.mcKey);
			methodInfos.InitializeInfos();

			var methodDef = peImage.Metadata.TablesStream.MethodTable;
			for (uint rid = 1; rid <= methodDef.Rows; rid++) {
				var dm = new DumpedMethod();
				peImage.ReadMethodTableRowTo(dm, rid);

				var info = methodInfos.Lookup(dm.mdRVA);
				if (info == null)
					continue;

				ushort magic = peImage.ReadUInt16(dm.mdRVA);
				if (magic != 0xFFF3)
					continue;

				var bodyReader = ByteArrayDataReaderFactory.CreateReader(info.body);
				var mbHeader = MethodBodyParser.ParseMethodBody(ref bodyReader, out dm.code, out dm.extraSections);
				peImage.UpdateMethodHeaderInfo(dm, mbHeader);

				dumpedMethods.Add(dm);
			}

			return dumpedMethods;
		}

		void DecryptResources() {
			var peHeader = decrypterInfo.peHeader;
			var mcKey = decrypterInfo.mcKey;
			var peImage = decrypterInfo.peImage;
			var fileData = decrypterInfo.fileData;

			uint decryptedResources = peHeader.ReadUInt32(0xFE8) ^ mcKey.ReadUInt32(0);
			uint resourceRva = peHeader.GetRva(0x0E10, mcKey.ReadUInt32(0x00A0));
			int resourceSize = (int)(peHeader.ReadUInt32(0x0E14) ^ mcKey.ReadUInt32(0x00AA));
			if (decryptedResources == 1) {
				Logger.v("Resources have already been decrypted");
				return;
			}
			if (resourceRva == 0 || resourceSize <= 0)
				return;
			if (resourceRva != (uint)peImage.Cor20Header.Resources.VirtualAddress ||
				resourceSize != peImage.Cor20Header.Resources.Size) {
				Logger.w("Invalid resource RVA and size found");
			}

			Logger.v("Decrypting resources @ RVA {0:X8}, {1} bytes", resourceRva, resourceSize);

			int resourceOffset = (int)peImage.RvaToOffset(resourceRva);
			for (int i = 0; i < resourceSize; i++)
				fileData[resourceOffset + i] ^= mcKey[i % 0x2000];
		}

		void DecryptStrings() {
			var peHeader = decrypterInfo.peHeader;
			var mcKey = decrypterInfo.mcKey;
			var peImage = decrypterInfo.peImage;
			var fileData = decrypterInfo.fileData;

			uint usHeapRva = peHeader.GetRva(0x0E00, mcKey.ReadUInt32(0x0078));
			uint usHeapSize = peHeader.ReadUInt32(0x0E04) ^ mcKey.ReadUInt32(0x0082);
			if (usHeapRva == 0 || usHeapSize == 0)
				return;
			var usHeap = peImage.Metadata.USStream;
			if (usHeap.StartOffset == 0 ||	// Start offset is 0 if it's not present in the file
				peImage.RvaToOffset(usHeapRva) != (uint)usHeap.StartOffset ||
				usHeapSize != (uint)(usHeap.EndOffset - usHeap.StartOffset)) {
				Logger.w("Invalid #US heap RVA and size found");
			}

			Logger.v("Decrypting strings @ RVA {0:X8}, {1} bytes", usHeapRva, usHeapSize);
			Logger.Instance.Indent();

			int mcKeyOffset = 0;
			int usHeapOffset = (int)peImage.RvaToOffset(usHeapRva);
			int usHeapEnd = usHeapOffset + (int)usHeapSize;
			usHeapOffset++;
			while (usHeapOffset < usHeapEnd) {
				if (fileData[usHeapOffset] == 0 || fileData[usHeapOffset] == 1) {
					usHeapOffset++;
					continue;
				}

				int usHeapOffsetOrig = usHeapOffset;
				int stringDataLength = DeobUtils.ReadVariableLengthInt32(fileData, ref usHeapOffset);
				int usHeapOffsetString = usHeapOffset;
				int encryptedLength = stringDataLength - (usHeapOffset - usHeapOffsetOrig == 1 ? 1 : 2);
				for (int i = 0; i < encryptedLength; i++) {
					byte k = mcKey.ReadByte(mcKeyOffset++ % 0x2000);
					fileData[usHeapOffset] = Rolb((byte)(fileData[usHeapOffset] ^ k), 3);
					usHeapOffset++;
				}

				try {
					Logger.v("Decrypted string: {0}", Utils.ToCsharpString(Encoding.Unicode.GetString(fileData, usHeapOffsetString, stringDataLength - 1)));
				}
				catch {
					Logger.v("Could not decrypt string at offset {0:X8}", usHeapOffsetOrig);
				}

				usHeapOffset++;
			}

			Logger.Instance.DeIndent();
		}

		byte Rolb(byte b, int n) => (byte)((b << n) | (b >> (8 - n)));
	}
}



================================================
File: de4dot.code/deobfuscators/MaxtoCode/PeHeader.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using dnlib.PE;

namespace de4dot.code.deobfuscators.MaxtoCode {
	enum EncryptionVersion {
		Unknown,
		V1,
		V2,
		V3,
		V4,
		V5,
		V6,
		V7,
		V8,
	}

	class PeHeader {
		EncryptionVersion version;
		byte[] headerData;
		uint xorKey;

		public EncryptionVersion EncryptionVersion => version;

		public PeHeader(MainType mainType, MyPEImage peImage) {
			version = GetHeaderOffsetAndVersion(peImage, out uint headerOffset);
			headerData = peImage.OffsetReadBytes(headerOffset, 0x1000);

			switch (version) {
			case EncryptionVersion.V1:
			case EncryptionVersion.V2:
			case EncryptionVersion.V3:
			case EncryptionVersion.V4:
			case EncryptionVersion.V5:
			default:
				xorKey = 0x7ABF931;
				break;

			case EncryptionVersion.V6:
				xorKey = 0x7ABA931;
				break;

			case EncryptionVersion.V7:
				xorKey = 0x8ABA931;
				break;

			case EncryptionVersion.V8:
				if (CheckMcKeyRva(peImage, 0x99BA9A13))
					break;
				if (CheckMcKeyRva(peImage, 0x18ABA931))
					break;
				if (CheckMcKeyRva(peImage, 0x18ABA933))
					break;
				break;
			}
		}

		bool CheckMcKeyRva(MyPEImage peImage, uint newXorKey) {
			xorKey = newXorKey;
			uint rva = GetMcKeyRva();
			return (rva & 0xFFF) == 0 && peImage.FindSection((RVA)rva) != null;
		}

		public uint GetMcKeyRva() => GetRva(0x0FFC, xorKey);
		public uint GetRva(int offset, uint xorKey) => ReadUInt32(offset) ^ xorKey;
		public uint ReadUInt32(int offset) => BitConverter.ToUInt32(headerData, offset);

		static EncryptionVersion GetHeaderOffsetAndVersion(MyPEImage peImage, out uint headerOffset) {
			headerOffset = 0;

			var version = GetVersion(peImage, headerOffset);
			if (version != EncryptionVersion.Unknown)
				return version;

			var section = peImage.FindSection(".rsrc");
			if (section != null) {
				version = GetHeaderOffsetAndVersion(section, peImage, out headerOffset);
				if (version != EncryptionVersion.Unknown)
					return version;
			}

			foreach (var section2 in peImage.Sections) {
				version = GetHeaderOffsetAndVersion(section2, peImage, out headerOffset);
				if (version != EncryptionVersion.Unknown)
					return version;
			}

			return EncryptionVersion.Unknown;
		}

		static EncryptionVersion GetHeaderOffsetAndVersion(ImageSectionHeader section, MyPEImage peImage, out uint headerOffset) {
			headerOffset = section.PointerToRawData;
			uint end = section.PointerToRawData + section.SizeOfRawData - 0x1000 + 1;
			while (headerOffset < end) {
				var version = GetVersion(peImage, headerOffset);
				if (version != EncryptionVersion.Unknown)
					return version;
				headerOffset++;
			}

			return EncryptionVersion.Unknown;
		}

		static EncryptionVersion GetVersion(MyPEImage peImage, uint headerOffset) {
			uint m1lo = peImage.OffsetReadUInt32(headerOffset + 0x900);
			uint m1hi = peImage.OffsetReadUInt32(headerOffset + 0x904);

			foreach (var info in EncryptionInfos.Rva900h) {
				if (info.MagicLo == m1lo && info.MagicHi == m1hi)
					return info.Version;
			}

			return EncryptionVersion.Unknown;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/MaxtoCode/StringDecrypter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Text;
using dnlib.DotNet;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.MaxtoCode {
	class StringDecrypter {
		DecrypterInfo decrypterInfo;
		MethodDef decryptMethod;
		string[] decryptedStrings;
		Encoding encoding;

		public MethodDef Method => decryptMethod;
		public bool Detected => decryptMethod != null;
		public StringDecrypter(DecrypterInfo decrypterInfo) => this.decrypterInfo = decrypterInfo;

		public void Find() {
			if (decrypterInfo == null)
				return;
			decryptMethod = FindDecryptMethod(decrypterInfo.mainType.Type);
			if (decryptMethod == null)
				return;
		}

		static MethodDef FindDecryptMethod(TypeDef type) {
			if (type == null)
				return null;
			foreach (var method in type.Methods) {
				if (method.Body == null || !method.IsStatic || method.IsPrivate)
					continue;
				if (!DotNetUtils.IsMethod(method, "System.String", "(System.UInt32)"))
					continue;
				if (!DotNetUtils.CallsMethod(method, "System.String System.Runtime.InteropServices.Marshal::PtrToStringAnsi(System.IntPtr)"))
					continue;

				return method;
			}
			return null;
		}

		public void Initialize(Encoding encoding) => this.encoding = encoding;

		void InitializeStrings() {
			if (decryptedStrings != null)
				return;
			var peImage = decrypterInfo.peImage;
			var peHeader = decrypterInfo.peHeader;
			var mcKey = decrypterInfo.mcKey;
			var fileData = decrypterInfo.fileData;

			var stringsRva = peHeader.GetRva(0x0AF0, mcKey.ReadUInt32(0x46));
			if (stringsRva == 0)
				return;
			int stringsOffset = (int)peImage.RvaToOffset(stringsRva);

			int numStrings = peImage.ReadInt32(stringsRva) ^ (int)mcKey.ReadUInt32(0);
			decryptedStrings = new string[numStrings];
			for (int i = 0, ki = 2, soffs = stringsOffset + 4; i < numStrings; i++) {
				int stringLen = BitConverter.ToInt32(fileData, soffs) ^ (int)mcKey.ReadUInt32(ki);
				ki += 2;
				if (ki >= 0x1FF0)
					ki = 0;
				soffs += 4;
				var bytes = new byte[stringLen];
				for (int j = 0; j < stringLen; j++, soffs++) {
					byte b = (byte)(fileData[soffs] ^ mcKey.ReadByte(ki));
					ki = Add(ki, 1);
					bytes[j] = b;
				}

				decryptedStrings[i] = Decode(bytes);
			}
		}

		string Decode(byte[] bytes) {
			string s = encoding.GetString(bytes);
			int len = s.Length;
			if (len == 0 || s[len - 1] != 0)
				return s;
			for (; len > 0; len--) {
				if (s[len - 1] != 0)
					break;
			}
			if (len <= 0)
				return string.Empty;
			return s.Substring(0, len);
		}

		static int Add(int ki, int size) => (ki + size) % 0x1FF0;

		public string Decrypt(uint id) {
			InitializeStrings();
			return decryptedStrings[(int)id - 1];
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Rummage/Deobfuscator.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Rummage {
	public class DeobfuscatorInfo : DeobfuscatorInfoBase {
		public const string THE_NAME = "Rummage";
		public const string THE_TYPE = "rm";
		const string DEFAULT_REGEX = @"!.";

		public DeobfuscatorInfo()
			: base(DEFAULT_REGEX) {
		}

		public override string Name => THE_NAME;
		public override string Type => THE_TYPE;

		public override IDeobfuscator CreateDeobfuscator() =>
			new Deobfuscator(new Deobfuscator.Options {
				ValidNameRegex = validNameRegex.Get(),
			});
	}

	class Deobfuscator : DeobfuscatorBase {
		string obfuscatorName = DeobfuscatorInfo.THE_NAME;
		StringDecrypter stringDecrypter;

		internal class Options : OptionsBase {
		}

		public override string Type => DeobfuscatorInfo.THE_TYPE;
		public override string TypeLong => DeobfuscatorInfo.THE_NAME;
		public override string Name => obfuscatorName;

		public Deobfuscator(Options options)
			: base(options) {
		}

		protected override int DetectInternal() {
			int val = 0;

			int sum = ToInt32(stringDecrypter.Detected);
			if (sum > 0)
				val += 100 + 10 * (sum - 1);

			return val;
		}

		protected override void ScanForObfuscator() {
			stringDecrypter = new StringDecrypter(module);
			stringDecrypter.Find();
			DetectVersion();
		}

		void DetectVersion() {
			string version;
			switch (stringDecrypter.Version) {
			case RummageVersion.V1_1_445: version = "v1.1 - v2.0"; break;
			case RummageVersion.V2_1_729: version = "v2.1+"; break;
			default: version = null; break;
			}
			if (version != null)
				obfuscatorName += " " + version;
		}

		public override void DeobfuscateBegin() {
			base.DeobfuscateBegin();

			stringDecrypter.Initialize();
		}


		public override void DeobfuscateMethodEnd(Blocks blocks) {
			if (CanRemoveStringDecrypterType)
				stringDecrypter.Deobfuscate(blocks);
			base.DeobfuscateMethodEnd(blocks);
		}

		public override void DeobfuscateEnd() {
			if (CanRemoveStringDecrypterType) {
				AddTypeToBeRemoved(stringDecrypter.Type, "String decrypter type");
				AddTypesToBeRemoved(stringDecrypter.OtherTypes, "Decrypted string type");
			}
			base.DeobfuscateEnd();
		}

		public override IEnumerable<int> GetStringDecrypterMethods() => new List<int>();
	}
}



================================================
File: de4dot.code/deobfuscators/Rummage/RummageVersion.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

namespace de4dot.code.deobfuscators.Rummage {
	enum RummageVersion {
		Unknown,
		V1_1_445,	// 1.1.445.2781 - 2.0.640.3707
		V2_1_729,	// 2.1.729.3909 - 3.1.1016.4804
	}
}



================================================
File: de4dot.code/deobfuscators/Rummage/StringDecrypter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Rummage {
	class StringDecrypter {
		ModuleDefMD module;
		FieldDefAndDeclaringTypeDict<StringInfo> stringInfos = new FieldDefAndDeclaringTypeDict<StringInfo>();
		IDecrypter decrypter;

		interface IDecrypter {
			RummageVersion Version { get; }
			MethodDef Method { get; }
			void Initialize();
			string Decrypt(int stringId);
		}

		abstract class DecrypterBaseV11 : IDecrypter {
			RummageVersion version;
			MethodDef decrypterMethod;
			protected int fileDispl;
			protected BinaryReader reader;
			protected uint[] key;

			public RummageVersion Version => version;
			public MethodDef Method => decrypterMethod;

			protected DecrypterBaseV11(RummageVersion version, MethodDef decrypterMethod, int fileDispl) {
				this.version = version;
				this.decrypterMethod = decrypterMethod;
				this.fileDispl = fileDispl;
			}

			public void Initialize() {
				reader = new BinaryReader(new FileStream(decrypterMethod.DeclaringType.Module.Location, FileMode.Open, FileAccess.Read, FileShare.Read));
				InitializeImpl();
			}

			protected abstract void InitializeImpl();

			protected static MethodDef FindDecrypterMethod(TypeDef type) {
				MethodDef cctor = null, decrypterMethod = null;
				foreach (var method in type.Methods) {
					if (!method.IsStatic || method.Body == null)
						return null;
					if (method.Name == ".cctor")
						cctor = method;
					else if (DotNetUtils.IsMethod(method, "System.String", "(System.Int32)"))
						decrypterMethod = method;
					else
						return null;
				}
				if (cctor == null || decrypterMethod == null)
					return null;

				return decrypterMethod;
			}

			public abstract string Decrypt(int stringId);

			protected string DecryptInternal(int stringId) {
				uint v0 = reader.ReadUInt32();
				uint v1 = reader.ReadUInt32();
				DeobUtils.XteaDecrypt(ref v0, ref v1, key, 32);
				int utf8Length = (int)v0;
				var decrypted = new uint[(utf8Length + 11) / 8 * 2 - 1];
				decrypted[0] = v1;
				for (int i = 1; i + 1 < decrypted.Length; i += 2) {
					v0 = reader.ReadUInt32();
					v1 = reader.ReadUInt32();
					DeobUtils.XteaDecrypt(ref v0, ref v1, key, 32);
					decrypted[i] = v0;
					decrypted[i + 1] = v1;
				}

				var utf8 = new byte[utf8Length];
				Buffer.BlockCopy(decrypted, 0, utf8, 0, utf8.Length);
				return Encoding.UTF8.GetString(utf8);
			}
		}

		class DecrypterV11 : DecrypterBaseV11 {
			DecrypterV11(MethodDef decrypterMethod, int fileDispl)
				: base(RummageVersion.V1_1_445, decrypterMethod, fileDispl) {
			}

			public static DecrypterV11 Create(MethodDef cctor) {
				var method = CheckType(cctor);
				if (method == null)
					return null;
				if (!GetDispl(method, out int fileDispl))
					return null;

				return new DecrypterV11(method, fileDispl);
			}

			static readonly string[] requiredFields = new string[] {
				"System.UInt32[]",
			};
			static readonly string[] requiredLocals = new string[] {
				"System.Byte[]",
				"System.Int32",
				"System.IO.FileStream",
			};
			static MethodDef CheckType(MethodDef cctor) {
				var type = cctor.DeclaringType;
				if (!new FieldTypes(type).Exactly(requiredFields))
					return null;
				if (!new LocalTypes(cctor).All(requiredLocals))
					return null;

				return FindDecrypterMethod(type);
			}

			static bool GetDispl(MethodDef method, out int displ) {
				var instrs = method.Body.Instructions;
				for (int i = 0; i < instrs.Count - 2; i++) {
					var mul = instrs[i];
					if (mul.OpCode.Code != Code.Mul)
						continue;

					var ldci4 = instrs[i + 1];
					if (!ldci4.IsLdcI4())
						continue;

					var sub = instrs[i + 2];
					if (sub.OpCode.Code != Code.Sub)
						continue;

					displ = ldci4.GetLdcI4Value();
					return true;
				}

				displ = 0;
				return false;
			}

			protected override void InitializeImpl() => InitKey();

			void InitKey() {
				reader.BaseStream.Position = reader.BaseStream.Length - 48;
				key = new uint[4];
				for (int i = 0; i < key.Length; i++)
					key[i] = reader.ReadUInt32();
			}

			public override string Decrypt(int stringId) {
				reader.BaseStream.Position = reader.BaseStream.Length + (stringId * 4 - fileDispl);
				return DecryptInternal(stringId);
			}
		}

		class DecrypterV21 : DecrypterBaseV11 {
			long baseOffs;

			public DecrypterV21(MethodDef decrypterMethod, int fileDispl)
				: base(RummageVersion.V2_1_729, decrypterMethod, fileDispl) {
			}

			public static DecrypterV21 Create(MethodDef cctor) {
				var method = CheckType(cctor);
				if (method == null)
					return null;
				if (!GetDispl(method, out int fileDispl))
					return null;

				return new DecrypterV21(method, fileDispl);
			}

			static readonly string[] requiredFields = new string[] {
				"System.UInt32[]",
				"System.Int64",
			};
			static readonly string[] requiredLocals = new string[] {
				"System.Byte[]",
				"System.Int32",
				"System.IO.FileStream",
			};
			static MethodDef CheckType(MethodDef cctor) {
				var type = cctor.DeclaringType;
				if (!new FieldTypes(type).Exactly(requiredFields))
					return null;
				if (!new LocalTypes(cctor).All(requiredLocals))
					return null;

				return FindDecrypterMethod(type);
			}

			static bool GetDispl(MethodDef method, out int displ) {
				var instrs = method.Body.Instructions;
				for (int i = 0; i < instrs.Count - 6; i++) {
					var ldci4_1 = instrs[i];
					if (!ldci4_1.IsLdcI4() || ldci4_1.GetLdcI4Value() != 4)
						continue;
					if (instrs[i + 1].OpCode.Code != Code.Mul)
						continue;
					if (instrs[i + 2].OpCode.Code != Code.Conv_I8)
						continue;
					if (instrs[i + 3].OpCode.Code != Code.Add)
						continue;

					var ldci4 = instrs[i + 4];
					if (!ldci4.IsLdcI4())
						continue;

					if (instrs[i + 5].OpCode.Code != Code.Conv_I8)
						continue;
					if (instrs[i + 6].OpCode.Code != Code.Sub)
						continue;

					displ = ldci4.GetLdcI4Value();
					return true;
				}

				displ = 0;
				return false;
			}

			static readonly byte[] magic = new byte[32] {
				0xC9, 0x76, 0xC3, 0x0D, 0xE2, 0x83, 0x72, 0xE4,
				0xD5, 0xC7, 0x35, 0xF8, 0x86, 0xD0, 0x60, 0x69,
				0xEE, 0xE1, 0x4C, 0x5E, 0x07, 0xA1, 0xC1, 0xFE,
				0x61, 0xE3, 0xAA, 0xBC, 0xE4, 0xB1, 0xF0, 0x92,
			};

			protected override void InitializeImpl() {
				baseOffs = InitializeBaseOffs();
				InitKey();
			}

			void InitKey() {
				reader.BaseStream.Position = baseOffs - 16;
				key = new uint[4];
				for (int i = 0; i < key.Length; i++)
					key[i] = reader.ReadUInt32();
			}

			long InitializeBaseOffs() {
				byte[] buf = new byte[0x1000];	// Must be 4096 bytes
				reader.BaseStream.Position = reader.BaseStream.Length - buf.Length;
				while (true) {
					if (reader.Read(buf, 0, buf.Length) != buf.Length)
						throw new ApplicationException("Could not read");

					for (int bi = buf.Length - 1; bi > magic.Length; ) {
						int mi = magic.Length - 1;
						if (buf[bi--] != magic[mi--] ||
							buf[bi] != magic[mi--])
							continue;
						while (true) {
							if (buf[--bi] != magic[mi--])
								break;
							if (mi == -1)
								return reader.BaseStream.Position - buf.Length + bi;
						}
					}

					reader.BaseStream.Position -= buf.Length * 2 - 0x20;
				}
			}

			public override string Decrypt(int stringId) {
				reader.BaseStream.Position = baseOffs + stringId * 4 - fileDispl;
				return DecryptInternal(stringId);
			}
		}

		class StringInfo {
			public readonly FieldDef field;
			public readonly int stringId;
			public string decrypted;

			public StringInfo(FieldDef field, int stringId) {
				this.field = field;
				this.stringId = stringId;
			}

			public override string ToString() {
				if (decrypted != null)
					return $"{stringId:X8} - {Utils.ToCsharpString(decrypted)}";
				return $"{stringId:X8}";
			}
		}

		public RummageVersion Version => decrypter == null ? RummageVersion.Unknown : decrypter.Version;
		public TypeDef Type => decrypter?.Method.DeclaringType;

		public IEnumerable<TypeDef> OtherTypes {
			get {
				var list = new List<TypeDef>(stringInfos.Count);
				foreach (var info in stringInfos.GetValues())
					list.Add(info.field.DeclaringType);
				return list;
			}
		}

		public bool Detected => decrypter != null;
		public StringDecrypter(ModuleDefMD module) => this.module = module;

		public void Find() {
			foreach (var type in module.GetTypes()) {
				var cctor = type.FindStaticConstructor();
				if (cctor == null)
					continue;

				decrypter = DecrypterV11.Create(cctor);
				if (decrypter != null)
					break;

				decrypter = DecrypterV21.Create(cctor);
				if (decrypter != null)
					break;
			}
		}

		public void Initialize() {
			if (decrypter == null)
				return;

			decrypter.Initialize();
			foreach (var type in module.Types)
				InitType(type);
		}

		void InitType(TypeDef type) {
			var cctor = type.FindStaticConstructor();
			if (cctor == null)
				return;
			var info = GetStringInfo(cctor);
			if (info == null)
				return;

			stringInfos.Add(info.field, info);
		}

		StringInfo GetStringInfo(MethodDef method) {
			if (method == null || method.Body == null)
				return null;
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 2; i++) {
				var ldci4 = instrs[i];
				if (!ldci4.IsLdcI4())
					continue;
				int stringId = ldci4.GetLdcI4Value();

				var call = instrs[i + 1];
				if (call.OpCode.Code != Code.Call)
					continue;
				var calledMethod = call.Operand as IMethod;
				if (!MethodEqualityComparer.CompareDeclaringTypes.Equals(decrypter.Method, calledMethod))
					continue;

				var stsfld = instrs[i + 2];
				if (stsfld.OpCode.Code != Code.Stsfld)
					continue;
				var field = stsfld.Operand as FieldDef;
				if (field == null)
					continue;

				return new StringInfo(field, stringId);
			}

			return null;
		}

		public void Deobfuscate(Blocks blocks) {
			if (decrypter == null)
				return;
			foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {
				var instrs = block.Instructions;
				for (int i = 0; i < instrs.Count; i++) {
					var instr = instrs[i];

					if (instr.OpCode.Code != Code.Ldsfld)
						continue;

					var field = instr.Operand as IField;
					if (field == null)
						continue;
					var info = stringInfos.Find(field);
					if (info == null)
						continue;
					var decrypted = Decrypt(info);

					instrs[i] = new Instr(OpCodes.Ldstr.ToInstruction(decrypted));
					Logger.v("Decrypted string: {0}", Utils.ToCsharpString(decrypted));
				}
			}
		}

		string Decrypt(StringInfo info) {
			if (info.decrypted == null)
				info.decrypted = decrypter.Decrypt(info.stringId);

			return info.decrypted;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Skater_NET/Deobfuscator.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Skater_NET {
	public class DeobfuscatorInfo : DeobfuscatorInfoBase {
		public const string THE_NAME = "Skater .NET";
		public const string THE_TYPE = "sk";
		const string DEFAULT_REGEX = @"!`[^0-9]+&" + DeobfuscatorBase.DEFAULT_ASIAN_VALID_NAME_REGEX;

		public DeobfuscatorInfo()
			: base(DEFAULT_REGEX) {
		}

		public override string Name => THE_NAME;
		public override string Type => THE_TYPE;

		public override IDeobfuscator CreateDeobfuscator() =>
			new Deobfuscator(new Deobfuscator.Options {
				ValidNameRegex = validNameRegex.Get(),
			});
	}

	class Deobfuscator : DeobfuscatorBase {
		StringDecrypter stringDecrypter;
		EnumClassFinder enumClassFinder;

		internal class Options : OptionsBase {
		}

		public override string Type => DeobfuscatorInfo.THE_TYPE;
		public override string TypeLong => DeobfuscatorInfo.THE_NAME;
		public override string Name => DeobfuscatorInfo.THE_NAME;
		public Deobfuscator(Options options) : base(options) => StringFeatures = StringFeatures.AllowNoDecryption | StringFeatures.AllowStaticDecryption;

		protected override int DetectInternal() {
			int val = 0;

			if (stringDecrypter.Detected)
				val += 100;

			return val;
		}

		protected override void ScanForObfuscator() {
			stringDecrypter = new StringDecrypter(module);

			if (HasAssemblyRef("Microsoft.VisualBasic"))
				stringDecrypter.Find();
		}

		bool HasAssemblyRef(string name) {
			foreach (var asmRef in module.GetAssemblyRefs()) {
				if (asmRef.Name == name)
					return true;
			}
			return false;
		}

		public override void DeobfuscateBegin() {
			base.DeobfuscateBegin();

			enumClassFinder = new EnumClassFinder(module);

			stringDecrypter.Initialize(DeobfuscatedFile);
		}

		public override void DeobfuscateMethodEnd(Blocks blocks) {
			if (CanRemoveStringDecrypterType)
				stringDecrypter.Deobfuscate(blocks);
			enumClassFinder.Deobfuscate(blocks);
			base.DeobfuscateMethodEnd(blocks);
		}

		public override void DeobfuscateEnd() {
			if (Operations.DecryptStrings != OpDecryptString.None && stringDecrypter.CanRemoveType)
				AddTypeToBeRemoved(stringDecrypter.Type, "String decrypter type");
			FixEnumTypes();

			base.DeobfuscateEnd();
		}

		public override IEnumerable<int> GetStringDecrypterMethods() {
			var list = new List<int>();
			return list;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Skater_NET/EnumClassFinder.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Skater_NET {
	class EnumClassFinder {
		ModuleDefMD module;
		FieldDef enumField;

		public EnumClassFinder(ModuleDefMD module) {
			this.module = module;
			Find();
		}

		void Find() {
			foreach (var type in module.Types) {
				if (type.HasEvents || type.HasProperties)
					continue;
				if (type.Methods.Count != 1)
					continue;
				if (type.Fields.Count != 1)
					continue;
				var method = type.Methods[0];
				if (method.Name != ".ctor")
					continue;
				var field = type.Fields[0];
				var fieldType = DotNetUtils.GetType(module, field.FieldSig.GetFieldType());
				if (fieldType == null)
					continue;
				if (!fieldType.IsEnum)
					continue;
				enumField = field;
				return;
			}
		}

		public void Deobfuscate(Blocks blocks) {
			foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {
				var instrs = block.Instructions;
				for (int i = 0; i < instrs.Count - 2; i++) {
					var ldsfld = instrs[i];
					if (ldsfld.OpCode.Code != Code.Ldsfld)
						continue;

					var ldci4 = instrs[i + 1];
					if (!ldci4.IsLdcI4())
						continue;

					var stfld = instrs[i + 2];
					if (stfld.OpCode.Code != Code.Stfld)
						continue;

					var field = stfld.Operand as IField;
					if (!FieldEqualityComparer.CompareDeclaringTypes.Equals(enumField, field))
						continue;
					block.Remove(i, 3);
					i--;
				}
			}
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Skater_NET/StringDecrypter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Skater_NET {
	class StringDecrypter {
		ModuleDefMD module;
		TypeDef decrypterType;
		MethodDef decrypterCctor;
		FieldDefAndDeclaringTypeDict<string> fieldToDecryptedString = new FieldDefAndDeclaringTypeDict<string>();
		bool canRemoveType;
		IDecrypter decrypter;

		interface IDecrypter {
			string Decrypt(string encrypted);
		}

		class DecrypterV1 : IDecrypter {
			byte[] key;
			byte[] iv;

			public DecrypterV1(byte[] key, byte[] iv) {
				this.key = key;
				this.iv = iv;
			}

			public string Decrypt(string encrypted) {
				try {
					return Encoding.Unicode.GetString(DeobUtils.Des3Decrypt(Convert.FromBase64String(encrypted), key, iv));
				}
				catch (FormatException) {
					return "";
				}
			}
		}

		class DecrypterV2 : IDecrypter {
			public string Decrypt(string encrypted) {
				var ints = encrypted.Split(' ');
				if (ints.Length % 3 != 0)
					throw new ApplicationException("Invalid encrypted string");
				var sb = new StringBuilder(ints.Length / 3);
				for (int i = 0; i < ints.Length; i += 3) {
					int val1 = int.Parse(ints[i]);
					int val2 = int.Parse(ints[i + 1]);
					if ((double)val2 / 2.0 == Math.Round((double)val2 / 2.0))
						val1 += val1;
					sb.Append((char)val1);
				}
				return sb.ToString();
			}
		}

		public bool Detected => decrypterType != null;
		public bool CanRemoveType => canRemoveType;
		public TypeDef Type => decrypterType;
		public StringDecrypter(ModuleDefMD module) => this.module = module;

		public void Find() {
			foreach (var type in module.Types) {
				if (type.HasProperties || type.HasEvents)
					continue;

				var cctor = type.FindStaticConstructor();
				if (cctor == null)
					continue;

				if (CheckType(type)) {
					canRemoveType = true;
					decrypterType = type;
					decrypterCctor = cctor;
					return;
				}
			}
		}

		public void Initialize(ISimpleDeobfuscator deobfuscator) {
			if (decrypterCctor == null)
				return;

			deobfuscator.Deobfuscate(decrypterCctor);
			var instrs = decrypterCctor.Body.Instructions;
			for (int i = 0; i < instrs.Count - 4; i++) {
				var ldstr = instrs[i];
				if (ldstr.OpCode.Code != Code.Ldstr)
					continue;
				var encryptedString = ldstr.Operand as string;
				if (encryptedString == null)
					continue;
				if (instrs[i + 1].OpCode.Code != Code.Stsfld)
					continue;
				if (instrs[i + 2].OpCode.Code != Code.Ldsfld)
					continue;
				if (instrs[i + 3].OpCode.Code != Code.Call)
					continue;
				if (instrs[i + 4].OpCode.Code != Code.Stsfld)
					continue;
				var field = instrs[i + 4].Operand as FieldDef;
				if (field == null)
					continue;
				if (!new SigComparer().Equals(field.DeclaringType, decrypterType))
					continue;

				fieldToDecryptedString.Add(field, decrypter.Decrypt(encryptedString));
			}
		}

		bool CheckType(TypeDef type) {
			foreach (var method in type.Methods) {
				if (!method.IsStatic || method.Body == null)
					continue;
				if (!DotNetUtils.IsMethod(method, "System.String", "(System.String)"))
					continue;

				if (CheckMethodV1(method))
					return true;
				if (CheckMethodV2(method))
					return true;
			}

			return false;
		}

		bool CheckMethodV1(MethodDef method) {
			var salt = GetSalt(method);
			if (salt == null)
				return false;

			var password = GetPassword(method);
			if (string.IsNullOrEmpty(password))
				return false;

			var passwordBytes = new PasswordDeriveBytes(password, salt);
			var key = passwordBytes.GetBytes(16);
			var iv = passwordBytes.GetBytes(8);
			decrypter = new DecrypterV1(key, iv);
			return true;
		}

		static string[] callsMethodsV2 = new string[] {
			"System.String[] System.String::Split(System.Char[])",
			"System.Int32 System.Array::GetUpperBound(System.Int32)",
			"System.String Microsoft.VisualBasic.CompilerServices.Conversions::ToString(System.Char)",
			"System.Int32 Microsoft.VisualBasic.CompilerServices.Conversions::ToInteger(System.String)",
			"System.String System.String::Concat(System.String,System.String)",
			"System.Char Microsoft.VisualBasic.Strings::Chr(System.Int32)",
		};
		bool CheckMethodV2(MethodDef method) {
			if (!DeobUtils.HasInteger(method, ' '))
				return false;
			foreach (var calledMethodName in callsMethodsV2) {
				if (!DotNetUtils.CallsMethod(method, calledMethodName))
					return false;
			}

			decrypter = new DecrypterV2();
			return true;
		}

		static byte[] GetSalt(MethodDef method) {
			foreach (var s in DotNetUtils.GetCodeStrings(method)) {
				var saltAry = FixSalt(s);
				if (saltAry != null)
					return saltAry;
			}

			return null;
		}

		static byte[] FixSalt(string s) {
			if (s.Length < 10 || s.Length > 30 || s.Length / 2 * 2 != s.Length)
				return null;

			var ary = s.ToCharArray();
			Array.Reverse(ary);
			for (int i = 0; i < ary.Length; i++)
				ary[i]--;
			var s2 = new string(ary);

			var saltAry = new byte[(int)Math.Round((double)s2.Length / 2 - 1) + 1];
			for (int i = 0; i < saltAry.Length; i++) {
				if (!int.TryParse(s2.Substring(i * 2, 2), NumberStyles.AllowHexSpecifier, null, out int result))
					return null;
				saltAry[i] = (byte)result;
			}

			return saltAry;
		}

		string GetPassword(MethodDef decryptMethod) {
			foreach (var method in DotNetUtils.GetCalledMethods(module, decryptMethod)) {
				if (!method.IsStatic || method.Body == null)
					continue;
				if (!new SigComparer().Equals(method.DeclaringType, decryptMethod.DeclaringType))
					continue;
				if (!DotNetUtils.IsMethod(method, "System.String", "()"))
					continue;

				var hexChars = GetPassword2(method);
				if (string.IsNullOrEmpty(hexChars))
					continue;

				var password = FixPassword(hexChars);
				if (string.IsNullOrEmpty(password))
					continue;

				return password;
			}
			return null;
		}

		string FixPassword(string hexChars) {
			var ary = hexChars.Trim().Split(' ');
			string password = "";
			for (int i = 0; i < ary.Length; i++) {
				if (!int.TryParse(ary[i], NumberStyles.AllowHexSpecifier, null, out int result))
					return null;
				password += (char)result;
			}
			return password;
		}

		string GetPassword2(MethodDef method) {
			string password = "";
			foreach (var calledMethod in DotNetUtils.GetCalledMethods(module, method)) {
				var s = GetPassword3(calledMethod);
				if (string.IsNullOrEmpty(s))
					return null;

				password += s;
			}
			return password;
		}

		string GetPassword3(MethodDef method) {
			var strings = new List<string>(DotNetUtils.GetCodeStrings(method));
			if (strings.Count != 1)
				return null;

			var s = strings[0];
			if (!Regex.IsMatch(s, @"^[a-fA-F0-9]{2} $"))
				return null;

			return s;
		}

		public void Deobfuscate(Blocks blocks) {
			foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {
				var instrs = block.Instructions;
				for (int i = 0; i < instrs.Count; i++) {
					var instr = instrs[i];

					if (instr.OpCode.Code == Code.Call || instr.OpCode.Code == Code.Callvirt) {
						if (blocks.Method.DeclaringType == decrypterType)
							continue;
						if (instr.Operand is IMethod calledMethod && calledMethod.DeclaringType == decrypterType)
							canRemoveType = false;
					}
					else if (instr.OpCode.Code == Code.Ldsfld) {
						if (instr.OpCode.Code != Code.Ldsfld)
							continue;
						var field = instr.Operand as IField;
						if (field == null)
							continue;
						var decrypted = fieldToDecryptedString.Find(field);
						if (decrypted == null)
							continue;

						instrs[i] = new Instr(OpCodes.Ldstr.ToInstruction(decrypted));
						Logger.v("Decrypted string: {0}", Utils.ToCsharpString(decrypted));
					}
				}
			}
		}
	}
}



================================================
File: de4dot.code/deobfuscators/SmartAssembly/AssemblyResolver.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet;

namespace de4dot.code.deobfuscators.SmartAssembly {
	class AssemblyResolver {
		ResourceDecrypter resourceDecrypter;
		AssemblyResolverInfo assemblyResolverInfo;

		public AssemblyResolver(ResourceDecrypter resourceDecrypter, AssemblyResolverInfo assemblyResolverInfo) {
			this.resourceDecrypter = resourceDecrypter;
			this.assemblyResolverInfo = assemblyResolverInfo;
		}

		public bool ResolveResources() => assemblyResolverInfo.ResolveResources();

		public bool CanDecryptResource(EmbeddedAssemblyInfo info) {
			if (info == null || !info.isCompressed)
				return true;
			return resourceDecrypter.CanDecrypt;
		}

		public IEnumerable<Tuple<EmbeddedAssemblyInfo, byte[]>> GetDecryptedResources() {
			var returned = new Dictionary<Resource, bool>();
			foreach (var info in assemblyResolverInfo.EmbeddedAssemblyInfos) {
				if (info.resource == null) {
					Logger.w("Could not find embedded resource {0}", Utils.ToCsharpString(info.resourceName));
					continue;
				}
				if (returned.ContainsKey(info.resource))
					continue;
				returned[info.resource] = true;

				yield return new Tuple<EmbeddedAssemblyInfo, byte[]> {
					Item1 = info,
					Item2 = DecryptResource(info),
				};
			}
		}

		public byte[] RemoveDecryptedResource(EmbeddedAssemblyInfo info) {
			if (info == null)
				return null;

			var data = DecryptResource(info);
			if (!assemblyResolverInfo.RemoveEmbeddedAssemblyInfo(info))
				throw new ApplicationException($"Could not remove resource {Utils.ToCsharpString(info.resourceName)}");
			return data;
		}

		byte[] DecryptResource(EmbeddedAssemblyInfo info) {
			if (info.isCompressed)
				return resourceDecrypter.Decrypt(info.resource);
			else
				return info.resource.CreateReader().ToArray();
		}
	}
}



================================================
File: de4dot.code/deobfuscators/SmartAssembly/AssemblyResolverInfo.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Text;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.SmartAssembly {
	public class EmbeddedAssemblyInfo {
		public string assemblyName;
		public string simpleName;
		public string resourceName;
		public EmbeddedResource resource;
		public bool isCompressed = false;
		public bool isTempFile = false;
		public string flags = "";

		public override string ToString() => assemblyName ?? base.ToString();

		public static EmbeddedAssemblyInfo Create(ModuleDefMD module, string encName, string rsrcName) {
			var info = new EmbeddedAssemblyInfo();

			try {
				if (encName == "" || Convert.ToBase64String(Convert.FromBase64String(encName)) != encName)
					return null;
			}
			catch (FormatException) {
				return null;
			}

			if (rsrcName.Length > 0 && rsrcName[0] == '[') {
				int i = rsrcName.IndexOf(']');
				if (i < 0)
					return null;
				info.flags = rsrcName.Substring(1, i - 1);
				info.isTempFile = info.flags.IndexOf('t') >= 0;
				info.isCompressed = info.flags.IndexOf('z') >= 0;
				rsrcName = rsrcName.Substring(i + 1);
			}
			if (rsrcName == "")
				return null;

			info.assemblyName = Encoding.UTF8.GetString(Convert.FromBase64String(encName));
			info.resourceName = rsrcName;
			info.resource = DotNetUtils.GetResource(module, rsrcName) as EmbeddedResource;
			info.simpleName = Utils.GetAssemblySimpleName(info.assemblyName);

			return info;
		}
	}

	class AssemblyResolverInfo : ResolverInfoBase {
		MethodDef simpleZipTypeMethod;
		List<EmbeddedAssemblyInfo> embeddedAssemblyInfos = new List<EmbeddedAssemblyInfo>();

		public MethodDef SimpleZipTypeMethod => simpleZipTypeMethod;
		public IList<EmbeddedAssemblyInfo> EmbeddedAssemblyInfos => embeddedAssemblyInfos;

		public AssemblyResolverInfo(ModuleDefMD module, ISimpleDeobfuscator simpleDeobfuscator, IDeobfuscator deob)
			: base(module, simpleDeobfuscator, deob) {
		}

		public bool ResolveResources() {
			bool ok = true;

			foreach (var info in embeddedAssemblyInfos) {
				if (info.resource != null)
					continue;
				info.resource = DotNetUtils.GetResource(module, info.resourceName) as EmbeddedResource;
				if (info.resource == null)
					ok = false;
			}

			return ok;
		}

		protected override bool CheckResolverType(TypeDef type) {
			if (DotNetUtils.FindFieldType(type, "System.Collections.Hashtable", true) != null ||
				DotNetUtils.FindFieldType(type, "System.Collections.Generic.Dictionary`2<System.String,System.Reflection.Assembly>", true) != null)
				return true;

			foreach (var field in type.Fields) {
				if (DotNetUtils.DerivesFromDelegate(DotNetUtils.GetType(module, field.FieldType)))
					continue;
				if (field.IsLiteral && field.FieldType.ToString() == "System.String")
					continue;
				return false;
			}
			return true;
		}

		protected override bool CheckHandlerMethod(MethodDef method) {
			if (!method.IsStatic || !method.HasBody)
				return false;

			var infos = new List<EmbeddedAssemblyInfo>();
			foreach (var s in DotNetUtils.GetCodeStrings(method)) {
				if (string.IsNullOrEmpty(s))
					continue;
				if (!InitInfos(infos, s.Split(',')))
					continue;

				embeddedAssemblyInfos = infos;
				FindSimpleZipType(method);
				return true;
			}

			return false;
		}

		bool InitInfos(IList<EmbeddedAssemblyInfo> list, string[] strings) {
			list.Clear();
			if (strings.Length % 2 == 1)
				return false;

			for (int i = 0; i < strings.Length; i += 2) {
				var info = EmbeddedAssemblyInfo.Create(module, strings[i], strings[i + 1]);
				if (info == null)
					return false;
				list.Add(info);
			}

			Logger.v("Found embedded assemblies:");
			Logger.Instance.Indent();
			foreach (var info in list)
				Logger.v("{0}", info.assemblyName);
			Logger.Instance.DeIndent();

			return true;
		}

		void FindSimpleZipType(MethodDef method) {
			if (method == null || !method.HasBody)
				return;
			foreach (var call in method.Body.Instructions) {
				if (call.OpCode.Code != Code.Call)
					continue;
				var calledMethod = call.Operand as IMethod;
				if (calledMethod == null)
					continue;
				if (!SimpleZipInfo.IsSimpleZipDecryptMethod_QuickCheck(module, calledMethod, out simpleZipTypeMethod))
					continue;

				return;
			}
		}

		public EmbeddedAssemblyInfo Find(string simpleName) {
			foreach (var info in embeddedAssemblyInfos) {
				if (info.simpleName == simpleName)
					return info;
			}

			return null;
		}

		public bool RemoveEmbeddedAssemblyInfo(EmbeddedAssemblyInfo info) {
			bool removed = false;
			for (int i = 0; i < EmbeddedAssemblyInfos.Count; i++) {
				var other = EmbeddedAssemblyInfos[i];
				if (info.simpleName == other.simpleName) {
					EmbeddedAssemblyInfos.RemoveAt(i--);
					removed = true;
				}
			}
			return removed;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/SmartAssembly/AutomatedErrorReportingFinder.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.SmartAssembly {
	class AutomatedErrorReportingFinder : ExceptionLoggerRemover {
		ModuleDefMD module;
		bool enabled;

		protected override bool HasExceptionLoggers => enabled;
		public AutomatedErrorReportingFinder(ModuleDefMD module) => this.module = module;
		protected override bool IsExceptionLogger(IMethod method) => IsExceptionLoggerMethod(method);

		public void Find() {
			var entryPoint = module.EntryPoint;
			if (entryPoint == null)
				enabled = true;
			else
				enabled = CheckMethod(entryPoint, out var exceptionMethod);
		}

		bool CheckMethod(MethodDef method, out MethodDef exceptionMethod) {
			exceptionMethod = null;

			var body = method.Body;
			if (body == null)
				return false;
			var instrs = body.Instructions;
			if (instrs.Count < 1)
				return false;
			if (body.ExceptionHandlers.Count == 0)
				return false;
			var eh = body.ExceptionHandlers[body.ExceptionHandlers.Count - 1];
			if (eh.HandlerType != ExceptionHandlerType.Catch)
				return false;
			if (eh.FilterStart != null)
				return false;
			if (eh.CatchType == null || eh.CatchType.FullName != "System.Exception")
				return false;
			if (eh.HandlerStart == null)
				return false;

			int handlerStart = instrs.IndexOf(eh.HandlerStart);
			int handlerEnd = eh.HandlerEnd == null ? instrs.Count : instrs.IndexOf(eh.HandlerEnd);
			exceptionMethod = DotNetUtils.GetMethod(module, CheckHandler(instrs, handlerStart, handlerEnd));
			if (exceptionMethod == null || !exceptionMethod.IsStatic || exceptionMethod.Body == null)
				return false;

			return IsExceptionLoggerMethod(exceptionMethod);
		}

		IMethod CheckHandler(IList<Instruction> instrs, int start, int end) {
			IMethod calledMethod = null;
			for (int i = start; i < end; i++) {
				var instr = instrs[i];
				if (instr.OpCode.Code == Code.Call || instr.OpCode.Code == Code.Callvirt) {
					if (calledMethod != null)
						return null;
					var method = instr.Operand as IMethod;
					if (method == null)
						return null;
					calledMethod = method;
				}
			}

			return calledMethod;
		}

		static bool IsExceptionLoggerMethod(IMethod method) {
			if (method.Name == ".ctor" || method.Name == ".cctor")
				return false;

			var sig = method.MethodSig;
			if (sig == null || sig.Params.Count < 1)
				return false;

			var rtype = sig.RetType.GetFullName();
			var type0 = sig.Params[0].GetFullName();
			var type1 = sig.Params.Count < 2 ? "" : sig.Params[1].GetFullName();
			int index;
			if (rtype == "System.Void") {
				if (type0 == "System.Exception" && type1 == "System.Int32")
					index = 2;
				else if (type0 == "System.Object[]" && type1 == "System.Exception")
					return true;
				else if (sig.Params.Count == 2 && type0 == "System.Int32" && type1 == "System.Object[]")
					return true;
				else if (type0 == "System.Exception")
					index = 1;
				else
					return false;
			}
			else if (rtype == "System.Exception") {
				if (type0 == "System.Exception" && type1 == "System.Int32")
					index = 2;
				else if (type0 == "System.Int32" && type1 == "System.Exception")
					index = 2;
				else if (sig.Params.Count == 2 && type0 == "System.Int32" && type1 == "System.Object[]")
					return true;
				else if (type0 == "System.Exception")
					index = 1;
				else
					return false;
			}
			else
				return false;

			if (index + 1 == sig.Params.Count && sig.Params[index].GetFullName() == "System.Object[]")
				return true;

			for (int i = index; i < sig.Params.Count; i++) {
				if (sig.Params[i].GetElementType() != ElementType.Object)
					return false;
			}

			return true;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/SmartAssembly/Deobfuscator.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.SmartAssembly {
	public class DeobfuscatorInfo : DeobfuscatorInfoBase {
		public const string THE_NAME = "SmartAssembly";
		public const string THE_TYPE = "sa";
		const string DEFAULT_REGEX = DeobfuscatorBase.DEFAULT_ASIAN_VALID_NAME_REGEX;
		BoolOption removeAutomatedErrorReporting;
		BoolOption removeTamperProtection;
		BoolOption removeMemoryManager;

		public DeobfuscatorInfo()
			: base(DEFAULT_REGEX) {
			removeAutomatedErrorReporting = new BoolOption(null, MakeArgName("error"), "Remove automated error reporting code", true);
			removeTamperProtection = new BoolOption(null, MakeArgName("tamper"), "Remove tamper protection code", true);
			removeMemoryManager = new BoolOption(null, MakeArgName("memory"), "Remove memory manager code", true);
		}

		public override string Name => THE_NAME;
		public override string Type => THE_TYPE;

		public override IDeobfuscator CreateDeobfuscator() =>
			new Deobfuscator(new Deobfuscator.Options {
				ValidNameRegex = validNameRegex.Get(),
				RemoveAutomatedErrorReporting = removeAutomatedErrorReporting.Get(),
				RemoveTamperProtection = removeTamperProtection.Get(),
				RemoveMemoryManager = removeMemoryManager.Get(),
			});

		protected override IEnumerable<Option> GetOptionsInternal() =>
			new List<Option>() {
				removeAutomatedErrorReporting,
				removeTamperProtection,
				removeMemoryManager,
			};
	}

	class Deobfuscator : DeobfuscatorBase {
		Options options;
		bool foundVersion = false;
		Version approxVersion = new Version(0, 0, 0, 0);
		bool canRemoveTypes;
		string poweredByAttributeString = null;
		string obfuscatorName = DeobfuscatorInfo.THE_NAME;
		bool foundSmartAssemblyAttribute = false;

		IList<StringDecrypterInfo> stringDecrypterInfos = new List<StringDecrypterInfo>();
		IList<StringDecrypter> stringDecrypters = new List<StringDecrypter>();
		ResourceDecrypterInfo resourceDecrypterInfo;
		ResourceDecrypter resourceDecrypter;
		AssemblyResolverInfo assemblyResolverInfo;
		AssemblyResolver assemblyResolver;
		ResourceResolverInfo resourceResolverInfo;
		ResourceResolver resourceResolver;
		MemoryManagerInfo memoryManagerInfo;

		ProxyCallFixer proxyCallFixer;
		AutomatedErrorReportingFinder automatedErrorReportingFinder;
		TamperProtectionRemover tamperProtectionRemover;

		internal class Options : OptionsBase {
			public bool RemoveAutomatedErrorReporting { get; set; }
			public bool RemoveTamperProtection { get; set; }
			public bool RemoveMemoryManager { get; set; }
		}

		public override string Type => DeobfuscatorInfo.THE_TYPE;
		public override string TypeLong => DeobfuscatorInfo.THE_NAME;
		public override string Name => obfuscatorName;

		string ObfuscatorName {
			set {
				obfuscatorName = value;
				foundVersion = true;
			}
		}

		public Deobfuscator(Options options)
			: base(options) {
			this.options = options;
			StringFeatures = StringFeatures.AllowStaticDecryption;
		}

		public override void Initialize(ModuleDefMD module) => base.Initialize(module);

		protected override int DetectInternal() {
			int val = 0;

			if (memoryManagerInfo.Detected)
				val += 100;
			if (foundSmartAssemblyAttribute)
				val += 10;

			return val;
		}

		protected override void ScanForObfuscator() {
			FindSmartAssemblyAttributes();
			memoryManagerInfo = new MemoryManagerInfo(module);
			memoryManagerInfo.Find();
			proxyCallFixer = new ProxyCallFixer(module, DeobfuscatedFile);
			proxyCallFixer.FindDelegateCreator(module);

			if (!foundVersion)
				GuessVersion();
		}

		void FindSmartAssemblyAttributes() {
			foreach (var type in module.Types) {
				if (Utils.StartsWith(type.FullName, "SmartAssembly.Attributes.PoweredByAttribute", StringComparison.Ordinal)) {
					foundSmartAssemblyAttribute = true;
					AddAttributeToBeRemoved(type, "Obfuscator attribute");
					InitializeVersion(type);
				}
			}
		}

		void InitializeVersion(TypeDef attr) {
			var s = DotNetUtils.GetCustomArgAsString(GetAssemblyAttribute(attr), 0);
			if (s == null)
				return;

			poweredByAttributeString = s;

			var val = System.Text.RegularExpressions.Regex.Match(s, @"^Powered by (SmartAssembly (\d+)\.(\d+)\.(\d+)\.(\d+))$");
			if (val.Groups.Count < 6)
				return;
			ObfuscatorName = val.Groups[1].ToString();
			approxVersion = new Version(int.Parse(val.Groups[2].ToString()),
										int.Parse(val.Groups[3].ToString()),
										int.Parse(val.Groups[4].ToString()),
										int.Parse(val.Groups[5].ToString()));
			return;
		}

		void GuessVersion() {
			if (poweredByAttributeString == "Powered by SmartAssembly") {
				ObfuscatorName = "SmartAssembly 5.0/5.1";
				approxVersion = new Version(5, 0, 0, 0);
				return;
			}

			if (poweredByAttributeString == "Powered by {smartassembly}") {
				// It's SA 1.x - 4.x

				if (proxyCallFixer.Detected || HasEmptyClassesInEveryNamespace()) {
					ObfuscatorName = "SmartAssembly 4.x";
					approxVersion = new Version(4, 0, 0, 0);
					return;
				}

				int ver = CheckTypeIdAttribute();
				if (ver == 2) {
					ObfuscatorName = "SmartAssembly 2.x";
					approxVersion = new Version(2, 0, 0, 0);
					return;
				}
				if (ver == 1) {
					ObfuscatorName = "SmartAssembly 1.x-2.x";
					approxVersion = new Version(1, 0, 0, 0);
					return;
				}

				if (HasModuleCctor()) {
					ObfuscatorName = "SmartAssembly 3.x";
					approxVersion = new Version(3, 0, 0, 0);
					return;
				}

				ObfuscatorName = "SmartAssembly 1.x-4.x";
				approxVersion = new Version(1, 0, 0, 0);
				return;
			}
		}

		int CheckTypeIdAttribute() {
			var type = GetTypeIdAttribute();
			if (type == null)
				return -1;

			var fields = type.Fields;
			if (fields.Count == 1)
				return 1;	// 1.x: int ID
			if (fields.Count == 2)
				return 2;	// 2.x: int ID, static int AssemblyID
			return -1;
		}

		TypeDef GetTypeIdAttribute() {
			Dictionary<TypeDef, bool> attrs = null;
			int counter = 0;
			foreach (var type in module.GetTypes()) {
				counter++;
				var cattrs = type.CustomAttributes;
				if (cattrs.Count == 0)
					return null;

				var attrs2 = new Dictionary<TypeDef, bool>();
				foreach (var cattr in cattrs) {
					if (!DotNetUtils.IsMethod(cattr.Constructor, "System.Void", "(System.Int32)"))
						continue;
					var attrType = cattr.AttributeType as TypeDef;
					if (attrType == null)
						continue;
					if (attrs != null && !attrs.ContainsKey(attrType))
						continue;
					attrs2[attrType] = true;
				}
				attrs = attrs2;

				if (attrs.Count == 0)
					return null;
				if (attrs.Count == 1 && counter >= 30)
					break;
			}

			if (attrs == null)
				return null;
			foreach (var type in attrs.Keys)
				return type;
			return null;
		}

		bool HasModuleCctor() => DotNetUtils.GetModuleTypeCctor(module) != null;

		bool HasEmptyClassesInEveryNamespace() {
			var namespaces = new Dictionary<string, int>(StringComparer.Ordinal);
			var moduleType = DotNetUtils.GetModuleType(module);
			foreach (var type in module.Types) {
				if (type == moduleType)
					continue;
				var ns = type.Namespace.String;
				if (!namespaces.ContainsKey(ns))
					namespaces[ns] = 0;
				if (type.Name != "" || type.IsPublic || type.HasFields || type.HasMethods || type.HasProperties || type.HasEvents)
					continue;
				namespaces[ns]++;
			}

			foreach (int count in namespaces.Values) {
				if (count < 1)
					return false;
			}
			return true;
		}

		public override void DeobfuscateBegin() {
			base.DeobfuscateBegin();

			tamperProtectionRemover = new TamperProtectionRemover(module);
			automatedErrorReportingFinder = new AutomatedErrorReportingFinder(module);
			automatedErrorReportingFinder.Find();

			if (options.RemoveMemoryManager) {
				AddModuleCctorInitCallToBeRemoved(memoryManagerInfo.CctorInitMethod);
				AddCallToBeRemoved(module.EntryPoint, memoryManagerInfo.CctorInitMethod);
			}

			InitDecrypters();
			proxyCallFixer.Find();
		}

		void InitDecrypters() {
			assemblyResolverInfo = new AssemblyResolverInfo(module, DeobfuscatedFile, this);
			assemblyResolverInfo.FindTypes();
			resourceDecrypterInfo = new ResourceDecrypterInfo(module, assemblyResolverInfo.SimpleZipTypeMethod, DeobfuscatedFile);
			resourceResolverInfo = new ResourceResolverInfo(module, DeobfuscatedFile, this, assemblyResolverInfo);
			resourceResolverInfo.FindTypes();
			resourceDecrypter = new ResourceDecrypter(resourceDecrypterInfo);
			assemblyResolver = new AssemblyResolver(resourceDecrypter, assemblyResolverInfo);
			resourceResolver = new ResourceResolver(module, assemblyResolver, resourceResolverInfo);

			InitStringDecrypterInfos();
			assemblyResolverInfo.FindTypes();
			resourceResolverInfo.FindTypes();

			AddModuleCctorInitCallToBeRemoved(assemblyResolverInfo.CallResolverMethod);
			AddCallToBeRemoved(module.EntryPoint, assemblyResolverInfo.CallResolverMethod);
			AddModuleCctorInitCallToBeRemoved(resourceResolverInfo.CallResolverMethod);
			AddCallToBeRemoved(module.EntryPoint, resourceResolverInfo.CallResolverMethod);

			resourceDecrypterInfo.SetSimpleZipType(GetGlobalSimpleZipTypeMethod(), DeobfuscatedFile);

			if (!DecryptResources())
				throw new ApplicationException("Could not decrypt resources");

			DumpEmbeddedAssemblies();
		}

		void DumpEmbeddedAssemblies() {
			assemblyResolver.ResolveResources();
			foreach (var tuple in assemblyResolver.GetDecryptedResources()) {
				DeobfuscatedFile.CreateAssemblyFile(tuple.Item2, tuple.Item1.simpleName, null);
				AddResourceToBeRemoved(tuple.Item1.resource, $"Embedded assembly: {tuple.Item1.assemblyName}");
			}
		}

		bool DecryptResources() {
			if (!resourceResolver.CanDecryptResource())
				return false;
			var info = resourceResolver.MergeResources();
			if (info == null)
				return true;
			AddResourceToBeRemoved(info.resource, "Encrypted resources");
			assemblyResolver.ResolveResources();
			return true;
		}

		MethodDef GetGlobalSimpleZipTypeMethod() {
			if (assemblyResolverInfo.SimpleZipTypeMethod != null)
				return assemblyResolverInfo.SimpleZipTypeMethod;
			foreach (var info in stringDecrypterInfos) {
				if (info.SimpleZipTypeMethod != null)
					return info.SimpleZipTypeMethod;
			}
			return null;
		}

		void InitStringDecrypterInfos() {
			var stringEncoderClassFinder = new StringEncoderClassFinder(module, DeobfuscatedFile);
			stringEncoderClassFinder.Find();
			foreach (var info in stringEncoderClassFinder.StringsEncoderInfos) {
				var sinfo = new StringDecrypterInfo(module, info.StringDecrypterClass) {
					GetStringDelegate = info.GetStringDelegate,
					StringsType = info.StringsType,
					CreateStringDelegateMethod = info.CreateStringDelegateMethod,
				};
				stringDecrypterInfos.Add(sinfo);
			}

			// There may be more than one string decrypter. The strings in the first one's
			// methods may be decrypted by the other string decrypter.

			var initd = new Dictionary<StringDecrypterInfo, bool>(stringDecrypterInfos.Count);
			while (initd.Count != stringDecrypterInfos.Count) {
				StringDecrypterInfo initdInfo = null;
				for (int i = 0; i < 2; i++) {
					foreach (var info in stringDecrypterInfos) {
						if (initd.ContainsKey(info))
							continue;
						if (info.Initialize(this, DeobfuscatedFile)) {
							resourceDecrypterInfo.SetSimpleZipType(info.SimpleZipTypeMethod, DeobfuscatedFile);
							initdInfo = info;
							break;
						}
					}
					if (initdInfo != null)
						break;

					assemblyResolverInfo.FindTypes();
					resourceResolverInfo.FindTypes();
					DecryptResources();
				}

				if (initdInfo == null)
					break;

				initd[initdInfo] = true;
				InitStringDecrypter(initdInfo);
			}

			// Sometimes there could be a string decrypter present that isn't called by anyone.
			foreach (var info in stringDecrypterInfos) {
				if (initd.ContainsKey(info))
					continue;
				Logger.v("String decrypter not initialized. Token {0:X8}", info.StringsEncodingClass.MDToken.ToInt32());
			}
		}

		void InitStringDecrypter(StringDecrypterInfo info) {
			Logger.v("Adding string decrypter. Resource: {0}", Utils.ToCsharpString(info.StringsResource.Name));
			var decrypter = new StringDecrypter(info);
			if (decrypter.CanDecrypt) {
				var invokeMethod = info.GetStringDelegate?.FindMethod("Invoke");
				staticStringInliner.Add(invokeMethod, (method, gim, args) => {
					var fieldDef = DotNetUtils.GetField(module, (IField)args[0]);
					return decrypter.Decrypt(fieldDef.MDToken.ToInt32(), (int)args[1]);
				});
				staticStringInliner.Add(info.StringDecrypterMethod, (method, gim, args) => {
					return decrypter.Decrypt(0, (int)args[0]);
				});
			}
			stringDecrypters.Add(decrypter);
			DeobfuscatedFile.StringDecryptersAdded();
		}

		public override void DeobfuscateMethodEnd(Blocks blocks) {
			proxyCallFixer.Deobfuscate(blocks);
			RemoveAutomatedErrorReportingCode(blocks);
			RemoveTamperProtection(blocks);
			RemoveStringsInitCode(blocks);
			base.DeobfuscateMethodEnd(blocks);
		}

		public override void DeobfuscateEnd() {
			canRemoveTypes = FindBigType() == null;
			RemoveProxyDelegates(proxyCallFixer, canRemoveTypes);
			RemoveMemoryManagerStuff();
			RemoveTamperProtectionStuff();
			RemoveStringDecryptionStuff();
			RemoveResolverInfoTypes(assemblyResolverInfo, "Assembly");
			RemoveResolverInfoTypes(resourceResolverInfo, "Resource");
			base.DeobfuscateEnd();
		}

		TypeDef FindBigType() {
			if (approxVersion <= new Version(6, 5, 3, 53))
				return null;

			TypeDef bigType = null;
			foreach (var type in module.Types) {
				if (IsBigType(type)) {
					if (bigType == null || type.Methods.Count > bigType.Methods.Count)
						bigType = type;
				}
			}
			return bigType;
		}

		bool IsBigType(TypeDef type) {
			if (type.Methods.Count < 50)
				return false;
			if (type.HasProperties || type.HasEvents)
				return false;
			if (type.Fields.Count > 3)
				return false;
			foreach (var method in type.Methods) {
				if (!method.IsStatic)
					return false;
			}
			return true;
		}

		void RemoveResolverInfoTypes(ResolverInfoBase info, string typeName) {
			if (!canRemoveTypes)
				return;
			if (info.CallResolverType == null || info.Type == null)
				return;
			AddTypeToBeRemoved(info.CallResolverType, $"{typeName} resolver type #1");
			AddTypeToBeRemoved(info.Type, $"{typeName} resolver type #2");
		}

		void RemoveAutomatedErrorReportingCode(Blocks blocks) {
			if (!options.RemoveAutomatedErrorReporting)
				return;
			if (automatedErrorReportingFinder.Remove(blocks))
				Logger.v("Removed Automated Error Reporting code");
		}

		void RemoveTamperProtection(Blocks blocks) {
			if (!options.RemoveTamperProtection)
				return;
			if (tamperProtectionRemover.Remove(blocks))
				Logger.v("Removed Tamper Protection code");
		}

		void RemoveMemoryManagerStuff() {
			if (!canRemoveTypes || !options.RemoveMemoryManager)
				return;
			AddTypeToBeRemoved(memoryManagerInfo.Type, "Memory manager type");
		}

		void RemoveTamperProtectionStuff() {
			if (!options.RemoveTamperProtection)
				return;
			AddMethodsToBeRemoved(tamperProtectionRemover.PinvokeMethods, "Tamper protection PInvoke method");
		}

		void RemoveStringDecryptionStuff() {
			if (!CanRemoveStringDecrypterType)
				return;

			foreach (var decrypter in stringDecrypters) {
				var info = decrypter.StringDecrypterInfo;
				AddResourceToBeRemoved(info.StringsResource, "Encrypted strings");
				AddFieldsToBeRemoved(info.GetAllStringDelegateFields(), "String decrypter delegate field");

				if (canRemoveTypes) {
					AddTypeToBeRemoved(info.StringsEncodingClass, "String decrypter type");
					AddTypeToBeRemoved(info.StringsType, "Creates the string decrypter delegates");
					AddTypeToBeRemoved(info.GetStringDelegate, "String decrypter delegate type");
				}
			}
		}

		void RemoveStringsInitCode(Blocks blocks) {
			if (!CanRemoveStringDecrypterType)
				return;

			if (blocks.Method.Name == ".cctor") {
				foreach (var decrypter in stringDecrypters)
					decrypter.StringDecrypterInfo.RemoveInitCode(blocks);
			}
		}

		public override IEnumerable<int> GetStringDecrypterMethods() {
			var list = new List<int>();
			foreach (var method in staticStringInliner.Methods)
				list.Add(method.MDToken.ToInt32());
			return list;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/SmartAssembly/MemoryManagerInfo.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using dnlib.DotNet;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.SmartAssembly {
	class MemoryManagerInfo {
		ModuleDefMD module;
		TypeDef memoryManagerType;
		MethodDef attachAppMethod;

		public bool Detected => memoryManagerType != null;
		public TypeDef Type => memoryManagerType;
		public MethodDef CctorInitMethod => attachAppMethod;
		public MemoryManagerInfo(ModuleDefMD module) => this.module = module;

		public bool Find() {
			if (CheckCalledMethods(DotNetUtils.GetModuleTypeCctor(module)))
				return true;
			if (CheckCalledMethods(module.EntryPoint))
				return true;
			return false;
		}

		bool CheckCalledMethods(MethodDef checkMethod) {
			if (checkMethod == null)
				return false;
			foreach (var method in DotNetUtils.GetCalledMethods(module, checkMethod)) {
				if (method.Name == ".cctor" || method.Name == ".ctor")
					continue;
				if (!method.IsStatic || !DotNetUtils.IsMethod(method, "System.Void", "()"))
					continue;
				if (CheckMemoryManagerType(method.DeclaringType, method)) {
					memoryManagerType = method.DeclaringType;
					attachAppMethod = method;
					return true;
				}
			}

			return false;
		}

		bool CheckMemoryManagerType(TypeDef type, MethodDef method) {
			// Only two fields: itself and a long
			int fields = 0;
			foreach (var field in type.Fields) {
				if (new SigComparer().Equals(field.FieldType, type) ||
					field.FieldType.FullName == "System.Int64") {
					fields++;
					continue;
				}
				if (DotNetUtils.DerivesFromDelegate(DotNetUtils.GetType(module, field.FieldType)))
					continue;

				return false;
			}
			if (fields != 2)
				return false;

			if (DotNetUtils.GetPInvokeMethod(type, "kernel32", "SetProcessWorkingSetSize") == null)
				return false;

			return true;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/SmartAssembly/ProxyCallFixer.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.SmartAssembly {
	class ProxyCallFixer : ProxyCallFixer1 {
		static readonly Dictionary<char, int> specialCharsDict = new Dictionary<char, int>();
		static readonly char[] specialChars = new char[] {
			'\x01', '\x02', '\x03', '\x04', '\x05', '\x06', '\x07', '\x08',
			'\x0E', '\x0F', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15',
			'\x16', '\x17', '\x18', '\x19', '\x1A', '\x1B', '\x1C', '\x1D',
			'\x1E', '\x1F', '\x7F', '\x80', '\x81', '\x82', '\x83', '\x84',
			'\x86', '\x87', '\x88', '\x89', '\x8A', '\x8B', '\x8C', '\x8D',
			'\x8E', '\x8F', '\x90', '\x91', '\x92', '\x93', '\x94', '\x95',
			'\x96', '\x97', '\x98', '\x99', '\x9A', '\x9B', '\x9C', '\x9D',
			'\x9E', '\x9F',
		};

		ISimpleDeobfuscator simpleDeobfuscator;

		static ProxyCallFixer() {
			for (int i = 0; i < specialChars.Length; i++)
				specialCharsDict[specialChars[i]] = i;
		}

		public ProxyCallFixer(ModuleDefMD module, ISimpleDeobfuscator simpleDeobfuscator)
			: base(module) => this.simpleDeobfuscator = simpleDeobfuscator;

		protected override object CheckCctor(ref TypeDef type, MethodDef cctor) {
			var instrs = cctor.Body.Instructions;
			if (instrs.Count > 10)
				return null;
			if (instrs.Count != 3)
				simpleDeobfuscator.Deobfuscate(cctor);
			if (instrs.Count != 3)
				return null;
			if (!instrs[0].IsLdcI4())
				return null;
			if (instrs[1].OpCode != OpCodes.Call || !IsDelegateCreatorMethod(instrs[1].Operand as MethodDef))
				return null;
			if (instrs[2].OpCode != OpCodes.Ret)
				return null;

			int delegateToken = 0x02000001 + instrs[0].GetLdcI4Value();
			if (type.MDToken.ToInt32() != delegateToken) {
				Logger.w("Delegate token is not current type");
				return null;
			}

			return new object();
		}

		protected override void GetCallInfo(object context, FieldDef field, out IMethod calledMethod, out OpCode callOpcode) {
			callOpcode = OpCodes.Call;
			string name = field.Name.String;

			uint memberRefRid = 0;
			for (int i = name.Length - 1; i >= 0; i--) {
				char c = name[i];
				if (c == '~') {
					callOpcode = OpCodes.Callvirt;
					break;
				}

				if (specialCharsDict.TryGetValue(c, out int val))
					memberRefRid = memberRefRid * (uint)specialChars.Length + (uint)val;
			}
			memberRefRid++;

			calledMethod = module.ResolveMemberRef(memberRefRid);
			if (calledMethod == null)
				Logger.w("Ignoring invalid method RID: {0:X8}, field: {1:X8}", memberRefRid, field.MDToken.ToInt32());
		}

		public void FindDelegateCreator(ModuleDefMD module) {
			var callCounter = new CallCounter();
			foreach (var type in module.Types) {
				if (type.Namespace != "" || !DotNetUtils.DerivesFromDelegate(type))
					continue;
				var cctor = type.FindStaticConstructor();
				if (cctor == null)
					continue;
				foreach (var method in DotNetUtils.GetMethodCalls(cctor))
					callCounter.Add(method);
			}

			var mostCalls = callCounter.Most();
			if (mostCalls == null)
				return;

			SetDelegateCreatorMethod(DotNetUtils.GetMethod(module, mostCalls));
		}
	}
}



================================================
File: de4dot.code/deobfuscators/SmartAssembly/ResolverInfoBase.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.SmartAssembly {
	abstract class ResolverInfoBase {
		protected ModuleDefMD module;
		ISimpleDeobfuscator simpleDeobfuscator;
		IDeobfuscator deob;
		TypeDef resolverType;
		MethodDef callResolverMethod;

		public TypeDef Type => resolverType;

		public TypeDef CallResolverType {
			get {
				if (callResolverMethod == null)
					return null;
				if (!HasOnlyThisMethod(callResolverMethod.DeclaringType, callResolverMethod))
					return null;
				return callResolverMethod.DeclaringType;
			}
		}

		public MethodDef CallResolverMethod => callResolverMethod;

		public ResolverInfoBase(ModuleDefMD module, ISimpleDeobfuscator simpleDeobfuscator, IDeobfuscator deob) {
			this.module = module;
			this.simpleDeobfuscator = simpleDeobfuscator;
			this.deob = deob;
		}

		public bool FindTypes() {
			if (resolverType != null)
				return true;

			if (FindTypes(DotNetUtils.GetModuleTypeCctor(module)))
				return true;
			if (FindTypes(module.EntryPoint))
				return true;

			return false;
		}

		bool FindTypes(MethodDef initMethod) {
			if (initMethod == null)
				return false;
			foreach (var method in DotNetUtils.GetCalledMethods(module, initMethod)) {
				if (method.Name == ".cctor" || method.Name == ".ctor")
					continue;
				if (!method.IsStatic || !DotNetUtils.IsMethod(method, "System.Void", "()"))
					continue;
				if (CheckAttachAppMethod(method))
					return true;
			}

			return false;
		}

		bool CheckAttachAppMethod(MethodDef attachAppMethod) {
			callResolverMethod = null;
			if (!attachAppMethod.HasBody)
				return false;

			foreach (var method in DotNetUtils.GetCalledMethods(module, attachAppMethod)) {
				if (attachAppMethod == method)
					continue;
				if (method.Name == ".cctor" || method.Name == ".ctor")
					continue;
				if (!method.IsStatic || !DotNetUtils.IsMethod(method, "System.Void", "()"))
					continue;
				if (!CheckResolverInitMethod(method))
					continue;

				callResolverMethod = attachAppMethod;
				return true;
			}

			if (HasLdftn(attachAppMethod)) {
				simpleDeobfuscator.Deobfuscate(attachAppMethod);
				foreach (var resolverHandler in GetResolverHandlers(attachAppMethod)) {
					if (!resolverHandler.HasBody)
						continue;
					var resolverTypeTmp = GetResolverType(resolverHandler);
					if (resolverTypeTmp == null)
						continue;
					Deobfuscate(resolverHandler);
					if (CheckHandlerMethod(resolverHandler)) {
						callResolverMethod = attachAppMethod;
						resolverType = resolverTypeTmp;
						return true;
					}
				}
			}

			return false;
		}

		static bool HasLdftn(MethodDef method) {
			if (method == null || method.Body == null)
				return false;
			foreach (var instr in method.Body.Instructions) {
				if (instr.OpCode.Code == Code.Ldftn)
					return true;
			}
			return false;
		}

		bool CheckResolverInitMethod(MethodDef initMethod) {
			resolverType = null;
			if (!initMethod.HasBody)
				return false;

			Deobfuscate(initMethod);
			foreach (var handlerDef in GetResolverHandlers(initMethod)) {
				Deobfuscate(handlerDef);

				var resolverTypeTmp = GetResolverType(handlerDef);
				if (resolverTypeTmp == null)
					continue;

				if (CheckHandlerMethod(handlerDef)) {
					resolverType = resolverTypeTmp;
					return true;
				}
			}

			return false;
		}

		void Deobfuscate(MethodDef method) {
			simpleDeobfuscator.Deobfuscate(method);
			simpleDeobfuscator.DecryptStrings(method, deob);
		}

		TypeDef GetResolverType(MethodDef resolveHandler) {
			if (resolveHandler.Body == null)
				return null;
			foreach (var instr in resolveHandler.Body.Instructions) {
				if (instr.OpCode.Code != Code.Ldsfld && instr.OpCode.Code != Code.Stsfld)
					continue;
				var field = DotNetUtils.GetField(module, instr.Operand as IField);
				if (field == null)
					continue;
				if (!CheckResolverType(field.DeclaringType))
					continue;

				return field.DeclaringType;
			}

			if (CheckResolverType(resolveHandler.DeclaringType))
				return resolveHandler.DeclaringType;

			return null;
		}

		protected abstract bool CheckResolverType(TypeDef type);
		protected abstract bool CheckHandlerMethod(MethodDef handler);

		IEnumerable<MethodDef> GetResolverHandlers(MethodDef method) {
			int numHandlers = 0;
			var instructions = method.Body.Instructions;
			for (int i = 0; i < instructions.Count; i++) {
				var instrs = DotNetUtils.GetInstructions(instructions, i, OpCodes.Call, OpCodes.Ldnull, OpCodes.Ldftn, OpCodes.Newobj, OpCodes.Callvirt);
				if (instrs == null)
					continue;

				var call = instrs[0];
				if (!DotNetUtils.IsMethod(call.Operand as IMethod, "System.AppDomain", "()"))
					continue;

				var ldftn = instrs[2];
				var handlerDef = DotNetUtils.GetMethod(module, ldftn.Operand as IMethod);
				if (handlerDef == null)
					continue;

				var newobj = instrs[3];
				if (!DotNetUtils.IsMethod(newobj.Operand as IMethod, "System.Void", "(System.Object,System.IntPtr)"))
					continue;

				var callvirt = instrs[4];
				if (!DotNetUtils.IsMethod(callvirt.Operand as IMethod, "System.Void", "(System.ResolveEventHandler)"))
					continue;

				numHandlers++;
				yield return handlerDef;
			}

			// If no handlers found, it's possible that the method itself is the handler.
			if (numHandlers == 0)
				yield return method;
		}

		static bool HasOnlyThisMethod(TypeDef type, MethodDef method) {
			if (type == null || method == null)
				return false;
			foreach (var m in type.Methods) {
				if (m.Name == ".cctor" || m.Name == ".ctor")
					continue;
				if (m == method)
					continue;
				return false;
			}
			return true;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/SmartAssembly/ResourceDecrypter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.IO;
using System.Security.Cryptography;
using dnlib.DotNet;
using ICSharpCode.SharpZipLib.Zip.Compression;

namespace de4dot.code.deobfuscators.SmartAssembly {
	class ResourceDecrypter {
		ResourceDecrypterInfo resourceDecrypterInfo;

		public ResourceDecrypter(ResourceDecrypterInfo resourceDecrypterInfo) =>
			this.resourceDecrypterInfo = resourceDecrypterInfo;

		public bool CanDecrypt => resourceDecrypterInfo != null && resourceDecrypterInfo.CanDecrypt;

		public byte[] Decrypt(EmbeddedResource resource) {
			if (!CanDecrypt)
				throw new ApplicationException("Can't decrypt resources");
			var encryptedData = resource.CreateReader().ToArray();
			return Decrypt(encryptedData);
		}

		byte[] Decrypt(byte[] encryptedData) {
			var reader = new BinaryReader(new MemoryStream(encryptedData));
			int headerMagic = reader.ReadInt32();
			if (headerMagic == 0x04034B50)
				throw new NotImplementedException("Not implemented yet since I haven't seen anyone use it.");

			byte encryption = (byte)(headerMagic >> 24);
			if ((headerMagic & 0x00FFFFFF) != 0x007D7A7B)	// Check if "{z}"
				throw new ApplicationException($"Invalid SA header magic 0x{headerMagic:X8}");

			switch (encryption) {
			case 1:
				int totalInflatedLength = reader.ReadInt32();
				if (totalInflatedLength < 0)
					throw new ApplicationException("Invalid length");
				var inflatedBytes = new byte[totalInflatedLength];
				int partInflatedLength;
				for (int inflateOffset = 0; inflateOffset < totalInflatedLength; inflateOffset += partInflatedLength) {
					int partLength = reader.ReadInt32();
					partInflatedLength = reader.ReadInt32();
					if (partLength < 0 || partInflatedLength < 0)
						throw new ApplicationException("Invalid length");
					var inflater = new Inflater(true);
					inflater.SetInput(encryptedData, checked((int)reader.BaseStream.Position), partLength);
					reader.BaseStream.Seek(partLength, SeekOrigin.Current);
					int realInflatedLen = inflater.Inflate(inflatedBytes, inflateOffset, inflatedBytes.Length - inflateOffset);
					if (realInflatedLen != partInflatedLength)
						throw new ApplicationException("Could not inflate");
				}
				return inflatedBytes;

			case 2:
				if (resourceDecrypterInfo.DES_Key == null || resourceDecrypterInfo.DES_IV == null)
					throw new ApplicationException("DES key / iv have not been set yet");
				using (var provider = new DESCryptoServiceProvider()) {
					provider.Key = resourceDecrypterInfo.DES_Key;
					provider.IV  = resourceDecrypterInfo.DES_IV;
					using (var transform = provider.CreateDecryptor()) {
						return Decrypt(transform.TransformFinalBlock(encryptedData, 4, encryptedData.Length - 4));
					}
				}

			case 3:
				if (resourceDecrypterInfo.AES_Key == null || resourceDecrypterInfo.AES_IV == null)
					throw new ApplicationException("AES key / iv have not been set yet");
				using (var provider = new RijndaelManaged()) {
					provider.Key = resourceDecrypterInfo.AES_Key;
					provider.IV  = resourceDecrypterInfo.AES_IV;
					using (var transform = provider.CreateDecryptor()) {
						return Decrypt(transform.TransformFinalBlock(encryptedData, 4, encryptedData.Length - 4));
					}
				}

			default:
				throw new ApplicationException($"Unknown encryption type 0x{encryption:X2}");
			}
		}
	}
}



================================================
File: de4dot.code/deobfuscators/SmartAssembly/ResourceDecrypterInfo.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.SmartAssembly {
	class ResourceDecrypterInfo {
		ModuleDefMD module;
		MethodDef simpleZipTypeDecryptMethod;

		public byte[] DES_Key { get; private set; }
		public byte[] DES_IV  { get; private set; }
		public byte[] AES_Key { get; private set; }
		public byte[] AES_IV  { get; private set; }
		public bool CanDecrypt => simpleZipTypeDecryptMethod != null;

		public ResourceDecrypterInfo(ModuleDefMD module) => this.module = module;

		public ResourceDecrypterInfo(ModuleDefMD module, MethodDef simpleZipTypeDecryptMethod, ISimpleDeobfuscator simpleDeobfuscator)
			: this(module) => SetSimpleZipType(simpleZipTypeDecryptMethod, simpleDeobfuscator);

		public void SetSimpleZipType(MethodDef method, ISimpleDeobfuscator simpleDeobfuscator) {
			if (simpleZipTypeDecryptMethod != null || method == null)
				return;
			simpleZipTypeDecryptMethod = method;
			Initialize(simpleDeobfuscator, method);
		}

		void Initialize(ISimpleDeobfuscator simpleDeobfuscator, MethodDef method) {
			var desList = new List<byte[]>(2);
			var aesList = new List<byte[]>(2);

			var instructions = method.Body.Instructions;
			simpleDeobfuscator.Deobfuscate(method);
			for (int i = 0; i <= instructions.Count - 2; i++) {
				var ldtoken = instructions[i];
				if (ldtoken.OpCode.Code != Code.Ldtoken)
					continue;
				var field = DotNetUtils.GetField(module, ldtoken.Operand as IField);
				if (field == null)
					continue;
				if (field.InitialValue == null)
					continue;

				var call = instructions[i + 1];
				if (call.OpCode.Code != Code.Call)
					continue;
				var calledMethod = call.Operand as IMethod;
				if (!DotNetUtils.IsMethod(calledMethod, "System.Void", "(System.Array,System.RuntimeFieldHandle)"))
					continue;

				if (field.InitialValue.Length == 8)
					desList.Add(field.InitialValue);
				else if (field.InitialValue.Length == 16)
					aesList.Add(field.InitialValue);
			}

			if (desList.Count >= 2) {
				DES_Key = desList[desList.Count - 2];
				DES_IV  = desList[desList.Count - 1];
			}
			if (aesList.Count >= 2) {
				AES_Key = aesList[aesList.Count - 2];
				AES_IV  = aesList[aesList.Count - 1];
			}
		}
	}
}



================================================
File: de4dot.code/deobfuscators/SmartAssembly/ResourceResolver.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using dnlib.DotNet;

namespace de4dot.code.deobfuscators.SmartAssembly {
	class ResourceResolver {
		ModuleDefMD module;
		AssemblyResolver assemblyResolver;
		ResourceResolverInfo resourceResolverInfo;
		bool mergedIt = false;

		public ResourceResolver(ModuleDefMD module, AssemblyResolver assemblyResolver, ResourceResolverInfo resourceResolverInfo) {
			this.module = module;
			this.assemblyResolver = assemblyResolver;
			this.resourceResolverInfo = resourceResolverInfo;
		}

		public bool CanDecryptResource() => assemblyResolver.CanDecryptResource(resourceResolverInfo.ResourceInfo);

		public EmbeddedAssemblyInfo MergeResources() {
			if (mergedIt)
				return null;

			var info = resourceResolverInfo.ResourceInfo;
			if (info == null)
				return null;

			DeobUtils.DecryptAndAddResources(module, info.resourceName, () => assemblyResolver.RemoveDecryptedResource(info));
			mergedIt = true;
			return info;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/SmartAssembly/ResourceResolverInfo.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.SmartAssembly {
	class ResourceResolverInfo : ResolverInfoBase {
		EmbeddedAssemblyInfo resourceInfo;
		AssemblyResolverInfo assemblyResolverInfo;

		public EmbeddedAssemblyInfo ResourceInfo => resourceInfo;

		public ResourceResolverInfo(ModuleDefMD module, ISimpleDeobfuscator simpleDeobfuscator, IDeobfuscator deob, AssemblyResolverInfo assemblyResolverInfo)
			: base(module, simpleDeobfuscator, deob) => this.assemblyResolverInfo = assemblyResolverInfo;

		protected override bool CheckResolverType(TypeDef type) =>
			DotNetUtils.FindFieldType(type, "System.Reflection.Assembly", true) != null;

		protected override bool CheckHandlerMethod(MethodDef method) {
			if (!method.IsStatic || !method.HasBody)
				return false;

			EmbeddedAssemblyInfo info = null;
			var instructions = method.Body.Instructions;
			for (int i = 0; i < instructions.Count; i++) {
				var instrs = DotNetUtils.GetInstructions(instructions, i, OpCodes.Ldstr, OpCodes.Call);
				if (instrs == null)
					continue;

				var s = instrs[0].Operand as string;
				var calledMethod = instrs[1].Operand as IMethod;
				if (s == null || calledMethod == null)
					continue;

				info = assemblyResolverInfo.Find(Utils.GetAssemblySimpleName(s));
				if (info != null)
					break;
			}
			if (info == null)
				return false;

			resourceInfo = info;
			Logger.v("Found embedded assemblies resource {0}", Utils.ToCsharpString(info.resourceName));
			return true;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/SmartAssembly/SimpleZipInfo.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using dnlib.DotNet;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.SmartAssembly {
	class SimpleZipInfo {

		public static bool IsSimpleZipDecryptMethod_QuickCheck(ModuleDefMD module, IMethod method, out MethodDef simpleZipTypeMethod) {
			simpleZipTypeMethod = null;

			if (!DotNetUtils.IsMethod(method, "System.Byte[]", "(System.Byte[])"))
				return false;

			var methodDef = DotNetUtils.GetMethod(DotNetUtils.GetType(module, method.DeclaringType), method);
			if (methodDef == null)
				return false;

			simpleZipTypeMethod = methodDef;
			return true;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/SmartAssembly/StringDecrypter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Text;

namespace de4dot.code.deobfuscators.SmartAssembly {
	class StringDecrypter {
		int stringOffset;
		byte[] decryptedData;

		public bool CanDecrypt => decryptedData != null;
		public StringDecrypterInfo StringDecrypterInfo { get; private set; }

		public StringDecrypter(StringDecrypterInfo stringDecrypterInfo) {
			StringDecrypterInfo = stringDecrypterInfo;

			if (stringDecrypterInfo != null) {
				if (!stringDecrypterInfo.StringsEncrypted) {
					stringOffset = stringDecrypterInfo.StringOffset;
					decryptedData = stringDecrypterInfo.StringsResource.CreateReader().ToArray();
				}
				else if (stringDecrypterInfo.CanDecrypt) {
					stringOffset = stringDecrypterInfo.StringOffset;
					decryptedData = stringDecrypterInfo.Decrypt();
				}
			}
		}

		public string Decrypt(int token, int id) {
			if (!CanDecrypt)
				throw new ApplicationException("Can't decrypt strings since decryptedData is null");

			int index = id - (token & 0x00FFFFFF) - stringOffset;
			int len = DeobUtils.ReadVariableLengthInt32(decryptedData, ref index);

			switch (StringDecrypterInfo.DecrypterVersion) {
			case StringDecrypterVersion.V1:
				// Some weird problem with 1.x decrypted strings. They all have a \x01 char at the end.
				var buf = Convert.FromBase64String(Encoding.ASCII.GetString(decryptedData, index, len));
				if (buf.Length % 2 != 0)
					Array.Resize(ref buf, buf.Length - 1);
				return Encoding.Unicode.GetString(buf);

			case StringDecrypterVersion.V2:
				return Encoding.UTF8.GetString(Convert.FromBase64String(Encoding.ASCII.GetString(decryptedData, index, len)));

			default:
				return Encoding.UTF8.GetString(Convert.FromBase64String(Encoding.UTF8.GetString(decryptedData, index, len)));
			}
		}
	}
}



================================================
File: de4dot.code/deobfuscators/SmartAssembly/StringDecrypterInfo.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.SmartAssembly {
	enum StringDecrypterVersion {
		V1,
		V2,
		V3,
		V4,
		Unknown,
	}

	class StringDecrypterInfo {
		ModuleDefMD module;
		ResourceDecrypter resourceDecrypter;
		TypeDef stringsEncodingClass;
		EmbeddedResource stringsResource;
		int stringOffset;
		MethodDef simpleZipTypeMethod;
		MethodDef stringDecrypterMethod;
		StringDecrypterVersion decrypterVersion;

		public StringDecrypterVersion DecrypterVersion => decrypterVersion;
		public TypeDef GetStringDelegate { get; set; }
		public TypeDef StringsType { get; set; }
		public MethodDef CreateStringDelegateMethod { get; set; }
		public TypeDef StringsEncodingClass => stringsEncodingClass;
		public bool CanDecrypt => resourceDecrypter == null || resourceDecrypter.CanDecrypt;
		public MethodDef SimpleZipTypeMethod => simpleZipTypeMethod;
		public EmbeddedResource StringsResource => stringsResource;
		public int StringOffset => stringOffset;
		public bool StringsEncrypted => simpleZipTypeMethod != null;
		public MethodDef StringDecrypterMethod => stringDecrypterMethod;

		public StringDecrypterInfo(ModuleDefMD module, TypeDef stringsEncodingClass) {
			this.module = module;
			this.stringsEncodingClass = stringsEncodingClass;
		}

		static string[] fields2x = new string[] {
			"System.IO.Stream",
			"System.Int32",
		};
		static string[] fields3x = new string[] {
			"System.Byte[]",
			"System.Int32",
		};
		StringDecrypterVersion GuessVersion(MethodDef cctor) {
			var fieldTypes = new FieldTypes(stringsEncodingClass);
			if (fieldTypes.Exactly(fields2x))
				return StringDecrypterVersion.V2;
			if (cctor == null)
				return StringDecrypterVersion.V1;
			if (fieldTypes.Exactly(fields3x))
				return StringDecrypterVersion.V3;
			return StringDecrypterVersion.Unknown;
		}

		public bool Initialize(IDeobfuscator deob, ISimpleDeobfuscator simpleDeobfuscator) {
			var cctor = stringsEncodingClass.FindStaticConstructor();
			if (cctor != null)
				simpleDeobfuscator.Deobfuscate(cctor);

			decrypterVersion = GuessVersion(cctor);

			if (!FindDecrypterMethod())
				throw new ApplicationException("Could not find string decrypter method");

			if (!FindStringsResource(deob, simpleDeobfuscator, cctor))
				return false;

			if (decrypterVersion <= StringDecrypterVersion.V3) {
				MethodDef initMethod;
				if (decrypterVersion == StringDecrypterVersion.V3)
					initMethod = cctor;
				else if (decrypterVersion == StringDecrypterVersion.V2)
					initMethod = stringDecrypterMethod;
				else
					initMethod = stringDecrypterMethod;

				stringOffset = 0;
				if (decrypterVersion != StringDecrypterVersion.V1) {
					if (CallsGetPublicKeyToken(initMethod)) {
						var pkt = PublicKeyBase.ToPublicKeyToken(module.Assembly.PublicKeyToken);
						if (!PublicKeyBase.IsNullOrEmpty2(pkt)) {
							for (int i = 0; i < pkt.Data.Length - 1; i += 2)
								stringOffset ^= ((int)pkt.Data[i] << 8) + pkt.Data[i + 1];
						}
					}

					if (DeobUtils.HasInteger(initMethod, 0xFFFFFF) &&
						DeobUtils.HasInteger(initMethod, 0xFFFF)) {
						stringOffset ^= ((stringDecrypterMethod.MDToken.ToInt32() & 0xFFFFFF) - 1) % 0xFFFF;
					}
				}
			}
			else {
				var offsetVal = FindOffsetValue(cctor);
				if (offsetVal == null)
					throw new ApplicationException("Could not find string offset");
				stringOffset = offsetVal.Value;
				decrypterVersion = StringDecrypterVersion.V4;
			}

			simpleZipTypeMethod = FindSimpleZipTypeMethod(cctor) ?? FindSimpleZipTypeMethod(stringDecrypterMethod);
			if (simpleZipTypeMethod != null)
				resourceDecrypter = new ResourceDecrypter(new ResourceDecrypterInfo(module, simpleZipTypeMethod, simpleDeobfuscator));

			return true;
		}

		bool CallsGetPublicKeyToken(MethodDef method) {
			foreach (var calledMethod in DotNetUtils.GetMethodCalls(method)) {
				if (calledMethod.ToString() == "System.Byte[] System.Reflection.AssemblyName::GetPublicKeyToken()")
					return true;
			}
			return false;
		}

		bool FindStringsResource(IDeobfuscator deob, ISimpleDeobfuscator simpleDeobfuscator, MethodDef cctor) {
			if (stringsResource != null)
				return true;

			if (decrypterVersion <= StringDecrypterVersion.V3) {
				stringsResource = DotNetUtils.GetResource(module, (module.Mvid ?? Guid.NewGuid()).ToString("B")) as EmbeddedResource;
				if (stringsResource != null)
					return true;
			}

			if (FindStringsResource2(deob, simpleDeobfuscator, cctor))
				return true;
			if (FindStringsResource2(deob, simpleDeobfuscator, stringDecrypterMethod))
				return true;

			return false;
		}

		bool FindStringsResource2(IDeobfuscator deob, ISimpleDeobfuscator simpleDeobfuscator, MethodDef initMethod) {
			if (initMethod == null)
				return false;

			stringsResource = FindStringResource(initMethod);
			if (stringsResource != null)
				return true;

			simpleDeobfuscator.DecryptStrings(initMethod, deob);
			stringsResource = FindStringResource(initMethod);
			if (stringsResource != null)
				return true;

			return false;
		}

		public byte[] Decrypt() {
			if (!CanDecrypt)
				throw new ApplicationException("Can't decrypt strings");
			return resourceDecrypter.Decrypt(stringsResource);
		}

		// Find the embedded resource where all the strings are encrypted
		EmbeddedResource FindStringResource(MethodDef method) {
			foreach (var s in DotNetUtils.GetCodeStrings(method)) {
				if (s == null)
					continue;
				if (DotNetUtils.GetResource(module, s) is EmbeddedResource resource)
					return resource;
			}
			return null;
		}

		// Find the string decrypter string offset value or null if none found
		int? FindOffsetValue(MethodDef method) {
			var fieldDict = new FieldDefAndDeclaringTypeDict<IField>();
			foreach (var field in method.DeclaringType.Fields)
				fieldDict.Add(field, field);

			var offsetField = FindOffsetField(method);
			if (offsetField == null)
				return null;

			return FindOffsetValue(method, (FieldDef)fieldDict.Find(offsetField), fieldDict);
		}

		IField FindOffsetField(MethodDef method) {
			var instructions = method.Body.Instructions;
			for (int i = 0; i <= instructions.Count - 2; i++) {
				var ldsfld = instructions[i];
				if (ldsfld.OpCode.Code != Code.Ldsfld)
					continue;
				var field = ldsfld.Operand as IField;
				if (field == null || field.FieldSig.GetFieldType().GetElementType() != ElementType.String)
					continue;
				if (!new SigComparer().Equals(stringsEncodingClass, field.DeclaringType))
					continue;

				var call = instructions[i + 1];
				if (call.OpCode.Code != Code.Call)
					continue;
				var calledMethod = call.Operand as IMethod;
				if (!DotNetUtils.IsMethod(calledMethod, "System.Int32", "(System.String)"))
					continue;

				return field;
			}

			return null;
		}

		int? FindOffsetValue(MethodDef method, FieldDef offsetField, FieldDefAndDeclaringTypeDict<IField> fields) {
			var instructions = method.Body.Instructions;
			for (int i = 0; i <= instructions.Count - 2; i++) {
				var ldstr = instructions[i];
				if (ldstr.OpCode.Code != Code.Ldstr)
					continue;
				var stringVal = ldstr.Operand as string;
				if (stringVal == null)
					continue;

				var stsfld = instructions[i + 1];
				if (stsfld.OpCode.Code != Code.Stsfld)
					continue;
				var field = stsfld.Operand as IField;
				if (field == null || fields.Find(field) != offsetField)
					continue;

				if (!int.TryParse(stringVal, System.Globalization.NumberStyles.Integer, null, out int value))
					continue;

				return value;
			}

			return null;
		}

		bool FindDecrypterMethod() {
			if (stringDecrypterMethod != null)
				return true;

			var methods = new List<MethodDef>(DotNetUtils.FindMethods(stringsEncodingClass.Methods, "System.String", new string[] { "System.Int32" }));
			if (methods.Count != 1)
				return false;

			stringDecrypterMethod = methods[0];
			return true;
		}

		MethodDef FindSimpleZipTypeMethod(MethodDef method) {
			if (method == null || method.Body == null)
				return null;
			var instructions = method.Body.Instructions;
			for (int i = 0; i <= instructions.Count - 2; i++) {
				var call = instructions[i];
				if (call.OpCode.Code != Code.Call)
					continue;
				var calledMethod = call.Operand as MethodDef;
				if (calledMethod == null)
					continue;
				if (!DotNetUtils.IsMethod(calledMethod, "System.Byte[]", "(System.Byte[])"))
					continue;

				var stsfld = instructions[i + 1];
				if (stsfld.OpCode.Code != Code.Stsfld)
					continue;
				var field = stsfld.Operand as IField;
				if (field == null || field.FieldSig.GetFieldType().GetFullName() != "System.Byte[]")
					continue;
				if (!new SigComparer().Equals(stringsEncodingClass, field.DeclaringType))
					continue;

				return calledMethod;
			}

			return null;
		}

		public IEnumerable<FieldDef> GetAllStringDelegateFields() {
			if (GetStringDelegate == null)
				yield break;
			foreach (var type in module.GetTypes()) {
				foreach (var field in type.Fields) {
					if (field.FieldType.TryGetTypeDef() == GetStringDelegate)
						yield return field;
				}
			}
		}

		public void RemoveInitCode(Blocks blocks) {
			if (CreateStringDelegateMethod == null)
				return;

			if (CreateStringDelegateMethod.Parameters.Count != 0)
				RemoveInitCode_v2(blocks);
			else
				RemoveInitCode_v1(blocks);
		}

		void RemoveInitCode_v1(Blocks blocks) {
			foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {
				var instructions = block.Instructions;
				for (int i = 0; i < instructions.Count; i++) {
					var call = instructions[i];
					if (call.OpCode != OpCodes.Call)
						continue;
					var method = call.Operand as IMethod;
					if (!MethodEqualityComparer.CompareDeclaringTypes.Equals(method, CreateStringDelegateMethod))
						continue;

					block.Remove(i, 1);
					break;
				}
			}
		}

		void RemoveInitCode_v2(Blocks blocks) {
			foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {
				var instructions = block.Instructions;
				for (int i = 0; i <= instructions.Count - 3; i++) {
					var ldtoken = instructions[i];
					if (ldtoken.OpCode != OpCodes.Ldtoken)
						continue;
					if (!new SigComparer().Equals(blocks.Method.DeclaringType, ldtoken.Operand as ITypeDefOrRef))
						continue;

					var call1 = instructions[i + 1];
					if (call1.OpCode != OpCodes.Call)
						continue;
					var method1 = call1.Operand as IMethod;
					if (method1 == null || method1.ToString() != "System.Type System.Type::GetTypeFromHandle(System.RuntimeTypeHandle)")
						continue;

					var call2 = instructions[i + 2];
					if (call2.OpCode != OpCodes.Call)
						continue;
					var method2 = call2.Operand as IMethod;
					if (!MethodEqualityComparer.CompareDeclaringTypes.Equals(method2, CreateStringDelegateMethod))
						continue;

					block.Remove(i, 3);
					break;
				}
			}
		}
	}
}



================================================
File: de4dot.code/deobfuscators/SmartAssembly/StringEncoderClassFinder.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.SmartAssembly {
	class StringsEncoderInfo {
		// SmartAssembly.HouseOfCards.Strings, the class that creates the string decrypter
		// delegates
		public TypeDef StringsType { get; set; }
		public TypeDef GetStringDelegate { get; set; }
		public MethodDef CreateStringDelegateMethod { get; set; }

		// The class that decodes the strings. Called by the strings delegate or normal code.
		public TypeDef StringDecrypterClass { get; set; }
	}

	class StringEncoderClassFinder {
		ModuleDefMD module;
		ISimpleDeobfuscator simpleDeobfuscator;
		IList<StringsEncoderInfo> stringsEncoderInfos = new List<StringsEncoderInfo>();

		public IList<StringsEncoderInfo> StringsEncoderInfos => stringsEncoderInfos;

		public StringEncoderClassFinder(ModuleDefMD module, ISimpleDeobfuscator simpleDeobfuscator) {
			this.module = module;
			this.simpleDeobfuscator = simpleDeobfuscator;
		}

		TypeDef GetType(ITypeDefOrRef typeRef) => DotNetUtils.GetType(module, typeRef);

		public void Find() {
			FindHouseOfCardsStrings_v2();
			if (stringsEncoderInfos.Count == 0)
				FindHouseOfCardsStrings_v1();

			FindStringDecrypterClasses();
		}

		// Finds SmartAssembly.HouseOfCards.Strings. It's the class that creates the string
		// decrypter delegates.
		void FindHouseOfCardsStrings_v2() {
			foreach (var type in module.Types) {
				if (type.Methods.Count != 1)
					continue;
				foreach (var method in DotNetUtils.FindMethods(type.Methods, "System.Void", new string[] { "System.Type" })) {
					if (CheckDelegateCreatorMethod(type, method))
						break;
				}
			}
		}

		void FindHouseOfCardsStrings_v1() {
			foreach (var type in module.Types) {
				if (type.Methods.Count != 1)
					continue;
				foreach (var method in DotNetUtils.FindMethods(type.Methods, "System.Void", new string[] { })) {
					if (CheckDelegateCreatorMethod(type, method))
						break;
				}
			}
		}

		bool CheckDelegateCreatorMethod(TypeDef type, MethodDef method) {
			simpleDeobfuscator.Deobfuscate(method);

			var getStringDelegate = FindGetStringDelegate(method);
			if (getStringDelegate == null)
				return false;

			var stringDecrypterClass = FindStringDecrypterClass(method);
			if (stringDecrypterClass == null)
				return false;

			stringsEncoderInfos.Add(new StringsEncoderInfo {
				StringsType = type,
				GetStringDelegate = getStringDelegate,
				StringDecrypterClass = stringDecrypterClass,
				CreateStringDelegateMethod = method,
			});

			return true;
		}

		// Finds the SmartAssembly.Delegates.GetString delegate
		TypeDef FindGetStringDelegate(MethodDef stringsCreateDelegateMethod) {
			if (!stringsCreateDelegateMethod.HasBody)
				return null;

			foreach (var ldtoken in stringsCreateDelegateMethod.Body.Instructions) {
				if (ldtoken.OpCode.Code != Code.Ldtoken)
					continue;
				var typeToken = ldtoken.Operand as ITypeDefOrRef;
				if (typeToken == null)
					continue;
				var delegateType = GetType(typeToken);
				if (!DotNetUtils.DerivesFromDelegate(delegateType))
					continue;
				var invoke = delegateType.FindMethod("Invoke");
				if (invoke == null || !DotNetUtils.IsMethod(invoke, "System.String", "(System.Int32)"))
					continue;

				return delegateType;
			}

			return null;
		}

		// Finds the SmartAssembly.StringsEncoding.Strings class. This class decrypts the
		// strings in the resources. It gets called by the SmartAssembly.Delegates.GetString
		// delegate instances which were created by SmartAssembly.HouseOfCards.Strings.
		TypeDef FindStringDecrypterClass(MethodDef stringsCreateDelegateMethod) {
			if (!stringsCreateDelegateMethod.HasBody)
				return null;

			foreach (var ldtoken in stringsCreateDelegateMethod.Body.Instructions) {
				if (ldtoken.OpCode.Code != Code.Ldtoken)
					continue;
				var typeToken = ldtoken.Operand as ITypeDefOrRef;
				if (typeToken == null)
					continue;
				var type = GetType(typeToken);
				if (type == null || DotNetUtils.DerivesFromDelegate(type))
					continue;
				if (!CouldBeStringDecrypterClass(type))
					continue;

				return type;
			}

			return null;
		}

		void FindStringDecrypterClasses() {
			var foundClasses = new Dictionary<TypeDef, bool>();
			foreach (var info in stringsEncoderInfos)
				foundClasses[info.StringDecrypterClass] = true;

			foreach (var type in module.Types) {
				if (!foundClasses.ContainsKey(type) && CouldBeStringDecrypterClass(type)) {
					stringsEncoderInfos.Add(new StringsEncoderInfo {
						StringsType = null,
						GetStringDelegate = null,
						StringDecrypterClass = type,
					});
				}
			}
		}

		static string[] fields1x = new string[] {
			"System.IO.Stream",
		};
		static string[] fields2x = new string[] {
			"System.IO.Stream",
			"System.Int32",
		};
		static string[] fields3x = new string[] {
			"System.Byte[]",
			"System.Int32",
		};
		bool CouldBeStringDecrypterClass(TypeDef type) {
			var fields = new FieldTypes(type);
			if (fields.Exists("System.Collections.Hashtable") ||
				fields.Exists("System.Collections.Generic.Dictionary`2<System.Int32,System.String>") ||
				fields.Exactly(fields3x)) {
				if (type.FindStaticConstructor() == null)
					return false;
			}
			else if (fields.Exactly(fields1x) || fields.Exactly(fields2x)) {
			}
			else
				return false;

			var methods = new List<MethodDef>(DotNetUtils.GetNormalMethods(type));
			if (methods.Count != 1)
				return false;
			var method = methods[0];
			if (!DotNetUtils.IsMethod(method, "System.String", "(System.Int32)"))
				return false;
			if (!method.IsStatic || !method.HasBody)
				return false;

			return true;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/SmartAssembly/TamperProtectionRemover.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.SmartAssembly {
	class TamperProtectionRemover {
		ModuleDefMD module;
		List<MethodDef> pinvokeMethods = new List<MethodDef>();

		enum Type {
			V1,
			V2,
		}

		public IList<MethodDef> PinvokeMethods => pinvokeMethods;
		public TamperProtectionRemover(ModuleDefMD module) => this.module = module;

		public bool Remove(Blocks blocks) {
			if (blocks.Method.Name != ".cctor")
				return false;
			return RemoveTamperProtection(blocks);
		}

		bool IsTamperProtected(IEnumerable<Block> allBlocks) {
			foreach (var block in allBlocks) {
				foreach (var instr in block.Instructions) {
					if (instr.OpCode != OpCodes.Ldstr)
						continue;
					var s = instr.Operand as string;
					if (s == "Assembly has been tampered")
						return true;
				}
			}
			return false;
		}

		class BlockInfo {
			public Block Block { get; set; }
			public int Start { get; set; }
			public int End { get; set; }
		}

		class TamperBlocks {
			public Type type;
			public MethodDef pinvokeMethod;
			public BlockInfo first;
			public BlockInfo second;
			public BlockInfo bad;
		}

		TamperBlocks FindTamperBlocks(Blocks blocks, IList<Block> allBlocks) {
			var tamperBlocks = new TamperBlocks();

			if (!FindFirstBlocks(tamperBlocks, allBlocks, blocks.Locals))
				return null;

			var second = tamperBlocks.second;
			var badBlock = second.Block.LastInstr.IsBrfalse() ? second.Block.Targets[0] : second.Block.FallThrough;
			tamperBlocks.bad = FindBadBlock(badBlock);
			if (tamperBlocks.bad == null)
				return null;

			return tamperBlocks;
		}

		bool FindFirstBlocks(TamperBlocks tamperBlocks, IList<Block> allBlocks, IList<Local> locals) {
			foreach (var b in allBlocks) {
				try {
					if (FindFirstBlocks(b, tamperBlocks, allBlocks, locals))
						return true;
				}
				catch (ArgumentOutOfRangeException) {
					continue;
				}
			}

			return false;
		}

		static int FindCallMethod(Block block, int index, bool keepLooking, Func<IMethod, bool> func) {
			var instrs = block.Instructions;
			for (int i = index; i < instrs.Count; i++) {
				var instr = instrs[i];
				if (instr.OpCode.Code != Code.Call && instr.OpCode.Code != Code.Callvirt)
					continue;

				if (instr.Operand is IMethod calledMethod && func(calledMethod))
					return i;
				if (!keepLooking)
					return -1;
			}
			return -1;
		}

		bool FindFirstBlocks(Block block, TamperBlocks tamperBlocks, IList<Block> allBlocks, IList<Local> locals) {
			if (!block.LastInstr.IsBrfalse())
				return false;

			/*
			 * ldc.i4.0
			 * stloc X
			 * call GetExecutingAssembly()
			 * stloc Y
			 * ldloc Y
			 * callvirt Location
			 * ldc.i4.1
			 * ldloca X
			 * call StrongNameSignatureVerificationEx
			 * pop / brfalse bad_code
			 * ldloc X
			 * brfalse bad_code
			 * ldloc Y
			 * callvirt FullName()
			 * ldstr "......"
			 * callvirt EndsWith(string)
			 * brfalse bad_code / brtrue good_code
			 */

			/*
			0	0000	ldc.i4.0
			1	0001	stloc.1
			2	0002	call	class [mscorlib]System.Reflection.Assembly [mscorlib]System.Reflection.Assembly::GetExecutingAssembly()
			3	0007	stloc.0
			4	0008	ldloc.0
			5	0009	callvirt	instance string [mscorlib]System.Reflection.Assembly::get_CodeBase()
			6	000E	ldstr	"%"
			7	0013	ldstr	"%25"
			8	0018	callvirt	instance string [mscorlib]System.String::Replace(string, string)
			9	001D	ldstr	"#"
			10	0022	ldstr	"%23"
			11	0027	callvirt	instance string [mscorlib]System.String::Replace(string, string)
			12	002C	newobj	instance void [System]System.Uri::.ctor(string)
			13	0031	stloc.2
			14	0032	ldloc.2
			15	0033	callvirt	instance string [System]System.Uri::get_LocalPath()
			16	0038	ldc.i4.1
			17	0039	ldloca.s	V_1 (1)
			18	003B	call	bool LiquidTechnologies.Licensing.ClientLicenseManager2::StrongNameSignatureVerificationEx(string, bool, bool&)
			19	0040	brfalse.s	27 (0057) ldstr "Assembly has been tampered"
			20	0042	ldloc.1
			21	0043	brfalse.s	27 (0057) ldstr "Assembly has been tampered"
			22	0045	ldloc.0
			23	0046	callvirt	instance string [mscorlib]System.Reflection.Assembly::get_FullName()
			24	004B	ldstr	"aabbccddee123456"
			25	0050	callvirt	instance bool [mscorlib]System.String::EndsWith(string)
			26	0055	brtrue.s	30 (0062) ret 
			27	0057	ldstr	"Assembly has been tampered"
			28	005C	newobj	instance void [mscorlib]System.Security.SecurityException::.ctor(string)
			29	0061	throw
			30	0062	ret
			*/
			
			var instrs = block.Instructions;
			int end = instrs.Count - 1;
			Instr instr;
			IMethod method;
			tamperBlocks.type = Type.V1;

			int index = 0;

			int start = FindCallMethod(block, index, true, (calledMethod) => calledMethod.ToString() == "System.Reflection.Assembly System.Reflection.Assembly::GetExecutingAssembly()");
			if (start < 0)
				return false;
			index = start + 1;
			instr = instrs[--start];
			if (!instr.IsStloc())
				return false;
			var loc0 = Instr.GetLocalVar(locals, instr);
			instr = instrs[--start];
			if (!instr.IsLdcI4())
				return false;

			int index2 = index;
			index = FindCallMethod(block, index, false, (calledMethod) => calledMethod.ToString() == "System.String System.Reflection.Assembly::get_Location()");
			if (index < 0) {
				index = index2;
				index = FindCallMethod(block, index, false, (calledMethod) => calledMethod.ToString() == "System.String System.Reflection.Assembly::get_CodeBase()");
				if (index < 0)
					return false;
			}
			index++;
			index2 = index;

			index = FindCallMethod(block, index, false, (calledMethod) => {
				tamperBlocks.pinvokeMethod = DotNetUtils.GetMethod(module, calledMethod);
				return DotNetUtils.IsPinvokeMethod(tamperBlocks.pinvokeMethod, "mscorwks", "StrongNameSignatureVerificationEx");
			});
			if (index < 0) {
				index = index2;

				index = FindCallMethod(block, index, false, (calledMethod) => calledMethod.ToString() == "System.String System.String::Replace(System.String,System.String)");
				if (index < 0) return false;
				index++;
				index2 = index;

				index = FindCallMethod(block, index, false, (calledMethod) => calledMethod.ToString() == "System.String System.String::Replace(System.String,System.String)");
				if (index < 0) return false;
				index++;
				index2 = index;

				index = FindCallMethod(block, index, false, (calledMethod) => calledMethod.ToString() == "System.String System.Uri::get_LocalPath()");
				if (index < 0) return false;
				index2 = index + 1;
				instr = instrs[--index];
				if (!instr.IsLdloc()) return false;
				instr = instrs[--index];
				if (!instr.IsStloc()) return false;
				index = index2;

				index = FindCallMethod(block, index, false, (calledMethod) => {
					tamperBlocks.pinvokeMethod = DotNetUtils.GetMethod(module, calledMethod);
					return DotNetUtils.IsPinvokeMethod(tamperBlocks.pinvokeMethod, "mscorwks", "StrongNameSignatureVerificationEx");
				});
				if (index < 0) return false;
			}
			index++;

			if (!instrs[index].IsBrfalse()) {
				if (instrs[index].OpCode.Code != Code.Pop)
					return false;
				instr = instrs[index + 1];
				if (!instr.IsLdloc() || Instr.GetLocalVar(locals, instr) != loc0)
					return false;
				if (!instrs[index + 2].IsBrfalse())
					return false;

				tamperBlocks.type = Type.V1;
				tamperBlocks.first = new BlockInfo {
					Block = block,
					Start = start,
					End = end,
				};
			}
			else {
				tamperBlocks.type = Type.V2;
				tamperBlocks.first = new BlockInfo {
					Block = block,
					Start = start,
					End = end,
				};

				block = block.FallThrough;
				if (block == null)
					return false;
				instrs = block.Instructions;
				index = 0;
				instr = instrs[index];
				if (!instr.IsLdloc() || Instr.GetLocalVar(locals, instr) != loc0)
					return false;
				if (!instrs[index + 1].IsBrfalse())
					return false;
			}

			block = block.FallThrough;
			instrs = block.Instructions;
			start = end = 0;

			instr = instrs[end++];
			if (!instr.IsLdloc())
				return false;

			instr = instrs[end++];
			if (instr.OpCode != OpCodes.Callvirt)
				return false;
			method = instr.Operand as IMethod;
			if (method == null || method.ToString() != "System.String System.Reflection.Assembly::get_FullName()")
				return false;

			instr = instrs[end++];
			if (instr.OpCode != OpCodes.Ldstr)
				return false;

			instr = instrs[end++];
			if (instr.OpCode != OpCodes.Callvirt)
				return false;
			method = instr.Operand as IMethod;
			if (method == null || method.ToString() != "System.Boolean System.String::EndsWith(System.String)")
				return false;

			instr = instrs[end++];
			if (!instr.IsBrfalse() && !instr.IsBrtrue())
				return false;

			end--;
			tamperBlocks.second = new BlockInfo {
				Block = block,
				Start = start,
				End = end,
			};

			return true;
		}

		BlockInfo FindBadBlock(Block last) {
			/*
			 * ldstr "........."
			 * newobj	System.Security.SecurityException(string)
			 * throw
			 */

			var instrs = last.Instructions;
			if (instrs.Count != 3)
				return null;

			Instr instr;
			int start = 0;
			int end = 0;

			instr = instrs[end++];
			if (instr.OpCode != OpCodes.Ldstr)
				return null;

			instr = instrs[end++];
			if (instr.OpCode != OpCodes.Newobj)
				return null;
			var method = instr.Operand as IMethod;
			if (method == null || method.ToString() != "System.Void System.Security.SecurityException::.ctor(System.String)")
				return null;

			instr = instrs[end++];
			if (instr.OpCode != OpCodes.Throw)
				return null;

			end--;
			return new BlockInfo {
				Block = last,
				Start = start,
				End = end,
			};
		}

		bool RemoveTamperProtection(Blocks blocks) {
			var allBlocks = blocks.MethodBlocks.GetAllBlocks();
			var tamperBlocks = FindTamperBlocks(blocks, allBlocks);

			if (tamperBlocks == null) {
				if (IsTamperProtected(allBlocks))
					Logger.w("Could not remove tamper protection code: {0} ({1:X8})", Utils.RemoveNewlines(blocks.Method), blocks.Method.MDToken.ToUInt32());
				return false;
			}

			switch (tamperBlocks.type) {
			case Type.V1:
				RemoveTamperV1(tamperBlocks);
				break;
			case Type.V2:
				RemoveTamperV2(tamperBlocks);
				break;
			default:
				throw new ApplicationException("Unknown type");
			}
			pinvokeMethods.Add(tamperBlocks.pinvokeMethod);

			return true;
		}

		void RemoveTamperV1(TamperBlocks tamperBlocks) {
			var first = tamperBlocks.first;
			var second = tamperBlocks.second;
			var bad = tamperBlocks.bad;
			var goodBlock = second.Block.LastInstr.IsBrtrue() ? second.Block.Targets[0] : second.Block.FallThrough;

			if (first.Block.Targets.Count != 1 || first.Block.Targets[0] != bad.Block)
				throw new ApplicationException("Invalid state");

			first.Block.Remove(first.Start, first.End - first.Start + 1);
			first.Block.ReplaceLastInstrsWithBranch(0, goodBlock);
			RemoveDeadBlock(second.Block);
			RemoveDeadBlock(bad.Block);
		}

		void RemoveTamperV2(TamperBlocks tamperBlocks) {
			var first = tamperBlocks.first;
			var second = tamperBlocks.second.Block;
			var bad = tamperBlocks.bad.Block;
			var firstFallthrough = first.Block.FallThrough;
			var goodBlock = second.LastInstr.IsBrtrue() ? second.Targets[0] : second.FallThrough;

			if (first.Block.Targets.Count != 1 || first.Block.Targets[0] != bad)
				throw new ApplicationException("Invalid state");

			first.Block.Remove(first.Start, first.End - first.Start + 1);
			first.Block.ReplaceLastInstrsWithBranch(0, goodBlock);
			RemoveDeadBlock(firstFallthrough);
			RemoveDeadBlock(second);
			RemoveDeadBlock(bad);
		}

		void RemoveDeadBlock(Block block) {
			var parent = block.Parent;
			if (parent != null)	// null if already dead
				parent.RemoveDeadBlock(block);
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Spices_Net/Deobfuscator.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using de4dot.blocks;
using de4dot.blocks.cflow;

namespace de4dot.code.deobfuscators.Spices_Net {
	public class DeobfuscatorInfo : DeobfuscatorInfoBase {
		public const string THE_NAME = "Spices.Net";
		public const string THE_TYPE = "sn";
		const string DEFAULT_REGEX = @"!^[a-zA-Z0-9]{1,2}$&" + DeobfuscatorBase.DEFAULT_ASIAN_VALID_NAME_REGEX;
		BoolOption inlineMethods;
		BoolOption removeInlinedMethods;
		BoolOption removeNamespaces;
		BoolOption restoreResourceNames;

		public DeobfuscatorInfo()
			: base(DEFAULT_REGEX) {
			inlineMethods = new BoolOption(null, MakeArgName("inline"), "Inline short methods", true);
			removeInlinedMethods = new BoolOption(null, MakeArgName("remove-inlined"), "Remove inlined methods", true);
			removeNamespaces = new BoolOption(null, MakeArgName("ns1"), "Clear namespace if there's only one class in it", true);
			restoreResourceNames = new BoolOption(null, MakeArgName("rsrc"), "Restore resource names", true);
		}

		public override string Name => THE_NAME;
		public override string Type => THE_TYPE;

		public override IDeobfuscator CreateDeobfuscator() =>
			new Deobfuscator(new Deobfuscator.Options {
				ValidNameRegex = validNameRegex.Get(),
				InlineMethods = inlineMethods.Get(),
				RemoveInlinedMethods = removeInlinedMethods.Get(),
				RemoveNamespaces = removeNamespaces.Get(),
				RestoreResourceNames = restoreResourceNames.Get(),
			});

		protected override IEnumerable<Option> GetOptionsInternal() =>
			new List<Option>() {
				inlineMethods,
				removeInlinedMethods,
				removeNamespaces,
				restoreResourceNames,
			};
	}

	class Deobfuscator : DeobfuscatorBase {
		Options options;
		bool foundSpicesAttribute = false;
		bool startedDeobfuscating = false;

		StringDecrypter stringDecrypter;
		SpicesMethodCallInliner methodCallInliner;
		ResourceNamesRestorer resourceNamesRestorer;

		internal class Options : OptionsBase {
			public bool InlineMethods { get; set; }
			public bool RemoveInlinedMethods { get; set; }
			public bool RemoveNamespaces { get; set; }
			public bool RestoreResourceNames { get; set; }
		}

		public override string Type => DeobfuscatorInfo.THE_TYPE;
		public override string TypeLong => DeobfuscatorInfo.THE_NAME;
		public override string Name => DeobfuscatorInfo.THE_NAME;
		protected override bool CanInlineMethods => startedDeobfuscating ? options.InlineMethods : true;

		public override IEnumerable<IBlocksDeobfuscator> BlocksDeobfuscators {
			get {
				var list = new List<IBlocksDeobfuscator>();
				if (CanInlineMethods)
					list.Add(methodCallInliner);
				return list;
			}
		}

		public Deobfuscator(Options options)
			: base(options) {
			this.options = options;

			if (options.RemoveNamespaces)
				RenamingOptions |= RenamingOptions.RemoveNamespaceIfOneType;
			else
				RenamingOptions &= ~RenamingOptions.RemoveNamespaceIfOneType;
		}

		protected override int DetectInternal() {
			int val = 0;

			int sum = ToInt32(stringDecrypter.Detected);
			if (sum > 0)
				val += 100 + 10 * (sum - 1);
			if (foundSpicesAttribute)
				val += 10;

			return val;
		}

		protected override void ScanForObfuscator() {
			methodCallInliner = new SpicesMethodCallInliner(module);
			stringDecrypter = new StringDecrypter(module);
			stringDecrypter.Find();
			FindSpicesAttributes();
		}

		void FindSpicesAttributes() {
			foreach (var type in module.Types) {
				switch (type.FullName) {
				case "NineRays.Decompiler.NotDecompile":
				case "NineRays.Obfuscator.Evaluation":
				case "NineRays.Obfuscator.SoftwareWatermarkAttribute":
					AddAttributeToBeRemoved(type, "Obfuscator attribute");
					foundSpicesAttribute = true;
					break;
				}
			}
		}

		public override void DeobfuscateBegin() {
			base.DeobfuscateBegin();

			methodCallInliner.Initialize(DeobfuscatedFile);

			if (options.RestoreResourceNames) {
				resourceNamesRestorer = new ResourceNamesRestorer(module);
				resourceNamesRestorer.Find();
			}

			stringDecrypter.Initialize();
			foreach (var info in stringDecrypter.DecrypterInfos) {
				staticStringInliner.Add(info.method, (method2, gim, args) => {
					return stringDecrypter.Decrypt(method2);
				});
			}
			DeobfuscatedFile.StringDecryptersAdded();

			startedDeobfuscating = true;
		}

		public override void DeobfuscateMethodEnd(Blocks blocks) {
			methodCallInliner.Deobfuscate(blocks);
			if (options.RestoreResourceNames)
				resourceNamesRestorer.Deobfuscate(blocks);
			base.DeobfuscateMethodEnd(blocks);
		}

		public override void DeobfuscateEnd() {
			RemoveInlinedMethods();

			if (options.RestoreResourceNames) {
				resourceNamesRestorer.RenameResources();
				AddTypeToBeRemoved(resourceNamesRestorer.ResourceManagerType, "Obfuscator ResourceManager type");
				AddTypeToBeRemoved(resourceNamesRestorer.ComponentResourceManagerType, "Obfuscator ComponentResourceManager type");
			}

			if (Operations.DecryptStrings != OpDecryptString.None) {
				AddTypeToBeRemoved(stringDecrypter.Type, "String decrypter type");
				AddTypeToBeRemoved(stringDecrypter.EncryptedStringsType, "Encrypted strings field type");
				stringDecrypter.CleanUp();
			}

			base.DeobfuscateEnd();
		}

		void RemoveInlinedMethods() {
			if (!options.InlineMethods || !options.RemoveInlinedMethods)
				return;

			var unusedMethods = new UnusedMethodsFinder(module, methodCallInliner.GetInlinedMethods(), GetRemovedMethods()).Find();
			var removedTypes = methodCallInliner.GetInlinedTypes(unusedMethods);

			AddTypesToBeRemoved(removedTypes.GetKeys(), "Obfuscator methods type");
			foreach (var method in unusedMethods) {
				if (!removedTypes.Find(method.DeclaringType))
					AddMethodToBeRemoved(method, "Inlined method");
			}
		}

		public override IEnumerable<int> GetStringDecrypterMethods() {
			var list = new List<int>();
			foreach (var info in stringDecrypter.DecrypterInfos)
				list.Add(info.method.MDToken.ToInt32());
			return list;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Spices_Net/QclzDecompressor.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

namespace de4dot.code.deobfuscators.Spices_Net {
	class QclzDecompressor : QuickLZBase {
		static int SPICES_QCLZ_SIG = 0x3952534E;	// "9RSN"

		public static byte[] Decompress(byte[] data) {
			if (Read32(data, 0) == SPICES_QCLZ_SIG)
				return QuickLZ.Decompress(data, SPICES_QCLZ_SIG);

			int headerLength, decompressedLength/*, compressedLength*/;
			if ((data[0] & 2) != 0) {
				headerLength = 9;
				/*compressedLength = (int)*/Read32(data, 1);
				decompressedLength = (int)Read32(data, 5);
			}
			else {
				headerLength = 3;
				//compressedLength = data[1];
				decompressedLength = data[2];
			}

			bool isCompressed = (data[0] & 1) != 0;
			byte[] decompressed = new byte[decompressedLength];
			if (isCompressed)
				Decompress(data, headerLength, decompressed);
			else
				Copy(data, headerLength, decompressed, 0, decompressed.Length);

			return decompressed;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Spices_Net/ResourceNamesRestorer.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Spices_Net {
	class ResourceNamesRestorer {
		ModuleDefMD module;
		TypeDef resourceManagerType;
		TypeDef componentResourceManagerType;
		MethodDefAndDeclaringTypeDict<IMethod> resourceManagerCtors = new MethodDefAndDeclaringTypeDict<IMethod>();
		MethodDefAndDeclaringTypeDict<IMethod> componentManagerCtors = new MethodDefAndDeclaringTypeDict<IMethod>();
		Dictionary<TypeDef, bool> callsResourceManager = new Dictionary<TypeDef, bool>();

		public TypeDef ResourceManagerType => resourceManagerType;
		public TypeDef ComponentResourceManagerType => componentResourceManagerType;
		public ResourceNamesRestorer(ModuleDefMD module) => this.module = module;

		public void Find() {
			foreach (var type in module.Types) {
				if (IsResourceType(type, "System.Resources.ResourceManager"))
					resourceManagerType = type;
				else if (IsResourceType(type, "System.ComponentModel.ComponentResourceManager"))
					componentResourceManagerType = type;
			}

			InitializeCtors(resourceManagerType, resourceManagerCtors);
			InitializeCtors(componentResourceManagerType, componentManagerCtors);
		}

		void InitializeCtors(TypeDef manager, MethodDefAndDeclaringTypeDict<IMethod> ctors) {
			if (manager == null)
				return;

			foreach (var ctor in manager.Methods) {
				if (ctor.Name != ".ctor")
					continue;

				var newCtor = new MemberRefUser(module, ctor.Name, ctor.MethodSig.Clone(), manager.BaseType);
				module.UpdateRowId(newCtor);
				ctors.Add(ctor, newCtor);
			}
		}

		static bool IsResourceType(TypeDef type, string baseTypeName) {
			if (type.BaseType == null || type.BaseType.FullName != baseTypeName)
				return false;
			if (type.HasProperties || type.HasEvents || type.HasFields)
				return false;
			if (type.Interfaces.Count > 0)
				return false;
			var method = type.FindMethod("GetResourceFileName");
			if (!DotNetUtils.IsMethod(method, "System.String", "(System.Globalization.CultureInfo)"))
				return false;

			return true;
		}

		class ResourceDictionary {
			struct Key {
				public readonly uint hash;
				public readonly string ns;
				public Key(uint hash, string ns) {
					this.hash = hash;
					this.ns = ns;
				}

				public override int GetHashCode() => (int)(hash ^ ns.GetHashCode());

				public override bool Equals(object obj) {
					if (!(obj is Key))
						return false;
					var other = (Key)obj;
					return hash == other.hash &&
						ns == other.ns;
				}

				public override string ToString() {
					if (ns == string.Empty)
						return $"{hash}";
					return $"{ns}.{hash}";
				}
			}
			Dictionary<Key, Resource> resources = new Dictionary<Key, Resource>();

			public int Count => resources.Count;

			public bool Add(Resource resource) {
				var name = resource.Name.String;
				int index = name.LastIndexOf('.');
				string ext;
				if (index < 0)
					ext = name;
				else
					ext = name.Substring(index + 1);
				if (!uint.TryParse(ext, out uint extNum))
					return false;
				var ns = index < 0 ? string.Empty : name.Substring(0, index);

				resources.Add(new Key(extNum, ns), resource);
				return true;
			}

			public Resource GetAndRemove(uint hash, string ns) {
				var key = new Key(hash, ns);
				if (resources.TryGetValue(key, out var resource))
					resources.Remove(key);
				return resource;
			}
		}

		public void RenameResources() {
			if (resourceManagerType == null && componentResourceManagerType == null)
				return;

			var rsrcDict = new ResourceDictionary();
			foreach (var resource in module.Resources)
				rsrcDict.Add(resource);

			if (module.Assembly != null)
				Rename(rsrcDict, "", module.Assembly.Name + ".g");

			foreach (var type in callsResourceManager.Keys)
				Rename(rsrcDict, type);

			if (rsrcDict.Count != 0) {
				foreach (var type in module.GetTypes()) {
					if (rsrcDict.Count == 0)
						break;
					if (!IsWinFormType(type))
						continue;
					Rename(rsrcDict, type);
				}
			}

			if (rsrcDict.Count != 0) {
				foreach (var type in module.GetTypes()) {
					if (rsrcDict.Count == 0)
						break;
					Rename(rsrcDict, type);
				}
			}

			if (rsrcDict.Count != 0)
				Logger.e("Couldn't restore all renamed resource names");
		}

		static bool IsWinFormType(TypeDef type) {
			for (int i = 0; i < 100; i++) {
				var baseType = type.BaseType;
				if (baseType == null)
					break;
				if (baseType.FullName == "System.Object" ||
					baseType.FullName == "System.ValueType")
					return false;
				// Speed up common cases
				if (baseType.FullName == "System.Windows.Forms.Control" ||
					baseType.FullName == "System.Windows.Forms.Form" ||
					baseType.FullName == "System.Windows.Forms.UserControl")
					return true;
				var resolvedBaseType = baseType.ResolveTypeDef();
				if (resolvedBaseType == null)
					break;
				type = resolvedBaseType;
			}
			return false;
		}

		static bool Rename(ResourceDictionary rsrcDict, TypeDef type) {
			if (!IsWinFormType(type) && Rename(rsrcDict, "", type.FullName))
				return true;
			return Rename(rsrcDict, type.Namespace, type.Name);
		}

		static bool Rename(ResourceDictionary rsrcDict, string ns, string name) {
			var resourceName = name + ".resources";
			uint hash = GetResourceHash(resourceName);
			var resource = rsrcDict.GetAndRemove(hash, ns);
			if (resource == null)
				return false;

			int index = resource.Name.String.LastIndexOf('.');
			string resourceNamespace, newName;
			if (index < 0) {
				resourceNamespace = "";
				newName = resourceName;
			}
			else {
				resourceNamespace = resource.Name.String.Substring(0, index);
				newName = resourceNamespace + "." + resourceName;
			}
			if (resourceNamespace != ns)
				throw new ApplicationException("Invalid resource namespace");

			Logger.v("Restoring resource name: '{0}' => '{1}'",
								Utils.RemoveNewlines(resource.Name),
								Utils.RemoveNewlines(newName));
			resource.Name = newName;
			return true;
		}

		static uint GetResourceHash(string name) {
			uint hash = 0;
			foreach (var c in name)
				hash = Ror(hash ^ c, 1);
			return hash;
		}

		static uint Ror(uint val, int n) => (val << (32 - n)) + (val >> n);

		public void Deobfuscate(Blocks blocks) {
			if (resourceManagerType == null && componentResourceManagerType == null)
				return;

			foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {
				var instrs = block.Instructions;
				for (int i = 0; i < instrs.Count; i++) {
					var instr = instrs[i];
					if (instr.OpCode.Code != Code.Newobj)
						continue;
					var ctor = instr.Operand as IMethod;
					if (ctor == null)
						continue;
					var newCtor = resourceManagerCtors.Find(ctor);
					if (newCtor == null)
						newCtor = componentManagerCtors.Find(ctor);
					if (newCtor == null)
						continue;
					instr.Operand = newCtor;
					callsResourceManager[blocks.Method.DeclaringType] = true;
				}
			}
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Spices_Net/SpicesMethodCallInliner.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;
using de4dot.blocks.cflow;

namespace de4dot.code.deobfuscators.Spices_Net {
	class SpicesMethodCallInliner : MethodCallInliner {
		ModuleDefMD module;
		TypeDefDict<bool> methodsTypes = new TypeDefDict<bool>();
		MethodDefAndDeclaringTypeDict<MethodDef> classMethods = new MethodDefAndDeclaringTypeDict<MethodDef>();

		public SpicesMethodCallInliner(ModuleDefMD module)
			: base(false) => this.module = module;

		protected override bool IsCompatibleType(int paramIndex, IType origType, IType newType) {
			if (new SigComparer(SigComparerOptions.IgnoreModifiers).Equals(origType, newType))
				return true;
			if (paramIndex == -1) {
				if (IsValueType(newType) || IsValueType(origType))
					return false;
			}
			return newType.FullName == "System.Object";
		}

		public bool CheckCanInline(MethodDef method) => methodsTypes.Find(method.DeclaringType);
		protected override bool CanInline(MethodDef method) => CheckCanInline(method);

		public void Initialize(ISimpleDeobfuscator simpleDeobfuscator) {
			InitializeMethodsTypes();
			RestoreMethodBodies(simpleDeobfuscator);
		}

		void RestoreMethodBodies(ISimpleDeobfuscator simpleDeobfuscator) {
			var methodToOrigMethods = new MethodDefAndDeclaringTypeDict<List<MethodDef>>();
			foreach (var t in module.Types) {
				var types = new List<TypeDef>(AllTypesHelper.Types(new List<TypeDef> { t }));
				foreach (var type in types) {
					if (methodsTypes.Find(type))
						continue;
					foreach (var method in type.Methods) {
						if (method.Name == ".ctor" || method.Name == ".cctor")
							continue;

						if (!CheckRestoreBody(method, out var calledMethod))
							continue;
						if (!CheckSameMethods(method, calledMethod))
							continue;
						if (!methodsTypes.Find(calledMethod.DeclaringType))
							continue;
						if (types.IndexOf(calledMethod.DeclaringType) < 0)
							continue;

						var list = methodToOrigMethods.Find(calledMethod);
						if (list == null)
							methodToOrigMethods.Add(calledMethod, list = new List<MethodDef>());
						list.Add(method);
					}
				}
			}

			foreach (var calledMethod in methodToOrigMethods.GetKeys()) {
				var list = methodToOrigMethods.Find(calledMethod);
				var method = list[0];

				Logger.v("Restored method body {0:X8} from method {1:X8}",
							method.MDToken.ToInt32(),
							calledMethod.MDToken.ToInt32());
				DotNetUtils.CopyBodyFromTo(calledMethod, method);
				classMethods.Add(calledMethod, method);
				simpleDeobfuscator.MethodModified(method);
			}
		}

		bool CheckRestoreBody(MethodDef method, out MethodDef calledMethod) {
			calledMethod = null;
			if (method.Body == null)
				return false;
			if (method.Body.Variables.Count > 0)
				return false;
			if (method.Body.ExceptionHandlers.Count > 0)
				return false;

			if (!CheckRestoreBody2(method, out calledMethod))
				return false;
			if (calledMethod == method)
				return false;
			if (!calledMethod.IsStatic)
				return false;
			if (calledMethod.GenericParameters.Count > 0)
				return false;
			if (calledMethod.Body == null || calledMethod.Body.Instructions.Count == 0)
				return false;

			return true;
		}

		bool CheckRestoreBody2(MethodDef instanceMethod, out MethodDef calledMethod) {
			calledMethod = null;

			var instrs = instanceMethod.Body.Instructions;
			int index;
			for (index = 0; index < instrs.Count; index++) {
				if (instrs[index].GetParameterIndex() != index)
					break;
			}
			var call = instrs[index++];
			if (call.OpCode.Code != Code.Call)
				return false;

			calledMethod = call.Operand as MethodDef;
			if (calledMethod == null)
				return false;

			if (instrs[index++].OpCode.Code != Code.Ret)
				return false;

			return true;
		}

		void InitializeMethodsTypes() {
			foreach (var type in module.GetTypes()) {
				if (CheckMethodsType(type))
					methodsTypes.Add(type, true);
			}
		}

		static bool CheckMethodsType(TypeDef type) {
			if (!type.IsNested)
				return false;
			if ((type.Attributes & ~TypeAttributes.BeforeFieldInit) != TypeAttributes.NestedAssembly)
				return false;
			if (type.HasProperties || type.HasEvents || type.HasFields || type.HasNestedTypes)
				return false;
			if (type.GenericParameters.Count > 0)
				return false;
			if (type.IsValueType || type.IsInterface)
				return false;
			if (type.BaseType == null || type.BaseType.FullName != "System.Object")
				return false;
			if (type.Interfaces.Count > 0)
				return false;
			if (!CheckMethods(type))
				return false;

			return true;
		}

		static bool CheckMethods(TypeDef type) {
			bool foundCtor = false;
			int numMethods = 0;

			foreach (var method in type.Methods) {
				if (method.Name == ".cctor")
					return false;
				if (method.Name == ".ctor") {
					if (method.MethodSig.GetParamCount() != 0)
						return false;
					foundCtor = true;
					continue;
				}
				if (method.Attributes != (MethodAttributes.Assembly | MethodAttributes.Static | MethodAttributes.HideBySig))
					return false;
				if (method.ImplMap != null)
					return false;
				if (method.GenericParameters.Count > 0)
					return false;

				numMethods++;
			}

			return numMethods > 0 && foundCtor;
		}

		public List<MethodDef> GetInlinedMethods() {
			var list = new List<MethodDef>();

			foreach (var type in methodsTypes.GetKeys())
				list.AddRange(type.Methods);

			return list;
		}

		public TypeDefDict<bool> GetInlinedTypes(IEnumerable<MethodDef> unusedMethods) {
			var unused = new MethodDefAndDeclaringTypeDict<bool>();
			foreach (var method in unusedMethods)
				unused.Add(method, true);

			var types = new TypeDefDict<bool>();
			foreach (var type in methodsTypes.GetKeys()) {
				if (CheckAllMethodsUnused(unused, type))
					types.Add(type, true);
			}
			return types;
		}

		static bool CheckAllMethodsUnused(MethodDefAndDeclaringTypeDict<bool> unused, TypeDef type) {
			foreach (var method in type.Methods) {
				if (!unused.Find(method))
					return false;
			}
			return true;
		}

		public void Deobfuscate(Blocks blocks) {
			foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {
				var instrs = block.Instructions;
				for (int i = 0; i < instrs.Count; i++) {
					var call = instrs[i];
					if (call.OpCode.Code != Code.Call)
						continue;
					var realInstanceMethod = classMethods.Find(call.Operand as IMethod);
					if (realInstanceMethod == null)
						continue;
					call.Operand = realInstanceMethod;
				}
			}
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Spices_Net/StringDecrypter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Text;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Spices_Net {
	class StringDecrypter {
		ModuleDefMD module;
		TypeDef decrypterType;
		FieldDef encryptedDataField;
		StringDataFlags stringDataFlags;
		MethodDefAndDeclaringTypeDict<DecrypterInfo> methodToInfo = new MethodDefAndDeclaringTypeDict<DecrypterInfo>();
		byte[] decryptedData;
		byte[] key;
		byte[] iv;

		[Flags]
		enum StringDataFlags {
			Compressed = 0x1,
			Encrypted1 = 0x2,
			Encrypted2 = 0x4,
			Encrypted3DES = 0x8,
		}

		public class DecrypterInfo {
			public MethodDef method;
			public int offset;
			public int length;

			public DecrypterInfo(MethodDef method, int offset, int length) {
				this.method = method;
				this.offset = offset;
				this.length = length;
			}
		}

		public TypeDef EncryptedStringsType {
			get {
				if (encryptedDataField == null)
					return null;
				var type = encryptedDataField.FieldSig.GetFieldType().TryGetTypeDef();
				if (type == null || type.Fields.Count != 1 || type.Fields[0] != encryptedDataField)
					return null;
				if (type.HasMethods || type.HasEvents || type.HasProperties || type.HasNestedTypes)
					return null;
				if (type.Interfaces.Count > 0)
					return null;

				return type;
			}
		}

		public TypeDef Type => decrypterType;
		public bool Detected => decrypterType != null;
		public IEnumerable<DecrypterInfo> DecrypterInfos => methodToInfo.GetValues();
		public StringDecrypter(ModuleDefMD module) => this.module = module;

		public void Find() {
			foreach (var type in module.Types) {
				if (type.HasNestedTypes || type.HasInterfaces)
					continue;
				if (type.HasEvents || type.HasProperties)
					continue;
				if (type.Fields.Count < 2 || type.Fields.Count > 3)
					continue;
				if ((type.Attributes & ~TypeAttributes.Sealed) != 0)
					continue;
				if (type.BaseType == null || type.BaseType.FullName != "System.Object")
					continue;
				if (HasInstanceMethods(type))
					continue;
				var cctor = type.FindStaticConstructor();
				if (cctor == null)
					continue;

				if (!CheckCctor(cctor, out var encryptedDataFieldTmp, out var stringDataFlagsTmp))
					continue;

				if (!InitializeDecrypterInfos(type))
					continue;

				encryptedDataField = encryptedDataFieldTmp;
				stringDataFlags = stringDataFlagsTmp;
				decrypterType = type;
				return;
			}
		}

		static bool HasInstanceMethods(TypeDef type) {
			foreach (var method in type.Methods) {
				if (!method.IsStatic)
					return true;
				if (method.ImplMap != null)
					return true;
			}
			return false;
		}

		bool CheckCctor(MethodDef cctor, out FieldDef compressedDataField, out StringDataFlags flags) {
			flags = 0;
			var instructions = cctor.Body.Instructions;
			for (int i = 0; i < instructions.Count; i++) {
				var ldci4 = instructions[i];
				if (!ldci4.IsLdcI4())
					continue;

				var instrs = DotNetUtils.GetInstructions(instructions, i + 1, OpCodes.Newarr, OpCodes.Dup, OpCodes.Ldtoken, OpCodes.Call);
				if (instrs == null)
					continue;

				var newarr = instrs[0];
				if (newarr.Operand.ToString() != "System.Byte")
					continue;

				var field = instrs[2].Operand as FieldDef;
				if (field == null || field.InitialValue == null || field.InitialValue.Length == 0)
					continue;

				int index = i + 1 + instrs.Count;
				if (index < instructions.Count && instructions[index].OpCode.Code == Code.Call)
					flags = GetStringDataFlags(instructions[index].Operand as MethodDef);

				compressedDataField = field;
				return true;
			}

			compressedDataField = null;
			return false;
		}

		StringDataFlags GetStringDataFlags(MethodDef method) {
			if (method == null || method.Body == null)
				return 0;
			var sig = method.MethodSig;
			if (sig == null || sig.Params.Count != 1)
				return 0;
			if (!CheckClass(sig.Params[0], "System.Byte[]"))
				return 0;
			if (!CheckClass(sig.RetType, "System.Byte[]"))
				return 0;

			StringDataFlags flags = 0;

			if (HasInstruction(method, Code.Not))
				flags |= StringDataFlags.Encrypted2;
			else if (HasInstruction(method, Code.Xor))
				flags |= StringDataFlags.Encrypted1;
			else if (Check3DesCreator(method))
				flags |= StringDataFlags.Encrypted3DES;
			if (CallsDecompressor(method))
				flags |= StringDataFlags.Compressed;

			return flags;
		}

		bool Check3DesCreator(MethodDef method) {
			foreach (var instr in method.Body.Instructions) {
				if (instr.OpCode.Code != Code.Call)
					continue;
				var calledMethod = instr.Operand as MethodDef;
				if (calledMethod == null)
					continue;
				var sig = calledMethod.MethodSig;
				if (sig == null || sig.RetType.GetElementType() == ElementType.Void)
					continue;
				if (sig.Params.Count != 0)
					continue;
				if (!Get3DesKeyIv(calledMethod, ref key, ref iv))
					continue;

				return true;
			}
			return false;
		}

		bool Get3DesKeyIv(MethodDef method, ref byte[] key, ref byte[] iv) {
			if (!new LocalTypes(method).Exists("System.Security.Cryptography.TripleDESCryptoServiceProvider"))
				return false;

			var instrs = method.Body.Instructions;
			var arrays = ArrayFinder.GetArrays(method, module.CorLibTypes.Byte);
			if (arrays.Count != 1 && arrays.Count != 2)
				return false;

			key = arrays[0];
			if (arrays.Count == 1) {
				var pkt = PublicKeyBase.ToPublicKeyToken(module.Assembly.PublicKey);
				iv = pkt?.Data;
			}
			else
				iv = arrays[1];
			return true;
		}

		static bool CallsDecompressor(MethodDef method) {
			foreach (var instr in method.Body.Instructions) {
				if (instr.OpCode.Code != Code.Call)
					continue;
				var called = instr.Operand as MethodDef;
				if (called == null)
					continue;
				var sig = called.MethodSig;
				if (sig == null)
					continue;
				if (sig.RetType.GetElementType() != ElementType.I4)
					continue;
				var parameters = sig.Params;
				if (parameters.Count != 4)
					continue;
				if (!CheckClass(parameters[0], "System.Byte[]"))
					continue;
				if (parameters[1].GetElementType() != ElementType.I4)
					continue;
				if (!CheckClass(parameters[2], "System.Byte[]"))
					continue;
				if (parameters[3].GetElementType() != ElementType.I4)
					continue;

				return true;
			}
			return false;
		}

		static bool HasInstruction(MethodDef method, Code code) {
			foreach (var instr in method.Body.Instructions) {
				if (instr.OpCode.Code == code)
					return true;
			}
			return false;
		}

		static bool CheckClass(TypeSig type, string fullName) =>
			type != null && (type.ElementType == ElementType.Object || type.FullName == fullName);

		static bool IsStringType(TypeSig type) =>
			type != null && (type.ElementType == ElementType.Object || type.ElementType == ElementType.String);

		bool InitializeDecrypterInfos(TypeDef type) {
			foreach (var method in type.Methods) {
				if (!method.IsStatic || method.Body == null)
					continue;
				var sig = method.MethodSig;
				if (sig == null)
					continue;
				if (sig.Params.Count != 0)
					continue;
				if (!IsStringType(sig.RetType))
					continue;

				var info = CreateInfo(method);
				if (info == null)
					continue;

				methodToInfo.Add(method, info);
			}

			return methodToInfo.Count != 0;
		}

		DecrypterInfo CreateInfo(MethodDef method) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 1; i++) {
				var ldci4_1 = instrs[i];
				var ldci4_2 = instrs[i + 1];
				if (!ldci4_1.IsLdcI4() || !ldci4_2.IsLdcI4())
					continue;

				int offset = ldci4_1.GetLdcI4Value();
				int length = ldci4_2.GetLdcI4Value();
				return new DecrypterInfo(method, offset, length);
			}

			return null;
		}

		public void Initialize() {
			if (decrypterType == null)
				return;

			decryptedData = new byte[encryptedDataField.InitialValue.Length];
			Array.Copy(encryptedDataField.InitialValue, 0, decryptedData, 0, decryptedData.Length);

			if ((stringDataFlags & StringDataFlags.Encrypted1) != 0) {
				for (int i = 0; i < decryptedData.Length; i++)
					decryptedData[i] ^= (byte)i;
			}

			if ((stringDataFlags & StringDataFlags.Encrypted2) != 0) {
				var k = module.Assembly.PublicKey.Data;
				int mask = (byte)(~k.Length);
				for (int i = 0; i < decryptedData.Length; i++)
					decryptedData[i] ^= k[i & mask];
			}

			if ((stringDataFlags & StringDataFlags.Encrypted3DES) != 0)
				decryptedData = DeobUtils.Des3Decrypt(decryptedData, key, iv);

			if ((stringDataFlags & StringDataFlags.Compressed) != 0)
				decryptedData = QclzDecompressor.Decompress(decryptedData);
		}

		public void CleanUp() {
			if (decrypterType == null)
				return;

			encryptedDataField.InitialValue = new byte[1];
			encryptedDataField.FieldSig.Type = module.CorLibTypes.Byte;
			encryptedDataField.RVA = 0;
		}

		public string Decrypt(MethodDef method) {
			var info = methodToInfo.Find(method);
			return Encoding.Unicode.GetString(decryptedData, info.offset, info.length);
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Unknown/Deobfuscator.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using System.Text.RegularExpressions;

namespace de4dot.code.deobfuscators.Unknown {
	public class DeobfuscatorInfo : DeobfuscatorInfoBase {
		public const string THE_NAME = "Unknown";
		public const string THE_TYPE = "un";
		const string DEFAULT_REGEX = DeobfuscatorBase.DEFAULT_VALID_NAME_REGEX;

		public DeobfuscatorInfo()
			: base(DEFAULT_REGEX) {
		}

		public override string Name => THE_NAME;
		public override string Type => THE_TYPE;

		public override IDeobfuscator CreateDeobfuscator() =>
			new Deobfuscator(new Deobfuscator.Options {
				RenameResourcesInCode = false,
				ValidNameRegex = validNameRegex.Get(),
			});
	}

	class Deobfuscator : DeobfuscatorBase {
		string obfuscatorName;

		internal class Options : OptionsBase {
		}

		public override string Type => DeobfuscatorInfo.THE_TYPE;
		public override string TypeLong => DeobfuscatorInfo.THE_NAME;
		public override string Name => obfuscatorName ?? "Unknown Obfuscator";

		internal Deobfuscator(Options options)
			: base(options) => KeepTypes = true;

		void SetName(string name) {
			if (obfuscatorName == null && name != null)
				obfuscatorName = $"{name} (not supported)";
		}

		protected override int DetectInternal() {
			SetName(ScanTypes());
			return 1;
		}

		protected override void ScanForObfuscator() {
		}

		string ScanTypes() {
			foreach (var type in module.Types) {
				var fn = type.FullName;
				if (fn == "ZYXDNGuarder")
					return "DNGuard HVM";
				if (type.Name.String.Contains("();\t"))
					return "Manco .NET Obfuscator";
				if (Regex.IsMatch(fn, @"^EMyPID_\d+_$"))
					return "BitHelmet Obfuscator";
				if (fn == "YanoAttribute")
					return "Yano Obfuscator";
			}
			return null;
		}

		public override IEnumerable<int> GetStringDecrypterMethods() => new List<int>();
	}
}



================================================
File: de4dot.code/deobfuscators/Xenocode/Deobfuscator.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet;

namespace de4dot.code.deobfuscators.Xenocode {
	public class DeobfuscatorInfo : DeobfuscatorInfoBase {
		public const string THE_NAME = "Xenocode";
		public const string THE_TYPE = "xc";
		const string DEFAULT_REGEX = @"!^[oO01l]{4,}$&!^(get_|set_|add_|remove_|_)?[x_][a-f0-9]{16,}$&" + DeobfuscatorBase.DEFAULT_ASIAN_VALID_NAME_REGEX;

		public DeobfuscatorInfo()
			: base(DEFAULT_REGEX) {
		}

		public override string Name => THE_NAME;
		public override string Type => THE_TYPE;

		public override IDeobfuscator CreateDeobfuscator() =>
			new Deobfuscator(new Deobfuscator.Options {
				ValidNameRegex = validNameRegex.Get(),
			});
	}

	class Deobfuscator : DeobfuscatorBase {
		bool foundXenocodeAttribute = false;
		StringDecrypter stringDecrypter;

		internal class Options : OptionsBase {
		}

		public override string Type => DeobfuscatorInfo.THE_TYPE;
		public override string TypeLong => DeobfuscatorInfo.THE_NAME;
		public override string Name => TypeLong;

		public Deobfuscator(Options options)
			: base(options) {
		}

		protected override int DetectInternal() {
			int val = 0;

			if (stringDecrypter.Detected)
				val += 100;
			if (foundXenocodeAttribute)
				val += 10;

			return val;
		}

		protected override void ScanForObfuscator() {
			FindXenocodeAttribute();
			stringDecrypter = new StringDecrypter(module);
			stringDecrypter.Find();
		}

		void FindXenocodeAttribute() {
			foreach (var type in module.Types) {
				switch (type.FullName) {
				case "Xenocode.Client.Attributes.AssemblyAttributes.ProcessedByXenocode":
				case "Xenocode.Client.Attributes.AssemblyAttributes.SuppressDisassembly":
				case "Xenocode.User.Attributes.AssemblyAttributes.ProcessedByXenoCode":
				case "Xenocode.User.Attributes.AssemblyAttributes.SuppressDisassembly":
					AddAttributeToBeRemoved(type, "Obfuscator attribute");
					foundXenocodeAttribute = true;
					break;
				}
			}
		}

		public override void DeobfuscateBegin() {
			base.DeobfuscateBegin();

			staticStringInliner.Add(stringDecrypter.Method, (method, gim, args) => stringDecrypter.Decrypt((string)args[0], (int)args[1]));
			DeobfuscatedFile.StringDecryptersAdded();
		}

		public override void DeobfuscateEnd() {
			if (CanRemoveStringDecrypterType)
				AddTypeToBeRemoved(stringDecrypter.Type, "String decrypter type");
			var obfType = FindTypeWithThousandsOfMethods();
			if (obfType != null)
				AddTypeToBeRemoved(obfType, "Obfuscator type with thousands of empty methods");
			RemoveInvalidAttributes(module);
			RemoveInvalidAttributes(module.Assembly);
			base.DeobfuscateEnd();
		}

		TypeDef FindTypeWithThousandsOfMethods() {
			foreach (var type in module.Types) {
				if (IsTypeWithThousandsOfMethods(type))
					return type;
			}

			return null;
		}

		bool IsTypeWithThousandsOfMethods(TypeDef type) {
			if (!type.IsNotPublic)
				return false;
			if (type.HasFields || type.HasEvents || type.HasProperties)
				return false;
			if (type.Methods.Count < 100)
				return false;

			foreach (var method in type.Methods) {
				if (method.IsStaticConstructor)
					return false;
				if (method.IsConstructor) {
					if (method.MethodSig.GetParamCount() != 0)
						return false;
					continue;
				}
				if (!method.IsPrivate || method.IsStatic)
					return false;
				if (method.Body == null)
					return false;
				if (method.Body.Instructions.Count != 1)
					return false;
			}

			return true;
		}

		// Remove the attribute Xenocode adds that has an invalid ctor
		void RemoveInvalidAttributes(IHasCustomAttribute hca) {
			if (!CanRemoveTypes)
				return;
			if (hca == null)
				return;
			for (int i = hca.CustomAttributes.Count - 1; i >= 0; i--) {
				var ca = hca.CustomAttributes[i];
				if (ca.Constructor == null)
					hca.CustomAttributes.RemoveAt(i);
			}
		}

		public override IEnumerable<int> GetStringDecrypterMethods() {
			var list = new List<int>();
			if (stringDecrypter.Method != null)
				list.Add(stringDecrypter.Method.MDToken.ToInt32());
			return list;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/Xenocode/StringDecrypter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Text;
using dnlib.DotNet;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.Xenocode {
	class StringDecrypter {
		const int STRING_DECRYPTER_KEY_CONST = 1789;
		ModuleDefMD module;
		TypeDef stringDecrypterType;
		MethodDef stringDecrypterMethod;

		public bool Detected => stringDecrypterMethod != null;
		public TypeDef Type => stringDecrypterType;
		public MethodDef Method => stringDecrypterMethod;
		public StringDecrypter(ModuleDefMD module) => this.module = module;

		public void Find() {
			foreach (var type in module.Types) {
				if (type.HasFields)
					continue;
				if (type.Methods.Count < 1 || type.Methods.Count > 3)
					continue;
				if (type.HasProperties || type.HasEvents)
					continue;

				MethodDef method = null;
				foreach (var m in type.Methods) {
					if (m.Name == ".ctor" || m.Name == ".cctor")
						continue;
					if (DotNetUtils.IsMethod(m, "System.String", "(System.String,System.Int32)")) {
						method = m;
						continue;
					}
					method = null;
					break;
				}
				if (method == null || method.Body == null)
					continue;

				bool foundConstant = false;
				foreach (var instr in method.Body.Instructions) {
					if (instr.IsLdcI4() && instr.GetLdcI4Value() == STRING_DECRYPTER_KEY_CONST) {
						foundConstant = true;
						break;
					}
				}
				if (!foundConstant)
					continue;

				stringDecrypterType = type;
				stringDecrypterMethod = method;
				break;
			}
		}

		public string Decrypt(string es, int magic) {
			int newLen = es.Length / 4;
			var sb = new StringBuilder(newLen);
			for (int i = 0; i < newLen * 4; i += 4) {
				char c = (char)((es[i] - 'a') +
							((es[i + 1] - 'a') << 4) +
							((es[i + 2] - 'a') << 8) +
							((es[i + 3] - 'a') << 12) - magic);
				magic += STRING_DECRYPTER_KEY_CONST;
				sb.Append(c);
			}
			return sb.ToString();
		}
	}
}



================================================
File: de4dot.code/deobfuscators/dotNET_Reactor/v3/AntiStrongName.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.dotNET_Reactor.v3 {
	class AntiStrongName {
		public bool Remove(Blocks blocks) {
			var allBlocks = blocks.MethodBlocks.GetAllBlocks();
			foreach (var block in allBlocks) {
				if (Remove(blocks, block))
					return true;
			}

			return false;
		}

		bool Remove(Blocks blocks, Block block) {
			var instrs = block.Instructions;
			const int numInstrsToRemove = 11;
			if (instrs.Count < numInstrsToRemove)
				return false;
			int startIndex = instrs.Count - numInstrsToRemove;
			int index = startIndex;

			if (instrs[index++].OpCode.Code != Code.Ldtoken)
				return false;
			if (!CheckCall(instrs[index++], "System.Type System.Type::GetTypeFromHandle(System.RuntimeTypeHandle)"))
				return false;
			if (!CheckCall(instrs[index++], "System.Reflection.Assembly System.Type::get_Assembly()"))
				return false;
			if (!CheckCall(instrs[index++], "System.Reflection.AssemblyName System.Reflection.Assembly::GetName()"))
				return false;
			if (!CheckCall(instrs[index++], "System.Byte[] System.Reflection.AssemblyName::GetPublicKeyToken()"))
				return false;
			if (!CheckCall(instrs[index++], "System.String System.Convert::ToBase64String(System.Byte[])"))
				return false;
			if (instrs[index++].OpCode.Code != Code.Ldstr)
				return false;
			if (!CheckCall(instrs[index++], "System.String", "(System.String,System.String)"))
				return false;
			if (instrs[index++].OpCode.Code != Code.Ldstr)
				return false;
			if (!CheckCall(instrs[index++], "System.Boolean System.String::op_Inequality(System.String,System.String)"))
				return false;
			if (!instrs[index++].IsBrfalse())
				return false;

			var badBlock = block.FallThrough;
			var goodblock = block.Targets[0];
			if (badBlock == null)
				return false;

			if (badBlock == goodblock) {
				// All of the bad block was removed by the cflow deobfuscator. It was just a useless
				// calculation (div by zero).
				block.ReplaceLastInstrsWithBranch(numInstrsToRemove, goodblock);
			}
			else if (badBlock.Sources.Count == 1) {
				instrs = badBlock.Instructions;
				if (instrs.Count != 12)
					return false;
				index = 0;
				if (!instrs[index++].IsLdcI4())
					return false;
				if (!instrs[index].IsStloc())
					return false;
				var local = Instr.GetLocalVar(blocks.Locals, instrs[index++]);
				if (local == null)
					return false;
				if (!CheckLdloc(blocks.Locals, instrs[index++], local))
					return false;
				if (!CheckLdloc(blocks.Locals, instrs[index++], local))
					return false;
				if (instrs[index++].OpCode.Code != Code.Sub)
					return false;
				if (instrs[index++].OpCode.Code != Code.Conv_U1)
					return false;
				if (!CheckStloc(blocks.Locals, instrs[index++], local))
					return false;
				if (!CheckLdloc(blocks.Locals, instrs[index++], local))
					return false;
				if (!CheckLdloc(blocks.Locals, instrs[index++], local))
					return false;
				if (instrs[index++].OpCode.Code != Code.Div)
					return false;
				if (instrs[index++].OpCode.Code != Code.Conv_U1)
					return false;
				if (!CheckStloc(blocks.Locals, instrs[index++], local))
					return false;

				block.ReplaceLastInstrsWithBranch(numInstrsToRemove, goodblock);
				badBlock.Parent.RemoveDeadBlock(badBlock);
			}
			else
				return false;

			return true;
		}

		static bool CheckCall(Instr instr, string methodFullname) {
			if (instr.OpCode.Code != Code.Call && instr.OpCode.Code != Code.Callvirt)
				return false;
			var calledMethod = instr.Operand as IMethod;
			if (calledMethod == null)
				return false;
			return calledMethod.ToString() == methodFullname;
		}

		static bool CheckCall(Instr instr, string returnType, string parameters) {
			if (instr.OpCode.Code != Code.Call && instr.OpCode.Code != Code.Callvirt)
				return false;
			var calledMethod = instr.Operand as IMethod;
			if (calledMethod == null)
				return false;
			return DotNetUtils.IsMethod(calledMethod, returnType, parameters);
		}

		static bool CheckLdloc(IList<Local> locals, Instr instr, Local local) {
			if (!instr.IsLdloc())
				return false;
			if (Instr.GetLocalVar(locals, instr) != local)
				return false;
			return true;
		}

		static bool CheckStloc(IList<Local> locals, Instr instr, Local local) {
			if (!instr.IsStloc())
				return false;
			if (Instr.GetLocalVar(locals, instr) != local)
				return false;
			return true;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/dotNET_Reactor/v3/ApplicationModeDecrypter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using dnlib.DotNet;
using de4dot.blocks;
using de4dot.blocks.cflow;

namespace de4dot.code.deobfuscators.dotNET_Reactor.v3 {
	class ApplicationModeDecrypter {
		ModuleDefMD module;
		AssemblyResolver assemblyResolver;
		MemoryPatcher memoryPatcher;

		public byte[] AssemblyKey => assemblyResolver.Key;
		public byte[] AssemblyIv => assemblyResolver.Iv;
		public MemoryPatcher MemoryPatcher => memoryPatcher;
		public bool Detected => assemblyResolver != null;

		public ApplicationModeDecrypter(ModuleDefMD module) {
			this.module = module;
			Find();
		}

		void Find() {
			var cflowDeobfuscator = new CflowDeobfuscator(new MethodCallInliner(true));

			foreach (var type in module.Types) {
				if (DotNetUtils.GetPInvokeMethod(type, "kernel32", "CloseHandle") == null)
					continue;

				var resolver = new AssemblyResolver(type, cflowDeobfuscator);
				if (!resolver.Detected)
					continue;
				var patcher = new MemoryPatcher(type, cflowDeobfuscator);
				if (!patcher.Detected)
					continue;

				assemblyResolver = resolver;
				memoryPatcher = patcher;
				return;
			}
		}
	}
}



================================================
File: de4dot.code/deobfuscators/dotNET_Reactor/v3/ApplicationModeUnpacker.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using dnlib.PE;
using dnlib.DotNet;

namespace de4dot.code.deobfuscators.dotNET_Reactor.v3 {
	class IniFile {
		Dictionary<string, string> nameToValue = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

		public string this[string name] {
			get {
				nameToValue.TryGetValue(name, out string value);
				return value;
			}
		}

		public IniFile(byte[] data) {
			using (var reader = new StreamReader(new MemoryStream(data), Encoding.UTF8)) {
				while (true) {
					var line = reader.ReadLine();
					if (line == null)
						break;
					var match = Regex.Match(line, @"^([^=]+)=([^;]+);?\s*$");
					if (match.Groups.Count < 3)
						continue;
					var name = match.Groups[1].ToString().Trim();
					var value = match.Groups[2].ToString().Trim();
					nameToValue[name] = value;
				}
			}
		}
	}

	// Unpacks "application mode" files (DNR 3.x)
	class ApplicationModeUnpacker {
		static byte[] key1 = new byte[32] {
			0x6B, 0x6C, 0xA7, 0x24, 0x25, 0x37, 0x67, 0x68,
			0x4A, 0x2F, 0x28, 0x29, 0x33, 0x77, 0x34, 0x35,
			0x5A, 0x5A, 0x48, 0x57, 0x24, 0x35, 0x24, 0x25,
			0x26, 0x67, 0x77, 0x53, 0x41, 0x44, 0x46, 0x32,
		};
		static byte[] iv1 = new byte[16] {
			0x73, 0x64, 0xA7, 0x35, 0x24, 0xA7, 0x26, 0x67,
			0x34, 0x35, 0x37, 0x21, 0x32, 0x33, 0x6E, 0x6D,
		};
		static byte[] key2 = new byte[32] {
			0x28, 0x24, 0x29, 0x28, 0x2F, 0x29, 0x28, 0x29,
			0x3D, 0x66, 0x67, 0x35, 0x35, 0x6A, 0x6D, 0x2C,
			0xA7, 0x39, 0x38, 0x2A, 0x6A, 0x67, 0x74, 0x36,
			0x35, 0x3D, 0xA7, 0x43, 0x33, 0x33, 0x24, 0x74,
		};
		static byte[] iv2 = new byte[16] {
			0x67, 0x26, 0x35, 0xA7, 0x24, 0xA7, 0x37, 0x21,
			0x73, 0x33, 0x6E, 0x6D, 0x34, 0x32, 0x64, 0x35,
		};

		IPEImage peImage;
		List<UnpackedFile> satelliteAssemblies = new List<UnpackedFile>();
		uint[] sizes;
		string[] filenames;
		bool shouldUnpack;

		public IEnumerable<UnpackedFile> EmbeddedAssemblies => satelliteAssemblies;
		public ApplicationModeUnpacker(IPEImage peImage) => this.peImage = peImage;

		public byte[] Unpack() {
			byte[] data = null;
			MyPEImage myPeImage = null;
			try {
				myPeImage = new MyPEImage(peImage);
				data = Unpack2(myPeImage);
			}
			catch {
			}
			finally {
				if (myPeImage != null)
					myPeImage.Dispose();
			}
			if (data != null)
				return data;

			if (shouldUnpack)
				Logger.w("Could not unpack file: {0}", peImage.Filename ?? "(unknown filename)");
			return null;
		}

		byte[] Unpack2(MyPEImage peImage) {
			shouldUnpack = false;
			uint headerOffset = (uint)peImage.Length - 12;
			uint offsetEncryptedAssembly = CheckOffset(peImage, peImage.OffsetReadUInt32(headerOffset));
			uint ezencryptionLibLength = peImage.OffsetReadUInt32(headerOffset + 4);
			uint iniFileLength = peImage.OffsetReadUInt32(headerOffset + 8);

			uint offsetClrVersionNumber = checked(offsetEncryptedAssembly - 12);
			uint iniFileOffset = checked(headerOffset - iniFileLength);
			uint ezencryptionLibOffset = checked(iniFileOffset - ezencryptionLibLength);

			uint clrVerMajor = peImage.OffsetReadUInt32(offsetClrVersionNumber);
			uint clrVerMinor = peImage.OffsetReadUInt32(offsetClrVersionNumber + 4);
			uint clrVerBuild = peImage.OffsetReadUInt32(offsetClrVersionNumber + 8);
			if (clrVerMajor <= 0 || clrVerMajor >= 20 || clrVerMinor >= 20 || clrVerBuild >= 1000000)
				return null;

			var settings = new IniFile(Decompress2(peImage.OffsetReadBytes(iniFileOffset, (int)iniFileLength)));
			sizes = GetSizes(settings["General_App_Satellite_Assemblies_Sizes"]);
			if (sizes == null || sizes.Length <= 1)
				return null;
			shouldUnpack = true;
			if (sizes[0] != offsetEncryptedAssembly)
				return null;
			filenames = settings["General_App_Satellite_Assemblies"].Split('|');
			if (sizes.Length - 1 != filenames.Length)
				return null;

			byte[] ezencryptionLibData = Decompress1(peImage.OffsetReadBytes(ezencryptionLibOffset, (int)ezencryptionLibLength));
			var ezencryptionLibModule = ModuleDefMD.Load(ezencryptionLibData);
			var decrypter = new ApplicationModeDecrypter(ezencryptionLibModule);
			if (!decrypter.Detected)
				return null;

			var mainAssembly = UnpackEmbeddedFile(peImage, 0, decrypter);
			decrypter.MemoryPatcher.Patch(mainAssembly.data);
			for (int i = 1; i < filenames.Length; i++)
				satelliteAssemblies.Add(UnpackEmbeddedFile(peImage, i, decrypter));

			ClearDllBit(mainAssembly.data);
			return mainAssembly.data;
		}

		static void ClearDllBit(byte[] peImageData) {
			using (var mainPeImage = new MyPEImage(peImageData)) {
				uint characteristicsOffset = (uint)mainPeImage.PEImage.ImageNTHeaders.FileHeader.StartOffset + 18;
				ushort characteristics = mainPeImage.OffsetReadUInt16(characteristicsOffset);
				characteristics &= 0xDFFF;
				characteristics |= 2;
				mainPeImage.OffsetWriteUInt16(characteristicsOffset, characteristics);
			}
		}

		UnpackedFile UnpackEmbeddedFile(MyPEImage peImage, int index, ApplicationModeDecrypter decrypter) {
			uint offset = 0;
			for (int i = 0; i < index + 1; i++)
				offset += sizes[i];
			string filename = Win32Path.GetFileName(filenames[index]);
			var data = peImage.OffsetReadBytes(offset, (int)sizes[index + 1]);
			data = DeobUtils.AesDecrypt(data, decrypter.AssemblyKey, decrypter.AssemblyIv);
			data = Decompress(data);
			return new UnpackedFile(filename, data);
		}

		static uint[] GetSizes(string sizes) {
			if (sizes == null)
				return null;
			var list = new List<uint>();
			foreach (var num in sizes.Split('|'))
				list.Add(uint.Parse(num));
			return list.ToArray();
		}

		uint CheckOffset(MyPEImage peImage, uint offset) {
			if (offset >= peImage.Length)
				throw new Exception();
			return offset;
		}

		static byte[] Decompress1(byte[] data) => Decompress(Decrypt1(data));
		static byte[] Decompress2(byte[] data) => Decompress(Decrypt2(data));

		static byte[] Decompress(byte[] data) {
			if (!QuickLZ.IsCompressed(data))
				return data;
			return QuickLZ.Decompress(data);
		}

		static byte[] Decrypt1(byte[] data) => DeobUtils.AesDecrypt(data, key1, iv1);
		static byte[] Decrypt2(byte[] data) => DeobUtils.AesDecrypt(data, key2, iv2);
	}
}



================================================
File: de4dot.code/deobfuscators/dotNET_Reactor/v3/AssemblyResolver.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet;
using de4dot.blocks;
using de4dot.blocks.cflow;

namespace de4dot.code.deobfuscators.dotNET_Reactor.v3 {
	class AssemblyResolver {
		DecryptMethod decryptMethod = new DecryptMethod();

		public byte[] Key => decryptMethod.Key;
		public byte[] Iv => decryptMethod.Iv;
		public bool Detected => decryptMethod.Detected;

		public AssemblyResolver(TypeDef type, ICflowDeobfuscator cflowDeobfuscator) =>
			Find(type, cflowDeobfuscator);

		void Find(TypeDef type, ICflowDeobfuscator cflowDeobfuscator) {
			var additionalTypes = new List<string> {
				"System.IO.BinaryReader",
				"System.IO.FileStream",
				"System.Reflection.Assembly",
				"System.Reflection.Assembly[]",
				"System.String",
			};
			foreach (var method in type.Methods) {
				if (!DotNetUtils.IsMethod(method, "System.Reflection.Assembly", "(System.Object,System.ResolveEventArgs)"))
					continue;
				if (!DecryptMethod.CouldBeDecryptMethod(method, additionalTypes))
					continue;
				cflowDeobfuscator.Deobfuscate(method);
				if (!decryptMethod.GetKey(method))
					continue;

				return;
			}
		}
	}
}



================================================
File: de4dot.code/deobfuscators/dotNET_Reactor/v3/DecryptMethod.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet;

namespace de4dot.code.deobfuscators.dotNET_Reactor.v3 {
	class DecryptMethod {
		MethodDef decryptionMethod;
		byte[] key;
		byte[] iv;

		public byte[] Key => key;
		public byte[] Iv => iv;
		public bool Detected => decryptionMethod != null;

		public static bool CouldBeDecryptMethod(MethodDef method, IEnumerable<string> additionalTypes) {
			if (method.Body == null)
				return false;

			var localTypes = new LocalTypes(method);
			var requiredTypes = new List<string> {
				"System.Byte[]",
				"System.IO.MemoryStream",
				"System.Security.Cryptography.CryptoStream",
				"System.Security.Cryptography.ICryptoTransform",
			};
			requiredTypes.AddRange(additionalTypes);
			if (!localTypes.All(requiredTypes))
				return false;
			if (!localTypes.Exists("System.Security.Cryptography.RijndaelManaged") &&
				!localTypes.Exists("System.Security.Cryptography.AesManaged"))
				return false;

			return true;
		}

		public bool GetKey(MethodDef method) {
			var tmpKey = ArrayFinder.GetInitializedByteArray(method, 32);
			if (tmpKey == null)
				return false;
			var tmpIv = ArrayFinder.GetInitializedByteArray(method, 16);
			if (tmpIv == null)
				return false;

			decryptionMethod = method;
			key = tmpKey;
			iv = tmpIv;
			return true;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/dotNET_Reactor/v3/DecrypterType.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Text;
using dnlib.DotNet;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.dotNET_Reactor.v3 {
	// Find the type that decrypts strings and calls the native lib
	class DecrypterType {
		ModuleDefMD module;
		TypeDef decrypterType;
		MethodDef stringDecrypter1;
		MethodDef stringDecrypter2;
		List<MethodDef> initMethods = new List<MethodDef>();
		List<ModuleRef> moduleRefs = new List<ModuleRef>();
		Resource linkedResource;

		public bool Detected => decrypterType != null;
		public TypeDef Type => decrypterType;
		public Resource LinkedResource => linkedResource;
		public MethodDef StringDecrypter1 => stringDecrypter1;
		public MethodDef StringDecrypter2 => stringDecrypter2;
		public IEnumerable<MethodDef> InitMethods => initMethods;

		public IEnumerable<MethodDef> StringDecrypters =>
			new List<MethodDef> {
				stringDecrypter1,
				stringDecrypter2,
			};

		public DecrypterType(ModuleDefMD module) => this.module = module;

		public DecrypterType(ModuleDefMD module, DecrypterType oldOne) {
			this.module = module;
			decrypterType = Lookup(oldOne.decrypterType, "Could not find decrypterType");
			stringDecrypter1 = Lookup(oldOne.stringDecrypter1, "Could not find stringDecrypter1");
			stringDecrypter2 = Lookup(oldOne.stringDecrypter2, "Could not find stringDecrypter2");
			foreach (var method in oldOne.initMethods)
				initMethods.Add(Lookup(method, "Could not find initMethod"));
			UpdateModuleRefs();
		}

		T Lookup<T>(T def, string errorMessage) where T : class, ICodedToken =>
			DeobUtils.Lookup(module, def, errorMessage);

		public void Find() {
			foreach (var type in module.Types) {
				if (type.FullName != "<PrivateImplementationDetails>{B4838DC1-AC79-43d1-949F-41B518B904A8}")
					continue;

				decrypterType = type;
				stringDecrypter1 = GetStringDecrypter(type, "CS$0$0004");
				stringDecrypter2 = GetStringDecrypter(type, "CS$0$0005");
				foreach (var method in type.Methods) {
					if (DotNetUtils.IsMethod(method, "System.Void", "()"))
						initMethods.Add(method);
				}
				UpdateModuleRefs();
				return;
			}
		}

		void UpdateModuleRefs() {
			foreach (var method in decrypterType.Methods) {
				if (method.ImplMap != null) {
					switch (method.ImplMap.Name.String) {
					case "nr_nli":
					case "nr_startup":
						moduleRefs.Add(method.ImplMap.Module);
						break;
					}
				}
			}
			UpdateLinkedResource();
		}

		void UpdateLinkedResource() {
			foreach (var modref in moduleRefs) {
				var resource = DotNetUtils.GetResource(module, modref.Name.String) as LinkedResource;
				if (resource == null)
					continue;

				linkedResource = resource;
				return;
			}
		}

		MethodDef GetStringDecrypter(TypeDef type, string name) {
			var method = type.FindMethod(name);
			if (method == null)
				return null;
			if (!DotNetUtils.IsMethod(method, "System.String", "(System.String)"))
				return null;
			return method;
		}

		public string Decrypt1(string s) {
			var sb = new StringBuilder(s.Length);
			foreach (var c in s)
				sb.Append((char)(0xFF - (byte)c));
			return sb.ToString();
		}

		public string Decrypt2(string s) => Encoding.Unicode.GetString(Convert.FromBase64String(s));

		public bool Patch(byte[] peData) {
			try {
				using (var peImage = new MyPEImage(peData))
					return Patch2(peImage);
			}
			catch {
				Logger.w("Could not patch the file");
				return false;
			}
		}

		bool Patch2(MyPEImage peImage) {
			uint numPatches = peImage.OffsetReadUInt32(peImage.Length - 4);
			uint offset = checked(peImage.Length - 4 - numPatches * 8);

			bool startedPatchingBadData = false;
			for (uint i = 0; i < numPatches; i++, offset += 8) {
				uint rva = GetValue(peImage.OffsetReadUInt32(offset));
				var value = peImage.OffsetReadUInt32(offset + 4);

				if (value == 4) {
					i++;
					offset += 8;
					rva = GetValue(peImage.OffsetReadUInt32(offset));
					value = peImage.OffsetReadUInt32(offset + 4);
				}
				else
					value = GetValue(value);

				// Seems there's a bug in their code where they sometimes overwrite valid data
				// with invalid data.
				if (startedPatchingBadData && value == 0x3115)
					continue;

				startedPatchingBadData |= !peImage.DotNetSafeWrite(rva, BitConverter.GetBytes(value));
			}

			return true;
		}

		static uint GetValue(uint value) {
			const uint magic = 2749;
			value = checked(value - magic);
			if (value % 3 != 0)
				throw new Exception();
			return value / 3;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/dotNET_Reactor/v3/Deobfuscator.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using System.Text.RegularExpressions;
using dnlib.PE;
using dnlib.DotNet;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.dotNET_Reactor.v3 {
	public class DeobfuscatorInfo : DeobfuscatorInfoBase {
		public const string THE_NAME = ".NET Reactor";
		public const string THE_TYPE = "dr3";
		const string DEFAULT_REGEX = DeobfuscatorBase.DEFAULT_ASIAN_VALID_NAME_REGEX;
		BoolOption restoreTypes;
		BoolOption inlineMethods;
		BoolOption removeInlinedMethods;
		BoolOption removeNamespaces;
		BoolOption removeAntiStrongName;

		public DeobfuscatorInfo()
			: base(DEFAULT_REGEX) {
			restoreTypes = new BoolOption(null, MakeArgName("types"), "Restore types (object -> real type)", true);
			inlineMethods = new BoolOption(null, MakeArgName("inline"), "Inline short methods", true);
			removeInlinedMethods = new BoolOption(null, MakeArgName("remove-inlined"), "Remove inlined methods", true);
			removeNamespaces = new BoolOption(null, MakeArgName("ns1"), "Clear namespace if there's only one class in it", true);
			removeAntiStrongName = new BoolOption(null, MakeArgName("sn"), "Remove anti strong name code", true);
		}

		public override string Name => THE_NAME;
		public override string Type => THE_TYPE;

		public override IDeobfuscator CreateDeobfuscator() =>
			new Deobfuscator(new Deobfuscator.Options {
				ValidNameRegex = validNameRegex.Get(),
				RestoreTypes = restoreTypes.Get(),
				InlineMethods = inlineMethods.Get(),
				RemoveInlinedMethods = removeInlinedMethods.Get(),
				RemoveNamespaces = removeNamespaces.Get(),
				RemoveAntiStrongName = removeAntiStrongName.Get(),
			});

		protected override IEnumerable<Option> GetOptionsInternal() =>
			new List<Option>() {
				restoreTypes,
				inlineMethods,
				removeInlinedMethods,
				removeNamespaces,
				removeAntiStrongName,
			};
	}

	class Deobfuscator : DeobfuscatorBase {
		Options options;
		string obfuscatorName = DeobfuscatorInfo.THE_NAME;

		DecrypterType decrypterType;
		NativeLibSaver nativeLibSaver;
		AntiStrongName antiStrongName;
		LibAssemblyResolver libAssemblyResolver;
		List<UnpackedFile> unpackedFiles = new List<UnpackedFile>();

		bool unpackedNativeFile = false;
		bool canRemoveDecrypterType = true;
		bool startedDeobfuscating = false;

		internal class Options : OptionsBase {
			public bool RestoreTypes { get; set; }
			public bool InlineMethods { get; set; }
			public bool RemoveInlinedMethods { get; set; }
			public bool RemoveNamespaces { get; set; }
			public bool RemoveAntiStrongName { get; set; }
		}

		public override string Type => DeobfuscatorInfo.THE_TYPE;
		public override string TypeLong => DeobfuscatorInfo.THE_NAME + " 3.x";
		public override string Name => obfuscatorName;
		protected override bool CanInlineMethods => startedDeobfuscating ? options.InlineMethods : true;

		public Deobfuscator(Options options)
			: base(options) {
			this.options = options;

			if (options.RemoveNamespaces)
				RenamingOptions |= RenamingOptions.RemoveNamespaceIfOneType;
			else
				RenamingOptions &= ~RenamingOptions.RemoveNamespaceIfOneType;
		}

		public override byte[] UnpackNativeFile(IPEImage peImage) {
			var unpacker = new ApplicationModeUnpacker(peImage);
			var data = unpacker.Unpack();
			if (data == null)
				return null;

			unpackedFiles.AddRange(unpacker.EmbeddedAssemblies);
			unpackedNativeFile = true;
			ModuleBytes = data;
			return data;
		}

		bool NeedsPatching() => decrypterType.LinkedResource != null || nativeLibSaver.Resource != null;

		public override bool GetDecryptedModule(int count, ref byte[] newFileData, ref DumpedMethods dumpedMethods) {
			if (count != 0 || !NeedsPatching())
				return false;

			var fileData = ModuleBytes ?? DeobUtils.ReadModule(module);
			if (!decrypterType.Patch(fileData))
				return false;

			newFileData = fileData;
			return true;
		}

		public override IDeobfuscator ModuleReloaded(ModuleDefMD module) {
			var newOne = new Deobfuscator(options);
			newOne.SetModule(module);
			newOne.decrypterType = new DecrypterType(module, decrypterType);
			newOne.nativeLibSaver = new NativeLibSaver(module, nativeLibSaver);
			return newOne;
		}

		static Regex isRandomName = new Regex(@"^[A-Z]{30,40}$");
		static Regex isRandomNameMembers = new Regex(@"^[a-zA-Z0-9]{9,11}$");	// methods, fields, props, events
		static Regex isRandomNameTypes = new Regex(@"^[a-zA-Z0-9]{18,19}(?:`\d+)?$");	// types, namespaces

		bool CheckValidName(string name, Regex regex) {
			if (isRandomName.IsMatch(name))
				return false;
			if (regex.IsMatch(name)) {
				if (RandomNameChecker.IsRandom(name))
					return false;
				if (!RandomNameChecker.IsNonRandom(name))
					return false;
			}
			return CheckValidName(name);
		}

		public override bool IsValidNamespaceName(string ns) {
			if (ns == null)
				return false;
			if (ns.Contains("."))
				return base.IsValidNamespaceName(ns);
			return CheckValidName(ns, isRandomNameTypes);
		}

		public override bool IsValidTypeName(string name) => name != null && CheckValidName(name, isRandomNameTypes);
		public override bool IsValidMethodName(string name) => name != null && CheckValidName(name, isRandomNameMembers);
		public override bool IsValidPropertyName(string name) => name != null && CheckValidName(name, isRandomNameMembers);
		public override bool IsValidEventName(string name) => name != null && CheckValidName(name, isRandomNameMembers);
		public override bool IsValidFieldName(string name) => name != null && CheckValidName(name, isRandomNameMembers);
		public override bool IsValidGenericParamName(string name) => name != null && CheckValidName(name, isRandomNameMembers);
		public override bool IsValidMethodArgName(string name) => name != null && CheckValidName(name, isRandomNameMembers);
		public override bool IsValidMethodReturnArgName(string name) => string.IsNullOrEmpty(name) || CheckValidName(name, isRandomNameMembers);
		public override bool IsValidResourceKeyName(string name) => name != null && CheckValidName(name, isRandomNameMembers);

		protected override int DetectInternal() {
			int val = 0;

			int sum = ToInt32(unpackedNativeFile) +
					ToInt32(decrypterType.Detected) +
					ToInt32(nativeLibSaver.Detected);
			if (sum > 0)
				val += 100 + 10 * (sum - 1);

			return val;
		}

		protected override void ScanForObfuscator() {
			decrypterType = new DecrypterType(module);
			decrypterType.Find();
			nativeLibSaver = new NativeLibSaver(module);
			nativeLibSaver.Find();
			obfuscatorName = DetectVersion();
			if (unpackedNativeFile)
				obfuscatorName += " (native)";
		}

		string DetectVersion() => DeobfuscatorInfo.THE_NAME + " 3.x";

		public override void DeobfuscateBegin() {
			base.DeobfuscateBegin();

			antiStrongName = new AntiStrongName();

			staticStringInliner.Add(decrypterType.StringDecrypter1, (method2, gim, args) => {
				return decrypterType.Decrypt1((string)args[0]);
			});
			staticStringInliner.Add(decrypterType.StringDecrypter2, (method2, gim, args) => {
				return decrypterType.Decrypt2((string)args[0]);
			});
			DeobfuscatedFile.StringDecryptersAdded();

			libAssemblyResolver = new LibAssemblyResolver(module);
			libAssemblyResolver.Find(DeobfuscatedFile, this);

			if (Operations.DecryptStrings == OpDecryptString.None)
				canRemoveDecrypterType = false;

			RemoveInitCall(nativeLibSaver.InitMethod);
			AddResourceToBeRemoved(nativeLibSaver.Resource, "Native lib resource");
			AddTypeToBeRemoved(nativeLibSaver.Type, "Native lib saver type");

			foreach (var initMethod in decrypterType.InitMethods)
				RemoveInitCall(initMethod);

			DumpUnpackedFiles();
			DumpResourceFiles();

			startedDeobfuscating = true;
		}

		void RemoveInitCall(MethodDef initMethod) {
			AddCctorInitCallToBeRemoved(initMethod);
			AddCtorInitCallToBeRemoved(initMethod);
		}

		void DumpUnpackedFiles() {
			foreach (var unpackedFile in unpackedFiles)
				DeobfuscatedFile.CreateAssemblyFile(unpackedFile.data,
							Win32Path.GetFileNameWithoutExtension(unpackedFile.filename),
							Win32Path.GetExtension(unpackedFile.filename));
		}

		void DumpResourceFiles() {
			foreach (var resource in libAssemblyResolver.Resources) {
				var mod = ModuleDefMD.Load(resource.CreateReader().ToArray());
				AddResourceToBeRemoved(resource, $"Embedded assembly: {mod.Assembly.FullName}");
				DeobfuscatedFile.CreateAssemblyFile(resource.CreateReader().ToArray(),
							Utils.GetAssemblySimpleName(mod.Assembly.FullName),
							DeobUtils.GetExtension(mod.Kind));
			}
			RemoveInitCall(libAssemblyResolver.InitMethod);
			AddCallToBeRemoved(module.EntryPoint, libAssemblyResolver.InitMethod);
			AddTypeToBeRemoved(libAssemblyResolver.Type, "Assembly resolver type (library mode)");
		}

		public override void DeobfuscateMethodEnd(Blocks blocks) {
			if (options.RemoveAntiStrongName) {
				if (antiStrongName.Remove(blocks))
					Logger.v("Removed Anti Strong Name code");
			}
			base.DeobfuscateMethodEnd(blocks);
		}

		public override void DeobfuscateEnd() {
			RemoveInlinedMethods();
			if (options.RestoreTypes)
				new TypesRestorer(module).Deobfuscate();

			if (canRemoveDecrypterType && !IsTypeCalled(decrypterType.Type)) {
				AddTypeToBeRemoved(decrypterType.Type, "Decrypter type");
				AddResourceToBeRemoved(decrypterType.LinkedResource, "Native lib linked resource");
			}

			base.DeobfuscateEnd();
		}

		void RemoveInlinedMethods() {
			if (!options.InlineMethods || !options.RemoveInlinedMethods)
				return;
			FindAndRemoveInlinedMethods();
		}

		public override IEnumerable<int> GetStringDecrypterMethods() {
			var list = new List<int>();
			foreach (var method in decrypterType.StringDecrypters)
				list.Add(method.MDToken.ToInt32());
			return list;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/dotNET_Reactor/v3/LibAssemblyResolver.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.dotNET_Reactor.v3 {
	// Find the assembly resolver that's used in lib mode (3.8+)
	class LibAssemblyResolver {
		ModuleDefMD module;
		MethodDef initMethod;
		List<EmbeddedResource> resources = new List<EmbeddedResource>();

		public TypeDef Type => initMethod?.DeclaringType;
		public MethodDef InitMethod => initMethod;
		public IEnumerable<EmbeddedResource> Resources => resources;
		public LibAssemblyResolver(ModuleDefMD module) => this.module = module;

		public void Find(ISimpleDeobfuscator simpleDeobfuscator, IDeobfuscator deob) {
			if (CheckInitMethod(DotNetUtils.GetModuleTypeCctor(module), simpleDeobfuscator, deob))
				return;
			if (CheckInitMethod(module.EntryPoint, simpleDeobfuscator, deob))
				return;
		}

		bool CheckInitMethod(MethodDef checkMethod, ISimpleDeobfuscator simpleDeobfuscator, IDeobfuscator deob) {
			var requiredFields = new string[] {
				"System.Collections.Hashtable",
				"System.Boolean",
			};

			foreach (var method in DotNetUtils.GetCalledMethods(module, checkMethod)) {
				if (method.Body == null)
					continue;
				if (!method.IsStatic)
					continue;
				if (!DotNetUtils.IsMethod(method, "System.Void", "()"))
					continue;

				var type = method.DeclaringType;
				if (!new FieldTypes(type).Exactly(requiredFields))
					continue;
				var ctor = type.FindMethod(".ctor");
				if (ctor == null)
					continue;
				var handler = DeobUtils.GetResolveMethod(ctor);
				if (handler == null)
					continue;
				simpleDeobfuscator.DecryptStrings(handler, deob);
				var resourcePrefix = GetResourcePrefix(handler);
				if (resourcePrefix == null)
					continue;

				for (int i = 0; ; i++) {
					var resource = DotNetUtils.GetResource(module, resourcePrefix + i.ToString("D5")) as EmbeddedResource;
					if (resource == null)
						break;
					resources.Add(resource);
				}

				initMethod = method;
				return true;
			}

			return false;
		}

		string GetResourcePrefix(MethodDef handler) {
			foreach (var s in DotNetUtils.GetCodeStrings(handler)) {
				if (DotNetUtils.GetResource(module, s + "00000") is EmbeddedResource resource)
					return s;
			}
			return null;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/dotNET_Reactor/v3/MemoryPatcher.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.IO;
using dnlib.DotNet;
using de4dot.blocks;
using de4dot.blocks.cflow;

namespace de4dot.code.deobfuscators.dotNET_Reactor.v3 {
	class MemoryPatcher {
		DecryptMethod decryptMethod = new DecryptMethod();
		List<PatchInfo> patchInfos = new List<PatchInfo>();

		class PatchInfo {
			public int[] offsets;
			public int[] values;
			public PatchInfo(int[] offsets, int[] values) {
				this.offsets = offsets;
				this.values = values;
			}
		}

		public bool Detected => decryptMethod.Detected;

		public MemoryPatcher(TypeDef type, ICflowDeobfuscator cflowDeobfuscator) =>
			Find(type, cflowDeobfuscator);

		void Find(TypeDef type, ICflowDeobfuscator cflowDeobfuscator) {
			var additionalTypes = new List<string> {
				"System.IO.BinaryWriter",
			};
			foreach (var method in type.Methods) {
				if (!DotNetUtils.IsMethod(method, "System.Void", "(System.Int32[],System.UInt32[])"))
					continue;
				if (!DecryptMethod.CouldBeDecryptMethod(method, additionalTypes))
					continue;
				cflowDeobfuscator.Deobfuscate(method);
				if (!decryptMethod.GetKey(method))
					continue;

				FindPatchData(type, cflowDeobfuscator);
				return;
			}
		}

		void FindPatchData(TypeDef type, ICflowDeobfuscator cflowDeobfuscator) {
			var locals = new List<string> {
				"System.Int32[]",
				"System.UInt32[]",
			};
			foreach (var method in type.Methods) {
				if (method.Attributes != MethodAttributes.Private)
					continue;
				if (!DotNetUtils.IsMethod(method, "System.Void", "()"))
					continue;
				if (!new LocalTypes(method).Exactly(locals))
					continue;
				cflowDeobfuscator.Deobfuscate(method);
				var patchInfo = GetPatchInfo(method);
				if (patchInfo == null)
					continue;

				patchInfos.Add(patchInfo);
			}
		}

		PatchInfo GetPatchInfo(MethodDef method) {
			int index1 = 0, index2, index3;
			if (!ArrayFinder.FindNewarr(method, ref index1, out int size1))
				return null;
			index2 = index1 + 1;
			if (!ArrayFinder.FindNewarr(method, ref index2, out int size2))
				return null;
			index3 = index2 + 1;
			if (ArrayFinder.FindNewarr(method, ref index3, out int size3))
				return null;

			if (size1 <= 0 || size1 > 35)
				return null;

			var ary1 = ArrayFinder.GetInitializedInt32Array(size1, method, ref index1);
			var ary2 = ArrayFinder.GetInitializedInt32Array(size2, method, ref index2);
			if (ary1 == null || ary2 == null)
				return null;
			ary2 = Decrypt(ary2);
			if (ary2 == null || ary1.Length != ary2.Length)
				return null;

			for (int i = 0; i < ary1.Length; i++)
				ary1[i] = -ary1[i];

			return new PatchInfo(ary1, ary2);
		}

		int[] Decrypt(int[] data) {
			var memStream = new MemoryStream();
			var writer = new BinaryWriter(memStream);
			foreach (var value in data)
				writer.Write(value);
			byte[] decrypted;
			try {
				decrypted = DeobUtils.AesDecrypt(memStream.ToArray(), decryptMethod.Key, decryptMethod.Iv);
			}
			catch {
				return null;
			}
			if (decrypted.Length / 4 * 4 != decrypted.Length)
				return null;
			var newData = new int[decrypted.Length / 4];
			for (int i = 0; i < newData.Length; i++)
				newData[i] = BitConverter.ToInt32(decrypted, i * 4);
			return newData;
		}

		public void Patch(byte[] peImageData) {
			using (var peImage = new MyPEImage(peImageData)) {
				foreach (var info in patchInfos) {
					for (int i = 0; i < info.offsets.Length; i++)
						peImage.DotNetSafeWriteOffset((uint)info.offsets[i], BitConverter.GetBytes(info.values[i]));
				}
			}
		}
	}
}



================================================
File: de4dot.code/deobfuscators/dotNET_Reactor/v3/NativeLibSaver.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using dnlib.DotNet;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.dotNET_Reactor.v3 {
	// Finds the type that saves the native lib (if in resources) to disk
	class NativeLibSaver {
		ModuleDefMD module;
		TypeDef nativeLibCallerType;
		MethodDef initMethod;
		Resource nativeFileResource;

		public TypeDef Type => nativeLibCallerType;
		public MethodDef InitMethod => initMethod;
		public Resource Resource => nativeFileResource;
		public bool Detected => nativeLibCallerType != null;
		public NativeLibSaver(ModuleDefMD module) => this.module = module;

		public NativeLibSaver(ModuleDefMD module, NativeLibSaver oldOne) {
			this.module = module;
			nativeLibCallerType = Lookup(oldOne.nativeLibCallerType, "Could not find nativeLibCallerType");
			initMethod = Lookup(oldOne.initMethod, "Could not find initMethod");
			if (oldOne.nativeFileResource != null) {
				nativeFileResource = DotNetUtils.GetResource(module, oldOne.nativeFileResource.Name.String);
				if (nativeFileResource == null)
					throw new ApplicationException("Could not find nativeFileResource");
			}
		}

		T Lookup<T>(T def, string errorMessage) where T : class, ICodedToken =>
			DeobUtils.Lookup(module, def, errorMessage);

		public void Find() {
			foreach (var calledMethod in DotNetUtils.GetCalledMethods(module, DotNetUtils.GetModuleTypeCctor(module))) {
				if (!DotNetUtils.IsMethod(calledMethod, "System.Void", "()"))
					continue;
				if (calledMethod.DeclaringType.FullName != "<PrivateImplementationDetails>{F1C5056B-0AFC-4423-9B83-D13A26B48869}")
					continue;

				nativeLibCallerType = calledMethod.DeclaringType;
				initMethod = calledMethod;
				foreach (var s in DotNetUtils.GetCodeStrings(initMethod)) {
					nativeFileResource = DotNetUtils.GetResource(module, s);
					if (nativeFileResource != null)
						break;
				}
				return;
			}
		}
	}
}



================================================
File: de4dot.code/deobfuscators/dotNET_Reactor/v4/AntiStrongName.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.dotNET_Reactor.v4 {
	class AntiStrongName {
		TypeDef decrypterType;
		MethodDef antiStrongNameMethod;

		public AntiStrongName(TypeDef decrypterType) {
			this.decrypterType = decrypterType;
			Find();
		}

		public void Find() {
			if (decrypterType == null)
				return;

			if (CheckType(decrypterType))
				return;

			foreach (var type in decrypterType.NestedTypes) {
				if (CheckType(type))
					return;
			}
		}

		bool CheckType(TypeDef type) {
			var requiredTypes = new string[] {
				"System.Byte[]",
				"System.IO.MemoryStream",
				"System.Security.Cryptography.CryptoStream",
				"System.Security.Cryptography.MD5",
				"System.Security.Cryptography.Rijndael",
			};

			foreach (var method in type.Methods) {
				if (!method.IsStatic || method.Body == null)
					continue;
				var sig = method.MethodSig;
				if (sig == null || sig.Params.Count != 2)
					continue;
				if (!CheckType(sig.RetType, ElementType.String))
					continue;
				if (!CheckType(sig.Params[0], ElementType.String))
					continue;
				if (!CheckType(sig.Params[1], ElementType.String))
					continue;

				var localTypes = new LocalTypes(method);
				if (!localTypes.All(requiredTypes))
					continue;

				antiStrongNameMethod = method;
				return true;
			}

			return false;
		}

		static bool CheckType(TypeSig type, ElementType expectedType) =>
			type != null && (type.ElementType == ElementType.Object || type.ElementType == expectedType);

		public bool Remove(Blocks blocks) {
			if (antiStrongNameMethod == null)
				return false;

			if (!FindBlock(blocks, out var antiSnBlock, out int numInstructions))
				return false;

			if (antiSnBlock.FallThrough == null || antiSnBlock.Targets == null || antiSnBlock.Targets.Count != 1)
				throw new ApplicationException("Invalid state");

			var goodBlock = antiSnBlock.Targets[0];
			var badBlock = antiSnBlock.FallThrough;

			antiSnBlock.ReplaceLastInstrsWithBranch(numInstructions, goodBlock);

			if (badBlock.FallThrough == badBlock && badBlock.Sources.Count == 1 && badBlock.Targets == null) {
				badBlock.Parent.RemoveGuaranteedDeadBlock(badBlock);
				return true;
			}
			if (badBlock.Instructions.Count <= 1 && badBlock.LastInstr.OpCode.Code == Code.Nop) {
				if (badBlock.FallThrough != null && badBlock.Targets == null && badBlock.Sources.Count == 0) {
					var badBlock2 = badBlock.FallThrough;
					if (badBlock2.FallThrough == badBlock2 && badBlock2.Sources.Count == 2 && badBlock2.Targets == null) {
						badBlock.Parent.RemoveGuaranteedDeadBlock(badBlock);
						badBlock2.Parent.RemoveGuaranteedDeadBlock(badBlock2);
						return true;
					}
				}
			}

			throw new ApplicationException("Invalid state");
		}

		bool FindBlock(Blocks blocks, out Block foundBlock, out int numInstructions) {
			const int NUM_INSTRS = 11;

			foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {
				if (!block.LastInstr.IsBrfalse())
					continue;

				var instructions = block.Instructions;
				if (instructions.Count < NUM_INSTRS)
					continue;
				int i = instructions.Count - NUM_INSTRS;
				if (instructions[i].OpCode.Code != Code.Ldtoken)
					continue;
				if (!(instructions[i].Operand is ITypeDefOrRef))
					continue;
				if (!CheckCall(instructions[i + 1], "System.Type System.Type::GetTypeFromHandle(System.RuntimeTypeHandle)"))
					continue;
				if (!CheckCall(instructions[i + 2], "System.Reflection.Assembly System.Type::get_Assembly()"))
					continue;
				if (!CheckCall(instructions[i + 3], "System.Reflection.AssemblyName System.Reflection.Assembly::GetName()"))
					continue;
				if (!CheckCall(instructions[i + 4], "System.Byte[] System.Reflection.AssemblyName::GetPublicKeyToken()"))
					continue;
				if (!CheckCall(instructions[i + 5], "System.String System.Convert::ToBase64String(System.Byte[])"))
					continue;
				if (instructions[i + 6].OpCode.Code != Code.Ldstr)
					continue;
				if (!CheckCall(instructions[i + 7], antiStrongNameMethod))
					continue;
				if (instructions[i + 8].OpCode.Code != Code.Ldstr)
					continue;
				if (!CheckCall(instructions[i + 9], "System.Boolean System.String::op_Inequality(System.String,System.String)"))
					continue;

				numInstructions = NUM_INSTRS;
				foundBlock = block;
				return true;
			}

			foundBlock = null;
			numInstructions = 0;
			return false;
		}

		static bool CheckCall(Instr instr, string methodFullName) {
			if (instr.OpCode.Code != Code.Call && instr.OpCode.Code != Code.Callvirt)
				return false;
			var calledMethod = instr.Operand as IMethod;
			if (calledMethod == null)
				return false;
			return calledMethod.FullName == methodFullName;
		}

		static bool CheckCall(Instr instr, IMethod expectedMethod) {
			if (instr.OpCode.Code != Code.Call && instr.OpCode.Code != Code.Callvirt)
				return false;
			var calledMethod = instr.Operand as IMethod;
			if (calledMethod == null)
				return false;
			return MethodEqualityComparer.CompareDeclaringTypes.Equals(calledMethod, expectedMethod);
		}
	}
}



================================================
File: de4dot.code/deobfuscators/dotNET_Reactor/v4/AssemblyResolver.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.dotNET_Reactor.v4 {
	class ResourceInfo {
		public EmbeddedResource resource;
		public string name;

		public ResourceInfo(EmbeddedResource resource, string name) {
			this.resource = resource;
			this.name = name;
		}

		public override string ToString() => $"{name} (rsrc: {Utils.ToCsharpString(resource.Name)})";
	}

	class AssemblyResolver {
		ModuleDefMD module;
		TypeDef assemblyResolverType;
		MethodDef assemblyResolverInitMethod;
		MethodDef assemblyResolverMethod;

		public bool Detected => assemblyResolverType != null;
		public TypeDef Type => assemblyResolverType;
		public MethodDef InitMethod => assemblyResolverInitMethod;
		public AssemblyResolver(ModuleDefMD module) => this.module = module;

		public AssemblyResolver(ModuleDefMD module, AssemblyResolver oldOne) {
			this.module = module;
			assemblyResolverType = Lookup(oldOne.assemblyResolverType, "Could not find assembly resolver type");
			assemblyResolverMethod = Lookup(oldOne.assemblyResolverMethod, "Could not find assembly resolver method");
			assemblyResolverInitMethod = Lookup(oldOne.assemblyResolverInitMethod, "Could not find assembly resolver init method");
		}

		T Lookup<T>(T def, string errorMessage) where T : class, ICodedToken =>
			DeobUtils.Lookup(module, def, errorMessage);

		public void Find(ISimpleDeobfuscator simpleDeobfuscator) {
			if (CheckMethod(simpleDeobfuscator, module.EntryPoint))
				return;
			if (module.EntryPoint != null) {
				if (CheckMethod(simpleDeobfuscator, module.EntryPoint.DeclaringType.FindStaticConstructor()))
					return;
			}
		}

		bool CheckMethod(ISimpleDeobfuscator simpleDeobfuscator, MethodDef methodToCheck) {
			if (methodToCheck == null)
				return false;

			var resolverLocals = new string[] {
				"System.Byte[]",
				"System.Reflection.Assembly",
				"System.String",
				"System.IO.BinaryReader",
				"System.IO.Stream",
			};
			var resolverLocals2 = new string[] {
				"System.Reflection.Assembly",
				"System.IO.BinaryReader",
				"System.IO.Stream",
			};

			simpleDeobfuscator.Deobfuscate(methodToCheck);
			foreach (var method in DotNetUtils.GetCalledMethods(module, methodToCheck)) {
				var type = method.DeclaringType;
				if (!DotNetUtils.IsMethod(method, "System.Void", "()"))
					continue;
				if (!method.IsStatic)
					continue;

				if (type.Fields.Count != 2 && type.Fields.Count != 3)
					continue;
				if (type.HasNestedTypes)
					continue;
				if (type.HasEvents || type.HasProperties)
					continue;
				if (!CheckFields(type.Fields))
					continue;

				var resolverMethod = FindAssemblyResolveMethod(type);
				if (resolverMethod == null)
					continue;

				var localTypes = new LocalTypes(resolverMethod);
				if (!localTypes.All(resolverLocals) && !localTypes.All(resolverLocals2))
					continue;

				assemblyResolverType = type;
				assemblyResolverMethod = resolverMethod;
				assemblyResolverInitMethod = method;
				return true;
			}

			return false;
		}

		static bool CheckFields(IList<FieldDef> fields) {
			if (fields.Count != 2 && fields.Count != 3)
				return false;

			var fieldTypes = new FieldTypes(fields);
			if (fieldTypes.Count("System.Boolean") != 1)
				return false;
			if (fields.Count == 2)
				return fieldTypes.Count("System.Collections.Hashtable") == 1 ||
				fieldTypes.Count("System.Object") == 1;
			return fieldTypes.Count("System.Object") == 2;
		}

		static MethodDef FindAssemblyResolveMethod(TypeDef type) {
			foreach (var method in type.Methods) {
				if (DotNetUtils.IsMethod(method, "System.Reflection.Assembly", "(System.Object,System.ResolveEventArgs)"))
					return method;
			}
			foreach (var method in type.Methods) {
				if (DotNetUtils.IsMethod(method, "System.Reflection.Assembly", "(System.Object,System.Object)"))
					return method;
			}
			return null;
		}

		public List<ResourceInfo> GetEmbeddedAssemblies(ISimpleDeobfuscator simpleDeobfuscator, IDeobfuscator deob) {
			var infos = new List<ResourceInfo>();
			if (assemblyResolverMethod == null)
				return infos;
			simpleDeobfuscator.Deobfuscate(assemblyResolverMethod);
			simpleDeobfuscator.DecryptStrings(assemblyResolverMethod, deob);

			foreach (var resourcePrefix in DotNetUtils.GetCodeStrings(assemblyResolverMethod))
				infos.AddRange(GetResourceInfos(resourcePrefix));

			return infos;
		}

		List<ResourceInfo> GetResourceInfos(string prefix) {
			var infos = new List<ResourceInfo>();

			foreach (var resource in FindResources(prefix))
				infos.Add(new ResourceInfo(resource, GetAssemblyName(resource)));

			return infos;
		}

		List<EmbeddedResource> FindResources(string prefix) {
			var result = new List<EmbeddedResource>();

			if (string.IsNullOrEmpty(prefix))
				return result;

			foreach (var rsrc in module.Resources) {
				var resource = rsrc as EmbeddedResource;
				if (resource == null)
					continue;
				if (!Utils.StartsWith(resource.Name.String, prefix, StringComparison.Ordinal))
					continue;

				result.Add(resource);
			}

			return result;
		}

		static int unknownNameCounter = 0;
		static string GetAssemblyName(EmbeddedResource resource) {
			try {
				var resourceModule = ModuleDefMD.Load(resource.CreateReader().ToArray());
				return resourceModule.Assembly.FullName;
			}
			catch {
				return $"unknown_name_{unknownNameCounter++}";
			}
		}
	}
}



================================================
File: de4dot.code/deobfuscators/dotNET_Reactor/v4/BooleanDecrypter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using dnlib.DotNet;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.dotNET_Reactor.v4 {
	class BooleanDecrypter {
		ModuleDefMD module;
		EncryptedResource encryptedResource;
		byte[] fileData;
		byte[] decryptedData;

		public bool Detected => encryptedResource.Method != null;
		public TypeDef DecrypterType => encryptedResource.Type;
		public MethodDef Method => encryptedResource.Method;
		public EmbeddedResource Resource => encryptedResource.Resource;

		public BooleanDecrypter(ModuleDefMD module) {
			this.module = module;
			encryptedResource = new EncryptedResource(module);
		}

		public BooleanDecrypter(ModuleDefMD module, BooleanDecrypter oldOne) {
			this.module = module;
			encryptedResource = new EncryptedResource(module, oldOne.encryptedResource);
		}

		public void Find() {
			var additionalTypes = new string[] {
				"System.Boolean",
			};
			foreach (var type in module.Types) {
				if (type.BaseType == null || type.BaseType.FullName != "System.Object")
					continue;
				foreach (var method in type.Methods) {
					if (!method.IsStatic || !method.HasBody)
						continue;
					if (!DotNetUtils.IsMethod(method, "System.Boolean", "(System.Int32)"))
						continue;
					if (!encryptedResource.CouldBeResourceDecrypter(method, additionalTypes))
						continue;

					encryptedResource.Method = method;
					return;
				}
			}
		}

		public void Initialize(byte[] fileData, ISimpleDeobfuscator simpleDeobfuscator) {
			if (encryptedResource.Method == null)
				return;
			this.fileData = fileData;

			encryptedResource.Initialize(simpleDeobfuscator);
			if (!encryptedResource.FoundResource)
				return;

			Logger.v("Adding boolean decrypter. Resource: {0}", Utils.ToCsharpString(encryptedResource.Resource.Name));
			decryptedData = encryptedResource.Decrypt();
		}

		public bool Decrypt(int offset) {
			uint byteOffset = BitConverter.ToUInt32(decryptedData, offset);
			return fileData[byteOffset] == 0x80;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/dotNET_Reactor/v4/Deobfuscator.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using System.Text.RegularExpressions;
using dnlib.PE;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using dnlib.DotNet.Writer;
using de4dot.blocks;
using de4dot.blocks.cflow;

namespace de4dot.code.deobfuscators.dotNET_Reactor.v4 {
	public class DeobfuscatorInfo : DeobfuscatorInfoBase {
		public const string THE_NAME = ".NET Reactor";
		public const string THE_TYPE = "dr4";
		public const string SHORT_NAME_REGEX = @"!^[A-Za-z0-9]{2,3}$";
		const string DEFAULT_REGEX = DeobfuscatorBase.DEFAULT_ASIAN_VALID_NAME_REGEX;
		BoolOption decryptMethods;
		BoolOption decryptBools;
		BoolOption restoreTypes;
		BoolOption inlineMethods;
		BoolOption removeInlinedMethods;
		BoolOption dumpEmbeddedAssemblies;
		BoolOption decryptResources;
		BoolOption removeNamespaces;
		BoolOption removeAntiStrongName;
		BoolOption renameShort;

		public DeobfuscatorInfo()
			: base(DEFAULT_REGEX) {
			decryptMethods = new BoolOption(null, MakeArgName("methods"), "Decrypt methods", true);
			decryptBools = new BoolOption(null, MakeArgName("bools"), "Decrypt booleans", true);
			restoreTypes = new BoolOption(null, MakeArgName("types"), "Restore types (object -> real type)", true);
			inlineMethods = new BoolOption(null, MakeArgName("inline"), "Inline short methods", true);
			removeInlinedMethods = new BoolOption(null, MakeArgName("remove-inlined"), "Remove inlined methods", true);
			dumpEmbeddedAssemblies = new BoolOption(null, MakeArgName("embedded"), "Dump embedded assemblies", true);
			decryptResources = new BoolOption(null, MakeArgName("rsrc"), "Decrypt resources", true);
			removeNamespaces = new BoolOption(null, MakeArgName("ns1"), "Clear namespace if there's only one class in it", true);
			removeAntiStrongName = new BoolOption(null, MakeArgName("sn"), "Remove anti strong name code", true);
			renameShort = new BoolOption(null, MakeArgName("sname"), "Rename short names", false);
		}

		public override string Name => THE_NAME;
		public override string Type => THE_TYPE;

		public override IDeobfuscator CreateDeobfuscator() =>
			new Deobfuscator(new Deobfuscator.Options {
				ValidNameRegex = validNameRegex.Get(),
				DecryptMethods = decryptMethods.Get(),
				DecryptBools = decryptBools.Get(),
				RestoreTypes = restoreTypes.Get(),
				InlineMethods = inlineMethods.Get(),
				RemoveInlinedMethods = removeInlinedMethods.Get(),
				DumpEmbeddedAssemblies = dumpEmbeddedAssemblies.Get(),
				DecryptResources = decryptResources.Get(),
				RemoveNamespaces = removeNamespaces.Get(),
				RemoveAntiStrongName = removeAntiStrongName.Get(),
				RenameShort = renameShort.Get(),
			});

		protected override IEnumerable<Option> GetOptionsInternal() =>
			new List<Option>() {
				decryptMethods,
				decryptBools,
				restoreTypes,
				inlineMethods,
				removeInlinedMethods,
				dumpEmbeddedAssemblies,
				decryptResources,
				removeNamespaces,
				removeAntiStrongName,
				renameShort,
			};
	}

	class Deobfuscator : DeobfuscatorBase {
		Options options;
		string obfuscatorName = DeobfuscatorInfo.THE_NAME;

		MyPEImage peImage;
		byte[] fileData;
		MethodsDecrypter methodsDecrypter;
		StringDecrypter stringDecrypter;
		BooleanDecrypter booleanDecrypter;
		BooleanValueInliner booleanValueInliner;
		MetadataTokenObfuscator metadataTokenObfuscator;
		AssemblyResolver assemblyResolver;
		ResourceResolver resourceResolver;
		AntiStrongName antiStrongname;
		EmptyClass emptyClass;
		ProxyCallFixer proxyCallFixer;

		bool unpackedNativeFile = false;
		bool canRemoveDecrypterType = true;
		bool startedDeobfuscating = false;

		internal class Options : OptionsBase {
			public bool DecryptMethods { get; set; }
			public bool DecryptBools { get; set; }
			public bool RestoreTypes { get; set; }
			public bool InlineMethods { get; set; }
			public bool RemoveInlinedMethods { get; set; }
			public bool DumpEmbeddedAssemblies { get; set; }
			public bool DecryptResources { get; set; }
			public bool RemoveNamespaces { get; set; }
			public bool RemoveAntiStrongName { get; set; }
			public bool RenameShort { get; set; }
		}

		public override string Type => DeobfuscatorInfo.THE_TYPE;
		public override string TypeLong => DeobfuscatorInfo.THE_NAME + " 4.x";
		public override string Name => obfuscatorName;
		protected override bool CanInlineMethods => startedDeobfuscating ? options.InlineMethods : true;

		public override IEnumerable<IBlocksDeobfuscator> BlocksDeobfuscators {
			get {
				var list = new List<IBlocksDeobfuscator>();
				if (CanInlineMethods)
					list.Add(new DnrMethodCallInliner());
				return list;
			}
		}

		public Deobfuscator(Options options)
			: base(options) {
			this.options = options;

			if (options.RemoveNamespaces)
				RenamingOptions |= RenamingOptions.RemoveNamespaceIfOneType;
			else
				RenamingOptions &= ~RenamingOptions.RemoveNamespaceIfOneType;
			if (options.RenameShort)
				options.ValidNameRegex.Regexes.Insert(0, new NameRegex(DeobfuscatorInfo.SHORT_NAME_REGEX));
		}

		public override byte[] UnpackNativeFile(IPEImage peImage) {
			var data = new NativeImageUnpacker(peImage).Unpack();
			if (data == null)
				return null;

			unpackedNativeFile = true;
			ModuleBytes = data;
			return data;
		}

		public override void Initialize(ModuleDefMD module) => base.Initialize(module);

		static Regex isRandomName = new Regex(@"^[A-Z]{30,40}$");
		static Regex isRandomNameMembers = new Regex(@"^[a-zA-Z0-9]{9,11}$");	// methods, fields, props, events
		static Regex isRandomNameTypes = new Regex(@"^[a-zA-Z0-9]{18,20}(?:`\d+)?$");	// types, namespaces

		bool CheckValidName(string name, Regex regex) {
			if (isRandomName.IsMatch(name))
				return false;
			if (regex.IsMatch(name)) {
				if (RandomNameChecker.IsRandom(name))
					return false;
				if (!RandomNameChecker.IsNonRandom(name))
					return false;
			}
			return CheckValidName(name);
		}

		public override bool IsValidNamespaceName(string ns) {
			if (ns == null)
				return false;
			if (ns.Contains("."))
				return base.IsValidNamespaceName(ns);
			return CheckValidName(ns, isRandomNameTypes);
		}

		public override bool IsValidTypeName(string name) => name != null && CheckValidName(name, isRandomNameTypes);
		public override bool IsValidMethodName(string name) => name != null && CheckValidName(name, isRandomNameMembers);
		public override bool IsValidPropertyName(string name) => name != null && CheckValidName(name, isRandomNameMembers);
		public override bool IsValidEventName(string name) => name != null && CheckValidName(name, isRandomNameMembers);
		public override bool IsValidFieldName(string name) => name != null && CheckValidName(name, isRandomNameMembers);
		public override bool IsValidGenericParamName(string name) => name != null && CheckValidName(name, isRandomNameMembers);
		public override bool IsValidMethodArgName(string name) => name != null && CheckValidName(name, isRandomNameMembers);
		public override bool IsValidMethodReturnArgName(string name) => string.IsNullOrEmpty(name) || CheckValidName(name, isRandomNameMembers);
		public override bool IsValidResourceKeyName(string name) => name != null && CheckValidName(name, isRandomNameMembers);

		protected override int DetectInternal() {
			int val = 0;

			int sum = ToInt32(methodsDecrypter.Detected) +
					ToInt32(stringDecrypter.Detected) +
					ToInt32(booleanDecrypter.Detected) +
					ToInt32(assemblyResolver.Detected) +
					ToInt32(resourceResolver.Detected);
			if (sum > 0)
				val += 100 + 10 * (sum - 1);

			if (sum == 0) {
				if (HasMetadataStream("#GUlD") && HasMetadataStream("#Blop"))
					val += 10;
			}

			return val;
		}

		protected override void ScanForObfuscator() {
			methodsDecrypter = new MethodsDecrypter(module);
			methodsDecrypter.Find();
			stringDecrypter = new StringDecrypter(module);
			stringDecrypter.Find(DeobfuscatedFile);
			booleanDecrypter = new BooleanDecrypter(module);
			booleanDecrypter.Find();
			assemblyResolver = new AssemblyResolver(module);
			assemblyResolver.Find(DeobfuscatedFile);
			obfuscatorName = DetectVersion();
			if (unpackedNativeFile)
				obfuscatorName += " (native)";
			resourceResolver = new ResourceResolver(module);
			resourceResolver.Find(DeobfuscatedFile);
		}

		string DetectVersion() {
			/*
			Methods decrypter locals (not showing its own types):
			3.7.0.3:
					"System.Byte[]"
					"System.Int32"
					"System.Int32[]"
					"System.IntPtr"
					"System.IO.BinaryReader"
					"System.IO.MemoryStream"
					"System.Object"
					"System.Reflection.Assembly"
					"System.Security.Cryptography.CryptoStream"
					"System.Security.Cryptography.ICryptoTransform"
					"System.Security.Cryptography.RijndaelManaged"
					"System.String"

			3.9.8.0:
			-		"System.Int32[]"
			+		"System.Diagnostics.StackFrame"

			4.0.0.0: (jitter)
			-		"System.Diagnostics.StackFrame"
			-		"System.Object"
			+		"System.Boolean"
			+		"System.Collections.IEnumerator"
			+		"System.Delegate"
			+		"System.Diagnostics.Process"
			+		"System.Diagnostics.ProcessModule"
			+		"System.Diagnostics.ProcessModuleCollection"
			+		"System.IDisposable"
			+		"System.Int64"
			+		"System.UInt32"
			+		"System.UInt64"

			4.1.0.0: (jitter)
			+		"System.Reflection.Assembly"

			4.3.1.0: (jitter)
			+		"System.Byte&"
			*/

			LocalTypes localTypes;
			int minVer = -1;
			foreach (var info in stringDecrypter.DecrypterInfos) {
				if (info.key == null)
					continue;
				localTypes = new LocalTypes(info.method);
				if (!localTypes.Exists("System.IntPtr"))
					return DeobfuscatorInfo.THE_NAME + " <= 3.7";
				minVer = 3800;
				break;
			}

			if (methodsDecrypter.DecrypterTypeVersion != DnrDecrypterType.V1)
				return DeobfuscatorInfo.THE_NAME;

			if (methodsDecrypter.Method == null) {
				if (minVer >= 3800)
					return DeobfuscatorInfo.THE_NAME + " >= 3.8";
				return DeobfuscatorInfo.THE_NAME;
			}
			localTypes = new LocalTypes(methodsDecrypter.Method);

			if (localTypes.Exists("System.Int32[]")) {
				if (minVer >= 3800)
					return DeobfuscatorInfo.THE_NAME + " 3.8.4.1 - 3.9.0.1";
				return DeobfuscatorInfo.THE_NAME + " <= 3.9.0.1";
			}
			if (!localTypes.Exists("System.Diagnostics.Process")) {	// If < 4.0
				if (localTypes.Exists("System.Diagnostics.StackFrame"))
					return DeobfuscatorInfo.THE_NAME + " 3.9.8.0";
			}

			var compileMethod = MethodsDecrypter.FindDnrCompileMethod(methodsDecrypter.Method.DeclaringType);
			if (compileMethod == null) {
				DeobfuscatedFile.Deobfuscate(methodsDecrypter.Method);
				if (!MethodsDecrypter.IsNewer45Decryption(methodsDecrypter.Method))
					return DeobfuscatorInfo.THE_NAME + " < 4.0";
				return DeobfuscatorInfo.THE_NAME + " 4.5+";
			}
			DeobfuscatedFile.Deobfuscate(compileMethod);
			bool compileMethodHasConstant_0x70000000 = DeobUtils.HasInteger(compileMethod, 0x70000000);	// 4.0-4.1
			DeobfuscatedFile.Deobfuscate(methodsDecrypter.Method);
			bool hasCorEnableProfilingString = FindString(methodsDecrypter.Method, "Cor_Enable_Profiling");	// 4.1-4.4
			bool hasCatchString = FindString(methodsDecrypter.Method, "catch: ");	// <= 4.7

			if (compileMethodHasConstant_0x70000000) {
				if (hasCorEnableProfilingString)
					return DeobfuscatorInfo.THE_NAME + " 4.1";
				return DeobfuscatorInfo.THE_NAME + " 4.0";
			}
			if (!hasCorEnableProfilingString) {
				bool callsReverse = DotNetUtils.CallsMethod(methodsDecrypter.Method, "System.Void System.Array::Reverse(System.Array)");
				if (!callsReverse)
					return DeobfuscatorInfo.THE_NAME + " 4.0 - 4.4";

				int numIntPtrSizeCompares = CountCompareSystemIntPtrSize(methodsDecrypter.Method);
				bool hasSymmetricAlgorithm = new LocalTypes(methodsDecrypter.Method).Exists("System.Security.Cryptography.SymmetricAlgorithm");
				if (module.IsClr40) {
					switch (numIntPtrSizeCompares) {
					case 7:
					case 9: return DeobfuscatorInfo.THE_NAME + " 4.5";
					case 10:
						if (!hasSymmetricAlgorithm)
							return DeobfuscatorInfo.THE_NAME + " 4.6";
						if (hasCatchString)
							return DeobfuscatorInfo.THE_NAME + " 4.7";
						return DeobfuscatorInfo.THE_NAME + " 4.8";
					}
				}
				else {
					switch (numIntPtrSizeCompares) {
					case 6:
					case 8: return DeobfuscatorInfo.THE_NAME + " 4.5";
					case 9:
						if (!hasSymmetricAlgorithm)
							return DeobfuscatorInfo.THE_NAME + " 4.6";
						if (hasCatchString)
							return DeobfuscatorInfo.THE_NAME + " 4.7";
						return DeobfuscatorInfo.THE_NAME + " 4.8";
					}
				}

				// Should never be reached unless it's a new version
				return DeobfuscatorInfo.THE_NAME + " 4.5+";
			}

			// 4.2-4.4

			if (!localTypes.Exists("System.Byte&"))
				return DeobfuscatorInfo.THE_NAME + " 4.2";

			localTypes = new LocalTypes(compileMethod);
			if (localTypes.Exists("System.Object"))
				return DeobfuscatorInfo.THE_NAME + " 4.4";
			return DeobfuscatorInfo.THE_NAME + " 4.3";
		}

		static int CountCompareSystemIntPtrSize(MethodDef method) {
			if (method == null || method.Body == null)
				return 0;
			int count = 0;
			var instrs = method.Body.Instructions;
			for (int i = 1; i < instrs.Count - 1; i++) {
				var ldci4 = instrs[i];
				if (!ldci4.IsLdcI4() || ldci4.GetLdcI4Value() != 4)
					continue;
				if (!instrs[i + 1].IsConditionalBranch())
					continue;
				var call = instrs[i - 1];
				if (call.OpCode.Code != Code.Call)
					continue;
				var calledMethod = call.Operand as MemberRef;
				if (calledMethod == null || calledMethod.FullName != "System.Int32 System.IntPtr::get_Size()")
					continue;

				count++;
			}
			return count;
		}

		static bool FindString(MethodDef method, string s) {
			foreach (var cs in DotNetUtils.GetCodeStrings(method)) {
				if (cs == s)
					return true;
			}
			return false;
		}

		public override bool GetDecryptedModule(int count, ref byte[] newFileData, ref DumpedMethods dumpedMethods) {
			if (count != 0)
				return false;
			fileData = ModuleBytes ?? DeobUtils.ReadModule(module);
			peImage = new MyPEImage(fileData);

			if (!options.DecryptMethods)
				return false;

			var tokenToNativeCode = new Dictionary<uint,byte[]>();
			if (!methodsDecrypter.Decrypt(peImage, DeobfuscatedFile, ref dumpedMethods, tokenToNativeCode, unpackedNativeFile))
				return false;

			newFileData = fileData;
			return true;
		}

		public override IDeobfuscator ModuleReloaded(ModuleDefMD module) {
			FreePEImage();
			var newOne = new Deobfuscator(options);
			newOne.SetModule(module);
			newOne.fileData = fileData;
			newOne.peImage = new MyPEImage(fileData);
			newOne.methodsDecrypter = new MethodsDecrypter(module, methodsDecrypter);
			newOne.stringDecrypter = new StringDecrypter(module, stringDecrypter);
			newOne.booleanDecrypter = new BooleanDecrypter(module, booleanDecrypter);
			newOne.assemblyResolver = new AssemblyResolver(module, assemblyResolver);
			newOne.resourceResolver = new ResourceResolver(module, resourceResolver);
			newOne.methodsDecrypter.Reloaded();
			return newOne;
		}

		void FreePEImage() {
			if (peImage != null)
				peImage.Dispose();
			peImage = null;
		}

		public override void DeobfuscateBegin() {
			base.DeobfuscateBegin();

			proxyCallFixer = new ProxyCallFixer(module, DeobfuscatedFile);
			proxyCallFixer.FindDelegateCreator();
			proxyCallFixer.Find();

			bool decryptStrings = Operations.DecryptStrings == OpDecryptString.Static;
			if (decryptStrings)
				stringDecrypter.Initialize(peImage, fileData, DeobfuscatedFile);
			if (!stringDecrypter.Detected || !decryptStrings)
				FreePEImage();
			booleanDecrypter.Initialize(fileData, DeobfuscatedFile);
			booleanValueInliner = new BooleanValueInliner();
			emptyClass = new EmptyClass(module);

			if (options.DecryptBools) {
				booleanValueInliner.Add(booleanDecrypter.Method, (method, gim, args) => {
					return booleanDecrypter.Decrypt((int)args[0]);
				});
			}

			if (decryptStrings) {
				foreach (var info in stringDecrypter.DecrypterInfos) {
					staticStringInliner.Add(info.method, (method2, gim, args) => {
						return stringDecrypter.Decrypt(method2, (int)args[0]);
					});
				}
				if (stringDecrypter.OtherStringDecrypter != null) {
					staticStringInliner.Add(stringDecrypter.OtherStringDecrypter, (method2, gim, args) => {
						return stringDecrypter.Decrypt((string)args[0]);
					});
				}
			}
			DeobfuscatedFile.StringDecryptersAdded();

			metadataTokenObfuscator = new MetadataTokenObfuscator(module);
			antiStrongname = new AntiStrongName(GetDecrypterType());

			bool removeResourceResolver = false;
			if (options.DecryptResources) {
				resourceResolver.Initialize(DeobfuscatedFile, this);
				DecryptResources();
				if (options.InlineMethods) {
					AddTypeToBeRemoved(resourceResolver.Type, "Resource decrypter type");
					removeResourceResolver = true;
				}
				AddEntryPointCallToBeRemoved(resourceResolver.InitMethod);
				AddCctorInitCallToBeRemoved(resourceResolver.InitMethod);
			}
			if (resourceResolver.Detected && !removeResourceResolver && !resourceResolver.FoundResource)
				canRemoveDecrypterType = false;	// There may be calls to its .ctor

			if (Operations.DecryptStrings != OpDecryptString.None)
				AddResourceToBeRemoved(stringDecrypter.Resource, "Encrypted strings");
			else
				canRemoveDecrypterType = false;

			if (options.DecryptMethods && !methodsDecrypter.HasNativeMethods) {
				AddResourceToBeRemoved(methodsDecrypter.Resource, "Encrypted methods");
				AddCctorInitCallToBeRemoved(methodsDecrypter.Method);
			}
			else
				canRemoveDecrypterType = false;

			if (options.DecryptBools)
				AddResourceToBeRemoved(booleanDecrypter.Resource, "Encrypted booleans");
			else
				canRemoveDecrypterType = false;

			if (!options.RemoveAntiStrongName)
				canRemoveDecrypterType = false;

			// The inlined methods may contain calls to the decrypter class
			if (!options.InlineMethods)
				canRemoveDecrypterType = false;

			if (options.DumpEmbeddedAssemblies) {
				if (options.InlineMethods)
					AddTypeToBeRemoved(assemblyResolver.Type, "Assembly resolver");
				AddEntryPointCallToBeRemoved(assemblyResolver.InitMethod);
				AddCctorInitCallToBeRemoved(assemblyResolver.InitMethod);
				DumpEmbeddedAssemblies();
			}

			if (options.InlineMethods)
				AddTypeToBeRemoved(metadataTokenObfuscator.Type, "Metadata token obfuscator");

			AddCctorInitCallToBeRemoved(emptyClass.Method);
			AddCtorInitCallToBeRemoved(emptyClass.Method);
			AddEntryPointCallToBeRemoved(emptyClass.Method);
			if (options.InlineMethods)
				AddTypeToBeRemoved(emptyClass.Type, "Empty class");

			startedDeobfuscating = true;
		}

		void AddEntryPointCallToBeRemoved(MethodDef methodToBeRemoved) {
			var entryPoint = module.EntryPoint;
			AddCallToBeRemoved(entryPoint, methodToBeRemoved);
			foreach (var calledMethod in DotNetUtils.GetCalledMethods(module, entryPoint))
				AddCallToBeRemoved(calledMethod, methodToBeRemoved);
		}

		void DecryptResources() {
			var rsrc = resourceResolver.MergeResources();
			if (rsrc == null)
				return;
			AddResourceToBeRemoved(rsrc, "Encrypted resources");
		}

		void DumpEmbeddedAssemblies() {
			if (!options.DumpEmbeddedAssemblies)
				return;
			foreach (var info in assemblyResolver.GetEmbeddedAssemblies(DeobfuscatedFile, this)) {
				var simpleName = Utils.GetAssemblySimpleName(info.name);
				DeobfuscatedFile.CreateAssemblyFile(info.resource.CreateReader().ToArray(), simpleName, null);
				AddResourceToBeRemoved(info.resource, $"Embedded assembly: {info.name}");
			}
		}

		public override bool DeobfuscateOther(Blocks blocks) => booleanValueInliner.Decrypt(blocks) > 0;

		public override void DeobfuscateMethodEnd(Blocks blocks) {
			proxyCallFixer.Deobfuscate(blocks);
			metadataTokenObfuscator.Deobfuscate(blocks);
			FixTypeofDecrypterInstructions(blocks);
			RemoveAntiStrongNameCode(blocks);
			base.DeobfuscateMethodEnd(blocks);
		}

		void RemoveAntiStrongNameCode(Blocks blocks) {
			if (!options.RemoveAntiStrongName)
				return;
			if (antiStrongname.Remove(blocks))
				Logger.v("Removed anti strong name code");
		}

		TypeDef GetDecrypterType() => methodsDecrypter.DecrypterType ?? stringDecrypter.DecrypterType ?? booleanDecrypter.DecrypterType;

		void FixTypeofDecrypterInstructions(Blocks blocks) {
			var type = GetDecrypterType();
			if (type == null)
				return;

			foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {
				var instructions = block.Instructions;
				for (int i = 0; i < instructions.Count; i++) {
					var instr = instructions[i];
					if (instr.OpCode.Code != Code.Ldtoken)
						continue;
					if (!new SigComparer().Equals(type, instr.Operand as ITypeDefOrRef))
						continue;
					instructions[i] = new Instr(OpCodes.Ldtoken.ToInstruction(blocks.Method.DeclaringType));
				}
			}
		}

		public override void DeobfuscateEnd() {
			FreePEImage();
			RemoveProxyDelegates(proxyCallFixer);
			RemoveInlinedMethods();
			if (options.RestoreTypes)
				new TypesRestorer(module).Deobfuscate();

			var decrypterType = GetDecrypterType();
			if (canRemoveDecrypterType && IsTypeCalled(decrypterType))
				canRemoveDecrypterType = false;

			if (canRemoveDecrypterType)
				AddTypeToBeRemoved(decrypterType, "Decrypter type");
			else
				Logger.v("Could not remove decrypter type");

			FixEntryPoint();

			base.DeobfuscateEnd();
		}

		void FixEntryPoint() {
			if (!module.IsClr1x)
				return;

			var ep = module.EntryPoint;
			if (ep == null)
				return;
			if (ep.MethodSig.GetParamCount() <= 1)
				return;

			ep.MethodSig = MethodSig.CreateStatic(ep.MethodSig.RetType, new SZArraySig(module.CorLibTypes.String));
			ep.ParamDefs.Clear();
			ep.Parameters.UpdateParameterTypes();
		}

		void RemoveInlinedMethods() {
			if (!options.InlineMethods || !options.RemoveInlinedMethods)
				return;
			FindAndRemoveInlinedMethods();
		}

		public override IEnumerable<int> GetStringDecrypterMethods() {
			var list = new List<int>();
			foreach (var info in stringDecrypter.DecrypterInfos)
				list.Add(info.method.MDToken.ToInt32());
			if (stringDecrypter.OtherStringDecrypter != null)
				list.Add(stringDecrypter.OtherStringDecrypter.MDToken.ToInt32());
			return list;
		}

		public override void OnWriterEvent(ModuleWriterBase writer, ModuleWriterEvent evt) {
			if (!options.DecryptMethods || !methodsDecrypter.HasNativeMethods)
				return;
			switch (evt) {
			case ModuleWriterEvent.Begin:
				// The decrypter assumes RVAs are unique so don't share any method bodies
				writer.TheOptions.ShareMethodBodies = false;
				break;

			case ModuleWriterEvent.MDBeginAddResources:
				methodsDecrypter.PrepareEncryptNativeMethods(writer);
				break;

			case ModuleWriterEvent.BeginWriteChunks:
				methodsDecrypter.EncryptNativeMethods(writer);
				break;
			}
		}

		protected override void Dispose(bool disposing) {
			if (disposing)
				FreePEImage();
			base.Dispose(disposing);
		}
	}
}



================================================
File: de4dot.code/deobfuscators/dotNET_Reactor/v4/DnrMethodCallInliner.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet.Emit;
using de4dot.blocks;
using de4dot.blocks.cflow;

namespace de4dot.code.deobfuscators.dotNET_Reactor.v4 {
	class DnrMethodCallInliner : MethodCallInliner {
		public DnrMethodCallInliner()
			: base(false) {
		}

		protected override Instruction GetFirstInstruction(IList<Instruction> instrs, ref int index) {
			var instr = GetFirstInstruction(instrs, index);
			if (instr != null)
				index = instrs.IndexOf(instr);
			return DotNetUtils.GetInstruction(instrs, ref index);
		}

		Instruction GetFirstInstruction(IList<Instruction> instrs, int index) {
			try {
				var instr = instrs[index];
				if (!instr.IsBr())
					return null;
				instr = instr.Operand as Instruction;
				if (instr == null)
					return null;
				if (!instr.IsLdcI4() || instr.GetLdcI4Value() != 0)
					return null;
				instr = instrs[instrs.IndexOf(instr) + 1];
				if (!instr.IsBrtrue())
					return null;
				return instrs[instrs.IndexOf(instr) + 1];
			}
			catch {
				return null;
			}
		}
	}
}



================================================
File: de4dot.code/deobfuscators/dotNET_Reactor/v4/EmptyClass.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using dnlib.DotNet;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.dotNET_Reactor.v4 {
	// Detect some empty class that is called from most .ctor's
	class EmptyClass {
		ModuleDefMD module;
		MethodDef emptyMethod;

		public MethodDef Method => emptyMethod;
		public TypeDef Type => emptyMethod?.DeclaringType;

		public EmptyClass(ModuleDefMD module) {
			this.module = module;
			Initialize();
		}

		void Initialize() {
			var callCounter = new CallCounter();
			int count = 0;
			foreach (var type in module.GetTypes()) {
				if (count >= 40)
					break;
				foreach (var method in type.Methods) {
					if (method.Name != ".ctor" && method.Name != ".cctor" && module.EntryPoint != method)
						continue;
					foreach (var calledMethod in DotNetUtils.GetCalledMethods(module, method)) {
						if (!calledMethod.IsStatic || calledMethod.Body == null)
							continue;
						if (!DotNetUtils.IsMethod(calledMethod, "System.Void", "()"))
							continue;
						if (IsEmptyClass(calledMethod)) {
							callCounter.Add(calledMethod);
							count++;
						}
					}
				}
			}

			var theMethod = (MethodDef)callCounter.Most(out int numCalls);
			if (numCalls >= 10)
				emptyMethod = theMethod;
		}

		bool IsEmptyClass(MethodDef emptyMethod) {
			if (!DotNetUtils.IsEmptyObfuscated(emptyMethod))
				return false;

			var type = emptyMethod.DeclaringType;
			if (type.HasEvents || type.HasProperties)
				return false;
			if (type.Fields.Count != 1)
				return false;
			if (type.Fields[0].FieldType.FullName != "System.Boolean")
				return false;
			if (type.IsPublic)
				return false;

			int otherMethods = 0;
			foreach (var method in type.Methods) {
				if (method.Name == ".ctor" || method.Name == ".cctor")
					continue;
				if (method == emptyMethod)
					continue;
				otherMethods++;
				if (method.Body == null)
					return false;
				if (method.Body.Instructions.Count > 20)
					return false;
			}
			if (otherMethods > 8)
				return false;

			return true;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/dotNET_Reactor/v4/EncryptedResource.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Security.Cryptography;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;
using de4dot.blocks.cflow;
using dnlib.IO;

namespace de4dot.code.deobfuscators.dotNET_Reactor.v4 {
	enum DnrDecrypterType {
		Unknown,
		V1,
		V2,
	}

	class EncryptedResource {
		ModuleDefMD module;
		MethodDef resourceDecrypterMethod;
		EmbeddedResource encryptedDataResource;
		IDecrypter decrypter;

		public DnrDecrypterType DecrypterTypeVersion => decrypter == null ? DnrDecrypterType.Unknown : decrypter.DecrypterType;
		public TypeDef Type => resourceDecrypterMethod?.DeclaringType;

		public MethodDef Method {
			get => resourceDecrypterMethod;
			set => resourceDecrypterMethod = value;
		}

		public EmbeddedResource Resource => encryptedDataResource;
		public bool FoundResource => encryptedDataResource != null;
		public EncryptedResource(ModuleDefMD module) => this.module = module;

		public EncryptedResource(ModuleDefMD module, EncryptedResource oldOne) {
			this.module = module;
			resourceDecrypterMethod = Lookup(oldOne.resourceDecrypterMethod, "Could not find resource decrypter method");
			if (oldOne.encryptedDataResource != null)
				encryptedDataResource = DotNetUtils.GetResource(module, oldOne.encryptedDataResource.Name.String) as EmbeddedResource;
			decrypter = oldOne.decrypter;

			if (encryptedDataResource == null && oldOne.encryptedDataResource != null)
				throw new ApplicationException("Could not initialize EncryptedResource");
		}

		public void SetNewResource(byte[] data) {
			var dataReaderFactory = ByteArrayDataReaderFactory.Create(data, filename: null);
			var newResource = new EmbeddedResource(encryptedDataResource.Name, dataReaderFactory, 0, (uint)data.Length, encryptedDataResource.Attributes);
			int index = module.Resources.IndexOf(encryptedDataResource);
			encryptedDataResource = newResource;
			module.Resources[index] = encryptedDataResource;
		}

		T Lookup<T>(T def, string errorMessage) where T : class, ICodedToken =>
			DeobUtils.Lookup(module, def, errorMessage);

		public bool CouldBeResourceDecrypter(MethodDef method, IList<string> additionalTypes) =>
			CouldBeResourceDecrypter(method, additionalTypes, true);

		public bool CouldBeResourceDecrypter(MethodDef method, IList<string> additionalTypes, bool checkResource) {
			if (GetDecrypterType(method, additionalTypes) == DnrDecrypterType.Unknown)
				return false;

			if (checkResource && FindMethodsDecrypterResource(method) == null)
				return false;

			return true;
		}

		public DnrDecrypterType GuessDecrypterType() => GetDecrypterType(resourceDecrypterMethod, null);

		static DnrDecrypterType GetDecrypterType(MethodDef method, IList<string> additionalTypes) {
			if (method == null || !method.IsStatic || method.Body == null)
				return DnrDecrypterType.Unknown;

			if (additionalTypes == null)
				additionalTypes = new string[0];
			var localTypes = new LocalTypes(method);
			if (DecrypterV1.CouldBeResourceDecrypter(method, localTypes, additionalTypes))
				return DnrDecrypterType.V1;
			else if (DecrypterV2.CouldBeResourceDecrypter(method, localTypes, additionalTypes))
				return DnrDecrypterType.V2;
			return DnrDecrypterType.Unknown;
		}

		public void Initialize(ISimpleDeobfuscator simpleDeobfuscator) {
			if (resourceDecrypterMethod == null)
				return;

			simpleDeobfuscator.Deobfuscate(resourceDecrypterMethod);

			encryptedDataResource = FindMethodsDecrypterResource(resourceDecrypterMethod);
			if (encryptedDataResource == null)
				return;

			var key = ArrayFinder.GetInitializedByteArray(resourceDecrypterMethod, 32);
			if (key == null)
				throw new ApplicationException("Could not find resource decrypter key");
			var iv = ArrayFinder.GetInitializedByteArray(resourceDecrypterMethod, 16);
			if (iv == null)
				throw new ApplicationException("Could not find resource decrypter IV");
			if (NeedReverse())
				Array.Reverse(iv);	// DNR 4.5.0.0
			if (UsesPublicKeyToken()) {
				var publicKeyToken = module.Assembly.PublicKeyToken;
				if (publicKeyToken != null && publicKeyToken.Data.Length > 0) {
					for (int i = 0; i < 8; i++)
						iv[i * 2 + 1] = publicKeyToken.Data[i];
				}
			}

			var decrypterType = GetDecrypterType(resourceDecrypterMethod, new string[0]);
			switch (decrypterType) {
			case DnrDecrypterType.V1: decrypter = new DecrypterV1(iv, key); break;
			case DnrDecrypterType.V2: decrypter = new DecrypterV2(iv, key, resourceDecrypterMethod); break;
			default: throw new ApplicationException("Unknown decrypter type");
			}
		}

		static int[] pktIndexes = new int[16] { 1, 0, 3, 1, 5, 2, 7, 3, 9, 4, 11, 5, 13, 6, 15, 7 };
		bool UsesPublicKeyToken() {
			int pktIndex = 0;
			foreach (var instr in resourceDecrypterMethod.Body.Instructions) {
				if (instr.OpCode.FlowControl != FlowControl.Next) {
					pktIndex = 0;
					continue;
				}
				if (!instr.IsLdcI4())
					continue;
				int val = instr.GetLdcI4Value();
				if (val != pktIndexes[pktIndex++]) {
					pktIndex = 0;
					continue;
				}
				if (pktIndex >= pktIndexes.Length)
					return true;
			}
			return false;
		}

		bool NeedReverse() => DotNetUtils.CallsMethod(resourceDecrypterMethod, "System.Void System.Array::Reverse(System.Array)");

		EmbeddedResource FindMethodsDecrypterResource(MethodDef method) {
			foreach (var s in DotNetUtils.GetCodeStrings(method)) {
				if (DotNetUtils.GetResource(module, s) is EmbeddedResource resource)
					return resource;
			}
			return null;
		}

		interface IDecrypter {
			DnrDecrypterType DecrypterType { get; }
			byte[] Decrypt(EmbeddedResource resource);
			byte[] Encrypt(byte[] data);
		}

		class DecrypterV1 : IDecrypter {
			readonly byte[] key, iv;

			public DnrDecrypterType DecrypterType => DnrDecrypterType.V1;

			public DecrypterV1(byte[] iv, byte[] key) {
				this.iv = iv;
				this.key = key;
			}

			public static bool CouldBeResourceDecrypter(MethodDef method, LocalTypes localTypes, IList<string> additionalTypes) {
				var requiredTypes = new List<string> {
					"System.Byte[]",
					"System.IO.BinaryReader",
					"System.IO.MemoryStream",
					"System.Security.Cryptography.CryptoStream",
					"System.Security.Cryptography.ICryptoTransform",
				};
				requiredTypes.AddRange(additionalTypes);
				if (!localTypes.All(requiredTypes))
					return false;

				if (DotNetUtils.GetMethod(method.DeclaringType, "System.Security.Cryptography.SymmetricAlgorithm", "()") != null) {
					if (localTypes.Exists("System.UInt64") || (localTypes.Exists("System.UInt32") && !localTypes.Exists("System.Reflection.Assembly")))
						return false;
				}

				if (!localTypes.Exists("System.Security.Cryptography.RijndaelManaged") &&
					!localTypes.Exists("System.Security.Cryptography.AesManaged") &&
					!localTypes.Exists("System.Security.Cryptography.SymmetricAlgorithm"))
					return false;

				return true;
			}

			public byte[] Decrypt(EmbeddedResource resource) => DeobUtils.AesDecrypt(resource.CreateReader().ToArray(), key, iv);

			public byte[] Encrypt(byte[] data) {
				using (var aes = new RijndaelManaged { Mode = CipherMode.CBC }) {
					using (var transform = aes.CreateEncryptor(key, iv)) {
						return transform.TransformFinalBlock(data, 0, data.Length);
					}
				}
			}
		}

		class DecrypterV2 : IDecrypter {
			readonly byte[] key, iv;
			readonly MethodDef method;
			List<Instruction> instructions;
			readonly List<Local> locals;
			readonly InstructionEmulator instrEmulator = new InstructionEmulator();
			Local emuLocal;

			public DnrDecrypterType DecrypterType => DnrDecrypterType.V2;

			public DecrypterV2(byte[] iv, byte[] key, MethodDef method) {
				this.iv = iv;
				this.key = key;
				this.method = method;
				locals = new List<Local>(method.Body.Variables);
				if (!Initialize())
					throw new ApplicationException("Could not initialize decrypter");
			}

			public static bool CouldBeResourceDecrypter(MethodDef method, LocalTypes localTypes, IList<string> additionalTypes) {
				var requiredTypes = new List<string> {
					"System.UInt32",
					"System.String",
					"System.Int32",
					"System.Byte[]",
					"System.IO.BinaryReader",
				};
				requiredTypes.AddRange(additionalTypes);
				if (!localTypes.All(requiredTypes))
					return false;

				return true;
			}

			bool Initialize() {
				for (int i = 0; i < iv.Length; i++)
					key[i] ^= iv[i];

				var origInstrs = method.Body.Instructions;

				if (!Find(origInstrs, out int emuStartIndex, out int emuEndIndex, out emuLocal)) {
					if (!FindStartEnd(origInstrs, out emuStartIndex, out emuEndIndex, out emuLocal))
						return false;
				}

				int count = emuEndIndex - emuStartIndex + 1;
				instructions = new List<Instruction>(count);
				for (int i = 0; i < count; i++)
					instructions.Add(origInstrs[emuStartIndex + i].Clone());

				return true;
			}

			bool Find(IList<Instruction> instrs, out int startIndex, out int endIndex, out Local tmpLocal) {
				startIndex = 0;
				endIndex = 0;
				tmpLocal = null;

				if (!FindStart(instrs, out int emuStartIndex, out emuLocal))
					return false;
				if (!FindEnd(instrs, emuStartIndex, out int emuEndIndex))
					return false;
				startIndex = emuStartIndex;
				endIndex = emuEndIndex;
				tmpLocal = emuLocal;
				return true;
			}

			bool FindStartEnd(IList<Instruction> instrs, out int startIndex, out int endIndex, out Local tmpLocal) {
				for (int i = 0; i + 8 < instrs.Count; i++) {
					if (instrs[i].OpCode.Code != Code.Conv_R_Un)
						continue;
					if (instrs[i + 1].OpCode.Code != Code.Conv_R8)
						continue;
					if (instrs[i + 2].OpCode.Code != Code.Conv_U4)
						continue;
					if (instrs[i + 3].OpCode.Code != Code.Add)
						continue;
					int newEndIndex = i + 3;
					int newStartIndex = -1;
					for (int x = newEndIndex; x > 0; x--)
						if (instrs[x].OpCode.FlowControl != FlowControl.Next) {
							newStartIndex = x + 1;
							break;
						}
					if (newStartIndex < 0)
						continue;

					var checkLocs = new List<Local>();
					int ckStartIndex = -1;
					for (int y = newEndIndex; y >= newStartIndex; y--) {
						var loc = CheckLocal(instrs[y], true);
						if (loc == null)
							continue;
						if (!checkLocs.Contains(loc))
							checkLocs.Add(loc);
						if (checkLocs.Count == 3)
							break;
						ckStartIndex = y;
					}
					endIndex = newEndIndex;
					startIndex = Math.Max(ckStartIndex, newStartIndex);
					tmpLocal = CheckLocal(instrs[startIndex], true);
					return true;
				}
				endIndex = 0;
				startIndex = 0;
				tmpLocal = null;
				return false;
			}

			bool FindStart(IList<Instruction> instrs, out int startIndex, out Local tmpLocal) {
				for (int i = 0; i + 8 < instrs.Count; i++) {
					if (instrs[i].OpCode.Code != Code.Conv_U)
						continue;
					if (instrs[i + 1].OpCode.Code != Code.Ldelem_U1)
						continue;
					if (instrs[i + 2].OpCode.Code != Code.Or)
						continue;
					if (CheckLocal(instrs[i + 3], false) == null)
						continue;
					Local local;
					if ((local = CheckLocal(instrs[i + 4], true)) == null)
						continue;
					if (CheckLocal(instrs[i + 5], true) == null)
						continue;
					if (instrs[i + 6].OpCode.Code != Code.Add)
						continue;
					if (CheckLocal(instrs[i + 7], false) != local)
						continue;
					var instr = instrs[i + 8];
					int newStartIndex = i + 8;
					if (instr.IsBr()) {
						instr = instr.Operand as Instruction;
						newStartIndex = instrs.IndexOf(instr);
					}
					if (newStartIndex < 0 || instr == null)
						continue;
					if (CheckLocal(instr, true) != local)
						continue;

					startIndex = newStartIndex;
					tmpLocal = local;
					return true;
				}

				startIndex = 0;
				tmpLocal = null;
				return false;
			}

			bool FindEnd(IList<Instruction> instrs, int startIndex, out int endIndex) {
				for (int i = startIndex; i < instrs.Count; i++) {
					var instr = instrs[i];
					if (instr.OpCode.FlowControl != FlowControl.Next)
						break;
					if (instr.IsStloc() && instr.GetLocal(locals) == emuLocal) {
						endIndex = i - 1;
						return true;
					}
				}

				endIndex = 0;
				return false;
			}

			Local CheckLocal(Instruction instr, bool isLdloc) {
				if (isLdloc && !instr.IsLdloc())
					return null;
				else if (!isLdloc && !instr.IsStloc())
					return null;

				return instr.GetLocal(locals);
			}

			public byte[] Decrypt(EmbeddedResource resource) {
				var encrypted = resource.CreateReader().ToArray();
				var decrypted = new byte[encrypted.Length];

				uint sum = 0;
				for (int i = 0; i < encrypted.Length; i += 4) {
					sum = CalculateMagic(sum + ReadUInt32(key, i % key.Length));
					WriteUInt32(decrypted, i, sum ^ ReadUInt32(encrypted, i));
				}

				return decrypted;
			}

			uint CalculateMagic(uint input) {
				instrEmulator.Initialize(method, method.Parameters, locals, method.Body.InitLocals, false);
				instrEmulator.SetLocal(emuLocal, new Int32Value((int)input));

				foreach (var instr in instructions)
					instrEmulator.Emulate(instr);

				var tos = instrEmulator.Pop() as Int32Value;
				if (tos == null || !tos.AllBitsValid())
					throw new ApplicationException("Couldn't calculate magic value");
				return (uint)tos.Value;
			}

			static uint ReadUInt32(byte[] ary, int index) {
				int sizeLeft = ary.Length - index;
				if (sizeLeft >= 4)
					return BitConverter.ToUInt32(ary, index);
				switch (sizeLeft) {
				case 1: return ary[index];
				case 2: return (uint)(ary[index] | (ary[index + 1] << 8));
				case 3: return (uint)(ary[index] | (ary[index + 1] << 8) | (ary[index + 2] << 16));
				default: throw new ApplicationException("Can't read data");
				}
			}

			static void WriteUInt32(byte[] ary, int index, uint value) {
				int sizeLeft = ary.Length - index;
				if (sizeLeft >= 1)
					ary[index] = (byte)value;
				if (sizeLeft >= 2)
					ary[index + 1] = (byte)(value >> 8);
				if (sizeLeft >= 3)
					ary[index + 2] = (byte)(value >> 16);
				if (sizeLeft >= 4)
					ary[index + 3] = (byte)(value >> 24);
			}

			public byte[] Encrypt(byte[] data) {
				//TODO: Support re-encryption
				Logger.e("Re-encryption is not supported. Assembly will probably crash at runtime.");
				return (byte[])data.Clone();
			}
		}

		public byte[] Decrypt() {
			if (encryptedDataResource == null || decrypter == null)
				throw new ApplicationException("Can't decrypt resource");
			return decrypter.Decrypt(encryptedDataResource);
		}

		public byte[] Encrypt(byte[] data) {
			if (decrypter == null)
				throw new ApplicationException("Can't encrypt resource");
			return decrypter.Encrypt(data);
		}
	}
}



================================================
File: de4dot.code/deobfuscators/dotNET_Reactor/v4/MetadataTokenObfuscator.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.dotNET_Reactor.v4 {
	// Find the class that returns a RuntimeTypeHandle/RuntimeFieldHandle. The value passed to
	// its methods is the original metadata token, which will be different when we save the file.
	class MetadataTokenObfuscator {
		ModuleDefMD module;
		TypeDef type;
		MethodDef typeMethod;
		MethodDef fieldMethod;

		public TypeDef Type => type;

		public MetadataTokenObfuscator(ModuleDefMD module) {
			this.module = module;
			Find();
		}

		void Find() {
			foreach (var type in module.Types) {
				var fields = type.Fields;
				if (fields.Count != 1)
					continue;
				if (fields[0].FieldType.FullName != "System.ModuleHandle")
					continue;
				if (type.HasProperties || type.HasEvents)
					continue;

				MethodDef fieldMethod = null, typeMethod = null;
				foreach (var method in type.Methods) {
					var sig = method.MethodSig;
					if (sig == null || sig.Params.Count != 1)
						continue;
					if (sig.Params[0].GetElementType() != ElementType.I4)
						continue;
					if (sig.RetType.GetFullName() == "System.RuntimeTypeHandle")
						typeMethod = method;
					else if (sig.RetType.GetFullName() == "System.RuntimeFieldHandle")
						fieldMethod = method;
				}

				if (typeMethod == null || fieldMethod == null)
					continue;

				this.type = type;
				this.typeMethod = typeMethod;
				this.fieldMethod = fieldMethod;
				return;
			}
		}

		public void Deobfuscate(Blocks blocks) {
			if (type == null)
				return;

			var gpContext = GenericParamContext.Create(blocks.Method);
			foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {
				var instrs = block.Instructions;
				for (int i = 0; i < instrs.Count - 1; i++) {
					var instr = instrs[i];
					if (instr.OpCode.Code != Code.Ldc_I4)
						continue;
					var call = instrs[i + 1];
					if (call.OpCode.Code != Code.Call)
						continue;
					var method = call.Operand as IMethod;
					if (method == null)
						continue;
					if (!new SigComparer().Equals(type, method.DeclaringType))
						continue;
					var methodDef = DotNetUtils.GetMethod(module, method);
					if (methodDef == null)
						continue;
					if (methodDef != typeMethod && methodDef != fieldMethod)
						continue;

					uint token = (uint)(int)instrs[i].Operand;
					instrs[i] = new Instr(OpCodes.Nop.ToInstruction());
					instrs[i + 1] = new Instr(new Instruction(OpCodes.Ldtoken, module.ResolveToken(token, gpContext) as ITokenOperand));
				}
			}
		}
	}
}



================================================
File: de4dot.code/deobfuscators/dotNET_Reactor/v4/MethodsDecrypter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.IO;
using dnlib.IO;
using dnlib.DotNet;
using dnlib.DotNet.MD;
using dnlib.DotNet.Emit;
using dnlib.DotNet.Writer;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.dotNET_Reactor.v4 {
	class MethodsDecrypter {
		ModuleDefMD module;
		EncryptedResource encryptedResource;
		Dictionary<uint, byte[]> tokenToNativeMethod = new Dictionary<uint, byte[]>();
		Dictionary<MethodDef, byte[]> methodToNativeMethod = new Dictionary<MethodDef, byte[]>();
		List<MethodDef> validNativeMethods;
		int totalEncryptedNativeMethods = 0;
		long xorKey;

		public bool Detected => encryptedResource.Method != null;
		public bool HasNativeMethods => methodToNativeMethod.Count > 0;
		public TypeDef DecrypterType => encryptedResource.Type;
		public MethodDef Method => encryptedResource.Method;
		public EmbeddedResource Resource => encryptedResource.Resource;
		public DnrDecrypterType DecrypterTypeVersion => encryptedResource.GuessDecrypterType();

		public MethodsDecrypter(ModuleDefMD module) {
			this.module = module;
			encryptedResource = new EncryptedResource(module);
		}

		public MethodsDecrypter(ModuleDefMD module, MethodsDecrypter oldOne) {
			this.module = module;
			encryptedResource = new EncryptedResource(module, oldOne.encryptedResource);
			tokenToNativeMethod = oldOne.tokenToNativeMethod;
			totalEncryptedNativeMethods = oldOne.totalEncryptedNativeMethods;
			xorKey = oldOne.xorKey;
		}

		public void Find() {
			var additionalTypes = new string[] {
				"System.IntPtr",
//				"System.Reflection.Assembly",		//TODO: Not in unknown DNR version with jitter support
			};
			var checkedMethods = new Dictionary<IMethod, bool>(MethodEqualityComparer.CompareDeclaringTypes);
			var callCounter = new CallCounter();
			int typesLeft = 30;
			foreach (var type in module.GetTypes()) {
				var cctor = type.FindStaticConstructor();
				if (cctor == null || cctor.Body == null)
					continue;
				if (typesLeft-- <= 0)
					break;

				foreach (var method in DotNetUtils.GetCalledMethods(module, cctor)) {
					if (!checkedMethods.ContainsKey(method)) {
						checkedMethods[method] = false;
						if (method.DeclaringType.BaseType == null || method.DeclaringType.BaseType.FullName != "System.Object")
							continue;
						if (!DotNetUtils.IsMethod(method, "System.Void", "()"))
							continue;
						if (!encryptedResource.CouldBeResourceDecrypter(method, additionalTypes))
							continue;
						checkedMethods[method] = true;
					}
					else if (!checkedMethods[method])
						continue;
					callCounter.Add(method);
				}
			}

			encryptedResource.Method = (MethodDef)callCounter.Most();
		}

		void XorEncrypt(byte[] data) {
			if (xorKey == 0)
				return;

			var stream = new MemoryStream(data);
			var reader = new BinaryReader(stream);
			var writer = new BinaryWriter(stream);
			int count = data.Length / 8;
			for (int i = 0; i < count; i++) {
				long val = reader.ReadInt64();
				val ^= xorKey;
				stream.Position -= 8;
				writer.Write(val);
			}
		}

		readonly static short[] nativeLdci4 = new short[] { 0x55, 0x8B, 0xEC, 0xB8, -1, -1, -1, -1, 0x5D, 0xC3 };
		readonly static short[] nativeLdci4_0 = new short[] { 0x55, 0x8B, 0xEC, 0x33, 0xC0, 0x5D, 0xC3 };
		public bool Decrypt(MyPEImage peImage, ISimpleDeobfuscator simpleDeobfuscator, ref DumpedMethods dumpedMethods, Dictionary<uint, byte[]> tokenToNativeCode, bool unpackedNativeFile) {
			if (encryptedResource.Method == null)
				return false;

			encryptedResource.Initialize(simpleDeobfuscator);
			if (!encryptedResource.FoundResource)
				return false;
			var methodsData = encryptedResource.Decrypt();

			bool hooksJitter = FindDnrCompileMethod(encryptedResource.Method.DeclaringType) != null;

			xorKey = GetXorKey();
			XorEncrypt(methodsData);

			var methodsDataReader = ByteArrayDataReaderFactory.CreateReader(methodsData);
			int patchCount = methodsDataReader.ReadInt32();
			int mode = methodsDataReader.ReadInt32();

			int tmp = methodsDataReader.ReadInt32();
			methodsDataReader.Position -= 4;
			if ((tmp & 0xFF000000) == 0x06000000) {
				// It's method token + rva. DNR 3.7.0.3 (and earlier?) - 3.9.0.1
				methodsDataReader.Position += 8 * (uint)patchCount;
				patchCount = methodsDataReader.ReadInt32();
				mode = methodsDataReader.ReadInt32();

				PatchDwords(peImage, ref methodsDataReader, patchCount);
				while (methodsDataReader.Position < methodsData.Length - 1) {
					/*uint token =*/ methodsDataReader.ReadUInt32();
					int numDwords = methodsDataReader.ReadInt32();
					PatchDwords(peImage, ref methodsDataReader, numDwords / 2);
				}
			}
			else if (!hooksJitter || mode == 1) {
				// DNR 3.9.8.0, 4.0+

				PatchDwords(peImage, ref methodsDataReader, patchCount);
				bool oldCode = !IsNewer45Decryption(encryptedResource.Method);
				while (methodsDataReader.Position < methodsData.Length - 1) {
					uint rva = methodsDataReader.ReadUInt32();
					int size;
					if (oldCode) {
						methodsDataReader.ReadUInt32();	// token, unknown, or index
						size = methodsDataReader.ReadInt32();
					}
					else
						size = methodsDataReader.ReadInt32() * 4;

					var newData = methodsDataReader.ReadBytes(size);
					if (unpackedNativeFile)
						peImage.DotNetSafeWriteOffset(rva, newData);
					else
						peImage.DotNetSafeWrite(rva, newData);
				}
			}
			else {
				// DNR 4.0+ (jitter is hooked)

				var methodDef = peImage.Metadata.TablesStream.MethodTable;
				var rvaToIndex = new Dictionary<uint, int>((int)methodDef.Rows);
				uint offset = (uint)methodDef.StartOffset;
				for (int i = 0; i < methodDef.Rows; i++) {
					uint rva = peImage.OffsetReadUInt32(offset);
					offset += methodDef.RowSize;
					if (rva == 0)
						continue;

					if ((peImage.ReadByte(rva) & 3) == 2)
						rva++;
					else
						rva += (uint)(4 * (peImage.ReadByte(rva + 1) >> 4));
					rvaToIndex[rva] = i;
				}

				PatchDwords(peImage, ref methodsDataReader, patchCount);
				/*int count =*/ methodsDataReader.ReadInt32();
				dumpedMethods = new DumpedMethods();
				while (methodsDataReader.Position < methodsData.Length - 1) {
					uint rva = methodsDataReader.ReadUInt32();
					uint index = methodsDataReader.ReadUInt32();
					bool isNativeCode = index >= 0x70000000;
					int size = methodsDataReader.ReadInt32();
					var methodData = methodsDataReader.ReadBytes(size);

					if (!rvaToIndex.TryGetValue(rva, out int methodIndex)) {
						Logger.w("Could not find method having code RVA {0:X8}", rva);
						continue;
					}

					uint methodToken = 0x06000001 + (uint)methodIndex;

					if (isNativeCode) {
						totalEncryptedNativeMethods++;
						if (tokenToNativeCode != null)
							tokenToNativeCode[methodToken] = methodData;

						// Convert return true / false methods. The others are converted to
						// throw 0xDEADCODE.
						if (DeobUtils.IsCode(nativeLdci4, methodData)) {
							uint val = BitConverter.ToUInt32(methodData, 4);
							// ldc.i4 XXXXXXXXh / ret
							methodData = new byte[] { 0x20, 0, 0, 0, 0, 0x2A };
							methodData[1] = (byte)val;
							methodData[2] = (byte)(val >> 8);
							methodData[3] = (byte)(val >> 16);
							methodData[4] = (byte)(val >> 24);
						}
						else if (DeobUtils.IsCode(nativeLdci4_0, methodData)) {
							// ldc.i4.0 / ret
							methodData = new byte[] { 0x16, 0x2A };
						}
						else {
							tokenToNativeMethod[methodToken] = methodData;

							// ldc.i4 0xDEADCODE / conv.u4 / throw
							methodData = new byte[] { 0x20, 0xDE, 0xC0, 0xAD, 0xDE, 0x6D, 0x7A };
						}
					}

					var dm = new DumpedMethod();
					peImage.ReadMethodTableRowTo(dm, MDToken.ToRID(methodToken));
					dm.code = methodData;

					var codeReader = peImage.Reader;
					codeReader.Position = peImage.RvaToOffset(dm.mdRVA);
					var mbHeader = MethodBodyParser.ParseMethodBody(ref codeReader, out var code, out dm.extraSections);
					peImage.UpdateMethodHeaderInfo(dm, mbHeader);

					dumpedMethods.Add(dm);
				}
			}

			return true;
		}

		public static bool IsNewer45Decryption(MethodDef method) {
			if (method == null || method.Body == null)
				return false;

			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 4; i++) {
				var ldci4 = instrs[i];
				if (!ldci4.IsLdcI4() || ldci4.GetLdcI4Value() != 4)
					continue;
				if (instrs[i + 1].OpCode.Code != Code.Mul)
					continue;
				ldci4 = instrs[i + 2];
				if (!ldci4.IsLdcI4() || ldci4.GetLdcI4Value() != 4)
					continue;
				if (instrs[i + 3].OpCode.Code != Code.Ldloca_S && instrs[i + 3].OpCode.Code != Code.Ldloca)
					continue;
				var call = instrs[i + 4];
				if (call.OpCode.Code != Code.Call)
					continue;
				if (!DotNetUtils.IsPinvokeMethod(call.Operand as MethodDef, "kernel32", "VirtualProtect"))
					continue;

				return true;
			}
			return false;
		}

		static void PatchDwords(MyPEImage peImage, ref DataReader reader, int count) {
			for (int i = 0; i < count; i++) {
				uint rva = reader.ReadUInt32();
				uint data = reader.ReadUInt32();
				peImage.DotNetSafeWrite(rva, BitConverter.GetBytes(data));
			}
		}

		long GetXorKey() {
			var instructions = encryptedResource.Method.Body.Instructions;
			for (int i = 0; i < instructions.Count - 1; i++) {
				if (instructions[i].OpCode.Code != Code.Ldind_I8)
					continue;
				var ldci4 = instructions[i + 1];
				if (ldci4.IsLdcI4())
					return ldci4.GetLdcI4Value();
				if (ldci4.OpCode.Code == Code.Ldc_I8)
					return (long)ldci4.Operand;
			}
			return 0;
		}

		public void Reloaded() {
			foreach (var pair in tokenToNativeMethod) {
				int token = (int)pair.Key;
				var method = module.ResolveToken(token) as MethodDef;
				if (method == null)
					throw new ApplicationException($"Could not find method {token:X8}");
				methodToNativeMethod[method] = pair.Value;
			}
			tokenToNativeMethod = null;
		}

		public void PrepareEncryptNativeMethods(ModuleWriterBase moduleWriter) {
			if (methodToNativeMethod.Count == 0)
				return;

			validNativeMethods = new List<MethodDef>(methodToNativeMethod.Count);
			int len = 12;
			foreach (var kv in methodToNativeMethod) {
				if (kv.Key.DeclaringType == null)
					continue;	// Method was removed
				if (kv.Key.DeclaringType.Module != module)
					continue;	// method.DeclaringType was removed
				validNativeMethods.Add(kv.Key);
				len += 3 * 4 + kv.Value.Length;
			}
			if (validNativeMethods.Count == 0)
				return;

			len = (len & ~15) + 16;
			encryptedResource.SetNewResource(new byte[len]);
		}

		public void EncryptNativeMethods(ModuleWriterBase moduleWriter) {
			if (validNativeMethods == null || validNativeMethods.Count == 0)
				return;

			Logger.v("Encrypting native methods");

			var stream = new MemoryStream();
			var writer = new BinaryWriter(stream);
			writer.Write((uint)0);	// patch count
			writer.Write((uint)0);	// mode
			writer.Write(validNativeMethods.Count);

			int index = 0;
			foreach (var method in validNativeMethods) {
				var code = methodToNativeMethod[method];

				var mb = moduleWriter.Metadata.GetMethodBody(method);
				if (mb == null) {
					Logger.e("Could not find method body for method {0} ({1:X8})", method, method.MDToken.Raw);
					continue;
				}

				uint codeRva = (uint)mb.RVA;
				if (mb.IsTiny)
					codeRva++;
				else
					codeRva += (uint)(4 * (mb.Code[1] >> 4));

				Logger.v("Native method {0:X8}, code RVA {1:X8}", new MDToken(Table.Method, moduleWriter.Metadata.GetRid(method)).Raw, codeRva);

				writer.Write(codeRva);
				writer.Write(0x70000000 + index++);
				writer.Write(code.Length);
				writer.Write(code);
			}

			if (index != 0)
				Logger.n("Re-encrypted {0}/{1} native methods", index, totalEncryptedNativeMethods);

			var resourceChunk = moduleWriter.Metadata.GetChunk(encryptedResource.Resource);
			var resourceData = resourceChunk.CreateReader();

			var encrypted = stream.ToArray();
			XorEncrypt(encrypted);

			encrypted = encryptedResource.Encrypt(encrypted);
			if (encrypted.Length != resourceData.Length)
				Logger.e("Encrypted native methods array is not same size as original array");
			resourceChunk.SetData(ByteArrayDataReaderFactory.CreateReader(encrypted));
		}

		enum CompileMethodType {
			Unknown,
			V1,	// <= DNR 4.5.0.0 (2012-11-06 <= endDate < 2013-01-31)
			V2,	// >= DNR 4.5.0.0 (2012-11-06 < startDate <= 2013-01-31)
		}

		public static MethodDef FindDnrCompileMethod(TypeDef type) {
			foreach (var method in type.Methods) {
				if (!method.IsStatic || method.Body == null)
					continue;
				var sig = method.MethodSig;
				if (sig == null || sig.Params.Count != 6)
					continue;
				if (GetCompileMethodType(method) == CompileMethodType.Unknown)
					continue;
				return method;
			}
			return null;
		}

		static CompileMethodType GetCompileMethodType(MethodDef method) {
			if (DotNetUtils.IsMethod(method, "System.UInt32", "(System.UInt64&,System.IntPtr,System.IntPtr,System.UInt32,System.IntPtr&,System.UInt32&)"))
				return CompileMethodType.V1;
			if (DotNetUtils.IsMethod(method, "System.UInt32", "(System.IntPtr,System.IntPtr,System.IntPtr,System.UInt32,System.IntPtr,System.UInt32&)"))
				return CompileMethodType.V2;
			return CompileMethodType.Unknown;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/dotNET_Reactor/v4/NativeFileDecrypter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;

namespace de4dot.code.deobfuscators.dotNET_Reactor.v4 {
	class NativeFileDecrypter {
		byte[] key;
		byte kb = 0;
		byte[,] transform = new byte[256, 256];

		public NativeFileDecrypter(byte[] keyData) {
			var keyInit = new byte[] {
				0x78, 0x61, 0x32, keyData[0], keyData[2],
				0x62, keyData[3], keyData[0], keyData[1], keyData[1],
				0x66, keyData[1], keyData[5], 0x33, keyData[2],
				keyData[4], 0x74, 0x32, keyData[3], keyData[2],
			};
			key = new byte[32];
			for (int i = 0; i < 32; i++) {
				key[i] = (byte)(i + keyInit[i % keyInit.Length] * keyInit[((i + 0x0B) | 0x1F) % keyInit.Length]);
				kb += key[i];
			}

			var transformTemp = new ushort[256, 256];
			for (int i = 0; i < 256; i++)
				for (int j = 0; j < 256; j++)
					transformTemp[i, j] = 0x400;
			int counter = 0x0B;
			byte newByte = 0;
			int ki = 0;
			for (int i = 0; i < 256; i++) {
				while (true) {
					for (int j = key.Length - 1; j >= ki; j--)
						newByte += (byte)(key[j] + counter);
					bool done = true;
					ki = (ki + 1) % key.Length;
					for (int k = 0; k <= i; k++) {
						if (newByte == transformTemp[k, 0]) {
							done = false;
							break;
						}
					}
					if (done)
						break;
					counter++;
				}
				transformTemp[i, 0] = newByte;
			}

			counter = ki = 0;
			for (int i = 1; i < 256; i++) {
				ki++;
				int i1;
				do {
					counter++;
					i1 = 1 + (key[(i + 37 + counter) % key.Length] + counter + kb) % 255;
				} while (transformTemp[0, i1] != 0x400);
				for (int i0 = 0; i0 < 256; i0++)
					transformTemp[i0, i1] = transformTemp[(i0 + ki) % 256, 0];
			}

			for (int i = 0; i < 256; i++) {
				for (int j = 0; j < 256; j++)
					transform[(byte)transformTemp[i, j], j] = (byte)i;
			}
		}

		public void Decrypt(byte[] data, int offset, int count) {
			for (int i = 0; i < count; i += 1024, offset += 1024) {
				int blockLen = Math.Min(1024, count - i);

				if (blockLen == 1) {
					data[offset] = transform[data[offset], kb];
					continue;
				}

				for (int j = 0; j < blockLen - 1; j++)
					data[offset + j] = transform[data[offset + j], data[offset + j + 1]];
				data[offset + blockLen - 1] = transform[data[offset + blockLen - 1], kb ^ 0x55];

				for (int j = blockLen - 1; j > 0; j--)
					data[offset + j] = transform[data[offset + j], data[offset + j - 1]];
				data[offset] = transform[data[offset], kb];
			}
		}
	}
}



================================================
File: de4dot.code/deobfuscators/dotNET_Reactor/v4/NativeImageUnpacker.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using ICSharpCode.SharpZipLib.Zip.Compression;
using dnlib.PE;
using dnlib.DotNet;

namespace de4dot.code.deobfuscators.dotNET_Reactor.v4 {
	class NativeImageUnpacker {
		MyPEImage peImage;
		bool isNet1x;
		const int loaderHeaderSizeV45 = 14;

		public NativeImageUnpacker(IPEImage peImage) => this.peImage = new MyPEImage(peImage);

		public byte[] Unpack() {
			if (peImage.PEImage.Win32Resources == null)
				return null;
			var dataEntry = peImage.PEImage.Win32Resources.Find(10, "__", 0);
			if (dataEntry == null)
				return null;

			var encryptedData = dataEntry.CreateReader().ToArray();

			var keyData = GetKeyData();
			if (keyData == null)
				return null;
			var decrypter = new NativeFileDecrypter(keyData);
			decrypter.Decrypt(encryptedData, 0, encryptedData.Length);

			byte[] inflatedData;
			if (isNet1x)
				inflatedData = DeobUtils.Inflate(encryptedData, false);
			else {
				int inflatedSize = BitConverter.ToInt32(encryptedData, 0);
				inflatedData = new byte[inflatedSize];
				var inflater = new Inflater(false);
				inflater.SetInput(encryptedData, 4, encryptedData.Length - 4);
				int count = inflater.Inflate(inflatedData);
				if (count != inflatedSize)
					return null;
			}

			// CLR 1.x or DNR v4.0 - v4.4
			if (BitConverter.ToInt16(inflatedData, 0) == 0x5A4D)
				return inflatedData;

			// DNR v4.5
			if (BitConverter.ToInt16(inflatedData, loaderHeaderSizeV45) == 0x5A4D)
				return UnpackLoader(inflatedData);

			return null;
		}

		static byte[] UnpackLoader(byte[] loaderData) {
			var loaderBytes = new byte[loaderData.Length - loaderHeaderSizeV45];
			Array.Copy(loaderData, loaderHeaderSizeV45, loaderBytes, 0, loaderBytes.Length);

			try {
				using (var asmLoader = ModuleDefMD.Load(loaderBytes)) {
					if (asmLoader.Resources.Count == 0)
						return null;
					var resource = asmLoader.Resources[0] as EmbeddedResource;
					if (resource == null)
						return null;

					return resource.CreateReader().ToArray();
				}
			}
			catch {
				return null;
			}
		}

		static readonly uint[] baseOffsets = new uint[] {
			0x1C00,	// DNR 4.0 & 4.1
			0x1900,	// DNR 4.2.7.5
			0x1B60,	// DNR 4.2.8.4, 4.3, 4.4, 4.5
			0x700,	// DNR 4.5.0.0
		};
		static readonly short[] decryptMethodPattern = new short[] {
			/* 00 */	0x83, 0xEC, 0x38,		// sub     esp, 38h
			/* 03 */	0x53,					// push    ebx
			/* 04 */	0xB0, -1,				// mov     al, ??h
			/* 06 */	0x88, 0x44, 0x24, 0x2B,	// mov     [esp+2Bh], al
			/* 0A */	0x88, 0x44, 0x24, 0x2F,	// mov     [esp+2Fh], al
			/* 0E */	0xB0, -1,				// mov     al, ??h
			/* 10 */	0x88, 0x44, 0x24, 0x30,	// mov     [esp+30h], al
			/* 14 */	0x88, 0x44, 0x24, 0x31,	// mov     [esp+31h], al
			/* 18 */	0x88, 0x44, 0x24, 0x33,	// mov     [esp+33h], al
			/* 1C */	0x55,					// push    ebp
			/* 1D */	0x56,					// push    esi
		};
		static readonly short[] startMethodNet1xPattern = new short[] {
			/* 00 */ 0x55,						// push    ebp
			/* 01 */ 0x8B, 0xEC,				// mov     ebp, esp
			/* 03 */ 0xB9, 0x14, 0x00, 0x00, 0x00, // mov  ecx, 14h
			/* 08 */ 0x6A, 0x00,				// push    0
			/* 0A */ 0x6A, 0x00,				// push    0
			/* 0C */ 0x49,						// dec     ecx
			/* 0D */ 0x75, 0xF9,				// jnz     short $-5
			/* 0F */ 0x53,						// push    ebx
			/* 10 */ 0x56,						// push    esi
			/* 11 */ 0x57,						// push    edi
			/* 12 */ 0xB8, -1, -1, -1, -1,		// mov     eax, offset XXXXXXXX
			/* 17 */ 0xE8, -1, -1, -1, -1,		// call    YYYYYYYY
		};
		byte[] GetKeyData() {
			isNet1x = false;
			for (int i = 0; i < baseOffsets.Length; i++) {
				var code = peImage.OffsetReadBytes(baseOffsets[i], decryptMethodPattern.Length);
				if (DeobUtils.IsCode(decryptMethodPattern, code))
					return GetKeyData(baseOffsets[i]);
			}

			var net1xCode = peImage.OffsetReadBytes(0x207E0, startMethodNet1xPattern.Length);
			if (DeobUtils.IsCode(startMethodNet1xPattern, net1xCode)) {
				isNet1x = true;
				return new byte[6] { 0x34, 0x38, 0x63, 0x65, 0x7A, 0x35 };
			}

			return null;
		}

		byte[] GetKeyData(uint baseOffset) =>
			new byte[6] {
				peImage.OffsetReadByte(baseOffset + 5),
				peImage.OffsetReadByte(baseOffset + 0xF),
				peImage.OffsetReadByte(baseOffset + 0x58),
				peImage.OffsetReadByte(baseOffset + 0x6D),
				peImage.OffsetReadByte(baseOffset + 0x98),
				peImage.OffsetReadByte(baseOffset + 0xA6),
			};
	}
}



================================================
File: de4dot.code/deobfuscators/dotNET_Reactor/v4/ProxyCallFixer.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.dotNET_Reactor.v4 {
	class ProxyCallFixer : ProxyCallFixer3 {
		ISimpleDeobfuscator simpleDeobfuscator;

		public ProxyCallFixer(ModuleDefMD module, ISimpleDeobfuscator simpleDeobfuscator)
			: base(module) => this.simpleDeobfuscator = simpleDeobfuscator;

		public void FindDelegateCreator() {
			foreach (var type in module.Types) {
				var creatorMethod = CheckType(type);
				if (creatorMethod == null)
					continue;

				SetDelegateCreatorMethod(creatorMethod);
				return;
			}
		}

		static readonly string[] requiredFields = new string[] {
			"System.Reflection.Module",
		};
		static MethodDef CheckType(TypeDef type) {
			if (!new FieldTypes(type).Exactly(requiredFields))
				return null;
			if (type.FindStaticConstructor() == null)
				return null;

			return CheckMethods(type);
		}

		static MethodDef CheckMethods(TypeDef type) {
			MethodDef creatorMethod = null;
			foreach (var method in type.Methods) {
				if (method.Body == null)
					return null;
				if (method.Name == ".cctor" || method.Name == ".ctor")
					continue;
				if (!DotNetUtils.IsMethod(method, "System.Void", "(System.Int32)"))
					return null;
				if (!DeobUtils.HasInteger(method, 0x02000000))
					return null;
				if (!DeobUtils.HasInteger(method, 0x06000000))
					return null;
				creatorMethod = method;
			}
			return creatorMethod;
		}

		protected override object CheckCctor(ref TypeDef type, MethodDef cctor) {
			simpleDeobfuscator.Deobfuscate(cctor);
			var realType = GetDelegateType(cctor);
			if (realType == null)
				return null;
			type = realType;

			return this;
		}

		TypeDef GetDelegateType(MethodDef method) {
			var instrs = method.Body.Instructions;
			for (int i = 0; i < instrs.Count - 1; i++) {
				var ldci4 = instrs[i];
				if (!ldci4.IsLdcI4())
					continue;

				var call = instrs[i + 1];
				if (call.OpCode.Code != Code.Call)
					continue;
				var calledMethod = call.Operand as MethodDef;
				if (calledMethod == null || !IsDelegateCreatorMethod(calledMethod))
					continue;

				return module.ResolveToken(0x02000000 + ldci4.GetLdcI4Value()) as TypeDef;
			}
			return null;
		}

		protected override void GetCallInfo(object context, FieldDef field, out IMethod calledMethod, out OpCode callOpcode) {
			calledMethod = module.ResolveToken(0x06000000 + field.MDToken.ToInt32()) as IMethod;
			callOpcode = OpCodes.Call;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/dotNET_Reactor/v4/ResourceResolver.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.dotNET_Reactor.v4 {
	class ResourceResolver {
		ModuleDefMD module;
		EncryptedResource encryptedResource;
		MethodDef initMethod;

		public bool Detected => encryptedResource.Method != null;
		public TypeDef Type => encryptedResource.Type;
		public MethodDef InitMethod => initMethod;
		public bool FoundResource => encryptedResource.FoundResource;

		public ResourceResolver(ModuleDefMD module) {
			this.module = module;
			encryptedResource = new EncryptedResource(module);
		}

		public ResourceResolver(ModuleDefMD module, ResourceResolver oldOne) {
			this.module = module;
			encryptedResource = new EncryptedResource(module, oldOne.encryptedResource);
		}

		public void Find(ISimpleDeobfuscator simpleDeobfuscator) {
			var additionalTypes = new string[] {
				"System.String",
			};
			foreach (var type in module.Types) {
				if (type.BaseType == null || type.BaseType.FullName != "System.Object")
					continue;
				if (!CheckFields(type.Fields))
					continue;
				foreach (var method in type.Methods) {
					if (!method.IsStatic || !method.HasBody)
						continue;
					if (!DotNetUtils.IsMethod(method, "System.Reflection.Assembly", "(System.Object,System.ResolveEventArgs)") &&
						!DotNetUtils.IsMethod(method, "System.Reflection.Assembly", "(System.Object,System.Object)"))
						continue;
					var initMethod = GetResourceDecrypterInitMethod(method, additionalTypes, false);
					if (initMethod == null)
						continue;

					encryptedResource.Method = initMethod;
					return;
				}
			}
		}

		MethodDef GetResourceDecrypterInitMethod(MethodDef method, string[] additionalTypes, bool checkResource) {
			if (encryptedResource.CouldBeResourceDecrypter(method, additionalTypes, checkResource))
				return method;

			foreach (var calledMethod in DotNetUtils.GetCalledMethods(module, method)) {
				if (!DotNetUtils.IsMethod(calledMethod, "System.Void", "()"))
					continue;
				if (encryptedResource.CouldBeResourceDecrypter(calledMethod, additionalTypes, checkResource))
					return calledMethod;
			}

			return null;
		}

		bool CheckFields(IList<FieldDef> fields) {
			if (fields.Count != 3 && fields.Count != 4)
				return false;

			int numBools = fields.Count == 3 ? 1 : 2;
			var fieldTypes = new FieldTypes(fields);
			if (fieldTypes.Count("System.Boolean") != numBools)
				return false;
			if (fieldTypes.Count("System.Object") == 2)
				return true;
			if (fieldTypes.Count("System.String[]") != 1)
				return false;
			return fieldTypes.Count("System.Reflection.Assembly") == 1 || fieldTypes.Count("System.Object") == 1;
		}

		public void Initialize(ISimpleDeobfuscator simpleDeobfuscator, IDeobfuscator deob) {
			if (encryptedResource.Method == null)
				return;

			initMethod = FindInitMethod(simpleDeobfuscator);
			if (initMethod == null)
				throw new ApplicationException("Could not find resource resolver init method");

			simpleDeobfuscator.Deobfuscate(encryptedResource.Method);
			simpleDeobfuscator.DecryptStrings(encryptedResource.Method, deob);
			encryptedResource.Initialize(simpleDeobfuscator);
		}

		MethodDef FindInitMethod(ISimpleDeobfuscator simpleDeobfuscator) {
			var ctor = Type.FindMethod(".ctor");
			foreach (var method in Type.Methods) {
				if (!method.IsStatic || method.Body == null)
					continue;
				if (!DotNetUtils.IsMethod(method, "System.Void", "()"))
					continue;
				if (method.Body.Variables.Count > 1)
					continue;

				simpleDeobfuscator.Deobfuscate(method);
				bool stsfldUsed = false, newobjUsed = false;
				foreach (var instr in method.Body.Instructions) {
					if (instr.OpCode.Code == Code.Stsfld) {
						var field = instr.Operand as IField;
						if (field == null || field.FieldSig.GetFieldType().GetElementType() != ElementType.Boolean)
							continue;
						if (!new SigComparer().Equals(Type, field.DeclaringType))
							continue;
						stsfldUsed = true;
					}
					else if (instr.OpCode.Code == Code.Newobj) {
						var calledCtor = instr.Operand as IMethod;
						if (calledCtor == null)
							continue;
						if (!MethodEqualityComparer.CompareDeclaringTypes.Equals(calledCtor, ctor))
							continue;
						newobjUsed = true;
					}
				}
				if (!stsfldUsed || !newobjUsed)
					continue;

				return method;
			}
			return null;
		}

		public EmbeddedResource MergeResources() {
			if (encryptedResource.Resource == null)
				return null;
			DeobUtils.DecryptAndAddResources(module, encryptedResource.Resource.Name.String, () => {
				return QuickLZ.Decompress(encryptedResource.Decrypt());
			});
			return encryptedResource.Resource;
		}
	}
}



================================================
File: de4dot.code/deobfuscators/dotNET_Reactor/v4/StringDecrypter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Text;
using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.dotNET_Reactor.v4 {
	class StringDecrypter {
		ModuleDefMD module;
		EncryptedResource encryptedResource;
		List<DecrypterInfo> decrypterInfos = new List<DecrypterInfo>();
		MethodDef otherStringDecrypter;
		byte[] decryptedData;
		MyPEImage peImage;
		byte[] fileData;
		StringDecrypterVersion stringDecrypterVersion;

		enum StringDecrypterVersion {
			UNKNOWN = 0,
			VER_37,		// 3.7-
			VER_38,		// 3.8+
		}

		public class DecrypterInfo {
			public MethodDef method;
			public byte[] key;
			public byte[] iv;

			public DecrypterInfo(MethodDef method, byte[] key, byte[] iv) {
				this.method = method;
				this.key = key;
				this.iv = iv;
			}
		}

		public bool Detected => encryptedResource.Method != null;
		public TypeDef DecrypterType => encryptedResource.Type;
		public EmbeddedResource Resource => encryptedResource.Resource;
		public IEnumerable<DecrypterInfo> DecrypterInfos => decrypterInfos;
		public MethodDef OtherStringDecrypter => otherStringDecrypter;

		public StringDecrypter(ModuleDefMD module) {
			this.module = module;
			encryptedResource = new EncryptedResource(module);
		}

		public StringDecrypter(ModuleDefMD module, StringDecrypter oldOne) {
			this.module = module;
			stringDecrypterVersion = oldOne.stringDecrypterVersion;
			encryptedResource = new EncryptedResource(module, oldOne.encryptedResource);
			foreach (var oldInfo in oldOne.decrypterInfos) {
				var method = Lookup(oldInfo.method, "Could not find string decrypter method");
				decrypterInfos.Add(new DecrypterInfo(method, oldInfo.key, oldInfo.iv));
			}
			otherStringDecrypter = Lookup(oldOne.otherStringDecrypter, "Could not find string decrypter method");
		}

		T Lookup<T>(T def, string errorMessage) where T : class, ICodedToken =>
			DeobUtils.Lookup(module, def, errorMessage);

		public void Find(ISimpleDeobfuscator simpleDeobfuscator) {
			var additionalTypes = new string[] {
				"System.String",
			};
			EmbeddedResource stringsResource = null;
			foreach (var type in module.Types) {
				if (decrypterInfos.Count > 0)
					break;
				if (type.BaseType == null || type.BaseType.FullName != "System.Object")
					continue;
				foreach (var method in type.Methods) {
					if (!method.IsStatic || !method.HasBody)
						continue;
					if (!DotNetUtils.IsMethod(method, "System.String", "(System.Int32)"))
						continue;
					if (!encryptedResource.CouldBeResourceDecrypter(method, additionalTypes))
						continue;

					var resource = DotNetUtils.GetResource(module, DotNetUtils.GetCodeStrings(method)) as EmbeddedResource;
					if (resource == null)
						throw new ApplicationException("Could not find strings resource");
					if (stringsResource != null && stringsResource != resource)
						throw new ApplicationException("Two different string resources found");

					stringsResource = resource;
					encryptedResource.Method = method;

					var info = new DecrypterInfo(method, null, null);
					simpleDeobfuscator.Deobfuscate(info.method);
					FindKeyIv(info.method, out info.key, out info.iv);

					decrypterInfos.Add(info);
				}
			}

			if (decrypterInfos.Count > 0)
				FindOtherStringDecrypter(decrypterInfos[0].method.DeclaringType);
		}

		void FindOtherStringDecrypter(TypeDef type) {
			foreach (var method in type.Methods) {
				if (!method.IsStatic || !method.HasBody)
					continue;
				var sig = method.MethodSig;
				if (sig == null)
					continue;
				if (sig.RetType.GetElementType() != ElementType.String)
					continue;
				if (sig.Params.Count != 1)
					continue;
				if (sig.Params[0].GetElementType() != ElementType.Object &&
					sig.Params[0].GetElementType() != ElementType.String)
					continue;

				otherStringDecrypter = method;
				return;
			}
		}

		public void Initialize(MyPEImage peImage, byte[] fileData, ISimpleDeobfuscator simpleDeobfuscator) {
			if (encryptedResource.Method == null)
				return;
			this.peImage = peImage;
			this.fileData = fileData;

			encryptedResource.Initialize(simpleDeobfuscator);
			if (!encryptedResource.FoundResource)
				return;
			Logger.v("Adding string decrypter. Resource: {0}", Utils.ToCsharpString(encryptedResource.Resource.Name));
			decryptedData = encryptedResource.Decrypt();
		}

		void FindKeyIv(MethodDef method, out byte[] key, out byte[] iv) {
			key = null;
			iv = null;

			var requiredTypes = new string[] {
				"System.Byte[]",
				"System.IO.MemoryStream",
				"System.Security.Cryptography.CryptoStream",
				"System.Security.Cryptography.Rijndael",
			};
			foreach (var calledMethod in DotNetUtils.GetCalledMethods(module, method)) {
				if (calledMethod.DeclaringType != method.DeclaringType)
					continue;
				if (calledMethod.MethodSig.GetRetType().GetFullName() != "System.Byte[]")
					continue;
				var localTypes = new LocalTypes(calledMethod);
				if (!localTypes.All(requiredTypes))
					continue;

				var instructions = calledMethod.Body.Instructions;
				byte[] newKey = null, newIv = null;
				for (int i = 0; i < instructions.Count && (newKey == null || newIv == null); i++) {
					var instr = instructions[i];
					if (instr.OpCode.Code != Code.Ldtoken)
						continue;
					var field = instr.Operand as FieldDef;
					if (field == null)
						continue;
					if (field.InitialValue == null)
						continue;
					if (field.InitialValue.Length == 32)
						newKey = field.InitialValue;
					else if (field.InitialValue.Length == 16)
						newIv = field.InitialValue;
				}
				if (newKey == null || newIv == null)
					continue;

				InitializeStringDecrypterVersion(method);
				key = newKey;
				iv = newIv;
				return;
			}
		}

		void InitializeStringDecrypterVersion(MethodDef method) {
			var localTypes = new LocalTypes(method);
			if (localTypes.Exists("System.IntPtr"))
				stringDecrypterVersion = StringDecrypterVersion.VER_38;
			else
				stringDecrypterVersion = StringDecrypterVersion.VER_37;
		}

		DecrypterInfo GetDecrypterInfo(MethodDef method) {
			foreach (var info in decrypterInfos) {
				if (info.method == method)
					return info;
			}
			throw new ApplicationException("Invalid string decrypter method");
		}

		public string Decrypt(MethodDef method, int offset) {
			var info = GetDecrypterInfo(method);

			if (info.key == null) {
				int length = BitConverter.ToInt32(decryptedData, offset);
				return Encoding.Unicode.GetString(decryptedData, offset + 4, length);
			}
			else {
				byte[] encryptedStringData;
				if (stringDecrypterVersion == StringDecrypterVersion.VER_37) {
					int fileOffset = BitConverter.ToInt32(decryptedData, offset);
					int length = BitConverter.ToInt32(fileData, fileOffset);
					encryptedStringData = new byte[length];
					Array.Copy(fileData, fileOffset + 4, encryptedStringData, 0, length);
				}
				else if (stringDecrypterVersion == StringDecrypterVersion.VER_38) {
					uint rva = BitConverter.ToUInt32(decryptedData, offset);
					int length = peImage.ReadInt32(rva);
					encryptedStringData = peImage.ReadBytes(rva + 4, length);
				}
				else
					throw new ApplicationException("Unknown string decrypter version");

				return Encoding.Unicode.GetString(DeobUtils.AesDecrypt(encryptedStringData, info.key, info.iv));
			}
		}

		public string Decrypt(string s) => Encoding.Unicode.GetString(Convert.FromBase64String(s));
	}
}



================================================
File: de4dot.code/renamer/DerivedFrom.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using de4dot.code.renamer.asmmodules;

namespace de4dot.code.renamer {
	public class DerivedFrom {
		Dictionary<string, bool> classNames = new Dictionary<string, bool>(StringComparer.Ordinal);
		Dictionary<MTypeDef, bool> results = new Dictionary<MTypeDef, bool>();

		public DerivedFrom(string className) => AddName(className);

		public DerivedFrom(string[] classNames) {
			foreach (var className in classNames)
				AddName(className);
		}

		void AddName(string className) => classNames[className] = true;
		public bool Check(MTypeDef type) => Check(type, 0);

		public bool Check(MTypeDef type, int recurseCount) {
			if (recurseCount >= 100)
				return false;
			if (results.ContainsKey(type))
				return results[type];

			bool val;
			if (classNames.ContainsKey(type.TypeDef.FullName))
				val = true;
			else if (type.baseType == null) {
				if (type.TypeDef.BaseType != null)
					val = classNames.ContainsKey(type.TypeDef.BaseType.FullName);
				else
					val = false;
			}
			else
				val = Check(type.baseType.typeDef, recurseCount + 1);

			results[type] = val;
			return val;
		}
	}
}



================================================
File: de4dot.code/renamer/ExistingNames.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet;

namespace de4dot.code.renamer {
	public class ExistingNames {
		Dictionary<string, bool> allNames = new Dictionary<string, bool>(StringComparer.Ordinal);

		public void Add(string name) => allNames[name] = true;
		public bool Exists(string name) => allNames.ContainsKey(name);
		public string GetName(UTF8String oldName, INameCreator nameCreator) => GetName(UTF8String.ToSystemStringOrEmpty(oldName), nameCreator);
		public string GetName(string oldName, INameCreator nameCreator) => GetName(oldName, () => nameCreator.Create());
		public string GetName(UTF8String oldName, Func<string> createNewName) => GetName(UTF8String.ToSystemStringOrEmpty(oldName), createNewName);

		public string GetName(string oldName, Func<string> createNewName) {
			string prevName = null;
			while (true) {
				var name = createNewName();
				if (name == prevName)
					throw new ApplicationException($"Could not rename symbol to {Utils.ToCsharpString(name)}");

				if (!Exists(name) || name == oldName) {
					allNames[name] = true;
					return name;
				}

				prevName = name;
			}
		}

		public void Merge(ExistingNames other) {
			if (this == other)
				return;
			foreach (var key in other.allNames.Keys)
				allNames[key] = true;
		}
	}
}



================================================
File: de4dot.code/renamer/INameChecker.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

namespace de4dot.code.renamer {
	public interface INameChecker {
		bool IsValidNamespaceName(string ns);
		bool IsValidTypeName(string name);
		bool IsValidMethodName(string name);
		bool IsValidPropertyName(string name);
		bool IsValidEventName(string name);
		bool IsValidFieldName(string name);
		bool IsValidGenericParamName(string name);
		bool IsValidMethodArgName(string name);
		bool IsValidMethodReturnArgName(string name);
		bool IsValidResourceKeyName(string name);
	}
}



================================================
File: de4dot.code/renamer/MemberInfos.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using de4dot.code.renamer.asmmodules;

namespace de4dot.code.renamer {
	public class MemberInfo {
		protected Ref memberRef;
		public string oldFullName;
		public string oldName;
		public string newName;
		public bool renamed;
		public string suggestedName;

		public MemberInfo(Ref memberRef) {
			this.memberRef = memberRef;
			oldFullName = memberRef.memberRef.FullName;
			oldName = memberRef.memberRef.Name.String;
			newName = memberRef.memberRef.Name.String;
		}

		public void Rename(string newTypeName) {
			renamed = true;
			newName = newTypeName;
		}

		public bool GotNewName() => oldName != newName;
		public override string ToString() => $"O:{oldFullName} -- N:{newName}";
	}

	public class GenericParamInfo : MemberInfo {
		public GenericParamInfo(MGenericParamDef genericParamDef) : base(genericParamDef) { }
	}

	public class PropertyInfo : MemberInfo {
		public PropertyInfo(MPropertyDef propertyDef) : base(propertyDef) { }
	}

	public class EventInfo : MemberInfo {
		public EventInfo(MEventDef eventDef) : base(eventDef) { }
	}

	public class FieldInfo : MemberInfo {
		public FieldInfo(MFieldDef fieldDef) : base(fieldDef) { }
	}

	public class MethodInfo : MemberInfo {
		public MMethodDef MethodDef => (MMethodDef)memberRef;
		public MethodInfo(MMethodDef methodDef) : base(methodDef) { }
	}

	public class ParamInfo {
		public string oldName;
		public string newName;

		public ParamInfo(MParamDef paramDef) {
			oldName = paramDef.ParameterDef.Name;
			newName = paramDef.ParameterDef.Name;
		}

		public bool GotNewName() => oldName != newName;
	}

	public class MemberInfos {
		Dictionary<MTypeDef, TypeInfo> allTypeInfos = new Dictionary<MTypeDef, TypeInfo>();
		Dictionary<MPropertyDef, PropertyInfo> allPropertyInfos = new Dictionary<MPropertyDef, PropertyInfo>();
		Dictionary<MEventDef, EventInfo> allEventInfos = new Dictionary<MEventDef, EventInfo>();
		Dictionary<MFieldDef, FieldInfo> allFieldInfos = new Dictionary<MFieldDef, FieldInfo>();
		Dictionary<MMethodDef, MethodInfo> allMethodInfos = new Dictionary<MMethodDef, MethodInfo>();
		Dictionary<MGenericParamDef, GenericParamInfo> allGenericParamInfos = new Dictionary<MGenericParamDef, GenericParamInfo>();
		Dictionary<MParamDef, ParamInfo> allParamInfos = new Dictionary<MParamDef, ParamInfo>();
		DerivedFrom checkWinFormsClass;

		static string[] WINFORMS_CLASSES = new string[] {
#region Win Forms class names
			"System.Windows.Forms.Control",
			"System.Windows.Forms.AxHost",
			"System.Windows.Forms.ButtonBase",
			"System.Windows.Forms.Button",
			"System.Windows.Forms.CheckBox",
			"System.Windows.Forms.RadioButton",
			"System.Windows.Forms.DataGrid",
			"System.Windows.Forms.DataGridView",
			"System.Windows.Forms.DataVisualization.Charting.Chart",
			"System.Windows.Forms.DateTimePicker",
			"System.Windows.Forms.GroupBox",
			"System.Windows.Forms.Integration.ElementHost",
			"System.Windows.Forms.Label",
			"System.Windows.Forms.LinkLabel",
			"System.Windows.Forms.ListControl",
			"System.Windows.Forms.ComboBox",
			"Microsoft.VisualBasic.Compatibility.VB6.DriveListBox",
			"System.Windows.Forms.DataGridViewComboBoxEditingControl",
			"System.Windows.Forms.ListBox",
			"Microsoft.VisualBasic.Compatibility.VB6.DirListBox",
			"Microsoft.VisualBasic.Compatibility.VB6.FileListBox",
			"System.Windows.Forms.CheckedListBox",
			"System.Windows.Forms.ListView",
			"System.Windows.Forms.MdiClient",
			"System.Windows.Forms.MonthCalendar",
			"System.Windows.Forms.PictureBox",
			"System.Windows.Forms.PrintPreviewControl",
			"System.Windows.Forms.ProgressBar",
			"System.Windows.Forms.ScrollableControl",
			"System.Windows.Forms.ContainerControl",
			"System.Windows.Forms.Form",
			"System.ComponentModel.Design.CollectionEditor.CollectionForm",
			"System.Messaging.Design.QueuePathDialog",
			"System.ServiceProcess.Design.ServiceInstallerDialog",
			"System.Web.UI.Design.WebControls.CalendarAutoFormatDialog",
			"System.Web.UI.Design.WebControls.RegexEditorDialog",
			"System.Windows.Forms.Design.ComponentEditorForm",
			"System.Windows.Forms.PrintPreviewDialog",
			"System.Windows.Forms.ThreadExceptionDialog",
			"System.Workflow.Activities.Rules.Design.RuleConditionDialog",
			"System.Workflow.Activities.Rules.Design.RuleSetDialog",
			"System.Workflow.ComponentModel.Design.ThemeConfigurationDialog",
			"System.Workflow.ComponentModel.Design.TypeBrowserDialog",
			"System.Workflow.ComponentModel.Design.WorkflowPageSetupDialog",
			"System.Windows.Forms.PropertyGrid",
			"System.Windows.Forms.SplitContainer",
			"System.Windows.Forms.ToolStripContainer",
			"System.Windows.Forms.ToolStripPanel",
			"System.Windows.Forms.UpDownBase",
			"System.Windows.Forms.DomainUpDown",
			"System.Windows.Forms.NumericUpDown",
			"System.Windows.Forms.UserControl",
			"Microsoft.VisualBasic.Compatibility.VB6.ADODC",
			"System.Web.UI.Design.WebControls.ParameterEditorUserControl",
			"System.Workflow.ComponentModel.Design.WorkflowOutline",
			"System.Workflow.ComponentModel.Design.WorkflowView",
			"System.Windows.Forms.Design.ComponentTray",
			"System.Windows.Forms.Panel",
			"System.Windows.Forms.Design.ComponentEditorPage",
			"System.Windows.Forms.FlowLayoutPanel",
			"System.Windows.Forms.SplitterPanel",
			"System.Windows.Forms.TableLayoutPanel",
			"System.ComponentModel.Design.ByteViewer",
			"System.Windows.Forms.TabPage",
			"System.Windows.Forms.ToolStripContentPanel",
			"System.Windows.Forms.ToolStrip",
			"System.Windows.Forms.BindingNavigator",
			"System.Windows.Forms.MenuStrip",
			"System.Windows.Forms.StatusStrip",
			"System.Windows.Forms.ToolStripDropDown",
			"System.Windows.Forms.ToolStripDropDownMenu",
			"System.Windows.Forms.ContextMenuStrip",
			"System.Windows.Forms.ToolStripOverflow",
			"System.Windows.Forms.ScrollBar",
			"System.Windows.Forms.HScrollBar",
			"System.Windows.Forms.VScrollBar",
			"System.Windows.Forms.Splitter",
			"System.Windows.Forms.StatusBar",
			"System.Windows.Forms.TabControl",
			"System.Windows.Forms.TextBoxBase",
			"System.Windows.Forms.MaskedTextBox",
			"System.Windows.Forms.RichTextBox",
			"System.Windows.Forms.TextBox",
			"System.Windows.Forms.DataGridTextBox",
			"System.Windows.Forms.DataGridViewTextBoxEditingControl",
			"System.Windows.Forms.ToolBar",
			"System.Windows.Forms.TrackBar",
			"System.Windows.Forms.TreeView",
			"System.ComponentModel.Design.ObjectSelectorEditor.Selector",
			"System.Windows.Forms.WebBrowserBase",
			"System.Windows.Forms.WebBrowser",
#endregion
		};

		public MemberInfos() => checkWinFormsClass = new DerivedFrom(WINFORMS_CLASSES);
		public bool IsWinFormsClass(MTypeDef type) => checkWinFormsClass.Check(type);
		public TypeInfo Type(MTypeDef t) => allTypeInfos[t];
		public bool TryGetType(MTypeDef t, out TypeInfo info) => allTypeInfos.TryGetValue(t, out info);
		public bool TryGetEvent(MEventDef e, out EventInfo info) => allEventInfos.TryGetValue(e, out info);
		public bool TryGetProperty(MPropertyDef p, out PropertyInfo info) => allPropertyInfos.TryGetValue(p, out info);
		public PropertyInfo Property(MPropertyDef prop) => allPropertyInfos[prop];
		public EventInfo Event(MEventDef evt) => allEventInfos[evt];
		public FieldInfo Field(MFieldDef field) => allFieldInfos[field];
		public MethodInfo Method(MMethodDef method) => allMethodInfos[method];
		public GenericParamInfo GenericParam(MGenericParamDef gparam) => allGenericParamInfos[gparam];
		public ParamInfo Param(MParamDef param) => allParamInfos[param];
		public void Add(MPropertyDef prop) => allPropertyInfos[prop] = new PropertyInfo(prop);
		public void Add(MEventDef evt) => allEventInfos[evt] = new EventInfo(evt);

		public void Initialize(Modules modules) {
			foreach (var type in modules.AllTypes) {
				allTypeInfos[type] = new TypeInfo(type, this);

				foreach (var gp in type.GenericParams)
					allGenericParamInfos[gp] = new GenericParamInfo(gp);

				foreach (var field in type.AllFields)
					allFieldInfos[field] = new FieldInfo(field);

				foreach (var evt in type.AllEvents)
					Add(evt);

				foreach (var prop in type.AllProperties)
					Add(prop);

				foreach (var method in type.AllMethods) {
					allMethodInfos[method] = new MethodInfo(method);
					foreach (var gp in method.GenericParams)
						allGenericParamInfos[gp] = new GenericParamInfo(gp);
					foreach (var param in method.AllParamDefs)
						allParamInfos[param] = new ParamInfo(param);
				}
			}
		}
	}
}



================================================
File: de4dot.code/renamer/NameCreators.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet;

namespace de4dot.code.renamer {
	public interface INameCreator {
		string Create();
	}

	public class OneNameCreator : INameCreator {
		string name;
		public OneNameCreator(string name) => this.name = name;
		public string Create() => name;
	}

	public abstract class NameCreatorCounter : INameCreator {
		protected int num;

		public abstract string Create();

		public NameCreatorCounter Merge(NameCreatorCounter other) {
			if (num < other.num)
				num = other.num;
			return this;
		}
	}

	public class GenericParamNameCreator : NameCreatorCounter {
		static string[] names = new string[] { "T", "U", "V", "W", "X", "Y", "Z" };

		public override string Create() {
			if (num < names.Length)
				return names[num++];
			return $"T{num++}";
		}
	}

	public class NameCreator : NameCreatorCounter {
		string prefix;

		public NameCreator(string prefix) : this(prefix, 0) { }

		public NameCreator(string prefix, int num) {
			this.prefix = prefix;
			this.num = num;
		}

		public NameCreator Clone() => new NameCreator(prefix, num);
		public override string Create() => prefix + num++;
	}

	// Like NameCreator but don't add the counter the first time
	public class NameCreator2 : NameCreatorCounter {
		string prefix;
		const string separator = "_";

		public NameCreator2(string prefix)
			: this(prefix, 0) {
		}

		public NameCreator2(string prefix, int num) {
			this.prefix = prefix;
			this.num = num;
		}

		public override string Create() {
			string rv;
			if (num == 0)
				rv = prefix;
			else
				rv = prefix + separator + num;
			num++;
			return rv;
		}
	}

	public interface ITypeNameCreator {
		string Create(TypeDef typeDef, string newBaseTypeName);
	}

	public class NameInfos {
		IList<NameInfo> nameInfos = new List<NameInfo>();

		class NameInfo {
			public string name;
			public NameCreator nameCreator;
			public NameInfo(string name, NameCreator nameCreator) {
				this.name = name;
				this.nameCreator = nameCreator;
			}
		}

		public void Add(string name, NameCreator nameCreator) => nameInfos.Add(new NameInfo(name, nameCreator));

		public NameCreator Find(string typeName) {
			foreach (var nameInfo in nameInfos) {
				if (typeName.Contains(nameInfo.name))
					return nameInfo.nameCreator;
			}

			return null;
		}
	}

	public class TypeNameCreator : ITypeNameCreator {
		ExistingNames existingNames;
		NameCreator createUnknownTypeName;
		NameCreator createEnumName;
		NameCreator createStructName;
		NameCreator createDelegateName;
		NameCreator createClassName;
		NameCreator createInterfaceName;
		NameInfos nameInfos = new NameInfos();

		public TypeNameCreator(ExistingNames existingNames) {
			this.existingNames = existingNames;
			createUnknownTypeName = CreateNameCreator("Type");
			createEnumName = CreateNameCreator("Enum");
			createStructName = CreateNameCreator("Struct");
			createDelegateName = CreateNameCreator("Delegate");
			createClassName = CreateNameCreator("Class");
			createInterfaceName = CreateNameCreator("Interface");

			var names = new string[] {
				"Exception",
				"EventArgs",
				"Attribute",
				"Form",
				"Dialog",
				"Control",
				"Stream",
			};
			foreach (var name in names)
				nameInfos.Add(name, CreateNameCreator(name));
		}

		protected virtual NameCreator CreateNameCreator(string prefix) => new NameCreator(prefix);

		public string Create(TypeDef typeDef, string newBaseTypeName) {
			var nameCreator = GetNameCreator(typeDef, newBaseTypeName);
			return existingNames.GetName(typeDef.Name.String, nameCreator);
		}

		NameCreator GetNameCreator(TypeDef typeDef, string newBaseTypeName) {
			var nameCreator = createUnknownTypeName;
			if (typeDef.IsEnum)
				nameCreator = createEnumName;
			else if (typeDef.IsValueType)
				nameCreator = createStructName;
			else if (typeDef.IsClass) {
				if (typeDef.BaseType != null) {
					var fn = typeDef.BaseType.FullName;
					if (fn == "System.Delegate")
						nameCreator = createDelegateName;
					else if (fn == "System.MulticastDelegate")
						nameCreator = createDelegateName;
					else {
						nameCreator = nameInfos.Find(newBaseTypeName ?? typeDef.BaseType.Name.String);
						if (nameCreator == null)
							nameCreator = createClassName;
					}
				}
				else
					nameCreator = createClassName;
			}
			else if (typeDef.IsInterface)
				nameCreator = createInterfaceName;
			return nameCreator;
		}
	}

	public class GlobalTypeNameCreator : TypeNameCreator {
		public GlobalTypeNameCreator(ExistingNames existingNames) : base(existingNames) { }
		protected override NameCreator CreateNameCreator(string prefix) => base.CreateNameCreator("G" + prefix);
	}
}



================================================
File: de4dot.code/renamer/Renamer.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using dnlib.DotNet;
using de4dot.code.renamer.asmmodules;
using dnlib.DotNet.Resources;
using de4dot.blocks;

namespace de4dot.code.renamer {
	[Flags]
	public enum RenamerFlags {
		RenameNamespaces = 1,
		RenameTypes = 2,
		RenameProperties = 4,
		RenameEvents = 8,
		RenameFields = 0x10,
		RenameMethods = 0x20,
		RenameMethodArgs = 0x40,
		RenameGenericParams = 0x80,
		RestoreProperties = 0x100,
		RestorePropertiesFromNames = 0x200,
		RestoreEvents = 0x400,
		RestoreEventsFromNames = 0x800,
		DontCreateNewParamDefs = 0x1000,
		DontRenameDelegateFields = 0x2000,
	}

	public class Renamer {
		public RenamerFlags RenamerFlags { get; set; }
		public bool RenameNamespaces {
			get => (RenamerFlags & RenamerFlags.RenameNamespaces) != 0;
			set {
				if (value)
					RenamerFlags |= RenamerFlags.RenameNamespaces;
				else
					RenamerFlags &= ~RenamerFlags.RenameNamespaces;
			}
		}
		public bool RenameTypes {
			get => (RenamerFlags & RenamerFlags.RenameTypes) != 0;
			set {
				if (value)
					RenamerFlags |= RenamerFlags.RenameTypes;
				else
					RenamerFlags &= ~RenamerFlags.RenameTypes;
			}
		}
		public bool RenameProperties {
			get => (RenamerFlags & RenamerFlags.RenameProperties) != 0;
			set {
				if (value)
					RenamerFlags |= RenamerFlags.RenameProperties;
				else
					RenamerFlags &= ~RenamerFlags.RenameProperties;
			}
		}
		public bool RenameEvents {
			get => (RenamerFlags & RenamerFlags.RenameEvents) != 0;
			set {
				if (value)
					RenamerFlags |= RenamerFlags.RenameEvents;
				else
					RenamerFlags &= ~RenamerFlags.RenameEvents;
			}
		}
		public bool RenameFields {
			get => (RenamerFlags & RenamerFlags.RenameFields) != 0;
			set {
				if (value)
					RenamerFlags |= RenamerFlags.RenameFields;
				else
					RenamerFlags &= ~RenamerFlags.RenameFields;
			}
		}
		public bool RenameMethods {
			get => (RenamerFlags & RenamerFlags.RenameMethods) != 0;
			set {
				if (value)
					RenamerFlags |= RenamerFlags.RenameMethods;
				else
					RenamerFlags &= ~RenamerFlags.RenameMethods;
			}
		}
		public bool RenameMethodArgs {
			get => (RenamerFlags & RenamerFlags.RenameMethodArgs) != 0;
			set {
				if (value)
					RenamerFlags |= RenamerFlags.RenameMethodArgs;
				else
					RenamerFlags &= ~RenamerFlags.RenameMethodArgs;
			}
		}
		public bool RenameGenericParams {
			get => (RenamerFlags & RenamerFlags.RenameGenericParams) != 0;
			set {
				if (value)
					RenamerFlags |= RenamerFlags.RenameGenericParams;
				else
					RenamerFlags &= ~RenamerFlags.RenameGenericParams;
			}
		}
		public bool RestoreProperties {
			get => (RenamerFlags & RenamerFlags.RestoreProperties) != 0;
			set {
				if (value)
					RenamerFlags |= RenamerFlags.RestoreProperties;
				else
					RenamerFlags &= ~RenamerFlags.RestoreProperties;
			}
		}
		public bool RestorePropertiesFromNames {
			get => (RenamerFlags & RenamerFlags.RestorePropertiesFromNames) != 0;
			set {
				if (value)
					RenamerFlags |= RenamerFlags.RestorePropertiesFromNames;
				else
					RenamerFlags &= ~RenamerFlags.RestorePropertiesFromNames;
			}
		}
		public bool RestoreEvents {
			get => (RenamerFlags & RenamerFlags.RestoreEvents) != 0;
			set {
				if (value)
					RenamerFlags |= RenamerFlags.RestoreEvents;
				else
					RenamerFlags &= ~RenamerFlags.RestoreEvents;
			}
		}
		public bool RestoreEventsFromNames {
			get => (RenamerFlags & RenamerFlags.RestoreEventsFromNames) != 0;
			set {
				if (value)
					RenamerFlags |= RenamerFlags.RestoreEventsFromNames;
				else
					RenamerFlags &= ~RenamerFlags.RestoreEventsFromNames;
			}
		}
		public bool DontCreateNewParamDefs {
			get => (RenamerFlags & RenamerFlags.DontCreateNewParamDefs) != 0;
			set {
				if (value)
					RenamerFlags |= RenamerFlags.DontCreateNewParamDefs;
				else
					RenamerFlags &= ~RenamerFlags.DontCreateNewParamDefs;
			}
		}
		public bool DontRenameDelegateFields {
			get => (RenamerFlags & RenamerFlags.DontRenameDelegateFields) != 0;
			set {
				if (value)
					RenamerFlags |= RenamerFlags.DontRenameDelegateFields;
				else
					RenamerFlags &= ~RenamerFlags.DontRenameDelegateFields;
			}
		}

		Modules modules;
		MemberInfos memberInfos = new MemberInfos();
		DerivedFrom isDelegateClass;
		MergeStateHelper mergeStateHelper;
		bool isVerbose;

		static string[] delegateClasses = new string[] {
			"System.Delegate",
			"System.MulticastDelegate",
		};

		public Renamer(IDeobfuscatorContext deobfuscatorContext, IEnumerable<IObfuscatedFile> files, RenamerFlags flags) {
			RenamerFlags = flags;

			WarnIfXaml(files);

			modules = new Modules(deobfuscatorContext);
			isDelegateClass = new DerivedFrom(delegateClasses);
			mergeStateHelper = new MergeStateHelper(memberInfos);

			foreach (var file in files)
				modules.Add(new Module(file));
		}

		static void WarnIfXaml(IEnumerable<IObfuscatedFile> files) {
			foreach (var file in files) {
				foreach (var tmp in file.ModuleDefMD.Resources) {
					var rsrc = tmp as EmbeddedResource;
					if (rsrc == null)
						continue;
					if (UTF8String.IsNullOrEmpty(rsrc.Name))
						continue;
					if (!rsrc.Name.String.EndsWith(".g.resources"))
						continue;
					if (!HasXamlFiles(file.ModuleDefMD, rsrc))
						continue;

					Logger.w("File '{0}' contains XAML which isn't supported. Use --dont-rename.", file.Filename);
					return;
				}
			}
		}

		static bool HasXamlFiles(ModuleDef module, EmbeddedResource rsrc) {
			try {
				var rsrcSet = ResourceReader.Read(module, rsrc.CreateReader());
				foreach (var elem in rsrcSet.ResourceElements) {
					if (elem.Name.EndsWith(".baml") || elem.Name.EndsWith(".xaml"))
						return true;
				}
			}
			catch {
			}
			return false;
		}

		public void Rename() {
			if (modules.Empty)
				return;
			isVerbose = !Logger.Instance.IgnoresEvent(LoggerEvent.Verbose);
			Logger.n("Renaming all obfuscated symbols");

			modules.Initialize();
			RenameResourceKeys();
			var groups = modules.InitializeVirtualMembers();
			memberInfos.Initialize(modules);
			RenameTypeDefs();
			RenameTypeRefs();
			modules.OnTypesRenamed();
			RestorePropertiesAndEvents(groups);
			PrepareRenameMemberDefs(groups);
			RenameMemberDefs();
			RenameMemberRefs();
			RemoveUselessOverrides(groups);
			RenameResources();
			modules.CleanUp();
		}

		void RenameResourceKeys() {
			foreach (var module in modules.TheModules) {
				if (!module.ObfuscatedFile.RenameResourceKeys)
					continue;
				new ResourceKeysRenamer(module.ModuleDefMD, module.ObfuscatedFile.NameChecker).Rename();
			}
		}

		void RemoveUselessOverrides(MethodNameGroups groups) {
			foreach (var group in groups.GetAllGroups()) {
				foreach (var method in group.Methods) {
					if (!method.Owner.HasModule)
						continue;
					if (!method.IsPublic())
						continue;
					var overrides = method.MethodDef.Overrides;
					for (int i = 0; i < overrides.Count; i++) {
						var overrideMethod = overrides[i].MethodDeclaration;
						if (method.MethodDef.Name != overrideMethod.Name)
							continue;
						if (isVerbose)
							Logger.v("Removed useless override from method {0} ({1:X8}), override: {2:X8}",
									Utils.RemoveNewlines(method.MethodDef),
									method.MethodDef.MDToken.ToInt32(),
									overrideMethod.MDToken.ToInt32());
						overrides.RemoveAt(i);
						i--;
					}
				}
			}
		}

		void RenameTypeDefs() {
			if (isVerbose)
				Logger.v("Renaming obfuscated type definitions");

			foreach (var module in modules.TheModules) {
				if (module.ObfuscatedFile.RemoveNamespaceWithOneType)
					RemoveOneClassNamespaces(module);
			}

			var state = new TypeRenamerState();
			foreach (var type in modules.AllTypes)
				state.AddTypeName(memberInfos.Type(type).oldName);
			PrepareRenameTypes(modules.BaseTypes, state);
			FixClsTypeNames();
			RenameTypeDefs(modules.NonNestedTypes);
		}

		void RemoveOneClassNamespaces(Module module) {
			var nsToTypes = new Dictionary<string, List<MTypeDef>>(StringComparer.Ordinal);

			foreach (var typeDef in module.GetAllTypes()) {
				var ns = typeDef.TypeDef.Namespace.String;
				if (string.IsNullOrEmpty(ns))
					continue;
				if (module.ObfuscatedFile.NameChecker.IsValidNamespaceName(ns))
					continue;
				if (!nsToTypes.TryGetValue(ns, out var list))
					nsToTypes[ns] = list = new List<MTypeDef>();
				list.Add(typeDef);
			}

			var sortedNamespaces = new List<List<MTypeDef>>(nsToTypes.Values);
			sortedNamespaces.Sort((a, b) => {
				return UTF8String.CompareTo(a[0].TypeDef.Namespace, b[0].TypeDef.Namespace);
			});
			foreach (var list in sortedNamespaces) {
				const int maxClasses = 1;
				if (list.Count != maxClasses)
					continue;
				if (isVerbose)
					Logger.v("Removing namespace: {0}", Utils.RemoveNewlines(list[0].TypeDef.Namespace));
				foreach (var type in list)
					memberInfos.Type(type).newNamespace = "";
			}
		}

		void RenameTypeDefs(IEnumerable<MTypeDef> typeDefs) {
			Logger.Instance.Indent();
			foreach (var typeDef in typeDefs) {
				Rename(typeDef);
				RenameTypeDefs(typeDef.NestedTypes);
			}
			Logger.Instance.DeIndent();
		}

		void Rename(MTypeDef type) {
			var typeDef = type.TypeDef;
			var info = memberInfos.Type(type);

			if (isVerbose)
				Logger.v("Type: {0} ({1:X8})", Utils.RemoveNewlines(typeDef.FullName), typeDef.MDToken.ToUInt32());
			Logger.Instance.Indent();

			RenameGenericParams2(type.GenericParams);

			if (RenameTypes && info.GotNewName()) {
				var old = typeDef.Name;
				typeDef.Name = info.newName;
				if (isVerbose)
					Logger.v("Name: {0} => {1}", Utils.RemoveNewlines(old), Utils.RemoveNewlines(typeDef.Name));
			}

			if (RenameNamespaces && info.newNamespace != null) {
				var old = typeDef.Namespace;
				typeDef.Namespace = info.newNamespace;
				if (isVerbose)
					Logger.v("Namespace: {0} => {1}", Utils.RemoveNewlines(old), Utils.RemoveNewlines(typeDef.Namespace));
			}

			Logger.Instance.DeIndent();
		}

		void RenameGenericParams2(IEnumerable<MGenericParamDef> genericParams) {
			if (!RenameGenericParams)
				return;
			foreach (var param in genericParams) {
				var info = memberInfos.GenericParam(param);
				if (!info.GotNewName())
					continue;
				param.GenericParam.Name = info.newName;
				if (isVerbose)
					Logger.v("GenParam: {0} => {1}", Utils.RemoveNewlines(info.oldFullName), Utils.RemoveNewlines(param.GenericParam.FullName));
			}
		}

		void RenameMemberDefs() {
			if (isVerbose)
				Logger.v("Renaming member definitions #2");

			var allTypes = new List<MTypeDef>(modules.AllTypes);
			allTypes.Sort((a, b) => a.Index.CompareTo(b.Index));

			Logger.Instance.Indent();
			foreach (var typeDef in allTypes)
				RenameMembers(typeDef);
			Logger.Instance.DeIndent();
		}

		void RenameMembers(MTypeDef type) {
			var info = memberInfos.Type(type);

			if (isVerbose)
				Logger.v("Type: {0}", Utils.RemoveNewlines(info.type.TypeDef.FullName));
			Logger.Instance.Indent();

			RenameFields2(info);
			RenameProperties2(info);
			RenameEvents2(info);
			RenameMethods2(info);

			Logger.Instance.DeIndent();
		}

		void RenameFields2(TypeInfo info) {
			if (!RenameFields)
				return;
			bool isDelegateType = isDelegateClass.Check(info.type);
			foreach (var fieldDef in info.type.AllFieldsSorted) {
				var fieldInfo = memberInfos.Field(fieldDef);
				if (!fieldInfo.GotNewName())
					continue;
				if (isDelegateType && DontRenameDelegateFields)
					continue;
				fieldDef.FieldDef.Name = fieldInfo.newName;
				if (isVerbose)
					Logger.v("Field: {0} ({1:X8}) => {2}",
							Utils.RemoveNewlines(fieldInfo.oldFullName),
							fieldDef.FieldDef.MDToken.ToUInt32(),
							Utils.RemoveNewlines(fieldDef.FieldDef.FullName));
			}
		}

		void RenameProperties2(TypeInfo info) {
			if (!RenameProperties)
				return;
			foreach (var propDef in info.type.AllPropertiesSorted) {
				var propInfo = memberInfos.Property(propDef);
				if (!propInfo.GotNewName())
					continue;
				propDef.PropertyDef.Name = propInfo.newName;
				if (isVerbose)
					Logger.v("Property: {0} ({1:X8}) => {2}",
							Utils.RemoveNewlines(propInfo.oldFullName),
							propDef.PropertyDef.MDToken.ToUInt32(),
							Utils.RemoveNewlines(propDef.PropertyDef.FullName));
			}
		}

		void RenameEvents2(TypeInfo info) {
			if (!RenameEvents)
				return;
			foreach (var eventDef in info.type.AllEventsSorted) {
				var eventInfo = memberInfos.Event(eventDef);
				if (!eventInfo.GotNewName())
					continue;
				eventDef.EventDef.Name = eventInfo.newName;
				if (isVerbose)
					Logger.v("Event: {0} ({1:X8}) => {2}",
							Utils.RemoveNewlines(eventInfo.oldFullName),
							eventDef.EventDef.MDToken.ToUInt32(),
							Utils.RemoveNewlines(eventDef.EventDef.FullName));
			}
		}

		void RenameMethods2(TypeInfo info) {
			if (!RenameMethods && !RenameMethodArgs && !RenameGenericParams)
				return;
			foreach (var methodDef in info.type.AllMethodsSorted) {
				var methodInfo = memberInfos.Method(methodDef);
				if (isVerbose)
					Logger.v("Method {0} ({1:X8})", Utils.RemoveNewlines(methodInfo.oldFullName), methodDef.MethodDef.MDToken.ToUInt32());
				Logger.Instance.Indent();

				RenameGenericParams2(methodDef.GenericParams);

				if (RenameMethods && methodInfo.GotNewName()) {
					methodDef.MethodDef.Name = methodInfo.newName;
					if (isVerbose)
						Logger.v("Name: {0} => {1}", Utils.RemoveNewlines(methodInfo.oldFullName), Utils.RemoveNewlines(methodDef.MethodDef.FullName));
				}

				if (RenameMethodArgs) {
					foreach (var param in methodDef.AllParamDefs) {
						var paramInfo = memberInfos.Param(param);
						if (!paramInfo.GotNewName())
							continue;
						if (!param.ParameterDef.HasParamDef) {
							if (DontCreateNewParamDefs)
								continue;
							param.ParameterDef.CreateParamDef();
						}
						param.ParameterDef.Name = paramInfo.newName;
						if (isVerbose) {
							if (param.IsReturnParameter)
								Logger.v("RetParam: {0} => {1}", Utils.RemoveNewlines(paramInfo.oldName), Utils.RemoveNewlines(paramInfo.newName));
							else
								Logger.v("Param ({0}/{1}): {2} => {3}", param.ParameterDef.MethodSigIndex + 1, methodDef.MethodDef.MethodSig.GetParamCount(), Utils.RemoveNewlines(paramInfo.oldName), Utils.RemoveNewlines(paramInfo.newName));
						}
					}
				}

				Logger.Instance.DeIndent();
			}
		}

		void RenameMemberRefs() {
			if (isVerbose)
				Logger.v("Renaming references to other definitions");
			foreach (var module in modules.TheModules) {
				if (modules.TheModules.Count > 1 && isVerbose)
					Logger.v("Renaming references to other definitions ({0})", module.Filename);
				Logger.Instance.Indent();
				foreach (var refToDef in module.MethodRefsToRename)
					refToDef.reference.Name = refToDef.definition.Name;
				foreach (var refToDef in module.FieldRefsToRename)
					refToDef.reference.Name = refToDef.definition.Name;
				foreach (var info in module.CustomAttributeFieldRefs)
					info.cattr.NamedArguments[info.index].Name = info.reference.Name;
				foreach (var info in module.CustomAttributePropertyRefs)
					info.cattr.NamedArguments[info.index].Name = info.reference.Name;
				Logger.Instance.DeIndent();
			}
		}

		void RenameResources() {
			if (isVerbose)
				Logger.v("Renaming resources");
			foreach (var module in modules.TheModules) {
				if (modules.TheModules.Count > 1 && isVerbose)
					Logger.v("Renaming resources ({0})", module.Filename);
				Logger.Instance.Indent();
				RenameResources(module);
				Logger.Instance.DeIndent();
			}
		}

		void RenameResources(Module module) {
			var renamedTypes = new List<TypeInfo>();
			foreach (var type in module.GetAllTypes()) {
				var info = memberInfos.Type(type);
				if (info.oldFullName != info.type.TypeDef.FullName)
					renamedTypes.Add(info);
			}
			if (renamedTypes.Count == 0)
				return;

			new ResourceRenamer(module).Rename(renamedTypes);
		}

		// Make sure the renamed types are using valid CLS names. That means renaming all
		// generic types from eg. Class1 to Class1`2. If we don't do this, some decompilers
		// (eg. ILSpy v1.0) won't produce correct output.
		void FixClsTypeNames() {
			foreach (var type in modules.NonNestedTypes)
				FixClsTypeNames(null, type);
		}

		void FixClsTypeNames(MTypeDef nesting, MTypeDef nested) {
			int nestingCount = nesting == null ? 0 : nesting.GenericParams.Count;
			int arity = nested.GenericParams.Count - nestingCount;
			var nestedInfo = memberInfos.Type(nested);
			if (nestedInfo.renamed && arity > 0)
				nestedInfo.newName += "`" + arity;
			foreach (var nestedType in nested.NestedTypes)
				FixClsTypeNames(nested, nestedType);
		}

		void PrepareRenameTypes(IEnumerable<MTypeDef> types, TypeRenamerState state) {
			foreach (var typeDef in types) {
				memberInfos.Type(typeDef).PrepareRenameTypes(state);
				PrepareRenameTypes(typeDef.derivedTypes, state);
			}
		}

		void RenameTypeRefs() {
			if (isVerbose)
				Logger.v("Renaming references to type definitions");
			var theModules = modules.TheModules;
			foreach (var module in theModules) {
				if (theModules.Count > 1 && isVerbose)
					Logger.v("Renaming references to type definitions ({0})", module.Filename);
				Logger.Instance.Indent();
				foreach (var refToDef in module.TypeRefsToRename) {
					refToDef.reference.Name = refToDef.definition.Name;
					refToDef.reference.Namespace = refToDef.definition.Namespace;
				}
				Logger.Instance.DeIndent();
			}
		}

		void RestorePropertiesAndEvents(MethodNameGroups groups) {
			var allGroups = groups.GetAllGroups();
			RestoreVirtualProperties(allGroups);
			RestorePropertiesFromNames2(allGroups);
			ResetVirtualPropertyNames(allGroups);
			RestoreVirtualEvents(allGroups);
			RestoreEventsFromNames2(allGroups);
			ResetVirtualEventNames(allGroups);
		}

		void ResetVirtualPropertyNames(IEnumerable<MethodNameGroup> allGroups) {
			if (!RenameProperties)
				return;
			foreach (var group in allGroups) {
				MPropertyDef prop = null;
				foreach (var method in group.Methods) {
					if (method.Property == null)
						continue;
					if (method.Owner.HasModule)
						continue;
					prop = method.Property;
					break;
				}
				if (prop == null)
					continue;
				foreach (var method in group.Methods) {
					if (!method.Owner.HasModule)
						continue;
					if (method.Property == null)
						continue;
					memberInfos.Property(method.Property).Rename(prop.PropertyDef.Name.String);
				}
			}
		}

		void ResetVirtualEventNames(IEnumerable<MethodNameGroup> allGroups) {
			if (!RenameEvents)
				return;
			foreach (var group in allGroups) {
				MEventDef evt = null;
				foreach (var method in group.Methods) {
					if (method.Event == null)
						continue;
					if (method.Owner.HasModule)
						continue;
					evt = method.Event;
					break;
				}
				if (evt == null)
					continue;
				foreach (var method in group.Methods) {
					if (!method.Owner.HasModule)
						continue;
					if (method.Event == null)
						continue;
					memberInfos.Event(method.Event).Rename(evt.EventDef.Name.String);
				}
			}
		}

		void RestoreVirtualProperties(IEnumerable<MethodNameGroup> allGroups) {
			if (!RestoreProperties)
				return;
			foreach (var group in allGroups) {
				RestoreVirtualProperties(group);
				RestoreExplicitVirtualProperties(group);
			}
		}

		void RestoreExplicitVirtualProperties(MethodNameGroup group) {
			if (group.Methods.Count != 1)
				return;
			var propMethod = group.Methods[0];
			if (propMethod.Property != null)
				return;
			if (propMethod.MethodDef.Overrides.Count == 0)
				return;

			var theProperty = GetOverriddenProperty(propMethod);
			if (theProperty == null)
				return;

			CreateProperty(theProperty, propMethod, GetOverridePrefix(group, propMethod));
		}

		void RestoreVirtualProperties(MethodNameGroup group) {
			if (group.Methods.Count <= 1 || !group.HasProperty())
				return;

			MPropertyDef prop = null;
			List<MMethodDef> missingProps = null;
			foreach (var method in group.Methods) {
				if (method.Property == null) {
					if (missingProps == null)
						missingProps = new List<MMethodDef>();
					missingProps.Add(method);
				}
				else if (prop == null || !method.Owner.HasModule)
					prop = method.Property;
			}
			if (prop == null)
				return;	// Should never happen
			if (missingProps == null)
				return;

			foreach (var method in missingProps)
				CreateProperty(prop, method, "");
		}

		void CreateProperty(MPropertyDef propDef, MMethodDef methodDef, string overridePrefix) {
			if (!methodDef.Owner.HasModule)
				return;

			var newPropertyName = overridePrefix + propDef.PropertyDef.Name;
			if (!DotNetUtils.HasReturnValue(methodDef.MethodDef))
				CreatePropertySetter(newPropertyName, methodDef);
			else
				CreatePropertyGetter(newPropertyName, methodDef);
		}

		void RestorePropertiesFromNames2(IEnumerable<MethodNameGroup> allGroups) {
			if (!RestorePropertiesFromNames)
				return;

			foreach (var group in allGroups) {
				var groupMethod = group.Methods[0];
				var methodName = groupMethod.MethodDef.Name.String;
				bool onlyRenamableMethods = !group.HasNonRenamableMethod();

				if (Utils.StartsWith(methodName, "get_", StringComparison.Ordinal)) {
					var propName = methodName.Substring(4);
					foreach (var method in group.Methods) {
						if (onlyRenamableMethods && !memberInfos.Type(method.Owner).NameChecker.IsValidPropertyName(propName))
							continue;
						CreatePropertyGetter(propName, method);
					}
				}
				else if (Utils.StartsWith(methodName, "set_", StringComparison.Ordinal)) {
					var propName = methodName.Substring(4);
					foreach (var method in group.Methods) {
						if (onlyRenamableMethods && !memberInfos.Type(method.Owner).NameChecker.IsValidPropertyName(propName))
							continue;
						CreatePropertySetter(propName, method);
					}
				}
			}

			foreach (var type in modules.AllTypes) {
				foreach (var method in type.AllMethodsSorted) {
					if (method.IsVirtual())
						continue;	// Virtual methods are in allGroups, so already fixed above
					if (method.Property != null)
						continue;
					var methodName = method.MethodDef.Name.String;
					if (Utils.StartsWith(methodName, "get_", StringComparison.Ordinal))
						CreatePropertyGetter(methodName.Substring(4), method);
					else if (Utils.StartsWith(methodName, "set_", StringComparison.Ordinal))
						CreatePropertySetter(methodName.Substring(4), method);
				}
			}
		}

		MPropertyDef CreatePropertyGetter(string name, MMethodDef propMethod) {
			if (string.IsNullOrEmpty(name))
				return null;
			var ownerType = propMethod.Owner;
			if (!ownerType.HasModule)
				return null;
			if (propMethod.Property != null)
				return null;

			var sig = propMethod.MethodDef.MethodSig;
			if (sig == null)
				return null;
			var propType = sig.RetType;
			var propDef = CreateProperty(ownerType, name, propType, propMethod.MethodDef, null);
			if (propDef == null)
				return null;
			if (propDef.GetMethod != null)
				return null;
			if (isVerbose)
				Logger.v("Restoring property getter {0} ({1:X8}), Property: {2} ({3:X8})",
						Utils.RemoveNewlines(propMethod),
						propMethod.MethodDef.MDToken.ToInt32(),
						Utils.RemoveNewlines(propDef.PropertyDef),
						propDef.PropertyDef.MDToken.ToInt32());
			propDef.PropertyDef.GetMethod = propMethod.MethodDef;
			propDef.GetMethod = propMethod;
			propMethod.Property = propDef;
			return propDef;
		}

		MPropertyDef CreatePropertySetter(string name, MMethodDef propMethod) {
			if (string.IsNullOrEmpty(name))
				return null;
			var ownerType = propMethod.Owner;
			if (!ownerType.HasModule)
				return null;
			if (propMethod.Property != null)
				return null;

			var sig = propMethod.MethodDef.MethodSig;
			if (sig == null || sig.Params.Count == 0)
				return null;
			var propType = sig.Params[sig.Params.Count - 1];
			var propDef = CreateProperty(ownerType, name, propType, null, propMethod.MethodDef);
			if (propDef == null)
				return null;
			if (propDef.SetMethod != null)
				return null;
			if (isVerbose)
				Logger.v("Restoring property setter {0} ({1:X8}), Property: {2} ({3:X8})",
						Utils.RemoveNewlines(propMethod),
						propMethod.MethodDef.MDToken.ToInt32(),
						Utils.RemoveNewlines(propDef.PropertyDef),
						propDef.PropertyDef.MDToken.ToInt32());
			propDef.PropertyDef.SetMethod = propMethod.MethodDef;
			propDef.SetMethod = propMethod;
			propMethod.Property = propDef;
			return propDef;
		}

		MPropertyDef CreateProperty(MTypeDef ownerType, string name, TypeSig propType, MethodDef getter, MethodDef setter) {
			if (string.IsNullOrEmpty(name) || propType.ElementType == ElementType.Void)
				return null;
			var newSig = CreatePropertySig(getter, propType, true) ?? CreatePropertySig(setter, propType, false);
			if (newSig == null)
				return null;
			var newProp = ownerType.Module.ModuleDefMD.UpdateRowId(new PropertyDefUser(name, newSig, 0));
			newProp.GetMethod = getter;
			newProp.SetMethod = setter;
			var propDef = ownerType.FindAny(newProp);
			if (propDef != null)
				return propDef;

			propDef = ownerType.Create(newProp);
			memberInfos.Add(propDef);
			if (isVerbose)
				Logger.v("Restoring property: {0}", Utils.RemoveNewlines(newProp));
			return propDef;
		}

		static PropertySig CreatePropertySig(MethodDef method, TypeSig propType, bool isGetter) {
			if (method == null)
				return null;
			var sig = method.MethodSig;
			if (sig == null)
				return null;

			var newSig = new PropertySig(sig.HasThis, propType);
			newSig.GenParamCount = sig.GenParamCount;

			int count = sig.Params.Count;
			if (!isGetter)
				count--;
			for (int i = 0; i < count; i++)
				newSig.Params.Add(sig.Params[i]);

			return newSig;
		}

		void RestoreVirtualEvents(IEnumerable<MethodNameGroup> allGroups) {
			if (!RestoreEvents)
				return;
			foreach (var group in allGroups) {
				RestoreVirtualEvents(group);
				RestoreExplicitVirtualEvents(group);
			}
		}

		enum EventMethodType {
			None,
			Other,
			Adder,
			Remover,
			Raiser,
		}

		void RestoreExplicitVirtualEvents(MethodNameGroup group) {
			if (group.Methods.Count != 1)
				return;
			var eventMethod = group.Methods[0];
			if (eventMethod.Event != null)
				return;
			if (eventMethod.MethodDef.Overrides.Count == 0)
				return;

			var theEvent = GetOverriddenEvent(eventMethod, out var overriddenMethod);
			if (theEvent == null)
				return;

			CreateEvent(theEvent, eventMethod, GetEventMethodType(overriddenMethod), GetOverridePrefix(group, eventMethod));
		}

		void RestoreVirtualEvents(MethodNameGroup group) {
			if (group.Methods.Count <= 1 || !group.HasEvent())
				return;

			var methodType = EventMethodType.None;
			MEventDef evt = null;
			List<MMethodDef> missingEvents = null;
			foreach (var method in group.Methods) {
				if (method.Event == null) {
					if (missingEvents == null)
						missingEvents = new List<MMethodDef>();
					missingEvents.Add(method);
				}
				else if (evt == null || !method.Owner.HasModule) {
					evt = method.Event;
					methodType = GetEventMethodType(method);
				}
			}
			if (evt == null)
				return;	// Should never happen
			if (missingEvents == null)
				return;

			foreach (var method in missingEvents)
				CreateEvent(evt, method, methodType, "");
		}

		void CreateEvent(MEventDef eventDef, MMethodDef methodDef, EventMethodType methodType, string overridePrefix) {
			if (!methodDef.Owner.HasModule)
				return;

			var newEventName = overridePrefix + eventDef.EventDef.Name;
			switch (methodType) {
			case EventMethodType.Adder:
				CreateEventAdder(newEventName, methodDef);
				break;
			case EventMethodType.Remover:
				CreateEventRemover(newEventName, methodDef);
				break;
			}
		}

		static EventMethodType GetEventMethodType(MMethodDef method) {
			var evt = method.Event;
			if (evt == null)
				return EventMethodType.None;
			if (evt.AddMethod == method)
				return EventMethodType.Adder;
			if (evt.RemoveMethod == method)
				return EventMethodType.Remover;
			if (evt.RaiseMethod == method)
				return EventMethodType.Raiser;
			return EventMethodType.Other;
		}

		void RestoreEventsFromNames2(IEnumerable<MethodNameGroup> allGroups) {
			if (!RestoreEventsFromNames)
				return;

			foreach (var group in allGroups) {
				var groupMethod = group.Methods[0];
				var methodName = groupMethod.MethodDef.Name.String;
				bool onlyRenamableMethods = !group.HasNonRenamableMethod();

				if (Utils.StartsWith(methodName, "add_", StringComparison.Ordinal)) {
					var eventName = methodName.Substring(4);
					foreach (var method in group.Methods) {
						if (onlyRenamableMethods && !memberInfos.Type(method.Owner).NameChecker.IsValidEventName(eventName))
							continue;
						CreateEventAdder(eventName, method);
					}
				}
				else if (Utils.StartsWith(methodName, "remove_", StringComparison.Ordinal)) {
					var eventName = methodName.Substring(7);
					foreach (var method in group.Methods) {
						if (onlyRenamableMethods && !memberInfos.Type(method.Owner).NameChecker.IsValidEventName(eventName))
							continue;
						CreateEventRemover(eventName, method);
					}
				}
			}

			foreach (var type in modules.AllTypes) {
				foreach (var method in type.AllMethodsSorted) {
					if (method.IsVirtual())
						continue;	// Virtual methods are in allGroups, so already fixed above
					if (method.Event != null)
						continue;
					var methodName = method.MethodDef.Name.String;
					if (Utils.StartsWith(methodName, "add_", StringComparison.Ordinal))
						CreateEventAdder(methodName.Substring(4), method);
					else if (Utils.StartsWith(methodName, "remove_", StringComparison.Ordinal))
						CreateEventRemover(methodName.Substring(7), method);
				}
			}
		}

		MEventDef CreateEventAdder(string name, MMethodDef eventMethod) {
			if (string.IsNullOrEmpty(name))
				return null;
			var ownerType = eventMethod.Owner;
			if (!ownerType.HasModule)
				return null;
			if (eventMethod.Event != null)
				return null;

			var method = eventMethod.MethodDef;
			var eventDef = CreateEvent(ownerType, name, GetEventType(method));
			if (eventDef == null)
				return null;
			if (eventDef.AddMethod != null)
				return null;
			if (isVerbose)
				Logger.v("Restoring event adder {0} ({1:X8}), Event: {2} ({3:X8})",
						Utils.RemoveNewlines(eventMethod),
						eventMethod.MethodDef.MDToken.ToInt32(),
						Utils.RemoveNewlines(eventDef.EventDef),
						eventDef.EventDef.MDToken.ToInt32());
			eventDef.EventDef.AddMethod = eventMethod.MethodDef;
			eventDef.AddMethod = eventMethod;
			eventMethod.Event = eventDef;
			return eventDef;
		}

		MEventDef CreateEventRemover(string name, MMethodDef eventMethod) {
			if (string.IsNullOrEmpty(name))
				return null;
			var ownerType = eventMethod.Owner;
			if (!ownerType.HasModule)
				return null;
			if (eventMethod.Event != null)
				return null;

			var method = eventMethod.MethodDef;
			var eventDef = CreateEvent(ownerType, name, GetEventType(method));
			if (eventDef == null)
				return null;
			if (eventDef.RemoveMethod != null)
				return null;
			if (isVerbose)
				Logger.v("Restoring event remover {0} ({1:X8}), Event: {2} ({3:X8})",
						Utils.RemoveNewlines(eventMethod),
						eventMethod.MethodDef.MDToken.ToInt32(),
						Utils.RemoveNewlines(eventDef.EventDef),
						eventDef.EventDef.MDToken.ToInt32());
			eventDef.EventDef.RemoveMethod = eventMethod.MethodDef;
			eventDef.RemoveMethod = eventMethod;
			eventMethod.Event = eventDef;
			return eventDef;
		}

		TypeSig GetEventType(IMethod method) {
			if (DotNetUtils.HasReturnValue(method))
				return null;
			var sig = method.MethodSig;
			if (sig == null || sig.Params.Count != 1)
				return null;
			return sig.Params[0];
		}

		MEventDef CreateEvent(MTypeDef ownerType, string name, TypeSig eventType) {
			if (string.IsNullOrEmpty(name) || eventType == null || eventType.ElementType == ElementType.Void)
				return null;
			var newEvent = ownerType.Module.ModuleDefMD.UpdateRowId(new EventDefUser(name, eventType.ToTypeDefOrRef(), 0));
			var eventDef = ownerType.FindAny(newEvent);
			if (eventDef != null)
				return eventDef;

			eventDef = ownerType.Create(newEvent);
			memberInfos.Add(eventDef);
			if (isVerbose)
				Logger.v("Restoring event: {0}", Utils.RemoveNewlines(newEvent));
			return eventDef;
		}

		void PrepareRenameMemberDefs(MethodNameGroups groups) {
			if (isVerbose)
				Logger.v("Renaming member definitions #1");

			PrepareRenameEntryPoints();

			var virtualMethods = new GroupHelper(memberInfos, modules.AllTypes);
			var ifaceMethods = new GroupHelper(memberInfos, modules.AllTypes);
			var propMethods = new GroupHelper(memberInfos, modules.AllTypes);
			var eventMethods = new GroupHelper(memberInfos, modules.AllTypes);
			foreach (var group in GetSorted(groups)) {
				if (group.HasNonRenamableMethod())
					continue;
				else if (group.HasGetterOrSetterPropertyMethod() && GetPropertyMethodType(group.Methods[0]) != PropertyMethodType.Other)
					propMethods.Add(group);
				else if (group.HasAddRemoveOrRaiseEventMethod())
					eventMethods.Add(group);
				else if (group.HasInterfaceMethod())
					ifaceMethods.Add(group);
				else
					virtualMethods.Add(group);
			}

			var prepareHelper = new PrepareHelper(memberInfos, modules.AllTypes);
			prepareHelper.Prepare((info) => info.PrepareRenameMembers());

			prepareHelper.Prepare((info) => info.PrepareRenamePropsAndEvents());
			propMethods.VisitAll((group) => PrepareRenameProperty(group, false));
			eventMethods.VisitAll((group) => PrepareRenameEvent(group, false));
			propMethods.VisitAll((group) => PrepareRenameProperty(group, true));
			eventMethods.VisitAll((group) => PrepareRenameEvent(group, true));

			foreach (var typeDef in modules.AllTypes)
				memberInfos.Type(typeDef).InitializeEventHandlerNames();

			prepareHelper.Prepare((info) => info.PrepareRenameMethods());
			ifaceMethods.VisitAll((group) => PrepareRenameVirtualMethods(group, "imethod_", false));
			virtualMethods.VisitAll((group) => PrepareRenameVirtualMethods(group, "vmethod_", false));
			ifaceMethods.VisitAll((group) => PrepareRenameVirtualMethods(group, "imethod_", true));
			virtualMethods.VisitAll((group) => PrepareRenameVirtualMethods(group, "vmethod_", true));

			RestoreMethodArgs(groups);

			foreach (var typeDef in modules.AllTypes)
				memberInfos.Type(typeDef).PrepareRenameMethods2();
		}

		void RestoreMethodArgs(MethodNameGroups groups) {
			foreach (var group in groups.GetAllGroups()) {
				if (group.Methods[0].VisibleParameterCount == 0)
					continue;

				var argNames = GetValidArgNames(group);

				foreach (var method in group.Methods) {
					if (!method.Owner.HasModule)
						continue;
					var nameChecker = method.Owner.Module.ObfuscatedFile.NameChecker;

					for (int i = 0; i < argNames.Length; i++) {
						var argName = argNames[i];
						if (argName == null || !nameChecker.IsValidMethodArgName(argName))
							continue;
						var info = memberInfos.Param(method.ParamDefs[i]);
						if (nameChecker.IsValidMethodArgName(info.oldName))
							continue;
						info.newName = argName;
					}
				}
			}
		}

		string[] GetValidArgNames(MethodNameGroup group) {
			var methods = new List<MMethodDef>(group.Methods);
			foreach (var method in group.Methods) {
				foreach (var ovrd in method.MethodDef.Overrides) {
					var overrideRef = ovrd.MethodDeclaration;
					var overrideDef = modules.ResolveMethod(overrideRef);
					if (overrideDef == null) {
						var typeDef = modules.ResolveType(overrideRef.DeclaringType) ?? modules.ResolveOther(overrideRef.DeclaringType);
						if (typeDef == null)
							continue;
						overrideDef = typeDef.FindMethod(overrideRef);
						if (overrideDef == null)
							continue;
					}
					if (overrideDef.VisibleParameterCount != method.VisibleParameterCount)
						continue;
					methods.Add(overrideDef);
				}
			}

			var argNames = new string[group.Methods[0].ParamDefs.Count];
			foreach (var method in methods) {
				var nameChecker = !method.Owner.HasModule ? null : method.Owner.Module.ObfuscatedFile.NameChecker;
				for (int i = 0; i < argNames.Length; i++) {
					var argName = method.ParamDefs[i].ParameterDef.Name;
					if (nameChecker == null || nameChecker.IsValidMethodArgName(argName))
						argNames[i] = argName;
				}
			}
			return argNames;
		}

		class PrepareHelper {
			Dictionary<MTypeDef, bool> prepareMethodCalled = new Dictionary<MTypeDef, bool>();
			MemberInfos memberInfos;
			Action<TypeInfo> func;
			IEnumerable<MTypeDef> allTypes;

			public PrepareHelper(MemberInfos memberInfos, IEnumerable<MTypeDef> allTypes) {
				this.memberInfos = memberInfos;
				this.allTypes = allTypes;
			}

			public void Prepare(Action<TypeInfo> func) {
				this.func = func;
				prepareMethodCalled.Clear();
				foreach (var typeDef in allTypes)
					Prepare(typeDef);
			}

			void Prepare(MTypeDef type) {
				if (prepareMethodCalled.ContainsKey(type))
					return;
				prepareMethodCalled[type] = true;

				foreach (var ifaceInfo in type.interfaces)
					Prepare(ifaceInfo.typeDef);
				if (type.baseType != null)
					Prepare(type.baseType.typeDef);

				if (memberInfos.TryGetType(type, out var info))
					func(info);
			}
		}

		static List<MethodNameGroup> GetSorted(MethodNameGroups groups) {
			var allGroups = new List<MethodNameGroup>(groups.GetAllGroups());
			allGroups.Sort((a, b) => b.Count.CompareTo(a.Count));
			return allGroups;
		}

		class GroupHelper {
			MemberInfos memberInfos;
			Dictionary<MTypeDef, bool> visited = new Dictionary<MTypeDef, bool>();
			Dictionary<MMethodDef, MethodNameGroup> methodToGroup;
			List<MethodNameGroup> groups = new List<MethodNameGroup>();
			IEnumerable<MTypeDef> allTypes;
			Action<MethodNameGroup> func;

			public GroupHelper(MemberInfos memberInfos, IEnumerable<MTypeDef> allTypes) {
				this.memberInfos = memberInfos;
				this.allTypes = allTypes;
			}

			public void Add(MethodNameGroup group) => groups.Add(group);

			public void VisitAll(Action<MethodNameGroup> func) {
				this.func = func;
				visited.Clear();

				methodToGroup = new Dictionary<MMethodDef, MethodNameGroup>();
				foreach (var group in groups) {
					foreach (var method in group.Methods)
						methodToGroup[method] = group;
				}

				foreach (var type in allTypes)
					Visit(type);
			}

			void Visit(MTypeDef type) {
				if (visited.ContainsKey(type))
					return;
				visited[type] = true;

				if (type.baseType != null)
					Visit(type.baseType.typeDef);
				foreach (var ifaceInfo in type.interfaces)
					Visit(ifaceInfo.typeDef);

				if (!memberInfos.TryGetType(type, out var info))
					return;

				foreach (var method in type.AllMethodsSorted) {
					if (!methodToGroup.TryGetValue(method, out var group))
						continue;
					foreach (var m in group.Methods)
						methodToGroup.Remove(m);
					func(group);
				}
			}
		}

		static readonly Regex removeGenericsArityRegex = new Regex(@"`[0-9]+");
		static string GetOverridePrefix(MethodNameGroup group, MMethodDef method) {
			if (method == null || method.MethodDef.Overrides.Count == 0)
				return "";
			if (group.Methods.Count > 1) {
				// Don't use an override prefix if the group has an iface method.
				foreach (var m in group.Methods) {
					if (m.Owner.TypeDef.IsInterface)
						return "";
				}
			}
			var overrideMethod = method.MethodDef.Overrides[0].MethodDeclaration;
			if (overrideMethod.DeclaringType == null)
				return "";
			var name = overrideMethod.DeclaringType.FullName.Replace('/', '.');
			name = removeGenericsArityRegex.Replace(name, "");
			return name + ".";
		}

		static string GetRealName(string name) {
			int index = name.LastIndexOf('.');
			if (index < 0)
				return name;
			return name.Substring(index + 1);
		}

		void PrepareRenameEvent(MethodNameGroup group, bool renameOverrides) {
			var eventName = PrepareRenameEvent(group, renameOverrides, out string overridePrefix, out string methodPrefix);
			if (eventName == null)
				return;

			var methodName = overridePrefix + methodPrefix + eventName;
			foreach (var method in group.Methods)
				memberInfos.Method(method).Rename(methodName);
		}

		string PrepareRenameEvent(MethodNameGroup group, bool renameOverrides, out string overridePrefix, out string methodPrefix) {
			var eventMethod = GetEventMethod(group);
			if (eventMethod == null)
				throw new ApplicationException("No events found");

			var eventDef = eventMethod.Event;
			if (eventMethod == eventDef.AddMethod)
				methodPrefix = "add_";
			else if (eventMethod == eventDef.RemoveMethod)
				methodPrefix = "remove_";
			else if (eventMethod == eventDef.RaiseMethod)
				methodPrefix = "raise_";
			else
				methodPrefix = "";

			overridePrefix = GetOverridePrefix(group, eventMethod);
			if (renameOverrides && overridePrefix == "")
				return null;
			if (!renameOverrides && overridePrefix != "")
				return null;

			string newEventName, oldEventName;
			var eventInfo = memberInfos.Event(eventDef);

			bool mustUseOldEventName = false;
			if (overridePrefix == "")
				oldEventName = eventInfo.oldName;
			else {
				var overriddenEventDef = GetOverriddenEvent(eventMethod);
				if (overriddenEventDef == null)
					oldEventName = GetRealName(eventInfo.oldName);
				else {
					mustUseOldEventName = true;
					if (memberInfos.TryGetEvent(overriddenEventDef, out var info))
						oldEventName = GetRealName(info.newName);
					else
						oldEventName = GetRealName(overriddenEventDef.EventDef.Name.String);
				}
			}

			if (eventInfo.renamed)
				newEventName = GetRealName(eventInfo.newName);
			else if (mustUseOldEventName || eventDef.Owner.Module.ObfuscatedFile.NameChecker.IsValidEventName(oldEventName))
				newEventName = oldEventName;
			else {
				mergeStateHelper.Merge(MergeStateFlags.Events, group);
				newEventName = GetAvailableName("Event_", false, group, (group2, newName) => IsEventAvailable(group2, newName));
			}

			var newEventNameWithPrefix = overridePrefix + newEventName;
			foreach (var method in group.Methods) {
				if (method.Event != null) {
					memberInfos.Event(method.Event).Rename(newEventNameWithPrefix);
					var ownerInfo = memberInfos.Type(method.Owner);
					ownerInfo.variableNameState.AddEventName(newEventName);
					ownerInfo.variableNameState.AddEventName(newEventNameWithPrefix);
				}
			}

			return newEventName;
		}

		MEventDef GetOverriddenEvent(MMethodDef overrideMethod) => GetOverriddenEvent(overrideMethod, out var overriddenMethod);

		MEventDef GetOverriddenEvent(MMethodDef overrideMethod, out MMethodDef overriddenMethod) {
			var theMethod = overrideMethod.MethodDef.Overrides[0].MethodDeclaration;
			overriddenMethod = modules.ResolveMethod(theMethod);
			if (overriddenMethod != null)
				return overriddenMethod.Event;

			var extType = theMethod.DeclaringType;
			if (extType == null)
				return null;
			var extTypeDef = modules.ResolveOther(extType);
			if (extTypeDef == null)
				return null;
			overriddenMethod = extTypeDef.FindMethod(theMethod);
			if (overriddenMethod != null)
				return overriddenMethod.Event;

			return null;
		}

		MMethodDef GetEventMethod(MethodNameGroup group) {
			foreach (var method in group.Methods) {
				if (method.Event != null)
					return method;
			}
			return null;
		}

		void PrepareRenameProperty(MethodNameGroup group, bool renameOverrides) {
			var propName = PrepareRenameProperty(group, renameOverrides, out string overridePrefix);
			if (propName == null)
				return;

			string methodPrefix;
			switch (GetPropertyMethodType(group.Methods[0])) {
			case PropertyMethodType.Getter:
				methodPrefix = "get_";
				break;
			case PropertyMethodType.Setter:
				methodPrefix = "set_";
				break;
			default:
				throw new ApplicationException("Invalid property type");
			}

			var methodName = overridePrefix + methodPrefix + propName;
			foreach (var method in group.Methods)
				memberInfos.Method(method).Rename(methodName);
		}

		string PrepareRenameProperty(MethodNameGroup group, bool renameOverrides, out string overridePrefix) {
			var propMethod = GetPropertyMethod(group);
			if (propMethod == null)
				throw new ApplicationException("No properties found");

			overridePrefix = GetOverridePrefix(group, propMethod);

			if (renameOverrides && overridePrefix == "")
				return null;
			if (!renameOverrides && overridePrefix != "")
				return null;

			string newPropName, oldPropName;
			var propDef = propMethod.Property;
			var propInfo = memberInfos.Property(propDef);

			bool mustUseOldPropName = false;
			if (overridePrefix == "")
				oldPropName = propInfo.oldName;
			else {
				var overriddenPropDef = GetOverriddenProperty(propMethod);
				if (overriddenPropDef == null)
					oldPropName = GetRealName(propInfo.oldName);
				else {
					mustUseOldPropName = true;
					if (memberInfos.TryGetProperty(overriddenPropDef, out var info))
						oldPropName = GetRealName(info.newName);
					else
						oldPropName = GetRealName(overriddenPropDef.PropertyDef.Name.String);
				}
			}

			if (propInfo.renamed)
				newPropName = GetRealName(propInfo.newName);
			else if (mustUseOldPropName || propDef.Owner.Module.ObfuscatedFile.NameChecker.IsValidPropertyName(oldPropName))
				newPropName = oldPropName;
			else if (IsItemProperty(group))
				newPropName = "Item";
			else {
				bool trySameName = true;
				var propPrefix = GetSuggestedPropertyName(group);
				if (propPrefix == null) {
					trySameName = false;
					propPrefix = GetNewPropertyNamePrefix(group);
				}
				mergeStateHelper.Merge(MergeStateFlags.Properties, group);
				newPropName = GetAvailableName(propPrefix, trySameName, group, (group2, newName) => IsPropertyAvailable(group2, newName));
			}

			var newPropNameWithPrefix = overridePrefix + newPropName;
			foreach (var method in group.Methods) {
				if (method.Property != null) {
					memberInfos.Property(method.Property).Rename(newPropNameWithPrefix);
					var ownerInfo = memberInfos.Type(method.Owner);
					ownerInfo.variableNameState.AddPropertyName(newPropName);
					ownerInfo.variableNameState.AddPropertyName(newPropNameWithPrefix);
				}
			}

			return newPropName;
		}

		bool IsItemProperty(MethodNameGroup group) {
			foreach (var method in group.Methods) {
				if (method.Property != null && method.Property.IsItemProperty())
					return true;
			}
			return false;
		}

		MPropertyDef GetOverriddenProperty(MMethodDef overrideMethod) {
			var theMethod = overrideMethod.MethodDef.Overrides[0].MethodDeclaration;
			var overriddenMethod = modules.ResolveMethod(theMethod);
			if (overriddenMethod != null)
				return overriddenMethod.Property;

			var extType = theMethod.DeclaringType;
			if (extType == null)
				return null;
			var extTypeDef = modules.ResolveOther(extType);
			if (extTypeDef == null)
				return null;
			var theMethodDef = extTypeDef.FindMethod(theMethod);
			if (theMethodDef != null)
				return theMethodDef.Property;

			return null;
		}

		MMethodDef GetPropertyMethod(MethodNameGroup group) {
			foreach (var method in group.Methods) {
				if (method.Property != null)
					return method;
			}
			return null;
		}

		string GetSuggestedPropertyName(MethodNameGroup group) {
			foreach (var method in group.Methods) {
				if (method.Property == null)
					continue;
				var info = memberInfos.Property(method.Property);
				if (info.suggestedName != null)
					return info.suggestedName;
			}
			return null;
		}

		internal static ITypeDefOrRef GetScopeType(TypeSig typeSig) {
			if (typeSig == null)
				return null;
			var scopeType = typeSig.ScopeType;
			if (scopeType != null)
				return scopeType;

			for (int i = 0; i < 100; i++) {
				var nls = typeSig as NonLeafSig;
				if (nls == null)
					break;
				typeSig = nls.Next;
			}

			switch (typeSig.GetElementType()) {
			case ElementType.MVar:
			case ElementType.Var:
				return new TypeSpecUser(typeSig);
			default:
				return null;
			}
		}

		string GetNewPropertyNamePrefix(MethodNameGroup group) {
			const string defaultVal = "Prop_";

			var propType = GetPropertyType(group);
			if (propType == null)
				return defaultVal;

			var elementType = GetScopeType(propType).ToTypeSig(false).RemovePinnedAndModifiers();
			if (propType is GenericInstSig || elementType is GenericSig)
				return defaultVal;

			var prefix = GetPrefix(propType);

			string name = elementType.TypeName;
			int i;
			if ((i = name.IndexOf('`')) >= 0)
				name = name.Substring(0, i);
			if ((i = name.LastIndexOf('.')) >= 0)
				name = name.Substring(i + 1);
			if (name == "")
				return defaultVal;

			return prefix.ToUpperInvariant() + UpperFirst(name) + "_";
		}

		static string UpperFirst(string s) => s.Substring(0, 1).ToUpperInvariant() + s.Substring(1);

		static string GetPrefix(TypeSig typeRef) {
			string prefix = "";
			typeRef = typeRef.RemovePinnedAndModifiers();
			while (typeRef is PtrSig) {
				typeRef = typeRef.Next;
				prefix += "p";
			}
			return prefix;
		}

		enum PropertyMethodType {
			Other,
			Getter,
			Setter,
		}

		static PropertyMethodType GetPropertyMethodType(MMethodDef method) {
			if (DotNetUtils.HasReturnValue(method.MethodDef))
				return PropertyMethodType.Getter;
			if (method.VisibleParameterCount > 0)
				return PropertyMethodType.Setter;
			return PropertyMethodType.Other;
		}

		// Returns property type, or null if not all methods have the same type
		TypeSig GetPropertyType(MethodNameGroup group) {
			var methodType = GetPropertyMethodType(group.Methods[0]);
			if (methodType == PropertyMethodType.Other)
				return null;

			TypeSig type = null;
			foreach (var propMethod in group.Methods) {
				TypeSig propType;
				if (methodType == PropertyMethodType.Setter)
					propType = propMethod.ParamDefs[propMethod.ParamDefs.Count - 1].ParameterDef.Type;
				else
					propType = propMethod.MethodDef.MethodSig.GetRetType();
				if (type == null)
					type = propType;
				else if (!new SigComparer().Equals(type, propType))
					return null;
			}
			return type;
		}

		MMethodDef GetOverrideMethod(MethodNameGroup group) {
			foreach (var method in group.Methods) {
				if (method.MethodDef.Overrides.Count > 0)
					return method;
			}
			return null;
		}

		void PrepareRenameVirtualMethods(MethodNameGroup group, string namePrefix, bool renameOverrides) {
			if (!HasInvalidMethodName(group))
				return;

			if (HasDelegateOwner(group)) {
				switch (group.Methods[0].MethodDef.Name.String) {
				case "Invoke":
				case "BeginInvoke":
				case "EndInvoke":
					return;
				}
			}

			var overrideMethod = GetOverrideMethod(group);
			var overridePrefix = GetOverridePrefix(group, overrideMethod);
			if (renameOverrides && overridePrefix == "")
				return;
			if (!renameOverrides && overridePrefix != "")
				return;

			string newMethodName;
			if (overridePrefix != "") {
				/*var overrideInfo =*/ memberInfos.Method(overrideMethod);
				var overriddenMethod = GetOverriddenMethod(overrideMethod);
				if (overriddenMethod == null)
					newMethodName = GetRealName(overrideMethod.MethodDef.Overrides[0].MethodDeclaration.Name.String);
				else
					newMethodName = GetRealName(memberInfos.Method(overriddenMethod).newName);
			}
			else {
				newMethodName = GetSuggestedMethodName(group);
				if (newMethodName == null) {
					mergeStateHelper.Merge(MergeStateFlags.Methods, group);
					newMethodName = GetAvailableName(namePrefix, false, group, (group2, newName) => IsMethodAvailable(group2, newName));
				}
			}

			var newMethodNameWithPrefix = overridePrefix + newMethodName;
			foreach (var method in group.Methods)
				memberInfos.Type(method.Owner).RenameMethod(method, newMethodNameWithPrefix);
		}

		[Flags]
		enum MergeStateFlags {
			None = 0,
			Methods = 0x1,
			Properties = 0x2,
			Events = 0x4,
		}

		class MergeStateHelper {
			MemberInfos memberInfos;
			MergeStateFlags flags;
			Dictionary<MTypeDef, bool> visited = new Dictionary<MTypeDef, bool>();

			public MergeStateHelper(MemberInfos memberInfos) => this.memberInfos = memberInfos;

			public void Merge(MergeStateFlags flags, MethodNameGroup group) {
				this.flags = flags;
				visited.Clear();
				foreach (var method in group.Methods)
					Merge(method.Owner);
			}

			void Merge(MTypeDef type) {
				if (visited.ContainsKey(type))
					return;
				visited[type] = true;

				if (!memberInfos.TryGetType(type, out var info))
					return;

				if (type.baseType != null)
					Merge(type.baseType.typeDef);
				foreach (var ifaceInfo in type.interfaces)
					Merge(ifaceInfo.typeDef);

				if (type.baseType != null)
					Merge(info, type.baseType.typeDef);
				foreach (var ifaceInfo in type.interfaces)
					Merge(info, ifaceInfo.typeDef);
			}

			void Merge(TypeInfo info, MTypeDef other) {
				if (!memberInfos.TryGetType(other, out var otherInfo))
					return;

				if ((flags & MergeStateFlags.Methods) != MergeStateFlags.None)
					info.variableNameState.MergeMethods(otherInfo.variableNameState);
				if ((flags & MergeStateFlags.Properties) != MergeStateFlags.None)
					info.variableNameState.MergeProperties(otherInfo.variableNameState);
				if ((flags & MergeStateFlags.Events) != MergeStateFlags.None)
					info.variableNameState.MergeEvents(otherInfo.variableNameState);
			}
		}

		MMethodDef GetOverriddenMethod(MMethodDef overrideMethod) =>
			modules.ResolveMethod(overrideMethod.MethodDef.Overrides[0].MethodDeclaration);

		string GetSuggestedMethodName(MethodNameGroup group) {
			foreach (var method in group.Methods) {
				var info = memberInfos.Method(method);
				if (info.suggestedName != null)
					return info.suggestedName;
			}
			return null;
		}

		bool HasInvalidMethodName(MethodNameGroup group) {
			foreach (var method in group.Methods) {
				var typeInfo = memberInfos.Type(method.Owner);
				var methodInfo = memberInfos.Method(method);
				if (!typeInfo.NameChecker.IsValidMethodName(methodInfo.oldName))
					return true;
			}
			return false;
		}

		static string GetAvailableName(string prefix, bool tryWithoutZero, MethodNameGroup group, Func<MethodNameGroup, string, bool> checkAvailable) {
			for (int i = 0; ; i++) {
				string newName = i == 0 && tryWithoutZero ? prefix : prefix + i;
				if (checkAvailable(group, newName))
					return newName;
			}
		}

		bool IsMethodAvailable(MethodNameGroup group, string methodName) {
			foreach (var method in group.Methods) {
				if (memberInfos.Type(method.Owner).variableNameState.IsMethodNameUsed(methodName))
					return false;
			}
			return true;
		}

		bool IsPropertyAvailable(MethodNameGroup group, string methodName) {
			foreach (var method in group.Methods) {
				if (memberInfos.Type(method.Owner).variableNameState.IsPropertyNameUsed(methodName))
					return false;
			}
			return true;
		}

		bool IsEventAvailable(MethodNameGroup group, string methodName) {
			foreach (var method in group.Methods) {
				if (memberInfos.Type(method.Owner).variableNameState.IsEventNameUsed(methodName))
					return false;
			}
			return true;
		}

		bool HasDelegateOwner(MethodNameGroup group) {
			foreach (var method in group.Methods) {
				if (isDelegateClass.Check(method.Owner))
					return true;
			}
			return false;
		}

		void PrepareRenameEntryPoints() {
			foreach (var module in modules.TheModules) {
				var entryPoint = module.ModuleDefMD.EntryPoint;
				if (entryPoint == null)
					continue;
				var methodDef = modules.ResolveMethod(entryPoint);
				if (methodDef == null) {
					Logger.w($"Could not find entry point. Module: {module.ModuleDefMD.Location}, Method: {Utils.RemoveNewlines(entryPoint)}");
					continue;
				}
				if (!methodDef.IsStatic())
					continue;
				memberInfos.Method(methodDef).suggestedName = "Main";
				if (methodDef.ParamDefs.Count == 1) {
					var paramDef = methodDef.ParamDefs[0];
					var type = paramDef.ParameterDef.Type;
					if (type.FullName == "System.String[]")
						memberInfos.Param(paramDef).newName = "args";
				}
			}
		}
	}
}



================================================
File: de4dot.code/renamer/ResourceKeysRenamer.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;
using dnlib.DotNet.Resources;

namespace de4dot.code.renamer {
	public class ResourceKeysRenamer {
		const int RESOURCE_KEY_MAX_LEN = 50;
		const string DEFAULT_KEY_NAME = "Key";

		ModuleDefMD module;
		INameChecker nameChecker;
		Dictionary<string, bool> newNames = new Dictionary<string, bool>();

		public ResourceKeysRenamer(ModuleDefMD module, INameChecker nameChecker) {
			this.module = module;
			this.nameChecker = nameChecker;
		}

		public void Rename() {
			Logger.v("Renaming resource keys ({0})", module);
			Logger.Instance.Indent();
			foreach (var type in module.GetTypes()) {
				string resourceName = GetResourceName(type);
				if (resourceName == null)
					continue;
				var resource = GetResource(resourceName);
				if (resource == null) {
					Logger.w("Could not find resource {0}", Utils.RemoveNewlines(resourceName));
					continue;
				}
				Logger.v("Resource: {0}", Utils.ToCsharpString(resource.Name));
				Logger.Instance.Indent();
				Rename(type, resource);
				Logger.Instance.DeIndent();
			}
			Logger.Instance.DeIndent();
		}

		EmbeddedResource GetResource(string resourceName) {
			if (DotNetUtils.GetResource(module, resourceName + ".resources") is EmbeddedResource resource)
				return resource;

			string name = "";
			var pieces = resourceName.Split('.');
			Array.Reverse(pieces);
			foreach (var piece in pieces) {
				name = piece + name;
				resource = DotNetUtils.GetResource(module, name + ".resources") as EmbeddedResource;
				if (resource != null)
					return resource;
			}
			return null;
		}

		static string GetResourceName(TypeDef type) {
			foreach (var method in type.Methods) {
				if (method.Body == null)
					continue;
				var instrs = method.Body.Instructions;
				string resourceName = null;
				for (int i = 0; i < instrs.Count; i++) {
					var instr = instrs[i];
					if (instr.OpCode.Code == Code.Ldstr) {
						resourceName = instr.Operand as string;
						continue;
					}

					if (instr.OpCode.Code == Code.Newobj) {
						var ctor = instr.Operand as IMethod;
						if (ctor.FullName != "System.Void System.Resources.ResourceManager::.ctor(System.String,System.Reflection.Assembly)")
							continue;
						if (resourceName == null) {
							Logger.w("Could not find resource name");
							continue;
						}

						return resourceName;
					}
				}
			}
			return null;
		}

		class RenameInfo {
			public readonly ResourceElement element;
			public string newName;
			public bool foundInCode;
			public RenameInfo(ResourceElement element, string newName) {
				this.element = element;
				this.newName = newName;
				foundInCode = false;
			}
			public override string ToString() => $"{element} => {newName}";
		}

		void Rename(TypeDef type, EmbeddedResource resource) {
			newNames.Clear();
			var resourceSet = ResourceReader.Read(module, resource.CreateReader());
			var renamed = new List<RenameInfo>();
			foreach (var elem in resourceSet.ResourceElements) {
				if (nameChecker.IsValidResourceKeyName(elem.Name)) {
					newNames.Add(elem.Name, true);
					continue;
				}

				renamed.Add(new RenameInfo(elem, GetNewName(elem)));
			}

			if (renamed.Count == 0)
				return;

			Rename(type, renamed);

			var outStream = new MemoryStream();
			ResourceWriter.Write(module, outStream, resourceSet);
			var newResource = new EmbeddedResource(resource.Name, outStream.ToArray(), resource.Attributes);
			int resourceIndex = module.Resources.IndexOf(resource);
			if (resourceIndex < 0)
				throw new ApplicationException("Could not find index of resource");
			module.Resources[resourceIndex] = newResource;
		}

		void Rename(TypeDef type, List<RenameInfo> renamed) {
			var nameToInfo = new Dictionary<string, RenameInfo>(StringComparer.Ordinal);
			foreach (var info in renamed)
				nameToInfo[info.element.Name] = info;

			foreach (var method in type.Methods) {
				if (method.Body == null)
					continue;

				var instrs = method.Body.Instructions;
				for (int i = 0; i < instrs.Count; i++) {
					var call = instrs[i];
					if (call.OpCode.Code != Code.Call && call.OpCode.Code != Code.Callvirt)
						continue;
					var calledMethod = call.Operand as IMethod;
					if (calledMethod == null)
						continue;

					int ldstrIndex;
					switch (calledMethod.FullName) {
					case "System.String System.Resources.ResourceManager::GetString(System.String,System.Globalization.CultureInfo)":
					case "System.IO.UnmanagedMemoryStream System.Resources.ResourceManager::GetStream(System.String,System.Globalization.CultureInfo)":
					case "System.Object System.Resources.ResourceManager::GetObject(System.String,System.Globalization.CultureInfo)":
						ldstrIndex = i - 2;
						break;

					case "System.String System.Resources.ResourceManager::GetString(System.String)":
					case "System.IO.UnmanagedMemoryStream System.Resources.ResourceManager::GetStream(System.String)":
					case "System.Object System.Resources.ResourceManager::GetObject(System.String)":
						ldstrIndex = i - 1;
						break;

					default:
						continue;
					}

					Instruction ldstr = null;
					string name = null;
					if (ldstrIndex >= 0)
						ldstr = instrs[ldstrIndex];
					if (ldstr == null || (name = ldstr.Operand as string) == null) {
						Logger.w("Could not find string argument to method {0}", calledMethod);
						continue;
					}

					if (!nameToInfo.TryGetValue(name, out var info))
						continue;   // should not be renamed

					ldstr.Operand = info.newName;
					Logger.v("Renamed resource key {0} => {1}", Utils.ToCsharpString(info.element.Name), Utils.ToCsharpString(info.newName));
					info.element.Name = info.newName;
					info.foundInCode = true;
				}
			}

			foreach (var info in renamed) {
				if (!info.foundInCode)
					Logger.w("Could not find resource key {0} in code", Utils.RemoveNewlines(info.element.Name));
			}
		}

		string GetNewName(ResourceElement elem) {
			if (elem.ResourceData.Code != ResourceTypeCode.String)
				return CreateDefaultName();
			var stringData = (BuiltInResourceData)elem.ResourceData;
			var name = CreatePrefixFromStringData((string)stringData.Data);
			return CreateName(counter => counter == 0 ? name : $"{name}_{counter}");
		}

		string CreatePrefixFromStringData(string data) {
			var sb = new StringBuilder();
			data = data.Substring(0, Math.Min(data.Length, 100));
			data = Regex.Replace(data, "[`'\"]", "");
			data = Regex.Replace(data, @"[^\w]+", " ");
			foreach (var piece in data.Split(' ')) {
				if (piece.Length == 0)
					continue;
				var piece2 = piece.Substring(0, 1).ToUpperInvariant() + piece.Substring(1).ToLowerInvariant();
				int maxLen = RESOURCE_KEY_MAX_LEN - sb.Length;
				if (maxLen <= 0)
					break;
				if (piece2.Length > maxLen)
					piece2 = piece2.Substring(0, maxLen);
				sb.Append(piece2);
			}
			if (sb.Length <= 3)
				return CreateDefaultName();
			return sb.ToString();
		}

		string CreateDefaultName() => CreateName(counter => $"{DEFAULT_KEY_NAME}{counter}");

		string CreateName(Func<int, string> create) {
			for (int counter = 0; ; counter++) {
				string newName = create(counter);
				if (!newNames.ContainsKey(newName)) {
					newNames[newName] = true;
					return newName;
				}
			}
		}
	}
}



================================================
File: de4dot.code/renamer/ResourceRenamer.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Text;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;
using de4dot.code.renamer.asmmodules;

namespace de4dot.code.renamer {
	public class ResourceRenamer {
		Module module;
		Dictionary<string, Resource> nameToResource;

		public ResourceRenamer(Module module) => this.module = module;

		public void Rename(List<TypeInfo> renamedTypes) {
			// Rename the longest names first. Otherwise eg. b.g.resources could be renamed
			// Class0.g.resources instead of Class1.resources when b.g was renamed Class1.
			renamedTypes.Sort((a, b) => {
				var aesc = EscapeTypeName(a.oldFullName);
				var besc = EscapeTypeName(b.oldFullName);
				if (besc.Length != aesc.Length)
					return besc.Length.CompareTo(aesc.Length);
				return besc.CompareTo(aesc);
			});

			nameToResource = new Dictionary<string, Resource>(module.ModuleDefMD.Resources.Count * 3, StringComparer.Ordinal);
			foreach (var resource in module.ModuleDefMD.Resources) {
				var name = resource.Name.String;
				nameToResource[name] = resource;
				if (name.EndsWith(".g.resources"))
					nameToResource[name.Substring(0, name.Length - 12)] = resource;
				int index = name.LastIndexOf('.');
				if (index > 0)
					nameToResource[name.Substring(0, index)] = resource;
			}

			RenameResourceNamesInCode(renamedTypes);
			RenameResources(renamedTypes);
		}

		void RenameResourceNamesInCode(List<TypeInfo> renamedTypes) {
			var oldNameToTypeInfo = new Dictionary<string, TypeInfo>(StringComparer.Ordinal);
			foreach (var info in renamedTypes)
				oldNameToTypeInfo[EscapeTypeName(info.oldFullName)] = info;

			foreach (var method in module.GetAllMethods()) {
				if (!method.HasBody)
					continue;
				var instrs = method.Body.Instructions;
				for (int i = 0; i < instrs.Count; i++) {
					var instr = instrs[i];
					if (instr.OpCode != OpCodes.Ldstr)
						continue;
					var codeString = (string)instr.Operand;
					if (string.IsNullOrEmpty(codeString))
						continue;

					if (!nameToResource.TryGetValue(codeString, out var resource))
						continue;

					if (!oldNameToTypeInfo.TryGetValue(codeString, out var typeInfo))
						continue;
					var newName = EscapeTypeName(typeInfo.type.TypeDef.FullName);

					bool renameCodeString = module.ObfuscatedFile.RenameResourcesInCode ||
											IsCallingResourceManagerCtor(instrs, i, typeInfo);
					if (!renameCodeString)
						Logger.v("Possible resource name in code: '{0}' => '{1}' in method {2}", Utils.RemoveNewlines(codeString), newName, Utils.RemoveNewlines(method));
					else {
						instr.Operand = newName;
						Logger.v("Renamed resource string in code: '{0}' => '{1}' ({2})", Utils.RemoveNewlines(codeString), newName, Utils.RemoveNewlines(method));
					}
				}
			}
		}

		static bool IsCallingResourceManagerCtor(IList<Instruction> instrs, int ldstrIndex, TypeInfo typeInfo) {
			try {
				int index = ldstrIndex + 1;

				var ldtoken = instrs[index++];
				if (ldtoken.OpCode.Code != Code.Ldtoken)
					return false;
				if (!new SigComparer().Equals(typeInfo.type.TypeDef, ldtoken.Operand as ITypeDefOrRef))
					return false;

				if (!CheckCalledMethod(instrs[index++], "System.Type", "(System.RuntimeTypeHandle)"))
					return false;
				if (!CheckCalledMethod(instrs[index++], "System.Reflection.Assembly", "()"))
					return false;

				var newobj = instrs[index++];
				if (newobj.OpCode.Code != Code.Newobj)
					return false;
				if (newobj.Operand.ToString() != "System.Void System.Resources.ResourceManager::.ctor(System.String,System.Reflection.Assembly)")
					return false;

				return true;
			}
			catch (ArgumentOutOfRangeException) {
				return false;
			}
			catch (IndexOutOfRangeException) {
				return false;
			}
		}

		static bool CheckCalledMethod(Instruction instr, string returnType, string parameters) {
			if (instr.OpCode.Code != Code.Call && instr.OpCode.Code != Code.Callvirt)
				return false;
			return DotNetUtils.IsMethod(instr.Operand as IMethod, returnType, parameters);
		}

		class RenameInfo {
			public Resource resource;
			public TypeInfo typeInfo;
			public string newResourceName;
			public RenameInfo(Resource resource, TypeInfo typeInfo, string newResourceName) {
				this.resource = resource;
				this.typeInfo = typeInfo;
				this.newResourceName = newResourceName;
			}
			public override string ToString() => $"{resource.Name} => {newResourceName}";
		}

		void RenameResources(List<TypeInfo> renamedTypes) {
			var newNames = new Dictionary<Resource, RenameInfo>();
			foreach (var info in renamedTypes) {
				var oldFullName = EscapeTypeName(info.oldFullName);
				if (!nameToResource.TryGetValue(oldFullName, out var resource))
					continue;
				if (newNames.ContainsKey(resource))
					continue;
				var newTypeName = EscapeTypeName(info.type.TypeDef.FullName);
				var newName = newTypeName + resource.Name.String.Substring(oldFullName.Length);
				newNames[resource] = new RenameInfo(resource, info, newName);

				Logger.v("Renamed resource in resources: {0} => {1}", Utils.RemoveNewlines(resource.Name), newName);
				resource.Name = newName;
			}
		}

		static bool IsReservedTypeNameChar(char c) {
			switch (c) {
			case ',':
			case '[':
			case ']':
			case '&':
			case '*':
			case '+':
			case '\\':
				return true;
			default:
				return false;
			}
		}

		static bool HasReservedTypeNameChar(string s) {
			foreach (var c in s) {
				if (IsReservedTypeNameChar(c))
					return true;
			}
			return false;
		}

		static string EscapeTypeName(string name) {
			if (!HasReservedTypeNameChar(name))
				return name;
			var sb = new StringBuilder();
			foreach (var c in name) {
				if (IsReservedTypeNameChar(c))
					sb.Append('\\');
				sb.Append(c);
			}
			return sb.ToString();
		}
	}
}



================================================
File: de4dot.code/renamer/TypeInfo.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.code.renamer.asmmodules;
using de4dot.blocks;

namespace de4dot.code.renamer {
	public class TypeInfo : MemberInfo {
		public string oldNamespace;
		public string newNamespace;
		public VariableNameState variableNameState = VariableNameState.Create();
		public MTypeDef type;
		MemberInfos memberInfos;

		public INameChecker NameChecker => type.Module.ObfuscatedFile.NameChecker;

		public TypeInfo(MTypeDef typeDef, MemberInfos memberInfos)
			: base(typeDef) {
			type = typeDef;
			this.memberInfos = memberInfos;
			oldNamespace = typeDef.TypeDef.Namespace.String;
		}

		bool IsWinFormsClass() => memberInfos.IsWinFormsClass(type);
		public PropertyInfo Property(MPropertyDef prop) => memberInfos.Property(prop);
		public EventInfo Event(MEventDef evt) => memberInfos.Event(evt);
		public FieldInfo Field(MFieldDef field) => memberInfos.Field(field);
		public MethodInfo Method(MMethodDef method) => memberInfos.Method(method);
		public GenericParamInfo GenericParam(MGenericParamDef gparam) => memberInfos.GenericParam(gparam);
		public ParamInfo Param(MParamDef param) => memberInfos.Param(param);

		TypeInfo GetBase() {
			if (type.baseType == null)
				return null;

			memberInfos.TryGetType(type.baseType.typeDef, out var baseInfo);
			return baseInfo;
		}

		bool IsModuleType() => type.TypeDef.IsGlobalModuleType;

		public void PrepareRenameTypes(TypeRenamerState state) {
			var checker = NameChecker;

			if (newNamespace == null && oldNamespace != "") {
				if (type.TypeDef.IsNested)
					newNamespace = "";
				else if (!checker.IsValidNamespaceName(oldNamespace))
					newNamespace = state.CreateNamespace(type.TypeDef, oldNamespace);
			}

			string origClassName = null;
			if (IsWinFormsClass())
				origClassName = FindWindowsFormsClassName(type);
			if (IsModuleType()) {
				if (oldNamespace != "")
					newNamespace = "";
				Rename("<Module>");
			}
			else if (!checker.IsValidTypeName(oldName)) {
				if (origClassName != null && checker.IsValidTypeName(origClassName))
					Rename(state.GetTypeName(oldName, origClassName));
				else {
					var nameCreator = type.IsGlobalType() ?
											state.globalTypeNameCreator :
											state.internalTypeNameCreator;
					string newBaseType = null;
					var baseInfo = GetBase();
					if (baseInfo != null && baseInfo.renamed)
						newBaseType = baseInfo.newName;
					Rename(nameCreator.Create(type.TypeDef, newBaseType));
				}
			}

			PrepareRenameGenericParams(type.GenericParams, checker);
		}

		public void MergeState() {
			foreach (var ifaceInfo in type.interfaces)
				MergeState(ifaceInfo.typeDef);
			if (type.baseType != null)
				MergeState(type.baseType.typeDef);
		}

		void MergeState(MTypeDef other) {
			if (other == null)
				return;
			if (!memberInfos.TryGetType(other, out var otherInfo))
				return;
			variableNameState.Merge(otherInfo.variableNameState);
		}

		public void PrepareRenameMembers() {
			MergeState();

			foreach (var fieldDef in type.AllFields)
				variableNameState.AddFieldName(Field(fieldDef).oldName);
			foreach (var eventDef in type.AllEvents)
				variableNameState.AddEventName(Event(eventDef).oldName);
			foreach (var propDef in type.AllProperties)
				variableNameState.AddPropertyName(Property(propDef).oldName);
			foreach (var methodDef in type.AllMethods)
				variableNameState.AddMethodName(Method(methodDef).oldName);

			if (IsWinFormsClass())
				InitializeWindowsFormsFieldsAndProps();

			PrepareRenameFields();
		}

		public void PrepareRenamePropsAndEvents() {
			MergeState();
			PrepareRenameProperties();
			PrepareRenameEvents();
		}

		void PrepareRenameFields() {
			var checker = NameChecker;

			if (type.TypeDef.IsEnum) {
				var instanceFields = GetInstanceFields();
				if (instanceFields.Count == 1)
					Field(instanceFields[0]).Rename("value__");

				int i = 0;
				string nameFormat = HasFlagsAttribute() ? "flag_{0}" : "const_{0}";
				foreach (var fieldDef in type.AllFieldsSorted) {
					var fieldInfo = Field(fieldDef);
					if (fieldInfo.renamed)
						continue;
					if (!fieldDef.FieldDef.IsStatic || !fieldDef.FieldDef.IsLiteral)
						continue;
					if (!checker.IsValidFieldName(fieldInfo.oldName))
						fieldInfo.Rename(string.Format(nameFormat, i));
					i++;
				}
			}
			foreach (var fieldDef in type.AllFieldsSorted) {
				var fieldInfo = Field(fieldDef);
				if (fieldInfo.renamed)
					continue;
				if (!checker.IsValidFieldName(fieldInfo.oldName))
					fieldInfo.Rename(fieldInfo.suggestedName ?? variableNameState.GetNewFieldName(fieldDef.FieldDef));
			}
		}

		List<MFieldDef> GetInstanceFields() {
			var fields = new List<MFieldDef>();
			foreach (var fieldDef in type.AllFields) {
				if (!fieldDef.FieldDef.IsStatic)
					fields.Add(fieldDef);
			}
			return fields;
		}

		bool HasFlagsAttribute() {
			foreach (var attr in type.TypeDef.CustomAttributes) {
				if (attr.AttributeType.FullName == "System.FlagsAttribute")
					return true;
			}
			return false;
		}

		void PrepareRenameProperties() {
			foreach (var propDef in type.AllPropertiesSorted) {
				if (propDef.IsVirtual())
					continue;
				PrepareRenameProperty(propDef);
			}
		}

		void PrepareRenameProperty(MPropertyDef propDef) {
			if (propDef.IsVirtual())
				throw new ApplicationException("Can't rename virtual props here");
			var propInfo = Property(propDef);
			if (propInfo.renamed)
				return;

			string propName = propInfo.oldName;
			if (!NameChecker.IsValidPropertyName(propName))
				propName = propInfo.suggestedName;
			if (!NameChecker.IsValidPropertyName(propName)) {
				if (propDef.IsItemProperty())
					propName = "Item";
				else
					propName = variableNameState.GetNewPropertyName(propDef.PropertyDef);
			}
			variableNameState.AddPropertyName(propName);
			propInfo.Rename(propName);

			RenameSpecialMethod(propDef.GetMethod, "get_" + propName);
			RenameSpecialMethod(propDef.SetMethod, "set_" + propName);
		}

		void PrepareRenameEvents() {
			foreach (var eventDef in type.AllEventsSorted) {
				if (eventDef.IsVirtual())
					continue;
				PrepareRenameEvent(eventDef);
			}
		}

		void PrepareRenameEvent(MEventDef eventDef) {
			if (eventDef.IsVirtual())
				throw new ApplicationException("Can't rename virtual events here");
			var eventInfo = Event(eventDef);
			if (eventInfo.renamed)
				return;

			string eventName = eventInfo.oldName;
			if (!NameChecker.IsValidEventName(eventName))
				eventName = eventInfo.suggestedName;
			if (!NameChecker.IsValidEventName(eventName))
				eventName = variableNameState.GetNewEventName(eventDef.EventDef);
			variableNameState.AddEventName(eventName);
			eventInfo.Rename(eventName);

			RenameSpecialMethod(eventDef.AddMethod, "add_" + eventName);
			RenameSpecialMethod(eventDef.RemoveMethod, "remove_" + eventName);
			RenameSpecialMethod(eventDef.RaiseMethod, "raise_" + eventName);
		}

		void RenameSpecialMethod(MMethodDef methodDef, string newName) {
			if (methodDef == null)
				return;
			if (methodDef.IsVirtual())
				return;
			RenameMethod(methodDef, newName);
		}

		public void PrepareRenameMethods() {
			MergeState();
			foreach (var methodDef in type.AllMethodsSorted) {
				if (methodDef.IsVirtual())
					continue;
				RenameMethod(methodDef);
			}
		}

		public void PrepareRenameMethods2() {
			var checker = NameChecker;
			foreach (var methodDef in type.AllMethodsSorted) {
				PrepareRenameMethodArgs(methodDef);
				PrepareRenameGenericParams(methodDef.GenericParams, checker, methodDef.Owner?.GenericParams);
			}
		}

		void PrepareRenameMethodArgs(MMethodDef methodDef) {
			VariableNameState newVariableNameState = null;
			ParamInfo info;
			if (methodDef.VisibleParameterCount > 0) {
				if (IsEventHandler(methodDef)) {
					info = Param(methodDef.ParamDefs[methodDef.VisibleParameterBaseIndex]);
					if (!info.GotNewName())
						info.newName = "sender";

					info = Param(methodDef.ParamDefs[methodDef.VisibleParameterBaseIndex + 1]);
					if (!info.GotNewName())
						info.newName = "e";
				}
				else {
					newVariableNameState = variableNameState.CloneParamsOnly();
					var checker = NameChecker;
					foreach (var paramDef in methodDef.ParamDefs) {
						if (paramDef.IsHiddenThisParameter)
							continue;
						info = Param(paramDef);
						if (info.GotNewName())
							continue;
						if (!checker.IsValidMethodArgName(info.oldName))
							info.newName = newVariableNameState.GetNewParamName(info.oldName, paramDef.ParameterDef);
					}
				}
			}

			info = Param(methodDef.ReturnParamDef);
			if (!info.GotNewName()) {
				if (!NameChecker.IsValidMethodReturnArgName(info.oldName)) {
					if (newVariableNameState == null)
						newVariableNameState = variableNameState.CloneParamsOnly();
					info.newName = newVariableNameState.GetNewParamName(info.oldName, methodDef.ReturnParamDef.ParameterDef);
				}
			}

			if ((methodDef.Property != null && methodDef == methodDef.Property.SetMethod) ||
				(methodDef.Event != null && (methodDef == methodDef.Event.AddMethod || methodDef == methodDef.Event.RemoveMethod))) {
				if (methodDef.VisibleParameterCount > 0) {
					var paramDef = methodDef.ParamDefs[methodDef.ParamDefs.Count - 1];
					Param(paramDef).newName = "value";
				}
			}
		}

		bool CanRenameMethod(MMethodDef methodDef) {
			var methodInfo = Method(methodDef);
			if (methodDef.IsStatic()) {
				if (methodInfo.oldName == ".cctor")
					return false;
			}
			else if (methodDef.IsVirtual()) {
				if (DotNetUtils.DerivesFromDelegate(type.TypeDef)) {
					switch (methodInfo.oldName) {
					case "BeginInvoke":
					case "EndInvoke":
					case "Invoke":
						return false;
					}
				}
			}
			else {
				if (methodInfo.oldName == ".ctor")
					return false;
			}
			return true;
		}

		public void RenameMethod(MMethodDef methodDef, string methodName) {
			if (!CanRenameMethod(methodDef))
				return;
			var methodInfo = Method(methodDef);
			variableNameState.AddMethodName(methodName);
			methodInfo.Rename(methodName);
		}

		void RenameMethod(MMethodDef methodDef) {
			if (methodDef.IsVirtual())
				throw new ApplicationException("Can't rename virtual methods here");
			if (!CanRenameMethod(methodDef))
				return;

			var info = Method(methodDef);
			if (info.renamed)
				return;
			info.renamed = true;
			var checker = NameChecker;

			// PInvoke methods' EntryPoint is always valid. It has to, so always rename.
			bool isValidName = NameChecker.IsValidMethodName(info.oldName);
			bool isExternPInvoke = methodDef.MethodDef.ImplMap != null && methodDef.MethodDef.RVA == 0;
			if (!isValidName || isExternPInvoke) {
				INameCreator nameCreator = null;
				string newName = info.suggestedName;
				string newName2;
				if (methodDef.MethodDef.ImplMap != null && !string.IsNullOrEmpty(newName2 = GetPinvokeName(methodDef)))
					newName = newName2;
				else if (methodDef.IsStatic())
					nameCreator = variableNameState.staticMethodNameCreator;
				else
					nameCreator = variableNameState.instanceMethodNameCreator;
				if (!string.IsNullOrEmpty(newName))
					nameCreator = new NameCreator2(newName);
				RenameMethod(methodDef, variableNameState.GetNewMethodName(info.oldName, nameCreator));
			}
		}

		string GetPinvokeName(MMethodDef methodDef) {
			var entryPoint = methodDef.MethodDef.ImplMap.Name.String;
			if (Regex.IsMatch(entryPoint, @"^#\d+$"))
				entryPoint = DotNetUtils.GetDllName(methodDef.MethodDef.ImplMap.Module.Name.String) + "_" + entryPoint.Substring(1);
			return entryPoint;
		}

		static bool IsEventHandler(MMethodDef methodDef) {
			var sig = methodDef.MethodDef.MethodSig;
			if (sig == null || sig.Params.Count != 2)
				return false;
			if (sig.RetType.ElementType != ElementType.Void)
				return false;
			if (sig.Params[0].ElementType != ElementType.Object)
				return false;
			if (!sig.Params[1].FullName.Contains("EventArgs"))
				return false;
			return true;
		}

		void PrepareRenameGenericParams(IEnumerable<MGenericParamDef> genericParams, INameChecker checker) =>
			PrepareRenameGenericParams(genericParams, checker, null);

		void PrepareRenameGenericParams(IEnumerable<MGenericParamDef> genericParams, INameChecker checker, IEnumerable<MGenericParamDef> otherGenericParams) {
			var usedNames = new Dictionary<string, bool>(StringComparer.Ordinal);
			var nameCreator = new GenericParamNameCreator();

			if (otherGenericParams != null) {
				foreach (var param in otherGenericParams) {
					var gpInfo = memberInfos.GenericParam(param);
					usedNames[gpInfo.newName] = true;
				}
			}

			foreach (var param in genericParams) {
				var gpInfo = memberInfos.GenericParam(param);
				if (!checker.IsValidGenericParamName(gpInfo.oldName) || usedNames.ContainsKey(gpInfo.oldName)) {
					string newName;
					do {
						newName = nameCreator.Create();
					} while (usedNames.ContainsKey(newName));
					usedNames[newName] = true;
					gpInfo.Rename(newName);
				}
			}
		}

		void InitializeWindowsFormsFieldsAndProps() {
			var checker = NameChecker;

			var ourFields = new FieldDefAndDeclaringTypeDict<MFieldDef>();
			foreach (var fieldDef in type.AllFields)
				ourFields.Add(fieldDef.FieldDef, fieldDef);
			var ourMethods = new MethodDefAndDeclaringTypeDict<MMethodDef>();
			foreach (var methodDef in type.AllMethods)
				ourMethods.Add(methodDef.MethodDef, methodDef);

			foreach (var methodDef in type.AllMethods) {
				if (methodDef.MethodDef.Body == null)
					continue;
				if (methodDef.MethodDef.IsStatic || methodDef.MethodDef.IsVirtual)
					continue;
				var instructions = methodDef.MethodDef.Body.Instructions;
				for (int i = 2; i < instructions.Count; i++) {
					var call = instructions[i];
					if (call.OpCode.Code != Code.Call && call.OpCode.Code != Code.Callvirt)
						continue;
					if (!IsWindowsFormsSetNameMethod(call.Operand as IMethod))
						continue;

					var ldstr = instructions[i - 1];
					if (ldstr.OpCode.Code != Code.Ldstr)
						continue;
					var fieldName = ldstr.Operand as string;
					if (fieldName == null || !checker.IsValidFieldName(fieldName))
						continue;

					var instr = instructions[i - 2];
					IField fieldRef = null;
					if (instr.OpCode.Code == Code.Call || instr.OpCode.Code == Code.Callvirt) {
						var calledMethod = instr.Operand as IMethod;
						if (calledMethod == null)
							continue;
						var calledMethodDef = ourMethods.Find(calledMethod);
						if (calledMethodDef == null)
							continue;
						fieldRef = GetFieldRef(calledMethodDef.MethodDef);

						var propDef = calledMethodDef.Property;
						if (propDef == null)
							continue;

						memberInfos.Property(propDef).suggestedName = fieldName;
						fieldName = "_" + fieldName;
					}
					else if (instr.OpCode.Code == Code.Ldfld) {
						fieldRef = instr.Operand as IField;
					}

					if (fieldRef == null)
						continue;
					var fieldDef = ourFields.Find(fieldRef);
					if (fieldDef == null)
						continue;
					var fieldInfo = memberInfos.Field(fieldDef);

					if (fieldInfo.renamed)
						continue;

					fieldInfo.suggestedName = variableNameState.GetNewFieldName(fieldInfo.oldName, new NameCreator2(fieldName));
				}
			}
		}

		static IField GetFieldRef(MethodDef method) {
			if (method == null || method.Body == null)
				return null;
			var instructions = method.Body.Instructions;
			int index = 0;
			var ldarg0 = DotNetUtils.GetInstruction(instructions, ref index);
			if (ldarg0 == null || ldarg0.GetParameterIndex() != 0)
				return null;
			var ldfld = DotNetUtils.GetInstruction(instructions, ref index);
			if (ldfld == null || ldfld.OpCode.Code != Code.Ldfld)
				return null;
			var ret = DotNetUtils.GetInstruction(instructions, ref index);
			if (ret == null)
				return null;
			if (ret.IsStloc()) {
				var local = ret.GetLocal(method.Body.Variables);
				ret = DotNetUtils.GetInstruction(instructions, ref index);
				if (ret == null || !ret.IsLdloc())
					return null;
				if (ret.GetLocal(method.Body.Variables) != local)
					return null;
				ret = DotNetUtils.GetInstruction(instructions, ref index);
			}
			if (ret == null || ret.OpCode.Code != Code.Ret)
				return null;
			return ldfld.Operand as IField;
		}

		public void InitializeEventHandlerNames() {
			var ourFields = new FieldDefAndDeclaringTypeDict<MFieldDef>();
			foreach (var fieldDef in type.AllFields)
				ourFields.Add(fieldDef.FieldDef, fieldDef);
			var ourMethods = new MethodDefAndDeclaringTypeDict<MMethodDef>();
			foreach (var methodDef in type.AllMethods)
				ourMethods.Add(methodDef.MethodDef, methodDef);

			InitVbEventHandlers(ourFields, ourMethods);
			InitFieldEventHandlers(ourFields, ourMethods);
			InitTypeEventHandlers(ourFields, ourMethods);
		}

		// VB initializes the handlers in the property setter, where it first removes the handler
		// from the previous control, and then adds the handler to the new control.
		void InitVbEventHandlers(FieldDefAndDeclaringTypeDict<MFieldDef> ourFields, MethodDefAndDeclaringTypeDict<MMethodDef> ourMethods) {
			var checker = NameChecker;

			foreach (var propDef in type.AllProperties) {
				var setterDef = propDef.SetMethod;
				if (setterDef == null)
					continue;

				var handler = GetVbHandler(setterDef.MethodDef, out string eventName);
				if (handler == null)
					continue;
				var handlerDef = ourMethods.Find(handler);
				if (handlerDef == null)
					continue;

				if (!checker.IsValidEventName(eventName))
					continue;

				memberInfos.Method(handlerDef).suggestedName = $"{memberInfos.Property(propDef).newName}_{eventName}";
			}
		}

		static IMethod GetVbHandler(MethodDef method, out string eventName) {
			eventName = null;
			if (method.Body == null)
				return null;
			var sig = method.MethodSig;
			if (sig == null)
				return null;
			if (sig.RetType.ElementType != ElementType.Void)
				return null;
			if (sig.Params.Count != 1)
				return null;
			if (method.Body.Variables.Count != 1)
				return null;
			if (!IsEventHandlerType(method.Body.Variables[0].Type))
				return null;

			var instructions = method.Body.Instructions;
			int index = 0;

			int newobjIndex = FindInstruction(instructions, index, Code.Newobj);
			if (newobjIndex == -1 || FindInstruction(instructions, newobjIndex + 1, Code.Newobj) != -1)
				return null;
			if (!IsEventHandlerCtor(instructions[newobjIndex].Operand as IMethod))
				return null;
			if (newobjIndex < 1)
				return null;
			var ldvirtftn = instructions[newobjIndex - 1];
			if (ldvirtftn.OpCode.Code != Code.Ldvirtftn && ldvirtftn.OpCode.Code != Code.Ldftn)
				return null;
			var handlerMethod = ldvirtftn.Operand as IMethod;
			if (handlerMethod == null)
				return null;
			if (!new SigComparer().Equals(method.DeclaringType, handlerMethod.DeclaringType))
				return null;
			index = newobjIndex;

			if (!FindEventCall(instructions, ref index, out var removeField, out var removeMethod))
				return null;
			if (!FindEventCall(instructions, ref index, out var addField, out var addMethod))
				return null;

			if (FindInstruction(instructions, index, Code.Callvirt) != -1)
				return null;
			if (!new SigComparer().Equals(addField, removeField))
				return null;
			if (!new SigComparer().Equals(method.DeclaringType, addField.DeclaringType))
				return null;
			if (!new SigComparer().Equals(addMethod.DeclaringType, removeMethod.DeclaringType))
				return null;
			if (!Utils.StartsWith(addMethod.Name.String, "add_", StringComparison.Ordinal))
				return null;
			if (!Utils.StartsWith(removeMethod.Name.String, "remove_", StringComparison.Ordinal))
				return null;
			eventName = addMethod.Name.String.Substring(4);
			if (eventName != removeMethod.Name.String.Substring(7))
				return null;
			if (eventName == "")
				return null;

			return handlerMethod;
		}

		static bool FindEventCall(IList<Instruction> instructions, ref int index, out IField field, out IMethod calledMethod) {
			field = null;
			calledMethod = null;

			int callvirt = FindInstruction(instructions, index, Code.Callvirt);
			if (callvirt < 2)
				return false;
			index = callvirt + 1;

			var ldloc = instructions[callvirt - 1];
			if (ldloc.OpCode.Code != Code.Ldloc_0)
				return false;

			var ldfld = instructions[callvirt - 2];
			if (ldfld.OpCode.Code != Code.Ldfld)
				return false;

			field = ldfld.Operand as IField;
			calledMethod = instructions[callvirt].Operand as IMethod;
			return field != null && calledMethod != null;
		}

		static int FindInstruction(IList<Instruction> instructions, int index, Code code) {
			for (int i = index; i < instructions.Count; i++) {
				if (instructions[i].OpCode.Code == code)
					return i;
			}
			return -1;
		}

		void InitFieldEventHandlers(FieldDefAndDeclaringTypeDict<MFieldDef> ourFields, MethodDefAndDeclaringTypeDict<MMethodDef> ourMethods) {
			var checker = NameChecker;

			foreach (var methodDef in type.AllMethods) {
				if (methodDef.MethodDef.Body == null)
					continue;
				if (methodDef.MethodDef.IsStatic)
					continue;
				var instructions = methodDef.MethodDef.Body.Instructions;
				for (int i = 0; i < instructions.Count - 6; i++) {
					// We're looking for this code pattern:
					//	ldarg.0
					//	ldfld field
					//	ldarg.0
					//	ldftn method / ldarg.0 + ldvirtftn
					//	newobj event_handler_ctor
					//	callvirt add_SomeEvent

					if (instructions[i].GetParameterIndex() != 0)
						continue;
					int index = i + 1;

					var ldfld = instructions[index++];
					if (ldfld.OpCode.Code != Code.Ldfld)
						continue;
					var fieldRef = ldfld.Operand as IField;
					if (fieldRef == null)
						continue;
					var fieldDef = ourFields.Find(fieldRef);
					if (fieldDef == null)
						continue;

					if (instructions[index++].GetParameterIndex() != 0)
						continue;

					IMethod methodRef;
					var instr = instructions[index + 1];
					if (instr.OpCode.Code == Code.Ldvirtftn) {
						if (!IsThisOrDup(instructions[index++]))
							continue;
						var ldvirtftn = instructions[index++];
						methodRef = ldvirtftn.Operand as IMethod;
					}
					else {
						var ldftn = instructions[index++];
						if (ldftn.OpCode.Code != Code.Ldftn)
							continue;
						methodRef = ldftn.Operand as IMethod;
					}
					if (methodRef == null)
						continue;
					var handlerMethod = ourMethods.Find(methodRef);
					if (handlerMethod == null)
						continue;

					var newobj = instructions[index++];
					if (newobj.OpCode.Code != Code.Newobj)
						continue;
					if (!IsEventHandlerCtor(newobj.Operand as IMethod))
						continue;

					var call = instructions[index++];
					if (call.OpCode.Code != Code.Call && call.OpCode.Code != Code.Callvirt)
						continue;
					var addHandler = call.Operand as IMethod;
					if (addHandler == null)
						continue;
					if (!Utils.StartsWith(addHandler.Name.String, "add_", StringComparison.Ordinal))
						continue;

					var eventName = addHandler.Name.String.Substring(4);
					if (!checker.IsValidEventName(eventName))
						continue;

					memberInfos.Method(handlerMethod).suggestedName = $"{memberInfos.Field(fieldDef).newName}_{eventName}";
				}
			}
		}

		void InitTypeEventHandlers(FieldDefAndDeclaringTypeDict<MFieldDef> ourFields, MethodDefAndDeclaringTypeDict<MMethodDef> ourMethods) {
			var checker = NameChecker;

			foreach (var methodDef in type.AllMethods) {
				if (methodDef.MethodDef.Body == null)
					continue;
				if (methodDef.MethodDef.IsStatic)
					continue;
				var method = methodDef.MethodDef;
				var instructions = method.Body.Instructions;
				for (int i = 0; i < instructions.Count - 5; i++) {
					// ldarg.0
					// ldarg.0 / dup
					// ldarg.0 / dup
					// ldvirtftn handler
					// newobj event handler ctor
					// call add_Xyz

					if (instructions[i].GetParameterIndex() != 0)
						continue;
					int index = i + 1;

					if (!IsThisOrDup(instructions[index++]))
						continue;
					IMethod handler;
					if (instructions[index].OpCode.Code == Code.Ldftn) {
						handler = instructions[index++].Operand as IMethod;
					}
					else {
						if (!IsThisOrDup(instructions[index++]))
							continue;
						var instr = instructions[index++];
						if (instr.OpCode.Code != Code.Ldvirtftn)
							continue;
						handler = instr.Operand as IMethod;
					}
					if (handler == null)
						continue;
					var handlerDef = ourMethods.Find(handler);
					if (handlerDef == null)
						continue;

					var newobj = instructions[index++];
					if (newobj.OpCode.Code != Code.Newobj)
						continue;
					if (!IsEventHandlerCtor(newobj.Operand as IMethod))
						continue;

					var call = instructions[index++];
					if (call.OpCode.Code != Code.Call && call.OpCode.Code != Code.Callvirt)
						continue;
					var addMethod = call.Operand as IMethod;
					if (addMethod == null)
						continue;
					if (!Utils.StartsWith(addMethod.Name.String, "add_", StringComparison.Ordinal))
						continue;

					var eventName = addMethod.Name.String.Substring(4);
					if (!checker.IsValidEventName(eventName))
						continue;

					memberInfos.Method(handlerDef).suggestedName = $"{newName}_{eventName}";
				}
			}
		}

		static bool IsThisOrDup(Instruction instr) => instr.GetParameterIndex() == 0 || instr.OpCode.Code == Code.Dup;

		static bool IsEventHandlerCtor(IMethod method) {
			if (method == null)
				return false;
			if (method.Name != ".ctor")
				return false;
			if (!DotNetUtils.IsMethod(method, "System.Void", "(System.Object,System.IntPtr)"))
				return false;
			if (!IsEventHandlerType(method.DeclaringType))
				return false;
			return true;
		}

		static bool IsEventHandlerType(IType type) => type.FullName.EndsWith("EventHandler", StringComparison.Ordinal);

		string FindWindowsFormsClassName(MTypeDef type) {
			foreach (var methodDef in type.AllMethods) {
				if (methodDef.MethodDef.Body == null)
					continue;
				if (methodDef.MethodDef.IsStatic || methodDef.MethodDef.IsVirtual)
					continue;
				var instructions = methodDef.MethodDef.Body.Instructions;
				for (int i = 2; i < instructions.Count; i++) {
					var call = instructions[i];
					if (call.OpCode.Code != Code.Call && call.OpCode.Code != Code.Callvirt)
						continue;
					if (!IsWindowsFormsSetNameMethod(call.Operand as IMethod))
						continue;

					var ldstr = instructions[i - 1];
					if (ldstr.OpCode.Code != Code.Ldstr)
						continue;
					var className = ldstr.Operand as string;
					if (className == null)
						continue;

					if (instructions[i - 2].GetParameterIndex() != 0)
						continue;

					FindInitializeComponentMethod(type, methodDef);
					return className;
				}
			}
			return null;
		}

		void FindInitializeComponentMethod(MTypeDef type, MMethodDef possibleInitMethod) {
			foreach (var methodDef in type.AllMethods) {
				if (methodDef.MethodDef.Name != ".ctor")
					continue;
				if (methodDef.MethodDef.Body == null)
					continue;
				foreach (var instr in methodDef.MethodDef.Body.Instructions) {
					if (instr.OpCode.Code != Code.Call && instr.OpCode.Code != Code.Callvirt)
						continue;
					if (!MethodEqualityComparer.CompareDeclaringTypes.Equals(possibleInitMethod.MethodDef, instr.Operand as IMethod))
						continue;

					memberInfos.Method(possibleInitMethod).suggestedName = "InitializeComponent";
					return;
				}
			}
		}

		static bool IsWindowsFormsSetNameMethod(IMethod method) {
			if (method == null)
				return false;
			if (method.Name.String != "set_Name")
				return false;
			var sig = method.MethodSig;
			if (sig == null)
				return false;
			if (sig.RetType.ElementType != ElementType.Void)
				return false;
			if (sig.Params.Count != 1)
				return false;
			if (sig.Params[0].ElementType != ElementType.String)
				return false;
			return true;
		}
	}
}



================================================
File: de4dot.code/renamer/TypeNames.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet;

namespace de4dot.code.renamer {
	public abstract class TypeNames {
		protected Dictionary<string, NameCreator> typeNames = new Dictionary<string, NameCreator>(StringComparer.Ordinal);
		protected NameCreator genericParamNameCreator = new NameCreator("gparam_");
		protected NameCreator fnPtrNameCreator = new NameCreator("fnptr_");
		protected NameCreator unknownNameCreator = new NameCreator("unknown_");
		protected Dictionary<string, string> fullNameToShortName;
		protected Dictionary<string, string> fullNameToShortNamePrefix;

		public string Create(TypeSig typeRef) {
			typeRef = typeRef.RemovePinnedAndModifiers();
			if (typeRef == null)
				return unknownNameCreator.Create();
			if (typeRef is GenericInstSig gis) {
				if (gis.FullName == "System.Nullable`1" &&
					gis.GenericArguments.Count == 1 && gis.GenericArguments[0] != null) {
					typeRef = gis.GenericArguments[0];
				}
			}

			string prefix = GetPrefix(typeRef);

			var elementType = Renamer.GetScopeType(typeRef);
			if (elementType == null && IsFnPtrSig(typeRef))
				return fnPtrNameCreator.Create();
			if (IsGenericParam(elementType))
				return genericParamNameCreator.Create();

			var typeFullName = typeRef.FullName;
			if (typeNames.TryGetValue(typeFullName, out var nc))
				return nc.Create();

			var fullName = elementType == null ? typeRef.FullName : elementType.FullName;
			var dict = prefix == "" ? fullNameToShortName : fullNameToShortNamePrefix;
			if (!dict.TryGetValue(fullName, out string shortName)) {
				fullName = fullName.Replace('/', '.');
				int index = fullName.LastIndexOf('.');
				shortName = index > 0 ? fullName.Substring(index + 1) : fullName;

				index = shortName.LastIndexOf('`');
				if (index > 0)
					shortName = shortName.Substring(0, index);
			}

			return AddTypeName(typeFullName, shortName, prefix).Create();
		}

		bool IsFnPtrSig(TypeSig sig) {
			while (sig != null) {
				if (sig is FnPtrSig)
					return true;
				sig = sig.Next;
			}
			return false;
		}

		bool IsGenericParam(ITypeDefOrRef tdr) {
			var ts = tdr as TypeSpec;
			if (ts == null)
				return false;
			var sig = ts.TypeSig.RemovePinnedAndModifiers();
			return sig is GenericSig;
		}

		static string GetPrefix(TypeSig typeRef) {
			string prefix = "";
			while (typeRef != null) {
				if (typeRef.IsPointer)
					prefix += "p";
				typeRef = typeRef.Next;
			}
			return prefix;
		}

		protected INameCreator AddTypeName(string fullName, string newName, string prefix) {
			newName = FixName(prefix, newName);

			var name2 = " " + newName;
			if (!typeNames.TryGetValue(name2, out var nc))
				typeNames[name2] = nc = new NameCreator(newName + "_");

			typeNames[fullName] = nc;
			return nc;
		}

		protected abstract string FixName(string prefix, string name);

		public virtual TypeNames Merge(TypeNames other) {
			if (this == other)
				return this;
			foreach (var pair in other.typeNames) {
				if (typeNames.TryGetValue(pair.Key, out var nc))
					nc.Merge(pair.Value);
				else
					typeNames[pair.Key] = pair.Value.Clone();
			}
			genericParamNameCreator.Merge(other.genericParamNameCreator);
			fnPtrNameCreator.Merge(other.fnPtrNameCreator);
			unknownNameCreator.Merge(other.unknownNameCreator);
			return this;
		}

		protected static string UpperFirst(string s) {
			if (string.IsNullOrEmpty(s))
				return string.Empty;
			return s.Substring(0, 1).ToUpperInvariant() + s.Substring(1);
		}
	}

	public class VariableNameCreator : TypeNames {
		static Dictionary<string, string> ourFullNameToShortName;
		static Dictionary<string, string> ourFullNameToShortNamePrefix;
		static VariableNameCreator() {
			ourFullNameToShortName = new Dictionary<string, string>(StringComparer.Ordinal) {
				{ "System.Boolean", "bool" },
				{ "System.Byte", "byte" },
				{ "System.Char", "char" },
				{ "System.Double", "double" },
				{ "System.Int16", "short" },
				{ "System.Int32", "int" },
				{ "System.Int64", "long" },
				{ "System.IntPtr", "intptr" },
				{ "System.SByte", "sbyte" },
				{ "System.Single", "float" },
				{ "System.String", "string" },
				{ "System.UInt16", "ushort" },
				{ "System.UInt32", "uint" },
				{ "System.UInt64", "ulong" },
				{ "System.UIntPtr", "uintptr" },
				{ "System.Decimal", "decimal" },
			};
			ourFullNameToShortNamePrefix = new Dictionary<string, string>(StringComparer.Ordinal) {
				{ "System.Boolean", "Bool" },
				{ "System.Byte", "Byte" },
				{ "System.Char", "Char" },
				{ "System.Double", "Double" },
				{ "System.Int16", "Short" },
				{ "System.Int32", "Int" },
				{ "System.Int64", "Long" },
				{ "System.IntPtr", "IntPtr" },
				{ "System.SByte", "SByte" },
				{ "System.Single", "Float" },
				{ "System.String", "String" },
				{ "System.UInt16", "UShort" },
				{ "System.UInt32", "UInt" },
				{ "System.UInt64", "ULong" },
				{ "System.UIntPtr", "UIntPtr" },
				{ "System.Decimal", "Decimal" },
			};
		}

		public VariableNameCreator() {
			fullNameToShortName = ourFullNameToShortName;
			fullNameToShortNamePrefix = ourFullNameToShortNamePrefix;
		}

		static string LowerLeadingChars(string name) {
			var s = "";
			for (int i = 0; i < name.Length; i++) {
				char c = char.ToLowerInvariant(name[i]);
				if (c == name[i])
					return s + name.Substring(i);
				s += c;
			}
			return s;
		}

		protected override string FixName(string prefix, string name) {
			name = LowerLeadingChars(name);
			if (prefix == "")
				return name;
			return prefix + UpperFirst(name);
		}
	}

	public class PropertyNameCreator : TypeNames {
		static Dictionary<string, string> ourFullNameToShortName = new Dictionary<string, string>(StringComparer.Ordinal);
		static Dictionary<string, string> ourFullNameToShortNamePrefix = new Dictionary<string, string>(StringComparer.Ordinal);

		public PropertyNameCreator() {
			fullNameToShortName = ourFullNameToShortName;
			fullNameToShortNamePrefix = ourFullNameToShortNamePrefix;
		}

		protected override string FixName(string prefix, string name) => prefix.ToUpperInvariant() + UpperFirst(name);
	}
}



================================================
File: de4dot.code/renamer/TypeRenamerState.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet;

namespace de4dot.code.renamer {
	public class TypeRenamerState {
		ExistingNames existingNames;
		Dictionary<string, string> namespaceToNewName;
		NameCreator createNamespaceName;
		public ITypeNameCreator globalTypeNameCreator;
		public ITypeNameCreator internalTypeNameCreator;

		public TypeRenamerState() {
			existingNames = new ExistingNames();
			namespaceToNewName = new Dictionary<string, string>(StringComparer.Ordinal);
			createNamespaceName = new NameCreator("ns");
			globalTypeNameCreator = new GlobalTypeNameCreator(existingNames);
			internalTypeNameCreator = new TypeNameCreator(existingNames);
		}

		public void AddTypeName(string name) => existingNames.Add(name);
		public string GetTypeName(string oldName, string newName) => existingNames.GetName(oldName, new NameCreator2(newName));

		public string CreateNamespace(TypeDef type, string ns) {
			string asmFullName;
			if (type.Module.Assembly != null)
				asmFullName = type.Module.Assembly.FullName;
			else
				asmFullName = "<no assembly>";

			// Make sure that two namespaces with the same names in different modules aren't renamed
			// to the same name.
			var key = $" [{type.Module.Location}] [{asmFullName}] [{type.Module.Name}] [{ns}] ";
			if (namespaceToNewName.TryGetValue(key, out string newName))
				return newName;
			return namespaceToNewName[key] = createNamespaceName.Create();
		}
	}
}



================================================
File: de4dot.code/renamer/VariableNameState.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using dnlib.DotNet;

namespace de4dot.code.renamer {
	public class VariableNameState {
		ExistingNames existingVariableNames;
		ExistingNames existingMethodNames;
		ExistingNames existingPropertyNames;
		ExistingNames existingEventNames;
		TypeNames variableNameCreator;				// For fields and method args
		TypeNames propertyNameCreator;
		NameCreator eventNameCreator;
		NameCreator genericPropertyNameCreator;
		public NameCreator staticMethodNameCreator;
		public NameCreator instanceMethodNameCreator;

		public static VariableNameState Create() {
			var vns = new VariableNameState();
			vns.existingVariableNames = new ExistingNames();
			vns.existingMethodNames = new ExistingNames();
			vns.existingPropertyNames = new ExistingNames();
			vns.existingEventNames = new ExistingNames();
			vns.variableNameCreator = new VariableNameCreator();
			vns.propertyNameCreator = new PropertyNameCreator();
			vns.eventNameCreator = new NameCreator("Event_");
			vns.genericPropertyNameCreator = new NameCreator("Prop_");
			vns.staticMethodNameCreator = new NameCreator("smethod_");
			vns.instanceMethodNameCreator = new NameCreator("method_");
			return vns;
		}

		VariableNameState() {
		}

		// Cloning only params will speed up the method param renaming code
		public VariableNameState CloneParamsOnly() {
			var vns = new VariableNameState();
			vns.existingVariableNames = new ExistingNames();
			vns.variableNameCreator = new VariableNameCreator();
			vns.existingVariableNames.Merge(existingVariableNames);
			vns.variableNameCreator.Merge(variableNameCreator);
			return vns;
		}

		public VariableNameState Merge(VariableNameState other) {
			if (this == other)
				return this;
			existingVariableNames.Merge(other.existingVariableNames);
			existingMethodNames.Merge(other.existingMethodNames);
			existingPropertyNames.Merge(other.existingPropertyNames);
			existingEventNames.Merge(other.existingEventNames);
			variableNameCreator.Merge(other.variableNameCreator);
			propertyNameCreator.Merge(other.propertyNameCreator);
			eventNameCreator.Merge(other.eventNameCreator);
			genericPropertyNameCreator.Merge(other.genericPropertyNameCreator);
			staticMethodNameCreator.Merge(other.staticMethodNameCreator);
			instanceMethodNameCreator.Merge(other.instanceMethodNameCreator);
			return this;
		}

		public void MergeMethods(VariableNameState other) => existingMethodNames.Merge(other.existingMethodNames);
		public void MergeProperties(VariableNameState other) => existingPropertyNames.Merge(other.existingPropertyNames);
		public void MergeEvents(VariableNameState other) => existingEventNames.Merge(other.existingEventNames);

		public string GetNewPropertyName(PropertyDef propertyDef) {
			var propType = propertyDef.PropertySig.GetRetType();
			string newName;
			if (IsGeneric(propType))
				newName = existingPropertyNames.GetName(propertyDef.Name, genericPropertyNameCreator);
			else
				newName = existingPropertyNames.GetName(propertyDef.Name, () => propertyNameCreator.Create(propType));
			AddPropertyName(newName);
			return newName;
		}

		static bool IsGeneric(TypeSig type) {
			while (type != null) {
				if (type.IsGenericParameter)
					return true;
				type = type.Next;
			}
			return false;
		}

		public string GetNewEventName(EventDef eventDef) {
			string newName = eventNameCreator.Create();
			AddEventName(newName);
			return newName;
		}

		public void AddFieldName(string fieldName) => existingVariableNames.Add(fieldName);
		public void AddParamName(string paramName) => existingVariableNames.Add(paramName);
		public void AddMethodName(string methodName) => existingMethodNames.Add(methodName);
		public void AddPropertyName(string propName) => existingPropertyNames.Add(propName);
		public void AddEventName(string eventName) => existingEventNames.Add(eventName);
		public bool IsMethodNameUsed(string methodName) => existingMethodNames.Exists(methodName);
		public bool IsPropertyNameUsed(string propName) => existingPropertyNames.Exists(propName);
		public bool IsEventNameUsed(string eventName) => existingEventNames.Exists(eventName);
		public string GetNewFieldName(FieldDef field) => existingVariableNames.GetName(field.Name, () => variableNameCreator.Create(field.FieldSig.GetFieldType()));
		public string GetNewFieldName(string oldName, INameCreator nameCreator) => existingVariableNames.GetName(oldName, () => nameCreator.Create());
		public string GetNewParamName(string oldName, Parameter param) => existingVariableNames.GetName(oldName, () => variableNameCreator.Create(param.Type));
		public string GetNewMethodName(string oldName, INameCreator nameCreator) => existingMethodNames.GetName(oldName, nameCreator);
	}
}



================================================
File: de4dot.code/renamer/asmmodules/EventDef.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet;

namespace de4dot.code.renamer.asmmodules {
	public class MEventDef : Ref {
		public MMethodDef AddMethod { get; set; }
		public MMethodDef RemoveMethod { get; set; }
		public MMethodDef RaiseMethod { get; set; }
		public EventDef EventDef => (EventDef)memberRef;

		public MEventDef(EventDef eventDef, MTypeDef owner, int index)
			: base(eventDef, owner, index) {
		}

		public IEnumerable<MethodDef> MethodDefs() {
			if (EventDef.AddMethod != null)
				yield return EventDef.AddMethod;
			if (EventDef.RemoveMethod != null)
				yield return EventDef.RemoveMethod;
			if (EventDef.InvokeMethod != null)
				yield return EventDef.InvokeMethod;
			if (EventDef.OtherMethods != null) {
				foreach (var m in EventDef.OtherMethods)
					yield return m;
			}
		}

		public bool IsVirtual() {
			foreach (var method in MethodDefs()) {
				if (method.IsVirtual)
					return true;
			}
			return false;
		}
	}
}



================================================
File: de4dot.code/renamer/asmmodules/FieldDef.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using dnlib.DotNet;

namespace de4dot.code.renamer.asmmodules {
	public class MFieldDef : Ref {
		public FieldDef FieldDef => (FieldDef)memberRef;
		public MFieldDef(FieldDef fieldDef, MTypeDef owner, int index) : base(fieldDef, owner, index) { }
	}
}



================================================
File: de4dot.code/renamer/asmmodules/GenericParamDef.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet;

namespace de4dot.code.renamer.asmmodules {
	public class MGenericParamDef : Ref {
		public GenericParam GenericParam => (GenericParam)memberRef;

		public MGenericParamDef(GenericParam genericParameter, int index)
			: base(genericParameter, null, index) {
		}

		public static List<MGenericParamDef> CreateGenericParamDefList(IEnumerable<GenericParam> parameters) {
			var list = new List<MGenericParamDef>();
			if (parameters == null)
				return list;
			int i = 0;
			foreach (var param in parameters)
				list.Add(new MGenericParamDef(param, i++));
			return list;
		}
	}
}



================================================
File: de4dot.code/renamer/asmmodules/IResolver.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using dnlib.DotNet;

namespace de4dot.code.renamer.asmmodules {
	public interface IResolver {
		MTypeDef ResolveType(ITypeDefOrRef typeRef);
		MMethodDef ResolveMethod(IMethodDefOrRef methodRef);
		MFieldDef ResolveField(MemberRef fieldRef);
	}
}



================================================
File: de4dot.code/renamer/asmmodules/MemberRefFinder.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using dnlib.DotNet;

namespace de4dot.code.renamer.asmmodules {
	public class MemberRefFinder : MemberFinder {
		public void RemoveTypeDef(TypeDef td) {
			if (!TypeDefs.Remove(td))
				throw new ApplicationException($"Could not remove TypeDef: {td}");
		}

		public void RemoveEventDef(EventDef ed) {
			if (!EventDefs.Remove(ed))
				throw new ApplicationException($"Could not remove EventDef: {ed}");
		}

		public void RemoveFieldDef(FieldDef fd) {
			if (!FieldDefs.Remove(fd))
				throw new ApplicationException($"Could not remove FieldDef: {fd}");
		}

		public void RemoveMethodDef(MethodDef md) {
			if (!MethodDefs.Remove(md))
				throw new ApplicationException($"Could not remove MethodDef: {md}");
		}

		public void RemovePropertyDef(PropertyDef pd) {
			if (!PropertyDefs.Remove(pd))
				throw new ApplicationException($"Could not remove PropertyDef: {pd}");
		}
	}
}



================================================
File: de4dot.code/renamer/asmmodules/MethodDef.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet;

namespace de4dot.code.renamer.asmmodules {
	public class MMethodDef : Ref {
		IList<MGenericParamDef> genericParams;
		IList<MParamDef> paramDefs = new List<MParamDef>();
		MParamDef returnParamDef;
		int visibleParamCount;
		int visibleBaseIndex;

		public MPropertyDef Property { get; set; }
		public MEventDef Event { get; set; }
		public int VisibleParameterCount => visibleParamCount;
		public int VisibleParameterBaseIndex => visibleBaseIndex;
		public IList<MParamDef> ParamDefs => paramDefs;

		public IEnumerable<MParamDef> AllParamDefs {
			get {
				yield return returnParamDef;
				foreach (var paramDef in paramDefs)
					yield return paramDef;
			}
		}

		public MParamDef ReturnParamDef => returnParamDef;
		public IList<MGenericParamDef> GenericParams => genericParams;
		public MethodDef MethodDef => (MethodDef)memberRef;

		public MMethodDef(MethodDef methodDef, MTypeDef owner, int index)
			: base(methodDef, owner, index) {
			genericParams = MGenericParamDef.CreateGenericParamDefList(MethodDef.GenericParameters);
			visibleBaseIndex = methodDef.MethodSig != null && methodDef.MethodSig.HasThis ? 1 : 0;
			for (int i = 0; i < methodDef.Parameters.Count; i++) {
				var param = methodDef.Parameters[i];
				if (param.IsNormalMethodParameter)
					visibleParamCount++;
				paramDefs.Add(new MParamDef(param, i));
			}
			returnParamDef = new MParamDef(methodDef.Parameters.ReturnParameter, -1);
		}

		public bool IsPublic() => MethodDef.IsPublic;
		public bool IsVirtual() => MethodDef.IsVirtual;
		public bool IsNewSlot() => MethodDef.IsNewSlot;
		public bool IsStatic() => MethodDef.IsStatic;
	}
}



================================================
File: de4dot.code/renamer/asmmodules/MethodNameGroups.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;

namespace de4dot.code.renamer.asmmodules {
	public class MethodNameGroup {
		List<MMethodDef> methods = new List<MMethodDef>();

		public List<MMethodDef> Methods => methods;
		public int Count => methods.Count;

		public void Add(MMethodDef method) => methods.Add(method);

		public void Merge(MethodNameGroup other) {
			if (this == other)
				return;
			methods.AddRange(other.methods);
		}

		public bool HasNonRenamableMethod() {
			foreach (var method in methods) {
				if (!method.Owner.HasModule)
					return true;
			}
			return false;
		}

		public bool HasInterfaceMethod() {
			foreach (var method in methods) {
				if (method.Owner.TypeDef.IsInterface)
					return true;
			}
			return false;
		}

		public bool HasGetterOrSetterPropertyMethod() {
			foreach (var method in methods) {
				if (method.Property == null)
					continue;
				var prop = method.Property;
				if (method == prop.GetMethod || method == prop.SetMethod)
					return true;
			}
			return false;
		}

		public bool HasAddRemoveOrRaiseEventMethod() {
			foreach (var method in methods) {
				if (method.Event == null)
					continue;
				var evt = method.Event;
				if (method == evt.AddMethod || method == evt.RemoveMethod || method == evt.RaiseMethod)
					return true;
			}
			return false;
		}

		public bool HasProperty() {
			foreach (var method in methods) {
				if (method.Property != null)
					return true;
			}
			return false;
		}

		public bool HasEvent() {
			foreach (var method in methods) {
				if (method.Event != null)
					return true;
			}
			return false;
		}

		public override string ToString() => $"{methods.Count} -- {(methods.Count > 0 ? methods[0].ToString() : "")}";
	}

	public class MethodNameGroups {
		Dictionary<MMethodDef, MethodNameGroup> methodGroups = new Dictionary<MMethodDef, MethodNameGroup>();

		public void Same(MMethodDef a, MMethodDef b) => Merge(Get(a), Get(b));
		public void Add(MMethodDef methodDef) => Get(methodDef);

		public MethodNameGroup Get(MMethodDef method) {
			if (!method.IsVirtual())
				throw new ApplicationException("Not a virtual method");
			if (!methodGroups.TryGetValue(method, out var group)) {
				methodGroups[method] = group = new MethodNameGroup();
				group.Add(method);
			}
			return group;
		}

		void Merge(MethodNameGroup a, MethodNameGroup b) {
			if (a == b)
				return;

			if (a.Count < b.Count) {
				var tmp = a;
				a = b;
				b = tmp;
			}
			a.Merge(b);
			foreach (var methodDef in b.Methods)
				methodGroups[methodDef] = a;
		}

		public IEnumerable<MethodNameGroup> GetAllGroups() => Utils.Unique(methodGroups.Values);
	}
}



================================================
File: de4dot.code/renamer/asmmodules/Module.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet;

namespace de4dot.code.renamer.asmmodules {
	public class Module : IResolver {
		IObfuscatedFile obfuscatedFile;
		TypeDefDict types = new TypeDefDict();
		MemberRefFinder memberRefFinder;
		IList<RefToDef<TypeRef, TypeDef>> typeRefsToRename = new List<RefToDef<TypeRef, TypeDef>>();
		IList<RefToDef<MemberRef, MethodDef>> methodRefsToRename = new List<RefToDef<MemberRef, MethodDef>>();
		IList<RefToDef<MemberRef, FieldDef>> fieldRefsToRename = new List<RefToDef<MemberRef, FieldDef>>();
		List<CustomAttributeRef> customAttributeFieldRefs = new List<CustomAttributeRef>();
		List<CustomAttributeRef> customAttributePropertyRefs = new List<CustomAttributeRef>();
		List<MethodDef> allMethods;

		public class CustomAttributeRef {
			public CustomAttribute cattr;
			public int index;
			public IMemberRef reference;
			public CustomAttributeRef(CustomAttribute cattr, int index, IMemberRef reference) {
				this.cattr = cattr;
				this.index = index;
				this.reference = reference;
			}
		}

		public class RefToDef<R, D> where R : ICodedToken where D : ICodedToken {
			public R reference;
			public D definition;
			public RefToDef(R reference, D definition) {
				this.reference = reference;
				this.definition = definition;
			}
		}

		public IEnumerable<RefToDef<TypeRef, TypeDef>> TypeRefsToRename => typeRefsToRename;
		public IEnumerable<RefToDef<MemberRef, MethodDef>> MethodRefsToRename => methodRefsToRename;
		public IEnumerable<RefToDef<MemberRef, FieldDef>> FieldRefsToRename => fieldRefsToRename;
		public IEnumerable<CustomAttributeRef> CustomAttributeFieldRefs => customAttributeFieldRefs;
		public IEnumerable<CustomAttributeRef> CustomAttributePropertyRefs => customAttributePropertyRefs;
		public IObfuscatedFile ObfuscatedFile => obfuscatedFile;
		public string Filename => obfuscatedFile.Filename;
		public ModuleDefMD ModuleDefMD => obfuscatedFile.ModuleDefMD;
		public Module(IObfuscatedFile obfuscatedFile) => this.obfuscatedFile = obfuscatedFile;

		public IEnumerable<MTypeDef> GetAllTypes() => types.GetValues();
		public IEnumerable<MethodDef> GetAllMethods() => allMethods;

		public void FindAllMemberRefs(ref int typeIndex) {
			memberRefFinder = new MemberRefFinder();
			memberRefFinder.FindAll(ModuleDefMD);
			allMethods = new List<MethodDef>(memberRefFinder.MethodDefs.Keys);

			var allTypesList = new List<MTypeDef>();
			foreach (var type in memberRefFinder.TypeDefs.Keys) {
				var typeDef = new MTypeDef(type, this, typeIndex++);
				types.Add(typeDef);
				allTypesList.Add(typeDef);
				typeDef.AddMembers();
			}

			var allTypesCopy = new List<MTypeDef>(allTypesList);
			var typeToIndex = new Dictionary<TypeDef, int>();
			for (int i = 0; i < allTypesList.Count; i++)
				typeToIndex[allTypesList[i].TypeDef] = i;
			foreach (var typeDef in allTypesList) {
				if (typeDef.TypeDef.NestedTypes == null)
					continue;
				foreach (var nestedTypeDef2 in typeDef.TypeDef.NestedTypes) {
					int index = typeToIndex[nestedTypeDef2];
					var nestedTypeDef = allTypesCopy[index];
					allTypesCopy[index] = null;
					if (nestedTypeDef == null)	// Impossible
						throw new ApplicationException("Nested type belongs to two or more types");
					typeDef.Add(nestedTypeDef);
					nestedTypeDef.NestingType = typeDef;
				}
			}
		}

		public void ResolveAllRefs(IResolver resolver) {
			foreach (var typeRef in memberRefFinder.TypeRefs.Keys) {
				var typeDef = resolver.ResolveType(typeRef);
				if (typeDef != null)
					typeRefsToRename.Add(new RefToDef<TypeRef, TypeDef>(typeRef, typeDef.TypeDef));
			}

			foreach (var memberRef in memberRefFinder.MemberRefs.Keys) {
				if (memberRef.IsMethodRef) {
					var methodDef = resolver.ResolveMethod(memberRef);
					if (methodDef != null)
						methodRefsToRename.Add(new RefToDef<MemberRef, MethodDef>(memberRef, methodDef.MethodDef));
				}
				else if (memberRef.IsFieldRef) {
					var fieldDef = resolver.ResolveField(memberRef);
					if (fieldDef != null)
						fieldRefsToRename.Add(new RefToDef<MemberRef, FieldDef>(memberRef, fieldDef.FieldDef));
				}
			}

			foreach (var cattr in memberRefFinder.CustomAttributes.Keys) {
				var typeDef = resolver.ResolveType(cattr.AttributeType);
				if (typeDef == null)
					continue;
				if (cattr.NamedArguments == null)
					continue;

				for (int i = 0; i < cattr.NamedArguments.Count; i++) {
					var namedArg = cattr.NamedArguments[i];
					if (namedArg.IsField) {
						var fieldDef = FindField(typeDef, namedArg.Name, namedArg.Type);
						if (fieldDef == null) {
							Logger.w("Could not find field {0} in attribute {1} ({2:X8})",
									Utils.ToCsharpString(namedArg.Name),
									Utils.ToCsharpString(typeDef.TypeDef.Name),
									typeDef.TypeDef.MDToken.ToInt32());
							continue;
						}

						customAttributeFieldRefs.Add(new CustomAttributeRef(cattr, i, fieldDef.FieldDef));
					}
					else {
						var propDef = FindProperty(typeDef, namedArg.Name, namedArg.Type);
						if (propDef == null) {
							Logger.w("Could not find property {0} in attribute {1} ({2:X8})",
									Utils.ToCsharpString(namedArg.Name),
									Utils.ToCsharpString(typeDef.TypeDef.Name),
									typeDef.TypeDef.MDToken.ToInt32());
							continue;
						}

						customAttributePropertyRefs.Add(new CustomAttributeRef(cattr, i, propDef.PropertyDef));
					}
				}
			}
		}

		static MFieldDef FindField(MTypeDef typeDef, UTF8String name, TypeSig fieldType) {
			while (typeDef != null) {
				foreach (var fieldDef in typeDef.AllFields) {
					if (fieldDef.FieldDef.Name != name)
						continue;
					if (new SigComparer().Equals(fieldDef.FieldDef.FieldSig.GetFieldType(), fieldType))
						return fieldDef;
				}

				if (typeDef.baseType == null)
					break;
				typeDef = typeDef.baseType.typeDef;
			}
			return null;
		}

		static MPropertyDef FindProperty(MTypeDef typeDef, UTF8String name, TypeSig propType) {
			while (typeDef != null) {
				foreach (var propDef in typeDef.AllProperties) {
					if (propDef.PropertyDef.Name != name)
						continue;
					if (new SigComparer().Equals(propDef.PropertyDef.PropertySig.GetRetType(), propType))
						return propDef;
				}

				if (typeDef.baseType == null)
					break;
				typeDef = typeDef.baseType.typeDef;
			}
			return null;
		}

		public void OnTypesRenamed() {
			var newTypes = new TypeDefDict();
			foreach (var typeDef in types.GetValues()) {
				typeDef.OnTypesRenamed();
				newTypes.Add(typeDef);
			}
			types = newTypes;

			ModuleDefMD.ResetTypeDefFindCache();
		}

		static ITypeDefOrRef GetNonGenericTypeRef(ITypeDefOrRef typeRef) {
			var ts = typeRef as TypeSpec;
			if (ts == null)
				return typeRef;
			var gis = ts.TryGetGenericInstSig();
			if (gis == null || gis.GenericType == null)
				return typeRef;
			return gis.GenericType.TypeDefOrRef;
		}

		public MTypeDef ResolveType(ITypeDefOrRef typeRef) => types.Find(GetNonGenericTypeRef(typeRef));

		public MMethodDef ResolveMethod(IMethodDefOrRef methodRef) {
			var typeDef = types.Find(GetNonGenericTypeRef(methodRef.DeclaringType));
			if (typeDef == null)
				return null;
			return typeDef.FindMethod(methodRef);
		}

		public MFieldDef ResolveField(MemberRef fieldRef) {
			var typeDef = types.Find(GetNonGenericTypeRef(fieldRef.DeclaringType));
			if (typeDef == null)
				return null;
			return typeDef.FindField(fieldRef);
		}
	}
}



================================================
File: de4dot.code/renamer/asmmodules/Modules.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet;

namespace de4dot.code.renamer.asmmodules {
	public class Modules : IResolver {
		bool initializeCalled = false;
		IDeobfuscatorContext deobfuscatorContext;
		List<Module> modules = new List<Module>();
		Dictionary<ModuleDef, Module> modulesDict = new Dictionary<ModuleDef, Module>();
		AssemblyHash assemblyHash = new AssemblyHash();

		List<MTypeDef> allTypes = new List<MTypeDef>();
		List<MTypeDef> baseTypes = new List<MTypeDef>();
		List<MTypeDef> nonNestedTypes;

		public IList<Module> TheModules => modules;
		public IEnumerable<MTypeDef> AllTypes => allTypes;
		public IEnumerable<MTypeDef> BaseTypes => baseTypes;
		public List<MTypeDef> NonNestedTypes => nonNestedTypes;

		class AssemblyHash {
			IDictionary<string, ModuleHash> assemblyHash = new Dictionary<string, ModuleHash>(StringComparer.Ordinal);

			public void Add(Module module) {
				var key = GetModuleKey(module);
				if (!assemblyHash.TryGetValue(key, out var moduleHash))
					assemblyHash[key] = moduleHash = new ModuleHash();
				moduleHash.Add(module);
			}

			static string GetModuleKey(Module module) {
				if (module.ModuleDefMD.Assembly != null)
					return GetAssemblyName(module.ModuleDefMD.Assembly);
				return Utils.GetBaseName(module.ModuleDefMD.Location);
			}

			public ModuleHash Lookup(IAssembly asm) {
				if (assemblyHash.TryGetValue(GetAssemblyName(asm), out var moduleHash))
					return moduleHash;
				return null;
			}

			static string GetAssemblyName(IAssembly asm) {
				if (asm == null)
					return string.Empty;
				if (PublicKeyBase.IsNullOrEmpty2(asm.PublicKeyOrToken))
					return asm.Name;
				return asm.FullName;
			}
		}

		class ModuleHash {
			ModulesDict modulesDict = new ModulesDict();
			Module mainModule = null;

			public void Add(Module module) {
				var asm = module.ModuleDefMD.Assembly;
				if (asm != null && ReferenceEquals(asm.ManifestModule, module.ModuleDefMD)) {
					if (mainModule != null) {
						throw new UserException(
							"Two modules in the same assembly are main modules.\n" +
							"Is one 32-bit and the other 64-bit?\n" +
							$"  Module1: \"{module.ModuleDefMD.Location}\"" +
							$"  Module2: \"{mainModule.ModuleDefMD.Location}\"");
					}
					mainModule = module;
				}

				modulesDict.Add(module);
			}

			public Module Lookup(string moduleName) => modulesDict.Lookup(moduleName);
			public IEnumerable<Module> Modules => modulesDict.Modules;
		}

		class ModulesDict {
			IDictionary<string, Module> modulesDict = new Dictionary<string, Module>(StringComparer.Ordinal);

			public void Add(Module module) {
				var moduleName = module.ModuleDefMD.Name.String;
				if (Lookup(moduleName) != null)
					throw new ApplicationException($"Module \"{moduleName}\" was found twice");
				modulesDict[moduleName] = module;
			}

			public Module Lookup(string moduleName) {
				if (modulesDict.TryGetValue(moduleName, out var module))
					return module;
				return null;
			}

			public IEnumerable<Module> Modules => modulesDict.Values;
		}

		public bool Empty => modules.Count == 0;
		public Modules(IDeobfuscatorContext deobfuscatorContext) => this.deobfuscatorContext = deobfuscatorContext;

		public void Add(Module module) {
			if (initializeCalled)
				throw new ApplicationException("initialize() has been called");
			if (modulesDict.TryGetValue(module.ModuleDefMD, out var otherModule))
				return;
			modulesDict[module.ModuleDefMD] = module;
			modules.Add(module);
			assemblyHash.Add(module);
		}

		public void Initialize() {
			initializeCalled = true;
			FindAllMemberRefs();
			InitAllTypes();
			ResolveAllRefs();
		}

		void FindAllMemberRefs() {
			Logger.v("Finding all MemberRefs");
			int index = 0;
			foreach (var module in modules) {
				if (modules.Count > 1)
					Logger.v("Finding all MemberRefs ({0})", module.Filename);
				Logger.Instance.Indent();
				module.FindAllMemberRefs(ref index);
				Logger.Instance.DeIndent();
			}
		}

		void ResolveAllRefs() {
			Logger.v("Resolving references");
			foreach (var module in modules) {
				if (modules.Count > 1)
					Logger.v("Resolving references ({0})", module.Filename);
				Logger.Instance.Indent();
				module.ResolveAllRefs(this);
				Logger.Instance.DeIndent();
			}
		}

		void InitAllTypes() {
			foreach (var module in modules)
				allTypes.AddRange(module.GetAllTypes());

			var typeToTypeDef = new Dictionary<TypeDef, MTypeDef>(allTypes.Count);
			foreach (var typeDef in allTypes)
				typeToTypeDef[typeDef.TypeDef] = typeDef;

			// Initialize Owner
			foreach (var typeDef in allTypes) {
				if (typeDef.TypeDef.DeclaringType != null)
					typeDef.Owner = typeToTypeDef[typeDef.TypeDef.DeclaringType];
			}

			// Initialize baseType and derivedTypes
			foreach (var typeDef in allTypes) {
				var baseType = typeDef.TypeDef.BaseType;
				if (baseType == null)
					continue;
				var baseTypeDef = ResolveType(baseType) ?? ResolveOther(baseType);
				if (baseTypeDef != null) {
					typeDef.AddBaseType(baseTypeDef, baseType);
					baseTypeDef.derivedTypes.Add(typeDef);
				}
			}

			// Initialize interfaces
			foreach (var typeDef in allTypes) {
				foreach (var iface in typeDef.TypeDef.Interfaces) {
					var ifaceTypeDef = ResolveType(iface.Interface) ?? ResolveOther(iface.Interface);
					if (ifaceTypeDef != null)
						typeDef.AddInterface(ifaceTypeDef, iface.Interface);
				}
			}

			// Find all non-nested types
			var allTypesDict = new Dictionary<MTypeDef, bool>();
			foreach (var t in allTypes)
				allTypesDict[t] = true;
			foreach (var t in allTypes) {
				foreach (var t2 in t.NestedTypes)
					allTypesDict.Remove(t2);
			}
			nonNestedTypes = new List<MTypeDef>(allTypesDict.Keys);

			foreach (var typeDef in allTypes) {
				if (typeDef.baseType == null || !typeDef.baseType.typeDef.HasModule)
					baseTypes.Add(typeDef);
			}
		}

		class AssemblyKeyDictionary<T> where T : class {
			Dictionary<ITypeDefOrRef, T> dict = new Dictionary<ITypeDefOrRef, T>(new TypeEqualityComparer(SigComparerOptions.CompareAssemblyVersion));
			Dictionary<ITypeDefOrRef, List<ITypeDefOrRef>> refs = new Dictionary<ITypeDefOrRef, List<ITypeDefOrRef>>(TypeEqualityComparer.Instance);

			public T this[ITypeDefOrRef type] {
				get {
					if (TryGetValue(type, out var value))
						return value;
					throw new KeyNotFoundException();
				}
				set {
					dict[type] = value;

					if (value != null) {
						if (!refs.TryGetValue(type, out var list))
							refs[type] = list = new List<ITypeDefOrRef>();
						list.Add(type);
					}
				}
			}

			public bool TryGetValue(ITypeDefOrRef type, out T value) => dict.TryGetValue(type, out value);

			public bool TryGetSimilarValue(ITypeDefOrRef type, out T value) {
				if (!refs.TryGetValue(type, out var list)) {
					value = default;
					return false;
				}

				// Find a type whose version is >= type's version and closest to it.

				ITypeDefOrRef foundType = null;
				var typeAsmName = type.DefinitionAssembly;
				IAssembly foundAsmName = null;
				foreach (var otherRef in list) {
					if (!dict.TryGetValue(otherRef, out value))
						continue;

					if (typeAsmName == null) {
						foundType = otherRef;
						break;
					}

					var otherAsmName = otherRef.DefinitionAssembly;
					if (otherAsmName == null)
						continue;
					// Check pkt or we could return a type in eg. a SL assembly when it's not a SL app.
					if (!PublicKeyBase.TokenEquals(typeAsmName.PublicKeyOrToken, otherAsmName.PublicKeyOrToken))
						continue;
					if (typeAsmName.Version > otherAsmName.Version)
						continue;	// old version

					if (foundType == null) {
						foundAsmName = otherAsmName;
						foundType = otherRef;
						continue;
					}

					if (foundAsmName.Version <= otherAsmName.Version)
						continue;
					foundAsmName = otherAsmName;
					foundType = otherRef;
				}

				if (foundType != null) {
					value = dict[foundType];
					return true;
				}

				value = default;
				return false;
			}
		}

		AssemblyKeyDictionary<MTypeDef> typeToTypeDefDict = new AssemblyKeyDictionary<MTypeDef>();
		public MTypeDef ResolveOther(ITypeDefOrRef type) {
			if (type == null)
				return null;
			type = type.ScopeType;
			if (type == null)
				return null;

			if (typeToTypeDefDict.TryGetValue(type, out var typeDef))
				return typeDef;

			var typeDef2 = deobfuscatorContext.ResolveType(type);
			if (typeDef2 == null) {
				typeToTypeDefDict.TryGetSimilarValue(type, out typeDef);
				typeToTypeDefDict[type] = typeDef;
				return typeDef;
			}

			if (typeToTypeDefDict.TryGetValue(typeDef2, out typeDef)) {
				typeToTypeDefDict[type] = typeDef;
				return typeDef;
			}

			typeToTypeDefDict[type] = null;	// In case of a circular reference
			typeToTypeDefDict[typeDef2] = null;

			typeDef = new MTypeDef(typeDef2, null, 0);
			typeDef.AddMembers();
			foreach (var iface in typeDef.TypeDef.Interfaces) {
				var ifaceDef = ResolveOther(iface.Interface);
				if (ifaceDef == null)
					continue;
				typeDef.AddInterface(ifaceDef, iface.Interface);
			}
			var baseDef = ResolveOther(typeDef.TypeDef.BaseType);
			if (baseDef != null)
				typeDef.AddBaseType(baseDef, typeDef.TypeDef.BaseType);

			typeToTypeDefDict[type] = typeDef;
			if (type != typeDef2)
				typeToTypeDefDict[typeDef2] = typeDef;
			return typeDef;
		}

		public MethodNameGroups InitializeVirtualMembers() {
			var groups = new MethodNameGroups();
			foreach (var typeDef in allTypes)
				typeDef.InitializeVirtualMembers(groups, this);
			return groups;
		}

		public void OnTypesRenamed() {
			foreach (var module in modules)
				module.OnTypesRenamed();
		}

		public void CleanUp() {
#if PORT
			foreach (var module in DotNetUtils.typeCaches.invalidateAll())
				AssemblyResolver.Instance.removeModule(module);
#endif
		}

		// Returns null if it's a non-loaded module/assembly
		IEnumerable<Module> FindModules(ITypeDefOrRef type) {
			if (type == null)
				return null;
			var scope = type.Scope;
			if (scope == null)
				return null;

			var scopeType = scope.ScopeType;
			if (scopeType == ScopeType.AssemblyRef)
				return FindModules((AssemblyRef)scope);

			if (scopeType == ScopeType.ModuleDef) {
				var modules = FindModules((ModuleDef)scope);
				if (modules != null)
					return modules;
			}

			if (scopeType == ScopeType.ModuleRef) {
				var moduleRef = (ModuleRef)scope;
				if (moduleRef.Name == type.Module.Name) {
					var modules = FindModules(type.Module);
					if (modules != null)
						return modules;
				}
			}

			if (scopeType == ScopeType.ModuleRef || scopeType == ScopeType.ModuleDef) {
				var asm = type.Module.Assembly;
				if (asm == null)
					return null;
				var moduleHash = assemblyHash.Lookup(asm);
				if (moduleHash == null)
					return null;
				var module = moduleHash.Lookup(scope.ScopeName);
				if (module == null)
					return null;
				return new List<Module> { module };
			}

			throw new ApplicationException($"scope is an unsupported type: {scope.GetType()}");
		}

		IEnumerable<Module> FindModules(AssemblyRef assemblyRef) {
			var moduleHash = assemblyHash.Lookup(assemblyRef);
			if (moduleHash != null)
				return moduleHash.Modules;
			return null;
		}

		IEnumerable<Module> FindModules(ModuleDef moduleDef) {
			if (modulesDict.TryGetValue(moduleDef, out var module))
				return new List<Module> { module };
			return null;
		}

		bool IsAutoCreatedType(ITypeDefOrRef typeRef) {
			var ts = typeRef as TypeSpec;
			if (ts == null)
				return false;
			var sig = ts.TypeSig;
			if (sig == null)
				return false;
			return sig.IsSZArray || sig.IsArray || sig.IsPointer;
		}

		public MTypeDef ResolveType(ITypeDefOrRef typeRef) {
			var modules = FindModules(typeRef);
			if (modules == null)
				return null;
			foreach (var module in modules) {
				var rv = module.ResolveType(typeRef);
				if (rv != null)
					return rv;
			}
			if (IsAutoCreatedType(typeRef))
				return null;
			Logger.e("Could not resolve TypeRef {0} ({1:X8}) (from {2} -> {3})",
						Utils.RemoveNewlines(typeRef),
						typeRef.MDToken.ToInt32(),
						typeRef.Module,
						typeRef.Scope);
			return null;
		}

		public MMethodDef ResolveMethod(IMethodDefOrRef methodRef) {
			if (methodRef.DeclaringType == null)
				return null;
			var modules = FindModules(methodRef.DeclaringType);
			if (modules == null)
				return null;
			foreach (var module in modules) {
				var rv = module.ResolveMethod(methodRef);
				if (rv != null)
					return rv;
			}
			if (IsAutoCreatedType(methodRef.DeclaringType))
				return null;
			Logger.e("Could not resolve MethodRef {0} ({1:X8}) (from {2} -> {3})",
						Utils.RemoveNewlines(methodRef),
						methodRef.MDToken.ToInt32(),
						methodRef.DeclaringType.Module,
						methodRef.DeclaringType.Scope);
			return null;
		}

		public MFieldDef ResolveField(MemberRef fieldRef) {
			if (fieldRef.DeclaringType == null)
				return null;
			var modules = FindModules(fieldRef.DeclaringType);
			if (modules == null)
				return null;
			foreach (var module in modules) {
				var rv = module.ResolveField(fieldRef);
				if (rv != null)
					return rv;
			}
			if (IsAutoCreatedType(fieldRef.DeclaringType))
				return null;
			Logger.e("Could not resolve FieldRef {0} ({1:X8}) (from {2} -> {3})",
						Utils.RemoveNewlines(fieldRef),
						fieldRef.MDToken.ToInt32(),
						fieldRef.DeclaringType.Module,
						fieldRef.DeclaringType.Scope);
			return null;
		}
	}
}



================================================
File: de4dot.code/renamer/asmmodules/ParamDef.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using dnlib.DotNet;

namespace de4dot.code.renamer.asmmodules {
	public class MParamDef {
		public Parameter ParameterDef { get; set; }
		public int Index { get; private set; }
		public bool IsReturnParameter => ParameterDef.IsReturnTypeParameter;
		public bool IsHiddenThisParameter => ParameterDef.IsHiddenThisParameter;

		public MParamDef(Parameter parameterDef, int index) {
			ParameterDef = parameterDef;
			Index = index;
		}
	}
}



================================================
File: de4dot.code/renamer/asmmodules/PropertyDef.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using dnlib.DotNet;

namespace de4dot.code.renamer.asmmodules {
	public class MPropertyDef : Ref {
		public MMethodDef GetMethod { get; set; }
		public MMethodDef SetMethod { get; set; }
		public PropertyDef PropertyDef => (PropertyDef)memberRef;

		public MPropertyDef(PropertyDef propertyDef, MTypeDef owner, int index)
			: base(propertyDef, owner, index) {
		}

		public IEnumerable<MethodDef> MethodDefs() {
			if (PropertyDef.GetMethod != null)
				yield return PropertyDef.GetMethod;
			if (PropertyDef.SetMethod != null)
				yield return PropertyDef.SetMethod;
			if (PropertyDef.OtherMethods != null) {
				foreach (var m in PropertyDef.OtherMethods)
					yield return m;
			}
		}

		public bool IsVirtual() {
			foreach (var method in MethodDefs()) {
				if (method.IsVirtual)
					return true;
			}
			return false;
		}

		public bool IsItemProperty() {
			if (GetMethod != null && GetMethod.VisibleParameterCount >= 1)
				return true;
			if (SetMethod != null && SetMethod.VisibleParameterCount >= 2)
				return true;
			return false;
		}
	}
}



================================================
File: de4dot.code/renamer/asmmodules/Ref.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using dnlib.DotNet;

namespace de4dot.code.renamer.asmmodules {
	public abstract class Ref {
		public readonly IMemberRef memberRef;
		public int Index { get; set; }
		public MTypeDef Owner { get; set; }

		protected Ref(IMemberRef memberRef, MTypeDef owner, int index) {
			this.memberRef = memberRef;
			Owner = owner;
			Index = index;
		}

		public override string ToString() => memberRef?.ToString();
	}
}



================================================
File: de4dot.code/renamer/asmmodules/RefDict.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using de4dot.blocks;

namespace de4dot.code.renamer.asmmodules {
	public static class DictHelper {
		public static IEnumerable<T> GetSorted<T>(IEnumerable<T> values) where T : Ref {
			var list = new List<T>(values);
			list.Sort((a, b) => a.Index.CompareTo(b.Index));
			return list;
		}
	}

	public class TypeDefDict : TypeDefDict<MTypeDef> {
		public IEnumerable<MTypeDef> GetSorted() => DictHelper.GetSorted(GetValues());
		public void Add(MTypeDef typeDef) => Add(typeDef.TypeDef, typeDef);
	}

	public class FieldDefDict : FieldDefDict<MFieldDef> {
		public IEnumerable<MFieldDef> GetSorted() => DictHelper.GetSorted(GetValues());
		public void Add(MFieldDef fieldDef) => Add(fieldDef.FieldDef, fieldDef);
	}

	public class MethodDefDict : MethodDefDict<MMethodDef> {
		public IEnumerable<MMethodDef> GetSorted() => DictHelper.GetSorted(GetValues());
		public void Add(MMethodDef methodDef) => Add(methodDef.MethodDef, methodDef);
	}

	public class PropertyDefDict : PropertyDefDict<MPropertyDef> {
		public IEnumerable<MPropertyDef> GetSorted() => DictHelper.GetSorted(GetValues());
		public void Add(MPropertyDef propDef) => Add(propDef.PropertyDef, propDef);
	}

	public class EventDefDict : EventDefDict<MEventDef> {
		public IEnumerable<MEventDef> GetSorted() => DictHelper.GetSorted(GetValues());
		public void Add(MEventDef eventDef) => Add(eventDef.EventDef, eventDef);
	}
}



================================================
File: de4dot.code/renamer/asmmodules/TypeDef.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet;
using de4dot.blocks;

namespace de4dot.code.renamer.asmmodules {
	public class TypeInfo {
		public ITypeDefOrRef typeRef;
		public MTypeDef typeDef;
		public TypeInfo(ITypeDefOrRef typeRef, MTypeDef typeDef) {
			this.typeRef = typeRef;
			this.typeDef = typeDef;
		}

		public TypeInfo(TypeInfo other, GenericInstSig git) {
			typeRef = GenericArgsSubstitutor.Create(other.typeRef, git);
			typeDef = other.typeDef;
		}

		public override int GetHashCode() => typeDef.GetHashCode() + new SigComparer().GetHashCode(typeRef);

		public override bool Equals(object obj) {
			var other = obj as TypeInfo;
			if (other == null)
				return false;
			return typeDef == other.typeDef &&
				new SigComparer().Equals(typeRef, other.typeRef);
		}

		public override string ToString() => typeRef.ToString();
	}

	public class MethodDefKey {
		public readonly MMethodDef methodDef;

		public MethodDefKey(MMethodDef methodDef) => this.methodDef = methodDef;
		public override int GetHashCode() => MethodEqualityComparer.CompareDeclaringTypes.GetHashCode(methodDef.MethodDef);

		public override bool Equals(object obj) {
			var other = obj as MethodDefKey;
			if (other == null)
				return false;
			return MethodEqualityComparer.CompareDeclaringTypes.Equals(methodDef.MethodDef, other.methodDef.MethodDef);
		}
	}

	public class MethodInst {
		public MMethodDef origMethodDef;
		public IMethodDefOrRef methodRef;

		public MethodInst(MMethodDef origMethodDef, IMethodDefOrRef methodRef) {
			this.origMethodDef = origMethodDef;
			this.methodRef = methodRef;
		}

		public override string ToString() => methodRef.ToString();
	}

	public class MethodInstances {
		Dictionary<IMethodDefOrRef, List<MethodInst>> methodInstances = new Dictionary<IMethodDefOrRef, List<MethodInst>>(MethodEqualityComparer.DontCompareDeclaringTypes);

		public void InitializeFrom(MethodInstances other, GenericInstSig git) {
			foreach (var list in other.methodInstances.Values) {
				foreach (var methodInst in list) {
					var newMethod = GenericArgsSubstitutor.Create(methodInst.methodRef, git);
					Add(new MethodInst(methodInst.origMethodDef, newMethod));
				}
			}
		}

		public void Add(MethodInst methodInst) {
			var key = methodInst.methodRef;
			if (methodInst.origMethodDef.IsNewSlot() || !methodInstances.TryGetValue(key, out var list))
				methodInstances[key] = list = new List<MethodInst>();
			list.Add(methodInst);
		}

		public List<MethodInst> Lookup(IMethodDefOrRef methodRef) {
			methodInstances.TryGetValue(methodRef, out var list);
			return list;
		}

		public IEnumerable<List<MethodInst>> GetMethods() => methodInstances.Values;
	}

	// Keeps track of which methods of an interface that have been implemented
	public class InterfaceMethodInfo {
		TypeInfo iface;
		Dictionary<MethodDefKey, MMethodDef> ifaceMethodToClassMethod = new Dictionary<MethodDefKey, MMethodDef>();

		public TypeInfo IFace => iface;
		public Dictionary<MethodDefKey, MMethodDef> IfaceMethodToClassMethod => ifaceMethodToClassMethod;

		public InterfaceMethodInfo(TypeInfo iface) {
			this.iface = iface;
			foreach (var methodDef in iface.typeDef.AllMethods)
				ifaceMethodToClassMethod[new MethodDefKey(methodDef)] = null;
		}

		public InterfaceMethodInfo(TypeInfo iface, InterfaceMethodInfo other) {
			this.iface = iface;
			foreach (var key in other.ifaceMethodToClassMethod.Keys)
				ifaceMethodToClassMethod[key] = other.ifaceMethodToClassMethod[key];
		}

		public void Merge(InterfaceMethodInfo other) {
			foreach (var key in other.ifaceMethodToClassMethod.Keys) {
				if (other.ifaceMethodToClassMethod[key] == null)
					continue;
				if (ifaceMethodToClassMethod[key] != null)
					throw new ApplicationException("Interface method already initialized");
				ifaceMethodToClassMethod[key] = other.ifaceMethodToClassMethod[key];
			}
		}

		// Returns the previous method, or null if none
		public MMethodDef AddMethod(MMethodDef ifaceMethod, MMethodDef classMethod) {
			var ifaceKey = new MethodDefKey(ifaceMethod);
			if (!ifaceMethodToClassMethod.ContainsKey(ifaceKey))
				throw new ApplicationException("Could not find interface method");

			ifaceMethodToClassMethod.TryGetValue(ifaceKey, out var oldMethod);
			ifaceMethodToClassMethod[ifaceKey] = classMethod;
			return oldMethod;
		}

		public void AddMethodIfEmpty(MMethodDef ifaceMethod, MMethodDef classMethod) {
			if (ifaceMethodToClassMethod[new MethodDefKey(ifaceMethod)] == null)
				AddMethod(ifaceMethod, classMethod);
		}

		public override string ToString() => iface.ToString();
	}

	public class InterfaceMethodInfos {
		Dictionary<ITypeDefOrRef, InterfaceMethodInfo> interfaceMethods = new Dictionary<ITypeDefOrRef, InterfaceMethodInfo>(TypeEqualityComparer.Instance);

		public IEnumerable<InterfaceMethodInfo> AllInfos => interfaceMethods.Values;

		public void InitializeFrom(InterfaceMethodInfos other, GenericInstSig git) {
			foreach (var pair in other.interfaceMethods) {
				var oldTypeInfo = pair.Value.IFace;
				var newTypeInfo = new TypeInfo(oldTypeInfo, git);
				var oldKey = oldTypeInfo.typeRef;
				var newKey = newTypeInfo.typeRef;

				var newMethodsInfo = new InterfaceMethodInfo(newTypeInfo, other.interfaceMethods[oldKey]);
				if (interfaceMethods.ContainsKey(newKey))
					newMethodsInfo.Merge(interfaceMethods[newKey]);
				interfaceMethods[newKey] = newMethodsInfo;
			}
		}

		public void AddInterface(TypeInfo iface) {
			var key = iface.typeRef;
			if (!interfaceMethods.ContainsKey(key))
				interfaceMethods[key] = new InterfaceMethodInfo(iface);
		}

		// Returns the previous classMethod, or null if none
		public MMethodDef AddMethod(TypeInfo iface, MMethodDef ifaceMethod, MMethodDef classMethod) =>
			AddMethod(iface.typeRef, ifaceMethod, classMethod);

		// Returns the previous classMethod, or null if none
		public MMethodDef AddMethod(ITypeDefOrRef iface, MMethodDef ifaceMethod, MMethodDef classMethod) {
			if (!interfaceMethods.TryGetValue(iface, out var info))
				throw new ApplicationException("Could not find interface");
			return info.AddMethod(ifaceMethod, classMethod);
		}

		public void AddMethodIfEmpty(TypeInfo iface, MMethodDef ifaceMethod, MMethodDef classMethod) {
			if (!interfaceMethods.TryGetValue(iface.typeRef, out var info))
				throw new ApplicationException("Could not find interface");
			info.AddMethodIfEmpty(ifaceMethod, classMethod);
		}
	}

	public class MTypeDef : Ref {
		EventDefDict events = new EventDefDict();
		FieldDefDict fields = new FieldDefDict();
		MethodDefDict methods = new MethodDefDict();
		PropertyDefDict properties = new PropertyDefDict();
		TypeDefDict types = new TypeDefDict();
		List<MGenericParamDef> genericParams;
		internal TypeInfo baseType = null;
		internal IList<TypeInfo> interfaces = new List<TypeInfo>();	// directly implemented interfaces
		internal IList<MTypeDef> derivedTypes = new List<MTypeDef>();
		Module module;

		bool initializeVirtualMembersCalled = false;
		MethodInstances virtualMethodInstances = new MethodInstances();
		Dictionary<TypeInfo, bool> allImplementedInterfaces = new Dictionary<TypeInfo, bool>();
		InterfaceMethodInfos interfaceMethodInfos = new InterfaceMethodInfos();

		public Module Module => module;

		// Returns false if this is a type from a dependency (non-renamble) assembly (eg. mscorlib)
		public bool HasModule => module != null;
		public IList<MGenericParamDef> GenericParams => genericParams;
		public IEnumerable<MTypeDef> NestedTypes => types.GetSorted();
		public MTypeDef NestingType { get; set; }
		public TypeDef TypeDef => (TypeDef)memberRef;
		public IEnumerable<MEventDef> AllEvents => events.GetValues();
		public IEnumerable<MFieldDef> AllFields => fields.GetValues();
		public IEnumerable<MMethodDef> AllMethods => methods.GetValues();
		public IEnumerable<MPropertyDef> AllProperties => properties.GetValues();
		public IEnumerable<MEventDef> AllEventsSorted => events.GetSorted();
		public IEnumerable<MFieldDef> AllFieldsSorted => fields.GetSorted();
		public IEnumerable<MMethodDef> AllMethodsSorted => methods.GetSorted();
		public IEnumerable<MPropertyDef> AllPropertiesSorted => properties.GetSorted();

		public MTypeDef(TypeDef typeDef, Module module, int index)
			: base(typeDef, null, index) {
			this.module = module;
			genericParams = MGenericParamDef.CreateGenericParamDefList(TypeDef.GenericParameters);
		}

		public void AddInterface(MTypeDef ifaceDef, ITypeDefOrRef iface) {
			if (ifaceDef == null || iface == null)
				return;
			interfaces.Add(new TypeInfo(iface, ifaceDef));
		}

		public void AddBaseType(MTypeDef baseDef, ITypeDefOrRef baseRef) {
			if (baseDef == null || baseRef == null)
				return;
			baseType = new TypeInfo(baseRef, baseDef);
		}

		public void Add(MEventDef e) => events.Add(e);
		public void Add(MFieldDef f) => fields.Add(f);
		public void Add(MMethodDef m) => methods.Add(m);
		public void Add(MPropertyDef p) => properties.Add(p);
		public void Add(MTypeDef t) => types.Add(t);
		public MMethodDef FindMethod(MemberRef mr) => methods.Find(mr);
		public MMethodDef FindMethod(IMethodDefOrRef md) => methods.Find(md);
		public MMethodDef FindMethod(MethodDef md) => methods.Find(md);
		public MMethodDef FindAnyMethod(MemberRef mr) => methods.FindAny(mr);
		public MFieldDef FindField(MemberRef fr) => fields.Find(fr);
		public MFieldDef FindAnyField(MemberRef fr) => fields.FindAny(fr);
		public MPropertyDef Find(PropertyDef pr) => properties.Find(pr);
		public MPropertyDef FindAny(PropertyDef pr) => properties.FindAny(pr);
		public MEventDef Find(EventDef er) => events.Find(er);
		public MEventDef FindAny(EventDef er) => events.FindAny(er);

		public MPropertyDef Create(PropertyDef newProp) {
			if (FindAny(newProp) != null)
				throw new ApplicationException("Can't add a property when it's already been added");

			var propDef = new MPropertyDef(newProp, this, properties.Count);
			Add(propDef);
			TypeDef.Properties.Add(newProp);
			return propDef;
		}

		public MEventDef Create(EventDef newEvent) {
			if (FindAny(newEvent) != null)
				throw new ApplicationException("Can't add an event when it's already been added");

			var eventDef = new MEventDef(newEvent, this, events.Count);
			Add(eventDef);
			TypeDef.Events.Add(newEvent);
			return eventDef;
		}

		public void AddMembers() {
			var type = TypeDef;

			for (int i = 0; i < type.Events.Count; i++)
				Add(new MEventDef(type.Events[i], this, i));
			for (int i = 0; i < type.Fields.Count; i++)
				Add(new MFieldDef(type.Fields[i], this, i));
			for (int i = 0; i < type.Methods.Count; i++)
				Add(new MMethodDef(type.Methods[i], this, i));
			for (int i = 0; i < type.Properties.Count; i++)
				Add(new MPropertyDef(type.Properties[i], this, i));

			foreach (var propDef in properties.GetValues()) {
				foreach (var method in propDef.MethodDefs()) {
					var methodDef = FindMethod(method);
					if (methodDef == null)
						throw new ApplicationException("Could not find property method");
					methodDef.Property = propDef;
					if (method == propDef.PropertyDef.GetMethod)
						propDef.GetMethod = methodDef;
					if (method == propDef.PropertyDef.SetMethod)
						propDef.SetMethod = methodDef;
				}
			}

			foreach (var eventDef in events.GetValues()) {
				foreach (var method in eventDef.MethodDefs()) {
					var methodDef = FindMethod(method);
					if (methodDef == null)
						throw new ApplicationException("Could not find event method");
					methodDef.Event = eventDef;
					if (method == eventDef.EventDef.AddMethod)
						eventDef.AddMethod = methodDef;
					if (method == eventDef.EventDef.RemoveMethod)
						eventDef.RemoveMethod = methodDef;
					if (method == eventDef.EventDef.InvokeMethod)
						eventDef.RaiseMethod = methodDef;
				}
			}
		}

		public void OnTypesRenamed() {
			events.OnTypesRenamed();
			properties.OnTypesRenamed();
			fields.OnTypesRenamed();
			methods.OnTypesRenamed();
			types.OnTypesRenamed();
		}

		public bool IsNested() => NestingType != null;

		public bool IsGlobalType() {
			if (!IsNested())
				return TypeDef.IsPublic;
			switch (TypeDef.Visibility) {
			case TypeAttributes.NestedPrivate:
			case TypeAttributes.NestedAssembly:
			case TypeAttributes.NestedFamANDAssem:
				return false;
			case TypeAttributes.NestedPublic:
			case TypeAttributes.NestedFamily:
			case TypeAttributes.NestedFamORAssem:
				return NestingType.IsGlobalType();
			default:
				return false;
			}
		}

		public void InitializeVirtualMembers(MethodNameGroups groups, IResolver resolver) {
			if (initializeVirtualMembersCalled)
				return;
			initializeVirtualMembersCalled = true;

			foreach (var iface in interfaces)
				iface.typeDef.InitializeVirtualMembers(groups, resolver);
			if (baseType != null)
				baseType.typeDef.InitializeVirtualMembers(groups, resolver);

			foreach (var methodDef in methods.GetValues()) {
				if (methodDef.IsVirtual())
					groups.Add(methodDef);
			}

			InstantiateVirtualMembers(groups);
			InitializeInterfaceMethods(groups);
		}

		void InitializeAllInterfaces() {
			if (baseType != null)
				InitializeInterfaces(baseType);

			foreach (var iface in interfaces) {
				allImplementedInterfaces[iface] = true;
				interfaceMethodInfos.AddInterface(iface);
				InitializeInterfaces(iface);
			}
		}

		void InitializeInterfaces(TypeInfo typeInfo) {
			var git = typeInfo.typeRef.TryGetGenericInstSig();
			interfaceMethodInfos.InitializeFrom(typeInfo.typeDef.interfaceMethodInfos, git);
			foreach (var info in typeInfo.typeDef.allImplementedInterfaces.Keys) {
				var newTypeInfo = new TypeInfo(info, git);
				allImplementedInterfaces[newTypeInfo] = true;
			}
		}

		void InitializeInterfaceMethods(MethodNameGroups groups) {
			InitializeAllInterfaces();

			if (TypeDef.IsInterface)
				return;

			//--- Partition II 12.2 Implementing virtual methods on interfaces:
			//--- The VES shall use the following algorithm to determine the appropriate
			//--- implementation of an interface's virtual abstract methods:
			//---
			//--- * If the base class implements the interface, start with the same virtual methods
			//---	that it provides; otherwise, create an interface that has empty slots for all
			//---	virtual functions.
			// Done. See initializeAllInterfaces().

			var methodsDict = new Dictionary<IMethodDefOrRef, MMethodDef>(MethodEqualityComparer.DontCompareDeclaringTypes);

			//--- * If this class explicitly specifies that it implements the interface (i.e., the
			//---	interfaces that appear in this classâ€˜ InterfaceImpl table, Â§22.23)
			//---	* If the class defines any public virtual newslot methods whose name and
			//---	  signature match a virtual method on the interface, then use these new virtual
			//---	  methods to implement the corresponding interface method.
			if (interfaces.Count > 0) {
				methodsDict.Clear();
				foreach (var method in methods.GetValues()) {
					if (!method.IsPublic() || !method.IsVirtual() || !method.IsNewSlot())
						continue;
					methodsDict[method.MethodDef] = method;
				}

				foreach (var ifaceInfo in interfaces) {
					foreach (var methodsList in ifaceInfo.typeDef.virtualMethodInstances.GetMethods()) {
						if (methodsList.Count < 1)
							continue;
						var methodInst = methodsList[0];
						var ifaceMethod = methodInst.origMethodDef;
						if (!ifaceMethod.IsVirtual())
							continue;
						var ifaceMethodRef = GenericArgsSubstitutor.Create(methodInst.methodRef, ifaceInfo.typeRef.TryGetGenericInstSig());
						if (!methodsDict.TryGetValue(ifaceMethodRef, out var classMethod))
							continue;
						interfaceMethodInfos.AddMethod(ifaceInfo, ifaceMethod, classMethod);
					}
				}
			}

			//--- * If there are any virtual methods in the interface that still have empty slots,
			//---	see if there are any public virtual methods, but not public virtual newslot
			//---	methods, available on this class (directly or inherited) having the same name
			//---	and signature, then use these to implement the corresponding methods on the
			//---	interface.
			methodsDict.Clear();
			foreach (var methodInstList in virtualMethodInstances.GetMethods()) {
				// This class' method is at the end
				for (int i = methodInstList.Count - 1; i >= 0; i--) {
					var classMethod = methodInstList[i];
					// These methods are guaranteed to be virtual.
					// We should allow newslot methods, despite what the official doc says.
					if (!classMethod.origMethodDef.IsPublic())
						continue;
					methodsDict[classMethod.methodRef] = classMethod.origMethodDef;
					break;
				}
			}
			foreach (var ifaceInfo in allImplementedInterfaces.Keys) {
				foreach (var methodsList in ifaceInfo.typeDef.virtualMethodInstances.GetMethods()) {
					if (methodsList.Count < 1)
						continue;
					var ifaceMethod = methodsList[0].origMethodDef;
					if (!ifaceMethod.IsVirtual())
						continue;
					var ifaceMethodRef = GenericArgsSubstitutor.Create(ifaceMethod.MethodDef, ifaceInfo.typeRef.TryGetGenericInstSig());
					if (!methodsDict.TryGetValue(ifaceMethodRef, out var classMethod))
						continue;
					interfaceMethodInfos.AddMethodIfEmpty(ifaceInfo, ifaceMethod, classMethod);
				}
			}

			//--- * Apply all MethodImpls that are specified for this class, thereby placing
			//---	explicitly specified virtual methods into the interface in preference to those
			//---	inherited or chosen by name matching.
			methodsDict.Clear();
			var ifaceMethodsDict = new Dictionary<IMethodDefOrRef, MMethodDef>(MethodEqualityComparer.CompareDeclaringTypes);
			foreach (var ifaceInfo in allImplementedInterfaces.Keys) {
				var git = ifaceInfo.typeRef.TryGetGenericInstSig();
				foreach (var ifaceMethod in ifaceInfo.typeDef.methods.GetValues()) {
					IMethodDefOrRef ifaceMethodRef = ifaceMethod.MethodDef;
					if (git != null)
						ifaceMethodRef = SimpleClone(ifaceMethod.MethodDef, ifaceInfo.typeRef);
					ifaceMethodsDict[ifaceMethodRef] = ifaceMethod;
				}
			}
			foreach (var classMethod in methods.GetValues()) {
				if (!classMethod.IsVirtual())
					continue;
				foreach (var overrideMethod in classMethod.MethodDef.Overrides) {
					if (!ifaceMethodsDict.TryGetValue(overrideMethod.MethodDeclaration, out var ifaceMethod)) {
						// We couldn't find the interface method (eg. interface not resolved) or
						// it overrides a base class method, and not an interface method.
						continue;
					}

					interfaceMethodInfos.AddMethod(overrideMethod.MethodDeclaration.DeclaringType, ifaceMethod, classMethod);
				}
			}

			//--- * If the current class is not abstract and there are any interface methods that
			//---	still have empty slots, then the program is invalid.
			// Check it anyway. C# requires a method, even if it's abstract. I don't think anyone
			// writes pure CIL assemblies.
			foreach (var info in interfaceMethodInfos.AllInfos) {
				foreach (var pair in info.IfaceMethodToClassMethod) {
					if (pair.Value != null)
						continue;
					if (!ResolvedAllInterfaces() || !ResolvedBaseClasses())
						continue;
					// Ignore if COM class
					if (!TypeDef.IsImport &&
						!HasAttribute("System.Runtime.InteropServices.ComImportAttribute") &&
						!HasAttribute("System.Runtime.InteropServices.TypeLibTypeAttribute")) {
						Logger.w("Could not find interface method {0} ({1:X8}). Type: {2} ({3:X8})",
								Utils.RemoveNewlines(pair.Key.methodDef.MethodDef),
								pair.Key.methodDef.MethodDef.MDToken.ToInt32(),
								Utils.RemoveNewlines(TypeDef),
								TypeDef.MDToken.ToInt32());
					}
				}
			}

			foreach (var info in interfaceMethodInfos.AllInfos) {
				foreach (var pair in info.IfaceMethodToClassMethod) {
					if (pair.Value == null)
						continue;
					if (pair.Key.methodDef.MethodDef.Name != pair.Value.MethodDef.Name)
						continue;
					groups.Same(pair.Key.methodDef, pair.Value);
				}
			}
		}

		bool HasAttribute(string name) {
			foreach (var attr in TypeDef.CustomAttributes) {
				if (attr.TypeFullName == name)
					return true;
			}
			return false;
		}

		// Returns true if all interfaces have been resolved
		bool? resolvedAllInterfacesResult;
		bool ResolvedAllInterfaces() {
			if (!resolvedAllInterfacesResult.HasValue) {
				resolvedAllInterfacesResult = true;	// If we find a circular reference
				resolvedAllInterfacesResult = ResolvedAllInterfacesInternal();
			}
			return resolvedAllInterfacesResult.Value;
		}
		bool ResolvedAllInterfacesInternal() {
			if (TypeDef.Interfaces.Count != interfaces.Count)
				return false;
			foreach (var ifaceInfo in interfaces) {
				if (!ifaceInfo.typeDef.ResolvedAllInterfaces())
					return false;
			}
			return true;
		}

		// Returns true if all base classes have been resolved
		bool? resolvedBaseClassesResult;
		bool ResolvedBaseClasses() {
			if (!resolvedBaseClassesResult.HasValue) {
				resolvedBaseClassesResult = true;	// If we find a circular reference
				resolvedBaseClassesResult = ResolvedBaseClassesInternal();
			}
			return resolvedBaseClassesResult.Value;
		}
		bool ResolvedBaseClassesInternal() {
			if (TypeDef.BaseType == null)
				return true;
			if (baseType == null)
				return false;
			return baseType.typeDef.ResolvedBaseClasses();
		}

		MemberRef SimpleClone(MethodDef methodRef, ITypeDefOrRef declaringType) {
			if (module == null)
				return new MemberRefUser(null, methodRef.Name, methodRef.MethodSig, declaringType);
			var mr = new MemberRefUser(module.ModuleDefMD, methodRef.Name, methodRef.MethodSig, declaringType);
			return module.ModuleDefMD.UpdateRowId(mr);
		}

		void InstantiateVirtualMembers(MethodNameGroups groups) {
			if (!TypeDef.IsInterface) {
				if (baseType != null)
					virtualMethodInstances.InitializeFrom(baseType.typeDef.virtualMethodInstances, baseType.typeRef.TryGetGenericInstSig());

				// Figure out which methods we override in the base class
				foreach (var methodDef in methods.GetValues()) {
					if (!methodDef.IsVirtual() || methodDef.IsNewSlot())
						continue;
					var methodInstList = virtualMethodInstances.Lookup(methodDef.MethodDef);
					if (methodInstList == null)
						continue;
					foreach (var methodInst in methodInstList)
						groups.Same(methodDef, methodInst.origMethodDef);
				}
			}

			foreach (var methodDef in methods.GetValues()) {
				if (!methodDef.IsVirtual())
					continue;
				virtualMethodInstances.Add(new MethodInst(methodDef, methodDef.MethodDef));
			}
		}
	}
}



================================================
File: de4dot.cui/CommandLineParser.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Writer;
using de4dot.code;
using de4dot.code.deobfuscators;
using de4dot.code.AssemblyClient;
using de4dot.code.renamer;

namespace de4dot.cui {
	class CommandLineParser {
		static Infos stringDecrypterTypes = new Infos();

		ObfuscatedFile.Options newFileOptions = null;
		IList<IObfuscatedFile> files = new List<IObfuscatedFile>();
		Dictionary<string, Option> optionsDict = new Dictionary<string, Option>(StringComparer.Ordinal);
		IList<IDeobfuscatorInfo> deobfuscatorInfos;
		IList<Option> miscOptions = new List<Option>();
		IList<Option> fileOptions = new List<Option>();
		Option defaultOption;
		FilesDeobfuscator.Options filesOptions;
		FilesDeobfuscator.SearchDir searchDir;
		DecrypterType? defaultStringDecrypterType;
		List<string> defaultStringDecrypterMethods = new List<string>();

		class Info {
			public object value;
			public string name;
			public string desc;

			public Info(object value, string name, string desc) {
				this.value = value;
				this.name = name;
				this.desc = desc;
			}
		}

		class Infos {
			List<Info> infos = new List<Info>();

			public void Add(object value, string name, string desc) => infos.Add(new Info(value, name, desc));
			public IEnumerable<Info> GetInfos() => infos;

			public bool GetValue(string name, out object value) {
				foreach (var info in infos) {
					if (name.Equals(info.name, StringComparison.OrdinalIgnoreCase)) {
						value = info.value;
						return true;
					}
				}
				value = null;
				return false;
			}
		}

		static CommandLineParser() {
			stringDecrypterTypes.Add(DecrypterType.None, "none", "Don't decrypt strings");
			stringDecrypterTypes.Add(DecrypterType.Default, "default", "Use default string decrypter type (usually static)");
			stringDecrypterTypes.Add(DecrypterType.Static, "static", "Use static string decrypter if available");
			stringDecrypterTypes.Add(DecrypterType.Delegate, "delegate", "Use a delegate to call the real string decrypter");
			stringDecrypterTypes.Add(DecrypterType.Emulate, "emulate", "Call real string decrypter and emulate certain instructions");
		}

		public CommandLineParser(IList<IDeobfuscatorInfo> deobfuscatorInfos, FilesDeobfuscator.Options filesOptions) {
			this.deobfuscatorInfos = deobfuscatorInfos;
			this.filesOptions = filesOptions;
			this.filesOptions.DeobfuscatorInfos = deobfuscatorInfos;
			this.filesOptions.AssemblyClientFactory = new NewAppDomainAssemblyClientFactory();

			AddAllOptions();
		}

		void AddAllOptions() {
			miscOptions.Add(new OneArgOption("r", null, "Scan for .NET files in all subdirs", "dir", (val) => {
				AddSearchDir();
				searchDir = new FilesDeobfuscator.SearchDir();
				if (!Utils.PathExists(val))
					ExitError($"Directory {val} does not exist");
				searchDir.InputDirectory = val;
			}));
			miscOptions.Add(new OneArgOption("ro", null, "Output base dir for recursively found files", "dir", (val) => {
				if (searchDir == null)
					ExitError("Missing -r option");
				searchDir.OutputDirectory = val;
			}));
			miscOptions.Add(new NoArgOption("ru", null, "Skip recursively found files with unsupported obfuscator", () => {
				if (searchDir == null)
					ExitError("Missing -r option");
				searchDir.SkipUnknownObfuscators = true;
			}));
			miscOptions.Add(new NoArgOption("d", null, "Detect obfuscators and exit", () => {
				filesOptions.DetectObfuscators = true;
			}));
			miscOptions.Add(new OneArgOption(null, "asm-path", "Add an assembly search path", "path", (val) => {
				TheAssemblyResolver.Instance.AddSearchDirectory(val);
			}));
			miscOptions.Add(new NoArgOption(null, "dont-rename", "Don't rename classes, methods, etc.", () => {
				filesOptions.RenameSymbols = false;
				filesOptions.RenamerFlags = 0;
			}));
			miscOptions.Add(new OneArgOption(null, "keep-names", "Don't rename n(amespaces), t(ypes), p(rops), e(vents), f(ields), m(ethods), a(rgs), g(enericparams), d(elegate fields). Can be combined, eg. efm", "flags", (val) => {
				foreach (var c in val) {
					switch (c) {
					case 'n': filesOptions.RenamerFlags &= ~RenamerFlags.RenameNamespaces; break;
					case 't': filesOptions.RenamerFlags &= ~RenamerFlags.RenameTypes; break;
					case 'p': filesOptions.RenamerFlags &= ~RenamerFlags.RenameProperties; break;
					case 'e': filesOptions.RenamerFlags &= ~RenamerFlags.RenameEvents; break;
					case 'f': filesOptions.RenamerFlags &= ~RenamerFlags.RenameFields; break;
					case 'm': filesOptions.RenamerFlags &= ~RenamerFlags.RenameMethods; break;
					case 'a': filesOptions.RenamerFlags &= ~RenamerFlags.RenameMethodArgs; break;
					case 'g': filesOptions.RenamerFlags &= ~RenamerFlags.RenameGenericParams; break;
					case 'd': filesOptions.RenamerFlags |= RenamerFlags.DontRenameDelegateFields; break;
					default: throw new UserException($"Unrecognized --keep-names char: '{c}'");
					}
				}
			}));
			miscOptions.Add(new NoArgOption(null, "dont-create-params", "Don't create method params when renaming", () => {
				filesOptions.RenamerFlags |= RenamerFlags.DontCreateNewParamDefs;
			}));
			miscOptions.Add(new NoArgOption(null, "dont-restore-props", "Don't restore properties/events", () => {
				filesOptions.RenamerFlags &= ~(RenamerFlags.RestorePropertiesFromNames | RenamerFlags.RestoreEventsFromNames);
			}));
			miscOptions.Add(new OneArgOption(null, "default-strtyp", "Default string decrypter type", "type", (val) => {
				if (!stringDecrypterTypes.GetValue(val, out object decrypterType))
					ExitError($"Invalid string decrypter type '{val}'");
				defaultStringDecrypterType = (DecrypterType)decrypterType;
			}));
			miscOptions.Add(new OneArgOption(null, "default-strtok", "Default string decrypter method token or [type::][name][(args,...)]", "method", (val) => {
				defaultStringDecrypterMethods.Add(val);
			}));
			miscOptions.Add(new NoArgOption(null, "no-cflow-deob", "No control flow deobfuscation (NOT recommended)", () => {
				filesOptions.ControlFlowDeobfuscation = false;
			}));
			miscOptions.Add(new NoArgOption(null, "only-cflow-deob", "Only control flow deobfuscation", () => {
				filesOptions.ControlFlowDeobfuscation = true;
				// --strtyp none
				defaultStringDecrypterType = DecrypterType.None;
				// --keep-types
				filesOptions.KeepObfuscatorTypes = true;
				// --preserve-tokens
				filesOptions.MetadataFlags |= MetadataFlags.PreserveRids |
						MetadataFlags.PreserveUSOffsets |
						MetadataFlags.PreserveBlobOffsets |
						MetadataFlags.PreserveExtraSignatureData;
				// --dont-rename
				filesOptions.RenameSymbols = false;
				filesOptions.RenamerFlags = 0;
			}));
			miscOptions.Add(new NoArgOption(null, "load-new-process", "Load executed assemblies into a new process", () => {
				filesOptions.AssemblyClientFactory = new NewProcessAssemblyClientFactory();
			}));
			miscOptions.Add(new NoArgOption(null, "keep-types", "Keep obfuscator types, fields, methods", () => {
				filesOptions.KeepObfuscatorTypes = true;
			}));
			miscOptions.Add(new NoArgOption(null, "preserve-tokens", "Preserve important tokens, #US, #Blob, extra sig data", () => {
				filesOptions.MetadataFlags |= MetadataFlags.PreserveRids |
						MetadataFlags.PreserveUSOffsets |
						MetadataFlags.PreserveBlobOffsets |
						MetadataFlags.PreserveExtraSignatureData;
			}));
			miscOptions.Add(new OneArgOption(null, "preserve-table", "Preserve rids in table: tr (TypeRef), td (TypeDef), fd (Field), md (Method), pd (Param), mr (MemberRef), s (StandAloneSig), ed (Event), pr (Property), ts (TypeSpec), ms (MethodSpec), all (all previous tables). Use - to disable (eg. all,-pd). Can be combined: ed,fd,md", "flags", (val) => {
				foreach (var t in val.Split(',')) {
					var s = t.Trim();
					if (s.Length == 0)
						continue;
					bool clear = s[0] == '-';
					if (clear)
						s = s.Substring(1);
					MetadataFlags flag;
					switch (s.Trim()) {
					case "": flag = 0; break;
					case "all": flag = MetadataFlags.PreserveRids; break;
					case "tr": flag = MetadataFlags.PreserveTypeRefRids; break;
					case "td": flag = MetadataFlags.PreserveTypeDefRids; break;
					case "fd": flag = MetadataFlags.PreserveFieldRids; break;
					case "md": flag = MetadataFlags.PreserveMethodRids; break;
					case "pd": flag = MetadataFlags.PreserveParamRids; break;
					case "mr": flag = MetadataFlags.PreserveMemberRefRids; break;
					case "s": flag = MetadataFlags.PreserveStandAloneSigRids; break;
					case "ed": flag = MetadataFlags.PreserveEventRids; break;
					case "pr": flag = MetadataFlags.PreservePropertyRids; break;
					case "ts": flag = MetadataFlags.PreserveTypeSpecRids; break;
					case "ms": flag = MetadataFlags.PreserveMethodSpecRids; break;
					default: throw new UserException($"Invalid --preserve-table option: {s}");
					}
					if (clear)
						filesOptions.MetadataFlags &= ~flag;
					else
						filesOptions.MetadataFlags |= flag;
				}
			}));
			miscOptions.Add(new NoArgOption(null, "preserve-strings", "Preserve #Strings heap offsets", () => {
				filesOptions.MetadataFlags |= MetadataFlags.PreserveStringsOffsets;
			}));
			miscOptions.Add(new NoArgOption(null, "preserve-us", "Preserve #US heap offsets", () => {
				filesOptions.MetadataFlags |= MetadataFlags.PreserveUSOffsets;
			}));
			miscOptions.Add(new NoArgOption(null, "preserve-blob", "Preserve #Blob heap offsets", () => {
				filesOptions.MetadataFlags |= MetadataFlags.PreserveBlobOffsets;
			}));
			miscOptions.Add(new NoArgOption(null, "preserve-sig-data", "Preserve extra data at the end of signatures", () => {
				filesOptions.MetadataFlags |= MetadataFlags.PreserveExtraSignatureData;
			}));
			miscOptions.Add(new NoArgOption(null, "one-file", "Deobfuscate one file at a time", () => {
				filesOptions.OneFileAtATime = true;
			}));
			miscOptions.Add(new NoArgOption("v", null, "Verbose", () => {
				Logger.Instance.MaxLoggerEvent = LoggerEvent.Verbose;
				Logger.Instance.CanIgnoreMessages = false;
			}));
			miscOptions.Add(new NoArgOption("vv", null, "Very verbose", () => {
				Logger.Instance.MaxLoggerEvent = LoggerEvent.VeryVerbose;
				Logger.Instance.CanIgnoreMessages = false;
			}));
			miscOptions.Add(new NoArgOption("h", "help", "Show this help message", () => {
				Usage();
				Exit(0);
			}));

			defaultOption = new OneArgOption("f", null, "Name of .NET file", "file", (val) => {
				AddFile();
				if (!Utils.FileExists(val))
					ExitError($"File \"{val}\" does not exist.");
				newFileOptions = new ObfuscatedFile.Options {
					Filename = val,
					ControlFlowDeobfuscation = filesOptions.ControlFlowDeobfuscation,
					KeepObfuscatorTypes = filesOptions.KeepObfuscatorTypes,
					MetadataFlags = filesOptions.MetadataFlags,
					RenamerFlags = filesOptions.RenamerFlags,
				};
				if (defaultStringDecrypterType != null)
					newFileOptions.StringDecrypterType = defaultStringDecrypterType.Value;
				newFileOptions.StringDecrypterMethods.AddRange(defaultStringDecrypterMethods);
			});
			fileOptions.Add(defaultOption);
			fileOptions.Add(new OneArgOption("o", null, "Name of output file", "file", (val) => {
				if (newFileOptions == null)
					ExitError("Missing input file");
				var newFilename = Utils.GetFullPath(val);
				if (string.Equals(Utils.GetFullPath(newFileOptions.Filename), newFilename, StringComparison.OrdinalIgnoreCase))
					ExitError($"Output file can't be same as input file ({newFilename})");
				newFileOptions.NewFilename = newFilename;
			}));
			fileOptions.Add(new OneArgOption("p", null, "Obfuscator type (see below)", "type", (val) => {
				if (newFileOptions == null)
					ExitError("Missing input file");
				if (!IsValidObfuscatorType(val))
					ExitError($"Invalid obfuscator type '{val}'");
				newFileOptions.ForcedObfuscatorType = val;
			}));
			fileOptions.Add(new OneArgOption(null, "strtyp", "String decrypter type", "type", (val) => {
				if (newFileOptions == null)
					ExitError("Missing input file");
				if (!stringDecrypterTypes.GetValue(val, out object decrypterType))
					ExitError($"Invalid string decrypter type '{val}'");
				newFileOptions.StringDecrypterType = (DecrypterType)decrypterType;
			}));
			fileOptions.Add(new OneArgOption(null, "strtok", "String decrypter method token or [type::][name][(args,...)]", "method", (val) => {
				if (newFileOptions == null)
					ExitError("Missing input file");
				newFileOptions.StringDecrypterMethods.Add(val);
			}));

			AddOptions(miscOptions);
			AddOptions(fileOptions);
			foreach (var info in deobfuscatorInfos)
				AddOptions(info.GetOptions());
		}

		void AddOptions(IEnumerable<Option> options) {
			foreach (var option in options) {
				AddOption(option, option.ShortName);
				AddOption(option, option.LongName);
			}
		}

		void AddOption(Option option, string name) {
			if (name == null)
				return;
			if (optionsDict.ContainsKey(name))
				throw new ApplicationException($"Option {name} is present twice!");
			optionsDict[name] = option;
		}

		public void Parse(string[] args) {
			if (args.Length == 0) {
				Usage();
				Exit(1);
			}

			for (int i = 0; i < args.Length; i++) {
				var arg = args[i];

				string val = null;
				if (optionsDict.TryGetValue(arg, out var option)) {
					if (option.NeedArgument) {
						if (++i >= args.Length)
							ExitError("Missing options value");
						val = args[i];
					}
				}
				else {
					option = defaultOption;
					val = arg;
				}

				if (!option.Set(val, out string errorString))
					ExitError(errorString);
			}
			AddFile();
			AddSearchDir();
			filesOptions.Files = files;
			filesOptions.DefaultStringDecrypterMethods.AddRange(defaultStringDecrypterMethods);
			filesOptions.DefaultStringDecrypterType = defaultStringDecrypterType;
		}

		void AddFile() {
			if (newFileOptions == null)
				return;
			files.Add(new ObfuscatedFile(newFileOptions, filesOptions.ModuleContext, filesOptions.AssemblyClientFactory));
			newFileOptions = null;
		}

		void AddSearchDir() {
			if (searchDir == null)
				return;
			filesOptions.SearchDirs.Add(searchDir);
			searchDir = null;
		}

		bool IsValidObfuscatorType(string type) {
			foreach (var info in deobfuscatorInfos) {
				if (string.Equals(info.Type, type, StringComparison.OrdinalIgnoreCase))
					return true;
			}
			return false;
		}

		void ExitError(string msg) {
			Usage();
			Logger.Instance.LogErrorDontIgnore("\n\nERROR: {0}\n", msg);
			Exit(2);
		}

		void Exit(int exitCode) => throw new ExitException(exitCode);

		void Usage() {
			string progName = GetProgramBaseName();
			Logger.n("Some of the advanced options may be incompatible, causing a nice exception.");
			Logger.n("With great power comes great responsibility.");
			Logger.n("");
			Logger.n("{0} <options> <file options>", progName);
			Logger.n("Options:");
			foreach (var option in miscOptions)
				PrintOption(option);
			Logger.n("");
			Logger.n("File options:");
			foreach (var option in fileOptions)
				PrintOption(option);
			Logger.n("");
			Logger.n("Deobfuscator options:");
			foreach (var info in deobfuscatorInfos) {
				Logger.n("Type {0} ({1})", info.Type, info.Name);
				foreach (var option in info.GetOptions())
					PrintOption(option);
				Logger.n("");
			}
			PrintInfos("String decrypter types", stringDecrypterTypes);
			Logger.n("");
			Logger.n("Multiple regexes can be used if separated by '{0}'.", NameRegexes.regexSeparatorChar);
			Logger.n("Use '{0}' if you want to invert the regex. Example: {0}^[a-z\\d]{{1,2}}${1}{0}^[A-Z]_\\d+${1}^[\\w.]+$", NameRegex.invertChar, NameRegexes.regexSeparatorChar);
			Logger.n("");
			Logger.n("Examples:");
			Logger.n("{0} -r c:\\my\\files -ro c:\\my\\output", progName);
			Logger.n("{0} file1 file2 file3", progName);
			Logger.n("{0} file1 -f file2 -o file2.out -f file3 -o file3.out", progName);
			Logger.n("{0} file1 --strtyp delegate --strtok 06000123", progName);
		}

		string GetProgramBaseName() => Utils.GetBaseName(Environment.GetCommandLineArgs()[0]);

		void PrintInfos(string desc, Infos infos) {
			Logger.n("{0}", desc);
			foreach (var info in infos.GetInfos())
				PrintOptionAndExplanation(info.name, info.desc);
		}

		void PrintOption(Option option) {
			string defaultAndDesc;
			if (option.NeedArgument && option.Default != null)
				defaultAndDesc = $"{option.Description} ({option.Default})";
			else
				defaultAndDesc = option.Description;
			PrintOptionAndExplanation(GetOptionAndArgName(option, option.ShortName ?? option.LongName), defaultAndDesc);
			if (option.ShortName != null && option.LongName != null)
				PrintOptionAndExplanation(option.LongName, $"Same as {option.ShortName}");
		}

		void PrintOptionAndExplanation(string option, string explanation) {
			const int maxCols = 16;
			const string prefix = "  ";
			string left = string.Format($"{{0,-{maxCols}}}", option);
			if (option.Length > maxCols) {
				Logger.n("{0}{1}", prefix, left);
				Logger.n("{0}{1} {2}", prefix, new string(' ', maxCols), explanation);
			}
			else
				Logger.n("{0}{1} {2}", prefix, left, explanation);
		}

		string GetOptionAndArgName(Option option, string optionName) {
			if (option.NeedArgument)
				return optionName + " " + option.ArgumentValueName.ToUpperInvariant();
			else
				return optionName;
		}
	}
}



================================================
File: de4dot.cui/FilesDeobfuscator.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.IO;
using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Writer;
using de4dot.code;
using de4dot.code.renamer;
using de4dot.code.deobfuscators;
using de4dot.code.AssemblyClient;

namespace de4dot.cui {
	class FilesDeobfuscator {
		Options options;
		IDeobfuscatorContext deobfuscatorContext = new DeobfuscatorContext();

		public class Options {
			public ModuleContext ModuleContext { get; set; }
			public IList<IDeobfuscatorInfo> DeobfuscatorInfos { get; set; }
			public IList<IObfuscatedFile> Files { get; set; }
			public IList<SearchDir> SearchDirs { get; set; }
			public MetadataFlags MetadataFlags { get; set; }
			public bool DetectObfuscators { get; set; }
			public RenamerFlags RenamerFlags { get; set; }
			public bool RenameSymbols { get; set; }
			public bool ControlFlowDeobfuscation { get; set; }
			public bool KeepObfuscatorTypes { get; set; }
			public bool OneFileAtATime { get; set; }
			public DecrypterType? DefaultStringDecrypterType { get; set; }
			public List<string> DefaultStringDecrypterMethods { get; private set; }
			public IAssemblyClientFactory AssemblyClientFactory { get; set; }

			public Options() {
				ModuleContext = new ModuleContext(TheAssemblyResolver.Instance);
				DeobfuscatorInfos = new List<IDeobfuscatorInfo>();
				Files = new List<IObfuscatedFile>();
				SearchDirs = new List<SearchDir>();
				DefaultStringDecrypterMethods = new List<string>();
				RenamerFlags = RenamerFlags.RenameNamespaces |
						RenamerFlags.RenameTypes |
						RenamerFlags.RenameProperties |
						RenamerFlags.RenameEvents |
						RenamerFlags.RenameFields |
						RenamerFlags.RenameMethods |
						RenamerFlags.RenameMethodArgs |
						RenamerFlags.RenameGenericParams |
						RenamerFlags.RestorePropertiesFromNames |
						RenamerFlags.RestoreEventsFromNames |
						RenamerFlags.RestoreProperties |
						RenamerFlags.RestoreEvents;
				RenameSymbols = true;
				ControlFlowDeobfuscation = true;
			}
		}

		public class SearchDir {
			public string InputDirectory { get; set; }
			public string OutputDirectory { get; set; }
			public bool SkipUnknownObfuscators { get; set; }
		}

		public FilesDeobfuscator(Options options) => this.options = options;

		public void DoIt() {
			if (options.DetectObfuscators)
				DetectObfuscators();
			else if (options.OneFileAtATime)
				DeobfuscateOneAtATime();
			else
				DeobfuscateAll();
		}

		static void RemoveModule(ModuleDef module) => TheAssemblyResolver.Instance.Remove(module);

		void DetectObfuscators() {
			foreach (var file in LoadAllFiles(true)) {
				RemoveModule(file.ModuleDefMD);
				file.Dispose();
				deobfuscatorContext.Clear();
			}
		}

		void DeobfuscateOneAtATime() {
			foreach (var file in LoadAllFiles()) {
				int oldIndentLevel = Logger.Instance.IndentLevel;
				try {
					file.DeobfuscateBegin();
					file.Deobfuscate();
					file.DeobfuscateEnd();
					Rename(new List<IObfuscatedFile> { file });
					file.Save();

					RemoveModule(file.ModuleDefMD);
					TheAssemblyResolver.Instance.ClearAll();
					deobfuscatorContext.Clear();
				}
				catch (Exception ex) {
					Logger.Instance.Log(false, null, LoggerEvent.Warning, "Could not deobfuscate {0}. Use -v to see stack trace", file.Filename);
					Program.PrintStackTrace(ex, LoggerEvent.Verbose);
				}
				finally {
					file.Dispose();
					Logger.Instance.IndentLevel = oldIndentLevel;
				}
			}
		}

		void DeobfuscateAll() {
			var allFiles = new List<IObfuscatedFile>(LoadAllFiles());
			try {
				DeobfuscateAllFiles(allFiles);
				Rename(allFiles);
				SaveAllFiles(allFiles);
			}
			finally {
				foreach (var file in allFiles) {
					if (file != null)
						file.Dispose();
				}
			}
		}

		IEnumerable<IObfuscatedFile> LoadAllFiles() => LoadAllFiles(false);

		IEnumerable<IObfuscatedFile> LoadAllFiles(bool onlyScan) {
			var loader = new DotNetFileLoader(new DotNetFileLoader.Options {
				ModuleContext = options.ModuleContext,
				PossibleFiles  = options.Files,
				SearchDirs = options.SearchDirs,
				CreateDeobfuscators = () => CreateDeobfuscators(),
				DefaultStringDecrypterType = options.DefaultStringDecrypterType,
				DefaultStringDecrypterMethods = options.DefaultStringDecrypterMethods,
				AssemblyClientFactory = options.AssemblyClientFactory,
				DeobfuscatorContext = deobfuscatorContext,
				ControlFlowDeobfuscation = options.ControlFlowDeobfuscation,
				KeepObfuscatorTypes = options.KeepObfuscatorTypes,
				MetadataFlags = options.MetadataFlags,
				RenamerFlags = options.RenamerFlags,
				CreateDestinationDir = !onlyScan,
			});

			foreach (var file in loader.Load())
				yield return file;
		}

		class DotNetFileLoader {
			Options options;
			Dictionary<string, bool> allFiles = new Dictionary<string, bool>(StringComparer.OrdinalIgnoreCase);
			Dictionary<string, bool> visitedDirectory = new Dictionary<string, bool>(StringComparer.OrdinalIgnoreCase);

			public class Options {
				public ModuleContext ModuleContext { get; set; }
				public IEnumerable<IObfuscatedFile> PossibleFiles { get; set; }
				public IEnumerable<SearchDir> SearchDirs { get; set; }
				public Func<IList<IDeobfuscator>> CreateDeobfuscators { get; set; }
				public DecrypterType? DefaultStringDecrypterType { get; set; }
				public List<string> DefaultStringDecrypterMethods { get; set; }
				public IAssemblyClientFactory AssemblyClientFactory { get; set; }
				public IDeobfuscatorContext DeobfuscatorContext { get; set; }
				public bool ControlFlowDeobfuscation { get; set; }
				public bool KeepObfuscatorTypes { get; set; }
				public MetadataFlags MetadataFlags { get; set; }
				public RenamerFlags RenamerFlags { get; set; }
				public bool CreateDestinationDir { get; set; }
			}

			public DotNetFileLoader(Options options) => this.options = options;

			public IEnumerable<IObfuscatedFile> Load() {
				foreach (var file in options.PossibleFiles) {
					if (Add(file, false, true))
						yield return file;
				}

				foreach (var searchDir in options.SearchDirs) {
					foreach (var file in LoadFiles(searchDir))
						yield return file;
				}
			}

			bool Add(IObfuscatedFile file, bool skipUnknownObfuscator, bool isFromPossibleFiles) {
				var key = Utils.GetFullPath(file.Filename);
				if (allFiles.ContainsKey(key)) {
					Logger.Instance.Log(false, null, LoggerEvent.Warning, "Ingoring duplicate file: {0}", file.Filename);
					return false;
				}
				allFiles[key] = true;

				int oldIndentLevel = Logger.Instance.IndentLevel;
				try {
					file.DeobfuscatorContext = options.DeobfuscatorContext;
					file.Load(options.CreateDeobfuscators());
				}
				catch (NotSupportedException) {
					return false;	// Eg. unsupported architecture
				}
				catch (BadImageFormatException) {
					if (isFromPossibleFiles)
						Logger.Instance.Log(false, null, LoggerEvent.Warning, "The file isn't a .NET PE file: {0}", file.Filename);
					return false;	// Not a .NET file
				}
				catch (EndOfStreamException) {
					return false;
				}
				catch (IOException) {
					if (isFromPossibleFiles)
						Logger.Instance.Log(false, null, LoggerEvent.Warning, "The file isn't a .NET PE file: {0}", file.Filename);
					return false;	// Not a .NET file
				}
				catch (Exception ex) {
					Logger.Instance.Log(false, null, LoggerEvent.Warning, "Could not load file ({0}): {1}", ex.GetType(), file.Filename);
					return false;
				}
				finally {
					Logger.Instance.IndentLevel = oldIndentLevel;
				}

				var deob = file.Deobfuscator;
				if (skipUnknownObfuscator && deob.Type == "un") {
					Logger.v("Skipping unknown obfuscator: {0}", file.Filename);
					RemoveModule(file.ModuleDefMD);
					return false;
				}
				else {
					Logger.n("Detected {0} ({1})", deob.Name, file.Filename);
					if (options.CreateDestinationDir)
						CreateDirectories(Path.GetDirectoryName(file.NewFilename));
					return true;
				}
			}

			IEnumerable<IObfuscatedFile> LoadFiles(SearchDir searchDir) {
				DirectoryInfo di = null;
				bool ok = false;
				try {
					di = new DirectoryInfo(searchDir.InputDirectory);
					if (di.Exists)
						ok = true;
				}
				catch (System.Security.SecurityException) {
				}
				catch (ArgumentException) {
				}
				if (ok) {
					foreach (var filename in DoDirectoryInfo(searchDir, di)) {
						var obfuscatedFile = CreateObfuscatedFile(searchDir, filename);
						if (obfuscatedFile != null)
							yield return obfuscatedFile;
					}					
				}
			}

			IEnumerable<string> RecursiveAdd(SearchDir searchDir, IEnumerable<FileSystemInfo> fileSystemInfos) {
				foreach (var fsi in fileSystemInfos) {
					if ((int)(fsi.Attributes & System.IO.FileAttributes.Directory) != 0) {
						foreach (var filename in DoDirectoryInfo(searchDir, (DirectoryInfo)fsi))
							yield return filename;
					}
					else {
						var fi = (FileInfo)fsi;
						if (fi.Exists)
							yield return fi.FullName;
					}
				}
			}

			IEnumerable<string> DoDirectoryInfo(SearchDir searchDir, DirectoryInfo di) {
				if (!di.Exists)
					return new List<string>();

				if (visitedDirectory.ContainsKey(di.FullName))
					return new List<string>();
				visitedDirectory[di.FullName] = true;

				FileSystemInfo[] fsinfos;
				try {
					fsinfos = di.GetFileSystemInfos();
				}
				catch (UnauthorizedAccessException) {
					return new List<string>();
				}
				catch (IOException) {
					return new List<string>();
				}
				catch (System.Security.SecurityException) {
					return new List<string>();
				}
				return RecursiveAdd(searchDir, fsinfos);
			}

			IObfuscatedFile CreateObfuscatedFile(SearchDir searchDir, string filename) {
				var fileOptions = new ObfuscatedFile.Options {
					Filename = Utils.GetFullPath(filename),
					ControlFlowDeobfuscation = options.ControlFlowDeobfuscation,
					KeepObfuscatorTypes = options.KeepObfuscatorTypes,
					MetadataFlags = options.MetadataFlags,
					RenamerFlags = options.RenamerFlags,
				};
				if (options.DefaultStringDecrypterType != null)
					fileOptions.StringDecrypterType = options.DefaultStringDecrypterType.Value;
				fileOptions.StringDecrypterMethods.AddRange(options.DefaultStringDecrypterMethods);

				if (!string.IsNullOrEmpty(searchDir.OutputDirectory)) {
					var inDir = Utils.GetFullPath(searchDir.InputDirectory);
					var outDir = Utils.GetFullPath(searchDir.OutputDirectory);

					if (!Utils.StartsWith(fileOptions.Filename, inDir, StringComparison.OrdinalIgnoreCase))
						throw new UserException($"Filename {fileOptions.Filename} does not start with inDir {inDir}");

					var subDirs = fileOptions.Filename.Substring(inDir.Length);
					if (subDirs.Length > 0 && subDirs[0] == Path.DirectorySeparatorChar)
						subDirs = subDirs.Substring(1);
					fileOptions.NewFilename = Utils.GetFullPath(Path.Combine(outDir, subDirs));

					if (fileOptions.Filename.Equals(fileOptions.NewFilename, StringComparison.OrdinalIgnoreCase))
						throw new UserException($"Input and output filename is the same: {fileOptions.Filename}");
				}

				var obfuscatedFile = new ObfuscatedFile(fileOptions, options.ModuleContext, options.AssemblyClientFactory);
				if (Add(obfuscatedFile, searchDir.SkipUnknownObfuscators, false))
					return obfuscatedFile;
				obfuscatedFile.Dispose();
				return null;
			}

			void CreateDirectories(string path) {
				if (string.IsNullOrEmpty(path))
					return;
				try {
					var di = new DirectoryInfo(path);
					if (!di.Exists)
						di.Create();
				}
				catch (System.Security.SecurityException) {
				}
				catch (ArgumentException) {
				}
			}
		}

		void DeobfuscateAllFiles(IEnumerable<IObfuscatedFile> allFiles) {
			try {
				foreach (var file in allFiles)
					file.DeobfuscateBegin();
				foreach (var file in allFiles) {
					file.Deobfuscate();
					file.DeobfuscateEnd();
				}
			}
			finally {
				foreach (var file in allFiles)
					file.DeobfuscateCleanUp();
			}
		}

		void SaveAllFiles(IEnumerable<IObfuscatedFile> allFiles) {
			foreach (var file in allFiles)
				file.Save();
		}

		IList<IDeobfuscator> CreateDeobfuscators() {
			var list = new List<IDeobfuscator>(options.DeobfuscatorInfos.Count);
			foreach (var info in options.DeobfuscatorInfos)
				list.Add(info.CreateDeobfuscator());
			return list;
		}

		void Rename(IEnumerable<IObfuscatedFile> theFiles) {
			if (!options.RenameSymbols)
				return;
			var renamer = new Renamer(deobfuscatorContext, theFiles, options.RenamerFlags);
			renamer.Rename();
		}
	}
}



================================================
File: de4dot.cui/Program.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Text;
using dnlib.DotNet;
using de4dot.code;
using de4dot.code.deobfuscators;
using System.IO;
using System.Reflection;

namespace de4dot.cui {
	class ExitException : Exception {
		public readonly int code;
		public ExitException(int code) => this.code = code;
	}

	class Program {
		static IList<IDeobfuscatorInfo> deobfuscatorInfos = CreateDeobfuscatorInfos();

		static IList<IDeobfuscatorInfo> LoadPlugin(string assembly) {
			var plugins = new List<IDeobfuscatorInfo>();
			try {
				foreach (var item in Assembly.LoadFile(assembly).GetTypes()) {
					var interfaces = new List<Type>(item.GetInterfaces());
					if (item.IsClass && interfaces.Contains(typeof(IDeobfuscatorInfo)))
						plugins.Add((IDeobfuscatorInfo)Activator.CreateInstance(item));
				}
			}
			catch {
			}
			return plugins;
		}

		public static void GetPlugins(string directory, ref Dictionary<string, IDeobfuscatorInfo> result) {
			var plugins = new List<IDeobfuscatorInfo>();
			try {
				var files = Directory.GetFiles(directory, "deobfuscator.*.dll", SearchOption.TopDirectoryOnly);
				foreach (var file in files)
					plugins.AddRange(LoadPlugin(Path.GetFullPath(file)));
			}
			catch {
			}
			foreach(var p in plugins)
				result[p.Type] = p;
		}

		static IList<IDeobfuscatorInfo> CreateDeobfuscatorInfos() {
			var local = new List<IDeobfuscatorInfo> {
				new de4dot.code.deobfuscators.Unknown.DeobfuscatorInfo(),
				new de4dot.code.deobfuscators.Agile_NET.DeobfuscatorInfo(),
				new de4dot.code.deobfuscators.Babel_NET.DeobfuscatorInfo(),
				new de4dot.code.deobfuscators.CodeFort.DeobfuscatorInfo(),
				new de4dot.code.deobfuscators.CodeVeil.DeobfuscatorInfo(),
				new de4dot.code.deobfuscators.CodeWall.DeobfuscatorInfo(),
				new de4dot.code.deobfuscators.Confuser.DeobfuscatorInfo(),
				new de4dot.code.deobfuscators.CryptoObfuscator.DeobfuscatorInfo(),
				new de4dot.code.deobfuscators.DeepSea.DeobfuscatorInfo(),
				new de4dot.code.deobfuscators.Dotfuscator.DeobfuscatorInfo(),
				new de4dot.code.deobfuscators.dotNET_Reactor.v3.DeobfuscatorInfo(),
				new de4dot.code.deobfuscators.dotNET_Reactor.v4.DeobfuscatorInfo(),
				new de4dot.code.deobfuscators.Eazfuscator_NET.DeobfuscatorInfo(),
				new de4dot.code.deobfuscators.Goliath_NET.DeobfuscatorInfo(),
				new de4dot.code.deobfuscators.ILProtector.DeobfuscatorInfo(),
				new de4dot.code.deobfuscators.MaxtoCode.DeobfuscatorInfo(),
				new de4dot.code.deobfuscators.MPRESS.DeobfuscatorInfo(),
				new de4dot.code.deobfuscators.Rummage.DeobfuscatorInfo(),
				new de4dot.code.deobfuscators.Skater_NET.DeobfuscatorInfo(),
				new de4dot.code.deobfuscators.SmartAssembly.DeobfuscatorInfo(),
				new de4dot.code.deobfuscators.Spices_Net.DeobfuscatorInfo(),
				new de4dot.code.deobfuscators.Xenocode.DeobfuscatorInfo(),
			};
			var dict = new Dictionary<string, IDeobfuscatorInfo>();
			foreach (var d in local)
				dict[d.Type] = d;
			string pluginDir = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "bin");
			GetPlugins(pluginDir, ref dict);
			return new List<IDeobfuscatorInfo>(dict.Values);
		}

		public static int Main(string[] args) {
			int exitCode = 0;

			const string showAllMessagesEnvName = "SHOWALLMESSAGES";
			try {
				if (Console.OutputEncoding.IsSingleByte || Console.OutputEncoding.CodePage == 437)
					Console.OutputEncoding = new UTF8Encoding(false);

				Logger.Instance.CanIgnoreMessages = !HasEnv(showAllMessagesEnvName);

				Logger.n("");
				Logger.n("de4dot v{0}", System.Reflection.Assembly.GetExecutingAssembly().GetName().Version);
				Logger.n("");

				var options = new FilesDeobfuscator.Options();
				ParseCommandLine(args, options);
				new FilesDeobfuscator(options).DoIt();
			}
			catch (ExitException ex) {
				exitCode = ex.code;
			}
			catch (UserException ex) {
				Logger.Instance.LogErrorDontIgnore("{0}", ex.Message);
				exitCode = 1;
			}
			catch (Exception ex) {
				if (PrintFullStackTrace()) {
					PrintStackTrace(ex);
					Logger.Instance.LogErrorDontIgnore("\nTry the latest version!");
				}
				else {
					Logger.Instance.LogErrorDontIgnore("\n\n");
					Logger.Instance.LogErrorDontIgnore("Hmmmm... something didn't work. Try the latest version.");
				}
				exitCode = 1;
			}

			if (Logger.Instance.NumIgnoredMessages > 0) {
				if (Logger.Instance.NumIgnoredMessages == 1)
					Logger.n("Ignored {0} warning/error", Logger.Instance.NumIgnoredMessages);
				else
					Logger.n("Ignored {0} warnings/errors", Logger.Instance.NumIgnoredMessages);
				Logger.n("Use -v/-vv option or set environment variable {0}=1 to see all messages", showAllMessagesEnvName);
			}

			if (IsN00bUser()) {
				Console.Error.WriteLine("\n\nPress any key to exit...\n");
				try {
					Console.ReadKey(true);
				}
				catch (InvalidOperationException) {
				}
			}

			return exitCode;
		}

		static bool PrintFullStackTrace() {
			if (!Logger.Instance.IgnoresEvent(LoggerEvent.Verbose))
				return true;
			if (HasEnv("STACKTRACE"))
				return true;

			return false;
		}

		static bool HasEnv(string name) {
			foreach (var tmp in Environment.GetEnvironmentVariables().Keys) {
				var env = tmp as string;
				if (env == null)
					continue;
				if (string.Equals(env, name, StringComparison.OrdinalIgnoreCase))
					return true;
			}
			return false;
		}

		static bool IsN00bUser() {
			if (HasEnv("VisualStudioDir"))
				return false;
			if (HasEnv("SHELL"))
				return false;
			return HasEnv("windir") && !HasEnv("PROMPT");
		}

		public static void PrintStackTrace(Exception ex) => PrintStackTrace(ex, LoggerEvent.Error);

		public static void PrintStackTrace(Exception ex, LoggerEvent loggerEvent) {
			var line = new string('-', 78);
			Logger.Instance.Log(false, null, loggerEvent, "\n\n");
			Logger.Instance.Log(false, null, loggerEvent, line);
			Logger.Instance.Log(false, null, loggerEvent, "Stack trace:\n{0}", ex.StackTrace);
			Logger.Instance.Log(false, null, loggerEvent, "\n\nCaught an exception:\n");
			Logger.Instance.Log(false, null, loggerEvent, line);
			Logger.Instance.Log(false, null, loggerEvent, "Message:");
			Logger.Instance.Log(false, null, loggerEvent, "  {0}", ex.Message);
			Logger.Instance.Log(false, null, loggerEvent, "Type:");
			Logger.Instance.Log(false, null, loggerEvent, "  {0}", ex.GetType());
			Logger.Instance.Log(false, null, loggerEvent, line);
		}

		static void ParseCommandLine(string[] args, FilesDeobfuscator.Options options) {
			new CommandLineParser(deobfuscatorInfos, options).Parse(args);

			Logger.vv("Args:");
			Logger.Instance.Indent();
			foreach (var arg in args)
				Logger.vv("{0}", Utils.ToCsharpString(arg));
			Logger.Instance.DeIndent();
		}
	}
}



================================================
File: de4dot.cui/de4dot.cui.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">

  <Import Project="..\De4DotCommon.props" />

  <ItemGroup>
    <ProjectReference Include="..\de4dot.blocks\de4dot.blocks.csproj" />
    <ProjectReference Include="..\de4dot.code\de4dot.code.csproj" />
  </ItemGroup>

</Project>



================================================
File: de4dot.cui/Properties/AssemblyInfo.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Runtime.CompilerServices;

[assembly: InternalsVisibleTo("de4dot, PublicKey=00240000048000009400000006020000002400005253413100040000010001006dc721ade368b747b89b536e7f1887993469726dd10be2ed8527a5b9c473633afe734730bd801e2e888f4462ce9b64a17df849453af430351ade9b4e5b1071fcd7f036871e85c6be368fe65b750b87e44dbea709b0524de642803c31db2a6ac68a61bb09e9289b14ce372190a50b94d7bc021366d401d53d54f6e1907259cda9")]
[assembly: InternalsVisibleTo("de4dot-x64, PublicKey=00240000048000009400000006020000002400005253413100040000010001006dc721ade368b747b89b536e7f1887993469726dd10be2ed8527a5b9c473633afe734730bd801e2e888f4462ce9b64a17df849453af430351ade9b4e5b1071fcd7f036871e85c6be368fe65b750b87e44dbea709b0524de642803c31db2a6ac68a61bb09e9289b14ce372190a50b94d7bc021366d401d53d54f6e1907259cda9")]



================================================
File: de4dot.mdecrypt/DecryptMethodsInfo.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;

namespace de4dot.mdecrypt {
	[Serializable]
	public class DecryptMethodsInfo {
		// The <Module>::.cctor() method body bytes.
		// Initialize this so only the methods decrypter method gets executed in
		// <Module>::.cctor(). If null, all code in the original <Module>::.cctor()
		// gets executed.
		public byte[] moduleCctorBytes;

		// The metadata tokens of all methods to decrypt. Use null if all methods should
		// be decrypted.
		public List<uint> methodsToDecrypt;
	}
}



================================================
File: de4dot.mdecrypt/DynamicMethodsDecrypter.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Runtime.CompilerServices;
using System.Runtime.ExceptionServices;
using System.Runtime.InteropServices;
using System.Reflection;
using System.Security;
using dnlib.DotNet;
using dnlib.DotNet.MD;
using dnlib.PE;
using de4dot.blocks;

#if NET35
namespace System.Runtime.ExceptionServices {
	[AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
	class HandleProcessCorruptedStateExceptionsAttribute : Attribute {
	}
}
#endif

namespace de4dot.mdecrypt {
	public class DynamicMethodsDecrypter {
		static DynamicMethodsDecrypter instance;
		DecryptMethodsInfo decryptMethodsInfo;

		struct FuncPtrInfo<D> {
			public D del;
			public IntPtr ptr;
			public IntPtr ptrInDll;

			public void Prepare(Delegate del) {
				RuntimeHelpers.PrepareDelegate(del);
				ptr = Marshal.GetFunctionPointerForDelegate(del);
			}
		}

		[StructLayout(LayoutKind.Sequential, Pack = 1)]
		struct IMAGE_SECTION_HEADER {
			public ulong name;
			public uint VirtualSize;
			public uint VirtualAddress;
			public uint SizeOfRawData;
			public uint PointerToRawData;
			public uint PointerToRelocations;
			public uint PointerToLinenumbers;
			public ushort NumberOfRelocations;
			public ushort NumberOfLinenumbers;
			public uint Characteristics;
		}

		[StructLayout(LayoutKind.Sequential, Pack=1, Size=0x88)]
		struct CORINFO_METHOD_INFO {
			public IntPtr ftn;
			public IntPtr scope;
			public IntPtr ILCode;
			public uint ILCodeSize;
			public ushort maxStack;
			public ushort EHCount;
			// 0x64 other bytes here...
		}

		class DecryptContext {
			public DumpedMethod dm;
			public MethodDef method;
		}

		FuncPtrInfo<CompileMethod> ourCompileMethodInfo = new FuncPtrInfo<CompileMethod>();
		FuncPtrInfo<ReturnMethodToken> returnMethodTokenInfo = new FuncPtrInfo<ReturnMethodToken>();
		FuncPtrInfo<ReturnNameOfMethod> returnNameOfMethodInfo = new FuncPtrInfo<ReturnNameOfMethod>();

		IntPtr origCompileMethod;
		//IntPtr jitterTextFreeMem;

		IntPtr callMethod;
		CallMethod callMethodDelegate;

		IntPtr jitterInstance;
		IntPtr jitterVtbl;
		Module moduleToDecrypt;
		IntPtr hInstModule;
		IntPtr ourCompMem;
		bool compileMethodIsThisCall;
		IntPtr ourCodeAddr;

		MDTable methodDefTable;
		IntPtr methodDefTablePtr;
		ModuleDefMD dnlibModule;
		MethodDef moduleCctor;
		uint moduleCctorCodeRva;
		IntPtr moduleToDecryptScope;

		DecryptContext ctx = new DecryptContext();

		public static DynamicMethodsDecrypter Instance {
			get {
				if (instance != null)
					return instance;
				return instance = new DynamicMethodsDecrypter();
			}
		}

		static Version VersionNet45DevPreview = new Version(4, 0, 30319, 17020);
		static Version VersionNet45Rtm = new Version(4, 0, 30319, 17929);
		DynamicMethodsDecrypter() {
			if (UIntPtr.Size != 4)
				throw new ApplicationException("Only 32-bit dynamic methods decryption is supported");

			// .NET 4.5 beta/preview/RC compileMethod has thiscall calling convention, but they
			// switched back to stdcall in .NET 4.5 RTM
			compileMethodIsThisCall = Environment.Version >= VersionNet45DevPreview &&
				Environment.Version < VersionNet45Rtm;
		}

		[DllImport("kernel32", CharSet = CharSet.Ansi)]
		static extern IntPtr GetModuleHandle(string name);

		[DllImport("kernel32", CharSet = CharSet.Ansi)]
		static extern IntPtr GetProcAddress(IntPtr hModule, string name);

		[DllImport("kernel32")]
		static extern bool VirtualProtect(IntPtr addr, int size, uint newProtect, out uint oldProtect);
		const uint PAGE_EXECUTE_READWRITE = 0x40;

		[DllImport("kernel32")]
		static extern IntPtr VirtualAlloc(IntPtr lpAddress, UIntPtr dwSize, uint flAllocationType, uint flProtect);

		[DllImport("kernel32")]
		static extern bool GetModuleHandleEx(uint dwFlags, IntPtr lpModuleName, out IntPtr phModule);

		delegate IntPtr GetJit();
		delegate int CompileMethod(IntPtr jitter, IntPtr comp, IntPtr info, uint flags, IntPtr nativeEntry, IntPtr nativeSizeOfCode, out bool handled);
		delegate int ReturnMethodToken();
		delegate string ReturnNameOfMethod();
		delegate int CallMethod(IntPtr compileMethod, IntPtr jitter, IntPtr comp, IntPtr info, uint flags, IntPtr nativeEntry, IntPtr nativeSizeOfCode);

		public DecryptMethodsInfo DecryptMethodsInfo {
			set => decryptMethodsInfo = value;
		}

		public unsafe Module Module {
			set {
				if (moduleToDecrypt != null)
					throw new ApplicationException("Module has already been initialized");

				moduleToDecrypt = value;
				hInstModule = Marshal.GetHINSTANCE(moduleToDecrypt);
				moduleToDecryptScope = GetScope(moduleToDecrypt);

				dnlibModule = ModuleDefMD.Load(hInstModule);
				methodDefTable = dnlibModule.TablesStream.MethodTable;
				methodDefTablePtr = new IntPtr((byte*)hInstModule + (uint)dnlibModule.Metadata.PEImage.ToRVA(methodDefTable.StartOffset));

				InitializeDNLibMethods();
			}
		}

		static IntPtr GetScope(Module module) {
			var obj = GetFieldValue(module.ModuleHandle, "m_ptr");
			if (obj is IntPtr)
				return (IntPtr)obj;
			if (obj.GetType().ToString() == "System.Reflection.RuntimeModule")
				return (IntPtr)GetFieldValue(obj, "m_pData");

			throw new ApplicationException($"m_ptr is an invalid type: {obj.GetType()}");
		}

		static object GetFieldValue(object obj, string fieldName) {
			var field = obj.GetType().GetField(fieldName, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
			if (field == null)
				throw new ApplicationException($"Could not get field {obj.GetType()}::{fieldName}");
			return field.GetValue(obj);
		}

		unsafe void InitializeDNLibMethods() {
			moduleCctor = dnlibModule.GlobalType.FindStaticConstructor();
			if (moduleCctor == null)
				moduleCctorCodeRva = 0;
			else {
				byte* p = (byte*)hInstModule + (uint)moduleCctor.RVA;
				if ((*p & 3) == 2)
					moduleCctorCodeRva = (uint)moduleCctor.RVA + 1;
				else
					moduleCctorCodeRva = (uint)((uint)moduleCctor.RVA + (p[1] >> 4) * 4);
			}
		}

		public unsafe void InstallCompileMethod() {
			var hJitterDll = GetJitterDllHandle();
			/*jitterTextFreeMem =*/ GetEndOfText(hJitterDll);

			var getJitPtr = GetProcAddress(hJitterDll, "getJit");
			var getJit = (GetJit)Marshal.GetDelegateForFunctionPointer(getJitPtr, typeof(GetJit));
			jitterInstance = getJit();
			jitterVtbl = *(IntPtr*)jitterInstance;
			origCompileMethod = *(IntPtr*)jitterVtbl;

			PrepareMethods();
			InitializeDelegateFunctionPointers();
			CreateOurCode();
			callMethodDelegate = (CallMethod)Marshal.GetDelegateForFunctionPointer(callMethod, typeof(CallMethod));

			WriteCompileMethod(ourCompileMethodInfo.ptrInDll);
		}

		unsafe void WriteCompileMethod(IntPtr newCompileMethod) {
			if (!VirtualProtect(jitterVtbl, IntPtr.Size, PAGE_EXECUTE_READWRITE, out uint oldProtect))
				throw new ApplicationException("Could not enable write access to jitter vtbl");
			*(IntPtr*)jitterVtbl = newCompileMethod;
			VirtualProtect(jitterVtbl, IntPtr.Size, oldProtect, out oldProtect);
		}

		void InitializeDelegateFunctionPointers() {
			ourCompileMethodInfo.Prepare(ourCompileMethodInfo.del = TheCompileMethod);
			returnMethodTokenInfo.Prepare(returnMethodTokenInfo.del = ReturnMethodToken2);
			returnNameOfMethodInfo.Prepare(returnNameOfMethodInfo.del = ReturnNameOfMethod2);
		}

		public void LoadObfuscator() => RuntimeHelpers.RunModuleConstructor(moduleToDecrypt.ModuleHandle);

		public unsafe bool CanDecryptMethods() =>
			*(IntPtr*)jitterVtbl != ourCompileMethodInfo.ptrInDll &&
			*(IntPtr*)jitterVtbl != origCompileMethod;

		unsafe static IntPtr GetEndOfText(IntPtr hDll) {
			byte* p = (byte*)hDll;
			p += *(uint*)(p + 0x3C);	// add DOSHDR.e_lfanew
			p += 4;
			int numSections = *(ushort*)(p + 2);
			int sizeOptionalHeader = *(ushort*)(p + 0x10);
			p += 0x14;
			//uint sectionAlignment = *(uint*)(p + 0x20);
			p += sizeOptionalHeader;

			var textName = new byte[8] { (byte)'.', (byte)'t', (byte)'e', (byte)'x', (byte)'t', 0, 0, 0 };
			var name = new byte[8];
			var pSection = (IMAGE_SECTION_HEADER*)p;
			for (int i = 0; i < numSections; i++, pSection++) {
				Marshal.Copy(new IntPtr(pSection), name, 0, name.Length);
				if (!CompareName(textName, name, name.Length))
					continue;

				uint size = pSection->VirtualSize;
				uint rva = pSection->VirtualAddress;
				int displ = -8;
				return new IntPtr((byte*)hDll + rva + size + displ);
			}

			throw new ApplicationException("Could not find .text section");
		}

		static bool CompareName(byte[] b1, byte[] b2, int len) {
			for (int i = 0; i < len; i++) {
				if (b1[i] != b2[i])
					return false;
			}
			return true;
		}

		void PrepareMethods() {
			Marshal.PrelinkAll(GetType());
			foreach (var methodInfo in GetType().GetMethods(BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance))
				RuntimeHelpers.PrepareMethod(methodInfo.MethodHandle);
		}

		unsafe void CreateOurCode() {
			var code = new NativeCodeGenerator();

			// our compileMethod() func
			int compileMethodOffset = code.Size;

			int numPushedArgs = compileMethodIsThisCall ? 5 : 6;

			code.WriteByte(0x51);			// push ecx
			code.WriteByte(0x50);			// push eax
			code.WriteByte(0x54);			// push esp
			for (int i = 0; i < 5; i++)
				WritePushDwordPtrEspDispl(code, (sbyte)(0xC + numPushedArgs * 4));	// push dword ptr [esp+XXh]
			if (!compileMethodIsThisCall)
				WritePushDwordPtrEspDispl(code, (sbyte)(0xC + numPushedArgs * 4));	// push dword ptr [esp+XXh]
			else
				code.WriteByte(0x51);		// push ecx
			code.WriteCall(ourCompileMethodInfo.ptr);
			code.WriteByte(0x5A);			// pop edx
			code.WriteByte(0x59);			// pop ecx
			code.WriteBytes(0x84, 0xD2);	// test dl, dl
			code.WriteBytes(0x74, 0x03);	// jz $+5
			code.WriteBytes(0xC2, (ushort)(numPushedArgs * 4)); // retn 14h/18h
			for (int i = 0; i < numPushedArgs; i++)
				WritePushDwordPtrEspDispl(code, (sbyte)(numPushedArgs * 4));	// push dword ptr [esp+XXh]
			code.WriteCall(origCompileMethod);
			code.WriteBytes(0xC2, (ushort)(numPushedArgs * 4)); // retn 14h/18h

			// Our callMethod() code. 1st arg is the method to call. stdcall calling convention.
			int callMethodOffset = code.Size;
			code.WriteByte(0x58);			// pop eax (ret addr)
			code.WriteByte(0x5A);			// pop edx (method to call)
			if (compileMethodIsThisCall)
				code.WriteByte(0x59);		// pop ecx (this ptr)
			code.WriteByte(0x50);			// push eax (ret addr)
			code.WriteBytes(0xFF, 0xE2);	// jmp edx

			// Returns token of method
			int getMethodTokenOffset = code.Size;
			code.WriteCall(returnMethodTokenInfo.ptr);
			code.WriteBytes(0xC2, (ushort)(IntPtr.Size * 2));

			// Returns name of method
			int getMethodNameOffset = code.Size;
			code.WriteCall(returnNameOfMethodInfo.ptr);
			code.WriteBytes(0xC2, (ushort)(IntPtr.Size * 3));

			ourCodeAddr = VirtualAlloc(IntPtr.Zero, new UIntPtr((ulong)code.Size), 0x00001000, PAGE_EXECUTE_READWRITE);
			var baseAddr = ourCodeAddr;
			ourCompileMethodInfo.ptrInDll = new IntPtr((byte*)baseAddr + compileMethodOffset);
			callMethod = new IntPtr((byte*)baseAddr + callMethodOffset);
			returnMethodTokenInfo.ptrInDll = new IntPtr((byte*)baseAddr + getMethodTokenOffset);
			returnNameOfMethodInfo.ptrInDll = new IntPtr((byte*)baseAddr + getMethodNameOffset);
			byte[] theCode = code.GetCode(baseAddr);
			Marshal.Copy(theCode, 0, baseAddr, theCode.Length);
		}

		// Writes push dword ptr [esp+displ]
		static void WritePushDwordPtrEspDispl(NativeCodeGenerator code, sbyte displ) {
			code.WriteBytes(0xFF, 0x74);
			code.WriteBytes(0x24, (byte)displ);
		}

		static IntPtr GetJitterDllHandle() {
			var hJitterDll = GetModuleHandle("mscorjit");
			if (hJitterDll == IntPtr.Zero)
				hJitterDll = GetModuleHandle("clrjit");
			if (hJitterDll == IntPtr.Zero)
				throw new ApplicationException("Could not get a handle to the jitter DLL");
			return hJitterDll;
		}

		unsafe int TheCompileMethod(IntPtr jitter, IntPtr comp, IntPtr info, uint flags, IntPtr nativeEntry, IntPtr nativeSizeOfCode, out bool handled) {
			if (ourCompMem != IntPtr.Zero && comp == ourCompMem) {
				// We're decrypting methods
				var info2 = (CORINFO_METHOD_INFO*)info;
				ctx.dm.code = new byte[info2->ILCodeSize];

				Marshal.Copy(info2->ILCode, ctx.dm.code, 0, ctx.dm.code.Length);
				ctx.dm.mhMaxStack = info2->maxStack;
				ctx.dm.mhCodeSize = info2->ILCodeSize;
				if ((ctx.dm.mhFlags & 8) != 0)
					ctx.dm.extraSections = ReadExtraSections((byte*)info2->ILCode + info2->ILCodeSize);

				UpdateFromMethodDefTableRow();

				handled = true;
				return 0;
			}
			else {
				// We're not decrypting methods

				var info2 = (CORINFO_METHOD_INFO*)info;
				if (info2->scope != moduleToDecryptScope ||
					decryptMethodsInfo.moduleCctorBytes == null ||
					moduleCctorCodeRva == 0) {
					handled = false;
					return 0;
				}

				uint codeRva = (uint)((byte*)info2->ILCode - (byte*)hInstModule);
				if (moduleCctorCodeRva == codeRva) {
					fixed (byte* newIlCodeBytes = &decryptMethodsInfo.moduleCctorBytes[0]) {
						WriteCompileMethod(origCompileMethod);
						info2->ILCode = new IntPtr(newIlCodeBytes);
						info2->ILCodeSize = (uint)decryptMethodsInfo.moduleCctorBytes.Length;
						handled = true;
						return callMethodDelegate(origCompileMethod, jitter, comp, info, flags, nativeEntry, nativeSizeOfCode);
					}
				}
			}

			handled = false;
			return 0;
		}

		unsafe static byte* Align(byte* p, int alignment) =>
			(byte*)new IntPtr((long)((ulong)(p + alignment - 1) & ~(ulong)(alignment - 1)));

		unsafe static byte[] ReadExtraSections(byte* p) {
			p = Align(p, 4);
			byte* startPos = p;
			p = ParseSection(p);
			int size = (int)(p - startPos);
			var sections = new byte[size];
			Marshal.Copy(new IntPtr(startPos), sections, 0, sections.Length);
			return sections;
		}

		unsafe static byte* ParseSection(byte* p) {
			byte flags;
			do {
				p = Align(p, 4);

				flags = *p++;
				if ((flags & 1) == 0)
					throw new ApplicationException("Not an exception section");
				if ((flags & 0x3E) != 0)
					throw new ApplicationException("Invalid bits set");

				if ((flags & 0x40) != 0) {
					p--;
					int num = (int)(*(uint*)p >> 8) / 24;
					p += 4 + num * 24;
				}
				else {
					int num = *p++ / 12;
					p += 2 + num * 12;
				}
			} while ((flags & 0x80) != 0);
			return p;
		}

		unsafe void UpdateFromMethodDefTableRow() {
			uint methodIndex = ctx.dm.token - 0x06000001;
			byte* row = (byte*)methodDefTablePtr + methodIndex * methodDefTable.RowSize;
			ctx.dm.mdRVA = Read(row, methodDefTable.Columns[0]);
			ctx.dm.mdImplFlags = (ushort)Read(row, methodDefTable.Columns[1]);
			ctx.dm.mdFlags = (ushort)Read(row, methodDefTable.Columns[2]);
			ctx.dm.mdName = Read(row, methodDefTable.Columns[3]);
			ctx.dm.mdSignature = Read(row, methodDefTable.Columns[4]);
			ctx.dm.mdParamList = Read(row, methodDefTable.Columns[5]);
		}

		static unsafe uint Read(byte* row, ColumnInfo colInfo) {
			switch (colInfo.Size) {
			case 1: return *(row + colInfo.Offset);
			case 2: return *(ushort*)(row + colInfo.Offset);
			case 4: return *(uint*)(row + colInfo.Offset);
			default: throw new ApplicationException($"Unknown size: {colInfo.Size}");
			}
		}

		string ReturnNameOfMethod2() => ctx.method.Name.String;
		int ReturnMethodToken2() => ctx.method.MDToken.ToInt32();

		public DumpedMethods DecryptMethods() {
			if (!CanDecryptMethods())
				throw new ApplicationException("Can't decrypt methods since compileMethod() isn't hooked yet");
			InstallCompileMethod2();

			var dumpedMethods = new DumpedMethods();

			if (decryptMethodsInfo.methodsToDecrypt == null) {
				for (uint rid = 1; rid <= methodDefTable.Rows; rid++)
					dumpedMethods.Add(DecryptMethod(0x06000000 + rid));
			}
			else {
				foreach (var token in decryptMethodsInfo.methodsToDecrypt)
					dumpedMethods.Add(DecryptMethod(token));
			}

			return dumpedMethods;
		}

		unsafe DumpedMethod DecryptMethod(uint token) {
			if (!CanDecryptMethods())
				throw new ApplicationException("Can't decrypt methods since compileMethod() isn't hooked yet");

			ctx = new DecryptContext();
			ctx.dm = new DumpedMethod();
			ctx.dm.token = token;

			ctx.method = dnlibModule.ResolveMethod(MDToken.ToRID(token));
			if (ctx.method == null)
				throw new ApplicationException($"Could not find method {token:X8}");

			byte* mh = (byte*)hInstModule + (uint)ctx.method.RVA;
			byte* code;
			if (mh == (byte*)hInstModule) {
				ctx.dm.mhMaxStack = 0;
				ctx.dm.mhCodeSize = 0;
				ctx.dm.mhFlags = 0;
				ctx.dm.mhLocalVarSigTok = 0;
				code = null;
			}
			else if ((*mh & 3) == 2) {
				uint headerSize = 1;
				ctx.dm.mhMaxStack = 8;
				ctx.dm.mhCodeSize = (uint)(*mh >> 2);
				ctx.dm.mhFlags = 2;
				ctx.dm.mhLocalVarSigTok = 0;
				code = mh + headerSize;
			}
			else {
				uint headerSize = (uint)((mh[1] >> 4) * 4);
				ctx.dm.mhMaxStack = *(ushort*)(mh + 2);
				ctx.dm.mhCodeSize = *(uint*)(mh + 4);
				ctx.dm.mhFlags = *(ushort*)mh;
				ctx.dm.mhLocalVarSigTok = *(uint*)(mh + 8);
				code = mh + headerSize;
			}

			CORINFO_METHOD_INFO info = default;
			info.ILCode = new IntPtr(code);
			info.ILCodeSize = ctx.dm.mhCodeSize;
			info.maxStack = ctx.dm.mhMaxStack;
			info.scope = moduleToDecryptScope;

			InitializeOurComp();
			if (code == null) {
				ctx.dm.code = new byte[0];
				UpdateFromMethodDefTableRow();
			}
			else
				callMethodDelegate(*(IntPtr*)jitterVtbl, jitterInstance, ourCompMem, new IntPtr(&info), 0, new IntPtr(0x12345678), new IntPtr(0x3ABCDEF0));

			var dm = ctx.dm;
			ctx = null;
			return dm;
		}

		unsafe void InitializeOurComp() {
			const int numIndexes = 15;
			if (ourCompMem == IntPtr.Zero)
				ourCompMem = Marshal.AllocHGlobal(numIndexes * IntPtr.Size);
			if (ourCompMem == IntPtr.Zero)
				throw new ApplicationException("Could not allocate memory");

			var mem = (IntPtr*)ourCompMem;
			for (int i = 0; i < numIndexes; i++)
				mem[i] = IntPtr.Zero;

			mem[1] = new IntPtr(mem + 2);
			mem[3] = new IntPtr(IntPtr.Size * 5);
			mem[5] = new IntPtr(IntPtr.Size * 7);
			mem[6] = new IntPtr(mem + 7);
			mem[7] = returnNameOfMethodInfo.ptrInDll;
			mem[8] = new IntPtr(mem);
			mem[13] = returnMethodTokenInfo.ptrInDll;	// .NET 2.0
			mem[14] = returnMethodTokenInfo.ptrInDll;	// .NET 4.0
		}

		bool hasInstalledCompileMethod2 = false;
		unsafe void InstallCompileMethod2() {
			if (hasInstalledCompileMethod2)
				return;

			if (!PatchCM(*(IntPtr*)jitterVtbl, origCompileMethod, ourCompileMethodInfo.ptrInDll))
				throw new ApplicationException("Couldn't patch compileMethod");

			hasInstalledCompileMethod2 = true;
			return;
		}

		static IntPtr GetModuleHandle(IntPtr addr) {
			if (!GetModuleHandleEx(4, addr, out var hModule))
				throw new ApplicationException("GetModuleHandleEx() failed");
			return hModule;
		}

		class PatchInfo {
			public int RVA;
			public byte[] Data;
			public byte[] Orig;

			public PatchInfo(int rva, byte[] data, byte[] orig) {
				RVA = rva;
				Data = data;
				Orig = orig;
			}
		}
		static readonly PatchInfo[] patches = new PatchInfo[] {
			new PatchInfo(0x000110A5, new byte[] { 0x33, 0xC0, 0xC2, 0x04, 0x00 }, new byte[] { 0xE9, 0x36, 0x3A, 0x00, 0x00 }),
			new PatchInfo(0x000110AF, new byte[] { 0x33, 0xC0, 0xC2, 0x04, 0x00 }, new byte[] { 0xE9, 0x4C, 0x3C, 0x00, 0x00 }),
			new PatchInfo(0x000110AA, new byte[] { 0x33, 0xC0, 0xC2, 0x04, 0x00 }, new byte[] { 0xE9, 0xF1, 0x3A, 0x00, 0x00 }),
			new PatchInfo(0x00011019, new byte[] { 0x33, 0xC0, 0xC2, 0x04, 0x00 }, new byte[] { 0xE9, 0x12, 0x4B, 0x00, 0x00 }),
			new PatchInfo(0x00011019, new byte[] { 0x33, 0xC0, 0xC2, 0x04, 0x00 }, new byte[] { 0xE9, 0x02, 0x4B, 0x00, 0x00 }),
			new PatchInfo(0x00011019, new byte[] { 0x33, 0xC0, 0xC2, 0x04, 0x00 }, new byte[] { 0xE9, 0xA2, 0x4B, 0x00, 0x00 }),
		};

		static unsafe bool PatchCM(IntPtr addr, IntPtr origValue, IntPtr newValue) {
			var baseAddr = GetModuleHandle(addr);
			IntPtr patchAddr;
			using (var peImage = new PEImage(baseAddr))
				patchAddr = FindCMAddress(peImage, baseAddr, origValue);
			if (patchAddr == IntPtr.Zero)
				return false;

			*(IntPtr*)patchAddr = newValue;
			PatchRT(baseAddr);
			return true;
		}

		[HandleProcessCorruptedStateExceptions, SecurityCritical]	// Req'd on .NET 4.0
		static unsafe bool PatchRT(IntPtr baseAddr) {
			foreach (var info in patches) {
				try {
					var addr = new IntPtr(baseAddr.ToInt64() + info.RVA);

					var data = new byte[info.Orig.Length];
					Marshal.Copy(addr, data, 0, data.Length);
					if (!Equals(data, info.Orig))
						continue;

					if (!VirtualProtect(addr, info.Data.Length, PAGE_EXECUTE_READWRITE, out uint oldProtect))
						throw new ApplicationException("Could not enable write access");
					Marshal.Copy(info.Data, 0, addr, info.Data.Length);
					VirtualProtect(addr, info.Data.Length, oldProtect, out oldProtect);
					return true;
				}
				catch {
				}
			}
			return false;
		}

		static bool Equals(byte[] a, byte[] b) {
			if (a == b)
				return true;
			if (a == null || b == null)
				return false;
			if (a.Length != b.Length)
				return false;
			for (int i = 0; i < a.Length; i++) {
				if (a[i] != b[i])
					return false;
			}
			return true;
		}

		[HandleProcessCorruptedStateExceptions, SecurityCritical]	// Req'd on .NET 4.0
		static unsafe IntPtr FindCMAddress(PEImage peImage, IntPtr baseAddr, IntPtr origValue) {
			int offset = Environment.Version.Major == 2 ? 0x10 : 0x28;

			foreach (var section in peImage.ImageSectionHeaders) {
				const uint RW = 0x80000000 | 0x40000000;
				if ((section.Characteristics & RW) != RW)
					continue;

				byte* p = (byte*)baseAddr + (uint)section.VirtualAddress + ((section.VirtualSize + IntPtr.Size - 1) & ~(IntPtr.Size - 1)) - IntPtr.Size;
				for (; p >= (byte*)baseAddr; p -= IntPtr.Size) {
					try {
						byte* p2 = (byte*)*(IntPtr**)p;
						if ((ulong)p2 >= 0x10000) {
							if (*(IntPtr*)(p2 + 0x74) == origValue)
								return new IntPtr(p2 + 0x74);
							if (*(IntPtr*)(p2 + 0x78) == origValue)
								return new IntPtr(p2 + 0x78);
						}
					}
					catch {
					}
					try {
						byte* p2 = (byte*)*(IntPtr**)p;
						if ((ulong)p2 >= 0x10000) {
							p2 += offset;
							if (*(IntPtr*)p2 == origValue)
								return new IntPtr(p2);
						}
					}
					catch {
					}
					try {
						if (*(IntPtr*)p == origValue)
							return new IntPtr(p);
					}
					catch {
					}
				}
			}
			return IntPtr.Zero;
		}
	}
}



================================================
File: de4dot.mdecrypt/NativeCodeGenerator.cs
================================================
/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.IO;

namespace de4dot.mdecrypt {
	class NativeCodeGenerator {
		MemoryStream memStream;
		BinaryWriter writer;
		Dictionary<int, IntPtr> offsetToBranchAddr = new Dictionary<int, IntPtr>();

		public int Size => (int)memStream.Length;

		public NativeCodeGenerator() {
			memStream = new MemoryStream(0x200);
			writer = new BinaryWriter(memStream);
		}

		public void WriteByte(byte b) => writer.Write(b);

		public void WriteBytes(byte b1, byte b2) {
			WriteByte(b1);
			WriteByte(b2);
		}

		public void WriteBytes(byte b, ushort us) {
			WriteByte(b);
			WriteWord(us);
		}

		public void WriteWord(ushort w) => writer.Write(w);
		public void WriteDword(uint d) => writer.Write(d);
		public void WriteBytes(byte[] bytes) => writer.Write(bytes);

		public void WriteCall(IntPtr addr) {
			WriteByte(0xE8);
			WriteBranchAddr(addr);
		}

		public void WriteBranchAddr(IntPtr addr) {
			offsetToBranchAddr.Add((int)memStream.Position, addr);
			writer.Write(0);
		}

		public byte[] GetCode(IntPtr addr) {
			FixOffsets(addr);
			memStream.Position = memStream.Length;
			return memStream.ToArray();
		}

		unsafe void FixOffsets(IntPtr destAddr) {
			foreach (var kv in offsetToBranchAddr) {
				memStream.Position = kv.Key;
				// kv.Value (func/label) = destAddr + kv.Key + 4 + displ
				var displ = (ulong)((byte*)kv.Value - (byte*)destAddr - kv.Key - 4);
				uint high = (uint)(displ >> 32);
				if (high != 0 && high != 0xFFFFFFFF)
					throw new ApplicationException("Invalid displ");
				writer.Write((uint)displ);
			}
		}
	}
}



================================================
File: de4dot.mdecrypt/de4dot.mdecrypt.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">

  <Import Project="..\De4DotCommon.props" />

  <PropertyGroup>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\de4dot.blocks\de4dot.blocks.csproj" />
  </ItemGroup>

</Project>



================================================
File: deobfuscator.Template/deobfuscator.Template.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFrameworks>net35;netcoreapp2.1</TargetFrameworks>
    <SignAssembly>true</SignAssembly>
    <AssemblyOriginatorKeyFile>..\de4dot.snk</AssemblyOriginatorKeyFile>
    <Features>strict</Features>
    <LangVersion>latest</LangVersion>
    <OutputPath>..\$(Configuration)</OutputPath>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\AssemblyData\AssemblyData.csproj" />
    <ProjectReference Include="..\de4dot.blocks\de4dot.blocks.csproj" />
    <ProjectReference Include="..\de4dot.code\de4dot.code.csproj" />
    <ProjectReference Include="..\de4dot.mdecrypt\de4dot.mdecrypt.csproj" />
  </ItemGroup>

</Project>



================================================
File: deobfuscator.Template/readme.txt
================================================
This is a template deobfuscator module. Make a copy and rename it to create your own deobfuscator modules with the required references and the correct build directories.



================================================
File: .github/workflows/build.yml
================================================
name: GitHub CI
on:
  push:
    branches:
      - master
  pull_request:
    branches:
      - master
  release:
    types: released

jobs:
  build:
    name: Build
    runs-on: windows-latest

    steps:
      - uses: actions/checkout@v1

      - name: Build
        shell: pwsh
        run: |
          $msbuildPath = Split-Path (& "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe" -latest -requires Microsoft.Component.MSBuild -find MSBuild\Current\Bin\amd64\MSBuild.exe | Select-Object -First 1) -Parent
          $env:PATH = $msbuildPath + ';' + $env:PATH
          .\build.ps1

      - uses: actions/upload-artifact@v1
        if: github.ref == 'refs/heads/master' || startsWith(github.ref, 'refs/tags/')
        with:
          name: de4dot-net35
          path: Release/net35

      - uses: actions/upload-artifact@v1
        if: github.ref == 'refs/heads/master' || startsWith(github.ref, 'refs/tags/')
        with:
          name: de4dot-net45
          path: Release/net45

      - uses: actions/upload-artifact@v1
        if: github.ref == 'refs/heads/master' || startsWith(github.ref, 'refs/tags/')
        with:
          name: de4dot-netcoreapp2.1
          path: publish-netcoreapp2.1

      - uses: actions/upload-artifact@v1
        if: github.ref == 'refs/heads/master' || startsWith(github.ref, 'refs/tags/')
        with:
          name: de4dot-netcoreapp3.1
          path: publish-netcoreapp3.1



Directory structure:
└── kinimiwar-confuserex-static-string-decryptor/
    ├── README.md
    ├── ConfuserEx Static String Decryptor.sln
    └── ConfuserEx Static String Decryptor/
        ├── App.config
        ├── ConfuserEx Static String Decryptor.csproj
        ├── Excess Nop Remover.cs
        ├── Form1.Designer.cs
        ├── Form1.cs
        ├── Form1.resx
        ├── Program.cs
        ├── StringDecryptor.cs
        ├── Properties/
        │   ├── AssemblyInfo.cs
        │   ├── Resources.Designer.cs
        │   ├── Resources.resx
        │   ├── Settings.Designer.cs
        │   └── Settings.settings
        ├── bin/
        │   └── Debug/
        │       ├── ConfuserEx Static String Decryptor.exe.config
        │       ├── ConfuserEx Static String Decryptor.vshost.exe.config
        │       └── ConfuserEx Static String Decryptor.vshost.exe.manifest
        └── obj/
            └── Debug/
                ├── ConfuserEx Static String Decryptor.csproj.FileListAbsolute.txt
                ├── ConfuserEx Static String Decryptor.csproj.GenerateResource.Cache
                ├── ConfuserEx Static String Decryptor.csprojResolveAssemblyReference.cache
                ├── ConfuserEx_Static_String_Decryptor.Form1.resources
                ├── ConfuserEx_Static_String_Decryptor.Properties.Resources.resources
                ├── DesignTimeResolveAssemblyReferences.cache
                ├── DesignTimeResolveAssemblyReferencesInput.cache
                ├── TemporaryGeneratedFile_036C0B5B-1481-4323-8D20-8F5ADCB23D92.cs
                ├── TemporaryGeneratedFile_5937a670-0e60-4077-877b-f7221da3dda1.cs
                └── TemporaryGeneratedFile_E7A71F73-0F8D-4B9B-B56E-8E70B10BC5D3.cs

================================================
File: README.md
================================================
# ConfuserEx-Static-String-Decryptor
i made this a while ago when dealing with malware so didnt want to use codecrackers tool since it invokes and yq8 tool is really unstable so i made this 

it will decrypt strings statically from a non modded confuserex with or without cflow doesnt really matter

you have the option to invoke only then will your file be loaded with assembly.load

the code is terrible was a late night and a long time ago so could be improved alot 

if you find any bugs let me know ill try fix it 

i will also release my netguard 4.5 static tool which uses 2 parameters for string encryption just got to find the source

credits
yq8 for his unused nopremover found on blackstorm i think 



================================================
File: ConfuserEx Static String Decryptor.sln
================================================
ï»¿
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 14
VisualStudioVersion = 14.0.25420.1
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ConfuserEx Static String Decryptor", "ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor.csproj", "{9F4EF3D7-B13F-4B57-A0EE-BE728DC7D2CB}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{9F4EF3D7-B13F-4B57-A0EE-BE728DC7D2CB}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{9F4EF3D7-B13F-4B57-A0EE-BE728DC7D2CB}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{9F4EF3D7-B13F-4B57-A0EE-BE728DC7D2CB}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{9F4EF3D7-B13F-4B57-A0EE-BE728DC7D2CB}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal



================================================
File: ConfuserEx Static String Decryptor/App.config
================================================
ï»¿<?xml version="1.0" encoding="utf-8" ?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5.2" />
    </startup>
</configuration>


================================================
File: ConfuserEx Static String Decryptor/ConfuserEx Static String Decryptor.csproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="14.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{9F4EF3D7-B13F-4B57-A0EE-BE728DC7D2CB}</ProjectGuid>
    <OutputType>WinExe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>ConfuserEx_Static_String_Decryptor</RootNamespace>
    <AssemblyName>ConfuserEx Static String Decryptor</AssemblyName>
    <TargetFrameworkVersion>v4.5.2</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="dnlib">
      <HintPath>..\..\..\..\GitHub\dnSpy\dnSpy\dnSpy\bin\Debug\dnlib.dll</HintPath>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Deployment" />
    <Reference Include="System.Drawing" />
    <Reference Include="System.Net.Http" />
    <Reference Include="System.Windows.Forms" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Excess Nop Remover.cs" />
    <Compile Include="Form1.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Include="Form1.Designer.cs">
      <DependentUpon>Form1.cs</DependentUpon>
    </Compile>
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="StringDecryptor.cs" />
    <EmbeddedResource Include="Form1.resx">
      <DependentUpon>Form1.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
      <SubType>Designer</SubType>
    </EmbeddedResource>
    <Compile Include="Properties\Resources.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
    <None Include="Properties\Settings.settings">
      <Generator>SettingsSingleFileGenerator</Generator>
      <LastGenOutput>Settings.Designer.cs</LastGenOutput>
    </None>
    <Compile Include="Properties\Settings.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Settings.settings</DependentUpon>
      <DesignTimeSharedInput>True</DesignTimeSharedInput>
    </Compile>
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>


================================================
File: ConfuserEx Static String Decryptor/Excess Nop Remover.cs
================================================
ï»¿using dnlib.DotNet;
using dnlib.DotNet.Emit;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ConfuserEx_Static_String_Decryptor
{
    class Excess_Nop_Remover
    {
        public static void NopRemover(ModuleDefMD modulee)
        {
            foreach (TypeDef types in modulee.Types)
            {
                foreach (MethodDef methods in types.Methods)
                {
                    if (!methods.HasBody) continue;
                    RemoveUnusedNops(methods);
                }
            }
        }
        public static void RemoveUnusedNops(MethodDef MethodDef)
        {
            if (MethodDef.HasBody)
            {
                for (int i = 0; i < MethodDef.Body.Instructions.Count; i++)
                {
                    Instruction Instr = MethodDef.Body.Instructions[i];

                    if (Instr.OpCode == OpCodes.Nop)
                    {
                        if (!IsNopBranchTarget(MethodDef, Instr))
                        {
                            if (!IsNopSwitchTarget(MethodDef, Instr))
                            {
                                if (!IsNopExceptionHandlerTarget(MethodDef, Instr))
                                {
                                    // Remove Nop
                                    MethodDef.Body.Instructions.RemoveAt(i);
                                    i--; // Needed?
                                }
                            }
                        }
                    }
                }
            }
        }


        private static bool IsNopBranchTarget(MethodDef MethodDef, Instruction NopInstr)
        {
            for (int i = 0; i < MethodDef.Body.Instructions.Count; i++)
            {
                Instruction Instr = MethodDef.Body.Instructions[i];

                if (Instr.OpCode.OperandType == OperandType.InlineBrTarget ||
                    Instr.OpCode.OperandType == OperandType.ShortInlineBrTarget)
                {
                    if (Instr.Operand != null)
                    {
                        Instruction OperandInstr = (Instruction)Instr.Operand;

                        if (OperandInstr == NopInstr)
                            return true;
                    }
                }
            }
            return false;
        }

        private static bool IsNopSwitchTarget(MethodDef MethodDef, Instruction NopInstr)
        {
            for (int i = 0; i < MethodDef.Body.Instructions.Count; i++)
            {
                Instruction Instr = MethodDef.Body.Instructions[i];

                if (Instr.OpCode.OperandType == OperandType.InlineSwitch)
                {
                    if (Instr.Operand != null)
                    {
                        Instruction[] SwitchTargets = (Instruction[])Instr.Operand;

                        if (SwitchTargets.Contains(NopInstr))
                            return true;
                    }

                }
            }
            return false;
        }

        private static bool IsNopExceptionHandlerTarget(MethodDef MethodDef, Instruction NopInstr)
        {

            if (MethodDef.Body.HasExceptionHandlers == false)
                return false;

            var ExHandlers = MethodDef.Body.ExceptionHandlers;

            foreach (ExceptionHandler ExHandler in ExHandlers)
            {
                if (ExHandler.FilterStart == NopInstr)
                    return true;
                if (ExHandler.HandlerEnd == NopInstr)
                    return true;
                if (ExHandler.HandlerStart == NopInstr)
                    return true;
                if (ExHandler.TryEnd == NopInstr)
                    return true;
                if (ExHandler.TryStart == NopInstr)
                    return true;
            }
            return false;
        }
    }
}



================================================
File: ConfuserEx Static String Decryptor/Form1.Designer.cs
================================================
ï»¿namespace ConfuserEx_Static_String_Decryptor
{
    partial class Form1
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.textBox1 = new System.Windows.Forms.TextBox();
            this.button1 = new System.Windows.Forms.Button();
            this.button2 = new System.Windows.Forms.Button();
            this.label1 = new System.Windows.Forms.Label();
            this.openFileDialog1 = new System.Windows.Forms.OpenFileDialog();
            this.checkBox1 = new System.Windows.Forms.CheckBox();
            this.SuspendLayout();
            // 
            // textBox1
            // 
            this.textBox1.Location = new System.Drawing.Point(12, 12);
            this.textBox1.Multiline = true;
            this.textBox1.Name = "textBox1";
            this.textBox1.Size = new System.Drawing.Size(236, 20);
            this.textBox1.TabIndex = 0;
            // 
            // button1
            // 
            this.button1.Location = new System.Drawing.Point(254, 9);
            this.button1.Name = "button1";
            this.button1.Size = new System.Drawing.Size(75, 23);
            this.button1.TabIndex = 1;
            this.button1.Text = "Select File";
            this.button1.UseVisualStyleBackColor = true;
            this.button1.Click += new System.EventHandler(this.button1_Click);
            // 
            // button2
            // 
            this.button2.Location = new System.Drawing.Point(254, 40);
            this.button2.Name = "button2";
            this.button2.Size = new System.Drawing.Size(75, 22);
            this.button2.TabIndex = 2;
            this.button2.Text = "Decrypt";
            this.button2.UseVisualStyleBackColor = true;
            this.button2.Click += new System.EventHandler(this.button2_Click);
            // 
            // label1
            // 
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(105, 45);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(106, 13);
            this.label1.TabIndex = 3;
            this.label1.Text = "Strings Decrypted : 0";
            // 
            // openFileDialog1
            // 
            this.openFileDialog1.FileName = "openFileDialog1";
            // 
            // checkBox1
            // 
            this.checkBox1.AutoSize = true;
            this.checkBox1.Location = new System.Drawing.Point(12, 45);
            this.checkBox1.Name = "checkBox1";
            this.checkBox1.Size = new System.Drawing.Size(59, 17);
            this.checkBox1.TabIndex = 4;
            this.checkBox1.Text = "Invoke";
            this.checkBox1.UseVisualStyleBackColor = true;
            // 
            // Form1
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(339, 67);
            this.Controls.Add(this.checkBox1);
            this.Controls.Add(this.label1);
            this.Controls.Add(this.button2);
            this.Controls.Add(this.button1);
            this.Controls.Add(this.textBox1);
            this.Name = "Form1";
            this.Text = "Form1";
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.TextBox textBox1;
        private System.Windows.Forms.Button button1;
        private System.Windows.Forms.Button button2;
        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.OpenFileDialog openFileDialog1;
        private System.Windows.Forms.CheckBox checkBox1;
    }
}




================================================
File: ConfuserEx Static String Decryptor/Form1.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using dnlib.DotNet;
using System.IO;
using dnlib.DotNet.Writer;

namespace ConfuserEx_Static_String_Decryptor
{
    public partial class Form1 : Form
    {
        private string DirectoryName;
        private int amount;

        public Form1()
        {
            InitializeComponent();
        }

        public static string path;
        private void button2_Click(object sender, EventArgs e)
        {
            if (textBox1.Text == null || textBox1.Text == "")
                MessageBox.Show("Please Select File");
            else
            {
                path = textBox1.Text;
                ModuleDefMD LoadedFile = ModuleDefMD.Load(textBox1.Text);
                if (checkBox1.Checked)
                {
                    amount = StringDecryptor.InvokeDecryption(LoadedFile);
                }
                else
                {
                    amount = StringDecryptor.Run(LoadedFile);
                }
                
                Excess_Nop_Remover.NopRemover(LoadedFile);
                label1.Text = "Strings Decrypted : " + amount;
                string filename = DirectoryName +"\\"+ Path.GetFileNameWithoutExtension(textBox1.Text) + "-Decrypted" + Path.GetExtension(textBox1.Text);
                var opts = new ModuleWriterOptions(LoadedFile);
                opts.Logger = DummyLogger.NoThrowInstance;
                var writerOptions = new NativeModuleWriterOptions(LoadedFile);
                writerOptions.MetaDataOptions.Flags |= MetaDataFlags.PreserveAll;
                writerOptions.Logger = DummyLogger.NoThrowInstance;


                if (LoadedFile.IsILOnly)
                {
                    LoadedFile.Write(filename, opts);
                }
                else
                {
                    LoadedFile.NativeWrite(filename, writerOptions);
                }
                

            }

        }

        private void button1_Click(object sender, EventArgs e)
        {
           
            this.textBox1.Text = "";
            OpenFileDialog dialog = new OpenFileDialog
            {
                Title = "Browse for target assembly",
                InitialDirectory = @"c:\"
            };
            if (DirectoryName != "")
            {
                dialog.InitialDirectory = DirectoryName;
            }
            dialog.Filter = "All files (*.exe,*.dll)|*.exe;*.dll";
            dialog.FilterIndex = 2;
            dialog.RestoreDirectory = true;
            if (dialog.ShowDialog() == DialogResult.OK)
            {
                string fileName = dialog.FileName;
                textBox1.Text = fileName;
                int startIndex = fileName.LastIndexOf(@"\");
                if (startIndex != -1)
                {
                    DirectoryName = fileName.Remove(startIndex, fileName.Length - startIndex);
                }
                if (DirectoryName.Length == 2)
                {
                    DirectoryName = DirectoryName + @"\";
                }
            }

        }
    }
}



================================================
File: ConfuserEx Static String Decryptor/Form1.resx
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="openFileDialog1.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>17, 17</value>
  </metadata>
</root>


================================================
File: ConfuserEx Static String Decryptor/Program.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace ConfuserEx_Static_String_Decryptor
{
    static class Program
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main()
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new Form1());
        }
    }
}



================================================
File: ConfuserEx Static String Decryptor/StringDecryptor.cs
================================================
ï»¿using dnlib.DotNet;
using dnlib.DotNet.Emit;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace ConfuserEx_Static_String_Decryptor
{
    class StringDecryptor
    {
        public static List<Instruction> C = new List<Instruction>();
        public static int StringsDecrypted = 0;
        public static int Run(ModuleDefMD module)
        {
            MethodDef GetFirstMetohd = firstStep(module);
            uint val = getShit(module, GetFirstMetohd);
            if (val == 0)
                return 0;
            string fieldName = getArrayName(module, GetFirstMetohd);
            if (fieldName == null)
                return 0;
            uint[] val2 = getArray(module, fieldName);
            if (val2 == null)
                return 0;
            uint val3 = getFinalShit(module, GetFirstMetohd);
            if (val3 == 0)
                return 0 ;
            smethod_1(val, val2, val3);
            FindString(module);
            return StringsDecrypted;
        }
        public static MethodDef firstStep(ModuleDefMD module)
        {
            foreach (TypeDef type in module.Types)
            {
                foreach (MethodDef method in type.Methods)
                {
                    if (!method.HasBody) continue;
                    if (!method.IsConstructor) continue;
                    if (!method.FullName.ToLower().Contains("module")) continue;
                    for (int i = 0; i < method.Body.Instructions.Count; i++)
                    {
                        if (method.Body.Instructions[i].OpCode == OpCodes.Call)
                        {
                            MethodDef initMethod = (MethodDef)method.Body.Instructions[i].Operand;
                            if (!initMethod.HasBody) continue;
                            if (initMethod.Body.Instructions.Count < 300) continue;
                            for (int y = 0; y < initMethod.Body.Instructions.Count; y++)
                            {

                                if (initMethod.Body.Instructions[y].OpCode == OpCodes.Stloc_0)
                                {
                                    if (initMethod.Body.Instructions[y - 1].IsLdcI4())
                                    {
                                        C.Clear();
                                        var grfds = dthfs(module, initMethod);
                                        if (grfds == false) continue;
                                        else
                                           return initMethod;
                                       
                                    }
                                }

                            }

                        }
                    }
                }
            }
            return null;

        }
        public static bool dthfs(ModuleDefMD module, MethodDef method)
        {
            for (int y = 0; y < method.Body.Instructions.Count; y++)
            {
                if (method.Body.Instructions[y].OpCode == OpCodes.Call)
                {

                    C.Add(method.Body.Instructions[y]);



                }

            }
            return SortList();




        }
        public static bool SortList()
        {
            var dgrfs = "System.Reflection.Assembly System.Reflection.Assembly::Load(System.Byte[])";
            for (int i = 0; i < C.Count; i++)
            {
                if (C[i].Operand.ToString().Contains(dgrfs))
                {
                    return false;
                }
            }
            return true;
        }
        public static uint getFinalShit(ModuleDefMD module, MethodDef correct)
        {
            foreach (TypeDef type in module.Types)
            {
                foreach (MethodDef method in type.Methods)
                {

                    if (!method.HasBody) continue;
                    if (!method.IsConstructor) continue;
                    if (!method.FullName.ToLower().Contains("module")) continue;
                    for (int i = 0; i < method.Body.Instructions.Count; i++)
                    {
                        if (method.Body.Instructions[i].OpCode == OpCodes.Call)
                        {
                            MethodDef initMethod = (MethodDef)method.Body.Instructions[i].Operand;
                            if (!(initMethod == correct)) continue;
                            for (int y = 0; y < initMethod.Body.Instructions.Count; y++)
                            {
                                if (initMethod.Body.Instructions[y].OpCode == OpCodes.Stloc_3)
                                {
                                    if (initMethod.Body.Instructions[y - 1].IsLdcI4())
                                    {
                                        if (initMethod.Body.Instructions[y - 1].GetLdcI4Value() == 0) continue;
                                        else
                                            return (uint)initMethod.Body.Instructions[y - 1].GetLdcI4Value();
                                        


                                    }
                                }
                            }

                        }
                    }
                }
            }
            return 0;
        }

        public static void FindString(ModuleDefMD module)
        {
            foreach (TypeDef type in module.Types)
            {
                foreach (MethodDef method in type.Methods)
                {
                    if (!method.HasBody) continue;

                    for (int i = 0; i < method.Body.Instructions.Count; i++)
                    {
                        if (i < 1) continue;
                        if (method.Body.Instructions[i].OpCode == OpCodes.Call && method.Body.Instructions[i - 1].IsLdcI4())
                        {
                            try
                            {
                                DecryptionMethod = (MethodSpec)method.Body.Instructions[i].Operand;
                                if (DecryptionMethod.FullName.ToLower().Contains("string"))
                                {
                                    string DecryptedStringValue = GetParamValues(module, DecryptionMethod, (uint)method.Body.Instructions[i - 1].GetLdcI4Value());
                                    if (DecryptedStringValue != null)
                                    {
                                        method.Body.Instructions[i].OpCode = OpCodes.Nop;
                                        method.Body.Instructions[i - 1].OpCode = OpCodes.Ldstr;
                                        method.Body.Instructions[i - 1].Operand = DecryptedStringValue;
                                        StringsDecrypted++;
                                    }
                                }

                            }
                            catch
                            {

                            }



                        }
                    }

                }
            }
        }

        public static string GetParamValues(ModuleDefMD module, MethodSpec decryption, uint param)
        {
            foreach (TypeDef type in module.Types)
            {
                foreach (MethodDef method in type.Methods)
                {
                    if (!method.HasBody) continue;
                    if (!(method.FullName.Contains(decryption.Name))) continue;
                    for (int y = 0; y < method.Body.Instructions.Count; y++)
                    {
                        if (method.Body.Instructions[y].OpCode == OpCodes.Mul)
                        {
                            if (method.Body.Instructions[y - 1].IsLdcI4() && method.Body.Instructions[y + 1].IsLdcI4())
                               return smethod_6<string>((uint)param, (uint)method.Body.Instructions[y - 1].GetLdcI4Value(), (uint)method.Body.Instructions[y + 1].GetLdcI4Value());
                            
                        }
                    }
                }
            }
            return null;
        }

        internal static T smethod_6<T>(uint uint_0, uint param1, uint param2)
        {
            uint_0 = (uint_0 * param1 ^ param2);
            uint num = uint_0 >> 30;
            T result = default(T);
            uint_0 &= 1073741823u;
            uint_0 <<= 2;
            num = 3;
            if ((ulong)num == 3uL)
            {
                int count = (int)byte_0[(int)((UIntPtr)(uint_0++))] | (int)byte_0[(int)((UIntPtr)(uint_0++))] << 8 | (int)byte_0[(int)((UIntPtr)(uint_0++))] << 16 | (int)byte_0[(int)((UIntPtr)(uint_0++))] << 24;
                result = (T)((object)string.Intern(Encoding.UTF8.GetString(byte_0, (int)uint_0, count)));
            }
            else if ((ulong)num == 2uL)
            {
                T[] array = new T[1];
                Buffer.BlockCopy(byte_0, (int)uint_0, array, 0, System.Runtime.InteropServices.Marshal.SizeOf(default(T)));
                result = array[0];
            }
            else if ((ulong)num == 0uL)
            {
                int num2 = (int)byte_0[(int)((UIntPtr)(uint_0++))] | (int)byte_0[(int)((UIntPtr)(uint_0++))] << 8 | (int)byte_0[(int)((UIntPtr)(uint_0++))] << 16 | (int)byte_0[(int)((UIntPtr)(uint_0++))] << 24;
                int length = (int)byte_0[(int)((UIntPtr)(uint_0++))] | (int)byte_0[(int)((UIntPtr)(uint_0++))] << 8 | (int)byte_0[(int)((UIntPtr)(uint_0++))] << 16 | (int)byte_0[(int)((UIntPtr)(uint_0++))] << 24;
                Array array2 = Array.CreateInstance(typeof(T).GetElementType(), length);
                Buffer.BlockCopy(byte_0, (int)uint_0, array2, 0, num2 - 4);
                result = (T)((object)array2);
            }
            return result;
        }
        public static uint getShit(ModuleDefMD module, MethodDef correct)
        {
            foreach (TypeDef type in module.Types)
            {
                foreach (MethodDef method in type.Methods)
                {

                    if (!method.HasBody) continue;
                    if (!method.IsConstructor) continue;
                    if (!method.FullName.ToLower().Contains("module")) continue;
                    for (int i = 0; i < method.Body.Instructions.Count; i++)
                    {
                        if (method.Body.Instructions[i].OpCode == OpCodes.Call)
                        {
                            MethodDef initMethod = (MethodDef)method.Body.Instructions[i].Operand;
                            if (!(initMethod == correct)) continue;
                            for (int y = 0; y < initMethod.Body.Instructions.Count; y++)
                            {
                                if (initMethod.Body.Instructions[y].OpCode == OpCodes.Stloc_0)
                                {
                                    if (initMethod.Body.Instructions[y - 1].IsLdcI4())
                                    {
                                        if (initMethod.Body.Instructions[y - 1].GetLdcI4Value() == 0)
                                        {

                                        }
                                        else
                                        {
                                            return (uint)initMethod.Body.Instructions[y - 1].GetLdcI4Value();
                                        }


                                    }
                                }
                            }

                        }
                    }
                }

            }
            return 0;
        }
        public static string getArrayName(ModuleDefMD module, MethodDef correct)
        {
            foreach (TypeDef type in module.Types)
            {
                foreach (MethodDef method in type.Methods)
                {

                    if (!method.HasBody) continue;
                    if (!method.IsConstructor) continue;
                    if (!method.FullName.ToLower().Contains("module")) continue;
                    for (int i = 0; i < method.Body.Instructions.Count; i++)
                    {
                        if (method.Body.Instructions[i].OpCode == OpCodes.Call)
                        {
                            MethodDef initMethod = (MethodDef)method.Body.Instructions[i].Operand;
                            if (!(initMethod == correct)) continue;
                            for (int y = 0; y < initMethod.Body.Instructions.Count; y++)
                            {
                                if (initMethod.Body.Instructions[y].OpCode == OpCodes.Stloc_1)
                                {
                                    if (initMethod.Body.Instructions[y - 2].OpCode == OpCodes.Ldtoken)
                                    {

                                        return (string)initMethod.Body.Instructions[y - 2].Operand.ToString();



                                    }
                                }
                            }

                        }
                    }
                }

            }
            return null;

        }
        public static uint[] getArray(ModuleDefMD module, string fieldName)
        {
            foreach (TypeDef type in module.Types)
            {
                foreach (FieldDef fields in type.Fields)
                {
                    if (!fieldName.ToLower().Contains(fields.Name.ToLower())) continue;
                    if (!fields.HasFieldRVA) continue;
                    if (!(fields.InitialValue.Length != 0)) continue;
                    if (!fields.FullName.ToLower().Contains("module")) continue;
                    if (!fields.IsStatic) continue;
                    if (!fields.IsAssembly) continue;
                    byte[] arrrr = fields.InitialValue;
                    uint[] decoded = new uint[arrrr.Length / 4];
                    Buffer.BlockCopy(arrrr, 0, decoded, 0, arrrr.Length);
                    return (uint[])decoded;

                }

            }
            return null;

        }
  
        private static byte[] byte_0;
        private static MethodSpec DecryptionMethod;

        internal static void smethod_1(uint numis, uint[] arrayy, uint val3)
        {
            uint num = numis;
            uint[] array = arrayy;
            uint[] array2 = new uint[16];
            uint num2 = val3;
            for (int i = 0; i < 16; i++)
            {
                num2 ^= num2 >> 12;
                num2 ^= num2 << 25;
                num2 ^= num2 >> 27;
                array2[i] = num2;
            }
            int num3 = 0;
            int num4 = 0;
            uint[] array3 = new uint[16];
            byte[] array4 = new byte[num * 4u];
            while ((long)num3 < (long)((ulong)num))
            {
                for (int j = 0; j < 16; j++)
                {
                    array3[j] = array[num3 + j];
                }
                array3[0] = (array3[0] ^ array2[0]);
                array3[1] = (array3[1] ^ array2[1]);
                array3[2] = (array3[2] ^ array2[2]);
                array3[3] = (array3[3] ^ array2[3]);
                array3[4] = (array3[4] ^ array2[4]);
                array3[5] = (array3[5] ^ array2[5]);
                array3[6] = (array3[6] ^ array2[6]);
                array3[7] = (array3[7] ^ array2[7]);
                array3[8] = (array3[8] ^ array2[8]);
                array3[9] = (array3[9] ^ array2[9]);
                array3[10] = (array3[10] ^ array2[10]);
                array3[11] = (array3[11] ^ array2[11]);
                array3[12] = (array3[12] ^ array2[12]);
                array3[13] = (array3[13] ^ array2[13]);
                array3[14] = (array3[14] ^ array2[14]);
                array3[15] = (array3[15] ^ array2[15]);
                for (int k = 0; k < 16; k++)
                {
                    uint num5 = array3[k];
                    array4[num4++] = (byte)num5;
                    array4[num4++] = (byte)(num5 >> 8);
                    array4[num4++] = (byte)(num5 >> 16);
                    array4[num4++] = (byte)(num5 >> 24);
                    array2[k] ^= num5;
                }
                num3 += 16;
            }

            byte_0 = smethod_0(array4);
        }
       
        public static int InvokeDecryption(ModuleDefMD module)
        {
            foreach (TypeDef type in module.Types)
            {
                foreach (MethodDef method in type.Methods)
                {
                    if (!method.HasBody) continue;

                    for (int i = 0; i < method.Body.Instructions.Count; i++)
                    {
                        if (i < 1) continue;
                        if (method.Body.Instructions[i].OpCode == OpCodes.Call && method.Body.Instructions[i - 1].IsLdcI4())
                        {
                            try
                            {
                                DecryptionMethod = (MethodSpec)method.Body.Instructions[i].Operand;
                                if (DecryptionMethod.FullName.ToLower().Contains("string"))
                                {
                                    uint param = (uint) method.Body.Instructions[i - 1].GetLdcI4Value();
                                    object[] paramObjects = { param};
                                    MethodBase invokeMethodInfo =
                                        Assembly.LoadFrom(Form1.path).GetModules()[0].ResolveMethod(
                                            DecryptionMethod.MDToken.ToInt32());
                                   
                                    string DecryptedStringValue =(string) invokeMethodInfo.Invoke(null, paramObjects); 
                                    if (DecryptedStringValue != null)
                                    {
                                        method.Body.Instructions[i].OpCode = OpCodes.Nop;
                                        method.Body.Instructions[i - 1].OpCode = OpCodes.Ldstr;
                                        method.Body.Instructions[i - 1].Operand = DecryptedStringValue;
                                        StringsDecrypted++;
                                    }
                                }

                            }
                            catch(Exception exception)
                            {
                               
                            }



                        }
                    }
                }
            }
            return StringsDecrypted;
            
        }
        internal static byte[] smethod_0(byte[] byte_1)
        {
            MemoryStream memoryStream = new MemoryStream(byte_1);

            Class1 @class = new Class1();
            byte[] buffer = new byte[5];
            memoryStream.Read(buffer, 0, 5);
            @class.method_5(buffer);
            long num = 0L;
            for (int i = 0; i < 8; i++)
            {
                int num2 = memoryStream.ReadByte();
                num |= (long)((long)((ulong)((byte)num2)) << 8 * i);
            }
            byte[] array = new byte[(int)num];
            MemoryStream stream_ = new MemoryStream(array, true);
            long long_ = memoryStream.Length - 13L;
            @class.method_4(memoryStream, stream_, long_, num);
            return array;
        }
    }

    internal class Class1
    {
        internal Class1()
        {
            this.uint_0 = 4294967295u;
            int num = 0;
            while ((long)num < 4L)
            {
                this.struct1_0[num] = new Struct1(6);
                num++;
            }
        }

        // Token: 0x06000016 RID: 22 RVA: 0x000031E0 File Offset: 0x000031E0
        internal void method_0(uint uint_3)
        {
            if (this.uint_0 != uint_3)
            {
                this.uint_0 = uint_3;
                this.uint_1 = Math.Max(this.uint_0, 1u);
                uint uint_4 = Math.Max(this.uint_1, 4096u);
                this.class4_0.method_0(uint_4);
            }
        }

        // Token: 0x06000017 RID: 23 RVA: 0x0000218A File Offset: 0x0000218A
        internal void method_1(int int_0, int int_1)
        {
            this.class3_0.method_0(int_0, int_1);
        }

        // Token: 0x06000018 RID: 24 RVA: 0x0000322C File Offset: 0x0000322C
        internal void method_2(int int_0)
        {
            uint num = 1u << int_0;
            this.class2_0.method_0(num);
            this.class2_1.method_0(num);
            this.uint_2 = num - 1u;
        }

        // Token: 0x06000019 RID: 25 RVA: 0x00003264 File Offset: 0x00003264
        internal void method_3(Stream stream_0, Stream stream_1)
        {
            this.class0_0.method_0(stream_0);
            this.class4_0.method_1(stream_1, this.bool_0);
            for (uint num = 0u; num < 12u; num += 1u)
            {
                for (uint num2 = 0u; num2 <= this.uint_2; num2 += 1u)
                {
                    uint num3 = (num << 4) + num2;
                    this.struct0_0[(int)((UIntPtr)num3)].method_0();
                    this.struct0_1[(int)((UIntPtr)num3)].method_0();
                }
                this.struct0_2[(int)((UIntPtr)num)].method_0();
                this.struct0_3[(int)((UIntPtr)num)].method_0();
                this.struct0_4[(int)((UIntPtr)num)].method_0();
                this.struct0_5[(int)((UIntPtr)num)].method_0();
            }
            this.class3_0.method_1();
            for (uint num = 0u; num < 4u; num += 1u)
            {
                this.struct1_0[(int)((UIntPtr)num)].method_0();
            }
            for (uint num = 0u; num < 114u; num += 1u)
            {
                this.struct0_6[(int)((UIntPtr)num)].method_0();
            }
            this.class2_0.method_1();
            this.class2_1.method_1();
            this.struct1_1.method_0();
        }

        // Token: 0x0600001A RID: 26 RVA: 0x00003390 File Offset: 0x00003390
        internal void method_4(Stream stream_0, Stream stream_1, long long_0, long long_1)
        {
            this.method_3(stream_0, stream_1);

            Struct3 @struct = default(Struct3);
            @struct.method_0();
            uint num = 0u;
            uint num2 = 0u;
            uint num3 = 0u;
            uint num4 = 0u;
            ulong num5 = 0uL;
            if (0L < long_1)
            {
                this.struct0_0[(int)((UIntPtr)(@struct.uint_0 << 4))].method_1(this.class0_0);
                @struct.method_1();
                byte byte_ = this.class3_0.method_3(this.class0_0, 0u, 0);
                this.class4_0.method_5(byte_);
                num5 += 1uL;
            }
            while (num5 < (ulong)long_1)
            {
                uint num6 = (uint)num5 & this.uint_2;
                if (this.struct0_0[(int)((UIntPtr)((@struct.uint_0 << 4) + num6))].method_1(this.class0_0) == 0u)
                {
                    byte byte_2 = this.class4_0.method_6(0u);
                    byte byte_3;
                    if (!@struct.method_5())
                    {
                        byte_3 = this.class3_0.method_4(this.class0_0, (uint)num5, byte_2, this.class4_0.method_6(num));
                    }
                    else
                    {
                        byte_3 = this.class3_0.method_3(this.class0_0, (uint)num5, byte_2);
                    }
                    this.class4_0.method_5(byte_3);
                    @struct.method_1();
                    num5 += 1uL;
                }
                else
                {
                    uint num8;
                    if (this.struct0_2[(int)((UIntPtr)@struct.uint_0)].method_1(this.class0_0) == 1u)
                    {
                        if (this.struct0_3[(int)((UIntPtr)@struct.uint_0)].method_1(this.class0_0) == 0u)
                        {
                            if (this.struct0_1[(int)((UIntPtr)((@struct.uint_0 << 4) + num6))].method_1(this.class0_0) == 0u)
                            {
                                @struct.method_4();
                                this.class4_0.method_5(this.class4_0.method_6(num));
                                num5 += 1uL;
                                continue;
                            }
                        }
                        else
                        {
                            uint num7;
                            if (this.struct0_4[(int)((UIntPtr)@struct.uint_0)].method_1(this.class0_0) == 0u)
                            {
                                num7 = num2;
                            }
                            else
                            {
                                if (this.struct0_5[(int)((UIntPtr)@struct.uint_0)].method_1(this.class0_0) == 0u)
                                {
                                    num7 = num3;
                                }
                                else
                                {
                                    num7 = num4;
                                    num4 = num3;
                                }
                                num3 = num2;
                            }
                            num2 = num;
                            num = num7;
                        }
                        num8 = this.class2_1.method_2(this.class0_0, num6) + 2u;
                        @struct.method_3();
                    }
                    else
                    {
                        num4 = num3;
                        num3 = num2;
                        num2 = num;
                        num8 = 2u + this.class2_0.method_2(this.class0_0, num6);
                        @struct.method_2();
                        uint num9 = this.struct1_0[(int)((UIntPtr)Class1.smethod_0(num8))].method_1(this.class0_0);
                        if (num9 >= 4u)
                        {
                            int num10 = (int)((num9 >> 1) - 1u);
                            num = (2u | (num9 & 1u)) << num10;
                            if (num9 < 14u)
                            {
                                num += Struct1.smethod_0(this.struct0_6, num - num9 - 1u, this.class0_0, num10);
                            }
                            else
                            {
                                num += this.class0_0.method_3(num10 - 4) << 4;
                                num += this.struct1_1.method_2(this.class0_0);
                            }
                        }
                        else
                        {
                            num = num9;
                        }
                    }
                    if (((ulong)num >= num5 || num >= this.uint_1) && num == 4294967295u)
                    {
                        break;
                    }
                    this.class4_0.method_4(num, num8);
                    num5 += (ulong)num8;
                }
            }
            this.class4_0.method_3();
            this.class4_0.method_2();
            this.class0_0.method_1();
        }

        // Token: 0x0600001B RID: 27 RVA: 0x00003704 File Offset: 0x00003704
        internal void method_5(byte[] byte_0)
        {
            int int_ = (int)(byte_0[0] % 9);
            int num = (int)(byte_0[0] / 9);
            int int_2 = num % 5;
            int int_3 = num / 5;
            uint num2 = 0u;
            for (int i = 0; i < 4; i++)
            {
                num2 += (uint)((uint)byte_0[1 + i] << i * 8);
            }
            this.method_0(num2);
            this.method_1(int_2, int_);
            this.method_2(int_3);
        }
        internal void method_01(uint uint_3)
        {
            if (this.uint_0 != uint_3)
            {
                this.uint_0 = uint_3;
                this.uint_1 = Math.Max(this.uint_0, 1u);
                uint uint_4 = Math.Max(this.uint_1, 4096u);
                this.class4_0.method_0(uint_4);
            }
        }

        // Token: 0x0600001C RID: 28 RVA: 0x00002199 File Offset: 0x00002199
        internal static uint smethod_0(uint uint_3)
        {
            uint_3 -= 2u;
            if (uint_3 < 4u)
            {
                return uint_3;
            }
            return 3u;
        }

        // Token: 0x04000009 RID: 9
        internal readonly Struct0[] struct0_0 = new Struct0[192];

        // Token: 0x0400000A RID: 10
        internal readonly Struct0[] struct0_1 = new Struct0[192];

        // Token: 0x0400000B RID: 11
        internal readonly Struct0[] struct0_2 = new Struct0[12];

        // Token: 0x0400000C RID: 12
        internal readonly Struct0[] struct0_3 = new Struct0[12];

        // Token: 0x0400000D RID: 13
        internal readonly Struct0[] struct0_4 = new Struct0[12];

        // Token: 0x0400000E RID: 14
        internal readonly Struct0[] struct0_5 = new Struct0[12];

        // Token: 0x0400000F RID: 15
        internal readonly Class1.Class2 class2_0 = new Class1.Class2();

        // Token: 0x04000010 RID: 16
        internal readonly Class1.Class3 class3_0 = new Class1.Class3();

        // Token: 0x04000011 RID: 17
        internal readonly Class4 class4_0 = new Class4();

        // Token: 0x04000012 RID: 18
        internal readonly Struct0[] struct0_6 = new Struct0[114];

        // Token: 0x04000013 RID: 19
        internal readonly Struct1[] struct1_0 = new Struct1[4];

        // Token: 0x04000014 RID: 20
        internal readonly Class0 class0_0 = new Class0();

        // Token: 0x04000015 RID: 21
        internal readonly Class1.Class2 class2_1 = new Class1.Class2();

        // Token: 0x04000016 RID: 22
        internal bool bool_0;

        // Token: 0x04000017 RID: 23
        internal uint uint_0;

        // Token: 0x04000018 RID: 24
        internal uint uint_1;

        // Token: 0x04000019 RID: 25
        internal Struct1 struct1_1 = new Struct1(4);

        // Token: 0x0400001A RID: 26
        internal uint uint_2;

        // Token: 0x02000006 RID: 6
        internal class Class2
        {
            // Token: 0x0600001D RID: 29 RVA: 0x00003764 File Offset: 0x00003764
            internal void method_0(uint uint_1)
            {
                for (uint num = this.uint_0; num < uint_1; num += 1u)
                {
                    this.struct1_0[(int)((UIntPtr)num)] = new Struct1(3);
                    this.struct1_1[(int)((UIntPtr)num)] = new Struct1(3);
                }
                this.uint_0 = uint_1;
            }

            // Token: 0x0600001E RID: 30 RVA: 0x000037BC File Offset: 0x000037BC
            internal void method_1()
            {
                this.struct0_0.method_0();
                for (uint num = 0u; num < this.uint_0; num += 1u)
                {
                    this.struct1_0[(int)((UIntPtr)num)].method_0();
                    this.struct1_1[(int)((UIntPtr)num)].method_0();
                }
                this.struct0_1.method_0();
                this.struct1_2.method_0();
            }

            // Token: 0x0600001F RID: 31 RVA: 0x00003820 File Offset: 0x00003820
            internal uint method_2(Class0 class0_0, uint uint_1)
            {
                if (this.struct0_0.method_1(class0_0) == 0u)
                {
                    return this.struct1_0[(int)((UIntPtr)uint_1)].method_1(class0_0);
                }
                uint num = 8u;
                if (this.struct0_1.method_1(class0_0) == 0u)
                {
                    num += this.struct1_1[(int)((UIntPtr)uint_1)].method_1(class0_0);
                }
                else
                {
                    num += 8u;
                    num += this.struct1_2.method_1(class0_0);
                }
                return num;
            }

            // Token: 0x06000020 RID: 32 RVA: 0x0000388C File Offset: 0x0000388C
            internal Class2()
            {
            }

            // Token: 0x0400001B RID: 27
            internal readonly Struct1[] struct1_0 = new Struct1[16];

            // Token: 0x0400001C RID: 28
            internal readonly Struct1[] struct1_1 = new Struct1[16];

            // Token: 0x0400001D RID: 29
            internal Struct0 struct0_0 = default(Struct0);

            // Token: 0x0400001E RID: 30
            internal Struct0 struct0_1 = default(Struct0);

            // Token: 0x0400001F RID: 31
            internal Struct1 struct1_2 = new Struct1(8);

            // Token: 0x04000020 RID: 32
            internal uint uint_0;
        }

        // Token: 0x02000007 RID: 7
        internal class Class3
        {
            // Token: 0x06000021 RID: 33 RVA: 0x000038E0 File Offset: 0x000038E0
            internal void method_0(int int_2, int int_3)
            {
                if (this.struct2_0 != null && this.int_1 == int_3 && this.int_0 == int_2)
                {
                    return;
                }
                this.int_0 = int_2;
                this.uint_0 = (1u << int_2) - 1u;
                this.int_1 = int_3;
                uint num = 1u << this.int_1 + this.int_0;
                this.struct2_0 = new Class1.Class3.Struct2[num];
                for (uint num2 = 0u; num2 < num; num2 += 1u)
                {
                    this.struct2_0[(int)((UIntPtr)num2)].method_0();
                }
            }

            // Token: 0x06000022 RID: 34 RVA: 0x00003964 File Offset: 0x00003964
            internal void method_1()
            {
                uint num = 1u << this.int_1 + this.int_0;
                for (uint num2 = 0u; num2 < num; num2 += 1u)
                {
                    this.struct2_0[(int)((UIntPtr)num2)].method_1();
                }
            }

            // Token: 0x06000023 RID: 35 RVA: 0x000021A7 File Offset: 0x000021A7
            internal uint method_2(uint uint_1, byte byte_0)
            {
                return ((uint_1 & this.uint_0) << this.int_1) + (uint)(byte_0 >> 8 - this.int_1);
            }

            // Token: 0x06000024 RID: 36 RVA: 0x000021C9 File Offset: 0x000021C9
            internal byte method_3(Class0 class0_0, uint uint_1, byte byte_0)
            {
                return this.struct2_0[(int)((UIntPtr)this.method_2(uint_1, byte_0))].method_2(class0_0);
            }

            // Token: 0x06000025 RID: 37 RVA: 0x000021E5 File Offset: 0x000021E5
            internal byte method_4(Class0 class0_0, uint uint_1, byte byte_0, byte byte_1)
            {
                return this.struct2_0[(int)((UIntPtr)this.method_2(uint_1, byte_0))].method_3(class0_0, byte_1);
            }

            // Token: 0x06000026 RID: 38 RVA: 0x00002182 File Offset: 0x00002182
            internal Class3()
            {
            }

            // Token: 0x04000021 RID: 33
            internal Class1.Class3.Struct2[] struct2_0;

            // Token: 0x04000022 RID: 34
            internal int int_0;

            // Token: 0x04000023 RID: 35
            internal int int_1;

            // Token: 0x04000024 RID: 36
            internal uint uint_0;

            // Token: 0x02000008 RID: 8
            internal struct Struct2
            {
                // Token: 0x06000027 RID: 39 RVA: 0x00002203 File Offset: 0x00002203
                internal void method_0()
                {
                    this.struct0_0 = new Struct0[768];
                }

                // Token: 0x06000028 RID: 40 RVA: 0x000039A4 File Offset: 0x000039A4
                internal void method_1()
                {
                    for (int i = 0; i < 768; i++)
                    {
                        this.struct0_0[i].method_0();
                    }
                }

                // Token: 0x06000029 RID: 41 RVA: 0x000039D4 File Offset: 0x000039D4
                internal byte method_2(Class0 class0_0)
                {
                    uint num = 1u;
                    do
                    {
                        num = (num << 1 | this.struct0_0[(int)((UIntPtr)num)].method_1(class0_0));
                    }
                    while (num < 256u);
                    return (byte)num;
                }

                // Token: 0x0600002A RID: 42 RVA: 0x00003A08 File Offset: 0x00003A08
                internal byte method_3(Class0 class0_0, byte byte_0)
                {
                    uint num = 1u;
                    while (true)
                    {
                        uint num2 = (uint)(byte_0 >> 7 & 1);
                        byte_0 = (byte)(byte_0 << 1);
                        uint num3 = this.struct0_0[(int)((UIntPtr)((1u + num2 << 8) + num))].method_1(class0_0);
                        num = (num << 1 | num3);
                        if (num2 != num3)
                        {
                            break;
                        }
                        if (num >= 256u)
                        {
                            goto IL_5E;
                        }
                    }
                    while (num < 256u)
                    {
                        num = (num << 1 | this.struct0_0[(int)((UIntPtr)num)].method_1(class0_0));
                    }
                    IL_5E:
                    return (byte)num;
                }

                // Token: 0x04000025 RID: 37
                internal Struct0[] struct0_0;
            }
        }
    }

    internal class Struct1
    {
        internal Struct1(int int_1)
        {
            this.int_0 = int_1;
            this.struct0_0 = new Struct0[1 << int_1];
        }

        // Token: 0x0600000C RID: 12 RVA: 0x00002F18 File Offset: 0x00002F18
        internal void method_0()
        {
            uint num = 1u;
            while ((ulong)num < (ulong)(1L << (this.int_0 & 31)))
            {
                this.struct0_0[(int)((UIntPtr)num)].method_0();
                num += 1u;
            }
        }

        // Token: 0x0600000D RID: 13 RVA: 0x00002F50 File Offset: 0x00002F50
        internal uint method_1(Class0 class0_0)
        {
            uint num = 1u;
            for (int i = this.int_0; i > 0; i--)
            {
                num = (num << 1) + this.struct0_0[(int)((UIntPtr)num)].method_1(class0_0);
            }
            return num - (1u << this.int_0);
        }

        // Token: 0x0600000E RID: 14 RVA: 0x00002F98 File Offset: 0x00002F98
        internal uint method_2(Class0 class0_0)
        {
            uint num = 1u;
            uint num2 = 0u;
            for (int i = 0; i < this.int_0; i++)
            {
                uint num3 = this.struct0_0[(int)((UIntPtr)num)].method_1(class0_0);
                num <<= 1;
                num += num3;
                num2 |= num3 << i;
            }
            return num2;
        }

        // Token: 0x0600000F RID: 15 RVA: 0x00002FE0 File Offset: 0x00002FE0
        internal static uint smethod_0(Struct0[] struct0_1, uint uint_0, Class0 class0_0, int int_1)
        {
            uint num = 1u;
            uint num2 = 0u;
            for (int i = 0; i < int_1; i++)
            {
                uint num3 = struct0_1[(int)((UIntPtr)(uint_0 + num))].method_1(class0_0);
                num <<= 1;
                num += num3;
                num2 |= num3 << i;
            }
            return num2;
        }

        // Token: 0x04000004 RID: 4
        internal readonly Struct0[] struct0_0;

        // Token: 0x04000005 RID: 5
        internal readonly int int_0;
    }
    internal struct Struct0
    {
        // Token: 0x06000009 RID: 9 RVA: 0x00002117 File Offset: 0x00002117
        internal void method_0()
        {
            this.uint_0 = 1024u;
        }

        // Token: 0x0600000A RID: 10 RVA: 0x00002E2C File Offset: 0x00002E2C
        internal uint method_1(Class0 class0_0)
        {
            uint num = (class0_0.uint_1 >> 11) * this.uint_0;
            if (class0_0.uint_0 < num)
            {
                class0_0.uint_1 = num;
                this.uint_0 += 2048u - this.uint_0 >> 5;
                if (class0_0.uint_1 < 16777216u)
                {
                    class0_0.uint_0 = (class0_0.uint_0 << 8 | (uint)((byte)class0_0.stream_0.ReadByte()));
                    class0_0.uint_1 <<= 8;
                }
                return 0u;
            }
            class0_0.uint_1 -= num;
            class0_0.uint_0 -= num;
            this.uint_0 -= this.uint_0 >> 5;
            if (class0_0.uint_1 < 16777216u)
            {
                class0_0.uint_0 = (class0_0.uint_0 << 8 | (uint)((byte)class0_0.stream_0.ReadByte()));
                class0_0.uint_1 <<= 8;
            }
            return 1u;
        }

        // Token: 0x04000003 RID: 3
        internal uint uint_0;
    }
    internal struct Struct3
    {
        // Token: 0x06000033 RID: 51 RVA: 0x00002293 File Offset: 0x00002293
        internal void method_0()
        {
            this.uint_0 = 0u;
        }

        // Token: 0x06000034 RID: 52 RVA: 0x0000229C File Offset: 0x0000229C
        internal void method_1()
        {
            if (this.uint_0 < 4u)
            {
                this.uint_0 = 0u;
                return;
            }
            if (this.uint_0 < 10u)
            {
                this.uint_0 -= 3u;
                return;
            }
            this.uint_0 -= 6u;
        }

        // Token: 0x06000035 RID: 53 RVA: 0x000022D6 File Offset: 0x000022D6
        internal void method_2()
        {
            this.uint_0 = ((this.uint_0 < 7u) ? 7u : 10u);
        }

        // Token: 0x06000036 RID: 54 RVA: 0x000022EC File Offset: 0x000022EC
        internal void method_3()
        {
            this.uint_0 = ((this.uint_0 < 7u) ? 8u : 11u);
        }

        // Token: 0x06000037 RID: 55 RVA: 0x00002302 File Offset: 0x00002302
        internal void method_4()
        {
            this.uint_0 = ((this.uint_0 < 7u) ? 9u : 11u);
        }

        // Token: 0x06000038 RID: 56 RVA: 0x00002319 File Offset: 0x00002319
        internal bool method_5()
        {
            return this.uint_0 < 7u;
        }

        // Token: 0x0400002B RID: 43
        internal uint uint_0;
    }
    internal class Class0
    {
        // Token: 0x06000010 RID: 16 RVA: 0x00003020 File Offset: 0x00003020
        internal void method_0(Stream stream_1)
        {
            this.stream_0 = stream_1;
            this.uint_0 = 0u;
            this.uint_1 = 4294967295u;
            for (int i = 0; i < 5; i++)
            {
                this.uint_0 = (this.uint_0 << 8 | (uint)((byte)this.stream_0.ReadByte()));
            }
        }

        // Token: 0x06000011 RID: 17 RVA: 0x0000213E File Offset: 0x0000213E
        internal void method_1()
        {
            this.stream_0 = null;
        }

        // Token: 0x06000012 RID: 18 RVA: 0x00002147 File Offset: 0x00002147
        internal void method_2()
        {
            while (this.uint_1 < 16777216u)
            {
                this.uint_0 = (this.uint_0 << 8 | (uint)((byte)this.stream_0.ReadByte()));
                this.uint_1 <<= 8;
            }
        }

        // Token: 0x06000013 RID: 19 RVA: 0x0000306C File Offset: 0x0000306C
        internal uint method_3(int int_0)
        {
            uint num = this.uint_1;
            uint num2 = this.uint_0;
            uint num3 = 0u;
            for (int i = int_0; i > 0; i--)
            {
                num >>= 1;
                uint num4 = num2 - num >> 31;
                num2 -= (num & num4 - 1u);
                num3 = (num3 << 1 | 1u - num4);
                if (num < 16777216u)
                {
                    num2 = (num2 << 8 | (uint)((byte)this.stream_0.ReadByte()));
                    num <<= 8;
                }
            }
            this.uint_1 = num;
            this.uint_0 = num2;
            return num3;
        }

        // Token: 0x06000014 RID: 20 RVA: 0x00002182 File Offset: 0x00002182
        internal Class0()
        {
        }

        // Token: 0x04000006 RID: 6
        internal uint uint_0;

        // Token: 0x04000007 RID: 7
        internal uint uint_1;

        // Token: 0x04000008 RID: 8
        internal Stream stream_0;
    }
    internal class Class4
    {
        // Token: 0x0600002B RID: 43 RVA: 0x00002215 File Offset: 0x00002215
        internal void method_0(uint uint_3)
        {
            if (this.uint_2 != uint_3)
            {
                this.byte_0 = new byte[uint_3];
            }
            this.uint_2 = uint_3;
            this.uint_0 = 0u;
            this.uint_1 = 0u;
        }

        // Token: 0x0600002C RID: 44 RVA: 0x00002242 File Offset: 0x00002242
        internal void method_1(Stream stream_1, bool bool_0)
        {
            this.method_2();
            this.stream_0 = stream_1;
            if (!bool_0)
            {
                this.uint_1 = 0u;
                this.uint_0 = 0u;
            }
        }

        // Token: 0x0600002D RID: 45 RVA: 0x00002262 File Offset: 0x00002262
        internal void method_2()
        {
            this.method_3();
            this.stream_0 = null;
            Buffer.BlockCopy(new byte[this.byte_0.Length], 0, this.byte_0, 0, this.byte_0.Length);
        }

        // Token: 0x0600002E RID: 46 RVA: 0x00003A78 File Offset: 0x00003A78
        internal void method_3()
        {
            uint num = this.uint_0 - this.uint_1;
            if (num == 0u)
            {
                return;
            }
            this.stream_0.Write(this.byte_0, (int)this.uint_1, (int)num);
            if (this.uint_0 >= this.uint_2)
            {
                this.uint_0 = 0u;
            }
            this.uint_1 = this.uint_0;
        }

        // Token: 0x0600002F RID: 47 RVA: 0x00003AD0 File Offset: 0x00003AD0
        internal void method_4(uint uint_3, uint uint_4)
        {
            uint num = this.uint_0 - uint_3 - 1u;
            if (num >= this.uint_2)
            {
                num += this.uint_2;
            }
            while (uint_4 > 0u)
            {
                if (num >= this.uint_2)
                {
                    num = 0u;
                }
                this.byte_0[(int)((UIntPtr)(this.uint_0++))] = this.byte_0[(int)((UIntPtr)(num++))];
                if (this.uint_0 >= this.uint_2)
                {
                    this.method_3();
                }
                uint_4 -= 1u;
            }
        }

        // Token: 0x06000030 RID: 48 RVA: 0x00003B4C File Offset: 0x00003B4C
        internal void method_5(byte byte_1)
        {
            this.byte_0[(int)((UIntPtr)(this.uint_0++))] = byte_1;
            if (this.uint_0 >= this.uint_2)
            {
                this.method_3();
            }
        }

        // Token: 0x06000031 RID: 49 RVA: 0x00003B88 File Offset: 0x00003B88
        internal byte method_6(uint uint_3)
        {
            uint num = this.uint_0 - uint_3 - 1u;
            if (num >= this.uint_2)
            {
                num += this.uint_2;
            }
            return this.byte_0[(int)((UIntPtr)num)];
        }

        // Token: 0x06000032 RID: 50 RVA: 0x00002182 File Offset: 0x00002182
        internal Class4()
        {
        }

        // Token: 0x04000026 RID: 38
        internal byte[] byte_0;

        // Token: 0x04000027 RID: 39
        internal uint uint_0;

        // Token: 0x04000028 RID: 40
        internal Stream stream_0;

        // Token: 0x04000029 RID: 41
        internal uint uint_1;

        // Token: 0x0400002A RID: 42
        internal uint uint_2;
    }
}



================================================
File: ConfuserEx Static String Decryptor/Properties/AssemblyInfo.cs
================================================
ï»¿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("ConfuserEx Static String Decryptor")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("ConfuserEx Static String Decryptor")]
[assembly: AssemblyCopyright("Copyright Â©  2016")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("9f4ef3d7-b13f-4b57-a0ee-be728dc7d2cb")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]



================================================
File: ConfuserEx Static String Decryptor/Properties/Resources.Designer.cs
================================================
ï»¿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace ConfuserEx_Static_String_Decryptor.Properties
{


    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources
    {

        private static global::System.Resources.ResourceManager resourceMan;

        private static global::System.Globalization.CultureInfo resourceCulture;

        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources()
        {
        }

        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager
        {
            get
            {
                if ((resourceMan == null))
                {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("ConfuserEx_Static_String_Decryptor.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }

        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture
        {
            get
            {
                return resourceCulture;
            }
            set
            {
                resourceCulture = value;
            }
        }
    }
}



================================================
File: ConfuserEx Static String Decryptor/Properties/Resources.resx
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>


================================================
File: ConfuserEx Static String Decryptor/Properties/Settings.Designer.cs
================================================
ï»¿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace ConfuserEx_Static_String_Decryptor.Properties
{


    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "11.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase
    {

        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));

        public static Settings Default
        {
            get
            {
                return defaultInstance;
            }
        }
    }
}



================================================
File: ConfuserEx Static String Decryptor/Properties/Settings.settings
================================================
ï»¿<?xml version='1.0' encoding='utf-8'?>
<SettingsFile xmlns="http://schemas.microsoft.com/VisualStudio/2004/01/settings" CurrentProfile="(Default)">
  <Profiles>
    <Profile Name="(Default)" />
  </Profiles>
  <Settings />
</SettingsFile>



================================================
File: ConfuserEx Static String Decryptor/bin/Debug/ConfuserEx Static String Decryptor.exe.config
================================================
ï»¿<?xml version="1.0" encoding="utf-8" ?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5.2" />
    </startup>
</configuration>


================================================
File: ConfuserEx Static String Decryptor/bin/Debug/ConfuserEx Static String Decryptor.vshost.exe.config
================================================
ï»¿<?xml version="1.0" encoding="utf-8" ?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5.2" />
    </startup>
</configuration>


================================================
File: ConfuserEx Static String Decryptor/bin/Debug/ConfuserEx Static String Decryptor.vshost.exe.manifest
================================================
ï»¿<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
  <assemblyIdentity version="1.0.0.0" name="MyApplication.app"/>
  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v2">
    <security>
      <requestedPrivileges xmlns="urn:schemas-microsoft-com:asm.v3">
        <requestedExecutionLevel level="asInvoker" uiAccess="false"/>
      </requestedPrivileges>
    </security>
  </trustInfo>
</assembly>



================================================
File: ConfuserEx Static String Decryptor/obj/Debug/ConfuserEx Static String Decryptor.csproj.FileListAbsolute.txt
================================================
c:\users\admin\documents\visual studio 2015\Projects\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\bin\Debug\ConfuserEx Static String Decryptor.exe.config
c:\users\admin\documents\visual studio 2015\Projects\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\bin\Debug\ConfuserEx Static String Decryptor.exe
c:\users\admin\documents\visual studio 2015\Projects\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\bin\Debug\ConfuserEx Static String Decryptor.pdb
c:\users\admin\documents\visual studio 2015\Projects\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\bin\Debug\dnlib.dll
c:\users\admin\documents\visual studio 2015\Projects\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\bin\Debug\dnlib.pdb
c:\users\admin\documents\visual studio 2015\Projects\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\bin\Debug\dnlib.xml
c:\users\admin\documents\visual studio 2015\Projects\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\obj\Debug\ConfuserEx Static String Decryptor.csprojResolveAssemblyReference.cache
c:\users\admin\documents\visual studio 2015\Projects\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\obj\Debug\ConfuserEx_Static_String_Decryptor.Form1.resources
c:\users\admin\documents\visual studio 2015\Projects\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\obj\Debug\ConfuserEx_Static_String_Decryptor.Properties.Resources.resources
c:\users\admin\documents\visual studio 2015\Projects\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\obj\Debug\ConfuserEx Static String Decryptor.csproj.GenerateResource.Cache
c:\users\admin\documents\visual studio 2015\Projects\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\obj\Debug\ConfuserEx Static String Decryptor.exe
c:\users\admin\documents\visual studio 2015\Projects\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\obj\Debug\ConfuserEx Static String Decryptor.pdb
F:\Backup 13-11-16\Visual Studio 2015\Projects\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\bin\Debug\ConfuserEx Static String Decryptor.exe.config
F:\Backup 13-11-16\Visual Studio 2015\Projects\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\obj\Debug\ConfuserEx Static String Decryptor.exe
F:\Backup 13-11-16\Visual Studio 2015\Projects\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\obj\Debug\ConfuserEx Static String Decryptor.pdb
F:\Backup 13-11-16\Visual Studio 2015\Projects\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\bin\Debug\ConfuserEx Static String Decryptor.exe
F:\Backup 13-11-16\Visual Studio 2015\Projects\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\bin\Debug\ConfuserEx Static String Decryptor.pdb
F:\Backup 13-11-16\Visual Studio 2015\Projects\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\bin\Debug\dnlib.dll
F:\Backup 13-11-16\Visual Studio 2015\Projects\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\bin\Debug\dnlib.pdb
F:\Backup 13-11-16\Visual Studio 2015\Projects\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\bin\Debug\dnlib.xml
F:\Backup 13-11-16\Visual Studio 2015\Projects\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\obj\Debug\ConfuserEx Static String Decryptor.csprojResolveAssemblyReference.cache
F:\Backup 13-11-16\Visual Studio 2015\Projects\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\obj\Debug\ConfuserEx_Static_String_Decryptor.Form1.resources
F:\Backup 13-11-16\Visual Studio 2015\Projects\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\obj\Debug\ConfuserEx_Static_String_Decryptor.Properties.Resources.resources
F:\Backup 13-11-16\Visual Studio 2015\Projects\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\obj\Debug\ConfuserEx Static String Decryptor.csproj.GenerateResource.Cache
C:\Users\owner\Documents\RE\Confuserex\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\bin\Debug\ConfuserEx Static String Decryptor.exe.config
C:\Users\owner\Documents\RE\Confuserex\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\obj\Debug\ConfuserEx Static String Decryptor.exe
C:\Users\owner\Documents\RE\Confuserex\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\obj\Debug\ConfuserEx Static String Decryptor.pdb
C:\Users\owner\Documents\RE\Confuserex\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\bin\Debug\ConfuserEx Static String Decryptor.exe
C:\Users\owner\Documents\RE\Confuserex\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\bin\Debug\ConfuserEx Static String Decryptor.pdb
C:\Users\owner\Documents\RE\Confuserex\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\bin\Debug\dnlib.pdb
C:\Users\owner\Documents\RE\Confuserex\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\bin\Debug\dnlib.xml
C:\Users\owner\Documents\RE\Confuserex\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\obj\Debug\ConfuserEx Static String Decryptor.csprojResolveAssemblyReference.cache
C:\Users\owner\Documents\RE\Confuserex\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\obj\Debug\ConfuserEx_Static_String_Decryptor.Form1.resources
C:\Users\owner\Documents\RE\Confuserex\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\obj\Debug\ConfuserEx_Static_String_Decryptor.Properties.Resources.resources
C:\Users\owner\Documents\RE\Confuserex\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\obj\Debug\ConfuserEx Static String Decryptor.csproj.GenerateResource.Cache
D:\backup4-2-17\re\Confuserex\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\bin\Debug\ConfuserEx Static String Decryptor.exe.config
D:\backup4-2-17\re\Confuserex\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\obj\Debug\ConfuserEx Static String Decryptor.exe
D:\backup4-2-17\re\Confuserex\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\obj\Debug\ConfuserEx Static String Decryptor.pdb
D:\backup4-2-17\re\Confuserex\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\obj\Debug\ConfuserEx Static String Decryptor.csprojResolveAssemblyReference.cache
D:\backup4-2-17\re\Confuserex\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\obj\Debug\ConfuserEx_Static_String_Decryptor.Form1.resources
D:\backup4-2-17\re\Confuserex\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\obj\Debug\ConfuserEx_Static_String_Decryptor.Properties.Resources.resources
D:\backup4-2-17\re\Confuserex\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\obj\Debug\ConfuserEx Static String Decryptor.csproj.GenerateResource.Cache
D:\backup4-2-17\re\Confuserex\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\bin\Debug\ConfuserEx Static String Decryptor.exe
D:\backup4-2-17\re\Confuserex\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\ConfuserEx Static String Decryptor\bin\Debug\ConfuserEx Static String Decryptor.pdb



================================================
File: ConfuserEx Static String Decryptor/obj/Debug/ConfuserEx Static String Decryptor.csproj.GenerateResource.Cache
================================================
[Non-text file]


================================================
File: ConfuserEx Static String Decryptor/obj/Debug/ConfuserEx Static String Decryptor.csprojResolveAssemblyReference.cache
================================================
[Non-text file]


================================================
File: ConfuserEx Static String Decryptor/obj/Debug/ConfuserEx_Static_String_Decryptor.Form1.resources
================================================
[Non-text file]


================================================
File: ConfuserEx Static String Decryptor/obj/Debug/ConfuserEx_Static_String_Decryptor.Properties.Resources.resources
================================================
[Non-text file]


================================================
File: ConfuserEx Static String Decryptor/obj/Debug/DesignTimeResolveAssemblyReferences.cache
================================================
[Non-text file]


================================================
File: ConfuserEx Static String Decryptor/obj/Debug/DesignTimeResolveAssemblyReferencesInput.cache
================================================
[Non-text file]


================================================
File: ConfuserEx Static String Decryptor/obj/Debug/TemporaryGeneratedFile_036C0B5B-1481-4323-8D20-8F5ADCB23D92.cs
================================================



================================================
File: ConfuserEx Static String Decryptor/obj/Debug/TemporaryGeneratedFile_5937a670-0e60-4077-877b-f7221da3dda1.cs
================================================



================================================
File: ConfuserEx Static String Decryptor/obj/Debug/TemporaryGeneratedFile_E7A71F73-0F8D-4B9B-B56E-8E70B10BC5D3.cs
================================================


